begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2006 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/ath/ah_desc.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/ath/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unaligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int16_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8)))
end_define

begin_define
define|#
directive|define
name|LE_READ_4
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int32_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8) |	\ 	  (((u_int8_t *)(p))[2]<< 16) | (((u_int8_t *)(p))[3]<< 24)))
end_define

begin_enum
enum|enum
block|{
name|ATH_LED_TX
block|,
name|ATH_LED_RX
block|,
name|ATH_LED_POLL
block|, }
enum|;
end_enum

begin_function_decl
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rxorn_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_key_alloc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|,
name|ieee80211_keyix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_key_delete
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_key_set
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_hal
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
parameter_list|,
name|ath_bufhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|ath_node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|u_int32_t
name|rstamp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_next_scan
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
name|cc
parameter_list|,
name|HAL_BOOL
name|outdoor
parameter_list|,
name|HAL_BOOL
name|xchanmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_led_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_update_txpow
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_phymode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_sysctlattach
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bpfattach
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_ath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX validate sysctl values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ath_dwelltime
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5 channels/second */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|dwell
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_dwelltime
argument_list|,
literal|0
argument_list|,
literal|"channel dwell time (ms) for AP/station scanning"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_calinterval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calibrate every 30 secs */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|calibrate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_calinterval
argument_list|,
literal|0
argument_list|,
literal|"chip calibration interval (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_outdoor
init|=
name|AH_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* outdoor operation */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|outdoor
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_outdoor
argument_list|,
literal|0
argument_list|,
literal|"outdoor operation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.outdoor"
argument_list|,
operator|&
name|ath_outdoor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_xchanmode
init|=
name|AH_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extended channel use */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|xchanmode
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_xchanmode
argument_list|,
literal|0
argument_list|,
literal|"extended channel mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.xchanmode"
argument_list|,
operator|&
name|ath_xchanmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_countrycode
init|=
name|CTRY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* country code */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|countrycode
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_countrycode
argument_list|,
literal|0
argument_list|,
literal|"country code"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.countrycode"
argument_list|,
operator|&
name|ath_countrycode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_regdomain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regulatory domain */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|regdomain
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_regdomain
argument_list|,
literal|0
argument_list|,
literal|"regulatory domain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_rxbuf
init|=
name|ATH_RXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # rx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|rxbuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_rxbuf
argument_list|,
literal|0
argument_list|,
literal|"rx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.rxbuf"
argument_list|,
operator|&
name|ath_rxbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_txbuf
init|=
name|ATH_TXBUF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # tx buffers to allocate */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|txbuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_txbuf
argument_list|,
literal|0
argument_list|,
literal|"tx buffers allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.txbuf"
argument_list|,
operator|&
name|ath_txbuf
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ath_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.ath.debug"
argument_list|,
operator|&
name|ath_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|ATH_DEBUG_XMIT
init|=
literal|0x00000001
block|,
comment|/* basic xmit operation */
name|ATH_DEBUG_XMIT_DESC
init|=
literal|0x00000002
block|,
comment|/* xmit descriptors */
name|ATH_DEBUG_RECV
init|=
literal|0x00000004
block|,
comment|/* basic recv operation */
name|ATH_DEBUG_RECV_DESC
init|=
literal|0x00000008
block|,
comment|/* recv descriptors */
name|ATH_DEBUG_RATE
init|=
literal|0x00000010
block|,
comment|/* rate control */
name|ATH_DEBUG_RESET
init|=
literal|0x00000020
block|,
comment|/* reset processing */
name|ATH_DEBUG_MODE
init|=
literal|0x00000040
block|,
comment|/* mode init/setup */
name|ATH_DEBUG_BEACON
init|=
literal|0x00000080
block|,
comment|/* beacon handling */
name|ATH_DEBUG_WATCHDOG
init|=
literal|0x00000100
block|,
comment|/* watchdog timeout */
name|ATH_DEBUG_INTR
init|=
literal|0x00001000
block|,
comment|/* ISR */
name|ATH_DEBUG_TX_PROC
init|=
literal|0x00002000
block|,
comment|/* tx ISR proc */
name|ATH_DEBUG_RX_PROC
init|=
literal|0x00004000
block|,
comment|/* rx ISR proc */
name|ATH_DEBUG_BEACON_PROC
init|=
literal|0x00008000
block|,
comment|/* beacon ISR proc */
name|ATH_DEBUG_CALIBRATE
init|=
literal|0x00010000
block|,
comment|/* periodic calibration */
name|ATH_DEBUG_KEYCACHE
init|=
literal|0x00020000
block|,
comment|/* key cache management */
name|ATH_DEBUG_STATE
init|=
literal|0x00040000
block|,
comment|/* 802.11 state transitions */
name|ATH_DEBUG_NODE
init|=
literal|0x00080000
block|,
comment|/* node management */
name|ATH_DEBUG_LED
init|=
literal|0x00100000
block|,
comment|/* led management */
name|ATH_DEBUG_FF
init|=
literal|0x00200000
block|,
comment|/* fast frames */
name|ATH_DEBUG_DFS
init|=
literal|0x00400000
block|,
comment|/* DFS processing */
name|ATH_DEBUG_FATAL
init|=
literal|0x80000000
block|,
comment|/* fatal errors */
name|ATH_DEBUG_ANY
init|=
literal|0xffffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IFF_DUMPPKTS
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
define|\
value|((sc->sc_debug& (m)) || \ 	    (sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (sc->sc_debug& (m))					\ 		printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEYPRINTF
parameter_list|(
name|sc
parameter_list|,
name|ix
parameter_list|,
name|hk
parameter_list|,
name|mac
parameter_list|)
value|do {				\ 	if (sc->sc_debug& ATH_DEBUG_KEYCACHE)			\ 		ath_keyprint(sc, __func__, ix, hk, mac);	\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|ath_printrxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_printtxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
name|done
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFF_DUMPPKTS
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
define|\
value|((sc->sc_ifp->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEYPRINTF
parameter_list|(
name|sc
parameter_list|,
name|k
parameter_list|,
name|ix
parameter_list|,
name|mac
parameter_list|)
value|do {				\ 	(void) sc;						\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ATHDEV
argument_list|,
literal|"athdev"
argument_list|,
literal|"ath driver dma buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ath_attach
parameter_list|(
name|u_int16_t
name|devid
parameter_list|,
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|NULL
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: devid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|devid
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* set these up early for if_printf use */
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ah
operator|=
name|ath_hal_attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to attach hardware; HAL status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ah
operator|->
name|ah_abi
operator|!=
name|HAL_ABI_VERSION
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"HAL ABI mismatch detected "
literal|"(HAL:0x%x != driver:0x%x)\n"
argument_list|,
name|ah
operator|->
name|ah_abi
argument_list|,
name|HAL_ABI_VERSION
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_ah
operator|=
name|ah
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable interrupt handling */
comment|/* 	 * Check if the MAC has multi-rate retry support. 	 * We do this by trying to setup a fake extended 	 * descriptor.  MAC's that don't have support will 	 * return false w/o doing anything.  MAC's that do 	 * support it will return true w/o doing anything. 	 */
name|sc
operator|->
name|sc_mrretry
operator|=
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device has hardware counters for PHY 	 * errors.  If so we need to enable the MIB interrupt 	 * so we can act on stat triggers. 	 */
if|if
condition|(
name|ath_hal_hwphycounters
argument_list|(
name|ah
argument_list|)
condition|)
name|sc
operator|->
name|sc_needmib
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get the hardware key cache size. 	 */
name|sc
operator|->
name|sc_keymax
operator|=
name|ath_hal_keycachesize
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_keymax
operator|>
name|ATH_KEYMAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Warning, using only %u of %u key cache slots\n"
argument_list|,
name|ATH_KEYMAX
argument_list|,
name|sc
operator|->
name|sc_keymax
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_keymax
operator|=
name|ATH_KEYMAX
expr_stmt|;
block|}
comment|/* 	 * Reset the key cache since some parts do not 	 * reset the contents on initial power up. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_keymax
condition|;
name|i
operator|++
control|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Collect the channel list using the default country 	 * code and including outdoor channels.  The 802.11 layer 	 * is resposible for filtering this list based on settings 	 * like the phy mode. 	 */
name|error
operator|=
name|ath_getchannels
argument_list|(
name|sc
argument_list|,
name|ath_countrycode
argument_list|,
name|ath_outdoor
argument_list|,
name|ath_xchanmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Setup rate tables for all potential media types. 	 */
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO_G
argument_list|)
expr_stmt|;
comment|/* NB: setup here so ath_rate_update is happy */
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate tx+rx descriptors and populate the lists. 	 */
name|error
operator|=
name|ath_desc_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to allocate descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|,
name|debug_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfs_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|ATH_TXBUF_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ath_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|sc_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|ath_rx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxorntask
argument_list|,
literal|0
argument_list|,
name|ath_rxorn_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|,
literal|0
argument_list|,
name|ath_bmiss_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|,
literal|0
argument_list|,
name|ath_bstuck_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate hardware transmit queues: one queue for 	 * beacon frames and one data queue for each QoS 	 * priority.  Note that the hal handles reseting 	 * these queues at the needed time. 	 * 	 * XXX PS-Poll 	 */
name|sc
operator|->
name|sc_bhalq
operator|=
name|ath_beaconq_setup
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bhalq
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup a beacon xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_cabq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_CAB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cabq
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup CAB xmit queue!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mcastq
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NB: s/w q, qnum not used */
comment|/* NB: insure BK queue is the lowest priority h/w queue */
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|,
name|HAL_WME_AC_BK
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup xmit queue for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BK
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|,
name|HAL_WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|,
name|HAL_WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_tx_setup
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|,
name|HAL_WME_AC_VO
argument_list|)
condition|)
block|{
comment|/*  		 * Not enough hardware tx queues to properly do WME; 		 * just punt and assign them all to the same h/w queue. 		 * We could do a better job of this if, for example, 		 * we allocate queues when we switch from station to 		 * AP mode. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|NULL
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VI
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_VO
index|]
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
expr_stmt|;
block|}
comment|/*  	 * Special case certain configurations.  Note the 	 * CAB queue is handled by these specially so don't 	 * include them when checking the txq setup mask. 	 */
switch|switch
condition|(
name|sc
operator|->
name|sc_txqsetup
operator|&
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
operator|)
condition|)
block|{
case|case
literal|0x01
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc_q0123
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Setup rate control.  Some rate control modules 	 * call back to change the anntena state so expose 	 * the necessary entry points. 	 * XXX maybe belongs in struct ath_ratectrl? 	 */
name|sc
operator|->
name|sc_setdefantenna
operator|=
name|ath_setdefantenna
expr_stmt|;
name|sc
operator|->
name|sc_rc
operator|=
name|ath_rate_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ledstate
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledon
operator|=
literal|0
expr_stmt|;
comment|/* low true */
name|sc
operator|->
name|sc_ledidle
operator|=
operator|(
literal|2700
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* 2.7sec */
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|/* 	 * Auto-enable soft led processing for IBM cards and for 	 * 5211 minipci cards.  Users can also manually enable/disable 	 * support with a sysctl. 	 */
name|sc
operator|->
name|sc_softled
operator|=
operator|(
name|devid
operator|==
name|AR5212_DEVID_IBM
operator|||
name|devid
operator|==
name|AR5211_DEVID
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ath_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ath_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ath_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ath_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
name|ic
operator|->
name|ic_reset
operator|=
name|ath_reset
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|ath_newassoc
expr_stmt|;
name|ic
operator|->
name|ic_updateslot
operator|=
name|ath_updateslot
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
operator|=
name|ath_wme_update
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_IBSS
comment|/* ibss, nee adhoc, mode */
operator||
name|IEEE80211_C_HOSTAP
comment|/* hostap mode */
operator||
name|IEEE80211_C_MONITOR
comment|/* monitor mode */
operator||
name|IEEE80211_C_AHDEMO
comment|/* adhoc demo mode */
operator||
name|IEEE80211_C_SHPREAMBLE
comment|/* short preamble supported */
operator||
name|IEEE80211_C_SHSLOT
comment|/* short slot time supported */
operator||
name|IEEE80211_C_WPA
comment|/* capable of WPA1+WPA2 */
expr_stmt|;
comment|/* 	 * Query the hal to figure out h/w crypto support. 	 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_WEP
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_WEP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_OCB
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_AES
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_AES_CCM
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_AES_CCM
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CKIP
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_CKIP
expr_stmt|;
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_TKIP
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TKIP
expr_stmt|;
comment|/* 		 * Check if h/w does the MIC and/or whether the 		 * separate key cache entries are required to 		 * handle both tx+rx MIC keys. 		 */
if|if
condition|(
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_MIC
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TKIPMIC
expr_stmt|;
comment|/* 		 * If the h/w supports storing tx+rx MIC keys 		 * in one cache slot automatically enable use. 		 */
if|if
condition|(
name|ath_hal_hastkipsplit
argument_list|(
name|ah
argument_list|)
operator|||
operator|!
name|ath_hal_settkipsplit
argument_list|(
name|ah
argument_list|,
name|AH_FALSE
argument_list|)
condition|)
name|sc
operator|->
name|sc_splitmic
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_hasclrkey
operator|=
name|ath_hal_ciphersupported
argument_list|(
name|ah
argument_list|,
name|HAL_CIPHER_CLR
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mcastkey
operator|=
name|ath_hal_getmcastkeysearch
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Mark key cache slots associated with global keys 	 * as in use.  If we knew TKIP was not to be used we 	 * could leave the +32, +64, and +32+64 slots free. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|i
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * TPC support can be done either with a global cap or 	 * per-packet support.  The latter is not available on 	 * all parts.  We're a bit pedantic here as all parts 	 * support a global cap. 	 */
if|if
condition|(
name|ath_hal_hastpc
argument_list|(
name|ah
argument_list|)
operator|||
name|ath_hal_hastxpowlimit
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_TXPMGT
expr_stmt|;
comment|/* 	 * Mark WME capability only if we have sufficient 	 * hardware queues to do proper priority scheduling. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BE
index|]
operator|!=
name|sc
operator|->
name|sc_ac2q
index|[
name|WME_AC_BK
index|]
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_WME
expr_stmt|;
comment|/* 	 * Check for misc other capabilities. 	 */
if|if
condition|(
name|ath_hal_hasbursting
argument_list|(
name|ah
argument_list|)
condition|)
name|ic
operator|->
name|ic_caps
operator||=
name|IEEE80211_C_BURST
expr_stmt|;
comment|/* 	 * Indicate we need the 802.11 header padded to a 	 * 32-bit boundary for 4-address and QoS frames. 	 */
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_DATAPAD
expr_stmt|;
comment|/* 	 * Query the hal about antenna support. 	 */
name|sc
operator|->
name|sc_defant
operator|=
name|ath_hal_getdefantenna
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Not all chips have the VEOL support we want to 	 * use with IBSS beacons; check here for it. 	 */
name|sc
operator|->
name|sc_hasveol
operator|=
name|ath_hal_hasveol
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* get mac address from hardware */
name|ath_hal_getmac
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_node_alloc
operator|=
name|ath_node_alloc
expr_stmt|;
name|sc
operator|->
name|sc_node_free
operator|=
name|ic
operator|->
name|ic_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|ath_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_getrssi
operator|=
name|ath_node_getrssi
expr_stmt|;
name|sc
operator|->
name|sc_recv_mgmt
operator|=
name|ic
operator|->
name|ic_recv_mgmt
expr_stmt|;
name|ic
operator|->
name|ic_recv_mgmt
operator|=
name|ath_recv_mgmt
expr_stmt|;
name|sc
operator|->
name|sc_newstate
operator|=
name|ic
operator|->
name|ic_newstate
expr_stmt|;
name|ic
operator|->
name|ic_newstate
operator|=
name|ath_newstate
expr_stmt|;
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_max_keyix
operator|=
name|sc
operator|->
name|sc_keymax
expr_stmt|;
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_key_alloc
operator|=
name|ath_key_alloc
expr_stmt|;
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_key_delete
operator|=
name|ath_key_delete
expr_stmt|;
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_key_set
operator|=
name|ath_key_set
expr_stmt|;
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_key_update_begin
operator|=
name|ath_key_update_begin
expr_stmt|;
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_key_update_end
operator|=
name|ath_key_update_end
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|ath_raw_xmit
expr_stmt|;
comment|/* complete initialization */
name|ieee80211_media_init
argument_list|(
name|ic
argument_list|,
name|ath_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|ath_bpfattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Setup dynamic sysctl's now that country code and 	 * regdomain are available from the hal. 	 */
name|ath_sysctlattach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ieee80211_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ath_announce
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|ah
condition|)
name|ath_hal_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ath_detach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/*  	 * NB: the order of these is important: 	 * o call the 802.11 layer before detaching the hal to 	 *   insure callbacks into the driver to delete global 	 *   key cache entries can be handled 	 * o reclaim the tx queue data structures after calling 	 *   the 802.11 layer as we'll get called back to reclaim 	 *   node state and potentially want to use them 	 * o to cleanup the tx queues the hal is called, so detach 	 *   it last 	 * Other than that, it's straightforward... 	 */
name|ieee80211_ifdetach
argument_list|(
operator|&
name|sc
operator|->
name|sc_ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|detach
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|)
expr_stmt|;
name|ath_rate_detach
argument_list|(
name|sc
operator|->
name|sc_rc
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_detach
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ath_suspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|ath_hal_gpioCfgOutput
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ath_shutdown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags %x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handler.  Most of the actual processing is deferred.  */
end_comment

begin_function
name|void
name|ath_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_INT
name|status
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid; ignored\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|ath_hal_intrpend
argument_list|(
name|ah
argument_list|)
condition|)
comment|/* shared irq, not for us */
return|return;
if|if
condition|(
operator|!
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
return|return;
block|}
comment|/* 	 * Figure out the reason(s) for the interrupt.  Note 	 * that the hal returns a pseudo-ISR that may include 	 * bits we haven't explicitly enabled so we mask the 	 * value to insure we only process bits we requested. 	 */
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_INTR
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|&=
name|sc
operator|->
name|sc_imask
expr_stmt|;
comment|/* discard unasked for bits */
if|if
condition|(
name|status
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_hardware
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|ath_fatal_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXORN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxorn
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxorntask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|HAL_INT_SWBA
condition|)
block|{
comment|/* 			 * Software beacon alert--time to send a beacon. 			 * Handle beacon transmission directly; deferring 			 * this is too slow to meet timing constraints 			 * under load. 			 */
name|ath_beacon_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXEOL
condition|)
block|{
comment|/* 			 * NB: the hardware should re-read the link when 			 *     RXE bit is written, but it doesn't work at 			 *     least on older hardware revs. 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxeol
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TXURN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_txurn
operator|++
expr_stmt|;
comment|/* bump tx trigger level */
name|ath_hal_updatetxtriglevel
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RX
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_TX
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_BMISS
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_MIB
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_mib
operator|++
expr_stmt|;
comment|/* 			 * Disable interrupts until we service the MIB 			 * interrupt; otherwise it will continue to fire. 			 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Let the hal handle the event.  We assume it will 			 * clear whatever condition caused the interrupt. 			 */
name|ath_hal_mibevent
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
modifier|*
name|state
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"hardware error; resetting\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Fatal errors are unrecoverable.  Typically these 	 * are caused by DMA errors.  Collect h/w state from 	 * the hal so we can diagnose what's going on. 	 */
if|if
condition|(
name|ath_hal_getfatalstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|len
operator|>=
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
literal|"len %u bytes"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"0x%08x 0x%08x 0x%08x, 0x%08x 0x%08x 0x%08x\n"
argument_list|,
name|state
index|[
literal|0
index|]
argument_list|,
name|state
index|[
literal|1
index|]
argument_list|,
name|state
index|[
literal|2
index|]
argument_list|,
name|state
index|[
literal|3
index|]
argument_list|,
name|state
index|[
literal|4
index|]
argument_list|,
name|state
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rxorn_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"rx FIFO overrun; resetting\n"
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"unexpect operating mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|u_int64_t
name|lastrx
init|=
name|sc
operator|->
name|sc_lastrx
decl_stmt|;
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|u_int
name|bmisstimeout
init|=
name|ic
operator|->
name|ic_bmissthreshold
operator|*
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
operator|*
literal|1024
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %llu lastrx %lld (%llu) bmiss %u\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf
argument_list|,
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|tsf
operator|-
name|lastrx
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|lastrx
argument_list|,
name|bmisstimeout
argument_list|)
expr_stmt|;
comment|/* 		 * Workaround phantom bmiss interrupts by sanity-checking 		 * the time of our last rx'd frame.  If it is within the 		 * beacon miss interval then ignore the interrupt.  If it's 		 * truly a bmiss we'll get another interrupt soon and that'll 		 * be dispatched up for processing. 		 */
if|if
condition|(
name|tsf
operator|-
name|lastrx
operator|>
name|bmisstimeout
condition|)
block|{
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss_phantom
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|ath_chan2flags
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
specifier|static
specifier|const
name|u_int
name|modeflags
index|[]
init|=
block|{
literal|0
block|,
comment|/* IEEE80211_MODE_AUTO */
name|CHANNEL_A
block|,
comment|/* IEEE80211_MODE_11A */
name|CHANNEL_B
block|,
comment|/* IEEE80211_MODE_11B */
name|CHANNEL_PUREG
block|,
comment|/* IEEE80211_MODE_11G */
literal|0
block|,
comment|/* IEEE80211_MODE_FH */
name|CHANNEL_ST
block|,
comment|/* IEEE80211_MODE_TURBO_A */
name|CHANNEL_108G
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
init|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|mode
operator|<
name|N
argument_list|(
name|modeflags
argument_list|)
argument_list|,
operator|(
literal|"unexpected phy mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|modeflags
index|[
name|mode
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"mode %u undefined"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
return|return
name|modeflags
index|[
name|mode
index|]
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe 	 * whether this is the first time through or not. 	 */
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * The basic interface to setting the hardware in a good 	 * state is ``reset''.  On return the hardware is known to 	 * be powered up and with interrupts disabled.  This must 	 * be followed by initialization of the appropriate bits 	 * and then setup of the interrupt mask. 	 */
name|sc
operator|->
name|sc_curchan
operator|.
name|channel
operator|=
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
expr_stmt|;
name|sc
operator|->
name|sc_curchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|,
name|AH_FALSE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to reset hardware; hal status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * This is needed only to setup initial state 	 * but it's best done after a reset. 	 */
name|ath_update_txpow
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Likewise this is set during reset so update 	 * state cached in the driver. 	 */
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_calinterval
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_caltries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Setup the hardware after reset: the key cache 	 * is filled as needed and the receive engine is 	 * set going.  Frame transmit is handled entirely 	 * in the frame output path; there's nothing to do 	 * here except setup the interrupt mask. 	 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to start recv logic\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|sc_imask
operator|=
name|HAL_INT_RX
operator||
name|HAL_INT_TX
operator||
name|HAL_INT_RXEOL
operator||
name|HAL_INT_RXORN
operator||
name|HAL_INT_FATAL
operator||
name|HAL_INT_GLOBAL
expr_stmt|;
comment|/* 	 * Enable MIB interrupts when there are hardware phy counters. 	 * Note we only do this (at the moment) for station mode. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_needmib
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_MIB
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ic
operator|->
name|ic_state
operator|=
name|IEEE80211_S_INIT
expr_stmt|;
comment|/* 	 * The hardware should be ready to go now so it's safe 	 * to kick the 802.11 state machine as it's likely to 	 * immediately call back to us to send mgmt frames. 	 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|start
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_MONITOR
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_roaming
operator|!=
name|IEEE80211_ROAMING_MANUAL
condition|)
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|done
label|:
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid %u if_flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_invalid
argument_list|,
name|ifp
operator|->
name|if_flags
argument_list|)
expr_stmt|;
name|ATH_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* 		 * Shutdown the hardware and driver: 		 *    reset 802.11 state machine 		 *    turn off timers 		 *    disable interrupts 		 *    turn off the radio 		 *    clear transmit machinery 		 *    clear receive machinery 		 *    drain and release tx queues 		 *    reclaim beacon resources 		 *    power down hardware 		 * 		 * Note that some of this work is not possible if the 		 * hardware is gone (invalid). 		 */
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
if|if
condition|(
name|sc
operator|->
name|sc_tx99
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_tx99
operator|->
name|stop
argument_list|(
name|sc
operator|->
name|sc_tx99
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_phydisable
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|IFQ_DRV_PURGE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ath_beacon_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * Set the chip in full sleep mode.  Note that we are 		 * careful to do this only when bringing the interface 		 * completely to a stop.  When the chip is in this state 		 * it must be carefully woken up or references to 		 * registers in the PCI clock domain may freeze the bus 		 * (and system).  This varies by chip and is mostly an 		 * issue with newer parts that go to sleep more quickly. 		 */
name|ath_hal_setpower
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|)
expr_stmt|;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware w/o losing operational state.  This is  * basically a more efficient way of doing ath_stop, ath_init,  * followed by state transitions to the current 802.11  * operational state.  Used to recover from various errors and  * to reset or reload hardware state.  */
end_comment

begin_function
specifier|static
name|int
name|ath_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 	 * Convert to a HAL channel description with the flags 	 * constrained to reflect the current operating mode. 	 */
name|c
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|sc
operator|->
name|sc_curchan
operator|.
name|channel
operator|=
name|c
operator|->
name|ic_freq
expr_stmt|;
name|sc
operator|->
name|sc_curchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop xmit side */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop recv side */
comment|/* NB: indicate channel change so we do a full reset */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset hardware; hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ath_update_txpow
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* update tx power state */
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_calinterval
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_caltries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We may be doing a reset in response to an ioctl 	 * that changes the channel so update any state that 	 * might change as a result. 	 */
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* restart recv */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to start recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|ath_beacon_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* restart beacons */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* restart xmit */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Grab a TX buffer and associated resources. 		 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: out of xmit buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Poll the management queue for frames; they 		 * have priority over normal data frames. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No data frames go out unless we're associated. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: discard data packet, state %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ic
operator|->
name|ic_state
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_discard
operator|++
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX: LOCK */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  			 * Find the node for the destination so we can do 			 * things like power save and fast frames aggregation. 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
comment|/* XXX */
name|ni
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_txnode
argument_list|(
name|ic
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_find_txnode does stat+msg */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PWR_SAV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Station in power save mode; pass the frame 				 * to the 802.11 layer and continue.  We'll get 				 * the frame back when the time is right. 				 */
name|ieee80211_pwrsave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
comment|/* calculate priority so we can find the tx queue */
if|if
condition|(
name|ieee80211_classify
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: discard, classification failure\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * Encapsulate the packet in prep for transmission. 			 */
name|m
operator|=
name|ieee80211_encap
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: encapsulation failure\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_encap
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * Hack!  The referenced node pointer is in the 			 * rcvif field of the packet header.  This is 			 * placed there by ieee80211_mgmt_output because 			 * we need to hold the reference with the frame 			 * and there's no other way (other than packet 			 * tags which we consider too expensive to use) 			 * to pass it along. 			 */
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
block|{
comment|/* fill time stamp */
name|u_int64_t
name|tsf
decl_stmt|;
name|u_int32_t
modifier|*
name|tstamp
decl_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* XXX: adjust 100us delay to xmit */
name|tsf
operator|+=
literal|100
expr_stmt|;
name|tstamp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
expr_stmt|;
name|tstamp
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
name|tsf
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|tstamp
index|[
literal|1
index|]
operator|=
name|htole32
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_mgmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|reclaim
label|:
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
define|#
directive|define
name|IS_UP
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/*  			 * Adhoc demo mode is just ibss mode w/o beacons 			 * (mostly).  The hal knows nothing about it; 			 * tell it we're operating in ibss mode. 			 */
name|sc
operator|->
name|sc_opmode
operator|=
name|HAL_M_IBSS
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_opmode
operator|=
name|ic
operator|->
name|ic_opmode
expr_stmt|;
if|if
condition|(
name|IS_UP
argument_list|(
name|ifp
argument_list|)
condition|)
name|ath_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|IS_UP
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ath_keyprint
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|u_int
name|ix
parameter_list|,
specifier|const
name|HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|ciphers
index|[]
init|=
block|{
literal|"WEP"
block|,
literal|"AES-OCB"
block|,
literal|"AES-CCM"
block|,
literal|"CKIP"
block|,
literal|"TKIP"
block|,
literal|"CLR"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|printf
argument_list|(
literal|"%s: [%02u] %-7s "
argument_list|,
name|tag
argument_list|,
name|ix
argument_list|,
name|ciphers
index|[
name|hk
operator|->
name|kv_type
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
name|hk
operator|->
name|kv_len
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" mac %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|mac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hk
operator|->
name|kv_type
operator|==
name|HAL_CIPHER_TKIP
condition|)
block|{
name|printf
argument_list|(
literal|" %s "
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
literal|"mic"
else|:
literal|"rxmic"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_mic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAL_ABI_VERSION
operator|>
literal|0x06052200
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
name|printf
argument_list|(
literal|" txmic "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|hk
operator|->
name|kv_txmic
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set a TKIP key into the hardware.  This handles the  * potential distribution of key state to multiple key  * cache slots for TKIP.  */
end_comment

begin_function
specifier|static
name|int
name|ath_keyset_tkip
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|HAL_KEYVAL
modifier|*
name|hk
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_KEY_XR
value|(IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV)
specifier|static
specifier|const
name|u_int8_t
name|zerobssid
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|KASSERT
argument_list|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
argument_list|,
operator|(
literal|"got a non-TKIP key, cipher %u"
operator|,
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XR
operator|)
operator|==
name|IEEE80211_KEY_XR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* 			 * TX key goes at first index, RX key at the rx index. 			 * The hal handles the MIC keys at index+64. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|zerobssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|zerobssid
argument_list|)
condition|)
return|return
literal|0
return|;
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
operator|+
literal|32
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
comment|/* XXX delete tx key on failure? */
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
operator|+
literal|32
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
else|else
block|{
comment|/* 			 * Room for both TX+RX MIC keys in one key cache 			 * slot, just set key at the first index; the hal 			 * will handle the reset. 			 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAL_ABI_VERSION
operator|>
literal|0x06052200
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_txmic
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XR
condition|)
block|{
comment|/* 		 * TX/RX key goes at first index. 		 * The hal handles the MIC keys are index+64. 		 */
name|memcpy
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|,
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_XMIT
condition|?
name|k
operator|->
name|wk_txmic
else|:
name|k
operator|->
name|wk_rxmic
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
operator|->
name|kv_mic
argument_list|)
argument_list|)
expr_stmt|;
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|IEEE80211_KEY_XR
block|}
end_function

begin_comment
comment|/*  * Set a net80211 key into the hardware.  This handles the  * potential distribution of key state to multiple key  * cache slots for TKIP with hardware MIC support.  */
end_comment

begin_function
specifier|static
name|int
name|ath_keyset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
specifier|const
name|u_int8_t
name|mac0
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|bss
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
specifier|static
specifier|const
name|u_int8_t
name|ciphermap
index|[]
init|=
block|{
name|HAL_CIPHER_WEP
block|,
comment|/* IEEE80211_CIPHER_WEP */
name|HAL_CIPHER_TKIP
block|,
comment|/* IEEE80211_CIPHER_TKIP */
name|HAL_CIPHER_AES_OCB
block|,
comment|/* IEEE80211_CIPHER_AES_OCB */
name|HAL_CIPHER_AES_CCM
block|,
comment|/* IEEE80211_CIPHER_AES_CCM */
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
block|,
comment|/* 4 is not allocated */
name|HAL_CIPHER_CKIP
block|,
comment|/* IEEE80211_CIPHER_CKIP */
name|HAL_CIPHER_CLR
block|,
comment|/* IEEE80211_CIPHER_NONE */
block|}
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|u_int8_t
name|gmac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|mac
decl_stmt|;
name|HAL_KEYVAL
name|hk
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Software crypto uses a "clear key" so non-crypto 	 * state kept in the key cache are maintained and 	 * so that rx frames have an entry to match. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|cip
operator|->
name|ic_cipher
operator|<
name|N
argument_list|(
name|ciphermap
argument_list|)
argument_list|,
operator|(
literal|"invalid cipher type %u"
operator|,
name|cip
operator|->
name|ic_cipher
operator|)
argument_list|)
expr_stmt|;
name|hk
operator|.
name|kv_type
operator|=
name|ciphermap
index|[
name|cip
operator|->
name|ic_cipher
index|]
expr_stmt|;
name|hk
operator|.
name|kv_len
operator|=
name|k
operator|->
name|wk_keylen
expr_stmt|;
name|memcpy
argument_list|(
name|hk
operator|.
name|kv_val
argument_list|,
name|k
operator|->
name|wk_key
argument_list|,
name|k
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
block|}
else|else
name|hk
operator|.
name|kv_type
operator|=
name|HAL_CIPHER_CLR
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|&&
name|sc
operator|->
name|sc_mcastkey
condition|)
block|{
comment|/* 		 * Group keys on hardware that supports multicast frame 		 * key search use a mac that is the sender's address with 		 * the high bit set instead of the app-specified address. 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|gmac
argument_list|,
name|bss
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|gmac
index|[
literal|0
index|]
operator||=
literal|0x80
expr_stmt|;
name|mac
operator|=
name|gmac
expr_stmt|;
block|}
else|else
name|mac
operator|=
name|mac0
expr_stmt|;
if|if
condition|(
name|hk
operator|.
name|kv_type
operator|==
name|HAL_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|ath_keyset_tkip
argument_list|(
name|sc
argument_list|,
name|k
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
else|else
block|{
name|KEYPRINTF
argument_list|(
name|sc
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
expr_stmt|;
return|return
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
operator|&
name|hk
argument_list|,
name|mac
argument_list|)
return|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate tx/rx key slots for TKIP.  We allocate two slots for  * each key, one for decrypt/encrypt and the other for the MIC.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_alloc_2pair
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_splitmic
argument_list|,
operator|(
literal|"key cache !split"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX could optimize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots in this byte are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|again
label|:
name|keyix
operator|++
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* XXX IEEE80211_KEY_XMIT | IEEE80211_KEY_RECV */
if|if
condition|(
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
operator|||
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
condition|)
block|{
comment|/* full pair unavailable */
comment|/* XXX statistic */
if|if
condition|(
name|keyix
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* no slots were appropriate, advance */
continue|continue;
block|}
goto|goto
name|again
goto|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key pair %u,%u %u,%u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|,
name|keyix
operator|+
literal|64
argument_list|,
name|keyix
operator|+
literal|32
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
name|keyix
expr_stmt|;
operator|*
name|rxkeyix
operator|=
name|keyix
operator|+
literal|32
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of pair space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate tx/rx key slots for TKIP.  We allocate two slots for  * each key, one for decrypt/encrypt and the other for the MIC.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_alloc_pair
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|sc
operator|->
name|sc_splitmic
argument_list|,
operator|(
literal|"key cache split"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX could optimize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots in this byte are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
block|{
name|again
label|:
name|keyix
operator|++
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
condition|)
block|{
comment|/* full pair unavailable */
comment|/* XXX statistic */
if|if
condition|(
name|keyix
operator|==
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|NBBY
condition|)
block|{
comment|/* no slots were appropriate, advance */
continue|continue;
block|}
goto|goto
name|again
goto|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key pair %u,%u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
name|keyix
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of pair space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate a single key cache slot.  */
end_comment

begin_function
specifier|static
name|int
name|key_alloc_single
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ieee80211_keyix
modifier|*
name|txkeyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|u_int
name|i
decl_stmt|,
name|keyix
decl_stmt|;
comment|/* XXX try i,i+32,i+64,i+32+64 to minimize key pair conflicts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|b
init|=
name|sc
operator|->
name|sc_keymap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|b
operator|!=
literal|0xff
condition|)
block|{
comment|/* 			 * One or more slots are free. 			 */
name|keyix
operator|=
name|i
operator|*
name|NBBY
expr_stmt|;
while|while
condition|(
name|b
operator|&
literal|1
condition|)
name|keyix
operator|++
operator|,
name|b
operator|>>=
literal|1
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: key %u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
operator|*
name|txkeyix
operator|=
operator|*
name|rxkeyix
operator|=
name|keyix
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: out of space\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Allocate one or more key cache slots for a uniacst key.  The  * key itself is needed only to identify the cipher.  For hardware  * TKIP with split cipher+MIC keys we allocate two key cache slot  * pairs so that we can setup separate TX and RX MIC keys.  Note  * that the MIC key for a TKIP key at slot i is assumed by the  * hardware to be at slot i+64.  This limits TKIP keys to the first  * 64 entries.  */
end_comment

begin_function
specifier|static
name|int
name|ath_key_alloc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|ieee80211_keyix
modifier|*
name|keyix
parameter_list|,
name|ieee80211_keyix
modifier|*
name|rxkeyix
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 	 * Group key allocation must be handled specially for 	 * parts that do not support multicast key cache search 	 * functionality.  For those parts the key id must match 	 * the h/w key index so lookups find the right key.  On 	 * parts w/ the key search facility we install the sender's 	 * mac address (with the high bit set) and let the hardware 	 * find the key w/o using the key id.  This is preferred as 	 * it permits us to support multiple users for adhoc and/or 	 * multi-station operation. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_GROUP
operator|)
operator|&&
operator|!
name|sc
operator|->
name|sc_mcastkey
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
literal|0
index|]
operator|<=
name|k
operator|&&
name|k
operator|<
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|IEEE80211_WEP_NKID
index|]
operator|)
condition|)
block|{
comment|/* should not happen */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: bogus group key\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * XXX we pre-allocate the global keys so 		 * have no way to check if they've already been allocated. 		 */
operator|*
name|keyix
operator|=
operator|*
name|rxkeyix
operator|=
name|k
operator|-
name|ic
operator|->
name|ic_nw_keys
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * We allocate two pair for TKIP when using the h/w to do 	 * the MIC.  For everything else, including software crypto, 	 * we allocate a single entry.  Note that s/w crypto requires 	 * a pass-through slot on the 5211 and 5212.  The 5210 does 	 * not support pass-through cache entries and we map all 	 * those requests to slot 0. 	 */
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
condition|)
block|{
return|return
name|key_alloc_single
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
return|return
name|key_alloc_2pair
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
else|else
return|return
name|key_alloc_pair
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|key_alloc_single
argument_list|(
name|sc
argument_list|,
name|keyix
argument_list|,
name|rxkeyix
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete an entry in the key cache allocated by ath_key_alloc.  */
end_comment

begin_function
specifier|static
name|int
name|ath_key_delete
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
init|=
name|k
operator|->
name|wk_cipher
decl_stmt|;
name|u_int
name|keyix
init|=
name|k
operator|->
name|wk_keyix
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s: delete key %u\n"
argument_list|,
name|__func__
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
comment|/* 	 * Handle split tx/rx keying required for TKIP with h/w MIC. 	 */
if|if
condition|(
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_splitmic
condition|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/* RX key */
if|if
condition|(
name|keyix
operator|>=
name|IEEE80211_WEP_NKID
condition|)
block|{
comment|/* 		 * Don't touch keymap entries for global keys so 		 * they are never considered for dynamic allocation. 		 */
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|cip
operator|->
name|ic_cipher
operator|==
name|IEEE80211_CIPHER_TKIP
operator|&&
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
block|{
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* TX key MIC */
if|if
condition|(
name|sc
operator|->
name|sc_splitmic
condition|)
block|{
comment|/* +32 for RX key, +32+64 for RX key MIC */
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_keymap
argument_list|,
name|keyix
operator|+
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Set the key cache contents for the specified key.  Key cache  * slot(s) must already have been allocated by ath_key_alloc.  */
end_comment

begin_function
specifier|static
name|int
name|ath_key_set
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
name|ath_keyset
argument_list|(
name|sc
argument_list|,
name|k
argument_list|,
name|mac
argument_list|,
name|ic
operator|->
name|ic_bss
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block/unblock tx+rx processing while a key change is done.  * We assume the caller serializes key management operations  * so we only need to worry about synchronization with other  * uses that originate in the driver.  */
end_comment

begin_function
specifier|static
name|void
name|ath_key_update_begin
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|tasklet_disable(&sc->sc_rxtq);
endif|#
directive|endif
name|IF_LOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* NB: doesn't block mgmt frames */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_key_update_end
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_KEYCACHE
argument_list|,
literal|"%s:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|tasklet_enable(&sc->sc_rxtq);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Calculate the receive filter according to the  * operating mode and state:  *  * o always accept unicast, broadcast, and multicast traffic  * o maintain current state of phy error reception (the hal  *   may enable phy error frames for noise immunity work)  * o probe request frames are accepted only when operating in  *   hostap, adhoc, or monitor modes  * o enable promiscuous mode according to the interface state  * o accept beacons:  *   - when operating in adhoc mode so the 802.11 layer creates  *     node table entries for peers,  *   - when operating in station mode for collecting rssi data when  *     the station is otherwise quiet, or  *   - when scanning  * o accept control frames:  *   - when in monitor mode  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|ath_calcrxfilter
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_state
name|state
parameter_list|)
block|{
define|#
directive|define
name|RX_FILTER_PRESERVE
value|(HAL_RX_FILTER_PHYERR | HAL_RX_FILTER_PHYRADAR)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|rfilt
operator|=
operator|(
name|ath_hal_getrxfilter
argument_list|(
name|ah
argument_list|)
operator|&
name|RX_FILTER_PRESERVE
operator|)
operator||
name|HAL_RX_FILTER_UCAST
operator||
name|HAL_RX_FILTER_BCAST
operator||
name|HAL_RX_FILTER_MCAST
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROBEREQ
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|state
operator|==
name|IEEE80211_S_SCAN
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_CONTROL
expr_stmt|;
return|return
name|rfilt
return|;
undef|#
directive|undef
name|RX_FILTER_PRESERVE
block|}
end_function

begin_function
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|,
name|mfilt
index|[
literal|2
index|]
decl_stmt|,
name|val
decl_stmt|;
name|u_int8_t
name|pos
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* configure rx filter */
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_state
argument_list|)
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* configure operational mode */
name|ath_hal_setopmode
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Handle any link-level address change.  Note that we only 	 * need to force ic_myaddr; any other addresses are handled 	 * as a byproduct of the ifnet code marking the interface 	 * down then up. 	 * 	 * XXX should get from lladdr instead of arpcom but that's more work 	 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_setmac
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
comment|/* calculate and install multicast filter */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|==
literal|0
condition|)
block|{
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
name|caddr_t
name|dl
decl_stmt|;
comment|/* calculate XOR of eight 6bit values */
name|dl
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|^=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|pos
operator|&=
literal|0x3f
expr_stmt|;
name|mfilt
index|[
name|pos
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pos
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|ath_hal_setmcastfilter
argument_list|(
name|ah
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x, MC filter %08x:%08x\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setslottime
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|ath_hal_setslottime
argument_list|(
name|ah
argument_list|,
name|HAL_SLOT_TIME_9
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setslottime
argument_list|(
name|ah
argument_list|,
name|HAL_SLOT_TIME_20
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_updateslot
operator|=
name|OK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update the  * slot time based on the current setting.  */
end_comment

begin_function
specifier|static
name|void
name|ath_updateslot
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
comment|/* 	 * When not coordinating the BSS, change the hardware 	 * immediately.  For other operation we defer the change 	 * until beacon updates have propagated to the stations. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|sc
operator|->
name|sc_updateslot
operator|=
name|UPDATE
expr_stmt|;
else|else
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue for beacons.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beaconq_setup
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|)
block|{
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* NB: for dynamic turbo, don't enable any other interrupts */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
return|return
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|HAL_TX_QUEUE_BEACON
argument_list|,
operator|&
name|qi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the transmit queue parameters for the beacon queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beaconq_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<(v))-1)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* 		 * Always burst out beacon and CAB traffic. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|ATH_BEACON_AIFS_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_BEACON_CWMIN_DEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_BEACON_CWMAX_DEFAULT
expr_stmt|;
block|}
else|else
block|{
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
decl_stmt|;
comment|/* 		 * Adhoc mode; important thing is to use 2x cwmin. 		 */
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
literal|2
operator|*
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update parameters for "
literal|"beacon hardware queue!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Allocate and setup an initial beacon frame.  */
end_comment

begin_function
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: no dma buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_nombuf
operator|++
expr_stmt|;
comment|/* XXX */
return|return
name|ENOMEM
return|;
comment|/* XXX */
block|}
comment|/* 	 * NB: the beacon data buffer must be 32-bit aligned; 	 * we assume the mbuf routines will return us something 	 * with this alignment (perhaps should assert). 	 */
name|m
operator|=
name|ieee80211_beacon_alloc
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
operator|&
name|sc
operator|->
name|sc_boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: cannot get mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the beacon frame for transmit.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
define|#
directive|define
name|USE_SHPREAMBLE
parameter_list|(
name|_ic
parameter_list|)
define|\
value|(((_ic)->ic_flags& (IEEE80211_F_SHPREAMBLE | IEEE80211_F_USEBARKER))\ 		== IEEE80211_F_SHPREAMBLE)
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|antenna
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|rate
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_NOACK
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
block|{
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* self-linked */
name|flags
operator||=
name|HAL_TXDESC_VEOL
expr_stmt|;
comment|/* 		 * Let hardware handle antenna switching. 		 */
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Switch antenna every 4 beacons. 		 * XXX assumes two antenna 		 */
name|antenna
operator|=
name|sc
operator|->
name|sc_txantenna
operator|!=
literal|0
condition|?
name|sc
operator|->
name|sc_txantenna
else|:
operator|(
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|&
literal|4
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment beacon frame; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* 	 * Calculate rate code. 	 * XXX everything at min xmit rate 	 */
name|rix
operator|=
name|sc
operator|->
name|sc_minrateix
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|rate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|USE_SHPREAMBLE
argument_list|(
name|ic
argument_list|)
condition|)
name|rate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
operator|+
name|IEEE80211_CRC_LEN
comment|/* frame length */
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
comment|/* header length */
argument_list|,
name|HAL_PKT_TYPE_BEACON
comment|/* Atheros packet type */
argument_list|,
name|ni
operator|->
name|ni_txpower
comment|/* txpower XXX */
argument_list|,
name|rate
argument_list|,
literal|1
comment|/* series 0 rate/tries */
argument_list|,
name|HAL_TXKEYIX_INVALID
comment|/* no encryption */
argument_list|,
name|antenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* no ack, veol for beacons */
argument_list|,
literal|0
comment|/* rts/cts rate */
argument_list|,
literal|0
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* NB: beacon's BufLen must be a multiple of 4 bytes */
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|roundup
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
literal|4
argument_list|)
comment|/* buffer length */
argument_list|,
name|AH_TRUE
comment|/* first segment */
argument_list|,
name|AH_TRUE
comment|/* last segment */
argument_list|,
name|ds
comment|/* first descriptor */
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|USE_SHPREAMBLE
block|}
end_function

begin_comment
comment|/*  * Append the contents of src to dst; both queues  * are assumed to be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_txqmove
parameter_list|(
name|struct
name|ath_txq
modifier|*
name|dst
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|src
parameter_list|)
block|{
name|STAILQ_CONCAT
argument_list|(
operator|&
name|dst
operator|->
name|axq_q
argument_list|,
operator|&
name|src
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|dst
operator|->
name|axq_link
operator|=
name|src
operator|->
name|axq_link
expr_stmt|;
name|src
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|dst
operator|->
name|axq_depth
operator|+=
name|src
operator|->
name|axq_depth
expr_stmt|;
name|src
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit a beacon frame at SWBA.  Dynamic updates to the  * frame contents are done as needed and the slot time is  * also adjusted based on current state.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|cabq
init|=
name|sc
operator|->
name|sc_cabq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ncabq
decl_stmt|,
name|nmcastq
decl_stmt|,
name|error
decl_stmt|,
name|otherant
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
name|bf
operator|==
name|NULL
operator|||
name|bf
operator|->
name|bf_m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: ic_flags=%x bf=%p bf_m=%p\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_flags
argument_list|,
name|bf
argument_list|,
name|bf
condition|?
name|bf
operator|->
name|bf_m
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check if the previous beacon has gone out.  If 	 * not don't try to post another, skip this period 	 * and wait for the next.  Missed beacons indicate 	 * a problem and should not occur.  If we miss too 	 * many consecutive beacons reset the device. 	 */
if|if
condition|(
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bmisscount
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: missed %u consecutive beacons\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|>
literal|3
condition|)
comment|/* NB: 3 is a guess */
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_bstucktask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bmisscount
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: resume beacon xmit after %u misses\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Update dynamic beacon contents.  If this returns 	 * non-zero then we need to remap the memory because 	 * the beacon frame changed size (probably because 	 * of the TIM bitmap). 	 */
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
name|nmcastq
operator|=
name|sc
operator|->
name|sc_mcastq
operator|.
name|axq_depth
expr_stmt|;
name|ncabq
operator|=
name|ath_hal_numtxpending
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_beacon_update
argument_list|(
name|ic
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|,
operator|&
name|sc
operator|->
name|sc_boff
argument_list|,
name|m
argument_list|,
name|ncabq
operator|+
name|nmcastq
argument_list|)
condition|)
block|{
comment|/* XXX too conservative? */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed, error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ncabq
operator|&&
operator|(
name|sc
operator|->
name|sc_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
operator|)
condition|)
block|{
comment|/* 		 * CABQ traffic from the previous DTIM is still pending. 		 * This is ok for now but when there are multiple vap's 		 * and we are using staggered beacons we'll want to drain 		 * the cabq before loading frames for the different vap. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: cabq did not drain, mcastq %u cabq %u/%u\n"
argument_list|,
name|__func__
argument_list|,
name|nmcastq
argument_list|,
name|ncabq
argument_list|,
name|cabq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_busy
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle slot time change when a non-ERP station joins/leaves 	 * an 11g network.  The 802.11 layer notifies us via callback, 	 * we mark updateslot, then wait one beacon before effecting 	 * the change.  This gives associated stations at least one 	 * beacon interval to note the state change. 	 */
comment|/* XXX locking */
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|UPDATE
condition|)
name|sc
operator|->
name|sc_updateslot
operator|=
name|COMMIT
expr_stmt|;
comment|/* commit next beacon */
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_updateslot
operator|==
name|COMMIT
condition|)
name|ath_setslottime
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* commit change to h/w */
comment|/* 	 * Check recent per-antenna transmit statistics and flip 	 * the default antenna if noticeably more frames went out 	 * on the non-default antenna. 	 * XXX assumes 2 anntenae 	 */
name|otherant
operator|=
name|sc
operator|->
name|sc_defant
operator|&
literal|1
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ant_tx
index|[
name|otherant
index|]
operator|>
name|sc
operator|->
name|sc_ant_tx
index|[
name|sc
operator|->
name|sc_defant
index|]
operator|+
literal|2
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|otherant
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_ant_tx
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Construct tx descriptor. 	 */
name|ath_beacon_setup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 	 * Stop any current dma and put the new frame on the queue. 	 * This should never fail since we check above that no frames 	 * are still pending on the queue. 	 */
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: beacon queue %u did not stop?\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the CAB queue before the beacon queue to 	 * insure cab frames are triggered by this beacon. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_boff
operator|.
name|bo_tim_len
operator|&&
operator|(
name|sc
operator|->
name|sc_boff
operator|.
name|bo_tim
index|[
literal|4
index|]
operator|&
literal|1
operator|)
condition|)
block|{
comment|/* NB: only at DTIM */
name|ATH_TXQ_LOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcastq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmcastq
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bfm
decl_stmt|;
comment|/* 			 * Move frames from the s/w mcast q to the h/w cab q. 			 */
name|bfm
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcastq
operator|.
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|cabq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cabq
operator|->
name|axq_link
operator|=
name|bfm
operator|->
name|bf_daddr
expr_stmt|;
block|}
else|else
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|,
name|bfm
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_txqmove
argument_list|(
name|cabq
argument_list|,
operator|&
name|sc
operator|->
name|sc_mcastq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_cabq_xmit
operator|+=
name|nmcastq
expr_stmt|;
block|}
comment|/* NB: gated by beacon so safe to start here */
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|cabq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcastq
argument_list|)
expr_stmt|;
block|}
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON_PROC
argument_list|,
literal|"%s: TXDP[%u] = %p (%p)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_xmit
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware after detecting beacons have stopped.  */
end_comment

begin_function
specifier|static
name|void
name|ath_bstuck_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"stuck beacon; resetting (bmiss count %u)\n"
argument_list|,
name|sc
operator|->
name|sc_bmisscount
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim beacon resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_bbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the beacon and sleep timers.  *  * When operating as an AP this resets the TSF and sets  * up the hardware to notify us when we need to issue beacons.  *  * When operating in station mode this sets up the beacon  * timers according to the timestamp of the last received  * beacon and the current TSF, configures PCF and DTIM  * handling, programs the sleep registers so the hardware  * will wakeup in time to receive beacons, and configures  * the beacon miss handling so we'll receive a BMISS  * interrupt when we stop seeing beacons from the AP  * we've associated with.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|TSF_TO_TU
parameter_list|(
name|_h
parameter_list|,
name|_l
parameter_list|)
define|\
value|((((u_int32_t)(_h))<< 22) | (((u_int32_t)(_l))>> 10))
define|#
directive|define
name|FUDGE
value|2
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|ic
operator|->
name|ic_bss
decl_stmt|;
name|u_int32_t
name|nexttbtt
decl_stmt|,
name|intval
decl_stmt|,
name|tsftu
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
comment|/* extract tstamp from last beacon and convert to TU */
name|nexttbtt
operator|=
name|TSF_TO_TU
argument_list|(
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
argument_list|,
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: the beacon interval is kept internally in TU's */
name|intval
operator|=
name|ni
operator|->
name|ni_intval
operator|&
name|HAL_BEACON_PERIOD
expr_stmt|;
if|if
condition|(
name|nexttbtt
operator|==
literal|0
condition|)
comment|/* e.g. for ap mode */
name|nexttbtt
operator|=
name|intval
expr_stmt|;
elseif|else
if|if
condition|(
name|intval
condition|)
comment|/* NB: can be 0 for monitor mode */
name|nexttbtt
operator|=
name|roundup
argument_list|(
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: nexttbtt %u intval %u (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|HAL_BEACON_STATE
name|bs
decl_stmt|;
name|int
name|dtimperiod
decl_stmt|,
name|dtimcount
decl_stmt|;
name|int
name|cfpperiod
decl_stmt|,
name|cfpcount
decl_stmt|;
comment|/* 		 * Setup dtim and cfp parameters according to 		 * last beacon we received (which may be none). 		 */
name|dtimperiod
operator|=
name|ni
operator|->
name|ni_dtim_period
expr_stmt|;
if|if
condition|(
name|dtimperiod
operator|<=
literal|0
condition|)
comment|/* NB: 0 if not known */
name|dtimperiod
operator|=
literal|1
expr_stmt|;
name|dtimcount
operator|=
name|ni
operator|->
name|ni_dtim_count
expr_stmt|;
if|if
condition|(
name|dtimcount
operator|>=
name|dtimperiod
condition|)
comment|/* NB: sanity check */
name|dtimcount
operator|=
literal|0
expr_stmt|;
comment|/* XXX? */
name|cfpperiod
operator|=
literal|1
expr_stmt|;
comment|/* NB: no PCF support yet */
name|cfpcount
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Pull nexttbtt forward to reflect the current 		 * TSF and calculate dtim+cfp state for the result. 		 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
if|if
condition|(
operator|--
name|dtimcount
operator|<
literal|0
condition|)
block|{
name|dtimcount
operator|=
name|dtimperiod
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|cfpcount
operator|<
literal|0
condition|)
name|cfpcount
operator|=
name|cfpperiod
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
name|memset
argument_list|(
operator|&
name|bs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|.
name|bs_intval
operator|=
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bs
operator|.
name|bs_dtimperiod
operator|=
name|dtimperiod
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_nextdtim
operator|=
name|bs
operator|.
name|bs_nexttbtt
operator|+
name|dtimcount
operator|*
name|intval
expr_stmt|;
name|bs
operator|.
name|bs_cfpperiod
operator|=
name|cfpperiod
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpnext
operator|=
name|bs
operator|.
name|bs_nextdtim
operator|+
name|cfpcount
operator|*
name|bs
operator|.
name|bs_dtimperiod
expr_stmt|;
name|bs
operator|.
name|bs_cfpmaxduration
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * The 802.11 layer records the offset to the DTIM 		 * bitmap while receiving beacons; use it here to 		 * enable h/w detection of our AID being marked in 		 * the bitmap vector (to indicate frames for us are 		 * pending at the AP). 		 * XXX do DTIM handling in s/w to WAR old h/w bugs 		 * XXX enable based on h/w rev for newer chips 		 */
block|bs.bs_timoffset = ni->ni_timoff;
endif|#
directive|endif
comment|/* 		 * Calculate the number of consecutive beacons to miss 		 * before taking a BMISS interrupt.  The configuration 		 * is specified in ms, so we need to convert that to 		 * TU's and then calculate based on the beacon interval. 		 * Note that we clamp the result to at most 10 beacons. 		 */
name|bs
operator|.
name|bs_bmissthreshold
operator|=
name|ic
operator|->
name|ic_bmissthreshold
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|>
literal|10
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|<=
literal|0
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Calculate sleep duration.  The configuration is 		 * given in ms.  We insure a multiple of the beacon 		 * period is used.  Also, if the sleep duration is 		 * greater than the DTIM period then it makes senses 		 * to make it a multiple of that. 		 * 		 * XXX fixed at 100ms 		 */
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|IEEE80211_MS_TO_TU
argument_list|(
literal|100
argument_list|)
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_sleepduration
operator|>
name|bs
operator|.
name|bs_dtimperiod
condition|)
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf %ju tsf:tu %u intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u sleep %u cfp:period %u maxdur %u next %u timoffset %u\n"
argument_list|,
name|__func__
argument_list|,
name|tsf
argument_list|,
name|tsftu
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|,
name|bs
operator|.
name|bs_nexttbtt
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|,
name|bs
operator|.
name|bs_nextdtim
argument_list|,
name|bs
operator|.
name|bs_bmissthreshold
argument_list|,
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_cfpperiod
argument_list|,
name|bs
operator|.
name|bs_cfpmaxduration
argument_list|,
name|bs
operator|.
name|bs_cfpnext
argument_list|,
name|bs
operator|.
name|bs_timoffset
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_beacontimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bs
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_BMISS
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttbtt
operator|==
name|intval
condition|)
name|intval
operator||=
name|HAL_BEACON_RESET_TSF
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
comment|/* 			 * In IBSS mode enable the beacon timers but only 			 * enable SWBA interrupts if we need to manually 			 * prepare beacon frames.  Otherwise we use a 			 * self-linked tx descriptor and let the hardware 			 * deal with things. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hasveol
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
if|if
condition|(
operator|(
name|intval
operator|&
name|HAL_BEACON_RESET_TSF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Pull nexttbtt forward to reflect 				 * the current TSF. 				 */
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|tsftu
operator|=
name|TSF_TO_TU
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|,
name|tsf
argument_list|)
operator|+
name|FUDGE
expr_stmt|;
do|do
block|{
name|nexttbtt
operator|+=
name|intval
expr_stmt|;
block|}
do|while
condition|(
name|nexttbtt
operator|<
name|tsftu
condition|)
do|;
block|}
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* 			 * In AP mode we enable the beacon timers and 			 * SWBA interrupts to prepare beacon frames. 			 */
name|intval
operator||=
name|HAL_BEACON_ENA
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
comment|/* beacon prepare */
name|ath_beaconq_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ath_hal_beaconinit
argument_list|(
name|ah
argument_list|,
name|nexttbtt
argument_list|,
name|intval
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bmisscount
operator|=
literal|0
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
comment|/* 		 * When using a self-linked beacon descriptor in 		 * ibss mode load it once here. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|sc
operator|->
name|sc_hasveol
condition|)
name|ath_beacon_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
undef|#
directive|undef
name|FUDGE
undef|#
directive|undef
name|TSF_TO_TU
block|}
end_function

begin_function
specifier|static
name|void
name|ath_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_descdma_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|int
name|ndesc
parameter_list|)
block|{
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u buffers %u desc/buf\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nbuf
argument_list|,
name|ndesc
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
operator|*
name|nbuf
operator|*
name|ndesc
expr_stmt|;
comment|/* 	 * Setup DMA descriptor area. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot allocate %s DMA tag\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s descriptors, "
literal|"error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail0
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|dd_desc
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to alloc memory for %u %s descriptors, "
literal|"error %u\n"
argument_list|,
name|nbuf
operator|*
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|,
name|ath_load_cb
argument_list|,
operator|&
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to map %s descriptors, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ds
operator|=
name|dd
operator|->
name|dd_desc
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA map: %p (%lu) -> %p (%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|ds
argument_list|,
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|,
operator|(
name|caddr_t
operator|)
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
comment|/* allocate rx buffers */
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
argument_list|)
operator|*
name|nbuf
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_ATHDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"malloc of %s buffers failed, size %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|dd
operator|->
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
name|ndesc
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
name|dd
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to create dmamap for %s "
literal|"buffer %u, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
name|dd
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail3
label|:
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|DS2PHYS
block|}
end_function

begin_function
specifier|static
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|head
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
condition|)
block|{
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|STAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dd
operator|->
name|dd_bufptr
argument_list|,
name|M_ATHDEV
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
literal|"rx"
argument_list|,
name|ath_rxbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
literal|"tx"
argument_list|,
name|ath_txbuf
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|,
literal|"beacon"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_bdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
specifier|const
name|size_t
name|space
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_node
argument_list|)
operator|+
name|sc
operator|->
name|sc_rc
operator|->
name|arc_space
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|an
operator|=
name|malloc
argument_list|(
name|space
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|an
operator|==
name|NULL
condition|)
block|{
comment|/* XXX stat+msg */
return|return
name|NULL
return|;
block|}
name|an
operator|->
name|an_avgrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|ath_rate_node_init
argument_list|(
name|sc
argument_list|,
name|an
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: an %p\n"
argument_list|,
name|__func__
argument_list|,
name|an
argument_list|)
expr_stmt|;
return|return
operator|&
name|an
operator|->
name|an_node
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: ni %p\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ath_rate_node_cleanup
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ath_node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|HAL_EP_RND
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
define|\
value|((((x)%(mul))>= ((mul)/2)) ? ((x) + ((mul) - 1)) / (mul) : (x)/(mul))
name|u_int32_t
name|avgrssi
init|=
name|ATH_NODE_CONST
argument_list|(
name|ni
argument_list|)
operator|->
name|an_avgrssi
decl_stmt|;
name|int32_t
name|rssi
decl_stmt|;
comment|/* 	 * When only one frame is received there will be no state in 	 * avgrssi so fallback on the value recorded by the 802.11 layer. 	 */
if|if
condition|(
name|avgrssi
operator|!=
name|ATH_RSSI_DUMMY_MARKER
condition|)
name|rssi
operator|=
name|HAL_EP_RND
argument_list|(
name|avgrssi
argument_list|,
name|HAL_RSSI_EP_MULTIPLIER
argument_list|)
expr_stmt|;
else|else
name|rssi
operator|=
name|ni
operator|->
name|ni_rssi
expr_stmt|;
return|return
name|rssi
operator|<
literal|0
condition|?
literal|0
else|:
name|rssi
operator|>
literal|127
condition|?
literal|127
else|:
name|rssi
return|;
undef|#
directive|undef
name|HAL_EP_RND
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * NB: by assigning a page to the rx dma buffer we 		 * implicitly satisfy the Atheros requirement that 		 * this buffer be cache-line-aligned and sized to be 		 * multiple of the cache line size.  Not doing this 		 * causes weird stuff to happen (for the 5210 at least). 		 */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf/cluster\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed; error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment packet; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Setup descriptors.  For receive we always terminate 	 * the descriptor list with a self-linked entry so we'll 	 * not get overrun under high load (as can happen with a 	 * 5212 when ANI processing enables PHY error frames). 	 * 	 * To insure the last descriptor is self-linked we create 	 * each descriptor as self-linked and add it to the end.  As 	 * each additional descriptor is added the previous self-linked 	 * entry is ``fixed'' naturally.  This should be safe even 	 * if DMA is happening.  When processing RX interrupts we 	 * never remove/process the last, self-linked, entry on the 	 * descriptor list.  This insures the hardware always has 	 * someplace to write a new frame. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* link to self */
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ds
operator|->
name|ds_vdata
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/* for radar */
name|ath_hal_setuprxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
comment|/* buffer size */
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxlink
operator|!=
name|NULL
condition|)
operator|*
name|sc
operator|->
name|sc_rxlink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
operator|&
name|ds
operator|->
name|ds_link
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extend 15-bit time stamp from rx descriptor to  * a full 64-bit TSF using the specified TSF.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int64_t
name|ath_extend_tsf
parameter_list|(
name|u_int32_t
name|rstamp
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tsf
operator|&
literal|0x7fff
operator|)
operator|<
name|rstamp
condition|)
name|tsf
operator|-=
literal|0x8000
expr_stmt|;
return|return
operator|(
operator|(
name|tsf
operator|&
operator|~
literal|0x7fff
operator|)
operator||
name|rstamp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Intercept management frames to collect beacon rssi data  * and to do ibss merges.  */
end_comment

begin_function
specifier|static
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|u_int32_t
name|rstamp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 	 * Call up first so subsequent work can use information 	 * potentially stored in the node (e.g. for ibss merge). 	 */
name|sc
operator|->
name|sc_recv_mgmt
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|subtype
argument_list|,
name|rssi
argument_list|,
name|rstamp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_BEACON
case|:
comment|/* update rssi statistics for use by the hal */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncbeacon
operator|&&
name|ni
operator|==
name|ic
operator|->
name|ic_bss
operator|&&
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 			 * Resync beacon timers using the tsf of the beacon 			 * frame we just received. 			 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru... */
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_extend_tsf
argument_list|(
name|rstamp
argument_list|,
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 			 * Handle ibss merge as needed; check the tsf on the 			 * frame before attempting the merge.  The 802.11 spec 			 * says the station should change it's bssid to match 			 * the oldest station with the same ssid, where oldest 			 * is determined by the tsf.  Note that hardware 			 * reconfiguration happens through callback to 			 * ath_newstate as the state machine will go from 			 * RUN -> RUN when this happens. 			 */
if|if
condition|(
name|le64toh
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
operator|>=
name|tsf
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"ibss merge, rstamp %u tsf %ju "
literal|"tstamp %ju\n"
argument_list|,
name|rstamp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tsf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ibss_merge
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the default antenna.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setdefantenna
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|antenna
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* XXX block beacon interrupts */
name|ath_hal_setdefantenna
argument_list|(
name|ah
argument_list|,
name|antenna
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|antenna
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_defswitch
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_defant
operator|=
name|antenna
expr_stmt|;
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rx_tap
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ath_desc
modifier|*
name|ds
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
name|u_int8_t
name|rix
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_drvbpf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no tap"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Discard anything shorter than an ack or cts. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|IEEE80211_ACK_LEN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: runt packet %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_tooshort
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_tsf
operator|=
name|htole64
argument_list|(
name|ath_extend_tsf
argument_list|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rate
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|rxflags
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_BADFCS
expr_stmt|;
comment|/* XXX propagate other error flags from descriptor */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antsignal
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
operator|+
name|nf
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antnoise
operator|=
name|nf
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antenna
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_antenna
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|,
operator|&
name|sc
operator|->
name|sc_rx_th
argument_list|,
name|sc
operator|->
name|sc_rx_th_len
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|,
name|ngood
decl_stmt|;
name|u_int
name|phyerr
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
comment|/* XXX */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RX_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|ngood
operator|=
literal|0
expr_stmt|;
name|nf
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
do|do
block|{
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no buffer!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
comment|/* 			 * If mbuf allocation failed previously there 			 * will be no mbuf; try again to re-populate it. 			 */
comment|/* XXX make debug msg */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: no mbuf!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_link
operator|==
name|bf
operator|->
name|bf_daddr
condition|)
block|{
comment|/* NB: never process the self-linked entry at the end */
break|break;
block|}
comment|/* XXX sync descriptor memory */
comment|/* 		 * Must provide the virtual address of the current 		 * descriptor, the physical address, and the virtual 		 * address of the next descriptor in the h/w chain. 		 * This allows the HAL to look ahead to see if the 		 * hardware is done with a descriptor by checking the 		 * done bit in the following descriptor and the address 		 * of the current descriptor the DMA engine is working 		 * on.  All this is necessary because of our use of 		 * a self-linked list to avoid rx overruns. 		 */
name|status
operator|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RECV_DESC
condition|)
name|ath_printrxbuf
argument_list|(
name|bf
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_more
condition|)
block|{
comment|/* 			 * Frame spans multiple descriptors; this 			 * cannot happen yet as we don't support 			 * jumbograms.  If not in monitor mode, 			 * discard the frame. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_MONITOR
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_toobig
operator|++
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
comment|/* fall thru for monitor mode handling... */
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_crcerr
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phyerr
operator|++
expr_stmt|;
name|phyerr
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_phyerr
operator|&
literal|0x1f
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phy
index|[
name|phyerr
index|]
operator|++
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_DECRYPT
condition|)
block|{
comment|/* 				 * Decrypt error.  If the error occurred 				 * because there was no hardware key, then 				 * let the frame through so the upper layers 				 * can process it.  This is necessary for 5210 				 * parts which have no way to setup a ``clear'' 				 * key cache entry. 				 * 				 * XXX do key cache faulting 				 */
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|)
goto|goto
name|rx_accept
goto|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badcrypt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_MIC
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badmic
operator|++
expr_stmt|;
comment|/* 				 * Do minimal work required to hand off 				 * the 802.11 header for notifcation. 				 */
comment|/* XXX frag's and qos frames */
name|len
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_datalen
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|ieee80211_notify_michael_failure
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_keyix
operator|-
literal|32
else|:
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_keyix
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
comment|/* 			 * When a tap is present pass error frames 			 * that have been requested.  By default we 			 * pass decrypt+mic errors but others may be 			 * interesting (e.g. crc). 			 */
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|)
operator|&&
operator|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|sc
operator|->
name|sc_monpass
operator|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* NB: bpf needs the mbuf length setup */
name|len
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|ath_rx_tap
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ds
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
comment|/* XXX pass MIC errors up for s/w reclaculation */
goto|goto
name|rx_next
goto|;
block|}
name|rx_accept
label|:
comment|/* 		 * Sync and unmap the frame.  At this point we're 		 * committed to passing the mbuf somewhere so clear 		 * bf_m; this means a new mbuf must be allocated 		 * when the rx descriptor is setup again to receive 		 * another frame. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|len
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_rx
index|[
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_antenna
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|)
operator|&&
operator|!
name|ath_rx_tap
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ds
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX reclaim */
goto|goto
name|rx_next
goto|;
block|}
comment|/* 		 * From this point on we assume the frame is at least 		 * as large as ieee80211_frame_min; verify that. 		 */
if|if
condition|(
name|len
operator|<
name|IEEE80211_MIN_LEN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: short packet %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_tooshort
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|)
condition|)
block|{
name|ieee80211_dump_pkt
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rate
index|]
operator|.
name|ieeerate
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
argument_list|)
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* 		 * Locate the node for sender, track state, and then 		 * pass the (referenced) node up to the 802.11 layer 		 * for its use. 		 */
name|ni
operator|=
name|ieee80211_find_rxnode_withkey
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|?
name|IEEE80211_KEYIX_NONE
else|:
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_keyix
argument_list|)
expr_stmt|;
comment|/* 		 * Track rx rssi and do any rx antenna management. 		 */
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ATH_RSSI_LPF
argument_list|(
name|an
operator|->
name|an_avgrssi
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
argument_list|)
expr_stmt|;
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
argument_list|)
expr_stmt|;
comment|/* 		 * Send frame up for processing. 		 */
name|type
operator|=
name|ieee80211_input
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_tstamp
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_diversity
condition|)
block|{
comment|/* 			 * When using fast diversity, change the default rx 			 * antenna if diversity chooses the other antenna 3 			 * times in a row. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_antenna
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_rxotherant
operator|>=
literal|3
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_antenna
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
comment|/* 			 * Blink for any data frame.  Otherwise do a 			 * heartbeat-style blink when idle.  The latter 			 * is mainly for station mode where we depend on 			 * periodic beacon frames to trigger the poll event. 			 */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
name|sc
operator|->
name|sc_rxrate
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rate
expr_stmt|;
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|ATH_LED_RX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_ledevent
operator|>=
name|sc
operator|->
name|sc_ledidle
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|ATH_LED_POLL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Arrange to update the last rx timestamp only for 		 * frames from our ap when operating in station mode. 		 * This assumes the rx key is always setup when associated. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_keyix
operator|!=
name|HAL_RXKEYIX_INVALID
condition|)
name|ngood
operator|++
expr_stmt|;
name|rx_next
label|:
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* rx signal state monitoring */
name|ath_hal_rxmonitor
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|,
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngood
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|tsf
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
comment|/* XXX */
undef|#
directive|undef
name|PA2DESC
block|}
end_function

begin_function
specifier|static
name|void
name|ath_txq_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|txq
operator|->
name|axq_qnum
operator|=
name|qnum
expr_stmt|;
name|txq
operator|->
name|axq_depth
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_INIT
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup a h/w transmit queue.  */
end_comment

begin_function
specifier|static
name|struct
name|ath_txq
modifier|*
name|ath_txq_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qtype
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|int
name|qnum
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qi
argument_list|)
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_subtype
operator|=
name|subtype
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|HAL_TXQ_USEDEFAULT
expr_stmt|;
comment|/* 	 * Enable interrupts only for EOL and DESC conditions. 	 * We mark tx descriptors to receive a DESC interrupt 	 * when a tx queue gets deep; otherwise waiting for the 	 * EOL to reap descriptors.  Note that this is done to 	 * reduce interrupt load and this only defers reaping 	 * descriptors, never transmitting frames.  Aside from 	 * reducing interrupts this also permits more concurrency. 	 * The only potential downside is if the tx queue backs 	 * up in which case the top half of the kernel may backup 	 * due to a lack of tx descriptors. 	 */
name|qi
operator|.
name|tqi_qflags
operator|=
name|HAL_TXQ_TXEOLINT_ENABLE
operator||
name|HAL_TXQ_TXDESCINT_ENABLE
expr_stmt|;
name|qnum
operator|=
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|qtype
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnum
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * NB: don't print a message, this happens 		 * normally on parts with too few tx queues 		 */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|qnum
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hal qnum %u out of range, max %zu!\n"
argument_list|,
name|qnum
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_txq
argument_list|)
argument_list|)
expr_stmt|;
name|ath_hal_releasetxqueue
argument_list|(
name|ah
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|qnum
argument_list|)
condition|)
block|{
name|ath_txq_init
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
argument_list|,
name|qnum
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator||=
literal|1
operator|<<
name|qnum
expr_stmt|;
block|}
return|return
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|qnum
index|]
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Setup a hardware data transmit queue for the specified  * access control.  The hal may not support all requested  * queues in which case it will return a reference to a  * previously setup queue.  We record the mapping from ac's  * to h/w queues for use by ath_tx_start and also track  * the set of h/w queues being used to optimize work in the  * transmit interrupt handler and related routines.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|,
name|int
name|haltype
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
if|if
condition|(
name|ac
operator|>=
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"AC %u out of range, max %zu!\n"
argument_list|,
name|ac
argument_list|,
name|N
argument_list|(
name|sc
operator|->
name|sc_ac2q
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|txq
operator|=
name|ath_txq_setup
argument_list|(
name|sc
argument_list|,
name|HAL_TX_QUEUE_DATA
argument_list|,
name|haltype
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
operator|=
name|txq
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for a transmit queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_txq_update
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|ac
parameter_list|)
block|{
define|#
directive|define
name|ATH_EXPONENT_TO_VALUE
parameter_list|(
name|v
parameter_list|)
value|((1<<v)-1)
define|#
directive|define
name|ATH_TXOP_TO_US
parameter_list|(
name|v
parameter_list|)
value|(v<<5)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_TXQ_INFO
name|qi
decl_stmt|;
name|ath_hal_gettxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_aifs
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|qi
operator|.
name|tqi_cwmin
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_cwmax
operator|=
name|ATH_EXPONENT_TO_VALUE
argument_list|(
name|wmep
operator|->
name|wmep_logcwmax
argument_list|)
expr_stmt|;
name|qi
operator|.
name|tqi_burstTime
operator|=
name|ATH_TXOP_TO_US
argument_list|(
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_settxqueueprops
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|&
name|qi
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to update hardware queue "
literal|"parameters for %s traffic!\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|ac
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|ath_hal_resettxqueue
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
comment|/* push to h/w */
return|return
literal|1
return|;
block|}
undef|#
directive|undef
name|ATH_TXOP_TO_US
undef|#
directive|undef
name|ATH_EXPONENT_TO_VALUE
block|}
end_function

begin_comment
comment|/*  * Callback from the 802.11 layer to update WME parameters.  */
end_comment

begin_function
specifier|static
name|int
name|ath_wme_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
return|return
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BE
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_BK
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VI
argument_list|)
operator|||
operator|!
name|ath_txq_update
argument_list|(
name|sc
argument_list|,
name|WME_AC_VO
argument_list|)
condition|?
name|EIO
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim resources for a setup queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanupq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|ath_hal_releasetxqueue
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txqsetup
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|txq
operator|->
name|axq_qnum
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim all tx queue resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ATH_TXBUF_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_cleanupq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_DESTROY
argument_list|(
operator|&
name|sc
operator|->
name|sc_mcastq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Defragment an mbuf chain, returning at most maxfrags separate  * mbufs+clusters.  If this is not possible NULL is returned and  * the original mbuf chain is left in it's present (potentially  * modified) state.  We use two techniques: collapsing consecutive  * mbufs and replacing consecutive mbufs by a cluster.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ath_defrag
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|how
parameter_list|,
name|int
name|maxfrags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
name|u_int
name|curfrags
decl_stmt|;
comment|/* 	 * Calculate the current number of frags. 	 */
name|curfrags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|curfrags
operator|++
expr_stmt|;
comment|/* 	 * First, try to collapse mbufs.  Note that we always collapse 	 * towards the front so we don't need to deal with moving the 	 * pkthdr.  This may be suboptimal if the first mbuf has much 	 * less data than the following. 	 */
name|m
operator|=
name|m0
expr_stmt|;
name|again
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_RDONLY
operator|)
operator|==
literal|0
operator|&&
name|n
operator|->
name|m_len
operator|<
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|curfrags
operator|<=
name|maxfrags
condition|)
return|return
name|m0
return|;
block|}
else|else
name|m
operator|=
name|n
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|maxfrags
operator|>
literal|1
argument_list|,
operator|(
literal|"maxfrags %u, but normal collapse failed"
operator|,
name|maxfrags
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Collapse consecutive mbufs to a cluster. 	 */
name|prev
operator|=
operator|&
name|m0
operator|->
name|m_next
expr_stmt|;
comment|/* NB: not the first mbuf */
while|while
condition|(
operator|(
name|n
operator|=
operator|*
name|prev
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|n2
operator|=
name|n
operator|->
name|m_next
operator|)
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|m_len
operator|+
name|n2
operator|->
name|m_len
operator|<
name|MCLBYTES
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|how
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n2
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|n
operator|->
name|m_len
argument_list|,
name|n2
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|n
operator|->
name|m_len
operator|+
name|n2
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|n2
operator|->
name|m_next
expr_stmt|;
operator|*
name|prev
operator|=
name|m
expr_stmt|;
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|n2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|curfrags
operator|<=
name|maxfrags
condition|)
comment|/* +1 cl -2 mbufs */
return|return
name|m0
return|;
comment|/* 			 * Still not there, try the normal collapse 			 * again before we allocate another cluster. 			 */
goto|goto
name|again
goto|;
block|}
name|prev
operator|=
operator|&
name|n
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	 * No place where we can collapse to a cluster; punt. 	 * This can occur if, for example, you request 2 frags 	 * but the packet requires that both be clusters (we 	 * never reallocate the first mbuf to avoid moving the 	 * packet header). 	 */
name|bad
label|:
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Return h/w rate index for an IEEE rate (w/o basic rate bit).  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_findrix
parameter_list|(
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|rate
condition|)
return|return
name|i
return|;
return|return
literal|0
return|;
comment|/* NB: lowest rate */
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_dmasetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|ATH_TXDESC
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|>
name|ATH_TXDESC
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_linear
operator|++
expr_stmt|;
name|m
operator|=
name|ath_defrag
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|ATH_TXDESC
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodata
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_handoff
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fillin the remainder of the descriptor info. 	 */
name|ds0
operator|=
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
comment|/* segment length */
argument_list|,
name|i
operator|==
literal|0
comment|/* first segment */
argument_list|,
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|,
name|ds0
comment|/* first descriptor */
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %d: %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert the frame on the outbound list and pass it on 	 * to the hardware.  Multicast frames buffered for power 	 * save stations and transmit from the CAB queue are stored 	 * on a s/w only queue and loaded on to the CAB queue in 	 * the SWBA handler since frames only go out on DTIM and 	 * to avoid possible races. 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|!=
operator|&
name|sc
operator|->
name|sc_mcastq
condition|)
block|{
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
specifier|const
name|struct
name|chanAccParams
modifier|*
name|cap
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
decl_stmt|;
name|int
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|ismcast
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|;
name|u_int8_t
name|cix
init|=
literal|0xff
decl_stmt|;
comment|/* NB: silence compiler */
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|subtype
decl_stmt|,
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Adjust the packet + header lengths for the crypto 		 * additions and calculate the h/w key index.  When 		 * a s/w mic is done the frame will have had any mic 		 * added to it prior to entry so m0->m_pkthdr.len above will 		 * account for it. Otherwise we need to add it to the 		 * packet length. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
name|hdrlen
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
name|pktlen
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
condition|)
name|pktlen
operator|+=
name|cip
operator|->
name|ic_miclen
expr_stmt|;
name|keyix
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
operator|==
operator|&
name|ieee80211_cipher_none
condition|)
block|{
comment|/* 		 * Use station key cache slot, if assigned. 		 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
expr_stmt|;
if|if
condition|(
name|keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|keyix
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
block|}
else|else
name|keyix
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
name|pktlen
operator|+=
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the 802.11 layer marks whether or not we should 	 * use short preamble based on the current mode and 	 * negotiated parameters. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
block|{
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortpre
operator|++
expr_stmt|;
block|}
else|else
block|{
name|shortPreamble
operator|=
name|AH_FALSE
expr_stmt|;
block|}
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* default no multi-rate retry*/
comment|/* 	 * Calculate Atheros packet type from IEEE80211 packet header, 	 * setup for rate calculations, and select h/w transmit queue. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_BEACON
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PROBE_RESP
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ATIM
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_ATIM
expr_stmt|;
else|else
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* XXX */
name|rix
operator|=
name|sc
operator|->
name|sc_minrateix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* NB: force all management frames to highest queue */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|)
block|{
comment|/* NB: force all management frames to highest queue */
name|pri
operator|=
name|WME_AC_VO
expr_stmt|;
block|}
else|else
name|pri
operator|=
name|WME_AC_BE
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
comment|/* stop setting of duration */
name|rix
operator|=
name|sc
operator|->
name|sc_minrateix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* NB: force all ctl frames to highest queue */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|)
block|{
comment|/* NB: force all ctl frames to highest queue */
name|pri
operator|=
name|WME_AC_VO
expr_stmt|;
block|}
else|else
name|pri
operator|=
name|WME_AC_BE
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* default */
comment|/* 		 * Data frames: multicast frames go out at a fixed rate, 		 * otherwise consult the rate control module for the 		 * rate to use. 		 */
if|if
condition|(
name|ismcast
condition|)
block|{
comment|/* 			 * Check mcast rate setting in case it's changed. 			 * XXX move out of fastpath 			 */
if|if
condition|(
name|ic
operator|->
name|ic_mcast_rate
operator|!=
name|sc
operator|->
name|sc_mcastrate
condition|)
block|{
name|sc
operator|->
name|sc_mcastrix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|ic
operator|->
name|ic_mcast_rate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mcastrate
operator|=
name|ic
operator|->
name|ic_mcast_rate
expr_stmt|;
block|}
name|rix
operator|=
name|sc
operator|->
name|sc_mcastrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ath_rate_findrate
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|shortPreamble
argument_list|,
name|pktlen
argument_list|,
operator|&
name|rix
argument_list|,
operator|&
name|try0
argument_list|,
operator|&
name|txrate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txrate
operator|=
name|txrate
expr_stmt|;
comment|/* for LED blinking */
if|if
condition|(
name|try0
operator|!=
name|ATH_TXMAXTRY
condition|)
name|ismrr
operator|=
literal|1
expr_stmt|;
block|}
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|cap_wmeParams
index|[
name|pri
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX statistic */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
comment|/* 	 * When servicing one or more stations in power-save mode 	 * (or) if there is some mcast data waiting on the mcast 	 * queue (to prevent out of order delivery) multicast 	 * frames must be buffered until after the beacon. 	 */
if|if
condition|(
name|ismcast
operator|&&
operator|(
name|ic
operator|->
name|ic_ps_sta
operator|||
name|sc
operator|->
name|sc_mcastq
operator|.
name|axq_depth
operator|)
condition|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|sc_mcastq
expr_stmt|;
comment|/* XXX? more bit in 802.11 frame header */
block|}
comment|/* 	 * Calculate miscellaneous flags. 	 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
comment|/* no ack on broad/multicast */
block|}
elseif|else
if|if
condition|(
name|pktlen
operator|>
name|ic
operator|->
name|ic_rtsthreshold
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
comment|/* RTS based on frame length */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|controlRate
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
condition|)
comment|/* NB: avoid double counting */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_noack
operator|++
expr_stmt|;
comment|/* 	 * If 802.11g protection is enabled, determine whether 	 * to use RTS/CTS or just CTS.  Note that this is only 	 * done for OFDM unicast frames. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX fragments must use CCK rates w/ protection */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_protrix
index|]
operator|.
name|controlRate
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_protect
operator|++
expr_stmt|;
block|}
comment|/* 	 * Calculate duration.  This logically belongs in the 802.11 	 * layer but it lacks sufficient information to calculate it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
name|u_int16_t
name|dur
decl_stmt|;
comment|/* 		 * XXX not right with fragmentation. 		 */
if|if
condition|(
name|shortPreamble
condition|)
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
else|else
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate RTS/CTS rate and duration if needed. 	 */
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
block|{
comment|/* 		 * CTS transmit rate is derived from the transmit rate 		 * by looking in the h/w rate table.  We must also factor 		 * in whether or not a short preamble is to be used. 		 */
comment|/* NB: cix is set above where RTS/CTS is enabled */
name|KASSERT
argument_list|(
name|cix
operator|!=
literal|0xff
argument_list|,
operator|(
literal|"cix not setup"
operator|)
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* 		 * Compute the transmit duration based on the frame 		 * size and the size of an ACK frame.  We call into the 		 * HAL to do the computation since it depends on the 		 * characteristics of the actual PHY being used. 		 * 		 * NB: CTS is assumed the same size as an ACK so we can 		 *     use the precalculated ACK durations. 		 */
if|if
condition|(
name|shortPreamble
condition|)
block|{
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
comment|/* 		 * Must disable multi-rate retry when using RTS/CTS. 		 */
name|ismrr
operator|=
literal|0
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|txrate
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ic
operator|->
name|ic_rawbpf
argument_list|)
condition|)
name|bpf_mtap
argument_list|(
name|ic
operator|->
name|ic_rawbpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|txrate
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|txrate
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
argument_list|,
name|sc
operator|->
name|sc_tx_th_len
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Determine if a tx interrupt should be generated for 	 * this descriptor.  We take a tx interrupt to reap 	 * descriptors when the h/w hits an EOL condition or 	 * when the descriptor is specifically marked to generate 	 * an interrupt.  We periodically mark descriptors in this 	 * way to insure timely replenishing of the supply needed 	 * for sending frames.  Defering interrupts reduces system 	 * load and potentially allows more concurrent work to be 	 * done but if done to aggressively can cause senders to 	 * backup. 	 * 	 * NB: use>= to deal with sc_txintrperiod changing 	 *     dynamically through sysctl. 	 */
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_INTREQ
condition|)
block|{
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|txq
operator|->
name|axq_intrcnt
operator|>=
name|sc
operator|->
name|sc_txintrperiod
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
comment|/* XXX check return value? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
name|ni
operator|->
name|ni_txpower
comment|/* txpower */
argument_list|,
name|txrate
argument_list|,
name|try0
comment|/* series 0 rate/tries */
argument_list|,
name|keyix
comment|/* key cache index */
argument_list|,
name|sc
operator|->
name|sc_txantenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_flags
operator|=
name|flags
expr_stmt|;
comment|/* 	 * Setup the multi-rate retry state only when we're 	 * going to use it.  This assumes ath_hal_setuptxdesc 	 * initializes the descriptors (so we don't have to) 	 * when the hardware supports multi-rate retry and 	 * we don't use it. 	 */
if|if
condition|(
name|ismrr
condition|)
name|ath_rate_setupxtxdesc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|ds
argument_list|,
name|shortPreamble
argument_list|,
name|rix
argument_list|)
expr_stmt|;
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process completed xmit descriptors from the specified queue.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_processq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|int
name|sr
decl_stmt|,
name|lr
decl_stmt|,
name|pri
decl_stmt|,
name|nacked
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TX_PROC
argument_list|,
literal|"%s: tx queue %u head %p link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
comment|/* reset periodic desc intr count */
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds0
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
literal|0
index|]
expr_stmt|;
name|ds
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
expr_stmt|;
name|status
operator|=
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_XMIT_DESC
condition|)
name|ath_printtxbuf
argument_list|(
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE_HEAD
argument_list|(
name|txq
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|==
literal|0
condition|)
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|==
literal|0
condition|)
block|{
name|u_int8_t
name|txant
init|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_antenna
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ant_tx
index|[
name|txant
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_rate
operator|&
name|HAL_TXSTAT_ALTRATE
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_altrate
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rssi
operator|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_rssi
expr_stmt|;
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
argument_list|,
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_rssi
argument_list|)
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
name|WME_AC_VO
condition|)
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_traffic
operator|++
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FILT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_filtered
operator|++
expr_stmt|;
block|}
name|sr
operator|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_shortretry
expr_stmt|;
name|lr
operator|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_longretry
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortretry
operator|+=
name|sr
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_longretry
operator|+=
name|lr
expr_stmt|;
comment|/* 			 * Hand the descriptor to the rate control algorithm. 			 */
if|if
condition|(
operator|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If frame was ack'd update the last rx time 				 * used to workaround phantom bmiss interrupts. 				 */
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|==
literal|0
condition|)
name|nacked
operator|++
expr_stmt|;
name|ath_rate_tx_complete
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|ds
argument_list|,
name|ds0
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Reclaim reference to node. 			 * 			 * NB: the node may be reclaimed here if, for example 			 *     this is a DEAUTH message that was sent and the 			 *     node was timed out due to inactivity. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|nacked
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|txqactive
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|qnum
parameter_list|)
block|{
name|u_int32_t
name|txqs
init|=
literal|1
operator|<<
name|qnum
decl_stmt|;
name|ath_hal_gettxintrtxqs
argument_list|(
name|ah
argument_list|,
operator|&
name|txqs
argument_list|)
expr_stmt|;
return|return
operator|(
name|txqs
operator|&
operator|(
literal|1
operator|<<
name|qnum
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for a single hardware transmit queue (e.g. 5210 and 5211).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
operator|&&
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|)
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|ATH_LED_TX
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt; special-cased  * for four hardware queues, 0-3 (e.g. 5212 w/ WME support).  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc_q0123
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|nacked
decl_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|0
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|1
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|2
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|3
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
condition|)
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_cabq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|ATH_LED_TX
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred processing of transmit interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nacked
decl_stmt|;
comment|/* 	 * Process each active queue. 	 */
name|nacked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
operator|&&
name|txqactive
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|i
argument_list|)
condition|)
name|nacked
operator|+=
name|ath_tx_processq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nacked
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|ATH_LED_TX
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
endif|#
directive|endif
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
comment|/* 	 * NB: this assumes output has been stopped and 	 *     we do not need to block ath_tx_tasklet 	 */
for|for
control|(
name|ix
operator|=
literal|0
init|;
condition|;
name|ix
operator|++
control|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|txq
operator|->
name|axq_link
operator|=
name|NULL
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
break|break;
block|}
name|ATH_TXQ_REMOVE_HEAD
argument_list|(
name|txq
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|ath_printtxbuf
argument_list|(
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ix
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Reclaim node reference. 			 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_stopdma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain the transmit queues and reclaim resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX return value */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* don't touch the hardware if marked invalid */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: tx queue [%u] %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_stopdma
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HAL_NUM_TX_QUEUES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ATH_TXQ_SETUP
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
condition|)
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_txq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ath_tx_draintxq
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mcastq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_bbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|ath_printtxbuf
argument_list|(
name|bf
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
literal|0
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ATH_DEBUG */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable the receive h/w in preparation for a reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ath_hal_stoppcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable PCU */
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear recv filter */
name|ath_hal_stopdmarecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable DMA engine */
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* 3ms is long enough for 1 frame */
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
operator|(
name|ATH_DEBUG_RESET
operator||
name|ATH_DEBUG_FATAL
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
name|printf
argument_list|(
literal|"%s: rx queue %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_getrxbuf
argument_list|(
name|ah
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_rxlink
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|HAL_STATUS
name|status
init|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|HAL_OK
operator|||
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_FATAL
operator|)
condition|)
name|ath_printrxbuf
argument_list|(
name|bf
argument_list|,
name|ix
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
comment|/* just in case */
undef|#
directive|undef
name|PA2DESC
block|}
end_function

begin_comment
comment|/*  * Enable the receive h/w following a reset.  */
end_comment

begin_function
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: ath_rxbuf_init failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Update internal state after a channel change.  */
end_comment

begin_function
specifier|static
name|void
name|ath_chan_change
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
comment|/* 	 * Change channels and update the h/w rate map 	 * if we're switching; e.g. 11a to 11b/g. 	 */
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|sc
operator|->
name|sc_curmode
condition|)
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* 	 * Update BPF state.  NB: ethereal et. al. don't handle 	 * merged flags well so pick a unique mode for their use. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
name|flags
operator|=
name|IEEE80211_CHAN_A
expr_stmt|;
comment|/* XXX 11g schizophrenia */
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_G
argument_list|(
name|chan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_PUREG
argument_list|(
name|chan
argument_list|)
condition|)
name|flags
operator|=
name|IEEE80211_CHAN_G
expr_stmt|;
else|else
name|flags
operator|=
name|IEEE80211_CHAN_B
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_T
argument_list|(
name|chan
argument_list|)
condition|)
name|flags
operator||=
name|IEEE80211_CHAN_TURBO
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_freq
operator|=
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_flags
operator|=
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poll for a channel clear indication; this is required  * for channels requiring DFS and not previously visited  * and/or with a recent radar detection.  */
end_comment

begin_function
specifier|static
name|void
name|ath_dfswait
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_CHANNEL
name|hchan
decl_stmt|;
name|ath_hal_radar_wait
argument_list|(
name|ah
argument_list|,
operator|&
name|hchan
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_DFS
argument_list|,
literal|"%s: radar_wait %u/%x/%x\n"
argument_list|,
name|__func__
argument_list|,
name|hchan
operator|.
name|channel
argument_list|,
name|hchan
operator|.
name|channelFlags
argument_list|,
name|hchan
operator|.
name|privFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hchan
operator|.
name|privFlags
operator|&
name|CHANNEL_INTERFERENCE
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"channel %u/0x%x/0x%x has interference\n"
argument_list|,
name|hchan
operator|.
name|channel
argument_list|,
name|hchan
operator|.
name|channelFlags
argument_list|,
name|hchan
operator|.
name|privFlags
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|hchan
operator|.
name|privFlags
operator|&
name|CHANNEL_DFS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX should not happen */
return|return;
block|}
if|if
condition|(
name|hchan
operator|.
name|privFlags
operator|&
name|CHANNEL_DFS_CLEAR
condition|)
block|{
name|sc
operator|->
name|sc_curchan
operator|.
name|privFlags
operator||=
name|CHANNEL_DFS_CLEAR
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"channel %u/0x%x/0x%x marked clear\n"
argument_list|,
name|hchan
operator|.
name|channel
argument_list|,
name|hchan
operator|.
name|channelFlags
argument_list|,
name|hchan
operator|.
name|privFlags
argument_list|)
expr_stmt|;
block|}
else|else
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfs_ch
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ath_dfswait
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  If the channel is really being changed,  * it's done by reseting the chip.  To accomplish this we must  * first cleanup any pending DMA, then restart stuff after a la  * ath_init.  */
end_comment

begin_function
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|HAL_CHANNEL
name|hchan
decl_stmt|;
comment|/* 	 * Convert to a HAL channel description with 	 * the flags constrained to reflect the current 	 * operating mode. 	 */
name|hchan
operator|.
name|channel
operator|=
name|chan
operator|->
name|ic_freq
expr_stmt|;
name|hchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %u (%u MHz, hal flags 0x%x) -> %u (%u MHz, hal flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ath_hal_mhz2ieee
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|.
name|channel
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|.
name|channelFlags
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|.
name|channel
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|.
name|channelFlags
argument_list|,
name|ath_hal_mhz2ieee
argument_list|(
name|ah
argument_list|,
name|hchan
operator|.
name|channel
argument_list|,
name|hchan
operator|.
name|channelFlags
argument_list|)
argument_list|,
name|hchan
operator|.
name|channel
argument_list|,
name|hchan
operator|.
name|channelFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|hchan
operator|.
name|channel
operator|!=
name|sc
operator|->
name|sc_curchan
operator|.
name|channel
operator|||
name|hchan
operator|.
name|channelFlags
operator|!=
name|sc
operator|->
name|sc_curchan
operator|.
name|channelFlags
condition|)
block|{
name|HAL_STATUS
name|status
decl_stmt|;
comment|/* 		 * To switch channels clear any pending DMA operations; 		 * wait long enough for the RX fifo to drain, reset the 		 * hardware at the new frequency, and then re-enable 		 * the relevant bits of the h/w. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear pending tx frames */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* turn off frame recv */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_opmode
argument_list|,
operator|&
name|hchan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: unable to reset "
literal|"channel %u (%u Mhz, flags 0x%x hal flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|,
name|hchan
operator|.
name|channelFlags
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|sc
operator|->
name|sc_curchan
operator|=
name|hchan
expr_stmt|;
name|ath_update_txpow
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* update tx power state */
name|sc
operator|->
name|sc_diversity
operator|=
name|ath_hal_getdiversity
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_calinterval
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_caltries
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Re-enable rx framework. 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"%s: unable to restart recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Change channels and update the h/w rate map 		 * if we're switching; e.g. 11a to 11b/g. 		 */
name|ic
operator|->
name|ic_ibss_chan
operator|=
name|chan
expr_stmt|;
name|ath_chan_change
argument_list|(
name|sc
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 		 * Handle DFS required waiting period to determine 		 * if channel is clear of radar traffic. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
define|#
directive|define
name|DFS_AND_NOT_CLEAR
parameter_list|(
name|_c
parameter_list|)
define|\
value|(((_c)->privFlags& (CHANNEL_DFS | CHANNEL_DFS_CLEAR)) == CHANNEL_DFS)
if|if
condition|(
name|DFS_AND_NOT_CLEAR
argument_list|(
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"wait for DFS clear channel signal\n"
argument_list|)
expr_stmt|;
comment|/* XXX stop sndq */
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfs_ch
argument_list|,
literal|2
operator|*
name|hz
argument_list|,
name|ath_dfswait
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfs_ch
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DFS_NOT_CLEAR
block|}
comment|/* 		 * Re-enable interrupts. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_next_scan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_SCAN
condition|)
name|ieee80211_next_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Periodically recalibrate the PHY to account  * for temperature/environment changes.  */
end_comment

begin_function
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_BOOL
name|iqCalDone
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_cal
operator|++
expr_stmt|;
if|if
condition|(
name|ath_hal_getrfgain
argument_list|(
name|ah
argument_list|)
operator|==
name|HAL_RFGAIN_NEED_CHANGE
condition|)
block|{
comment|/* 		 * Rfgain is out of bounds, reset the chip 		 * to load new gain values. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: rfgain change\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_rfgain
operator|++
expr_stmt|;
name|ath_reset
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ath_hal_calibrate
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|,
operator|&
name|iqCalDone
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: calibration of channel %u failed\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_curchan
operator|.
name|channel
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_calfail
operator|++
expr_stmt|;
block|}
comment|/* 	 * Calibrate noise floor data again in case of change. 	 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Poll more frequently when the IQ calibration is in 	 * progress to speedup loading the final settings.  	 * We temper this aggressive polling with an exponential 	 * back off after 4 tries up to ath_calinterval. 	 */
if|if
condition|(
name|iqCalDone
operator|||
name|sc
operator|->
name|sc_calinterval
operator|>=
name|ath_calinterval
condition|)
block|{
name|sc
operator|->
name|sc_caltries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_calinterval
operator|=
name|ath_calinterval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_caltries
operator|>
literal|4
condition|)
block|{
name|sc
operator|->
name|sc_caltries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_calinterval
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_calinterval
operator|>
name|ath_calinterval
condition|)
name|sc
operator|->
name|sc_calinterval
operator|=
name|ath_calinterval
expr_stmt|;
block|}
name|KASSERT
argument_list|(
literal|0
operator|<
name|sc
operator|->
name|sc_calinterval
operator|&&
name|sc
operator|->
name|sc_calinterval
operator|<=
name|ath_calinterval
argument_list|,
operator|(
literal|"bad calibration interval %u"
operator|,
name|sc
operator|->
name|sc_calinterval
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_CALIBRATE
argument_list|,
literal|"%s: next +%u (%siqCalDone tries %u)\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_calinterval
argument_list|,
name|iqCalDone
condition|?
literal|""
else|:
literal|"!"
argument_list|,
name|sc
operator|->
name|sc_caltries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_caltries
operator|++
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|sc
operator|->
name|sc_calinterval
operator|*
name|hz
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
specifier|const
name|u_int8_t
modifier|*
name|bssid
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
specifier|static
specifier|const
name|HAL_LED_STATE
name|leds
index|[]
init|=
block|{
name|HAL_LED_INIT
block|,
comment|/* IEEE80211_S_INIT */
name|HAL_LED_SCAN
block|,
comment|/* IEEE80211_S_SCAN */
name|HAL_LED_AUTH
block|,
comment|/* IEEE80211_S_AUTH */
name|HAL_LED_ASSOC
block|,
comment|/* IEEE80211_S_ASSOC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_RUN */
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ic
operator|->
name|ic_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_dfs_ch
argument_list|)
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|leds
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* set LED */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
comment|/* 		 * NB: disable interrupts so we don't rx frames. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
name|HAL_INT_GLOBAL
argument_list|)
expr_stmt|;
comment|/* 		 * Notify the rate control algorithm. 		 */
name|ath_rate_newstate
argument_list|(
name|sc
argument_list|,
name|nstate
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|error
operator|=
name|ath_chan_set
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|rfilt
operator|=
name|ath_calcrxfilter
argument_list|(
name|sc
argument_list|,
name|nstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
name|bssid
operator|=
name|ifp
operator|->
name|if_broadcastaddr
expr_stmt|;
else|else
name|bssid
operator|=
name|ni
operator|->
name|ni_bssid
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s: RX filter 0x%x bssid %s\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ether_sprintf
argument_list|(
name|bssid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|bssid
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|bssid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ath_hal_keyisvalid
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
condition|)
name|ath_hal_keysetmac
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Notify the rate control algorithm so rates 	 * are setup should ath_beacon_alloc be called. 	 */
name|ath_rate_newstate
argument_list|(
name|sc
argument_list|,
name|nstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
block|{
comment|/* nothing to do */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"%s(RUN): ic_flags=0x%08x iv=%d bssid=%s "
literal|"capinfo=0x%04x chan=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_flags
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_IBSS
case|:
comment|/* 			 * Allocate and setup the beacon frame. 			 * 			 * Stop any previous beacon DMA.  This may be 			 * necessary, for example, when an ibss merge 			 * causes reconfiguration; there will be a state 			 * transition from RUN->RUN that means we may 			 * be called with beacon transmission active. 			 */
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|ath_beacon_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_beacon_alloc
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * If joining an adhoc network defer beacon timer 			 * configuration to the next beacon frame so we 			 * have a current TSF to use.  Otherwise we're 			 * starting an ibss/bss so there's no need to delay. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
else|else
name|ath_beacon_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_STA
case|:
comment|/* 			 * Allocate a key cache slot to the station. 			 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_hasclrkey
operator|&&
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
name|ath_setup_stationkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 			 * Defer beacon timer configuration to the next 			 * beacon frame so we have a current TSF to use 			 * (any TSF collected when scanning is likely old). 			 */
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Let the hal process statistics collected during a 		 * scan so it can provide calibrated noise floor data. 		 */
name|ath_hal_process_noisefloor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * Reset rssi stats; maybe not the best place... 		 */
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgtxrssi
operator|=
name|ATH_RSSI_DUMMY_MARKER
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
operator|&
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Invoke the parent method to complete the work. 	 */
name|error
operator|=
name|sc
operator|->
name|sc_newstate
argument_list|(
name|ic
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, start any timers. 	 */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* start periodic recalibration timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|sc
operator|->
name|sc_calinterval
operator|*
name|hz
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
comment|/* start ap/neighbor scan timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|,
operator|(
name|ath_dwelltime
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|,
name|ath_next_scan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a key cache slot to the station so we can  * setup a mapping from key index to node. The key cache  * slot is needed for managing antenna state and for  * compression when stations do not use crypto.  We do  * it uniliaterally here; if crypto is employed this slot  * will be reassigned.  */
end_comment

begin_function
specifier|static
name|void
name|ath_setup_stationkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|,
name|rxkeyix
decl_stmt|;
if|if
condition|(
operator|!
name|ath_key_alloc
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
operator|&
name|keyix
argument_list|,
operator|&
name|rxkeyix
argument_list|)
condition|)
block|{
comment|/* 		 * Key cache is full; we'll fall back to doing 		 * the more expensive lookup in software.  Note 		 * this also means no h/w compression. 		 */
comment|/* XXX msg+statistic */
block|}
else|else
block|{
comment|/* XXX locking? */
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|=
name|keyix
expr_stmt|;
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
operator|=
name|rxkeyix
expr_stmt|;
comment|/* NB: this will create a pass-thru key entry */
name|ath_keyset
argument_list|(
name|sc
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup driver-specific state for a newly associated node.  * Note that we're called also on a re-associate, the isnew  * param tells us if this is the first time or not.  */
end_comment

begin_function
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|ath_rate_newassoc
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|isnew
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_hasclrkey
condition|)
block|{
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|==
name|IEEE80211_KEYIX_NONE
argument_list|,
operator|(
literal|"new assoc with a unicast key already setup (keyix %u)"
operator|,
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|)
argument_list|)
expr_stmt|;
name|ath_setup_stationkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cc
parameter_list|,
name|HAL_BOOL
name|outdoor
parameter_list|,
name|HAL_BOOL
name|xchanmode
parameter_list|)
block|{
define|#
directive|define
name|COMPAT
value|(CHANNEL_ALL_NOTURBO|CHANNEL_PASSIVE)
define|#
directive|define
name|IS_CHAN_PUBLIC_SAFETY
parameter_list|(
name|_c
parameter_list|)
define|\
value|(((_c)->channelFlags& CHANNEL_5GHZ)&& \ 	 ((_c)->channel> 4940&& (_c)->channel< 4990))
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_CHANNEL
modifier|*
name|chans
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ix
decl_stmt|,
name|nchan
decl_stmt|;
name|chans
operator|=
name|malloc
argument_list|(
name|IEEE80211_CHAN_MAX
operator|*
sizeof|sizeof
argument_list|(
name|HAL_CHANNEL
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chans
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to allocate channel table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|!
name|ath_hal_init_channels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|nchan
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|cc
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|outdoor
argument_list|,
name|xchanmode
argument_list|)
condition|)
block|{
name|u_int32_t
name|rd
decl_stmt|;
name|ath_hal_getregdomain
argument_list|(
name|ah
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to collect channel list from hal; "
literal|"regdomain likely %u country code %u\n"
argument_list|,
name|rd
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chans
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Convert HAL channels to ieee80211 ones and insert 	 * them in the table according to their channel number. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|HAL_CHANNEL
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
comment|/* 		 * XXX we're not ready to handle the ieee number mapping 		 * for public safety channels as they overlap with any 		 * 2GHz channels; for now use the non-public safety 		 * numbering which is non-overlapping. 		 */
if|if
condition|(
name|IS_CHAN_PUBLIC_SAFETY
argument_list|(
name|c
argument_list|)
condition|)
name|ix
operator|=
operator|(
name|c
operator|->
name|channel
operator|-
literal|4000
operator|)
operator|/
literal|5
expr_stmt|;
else|else
name|ix
operator|=
name|ath_hal_mhz2ieee
argument_list|(
name|ah
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>
name|IEEE80211_CHAN_MAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bad hal channel %d (%u/%x) ignored\n"
argument_list|,
name|ix
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ix
operator|<
literal|0
condition|)
block|{
comment|/* XXX can't handle stuff<2400 right now */
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"hal channel %d (%u/%x) "
literal|"cannot be handled; ignored\n"
argument_list|,
name|ix
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Calculate net80211 flags; most are compatible 		 * but some need massaging.  Note the static turbo 		 * conversion can be removed once net80211 is updated 		 * to understand static vs. dynamic turbo. 		 */
name|flags
operator|=
name|c
operator|->
name|channelFlags
operator|&
name|COMPAT
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|channelFlags
operator|&
name|CHANNEL_STURBO
condition|)
name|flags
operator||=
name|IEEE80211_CHAN_TURBO
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_freq
operator|==
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_freq
operator|=
name|c
operator|->
name|channel
expr_stmt|;
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_flags
operator|=
name|flags
expr_stmt|;
block|}
else|else
block|{
comment|/* channels overlap; e.g. 11g and 11b */
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_flags
operator||=
name|flags
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|chans
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|IS_CHAN_PUBLIC_SAFETY
undef|#
directive|undef
name|COMPAT
block|}
end_function

begin_function
specifier|static
name|void
name|ath_led_done
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Turn the LED off: flip the pin and then set a timer so no  * update will happen for the specified duration.  */
end_comment

begin_function
specifier|static
name|void
name|ath_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|sc
operator|->
name|sc_ledoff
argument_list|,
name|ath_led_done
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Blink the LED according to the specified on/off times.  */
end_comment

begin_function
specifier|static
name|void
name|ath_led_blink
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_LED
argument_list|,
literal|"%s: on %u off %u\n"
argument_list|,
name|__func__
argument_list|,
name|on
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blinking
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ledoff
operator|=
name|off
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ledtimer
argument_list|,
name|on
argument_list|,
name|ath_led_off
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_led_event
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|sc
operator|->
name|sc_ledevent
operator|=
name|ticks
expr_stmt|;
comment|/* time of last event */
if|if
condition|(
name|sc
operator|->
name|sc_blinking
condition|)
comment|/* don't interrupt active blink */
return|return;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|ATH_LED_POLL
case|:
name|ath_led_blink
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
literal|0
index|]
operator|.
name|ledon
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
literal|0
index|]
operator|.
name|ledoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATH_LED_TX
case|:
name|ath_led_blink
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|sc
operator|->
name|sc_txrate
index|]
operator|.
name|ledon
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|sc
operator|->
name|sc_txrate
index|]
operator|.
name|ledoff
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATH_LED_RX
case|:
name|ath_led_blink
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|sc
operator|->
name|sc_rxrate
index|]
operator|.
name|ledon
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|sc
operator|->
name|sc_rxrate
index|]
operator|.
name|ledoff
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_update_txpow
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int32_t
name|txpow
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_curtxpow
operator|!=
name|ic
operator|->
name|ic_txpowlimit
condition|)
block|{
name|ath_hal_settxpowlimit
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_txpowlimit
argument_list|)
expr_stmt|;
comment|/* read back in case value is clamped */
name|ath_hal_gettxpowlimit
argument_list|(
name|ah
argument_list|,
operator|&
name|txpow
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_txpowlimit
operator|=
name|sc
operator|->
name|sc_curtxpow
operator|=
name|txpow
expr_stmt|;
block|}
comment|/*  	 * Fetch max tx power level for status requests. 	 */
name|ath_hal_getmaxtxpow
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|txpow
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|->
name|ni_txpower
operator|=
name|txpow
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|maxrates
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rateCount
operator|>
name|IEEE80211_RATE_MAXSIZE
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: rate table too small (%u> %u)\n"
argument_list|,
name|__func__
argument_list|,
name|rt
operator|->
name|rateCount
argument_list|,
name|IEEE80211_RATE_MAXSIZE
argument_list|)
expr_stmt|;
name|maxrates
operator|=
name|IEEE80211_RATE_MAXSIZE
expr_stmt|;
block|}
else|else
name|maxrates
operator|=
name|rt
operator|->
name|rateCount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxrates
condition|;
name|i
operator|++
control|)
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
expr_stmt|;
name|rs
operator|->
name|rs_nrates
operator|=
name|maxrates
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mode
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11A
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11B
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11B
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_A
case|:
comment|/* XXX until static/dynamic turbo is fixed */
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_TURBO
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO_G
case|:
name|rt
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_108G
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: invalid mode %u\n"
argument_list|,
name|__func__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|rt
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|rate_setup
argument_list|(
name|sc
argument_list|,
name|rt
argument_list|,
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
comment|/* NB: on/off times from the Atheros NDIS driver, w/ permission */
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|rate
decl_stmt|;
comment|/* tx/rx 802.11 rate */
name|u_int16_t
name|timeOn
decl_stmt|;
comment|/* LED on time (ms) */
name|u_int16_t
name|timeOff
decl_stmt|;
comment|/* LED off time (ms) */
block|}
name|blinkrates
index|[]
init|=
block|{
block|{
literal|108
block|,
literal|40
block|,
literal|10
block|}
block|,
block|{
literal|96
block|,
literal|44
block|,
literal|11
block|}
block|,
block|{
literal|72
block|,
literal|50
block|,
literal|13
block|}
block|,
block|{
literal|48
block|,
literal|57
block|,
literal|14
block|}
block|,
block|{
literal|36
block|,
literal|67
block|,
literal|16
block|}
block|,
block|{
literal|24
block|,
literal|80
block|,
literal|20
block|}
block|,
block|{
literal|22
block|,
literal|100
block|,
literal|25
block|}
block|,
block|{
literal|18
block|,
literal|133
block|,
literal|34
block|}
block|,
block|{
literal|12
block|,
literal|160
block|,
literal|40
block|}
block|,
block|{
literal|10
block|,
literal|200
block|,
literal|50
block|}
block|,
block|{
literal|6
block|,
literal|240
block|,
literal|58
block|}
block|,
block|{
literal|4
block|,
literal|267
block|,
literal|66
block|}
block|,
block|{
literal|2
block|,
literal|400
block|,
literal|100
block|}
block|,
block|{
literal|0
block|,
literal|500
block|,
literal|130
block|}
block|, 	}
struct|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no h/w rate set for phy mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_rixmap
index|[
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
index|]
operator|=
name|i
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|ix
init|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ix
operator|==
literal|0xff
condition|)
block|{
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
literal|500
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
literal|130
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
operator|=
name|rt
operator|->
name|info
index|[
name|ix
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator|=
name|IEEE80211_RADIOTAP_F_DATAPAD
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|ix
index|]
operator|.
name|shortPreamble
operator|||
name|rt
operator|->
name|info
index|[
name|ix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
condition|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTPRE
expr_stmt|;
comment|/* NB: receive frames include FCS */
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|rxflags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|txflags
operator||
name|IEEE80211_RADIOTAP_F_FCS
expr_stmt|;
comment|/* setup blink rate table to avoid per-packet lookup */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|N
argument_list|(
name|blinkrates
argument_list|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|rate
operator|==
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ieeerate
condition|)
break|break;
comment|/* NB: this uses the last entry if the rate isn't found */
comment|/* XXX beware of overlow */
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledon
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOn
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|.
name|ledoff
operator|=
operator|(
name|blinkrates
index|[
name|j
index|]
operator|.
name|timeOff
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
name|sc
operator|->
name|sc_currates
operator|=
name|rt
expr_stmt|;
name|sc
operator|->
name|sc_curmode
operator|=
name|mode
expr_stmt|;
comment|/* 	 * All protection frames are transmited at 2Mb/s for 	 * 11g, otherwise at 1Mb/s. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
literal|2
operator|*
literal|2
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_protrix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
literal|2
operator|*
literal|1
argument_list|)
expr_stmt|;
comment|/* rate index used to send management frames */
name|sc
operator|->
name|sc_minrateix
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Setup multicast rate state. 	 */
comment|/* XXX layering violation */
name|sc
operator|->
name|sc_mcastrix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|sc
operator|->
name|sc_ic
operator|.
name|ic_mcast_rate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mcastrate
operator|=
name|sc
operator|->
name|sc_ic
operator|.
name|ic_mcast_rate
expr_stmt|;
comment|/* NB: caller is responsible for reseting rate control state */
undef|#
directive|undef
name|N
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ath_printrxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"R[%2u] (DS.V:%p DS.P:%p) L:%08x D:%08x%s\n"
literal|"      %08x %08x %08x %08x\n"
argument_list|,
name|ix
argument_list|,
name|ds
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
operator|+
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
operator|!
name|done
condition|?
literal|""
else|:
operator|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|==
literal|0
operator|)
condition|?
literal|" *"
else|:
literal|" !"
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_printtxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|u_int
name|qnum
parameter_list|,
name|u_int
name|ix
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Q%u[%3u]"
argument_list|,
name|qnum
argument_list|,
name|ix
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" (DS.V:%p DS.P:%p) L:%08x D:%08x F:04%x%s\n"
literal|"        %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|ds
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
operator|+
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|bf
operator|->
name|bf_flags
argument_list|,
operator|!
name|done
condition|?
literal|""
else|:
operator|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|" *"
else|:
literal|" !"
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|2
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DEBUG */
end_comment

begin_function
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_watchdog
operator|++
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
name|ieee80211_watchdog
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DIAGAPI
end_ifdef

begin_comment
comment|/*  * Diagnostic interface to the HAL.  This is used by various  * tools to do things like retrieve register contents for  * debugging.  The mechanism is intentionally opaque so that  * it can change frequently w/o concern for compatiblity.  */
end_comment

begin_function
specifier|static
name|int
name|ath_ioctl_diag
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_diag
modifier|*
name|ad
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|id
init|=
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_ID
decl_stmt|;
name|void
modifier|*
name|indata
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|outdata
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|insize
init|=
name|ad
operator|->
name|ad_in_size
decl_stmt|;
name|u_int32_t
name|outsize
init|=
name|ad
operator|->
name|ad_out_size
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_IN
condition|)
block|{
comment|/* 		 * Copy in data. 		 */
name|indata
operator|=
name|malloc
argument_list|(
name|insize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|indata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|ad
operator|->
name|ad_in_data
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_DYN
condition|)
block|{
comment|/* 		 * Allocate a buffer for the results (otherwise the HAL 		 * returns a pointer to a buffer where we can read the 		 * results).  Note that we depend on the HAL leaving this 		 * pointer for us to use below in reclaiming the buffer; 		 * may want to be more defensive. 		 */
name|outdata
operator|=
name|malloc
argument_list|(
name|outsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|ath_hal_getdiagstate
argument_list|(
name|ah
argument_list|,
name|id
argument_list|,
name|indata
argument_list|,
name|insize
argument_list|,
operator|&
name|outdata
argument_list|,
operator|&
name|outsize
argument_list|)
condition|)
block|{
if|if
condition|(
name|outsize
operator|<
name|ad
operator|->
name|ad_out_size
condition|)
name|ad
operator|->
name|ad_out_size
operator|=
name|outsize
expr_stmt|;
if|if
condition|(
name|outdata
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|outdata
argument_list|,
name|ad
operator|->
name|ad_out_data
argument_list|,
name|ad
operator|->
name|ad_out_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
operator|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_IN
operator|)
operator|&&
name|indata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|indata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ad
operator|->
name|ad_id
operator|&
name|ATH_DIAG_DYN
operator|)
operator|&&
name|outdata
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|outdata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DIAGAPI */
end_comment

begin_function
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
define|#
directive|define
name|IS_RUNNING
parameter_list|(
name|ifp
parameter_list|)
define|\
value|((ifp->if_flags& IFF_UP)&& (ifp->if_drv_flags& IFF_DRV_RUNNING))
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* 			 * To avoid rescanning another access point, 			 * do not call ath_init() here.  Instead, 			 * only reflect promisc mode settings. 			 */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * Beware of being called during attach/detach 			 * to reset promiscuous mode.  In that case we 			 * will still be marked UP but not RUNNING. 			 * However trying to re-init the interface 			 * is the wrong thing to do as we've already 			 * torn down much of our state.  There's 			 * probably a better way to deal with this. 			 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
operator|&&
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
block|}
else|else
name|ath_stop_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * The upper layer has already installed/removed 		 * the multicast address(es), just recalculate the 		 * multicast filter for the card. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGATHSTATS
case|:
comment|/* NB: embed these numbers to get a consistent view */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_packets
operator|=
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_packets
operator|=
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_rssi
operator|=
name|ieee80211_getrssi
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_noise
operator|=
name|ath_hal_getchannoise
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|sc
operator|->
name|sc_txrate
index|]
operator|.
name|ieeerate
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * NB: Drop the softc lock in case of a page fault; 		 * we'll accept any potential inconsisentcy in the 		 * statistics.  The alternative is to copy the data 		 * to a local structure. 		 */
return|return
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|ATH_DIAGAPI
case|case
name|SIOCGATHDIAG
case|:
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_ioctl_diag
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|ath_diag
operator|*
operator|)
name|ifr
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ieee80211_ioctl
argument_list|(
name|ic
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
if|if
condition|(
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
operator|&&
name|ic
operator|->
name|ic_roaming
operator|!=
name|IEEE80211_ROAMING_MANUAL
condition|)
name|ath_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|IS_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|?
name|ath_reset
argument_list|(
name|ifp
argument_list|)
else|:
literal|0
expr_stmt|;
break|break;
block|}
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|IS_RUNNING
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_slottime
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|slottime
init|=
name|ath_hal_getslottime
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|slottime
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setslottime
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|slottime
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_acktimeout
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|acktimeout
init|=
name|ath_hal_getacktimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|acktimeout
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setacktimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|acktimeout
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_ctstimeout
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|ctstimeout
init|=
name|ath_hal_getctstimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ctstimeout
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setctstimeout
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|ctstimeout
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_softled
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|softled
init|=
name|sc
operator|->
name|sc_softled
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|softled
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|softled
operator|=
operator|(
name|softled
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|softled
operator|!=
name|sc
operator|->
name|sc_softled
condition|)
block|{
if|if
condition|(
name|softled
condition|)
block|{
comment|/* NB: handle any sc_ledpin change */
name|ath_hal_gpioCfgOutput
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|)
expr_stmt|;
name|ath_hal_gpioset
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_ledpin
argument_list|,
operator|!
name|sc
operator|->
name|sc_ledon
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_softled
operator|=
name|softled
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_rxantenna
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|defantenna
init|=
name|ath_hal_getdefantenna
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|defantenna
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|req
operator|->
name|newptr
condition|)
name|ath_hal_setdefantenna
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|defantenna
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_diversity
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|diversity
init|=
name|ath_hal_getdiversity
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|diversity
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|ath_hal_setdiversity
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|diversity
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|sc_diversity
operator|=
name|diversity
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_diag
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|diag
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getdiag
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|diag
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|diag
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setdiag
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|diag
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpscale
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|u_int32_t
name|scale
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ath_hal_gettpscale
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|scale
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|scale
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpscale
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|scale
argument_list|)
condition|?
name|EINVAL
else|:
name|ath_reset
argument_list|(
name|ifp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|tpc
init|=
name|ath_hal_gettpc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tpc
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tpc
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_rfkill
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|rfkill
init|=
name|ath_hal_getrfkill
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rfkill
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
name|rfkill
operator|==
name|ath_hal_getrfkill
argument_list|(
name|ah
argument_list|)
condition|)
comment|/* unchanged */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ath_hal_setrfkill
argument_list|(
name|ah
argument_list|,
name|rfkill
argument_list|)
operator|||
name|ath_reset
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_rfsilent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int
name|rfsilent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ath_hal_getrfsilent
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|rfsilent
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rfsilent
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|ath_hal_setrfsilent
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rfsilent
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|sc_rfsilentpin
operator|=
name|rfsilent
operator|&
literal|0x1c
expr_stmt|;
name|sc
operator|->
name|sc_rfsilentpol
operator|=
operator|(
name|rfsilent
operator|&
literal|0x2
operator|)
operator|!=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_regdomain
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|rd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|ath_hal_getregdomain
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|rd
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|rd
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_setregdomain
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rd
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpack
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|tpack
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ath_hal_gettpack
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|tpack
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tpack
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpack
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tpack
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_sysctl_tpcts
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|u_int32_t
name|tpcts
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ath_hal_gettpcts
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|tpcts
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|tpcts
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
return|return
operator|!
name|ath_hal_settpcts
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|tpcts
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_sysctlattach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ath_hal_getcountrycode
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_countrycode
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"countrycode"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|sc_countrycode
argument_list|,
literal|0
argument_list|,
literal|"EEPROM country code"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"regdomain"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_regdomain
argument_list|,
literal|"I"
argument_list|,
literal|"EEPROM regdomain code"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|sc
operator|->
name|sc_debug
operator|=
name|ath_debug
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"slottime"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_slottime
argument_list|,
literal|"I"
argument_list|,
literal|"802.11 slot time (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"acktimeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_acktimeout
argument_list|,
literal|"I"
argument_list|,
literal|"802.11 ACK timeout (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ctstimeout"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_ctstimeout
argument_list|,
literal|"I"
argument_list|,
literal|"802.11 CTS timeout (us)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"softled"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_softled
argument_list|,
literal|"I"
argument_list|,
literal|"enable/disable software LED support"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ledpin"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_ledpin
argument_list|,
literal|0
argument_list|,
literal|"GPIO pin connected to LED"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ledon"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_ledon
argument_list|,
literal|0
argument_list|,
literal|"setting to turn LED on"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ledidle"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_ledidle
argument_list|,
literal|0
argument_list|,
literal|"idle time for inactivity LED (ticks)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txantenna"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_txantenna
argument_list|,
literal|0
argument_list|,
literal|"tx antenna (0=auto)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxantenna"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_rxantenna
argument_list|,
literal|"I"
argument_list|,
literal|"default/rx antenna"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_hasdiversity
argument_list|(
name|ah
argument_list|)
condition|)
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"diversity"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_diversity
argument_list|,
literal|"I"
argument_list|,
literal|"antenna diversity"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txintrperiod
operator|=
name|ATH_TXINTR_PERIOD
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txintrperiod"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_txintrperiod
argument_list|,
literal|0
argument_list|,
literal|"tx descriptor batching"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"diag"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_diag
argument_list|,
literal|"I"
argument_list|,
literal|"h/w diagnostic control"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpscale"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpscale
argument_list|,
literal|"I"
argument_list|,
literal|"tx power scaling"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_hastpc
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpc"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpc
argument_list|,
literal|"I"
argument_list|,
literal|"enable/disable per-packet TPC"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpack"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpack
argument_list|,
literal|"I"
argument_list|,
literal|"tx power for ack frames"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tpcts"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_tpcts
argument_list|,
literal|"I"
argument_list|,
literal|"tx power for cts frames"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_hal_hasrfsilent
argument_list|(
name|ah
argument_list|)
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rfsilent"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_rfsilent
argument_list|,
literal|"I"
argument_list|,
literal|"h/w RF silent config"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rfkill"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|ath_sysctl_rfkill
argument_list|,
literal|"I"
argument_list|,
literal|"enable/disable RF kill switch"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_monpass
operator|=
name|HAL_RXERR_DECRYPT
operator||
name|HAL_RXERR_MIC
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"monpass"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|sc_monpass
argument_list|,
literal|0
argument_list|,
literal|"mask of error frames to pass when monitoring"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bpfattach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|bpfattach2
argument_list|(
name|ifp
argument_list|,
name|DLT_IEEE802_11_RADIO
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_drvbpf
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize constant fields. 	 * XXX make header lengths a multiple of 32-bits so subsequent 	 *     headers are properly aligned; this is a kludge to keep 	 *     certain applications happy. 	 * 	 * NB: the channel is setup each time we transition to the 	 *     RUN state to avoid filling it in for each frame. 	 */
name|sc
operator|->
name|sc_tx_th_len
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
operator|.
name|it_len
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|sc_tx_th_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
operator|.
name|it_present
operator|=
name|htole32
argument_list|(
name|ATH_TX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th_len
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
operator|.
name|it_len
operator|=
name|htole16
argument_list|(
name|sc
operator|->
name|sc_rx_th_len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
operator|.
name|it_present
operator|=
name|htole32
argument_list|(
name|ATH_RX_RADIOTAP_PRESENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_raw_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ismcast
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|,
name|txantenna
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|cix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|,
name|rate1
decl_stmt|,
name|rate2
decl_stmt|,
name|rate3
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
comment|/* XXX honor IEEE80211_BPF_DATAPAD */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
comment|/* XXX leave ismcast to injector? */
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|||
name|ismcast
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|sc
operator|->
name|sc_txrate
operator|=
name|txrate
expr_stmt|;
name|try0
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|ismrr
operator|=
operator|(
name|params
operator|->
name|ibp_try1
operator|!=
literal|0
operator|)
expr_stmt|;
name|txantenna
operator|=
name|params
operator|->
name|ibp_pri
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|txantenna
operator|==
literal|0
condition|)
comment|/* XXX? */
name|txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_CTSENA
operator||
name|HAL_TXDESC_RTSENA
operator|)
condition|)
block|{
name|cix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|params
operator|->
name|ibp_ctsrate
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
block|{
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
name|pri
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
comment|/* 	 * NB: we mark all packets as type PSPOLL so the h/w won't 	 * set the sequence number, duration, etc. 	 */
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|txrate
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ic
operator|->
name|ic_rawbpf
argument_list|)
condition|)
name|bpf_mtap
argument_list|(
name|ic
operator|->
name|ic_rawbpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|txrate
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|txrate
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|,
operator|&
name|sc
operator|->
name|sc_tx_th
argument_list|,
name|sc
operator|->
name|sc_tx_th_len
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* XXX check return value? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
name|params
operator|->
name|ibp_power
comment|/* txpower */
argument_list|,
name|txrate
argument_list|,
name|try0
comment|/* series 0 rate/tries */
argument_list|,
name|HAL_TXKEYIX_INVALID
comment|/* key cache index */
argument_list|,
name|txantenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|ismrr
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|params
operator|->
name|ibp_rate1
argument_list|)
expr_stmt|;
name|rate1
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate1
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_try2
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|params
operator|->
name|ibp_rate2
argument_list|)
expr_stmt|;
name|rate2
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate2
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
block|}
else|else
name|rate2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_try3
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|rt
argument_list|,
name|params
operator|->
name|ibp_rate3
argument_list|)
expr_stmt|;
name|rate3
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate3
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
block|}
else|else
name|rate3
operator|=
literal|0
expr_stmt|;
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|rate1
argument_list|,
name|params
operator|->
name|ibp_try1
comment|/* series 1 */
argument_list|,
name|rate2
argument_list|,
name|params
operator|->
name|ibp_try2
comment|/* series 2 */
argument_list|,
name|rate3
argument_list|,
name|params
operator|->
name|ibp_try3
comment|/* series 3 */
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * When servicing one or more stations in power-save mode 	 * (or) if there is some mcast data waiting on the mcast 	 * queue (to prevent out of order delivery) multicast 	 * frames must be buffered until after the beacon. 	 */
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
if|if
condition|(
name|ismcast
operator|&&
operator|(
name|ic
operator|->
name|ic_ps_sta
operator|||
name|sc
operator|->
name|sc_mcastq
operator|.
name|axq_depth
operator|)
condition|)
name|txq
operator|=
operator|&
name|sc
operator|->
name|sc_mcastq
expr_stmt|;
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: out of xmit buffers\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw
operator|++
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
if|if
condition|(
name|ath_tx_raw_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
end_function

begin_comment
comment|/*  * Announce various information on device/driver attach.  */
end_comment

begin_function
specifier|static
name|void
name|ath_announce
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|HAL_MODE_DUALBAND
value|(HAL_MODE_11A|HAL_MODE_11B)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|u_int
name|modes
decl_stmt|,
name|cc
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"mac %d.%d phy %d.%d"
argument_list|,
name|ah
operator|->
name|ah_macVersion
argument_list|,
name|ah
operator|->
name|ah_macRev
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_phyRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|/* 	 * Print radio revision(s).  We check the wireless modes 	 * to avoid falsely printing revs for inoperable parts. 	 * Dual-band radio revs are returned in the 5Ghz rev number. 	 */
name|ath_hal_getcountrycode
argument_list|(
name|ah
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
name|modes
operator|=
name|ath_hal_getwirelessmodes
argument_list|(
name|ah
argument_list|,
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|modes
operator|&
name|HAL_MODE_DUALBAND
operator|)
operator|==
name|HAL_MODE_DUALBAND
condition|)
block|{
if|if
condition|(
name|ah
operator|->
name|ah_analog5GhzRev
operator|&&
name|ah
operator|->
name|ah_analog2GhzRev
condition|)
name|printf
argument_list|(
literal|" 5ghz radio %d.%d 2ghz radio %d.%d"
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
operator|&
literal|0xf
argument_list|,
name|ah
operator|->
name|ah_analog2GhzRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_analog2GhzRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" radio %d.%d"
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" radio %d.%d"
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
operator|>>
literal|4
argument_list|,
name|ah
operator|->
name|ah_analog5GhzRev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|WME_AC_VO
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|i
index|]
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for %s traffic\n"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for CAB traffic\n"
argument_list|,
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Use hw queue %u for beacons\n"
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_rxbuf
operator|!=
name|ATH_RXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u rx buffers\n"
argument_list|,
name|ath_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_txbuf
operator|!=
name|ATH_TXBUF
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"using %u tx buffers\n"
argument_list|,
name|ath_txbuf
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|HAL_MODE_DUALBAND
block|}
end_function

end_unit

