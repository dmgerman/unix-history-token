begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  * 3. Neither the names of the above-listed copyright holders nor the names  *    of any contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AR_DEBUG
end_define

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/ath/ah_desc.h>
end_include

begin_comment
comment|/* unalligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int16_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8)))
end_define

begin_define
define|#
directive|define
name|LE_READ_4
parameter_list|(
name|p
parameter_list|)
define|\
value|((u_int32_t)							\ 	 ((((u_int8_t *)(p))[0]      ) | (((u_int8_t *)(p))[1]<<  8) |	\ 	  (((u_int8_t *)(p))[2]<< 16) | (((u_int8_t *)(p))[3]<< 24)))
end_define

begin_function_decl
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_reset
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rxorn_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_initkeytable
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_node_copy
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|ath_node_getrssi
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ath_buf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_next_scan
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|u_int
name|cc
parameter_list|,
name|HAL_BOOL
name|outdoor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_phymode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rate_ctl_reset
parameter_list|(
name|struct
name|ath_softc
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_rate_ctl
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_ath
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX validate sysctl values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ath_dwelltime
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5 channels/second */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|dwell
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_dwelltime
argument_list|,
literal|0
argument_list|,
literal|"channel dwell time (ms) for AP/station scanning"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_calinterval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calibrate every 30 secs */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|calibrate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_calinterval
argument_list|,
literal|0
argument_list|,
literal|"chip calibration interval (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_outdoor
init|=
name|AH_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* outdoor operation */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|outdoor
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_outdoor
argument_list|,
literal|0
argument_list|,
literal|"enable/disable outdoor operation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_countrycode
init|=
name|CTRY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* country code */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|countrycode
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_countrycode
argument_list|,
literal|0
argument_list|,
literal|"country code"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ath_regdomain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regulatory domain */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|regdomain
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ath_regdomain
argument_list|,
literal|0
argument_list|,
literal|"regulatory domain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AR_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ath_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ath_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|IFF_DUMPPKTS
parameter_list|(
name|_ifp
parameter_list|)
define|\
value|(ath_debug || \ 	    ((_ifp)->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_function_decl
specifier|static
name|void
name|ath_printrxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ath_printtxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|X
parameter_list|)
value|if (ath_debug) printf X
end_define

begin_define
define|#
directive|define
name|DPRINTF2
parameter_list|(
name|X
parameter_list|)
value|if (ath_debug> 1) printf X
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFF_DUMPPKTS
parameter_list|(
name|_ifp
parameter_list|)
define|\
value|(((_ifp)->if_flags& (IFF_DEBUG|IFF_LINK2)) == (IFF_DEBUG|IFF_LINK2))
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|X
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTF2
parameter_list|(
name|X
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ath_attach
parameter_list|(
name|u_int16_t
name|devid
parameter_list|,
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_attach: devid 0x%x\n"
operator|,
name|devid
operator|)
argument_list|)
expr_stmt|;
comment|/* set these up early for if_printf use */
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ath"
expr_stmt|;
name|ah
operator|=
name|ath_hal_attach
argument_list|(
name|devid
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to attach hardware; HAL status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_ah
operator|=
name|ah
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|0
expr_stmt|;
comment|/* ready to go, enable interrupt handling */
comment|/* 	 * Collect the channel list using the default country 	 * code and including outdoor channels.  The 802.11 layer 	 * is resposible for filtering this list based on settings 	 * like the phy mode. 	 */
name|error
operator|=
name|ath_getchannels
argument_list|(
name|sc
argument_list|,
name|ath_countrycode
argument_list|,
name|ath_outdoor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Copy these back; they are set as a side effect 	 * of constructing the channel list. 	 */
name|ath_regdomain
operator|=
name|ath_hal_getregdomain
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ath_countrycode
operator|=
name|ath_hal_getcountrycode
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 	 * Setup rate tables for all potential media types. 	 */
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
name|ath_rate_setup
argument_list|(
name|sc
argument_list|,
name|IEEE80211_MODE_TURBO
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_desc_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to allocate descriptors: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"xmit buf q"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"xmit q"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|,
literal|0
argument_list|,
name|ath_tx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|,
literal|0
argument_list|,
name|ath_rx_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_swbatask
argument_list|,
literal|0
argument_list|,
name|ath_beacon_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxorntask
argument_list|,
literal|0
argument_list|,
name|ath_rxorn_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_fataltask
argument_list|,
literal|0
argument_list|,
name|ath_fatal_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|,
literal|0
argument_list|,
name|ath_bmiss_proc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * For now just pre-allocate one data queue and one 	 * beacon queue.  Note that the HAL handles resetting 	 * them at the needed time.  Eventually we'll want to 	 * allocate more tx queues for splitting management 	 * frames and for QOS support. 	 */
name|sc
operator|->
name|sc_txhalq
operator|=
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|HAL_TX_QUEUE_DATA
argument_list|,
name|AH_TRUE
comment|/* enable interrupts */
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txhalq
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup a data xmit queue!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_bhalq
operator|=
name|ath_hal_setuptxqueue
argument_list|(
name|ah
argument_list|,
name|HAL_TX_QUEUE_BEACON
argument_list|,
name|AH_TRUE
comment|/* enable interrupts */
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bhalq
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to setup a beacon xmit queue!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ath_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ath_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ath_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ath_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ic
operator|->
name|ic_softc
operator|=
name|sc
expr_stmt|;
name|ic
operator|->
name|ic_newassoc
operator|=
name|ath_newassoc
expr_stmt|;
comment|/* XXX not right but it's not used anywhere important */
name|ic
operator|->
name|ic_phytype
operator|=
name|IEEE80211_T_OFDM
expr_stmt|;
name|ic
operator|->
name|ic_opmode
operator|=
name|IEEE80211_M_STA
expr_stmt|;
name|ic
operator|->
name|ic_caps
operator|=
name|IEEE80211_C_WEP
operator||
name|IEEE80211_C_IBSS
operator||
name|IEEE80211_C_HOSTAP
operator||
name|IEEE80211_C_MONITOR
operator||
name|IEEE80211_C_SHPREAMBLE
expr_stmt|;
comment|/* get mac address from hardware */
name|ath_hal_getmac
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
comment|/* call MI attach routine. */
name|ieee80211_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* override default methods */
name|ic
operator|->
name|ic_node_alloc
operator|=
name|ath_node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|ath_node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_copy
operator|=
name|ath_node_copy
expr_stmt|;
name|ic
operator|->
name|ic_node_getrssi
operator|=
name|ath_node_getrssi
expr_stmt|;
name|sc
operator|->
name|sc_newstate
operator|=
name|ic
operator|->
name|ic_newstate
expr_stmt|;
name|ic
operator|->
name|ic_newstate
operator|=
name|ath_newstate
expr_stmt|;
comment|/* complete initialization */
name|ieee80211_media_init
argument_list|(
name|ifp
argument_list|,
name|ath_media_change
argument_list|,
name|ieee80211_media_status
argument_list|)
expr_stmt|;
name|bpfattach2
argument_list|(
name|ifp
argument_list|,
name|DLT_IEEE802_11_RADIO
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_drvbpf
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize constant fields. 	 * 	 * NB: the channel is setup each time we transition to the 	 *     RUN state to avoid filling it in for each frame. 	 */
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
operator|.
name|it_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_ihdr
operator|.
name|it_present
operator|=
name|ATH_TX_RADIOTAP_PRESENT
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
operator|.
name|it_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ihdr
operator|.
name|it_present
operator|=
name|ATH_RX_RADIOTAP_PRESENT
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"802.11 address: %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ic
operator|->
name|ic_myaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
name|ah
condition|)
name|ath_hal_detach
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_invalid
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ath_detach
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_ic
operator|.
name|ic_if
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_detach: if_flags %x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ath_desc_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_detach
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
name|ieee80211_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ath_suspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_ic
operator|.
name|ic_if
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_suspend: if_flags %x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_ic
operator|.
name|ic_if
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_resume: if_flags %x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|ath_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ath_shutdown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_ic
operator|.
name|ic_if
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_shutdown: if_flags %x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_INT
name|status
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* 		 * The hardware is not ready/present, don't touch anything. 		 * Note this can happen early on if the IRQ is shared. 		 */
name|DPRINTF
argument_list|(
operator|(
literal|"ath_intr: invalid; ignored\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
operator|)
operator|!=
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_intr: if_flags 0x%x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable further intr's */
return|return;
block|}
name|ath_hal_getisr
argument_list|(
name|ah
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* NB: clears ISR too */
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_intr: status 0x%x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AR_DEBUG
if|if
condition|(
name|ath_debug
operator|&&
operator|(
name|status
operator|&
operator|(
name|HAL_INT_FATAL
operator||
name|HAL_INT_RXORN
operator||
name|HAL_INT_BMISS
operator|)
operator|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"ath_intr: status 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ath_hal_dumpstate
argument_list|(
name|ah
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AR_DEBUG */
name|status
operator|&=
name|sc
operator|->
name|sc_imask
expr_stmt|;
comment|/* discard unasked for bits */
if|if
condition|(
name|status
operator|&
name|HAL_INT_FATAL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_hardware
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_fataltask
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXORN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxorn
operator|++
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable intr's until reset */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxorntask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|HAL_INT_RXEOL
condition|)
block|{
comment|/* 			 * NB: the hardware should re-read the link when 			 *     RXE bit is written, but it doesn't work at 			 *     least on older hardware revs. 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rxeol
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_TXURN
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_txurn
operator|++
expr_stmt|;
comment|/* bump tx trigger level */
name|ath_hal_updatetxtriglevel
argument_list|(
name|ah
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|HAL_INT_RX
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_TX
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_txtask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_SWBA
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_swbatask
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|HAL_INT_BMISS
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_bmiss
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_bmisstask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_fatal_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"hardware error; resetting\n"
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rxorn_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"rx FIFO overrun; resetting\n"
argument_list|)
expr_stmt|;
name|ath_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_bmiss_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_bmiss_proc: pending %u\n"
operator|,
name|pending
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"unexpect operating mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|ath_chan2flags
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
specifier|static
specifier|const
name|u_int
name|modeflags
index|[]
init|=
block|{
literal|0
block|,
comment|/* IEEE80211_MODE_AUTO */
name|CHANNEL_A
block|,
comment|/* IEEE80211_MODE_11A */
name|CHANNEL_B
block|,
comment|/* IEEE80211_MODE_11B */
name|CHANNEL_PUREG
block|,
comment|/* IEEE80211_MODE_11G */
name|CHANNEL_T
comment|/* IEEE80211_MODE_TURBO */
block|}
decl_stmt|;
return|return
name|modeflags
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ath_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|HAL_CHANNEL
name|hchan
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_init: if_flags 0x%x\n"
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Stop anything previously setup.  This is safe 	 * whether this is the first time through or not. 	 */
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * The basic interface to setting the hardware in a good 	 * state is ``reset''.  On return the hardware is known to 	 * be powered up and with interrupts disabled.  This must 	 * be followed by initialization of the appropriate bits 	 * and then setup of the interrupt mask. 	 */
name|hchan
operator|.
name|channel
operator|=
name|ic
operator|->
name|ic_ibss_chan
operator|->
name|ic_freq
expr_stmt|;
name|hchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_ibss_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|,
operator|&
name|hchan
argument_list|,
name|AH_FALSE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to reset hardware; hal status %u\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Setup the hardware after reset: the key cache 	 * is filled as needed and the receive engine is 	 * set going.  Frame transmit is handled entirely 	 * in the frame output path; there's nothing to do 	 * here except setup the interrupt mask. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
name|ath_initkeytable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to start recv logic\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Enable interrupts. 	 */
name|sc
operator|->
name|sc_imask
operator|=
name|HAL_INT_RX
operator||
name|HAL_INT_TX
operator||
name|HAL_INT_RXEOL
operator||
name|HAL_INT_RXORN
operator||
name|HAL_INT_FATAL
operator||
name|HAL_INT_GLOBAL
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ic
operator|->
name|ic_state
operator|=
name|IEEE80211_S_INIT
expr_stmt|;
comment|/* 	 * The hardware should be ready to go now so it's safe 	 * to kick the 802.11 state machine as it's likely to 	 * immediately call back to us to send mgmt frames. 	 */
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|ic
operator|->
name|ic_ibss_chan
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|sc
operator|->
name|sc_curmode
condition|)
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_MONITOR
condition|)
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|(
expr|struct
name|ieee80211com
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_stop: invalid %u if_flags 0x%x\n"
operator|,
name|sc
operator|->
name|sc_invalid
operator|,
name|ifp
operator|->
name|if_flags
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
comment|/* 		 * Shutdown the hardware and driver: 		 *    disable interrupts 		 *    turn off timers 		 *    clear transmit machinery 		 *    clear receive machinery 		 *    drain and release tx queues 		 *    reclaim beacon resources 		 *    reset 802.11 state machine 		 *    power down hardware 		 * 		 * Note that some of this work is not possible if the 		 * hardware is gone (invalid). 		 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ath_beacon_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
name|ath_hal_setpower
argument_list|(
name|ah
argument_list|,
name|HAL_PM_FULL_SLEEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the hardware w/o losing operational state.  This is  * basically a more efficient way of doing ath_stop, ath_init,  * followed by state transitions to the current 802.11  * operational state.  Used to recover from errors rx overrun  * and to reset the hardware when rf gain settings must be reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_reset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|HAL_CHANNEL
name|hchan
decl_stmt|;
comment|/* 	 * Convert to a HAL channel description with the flags 	 * constrained to reflect the current operating mode. 	 */
name|c
operator|=
name|ic
operator|->
name|ic_ibss_chan
expr_stmt|;
name|hchan
operator|.
name|channel
operator|=
name|c
operator|->
name|ic_freq
expr_stmt|;
name|hchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop xmit side */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop recv side */
comment|/* NB: indicate channel change so we do a full reset */
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|,
operator|&
name|hchan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to reset hardware; hal status %u\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* restart recv */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: unable to start recv logic\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* restart xmit */
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|ath_beacon_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* restart beacons */
block|}
end_function

begin_function
specifier|static
name|void
name|ath_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Grab a TX buffer and associated resources. 		 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_start: out of xmit buffers\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_qstop
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Poll the management queue for frames; they 		 * have priority over normal data frames. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No data frames go out unless we're associated. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_start: ignore data packet, "
literal|"state %u\n"
operator|,
name|ic
operator|->
name|ic_state
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_discard
operator|++
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
break|break;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
break|break;
block|}
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * Encapsulate the packet in prep for transmission. 			 */
name|m
operator|=
name|ieee80211_encap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_start: encapsulation failure\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_encap
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_WEP
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Hack!  The referenced node pointer is in the 			 * rcvif field of the packet header.  This is 			 * placed there by ieee80211_mgmt_output because 			 * we need to hold the reference with the frame 			 * and there's no other way (other than packet 			 * tags which we consider too expensive to use) 			 * to pass it along. 			 */
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
block|{
comment|/* fill time stamp */
name|u_int64_t
name|tsf
decl_stmt|;
name|u_int32_t
modifier|*
name|tstamp
decl_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* XXX: adjust 100us delay to xmit */
name|tsf
operator|+=
literal|100
expr_stmt|;
name|tstamp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
expr_stmt|;
name|tstamp
index|[
literal|0
index|]
operator|=
name|htole32
argument_list|(
name|tsf
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|tstamp
index|[
literal|1
index|]
operator|=
name|htole32
argument_list|(
name|tsf
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_mgmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_rawbpf
condition|)
name|bpf_mtap
argument_list|(
name|ic
operator|->
name|ic_rawbpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_drvbpf
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|MGETHDR
argument_list|(
name|mb
argument_list|,
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|ni
operator|->
name|ni_txrate
index|]
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mb
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_tx_th
expr_stmt|;
name|mb
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tx_th
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mb
operator|->
name|m_len
expr_stmt|;
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|bad
label|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|ni
operator|&&
name|ni
operator|!=
name|ic
operator|->
name|ic_bss
condition|)
name|ieee80211_free_node
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ieee80211_media_change
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
operator|)
operator|==
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
condition|)
name|ath_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|sc_tx_timer
condition|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_tx_timer
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"device timeout\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AR_DEBUG
if|if
condition|(
name|ath_debug
condition|)
name|ath_hal_dumpstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AR_DEBUG */
name|ath_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX ath_reset??? */
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_watchdog
operator|++
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_fixed_rate
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Run the rate control algorithm if we're not 		 * locked at a fixed rate. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ath_rate_ctl
argument_list|(
name|sc
argument_list|,
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
else|else
name|ieee80211_iterate_nodes
argument_list|(
name|ic
argument_list|,
name|ath_rate_ctl
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|ieee80211_watchdog
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
comment|/* 				 * To avoid rescanning another access point, 				 * do not call ath_init() here.  Instead, 				 * only reflect promisc mode settings. 				 */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|ath_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
block|}
else|else
name|ath_stop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * The upper layer has already installed/removed 		 * the multicast address(es), just recalculate the 		 * multicast filter for the card. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGATHSTATS
case|:
name|copyout
argument_list|(
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ieee80211_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
operator|)
operator|==
operator|(
name|IFF_RUNNING
operator||
name|IFF_UP
operator|)
condition|)
name|ath_init
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX lose error */
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Fill the hardware key cache with key entries.  */
end_comment

begin_function
specifier|static
name|void
name|ath_initkeytable
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_wepkey
modifier|*
name|k
init|=
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_len
operator|==
literal|0
condition|)
name|ath_hal_keyreset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
comment|/* XXX return value */
comment|/* NB: this uses HAL_KEYVAL == ieee80211_wepkey */
name|ath_hal_keyset
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
operator|(
specifier|const
name|HAL_KEYVAL
operator|*
operator|)
name|k
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_mode_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|,
name|mfilt
index|[
literal|2
index|]
decl_stmt|,
name|val
decl_stmt|;
name|u_int8_t
name|pos
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
comment|/* configure operational mode */
name|ath_hal_setopmode
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|)
expr_stmt|;
comment|/* receive filter */
name|rfilt
operator|=
operator|(
name|ath_hal_getrxfilter
argument_list|(
name|ah
argument_list|)
operator|&
name|HAL_RX_FILTER_PHYERR
operator|)
operator||
name|HAL_RX_FILTER_UCAST
operator||
name|HAL_RX_FILTER_BCAST
operator||
name|HAL_RX_FILTER_MCAST
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROBEREQ
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_SCAN
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
comment|/* calculate and install multicast filter */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|==
literal|0
condition|)
block|{
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
name|caddr_t
name|dl
decl_stmt|;
comment|/* calculate XOR of eight 6bit values */
name|dl
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|0
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|val
operator|=
name|LE_READ_4
argument_list|(
name|dl
operator|+
literal|3
argument_list|)
expr_stmt|;
name|pos
operator|^=
operator|(
name|val
operator|>>
literal|18
operator|)
operator|^
operator|(
name|val
operator|>>
literal|12
operator|)
operator|^
operator|(
name|val
operator|>>
literal|6
operator|)
operator|^
name|val
expr_stmt|;
name|pos
operator|&=
literal|0x3f
expr_stmt|;
name|mfilt
index|[
name|pos
operator|/
literal|32
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pos
operator|%
literal|32
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mfilt
index|[
literal|0
index|]
operator|=
name|mfilt
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|ath_hal_setmcastfilter
argument_list|(
name|ah
argument_list|,
name|mfilt
index|[
literal|0
index|]
argument_list|,
name|mfilt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_mode_init: RX filter 0x%x, MC filter %08x:%08x\n"
operator|,
name|rfilt
operator|,
name|mfilt
index|[
literal|0
index|]
operator|,
name|mfilt
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_mbuf_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|nseg
operator|<=
name|ATH_MAX_SCATTER
argument_list|,
operator|(
literal|"ath_mbuf_load_cb: too many DMA segments %u"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_mapsize
operator|=
name|mapsize
expr_stmt|;
name|bf
operator|->
name|bf_nseg
operator|=
name|nseg
expr_stmt|;
name|bcopy
argument_list|(
name|seg
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
name|nseg
operator|*
sizeof|sizeof
argument_list|(
name|seg
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_beacon_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pktlen
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
decl_stmt|,
name|rate
decl_stmt|;
name|u_int16_t
name|capinfo
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|bf
operator|=
name|sc
operator|->
name|sc_bcbuf
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * NB: the beacon data buffer must be 32-bit aligned; 	 * we assume the mbuf routines will return us something 	 * with this alignment (perhaps should assert). 	 */
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
literal|8
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_esslen
operator|+
literal|2
operator|+
name|rs
operator|->
name|rs_nrates
operator|+
literal|6
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|pktlen
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<=
name|MHLEN
condition|)
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_beacon_alloc: cannot get mbuf/cluster; size %u\n"
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_be_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_BEACON
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
literal|0
expr_stmt|;
comment|/* 	 * beacon frame format 	 *	[8] time stamp 	 *	[2] beacon interval 	 *	[2] cabability information 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[tlv] parameter set (IBSS) 	 *	[tlv] extended supported rates 	 */
name|frm
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* timestamp is set by hardware */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
else|else
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
block|}
else|else
block|{
comment|/* TODO: TIM */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_TIM
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* length */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* DTIM count */
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* DTIM period */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* bitmap control */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Partial Virtual Bitmap (variable length) */
block|}
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|pktlen
argument_list|,
operator|(
literal|"beacon bigger than expected, len %u calculated %u"
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_beacon_alloc: m %p len %u\n"
operator|,
name|m
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|ath_mbuf_load_cb
argument_list|,
name|bf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"ath_beacon_alloc: multi-segment packet; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* 	 * Calculate rate code. 	 * XXX everything at min xmit rate 	 */
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|rate
operator|=
name|rt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|rateCode
operator||
name|rt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|shortPreamble
expr_stmt|;
else|else
name|rate
operator|=
name|rt
operator|->
name|info
index|[
literal|0
index|]
operator|.
name|rateCode
expr_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_CRC_LEN
comment|/* packet length */
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
comment|/* header length */
argument_list|,
name|HAL_PKT_TYPE_BEACON
comment|/* Atheros packet type */
argument_list|,
literal|0x20
comment|/* txpower XXX */
argument_list|,
name|rate
argument_list|,
literal|1
comment|/* series 0 rate/tries */
argument_list|,
name|HAL_TXKEYIX_INVALID
comment|/* no encryption */
argument_list|,
literal|0
comment|/* antenna mode */
argument_list|,
name|HAL_TXDESC_NOACK
comment|/* no ack for beacons */
argument_list|,
literal|0
comment|/* rts/cts rate */
argument_list|,
literal|0
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* NB: beacon's BufLen must be a multiple of 4 bytes */
comment|/* XXX verify mbuf data area covers this roundup */
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|roundup
argument_list|(
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|,
literal|4
argument_list|)
comment|/* buffer length */
argument_list|,
name|AH_TRUE
comment|/* first segment */
argument_list|,
name|AH_TRUE
comment|/* last segment */
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|sc
operator|->
name|sc_bcbuf
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"%s: pending %u\n"
operator|,
name|__func__
operator|,
name|pending
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|bf
operator|==
name|NULL
operator|||
name|bf
operator|->
name|bf_m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: ic_flags=%x bf=%p bf_m=%p\n"
operator|,
name|__func__
operator|,
name|ic
operator|->
name|ic_flags
operator|,
name|bf
operator|,
name|bf
condition|?
name|bf
operator|->
name|bf_m
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* TODO: update beacon to reflect PS poll state */
if|if
condition|(
operator|!
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: beacon queue %u did not stop?"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_bhalq
operator|)
argument_list|)
expr_stmt|;
return|return;
comment|/* busy, XXX is this right? */
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"%s: TXDP%u = %p (%p)\n"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_bhalq
operator|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
operator|,
name|bf
operator|->
name|bf_desc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_beacon_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
init|=
name|sc
operator|->
name|sc_bcbuf
decl_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the beacon and sleep timers.  *  * When operating as an AP this resets the TSF and sets  * up the hardware to notify us when we need to issue beacons.  *  * When operating in station mode this sets up the beacon  * timers according to the timestamp of the last received  * beacon and the current TSF, configures PCF and DTIM  * handling, programs the sleep registers so the hardware  * will wakeup in time to receive beacons, and configures  * the beacon miss handling so we'll receive a BMISS  * interrupt when we stop seeing beacons from the AP  * we've associated with.  */
end_comment

begin_function
specifier|static
name|void
name|ath_beacon_config
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|ic
operator|->
name|ic_bss
decl_stmt|;
name|u_int32_t
name|nexttbtt
decl_stmt|;
name|nexttbtt
operator|=
operator|(
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|+
literal|4
argument_list|)
operator|<<
literal|22
operator|)
operator||
operator|(
name|LE_READ_4
argument_list|(
name|ni
operator|->
name|ni_tstamp
argument_list|)
operator|>>
literal|10
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: nexttbtt=%u\n"
operator|,
name|__func__
operator|,
name|nexttbtt
operator|)
argument_list|)
expr_stmt|;
name|nexttbtt
operator|+=
name|ni
operator|->
name|ni_intval
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|HAL_BEACON_STATE
name|bs
decl_stmt|;
name|u_int32_t
name|bmisstime
decl_stmt|;
comment|/* NB: no PCF support right now */
name|memset
argument_list|(
operator|&
name|bs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bs
argument_list|)
argument_list|)
expr_stmt|;
name|bs
operator|.
name|bs_intval
operator|=
name|ni
operator|->
name|ni_intval
expr_stmt|;
name|bs
operator|.
name|bs_nexttbtt
operator|=
name|nexttbtt
expr_stmt|;
name|bs
operator|.
name|bs_dtimperiod
operator|=
name|bs
operator|.
name|bs_intval
expr_stmt|;
name|bs
operator|.
name|bs_nextdtim
operator|=
name|nexttbtt
expr_stmt|;
comment|/* 		 * Calculate the number of consecutive beacons to miss 		 * before taking a BMISS interrupt.  The configuration 		 * is specified in ms, so we need to convert that to 		 * TU's and then calculate based on the beacon interval. 		 * Note that we clamp the result to at most 10 beacons. 		 */
name|bmisstime
operator|=
operator|(
name|ic
operator|->
name|ic_bmisstimeout
operator|*
literal|1000
operator|)
operator|/
literal|1024
expr_stmt|;
name|bs
operator|.
name|bs_bmissthreshold
operator|=
name|howmany
argument_list|(
name|bmisstime
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|>
literal|10
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|bs
operator|.
name|bs_bmissthreshold
operator|<=
literal|0
condition|)
name|bs
operator|.
name|bs_bmissthreshold
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Calculate sleep duration.  The configuration is 		 * given in ms.  We insure a multiple of the beacon 		 * period is used.  Also, if the sleep duration is 		 * greater than the DTIM period then it makes senses 		 * to make it a multiple of that. 		 * 		 * XXX fixed at 100ms 		 */
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
operator|(
literal|100
operator|*
literal|1000
operator|)
operator|/
literal|1024
argument_list|,
name|bs
operator|.
name|bs_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|.
name|bs_sleepduration
operator|>
name|bs
operator|.
name|bs_dtimperiod
condition|)
name|bs
operator|.
name|bs_sleepduration
operator|=
name|roundup
argument_list|(
name|bs
operator|.
name|bs_sleepduration
argument_list|,
name|bs
operator|.
name|bs_dtimperiod
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: intval %u nexttbtt %u dtim %u nextdtim %u bmiss %u sleep %u\n"
operator|,
name|__func__
operator|,
name|bs
operator|.
name|bs_intval
operator|,
name|bs
operator|.
name|bs_nexttbtt
operator|,
name|bs
operator|.
name|bs_dtimperiod
operator|,
name|bs
operator|.
name|bs_nextdtim
operator|,
name|bs
operator|.
name|bs_bmissthreshold
operator|,
name|bs
operator|.
name|bs_sleepduration
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Reset our tsf so the hardware will update the 		 * tsf register to reflect timestamps found in 		 * received beacons. 		 */
name|ath_hal_resettsf
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|ath_hal_beacontimers
argument_list|(
name|ah
argument_list|,
operator|&
name|bs
argument_list|,
literal|0
comment|/*XXX*/
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_BMISS
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: intval %u nexttbtt %u\n"
operator|,
name|__func__
operator|,
name|ni
operator|->
name|ni_intval
operator|,
name|nexttbtt
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_beaconinit
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|,
name|nexttbtt
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_MONITOR
condition|)
name|sc
operator|->
name|sc_imask
operator||=
name|HAL_INT_SWBA
expr_stmt|;
comment|/* beacon prepare */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_desc_alloc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
comment|/* allocate descriptors */
name|sc
operator|->
name|sc_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
operator|*
operator|(
name|ATH_TXBUF
operator|*
name|ATH_TXDESC
operator|+
name|ATH_RXBUF
operator|+
literal|1
operator|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_desc
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail0
goto|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|,
name|sc
operator|->
name|sc_desc
argument_list|,
name|sc
operator|->
name|sc_desc_len
argument_list|,
name|ath_load_cb
argument_list|,
operator|&
name|sc
operator|->
name|sc_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|ds
operator|=
name|sc
operator|->
name|sc_desc
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_desc_alloc: DMA map: %p (%d) -> %p (%lu)\n"
operator|,
name|ds
operator|,
name|sc
operator|->
name|sc_desc_len
operator|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_desc_paddr
operator|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|sc
operator|->
name|sc_desc_len
operator|)
argument_list|)
expr_stmt|;
comment|/* allocate buffers */
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
argument_list|)
operator|*
operator|(
name|ATH_TXBUF
operator|+
name|ATH_RXBUF
operator|+
literal|1
operator|)
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
goto|goto
name|fail2
goto|;
name|sc
operator|->
name|sc_bufptr
operator|=
name|bf
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_RXBUF
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|sc
operator|->
name|sc_desc_paddr
operator|+
operator|(
operator|(
name|caddr_t
operator|)
name|ds
operator|-
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_desc
operator|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_TXBUF
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
name|ATH_TXDESC
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|sc
operator|->
name|sc_desc_paddr
operator|+
operator|(
operator|(
name|caddr_t
operator|)
name|ds
operator|-
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_desc
operator|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|)
expr_stmt|;
comment|/* beacon buffer */
name|bf
operator|->
name|bf_desc
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|sc
operator|->
name|sc_desc_paddr
operator|+
operator|(
operator|(
name|caddr_t
operator|)
name|ds
operator|-
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_desc
operator|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|sc_bcbuf
operator|=
name|bf
expr_stmt|;
return|return
literal|0
return|;
name|fail2
label|:
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_desc
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
name|fail0
label|:
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ddmamap
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_desc_free
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_desc
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_ddmamap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_txq
argument_list|,
argument|bf_list
argument_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_txbuf
argument_list|,
argument|bf_list
argument_list|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bcbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_bcbuf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_bcbuf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bcbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_bufptr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bufptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|ath_node_alloc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_node
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
decl_stmt|;
if|if
condition|(
name|an
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATH_RHIST_SIZE
condition|;
name|i
operator|++
control|)
name|an
operator|->
name|an_rx_hist
index|[
name|i
index|]
operator|.
name|arh_ticks
operator|=
name|ATH_RHIST_NOTIME
expr_stmt|;
name|an
operator|->
name|an_rx_hist_next
operator|=
name|ATH_RHIST_SIZE
operator|-
literal|1
expr_stmt|;
return|return
operator|&
name|an
operator|->
name|an_node
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_free
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ic
operator|->
name|ic_if
operator|.
name|if_softc
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_txq
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_node
operator|==
name|ni
condition|)
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|ni
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_node_copy
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|dst
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|src
parameter_list|)
block|{
operator|*
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|dst
operator|=
operator|*
operator|(
specifier|const
expr|struct
name|ath_node
operator|*
operator|)
name|src
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ath_node_getrssi
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|now
decl_stmt|,
name|nsamples
decl_stmt|,
name|rssi
decl_stmt|;
comment|/* 	 * Calculate the average over the last second of sampled data. 	 */
name|now
operator|=
name|ticks
expr_stmt|;
name|nsamples
operator|=
literal|0
expr_stmt|;
name|rssi
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|an
operator|->
name|an_rx_hist_next
expr_stmt|;
do|do
block|{
name|struct
name|ath_recv_hist
modifier|*
name|rh
init|=
operator|&
name|an
operator|->
name|an_rx_hist
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|rh
operator|->
name|arh_ticks
operator|==
name|ATH_RHIST_NOTIME
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|now
operator|-
name|rh
operator|->
name|arh_ticks
operator|>
name|hz
condition|)
goto|goto
name|done
goto|;
name|rssi
operator|+=
name|rh
operator|->
name|arh_rssi
expr_stmt|;
name|nsamples
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
name|ATH_RHIST_SIZE
operator|-
literal|1
expr_stmt|;
else|else
name|i
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|an
operator|->
name|an_rx_hist_next
condition|)
do|;
name|done
label|:
comment|/* 	 * Return either the average or the last known 	 * value if there is no recent data. 	 */
return|return
operator|(
name|nsamples
condition|?
name|rssi
operator|/
name|nsamples
else|:
name|an
operator|->
name|an_rx_hist
index|[
name|i
index|]
operator|.
name|arh_rssi
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * NB: by assigning a page to the rx dma buffer we 		 * implicitly satisfy the Atheros requirement that 		 * this buffer be cache-line-aligned and sized to be 		 * multiple of the cache line size.  Not doing this 		 * causes weird stuff to happen (for the 5210 at least). 		 */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_rxbuf_init: no mbuf/cluster\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|ath_mbuf_load_cb
argument_list|,
name|bf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_rxbuf_init: bus_dmamap_load_mbuf failed;"
literal|" error %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_busdma
operator|++
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"ath_rxbuf_init: multi-segment packet; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ath_hal_setuprxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
comment|/* buffer size */
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxlink
operator|!=
name|NULL
condition|)
operator|*
name|sc
operator|->
name|sc_rxlink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
operator|&
name|ds
operator|->
name|ds_link
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|,
name|whbuf
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|struct
name|ath_recv_hist
modifier|*
name|rh
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int
name|phyerr
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_rx_proc: pending %u\n"
operator|,
name|npending
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"ath_rx_proc: no buffer!\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"ath_rx_proc: no mbuf!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|status
operator|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AR_DEBUG
if|if
condition|(
name|ath_debug
operator|>
literal|1
condition|)
name|ath_printrxbuf
argument_list|(
name|bf
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_crcerr
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_DECRYPT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badcrypt
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phyerr
operator|++
expr_stmt|;
name|phyerr
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_phyerr
operator|&
literal|0x1f
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phy
index|[
name|phyerr
index|]
operator|++
expr_stmt|;
block|}
goto|goto
name|rx_next
goto|;
block|}
name|len
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_datalen
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|IEEE80211_MIN_LEN
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_rx_proc: short packet %d\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_tooshort
operator|++
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_drvbpf
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
comment|/* XXX pre-allocate space when setting up recv's */
name|MGETHDR
argument_list|(
name|mb
argument_list|,
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rate
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antsignal
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antenna
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_antenna
expr_stmt|;
comment|/* XXX TSF */
operator|(
name|void
operator|)
name|m_dup_pkthdr
argument_list|(
name|mb
argument_list|,
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mb
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|sc_rx_th
expr_stmt|;
name|mb
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rx_th
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mb
operator|->
name|m_len
expr_stmt|;
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_drvbpf
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_CRC_LEN
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
comment|/* 			 * WEP is decrypted by hardware. Clear WEP bit 			 * and trim WEP header for ieee80211_input(). 			 */
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_FC1_WEP
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|whbuf
argument_list|,
name|wh
argument_list|,
sizeof|sizeof
argument_list|(
name|whbuf
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|&
name|whbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|whbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Also trim WEP ICV from the tail. 			 */
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_WEP_CRCLEN
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Locate the node for sender, track state, and 		 * then pass this node (referenced) up to the 802.11 		 * layer for its use.  We are required to pass 		 * something so we fall back to ic_bss when this frame 		 * is from an unknown sender. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
block|{
name|ni
operator|=
name|ieee80211_find_node
argument_list|(
name|ic
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
block|}
else|else
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
comment|/* 		 * Record driver-specific state. 		 */
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|an
operator|->
name|an_rx_hist_next
operator|)
operator|==
name|ATH_RHIST_SIZE
condition|)
name|an
operator|->
name|an_rx_hist_next
operator|=
literal|0
expr_stmt|;
name|rh
operator|=
operator|&
name|an
operator|->
name|an_rx_hist
index|[
name|an
operator|->
name|an_rx_hist_next
index|]
expr_stmt|;
name|rh
operator|->
name|arh_ticks
operator|=
name|ticks
expr_stmt|;
name|rh
operator|->
name|arh_rssi
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
expr_stmt|;
name|rh
operator|->
name|arh_antenna
operator|=
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_antenna
expr_stmt|;
comment|/* 		 * Send frame up for processing. 		 */
name|ieee80211_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_rssi
argument_list|,
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_tstamp
argument_list|)
expr_stmt|;
comment|/* 		 * The frame may have caused the node to be marked for 		 * reclamation (e.g. in response to a DEAUTH message) 		 * so use free_node here instead of unref_node. 		 */
if|if
condition|(
name|ni
operator|==
name|ic
operator|->
name|ic_bss
condition|)
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
else|else
name|ieee80211_free_node
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|rx_next
label|:
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
operator|==
literal|0
condition|)
do|;
name|ath_hal_rxmonitor
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* rx signal state monitoring */
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* in case of RXEOL */
block|}
end_function

begin_comment
comment|/*  * XXX Size of an ACK control frame in bytes.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_ACK_SIZE
value|(2+2+IEEE80211_ADDR_LEN+4)
end_define

begin_function
specifier|static
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_ic
operator|.
name|ic_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|cix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int32_t
name|iv
decl_stmt|;
name|u_int8_t
modifier|*
name|ivp
decl_stmt|;
name|u_int8_t
name|hdrbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
operator|+
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
index|]
decl_stmt|;
name|u_int
name|subtype
decl_stmt|,
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|,
name|antenna
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
block|{
name|memcpy
argument_list|(
name|hdrbuf
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
name|hdrbuf
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ivp
operator|=
name|hdrbuf
operator|+
name|hdrlen
expr_stmt|;
comment|/* 		 * XXX 		 * IV must not duplicate during the lifetime of the key. 		 * But no mechanism to renew keys is defined in IEEE 802.11 		 * WEP.  And IV may be duplicated between other stations 		 * because of the session key itself is shared. 		 * So we use pseudo random IV for now, though it is not the 		 * right way. 		 */
name|iv
operator|=
name|arc4random
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_IVLEN
condition|;
name|i
operator|++
control|)
block|{
name|ivp
index|[
name|i
index|]
operator|=
name|iv
expr_stmt|;
name|iv
operator|>>=
literal|8
expr_stmt|;
block|}
name|ivp
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_ic
operator|.
name|ic_wep_txkey
operator|<<
literal|6
expr_stmt|;
comment|/* Key ID and pad */
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|hdrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hdrbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The ICV length must be included into hdrlen and pktlen. 		 */
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
name|hdrbuf
argument_list|)
operator|+
name|IEEE80211_WEP_CRCLEN
expr_stmt|;
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|IEEE80211_WEP_CRCLEN
expr_stmt|;
block|}
name|pktlen
operator|+=
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|ath_mbuf_load_cb
argument_list|,
name|bf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|>
name|ATH_TXDESC
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_linear
operator|++
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|M_MOVE_PKTHDR
argument_list|(
name|m
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nomcl
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|ath_mbuf_load_cb
argument_list|,
name|bf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"ath_tx_start: packet not one segment; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodata
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_tx_start: m %p len %u\n"
operator|,
name|m0
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate Atheros packet type from IEEE80211 packet header 	 * and setup for rate calculations. 	 */
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* default */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_BEACON
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PROBE_RESP
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ATIM
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_ATIM
expr_stmt|;
name|rix
operator|=
literal|0
expr_stmt|;
comment|/* XXX lowest rate */
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PS_POLL
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
name|rix
operator|=
literal|0
expr_stmt|;
comment|/* XXX lowest rate */
break|break;
default|default:
name|rix
operator|=
name|sc
operator|->
name|sc_rixmap
index|[
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|ni
operator|->
name|ni_txrate
index|]
operator|&
name|IEEE80211_RATE_VAL
index|]
expr_stmt|;
if|if
condition|(
name|rix
operator|==
literal|0xff
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus xmit rate 0x%x\n"
argument_list|,
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|ni
operator|->
name|ni_txrate
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_badrate
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
break|break;
block|}
comment|/* 	 * NB: the 802.11 layer marks whether or not we should 	 * use short preamble based on the current mode and 	 * negotiated parameters. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
block|{
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
operator||
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortpre
operator|++
expr_stmt|;
block|}
else|else
block|{
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
name|shortPreamble
operator|=
name|AH_FALSE
expr_stmt|;
block|}
comment|/* 	 * Calculate miscellaneous flags. 	 */
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for wep errors */
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
comment|/* no ack on broad/multicast */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_noack
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pktlen
operator|>
name|ic
operator|->
name|ic_rtsthreshold
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
comment|/* RTS based on frame length */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rts
operator|++
expr_stmt|;
block|}
comment|/* 	 * Calculate duration.  This logically belongs in the 802.11 	 * layer but it lacks sufficient information to calculate it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
name|u_int16_t
name|dur
decl_stmt|;
comment|/* 		 * XXX not right with fragmentation. 		 */
name|dur
operator|=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|IEEE80211_ACK_SIZE
argument_list|,
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|)
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate RTS/CTS rate and duration if needed. 	 */
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
block|{
comment|/* 		 * CTS transmit rate is derived from the transmit rate 		 * by looking in the h/w rate table.  We must also factor 		 * in whether or not a short preamble is to be used. 		 */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|controlRate
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
comment|/* 		 * Compute the transmit duration based on the size 		 * of an ACK frame.  We call into the HAL to do the 		 * computation since it depends on the characteristics 		 * of the actual PHY being used. 		 */
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
block|{
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|IEEE80211_ACK_SIZE
argument_list|,
name|cix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
comment|/* SIFS + data */
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|IEEE80211_ACK_SIZE
argument_list|,
name|cix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
comment|/* 	 * For now use the antenna on which the last good 	 * frame was received on.  We assume this field is 	 * initialized to 0 which gives us ``auto'' or the 	 * ``default'' antenna. 	 */
name|an
operator|=
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|ni
expr_stmt|;
if|if
condition|(
name|an
operator|->
name|an_tx_antenna
condition|)
name|antenna
operator|=
name|an
operator|->
name|an_tx_antenna
expr_stmt|;
else|else
name|antenna
operator|=
name|an
operator|->
name|an_rx_hist
index|[
name|an
operator|->
name|an_rx_hist_next
index|]
operator|.
name|arh_antenna
expr_stmt|;
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
comment|/* XXX check return value? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
literal|60
comment|/* txpower XXX */
argument_list|,
name|txrate
argument_list|,
literal|1
operator|+
literal|10
comment|/* series 0 rate/tries */
argument_list|,
name|iswep
condition|?
name|sc
operator|->
name|sc_ic
operator|.
name|ic_wep_txkey
else|:
name|HAL_TXKEYIX_INVALID
argument_list|,
name|antenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|AH_FALSE
comment|/* short preamble */
argument_list|,
literal|0
argument_list|,
literal|0
comment|/* series 1 rate/tries */
argument_list|,
literal|0
argument_list|,
literal|0
comment|/* series 2 rate/tries */
argument_list|,
literal|0
argument_list|,
literal|0
comment|/* series 3 rate/tries */
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Fillin the remainder of the descriptor info. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
comment|/* segment length */
argument_list|,
name|i
operator|==
literal|0
comment|/* first segment */
argument_list|,
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|)
expr_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_tx_start: %d: %08x %08x %08x %08x %08x %08x\n"
operator|,
name|i
operator|,
name|ds
operator|->
name|ds_link
operator|,
name|ds
operator|->
name|ds_data
operator|,
name|ds
operator|->
name|ds_ctl0
operator|,
name|ds
operator|->
name|ds_ctl1
operator|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
operator|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert the frame on the outbound list and 	 * pass it on to the hardware. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_txlink
operator|==
name|NULL
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_txhalq
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_tx_start: TXDP0 = %p (%p)\n"
operator|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
operator|,
name|bf
operator|->
name|bf_desc
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sc
operator|->
name|sc_txlink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_tx_start: link(%p)=%p (%p)\n"
operator|,
name|sc
operator|->
name|sc_txlink
operator|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
operator|,
name|bf
operator|->
name|bf_desc
operator|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_txlink
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_txhalq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_proc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|int
name|sr
decl_stmt|,
name|lr
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|DPRINTF2
argument_list|(
operator|(
literal|"ath_tx_proc: pending %u tx queue %p, link %p\n"
operator|,
name|npending
operator|,
operator|(
name|caddr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|sc
operator|->
name|sc_txhalq
argument_list|)
operator|,
name|sc
operator|->
name|sc_txlink
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_txlink
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* only the last descriptor is needed */
name|ds
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
expr_stmt|;
name|status
operator|=
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AR_DEBUG
if|if
condition|(
name|ath_debug
operator|>
literal|1
condition|)
name|ath_printtxbuf
argument_list|(
name|bf
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|an
operator|=
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|ni
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|==
literal|0
condition|)
block|{
name|an
operator|->
name|an_tx_ok
operator|++
expr_stmt|;
name|an
operator|->
name|an_tx_antenna
operator|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_antenna
expr_stmt|;
block|}
else|else
block|{
name|an
operator|->
name|an_tx_err
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_xretries
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FILT
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_filtered
operator|++
expr_stmt|;
name|an
operator|->
name|an_tx_antenna
operator|=
literal|0
expr_stmt|;
comment|/* invalidate */
block|}
name|sr
operator|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_shortretry
expr_stmt|;
name|lr
operator|=
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_longretry
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortretry
operator|+=
name|sr
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_longretry
operator|+=
name|lr
expr_stmt|;
if|if
condition|(
name|sr
operator|+
name|lr
condition|)
name|an
operator|->
name|an_tx_retr
operator|++
expr_stmt|;
comment|/* 			 * Reclaim reference to node. 			 * 			 * NB: the node may be reclaimed here if, for example 			 *     this is a DEAUTH message that was sent and the 			 *     node was timed out due to inactivity. 			 */
if|if
condition|(
name|ni
operator|!=
name|ic
operator|->
name|ic_bss
condition|)
name|ieee80211_free_node
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
name|ath_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain the transmit queue and reclaim resources.  */
end_comment

begin_function
specifier|static
name|void
name|ath_draintxq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_ic
operator|.
name|ic_if
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
comment|/* XXX return value */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_invalid
condition|)
block|{
comment|/* don't touch the hardware if marked invalid */
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_txhalq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_draintxq: tx queue %p, link %p\n"
operator|,
operator|(
name|caddr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_txhalq
argument_list|)
operator|,
name|sc
operator|->
name|sc_txlink
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_hal_stoptxdma
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_draintxq: beacon queue %p\n"
operator|,
operator|(
name|caddr_t
operator|)
name|ath_hal_gettxbuf
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_bhalq
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_txlink
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
break|break;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txqlock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AR_DEBUG
if|if
condition|(
name|ath_debug
condition|)
name|ath_printtxbuf
argument_list|(
name|bf
argument_list|,
name|ath_hal_txprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AR_DEBUG */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuflock
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_tx_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable the receive h/w in preparation for a reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ath_hal_stoppcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable PCU */
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear recv filter */
name|ath_hal_stopdmarecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable DMA engine */
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* long enough for 1 frame */
ifdef|#
directive|ifdef
name|AR_DEBUG
if|if
condition|(
name|ath_debug
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_stoprecv: rx queue %p, link %p\n"
operator|,
operator|(
name|caddr_t
operator|)
name|ath_hal_getrxbuf
argument_list|(
name|ah
argument_list|)
operator|,
name|sc
operator|->
name|sc_rxlink
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
operator|==
name|HAL_OK
condition|)
name|ath_printrxbuf
argument_list|(
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
comment|/* just in case */
block|}
end_function

begin_comment
comment|/*  * Enable the receive h/w following a reset.  */
end_comment

begin_function
specifier|static
name|int
name|ath_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ath_startrecv: ath_rxbuf_init failed %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set/change channels.  If the channel is really being changed,  * it's done by resetting the chip.  To accomplish this we must  * first cleanup any pending DMA, then restart stuff after a la  * ath_init.  */
end_comment

begin_function
specifier|static
name|int
name|ath_chan_set
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ath_chan_set: %u (%u MHz) -> %u (%u MHz)\n"
operator|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_ibss_chan
argument_list|)
operator|,
name|ic
operator|->
name|ic_ibss_chan
operator|->
name|ic_freq
operator|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
operator|,
name|chan
operator|->
name|ic_freq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|ic
operator|->
name|ic_ibss_chan
condition|)
block|{
name|HAL_STATUS
name|status
decl_stmt|;
name|HAL_CHANNEL
name|hchan
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
comment|/* 		 * To switch channels clear any pending DMA operations; 		 * wait long enough for the RX fifo to drain, reset the 		 * hardware at the new frequency, and then re-enable 		 * the relevant bits of the h/w. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ath_draintxq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear pending tx frames */
name|ath_stoprecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* turn off frame recv */
comment|/* 		 * Convert to a HAL channel description with 		 * the flags constrained to reflect the current 		 * operating mode. 		 */
name|hchan
operator|.
name|channel
operator|=
name|chan
operator|->
name|ic_freq
expr_stmt|;
name|hchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_reset
argument_list|(
name|ah
argument_list|,
name|ic
operator|->
name|ic_opmode
argument_list|,
operator|&
name|hchan
argument_list|,
name|AH_TRUE
argument_list|,
operator|&
name|status
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
operator|&
name|ic
operator|->
name|ic_if
argument_list|,
literal|"ath_chan_set: unable to reset "
literal|"channel %u (%u Mhz)\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Re-enable rx framework. 		 */
if|if
condition|(
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_printf
argument_list|(
operator|&
name|ic
operator|->
name|ic_if
argument_list|,
literal|"ath_chan_set: unable to restart recv logic\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 		 * Update BPF state. 		 */
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_freq
operator|=
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_freq
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_chan_flags
operator|=
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|=
name|htole16
argument_list|(
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* 		 * Change channels and update the h/w rate map 		 * if we're switching; e.g. 11a to 11b/g. 		 */
name|ic
operator|->
name|ic_ibss_chan
operator|=
name|chan
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|sc
operator|->
name|sc_curmode
condition|)
name|ath_setcurmode
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* 		 * Re-enable interrupts. 		 */
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_next_scan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_SCAN
condition|)
name|ieee80211_next_scan
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Periodically recalibrate the PHY to account  * for temperature/environment changes.  */
end_comment

begin_function
specifier|static
name|void
name|ath_calibrate
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|HAL_CHANNEL
name|hchan
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_cal
operator|++
expr_stmt|;
comment|/* 	 * Convert to a HAL channel description with the flags 	 * constrained to reflect the current operating mode. 	 */
name|c
operator|=
name|ic
operator|->
name|ic_ibss_chan
expr_stmt|;
name|hchan
operator|.
name|channel
operator|=
name|c
operator|->
name|ic_freq
expr_stmt|;
name|hchan
operator|.
name|channelFlags
operator|=
name|ath_chan2flags
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: channel %u/%x\n"
operator|,
name|__func__
operator|,
name|c
operator|->
name|ic_freq
operator|,
name|c
operator|->
name|ic_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_hal_getrfgain
argument_list|(
name|ah
argument_list|)
operator|==
name|HAL_RFGAIN_NEED_CHANGE
condition|)
block|{
comment|/* 		 * Rfgain is out of bounds, reset the chip 		 * to load new gain values. 		 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_rfgain
operator|++
expr_stmt|;
name|ath_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ath_hal_calibrate
argument_list|(
name|ah
argument_list|,
operator|&
name|hchan
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: calibration of channel %u failed\n"
operator|,
name|__func__
operator|,
name|c
operator|->
name|ic_freq
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_per_calfail
operator|++
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|hz
operator|*
name|ath_calinterval
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_newstate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|u_int8_t
modifier|*
name|bssid
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
specifier|static
specifier|const
name|HAL_LED_STATE
name|leds
index|[]
init|=
block|{
name|HAL_LED_INIT
block|,
comment|/* IEEE80211_S_INIT */
name|HAL_LED_SCAN
block|,
comment|/* IEEE80211_S_SCAN */
name|HAL_LED_AUTH
block|,
comment|/* IEEE80211_S_AUTH */
name|HAL_LED_ASSOC
block|,
comment|/* IEEE80211_S_ASSOC */
name|HAL_LED_RUN
block|,
comment|/* IEEE80211_S_RUN */
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: %s -> %s\n"
operator|,
name|__func__
operator|,
name|ieee80211_state_name
index|[
name|ic
operator|->
name|ic_state
index|]
operator|,
name|ieee80211_state_name
index|[
name|nstate
index|]
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_setledstate
argument_list|(
name|ah
argument_list|,
name|leds
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
comment|/* set LED */
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
return|return
call|(
modifier|*
name|sc
operator|->
name|sc_newstate
call|)
argument_list|(
name|ic
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
block|}
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|error
operator|=
name|ath_chan_set
argument_list|(
name|sc
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|rfilt
operator|=
operator|(
name|ath_hal_getrxfilter
argument_list|(
name|ah
argument_list|)
operator|&
name|HAL_RX_FILTER_PHYERR
operator|)
operator||
name|HAL_RX_FILTER_UCAST
operator||
name|HAL_RX_FILTER_BCAST
operator||
name|HAL_RX_FILTER_MCAST
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROBEREQ
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_SCAN
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|,
operator|(
name|hz
operator|*
name|ath_dwelltime
operator|)
operator|/
literal|1000
argument_list|,
name|ath_next_scan
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|bssid
operator|=
name|ifp
operator|->
name|if_broadcastaddr
expr_stmt|;
block|}
else|else
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|)
expr_stmt|;
name|bssid
operator|=
name|ni
operator|->
name|ni_bssid
expr_stmt|;
block|}
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
name|rfilt
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: RX filter 0x%x bssid %s\n"
operator|,
name|__func__
operator|,
name|rfilt
operator|,
name|ether_sprintf
argument_list|(
name|bssid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|bssid
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
else|else
name|ath_hal_setassocid
argument_list|(
name|ah
argument_list|,
name|bssid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_NKID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ath_hal_keyisvalid
argument_list|(
name|ah
argument_list|,
name|i
argument_list|)
condition|)
name|ath_hal_keysetmac
argument_list|(
name|ah
argument_list|,
name|i
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s(RUN): ic_flags=0x%08x iv=%d bssid=%s "
literal|"capinfo=0x%04x chan=%d\n"
operator|,
name|__func__
operator|,
name|ic
operator|->
name|ic_flags
operator|,
name|ni
operator|->
name|ni_intval
operator|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
operator|,
name|ni
operator|->
name|ni_capinfo
operator|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate and setup the beacon frame for AP or adhoc mode. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|error
operator|=
name|ath_beacon_alloc
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Configure the beacon and sleep timers. 		 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* start periodic recalibration timer */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|,
name|hz
operator|*
name|ath_calinterval
argument_list|,
name|ath_calibrate
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_imask
operator|&=
operator|~
operator|(
name|HAL_INT_SWBA
operator||
name|HAL_INT_BMISS
operator|)
expr_stmt|;
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
comment|/* no calibration */
block|}
comment|/* 	 * Reset the rate control state. 	 */
name|ath_rate_ctl_reset
argument_list|(
name|sc
argument_list|,
name|nstate
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke the parent method to complete the work. 	 */
return|return
call|(
modifier|*
name|sc
operator|->
name|sc_newstate
call|)
argument_list|(
name|ic
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
return|;
name|bad
label|:
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_scan_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_cal_ch
argument_list|)
expr_stmt|;
comment|/* NB: do not invoke the parent */
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Setup driver-specific state for a newly associated node.  * Note that we're called also on a re-associate, the isnew  * param tells us if this is the first time or not.  */
end_comment

begin_function
specifier|static
name|void
name|ath_newassoc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|isnew
parameter_list|)
block|{
if|if
condition|(
name|isnew
condition|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|ni
decl_stmt|;
name|an
operator|->
name|an_tx_ok
operator|=
name|an
operator|->
name|an_tx_err
operator|=
name|an
operator|->
name|an_tx_retr
operator|=
name|an
operator|->
name|an_tx_upper
operator|=
literal|0
expr_stmt|;
comment|/* start with highest negotiated rate */
comment|/* 		 * XXX should do otherwise but only when 		 * the rate control algorithm is better. 		 */
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|>
literal|0
argument_list|,
operator|(
literal|"new association w/ no rates!"
operator|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txrate
operator|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_getchannels
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cc
parameter_list|,
name|HAL_BOOL
name|outdoor
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|HAL_CHANNEL
modifier|*
name|chans
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ix
decl_stmt|,
name|nchan
decl_stmt|;
name|chans
operator|=
name|malloc
argument_list|(
name|IEEE80211_CHAN_MAX
operator|*
sizeof|sizeof
argument_list|(
name|HAL_CHANNEL
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chans
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to allocate channel table\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
operator|!
name|ath_hal_init_channels
argument_list|(
name|ah
argument_list|,
name|chans
argument_list|,
name|IEEE80211_CHAN_MAX
argument_list|,
operator|&
name|nchan
argument_list|,
name|cc
argument_list|,
name|HAL_MODE_ALL
argument_list|,
name|outdoor
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"unable to collect channel list from hal\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chans
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Convert HAL channels to ieee80211 ones and insert 	 * them in the table according to their channel number. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchan
condition|;
name|i
operator|++
control|)
block|{
name|HAL_CHANNEL
modifier|*
name|c
init|=
operator|&
name|chans
index|[
name|i
index|]
decl_stmt|;
name|ix
operator|=
name|ath_hal_mhz2ieee
argument_list|(
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>
name|IEEE80211_CHAN_MAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bad hal channel %u (%u/%x) ignored\n"
argument_list|,
name|ix
argument_list|,
name|c
operator|->
name|channel
argument_list|,
name|c
operator|->
name|channelFlags
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* NB: flags are known to be compatible */
if|if
condition|(
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_freq
operator|==
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_freq
operator|=
name|c
operator|->
name|channel
expr_stmt|;
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_flags
operator|=
name|c
operator|->
name|channelFlags
expr_stmt|;
block|}
else|else
block|{
comment|/* channels overlap; e.g. 11g and 11b */
name|ic
operator|->
name|ic_channels
index|[
name|ix
index|]
operator|.
name|ic_flags
operator||=
name|c
operator|->
name|channelFlags
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|chans
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_rate_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|mode
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxrates
decl_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11A
case|:
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11A
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11B
case|:
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11B
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_11G
case|:
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_11G
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MODE_TURBO
case|:
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
operator|=
name|ath_hal_getratetable
argument_list|(
name|ah
argument_list|,
name|HAL_MODE_TURBO
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"%s: invalid mode %u\n"
operator|,
name|__func__
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rt
operator|=
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rt
operator|->
name|rateCount
operator|>
name|IEEE80211_RATE_MAXSIZE
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: rate table too small (%u> %u)\n"
operator|,
name|__func__
operator|,
name|rt
operator|->
name|rateCount
operator|,
name|IEEE80211_RATE_MAXSIZE
operator|)
argument_list|)
expr_stmt|;
name|maxrates
operator|=
name|IEEE80211_RATE_MAXSIZE
expr_stmt|;
block|}
else|else
name|maxrates
operator|=
name|rt
operator|->
name|rateCount
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxrates
condition|;
name|i
operator|++
control|)
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
expr_stmt|;
name|rs
operator|->
name|rs_nrates
operator|=
name|maxrates
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_setcurmode
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rixmap
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_rates
index|[
name|mode
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no h/w rate set for phy mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rt
operator|->
name|rateCount
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_rixmap
index|[
name|rt
operator|->
name|info
index|[
name|i
index|]
operator|.
name|dot11Rate
operator|&
name|IEEE80211_RATE_VAL
index|]
operator|=
name|i
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_hwmap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_hwmap
index|[
name|i
index|]
operator|=
name|rt
operator|->
name|info
index|[
name|rt
operator|->
name|rateCodeToIndex
index|[
name|i
index|]
index|]
operator|.
name|dot11Rate
expr_stmt|;
name|sc
operator|->
name|sc_currates
operator|=
name|rt
expr_stmt|;
name|sc
operator|->
name|sc_curmode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the rate control state for each 802.11 state transition.  */
end_comment

begin_function
specifier|static
name|void
name|ath_rate_ctl_reset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|ieee80211_state
name|state
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|an
operator|=
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|an
operator|->
name|an_tx_ok
operator|=
name|an
operator|->
name|an_tx_err
operator|=
name|an
operator|->
name|an_tx_retr
operator|=
name|an
operator|->
name|an_tx_upper
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* start with highest negotiated rate */
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|>
literal|0
argument_list|,
operator|(
literal|"transition to RUN state w/ no rates!"
operator|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txrate
operator|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* use lowest rate */
name|ni
operator|->
name|ni_txrate
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&ic->ic_node
argument_list|,
argument|ni_list
argument_list|)
block|{
name|ni
operator|->
name|ni_txrate
operator|=
literal|0
expr_stmt|;
comment|/* use lowest rate */
name|an
operator|=
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|ni
expr_stmt|;
name|an
operator|->
name|an_tx_ok
operator|=
name|an
operator|->
name|an_tx_err
operator|=
name|an
operator|->
name|an_tx_retr
operator|=
name|an
operator|->
name|an_tx_upper
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * Examine and potentially adjust the transmit rate.  */
end_comment

begin_function
specifier|static
name|void
name|ath_rate_ctl
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
operator|(
expr|struct
name|ath_node
operator|*
operator|)
name|ni
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
init|=
operator|&
name|ni
operator|->
name|ni_rates
decl_stmt|;
name|int
name|mod
init|=
literal|0
decl_stmt|,
name|orate
decl_stmt|,
name|enough
decl_stmt|;
comment|/* 	 * Rate control 	 * XXX: very primitive version. 	 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rate_calls
operator|++
expr_stmt|;
name|enough
operator|=
operator|(
name|an
operator|->
name|an_tx_ok
operator|+
name|an
operator|->
name|an_tx_err
operator|>=
literal|10
operator|)
expr_stmt|;
comment|/* no packet reached -> down */
if|if
condition|(
name|an
operator|->
name|an_tx_err
operator|>
literal|0
operator|&&
name|an
operator|->
name|an_tx_ok
operator|==
literal|0
condition|)
name|mod
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* all packets needs retry in average -> down */
if|if
condition|(
name|enough
operator|&&
name|an
operator|->
name|an_tx_ok
operator|<
name|an
operator|->
name|an_tx_retr
condition|)
name|mod
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no error and less than 10% of packets needs retry -> up */
if|if
condition|(
name|enough
operator|&&
name|an
operator|->
name|an_tx_err
operator|==
literal|0
operator|&&
name|an
operator|->
name|an_tx_ok
operator|>
name|an
operator|->
name|an_tx_retr
operator|*
literal|10
condition|)
name|mod
operator|=
literal|1
expr_stmt|;
name|orate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|enough
operator|&&
name|an
operator|->
name|an_tx_upper
operator|>
literal|0
condition|)
name|an
operator|->
name|an_tx_upper
operator|--
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|ni
operator|->
name|ni_txrate
operator|>
literal|0
condition|)
block|{
name|ni
operator|->
name|ni_txrate
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rate_drop
operator|++
expr_stmt|;
block|}
name|an
operator|->
name|an_tx_upper
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
operator|++
name|an
operator|->
name|an_tx_upper
operator|<
literal|2
condition|)
break|break;
name|an
operator|->
name|an_tx_upper
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_txrate
operator|+
literal|1
operator|<
name|rs
operator|->
name|rs_nrates
condition|)
block|{
name|ni
operator|->
name|ni_txrate
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rate_raise
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ni
operator|->
name|ni_txrate
operator|!=
name|orate
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %dM -> %dM (%d ok, %d err, %d retr)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|orate
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|ni
operator|->
name|ni_txrate
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
name|an
operator|->
name|an_tx_ok
argument_list|,
name|an
operator|->
name|an_tx_err
argument_list|,
name|an
operator|->
name|an_tx_retr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ni
operator|->
name|ni_txrate
operator|!=
name|orate
operator|||
name|enough
condition|)
name|an
operator|->
name|an_tx_ok
operator|=
name|an
operator|->
name|an_tx_err
operator|=
name|an
operator|->
name|an_tx_retr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AR_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_hw_ath_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|dmode
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|strncpy
argument_list|(
name|dmode
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|dmode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dmode
index|[
sizeof|sizeof
argument_list|(
name|dmode
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|dmode
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dmode
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
decl_stmt|;
name|ifp
operator|=
name|ifunit
argument_list|(
literal|"ath0"
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|!
name|ifp
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dmode
argument_list|,
literal|"hal"
argument_list|)
operator|==
literal|0
condition|)
name|ath_hal_dumpstate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dmode
argument_list|,
literal|"eeprom"
argument_list|)
operator|==
literal|0
condition|)
name|ath_hal_dumpeeprom
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dmode
argument_list|,
literal|"rfgain"
argument_list|)
operator|==
literal|0
condition|)
name|ath_hal_dumprfgain
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dmode
argument_list|,
literal|"ani"
argument_list|)
operator|==
literal|0
condition|)
name|ath_hal_dumpani
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
else|else
return|return
name|EINVAL
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_ath
argument_list|,
name|OID_AUTO
argument_list|,
name|dump
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_ath_dump
argument_list|,
literal|"A"
argument_list|,
literal|"Dump driver state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ath_printrxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"R%d (%p %p) %08x %08x %08x %08x %08x %08x %c\n"
argument_list|,
name|i
argument_list|,
name|ds
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
operator|+
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|,
operator|!
name|done
condition|?
literal|' '
else|:
operator|(
name|ds
operator|->
name|ds_rxstat
operator|.
name|rs_status
operator|==
literal|0
operator|)
condition|?
literal|'*'
else|:
literal|'!'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_printtxbuf
parameter_list|(
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|done
parameter_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"T%d (%p %p) %08x %08x %08x %08x %08x %08x %08x %08x %c\n"
argument_list|,
name|i
argument_list|,
name|ds
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|bf
operator|->
name|bf_daddr
operator|+
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|2
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|3
index|]
argument_list|,
operator|!
name|done
condition|?
literal|' '
else|:
operator|(
name|ds
operator|->
name|ds_txstat
operator|.
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|'*'
else|:
literal|'!'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AR_DEBUG */
end_comment

end_unit

