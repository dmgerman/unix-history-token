begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_ht.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx_ht.h>
end_include

begin_comment
comment|/*  * How many retries to perform in software  */
end_comment

begin_define
define|#
directive|define
name|SWMAX_RETRIES
value|10
end_define

begin_function_decl
specifier|static
name|int
name|ath_tx_ampdu_pending
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_ampdu_running
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ieee80211_seq
name|ath_tx_tid_seqno_assign
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_action_frame_override_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
modifier|*
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Whether to use the 11n rate scenario functions or not  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ath_tx_is_11n
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|sc_ah
operator|->
name|ah_magic
operator|==
literal|0x20065416
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Obtain the current TID from the given frame.  *  * Non-QoS frames need to go into TID 16 (IEEE80211_NONQOS_TID.)  * This has implications for which AC/priority the packet is placed  * in.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_gettid
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|pri
init|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
name|IEEE80211_NONQOS_TID
return|;
else|else
return|return
name|WME_AC_TO_TID
argument_list|(
name|pri
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine what the correct AC queue for the given frame  * should be.  *  * This code assumes that the TIDs map consistently to  * the underlying hardware (or software) ath_txq.  * Since the sender may try to set an AC which is  * arbitrary, non-QoS TIDs may end up being put on  * completely different ACs. There's no way to put a  * TID into multiple ath_txq's for scheduling, so  * for now we override the AC/TXQ selection and set  * non-QOS TID frames into the BE queue.  *  * This may be completely incorrect - specifically,  * some management frames may end up out of order  * compared to the QoS traffic they're controlling.  * I'll look into this later.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_getac
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|pri
init|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
name|pri
return|;
return|return
name|WME_AC_BE
return|;
block|}
end_function

begin_function
name|void
name|ath_txfrag_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|frags
argument_list|,
argument|bf_list
argument_list|,
argument|next
argument_list|)
block|{
comment|/* NB: bf assumed clean */
name|TAILQ_REMOVE
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup xmit of a fragmented frame.  Allocate a buffer  * for each frag and bump the node reference count to  * reflect the held reference to be setup by ath_tx_start.  */
end_comment

begin_function
name|int
name|ath_txfrag_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* out of buffers, cleanup */
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|ieee80211_node_incref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|!
name|TAILQ_EMPTY
argument_list|(
name|frags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim mbuf resources.  For fragmented frames we  * need to claim each frag chained with m_nextpkt.  */
end_comment

begin_function
name|void
name|ath_freetx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_dmasetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|ATH_TXDESC
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|>
name|ATH_TXDESC
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_linear
operator|++
expr_stmt|;
name|m
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|ATH_TXDESC
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodata
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Chain together segments+descriptors for a non-11n frame.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_chaindesclist
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fillin the remainder of the descriptor info. 	 */
name|ds0
operator|=
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
comment|/* segment length */
argument_list|,
name|i
operator|==
literal|0
comment|/* first segment */
argument_list|,
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|,
name|ds0
comment|/* first descriptor */
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %d: %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
name|ds
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fill in the descriptor list for a aggregate subframe.  *  * The subframe is returned with the ds_link field in the last subframe  * pointing to 0.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_chaindesclist_subframe
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ds0
operator|=
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* 	 * There's no need to call ath_hal_setupfirsttxdesc here; 	 * That's only going to occur for the first frame in an aggregate. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 		 * This performs the setup for an aggregate frame. 		 * This includes enabling the aggregate flags if needed. 		 */
name|ath_hal_chaintxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
argument_list|,
name|HAL_PKT_TYPE_AMPDU
argument_list|,
comment|/* forces aggregate bits to be set */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
argument_list|,
literal|0
argument_list|,
comment|/* cipher, calculated from keyix */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
argument_list|,
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|,
comment|/* segment length */
name|i
operator|==
literal|0
argument_list|,
comment|/* first segment */
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %d: %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
name|ds
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup segments+descriptors for an 11n aggregate.  * bf_first is the first buffer in the aggregate.  * The descriptor list must already been linked together using  * bf->bf_next.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_setds_11n
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_prev
init|=
name|NULL
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: nframes=%d, al=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_al
argument_list|)
expr_stmt|;
comment|/* 	 * Setup all descriptors of all subframes. 	 */
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: bf=%p, nseg=%d, pktlen=%d, seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_nseg
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sub-frame setup */
name|ath_tx_chaindesclist_subframe
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 		 * Link the last descriptor of the previous frame 		 * to the beginning descriptor of this frame. 		 */
if|if
condition|(
name|bf_prev
operator|!=
name|NULL
condition|)
name|bf_prev
operator|->
name|bf_lastds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* Save a copy so we can link the next descriptor in */
name|bf_prev
operator|=
name|bf
expr_stmt|;
name|bf
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
block|}
comment|/* 	 * Setup first descriptor of first frame. 	 * chaintxdesc() overwrites the descriptor entries; 	 * setupfirsttxdesc() merges in things. 	 * Otherwise various fields aren't set correctly (eg flags). 	 */
name|ath_hal_setupfirsttxdesc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf_first
operator|->
name|bf_desc
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_al
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_flags
operator||
name|HAL_TXDESC_INTREQ
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_txpower
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_txrate0
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_try0
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_txantenna
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the last descriptor in the list. 	 * bf_prev points to the last; bf is NULL here. 	 */
name|ath_hal_setuplasttxdesc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf_prev
operator|->
name|bf_desc
argument_list|,
name|bf_first
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
comment|/* 	 * Set the first descriptor bf_lastds field to point to 	 * the last descriptor in the last subframe, that's where 	 * the status update will occur. 	 */
name|bf_first
operator|->
name|bf_lastds
operator|=
name|bf_prev
operator|->
name|bf_lastds
expr_stmt|;
comment|/* 	 * And bf_last in the first descriptor points to the end of 	 * the aggregate list. 	 */
name|bf_first
operator|->
name|bf_last
operator|=
name|bf_prev
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_handoff_mcast
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: busy status 0x%x"
operator|,
name|__func__
operator|,
name|bf
operator|->
name|bf_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|last
init|=
name|ATH_TXQ_LAST
argument_list|(
name|txq
argument_list|,
name|axq_q_s
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* mark previous frame */
name|wh
operator|=
name|mtod
argument_list|(
name|last
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|last
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* link descriptor */
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
block|}
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_lastds
operator|->
name|ds_link
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hand-off packet to a hardware queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_handoff_hw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* 	 * Insert the frame on the outbound list and pass it on 	 * to the hardware.  Multicast frames buffered for power 	 * save stations and transmit from the CAB queue are stored 	 * on a s/w only queue and loaded on to the CAB queue in 	 * the SWBA handler since frames only go out on DTIM and 	 * to avoid possible races. 	 */
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: busy status 0x%x"
operator|,
name|__func__
operator|,
name|bf
operator|->
name|bf_flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|axq_qnum
operator|!=
name|ATH_TXQ_SWQ
argument_list|,
operator|(
literal|"ath_tx_handoff_hw called for mcast queue"
operator|)
argument_list|)
expr_stmt|;
comment|/* For now, so not to generate whitespace diffs */
if|if
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|int
name|qbusy
decl_stmt|;
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|qbusy
operator|=
name|ath_hal_txqenabled
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Be careful writing the address to TXDP.  If 			 * the tx q is enabled then this write will be 			 * ignored.  Normally this is not an issue but 			 * when tdma is in use and the q is beacon gated 			 * this race can occur.  If the q is busy then 			 * defer the work to later--either when another 			 * packet comes along or when we prepare a beacon 			 * frame at SWBA. 			 */
if|if
condition|(
operator|!
name|qbusy
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
operator||
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: Q%u busy, defer enable\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txq
operator|->
name|axq_flags
operator|&
name|ATH_TXQ_PUTPENDING
operator|)
operator|&&
operator|!
name|qbusy
condition|)
block|{
comment|/* 				 * The q was busy when we previously tried 				 * to write the address of the first buffer 				 * in the chain.  Since it's not busy now 				 * handle this chore.  We are certain the 				 * buffer at the front is the right one since 				 * axq_link is NULL only when the buffer list 				 * is/was empty. 				 */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
operator||
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: Q%u restarted\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_TDMA */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|txq
operator|->
name|axq_aggr_depth
operator|++
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_lastds
operator|->
name|ds_link
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Restart TX DMA for the given TXQ.  *  * This must be called whether the queue is empty or not.  */
end_comment

begin_function
name|void
name|ath_txq_restart_dma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* This is always going to be cleared, empty or not */
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
return|return;
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_lastds
operator|->
name|ds_link
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hand off a packet to the hardware (or mcast queue.)  *  * The relevant hardware txq should be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_handoff
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_qnum
operator|==
name|ATH_TXQ_SWQ
condition|)
name|ath_tx_handoff_mcast
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
else|else
name|ath_tx_handoff_hw
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_tag_crypto
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|iswep
parameter_list|,
name|int
name|isfrag
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|,
name|int
modifier|*
name|pktlen
parameter_list|,
name|int
modifier|*
name|keyix
parameter_list|)
block|{
if|if
condition|(
name|iswep
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
return|return
literal|0
return|;
block|}
comment|/* 		 * Adjust the packet + header lengths for the crypto 		 * additions and calculate the h/w key index.  When 		 * a s/w mic is done the frame will have had any mic 		 * added to it prior to entry so m0->m_pkthdr.len will 		 * account for it. Otherwise we need to add it to the 		 * packet length. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
operator|(
operator|*
name|hdrlen
operator|)
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
operator|(
operator|*
name|pktlen
operator|)
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
comment|/* NB: frags always have any TKIP MIC done in s/w */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|isfrag
condition|)
operator|(
operator|*
name|pktlen
operator|)
operator|+=
name|cip
operator|->
name|ic_miclen
expr_stmt|;
operator|(
operator|*
name|keyix
operator|)
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
operator|==
operator|&
name|ieee80211_cipher_none
condition|)
block|{
comment|/* 		 * Use station key cache slot, if assigned. 		 */
operator|(
operator|*
name|keyix
operator|)
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|keyix
operator|)
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
operator|(
operator|*
name|keyix
operator|)
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|keyix
operator|)
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ath_tx_get_rtscts_rate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|cix
parameter_list|,
name|int
name|shortPreamble
parameter_list|)
block|{
name|uint8_t
name|ctsrate
decl_stmt|;
comment|/* 	 * CTS transmit rate is derived from the transmit rate 	 * by looking in the h/w rate table.  We must also factor 	 * in whether or not a short preamble is to be used. 	 */
comment|/* NB: cix is set above where RTS/CTS is enabled */
name|KASSERT
argument_list|(
name|cix
operator|!=
literal|0xff
argument_list|,
operator|(
literal|"cix not setup"
operator|)
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* XXX this should only matter for legacy rates */
if|if
condition|(
name|shortPreamble
condition|)
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
return|return
name|ctsrate
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the RTS/CTS duration for legacy frames.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_calc_ctsduration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|rix
parameter_list|,
name|int
name|cix
parameter_list|,
name|int
name|shortPreamble
parameter_list|,
name|int
name|pktlen
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ctsduration
init|=
literal|0
decl_stmt|;
comment|/* This mustn't be called for HT modes */
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: HT rate where it shouldn't be (0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Compute the transmit duration based on the frame 	 * size and the size of an ACK frame.  We call into the 	 * HAL to do the computation since it depends on the 	 * characteristics of the actual PHY being used. 	 * 	 * NB: CTS is assumed the same size as an ACK so we can 	 *     use the precalculated ACK durations. 	 */
if|if
condition|(
name|shortPreamble
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
return|return
name|ctsduration
return|;
block|}
end_function

begin_comment
comment|/*  * Update the given ath_buf with updated rts/cts setup and duration  * values.  *  * To support rate lookups for each software retry, the rts/cts rate  * and cts duration must be re-calculated.  *  * This function assumes the RTS/CTS flags have been set as needed;  * mrr has been disabled; and the rate control lookup has been done.  *  * XXX TODO: MRR need only be disabled for the pre-11n NICs.  * XXX The 11n NICs support per-rate RTS/CTS configuration.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_set_rtscts
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|uint16_t
name|ctsduration
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ctsrate
init|=
literal|0
decl_stmt|;
name|uint8_t
name|rix
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
decl_stmt|;
name|uint8_t
name|cix
init|=
literal|0
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
comment|/* 	 * No RTS/CTS enabled? Don't bother. 	 */
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX is this really needed? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * If protection is enabled, use the protection rix control 	 * rate. Otherwise use the rate0 control rate. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doprot
condition|)
name|rix
operator|=
name|sc
operator|->
name|sc_protrix
expr_stmt|;
else|else
name|rix
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
expr_stmt|;
comment|/* 	 * If the raw path has hard-coded ctsrate0 to something, 	 * use it. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
operator|!=
literal|0
condition|)
name|cix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
argument_list|)
expr_stmt|;
else|else
comment|/* Control rate from above */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|controlRate
expr_stmt|;
comment|/* Calculate the rtscts rate for the given cix */
name|ctsrate
operator|=
name|ath_tx_get_rtscts_rate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rt
argument_list|,
name|cix
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
argument_list|)
expr_stmt|;
comment|/* The 11n chipsets do ctsduration calculations for you */
if|if
condition|(
operator|!
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
name|ctsduration
operator|=
name|ath_tx_calc_ctsduration
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rix
argument_list|,
name|cix
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|rt
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_flags
argument_list|)
expr_stmt|;
comment|/* Squirrel away in ath_buf */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
name|ctsrate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
name|ctsduration
expr_stmt|;
comment|/* 	 * Must disable multi-rate retry when using RTS/CTS. 	 * XXX TODO: only for pre-11n NICs. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX ew */
block|}
end_function

begin_comment
comment|/*  * Setup the descriptor chain for a normal or fast-frame  * frame.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_setds
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
comment|/* packet length */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
comment|/* header length */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
comment|/* Atheros packet type */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
comment|/* txpower */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
comment|/* series 0 rate/tries */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
comment|/* key cache index */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
comment|/* antenna mode */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_flags
comment|/* flags */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
comment|/* rts/cts rate */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* 	 * This will be overriden when the descriptor chain is written. 	 */
name|bf
operator|->
name|bf_lastds
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_last
operator|=
name|bf
expr_stmt|;
comment|/* XXX TODO: Setup descriptor chain */
block|}
end_function

begin_comment
comment|/*  * Do a rate lookup.  *  * This performs a rate lookup for the given ath_buf only if it's required.  * Non-data frames and raw frames don't require it.  *  * This populates the primary and MRR entries; MRR values are  * then disabled later on if something requires it (eg RTS/CTS on  * pre-11n chipsets.  *  * This needs to be done before the RTS/CTS fields are calculated  * as they may depend upon the rate chosen.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_do_ratelookup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|uint8_t
name|rate
decl_stmt|,
name|rix
decl_stmt|;
name|int
name|try0
decl_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doratelookup
condition|)
return|return;
comment|/* Get rid of any previous state */
name|bzero
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
argument_list|)
expr_stmt|;
name|ATH_NODE_LOCK
argument_list|(
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|)
expr_stmt|;
name|ath_rate_findrate
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
operator|&
name|rix
argument_list|,
operator|&
name|try0
argument_list|,
operator|&
name|rate
argument_list|)
expr_stmt|;
comment|/* In case MRR is disabled, make sure rc[0] is setup correctly */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|=
name|rate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|try0
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|&&
name|try0
operator|!=
name|ATH_TXMAXTRY
condition|)
name|ath_rate_getxtxrates
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|,
name|rix
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
expr_stmt|;
name|ATH_NODE_UNLOCK
argument_list|(
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
comment|/* for LED blinking */
name|sc
operator|->
name|sc_lastdatarix
operator|=
name|rix
expr_stmt|;
comment|/* for fast frames */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|=
name|rate
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the rate control fields in the given descriptor based on  * the bf_state fields and node state.  *  * The bfs fields should already be set with the relevant rate  * control information, including whether MRR is to be enabled.  *  * Since the FreeBSD HAL currently sets up the first TX rate  * in ath_hal_setuptxdesc(), this will setup the MRR  * conditionally for the pre-11n chips, and call ath_buf_set_rate  * unconditionally for 11n chips. These require the 11n rate  * scenario to be set if MCS rates are enabled, so it's easier  * to just always call it. The caller can then only set rates 2, 3  * and 4 if multi-rate retry is needed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_set_ratectrl
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_rc_series
modifier|*
name|rc
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
decl_stmt|;
comment|/* If mrr is disabled, blank tries 1, 2, 3 */
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
condition|)
name|rc
index|[
literal|1
index|]
operator|.
name|tries
operator|=
name|rc
index|[
literal|2
index|]
operator|.
name|tries
operator|=
name|rc
index|[
literal|3
index|]
operator|.
name|tries
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Always call - that way a retried descriptor will 	 * have the MRR fields overwritten. 	 * 	 * XXX TODO: see if this is really needed - setting up 	 * the first descriptor should set the MRR fields to 0 	 * for us anyway. 	 */
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ath_buf_set_rate
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_setupxtxdesc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|rc
index|[
literal|1
index|]
operator|.
name|ratecode
argument_list|,
name|rc
index|[
literal|1
index|]
operator|.
name|tries
argument_list|,
name|rc
index|[
literal|2
index|]
operator|.
name|ratecode
argument_list|,
name|rc
index|[
literal|2
index|]
operator|.
name|tries
argument_list|,
name|rc
index|[
literal|3
index|]
operator|.
name|ratecode
argument_list|,
name|rc
index|[
literal|3
index|]
operator|.
name|tries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit the given frame to the hardware.  *  * The frame must already be setup; rate control must already have  * been done.  *  * XXX since the TXQ lock is being held here (and I dislike holding  * it for this long when not doing software aggregation), later on  * break this function into "setup_normal" and "xmit_normal". The  * lock only needs to be held for the ath_tx_handoff call.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_xmit_normal
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Setup the descriptor before handoff */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Hand off to hardware */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_normal_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|chanAccParams
modifier|*
name|cap
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
decl_stmt|;
name|int
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|ismcast
decl_stmt|,
name|isfrag
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|rix
init|=
literal|0
decl_stmt|,
name|txrate
init|=
literal|0
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|subtype
decl_stmt|,
name|flags
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|isfrag
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* Handle encryption twiddling if needed */
if|if
condition|(
operator|!
name|ath_tx_tag_crypto
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|iswep
argument_list|,
name|isfrag
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|&
name|keyix
argument_list|)
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the 802.11 layer marks whether or not we should 	 * use short preamble based on the current mode and 	 * negotiated parameters. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
block|{
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortpre
operator|++
expr_stmt|;
block|}
else|else
block|{
name|shortPreamble
operator|=
name|AH_FALSE
expr_stmt|;
block|}
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* default no multi-rate retry*/
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* honor classification */
comment|/* XXX use txparams instead of fixed values */
comment|/* 	 * Calculate Atheros packet type from IEEE80211 packet header, 	 * setup for rate calculations, and select h/w transmit queue. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_BEACON
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PROBE_RESP
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ATIM
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_ATIM
expr_stmt|;
else|else
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* XXX */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
comment|/* stop setting of duration */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* default */
comment|/* 		 * Data frames: multicast frames go out at a fixed rate, 		 * EAPOL frames use the mgmt frame rate; otherwise consult 		 * the rate control module for the rate to use. 		 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|rix
operator|=
name|an
operator|->
name|an_mcastrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
block|{
comment|/* XXX? maybe always use long preamble? */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMAXTRY
expr_stmt|;
comment|/* XXX?too many? */
block|}
else|else
block|{
comment|/* 			 * Do rate lookup on each TX, rather than using 			 * the hard-coded TX information decided here. 			 */
name|ismrr
operator|=
literal|1
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doratelookup
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cap
operator|->
name|cap_wmeParams
index|[
name|pri
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX statistic */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
comment|/* 	 * When servicing one or more stations in power-save mode 	 * (or) if there is some mcast data waiting on the mcast 	 * queue (to prevent out of order delivery) multicast 	 * frames must be buffered until after the beacon. 	 */
if|if
condition|(
name|ismcast
operator|&&
operator|(
name|vap
operator|->
name|iv_ps_sta
operator|||
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
operator|)
condition|)
name|txq
operator|=
operator|&
name|avp
operator|->
name|av_mcastq
expr_stmt|;
comment|/* 	 * Calculate miscellaneous flags. 	 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
comment|/* no ack on broad/multicast */
block|}
elseif|else
if|if
condition|(
name|pktlen
operator|>
name|vap
operator|->
name|iv_rtsthreshold
operator|&&
operator|(
name|ni
operator|->
name|ni_ath_flags
operator|&
name|IEEE80211_NODE_FF
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
comment|/* RTS based on frame length */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
condition|)
comment|/* NB: avoid double counting */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_noack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: discard frame, ACK required w/ TDMA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_ack
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
endif|#
directive|endif
comment|/* 	 * If 802.11g protection is enabled, determine whether 	 * to use RTS/CTS or just CTS.  Note that this is only 	 * done for OFDM unicast frames. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doprot
operator|=
literal|1
expr_stmt|;
comment|/* XXX fragments must use CCK rates w/ protection */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
block|}
comment|/* 		 * For frags it would be desirable to use the 		 * highest CCK rate for RTS/CTS.  But stations 		 * farther away may detect it at a lower CCK rate 		 * so use the configured protection rate instead 		 * (for now). 		 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_protect
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * If 11n protection is enabled and it's a HT frame, 	 * enable RTS. 	 * 	 * XXX ic_htprotmode or ic_curhtprotmode? 	 * XXX should it_htprotmode only matter if ic_curhtprotmode  	 * XXX indicates it's not a HT pure environment? 	 */
block|if ((ic->ic_htprotmode == IEEE80211_PROT_RTSCTS)&& 	    rt->info[rix].phy == IEEE80211_T_HT&& 	    (flags& HAL_TXDESC_NOACK) == 0) { 		cix = rt->info[sc->sc_protrix].controlRate; 	    	flags |= HAL_TXDESC_RTSENA; 		sc->sc_stats.ast_tx_htprotect++; 	}
endif|#
directive|endif
comment|/* 	 * Calculate duration.  This logically belongs in the 802.11 	 * layer but it lacks sufficient information to calculate it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
name|u_int16_t
name|dur
decl_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
else|else
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_FRAG
condition|)
block|{
name|dur
operator|+=
name|dur
expr_stmt|;
comment|/* additional SIFS+ACK */
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no fragment"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Include the size of next fragment so NAV is 			 * updated properly.  The last fragment uses only 			 * the ACK duration 			 */
name|dur
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|m0
operator|->
name|m_nextpkt
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isfrag
condition|)
block|{
comment|/* 			 * Force hardware to use computed duration for next 			 * fragment by disabling multi-rate retry which updates 			 * duration based on the multi-rate duration table. 			 */
name|ismrr
operator|=
literal|0
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX? */
block|}
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine if a tx interrupt should be generated for 	 * this descriptor.  We take a tx interrupt to reap 	 * descriptors when the h/w hits an EOL condition or 	 * when the descriptor is specifically marked to generate 	 * an interrupt.  We periodically mark descriptors in this 	 * way to insure timely replenishing of the supply needed 	 * for sending frames.  Defering interrupts reduces system 	 * load and potentially allows more concurrent work to be 	 * done but if done to aggressively can cause senders to 	 * backup. 	 * 	 * NB: use>= to deal with sc_txintrperiod changing 	 *     dynamically through sysctl. 	 */
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_INTREQ
condition|)
block|{
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|txq
operator|->
name|axq_intrcnt
operator|>=
name|sc
operator|->
name|sc_txintrperiod
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This point forward is actual TX bits */
comment|/* 	 * At this point we are committed to sending the frame 	 * and we don't need to look at m_nextpkt; clear it in 	 * case this frame is part of frag chain. 	 */
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|isfrag
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* Blank the legacy rate array */
name|bzero
argument_list|(
operator|&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * ath_buf_set_rate needs at least one rate/try to setup 	 * the rate scenario. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|=
name|txrate
expr_stmt|;
comment|/* Store the decided rate index values away */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
operator|=
name|pktlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
operator|=
name|atype
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|=
name|txrate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
operator|=
name|keyix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_flags
operator|=
name|flags
expr_stmt|;
name|bf
operator|->
name|bf_txflags
operator|=
name|flags
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
operator|=
name|shortPreamble
expr_stmt|;
comment|/* XXX this should be done in ath_tx_setrate() */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
operator|=
literal|0
expr_stmt|;
comment|/* ie, no hard-coded ctsrate */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
literal|0
expr_stmt|;
comment|/* calculated later */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
name|ismrr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Direct-dispatch the current frame to the hardware.  *  * This can be called by the net80211 code.  *  * XXX what about locking? Or, push the seqno assign into the  * XXX aggregate scheduler so its serialised?  */
end_comment

begin_function
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|ismcast
decl_stmt|;
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|is_ampdu
decl_stmt|,
name|is_ampdu_tx
decl_stmt|,
name|is_ampdu_pending
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|subtype
decl_stmt|;
comment|/* 	 * Determine the target hardware queue. 	 * 	 * For multicast frames, the txq gets overridden to be the 	 * software TXQ and it's done via direct-dispatch. 	 * 	 * For any other frame, we do a TID/QoS lookup inside the frame 	 * to see what the TID should be. If it's a non-QoS frame, the 	 * AC and TID are overridden. The TID/TXQ code assumes the 	 * TID is on a predictable hardware TXQ, so we don't support 	 * having a node TID queued to multiple hardware TXQs. 	 * This may change in the future but would require some locking 	 * fudgery. 	 */
name|pri
operator|=
name|ath_tx_getac
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|tid
operator|=
name|ath_tx_gettid
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
comment|/* A-MPDU TX */
name|is_ampdu_tx
operator|=
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|is_ampdu_pending
operator|=
name|ath_tx_ampdu_pending
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|is_ampdu
operator|=
name|is_ampdu_tx
operator||
name|is_ampdu_pending
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d, ac=%d, is_ampdu=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|pri
argument_list|,
name|is_ampdu
argument_list|)
expr_stmt|;
comment|/* Multicast frames go onto the software multicast queue */
if|if
condition|(
name|ismcast
condition|)
name|txq
operator|=
operator|&
name|avp
operator|->
name|av_mcastq
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|is_ampdu
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_ps_sta
operator|||
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
operator|)
condition|)
name|txq
operator|=
operator|&
name|avp
operator|->
name|av_mcastq
expr_stmt|;
comment|/* Do the generic frame setup */
comment|/* XXX should just bzero the bf_state? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
comment|/* A-MPDU TX? Manually set sequence number */
comment|/* Don't do it whilst pending; the net80211 layer still assigns them */
comment|/* XXX do we need locking here? */
if|if
condition|(
name|is_ampdu_tx
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 		 * Always call; this function will 		 * handle making sure that null data frames 		 * don't get a sequence number from the current 		 * TID and thus mess with the BAW. 		 */
name|seqno
operator|=
name|ath_tx_tid_seqno_assign
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
operator|&&
name|subtype
operator|!=
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If needed, the sequence number has been assigned. 	 * Squirrel it away somewhere easy to get to. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
operator|=
name|M_SEQNO_GET
argument_list|(
name|m0
argument_list|)
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
comment|/* Is ampdu pending? fetch the seqno and print it out */
if|if
condition|(
name|is_ampdu_pending
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid %d: ampdu pending, seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|M_SEQNO_GET
argument_list|(
name|m0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This also sets up the DMA map */
name|r
operator|=
name|ath_tx_normal_setup
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
return|return
name|r
return|;
comment|/* At this point m0 could have changed! */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * If it's a multicast frame, do a direct-dispatch to the 	 * destination hardware queue. Don't bother software 	 * queuing it. 	 */
comment|/* 	 * If it's a BAR frame, do a direct dispatch to the 	 * destination hardware queue. Don't bother software 	 * queuing it, as the TID will now be paused. 	 * Sending a BAR frame can occur from the net80211 txa timer 	 * (ie, retries) or from the ath txtask (completion call.) 	 * It queues directly to hardware because the TID is paused 	 * at this point (and won't be unpaused until the BAR has 	 * either been TXed successfully or max retries has been 	 * reached.) 	 */
if|if
condition|(
name|txq
operator|==
operator|&
name|avp
operator|->
name|av_mcastq
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_CTL
operator|&&
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BAR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: BAR: TX'ing direct\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add to software queue */
name|ath_tx_swq
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * For now, since there's no software queue, 	 * direct-dispatch to the hardware. 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_raw_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ismcast
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|,
name|txantenna
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|txrate
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|int
name|o_tid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|do_override
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
comment|/* XXX honor IEEE80211_BPF_DATAPAD */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: ismcast=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ismcast
argument_list|)
expr_stmt|;
comment|/* Handle encryption twiddling if needed */
if|if
condition|(
operator|!
name|ath_tx_tag_crypto
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CRYPTO
argument_list|,
literal|0
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|&
name|keyix
argument_list|)
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* Do the generic frame setup */
comment|/* XXX should just bzero the bf_state? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
block|{
comment|/* XXX assume 11g/11n protection? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doprot
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
block|}
comment|/* XXX leave ismcast to injector? */
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|||
name|ismcast
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
name|try0
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|ismrr
operator|=
operator|(
name|params
operator|->
name|ibp_try1
operator|!=
literal|0
operator|)
expr_stmt|;
name|txantenna
operator|=
name|params
operator|->
name|ibp_pri
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|txantenna
operator|==
literal|0
condition|)
comment|/* XXX? */
name|txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
comment|/* 	 * Since ctsrate is fixed, store it away for later 	 * use when the descriptor fields are being set. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
operator|=
name|params
operator|->
name|ibp_ctsrate
expr_stmt|;
name|pri
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
comment|/* Override pri if the frame isn't a QoS one */
if|if
condition|(
operator|!
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
name|pri
operator|=
name|ath_tx_getac
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * NB: we mark all packets as type PSPOLL so the h/w won't 	 * set the sequence number, duration, etc. 	 */
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* XXX check return value? */
comment|/* Store the decided rate index values away */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
operator|=
name|pktlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
operator|=
name|atype
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
operator|=
name|params
operator|->
name|ibp_power
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|=
name|txrate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
operator|=
name|keyix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
operator|=
name|txantenna
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_flags
operator|=
name|flags
expr_stmt|;
name|bf
operator|->
name|bf_txflags
operator|=
name|flags
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
operator|=
operator|!
operator|!
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
operator|)
expr_stmt|;
comment|/* XXX this should be done in ath_tx_setrate() */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
name|ismrr
expr_stmt|;
comment|/* Blank the legacy rate array */
name|bzero
argument_list|(
operator|&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|=
name|txrate
expr_stmt|;
if|if
condition|(
name|ismrr
condition|)
block|{
name|int
name|rix
decl_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate1
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|1
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|1
index|]
operator|.
name|tries
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate2
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|2
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|2
index|]
operator|.
name|tries
operator|=
name|params
operator|->
name|ibp_try2
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate3
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|tries
operator|=
name|params
operator|->
name|ibp_try3
expr_stmt|;
block|}
comment|/* 	 * All the required rate control decisions have been made; 	 * fill in the rc flags. 	 */
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* NB: no buffered multicast in power save support */
comment|/* XXX If it's an ADDBA, override the correct queue */
name|do_override
operator|=
name|ath_tx_action_frame_override_queue
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
operator|&
name|o_tid
argument_list|)
expr_stmt|;
comment|/* Map ADDBA to the correct priority */
if|if
condition|(
name|do_override
condition|)
block|{
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, 		    "%s: overriding tid %d pri %d -> %d\n", 		    __func__, o_tid, pri, TID_TO_WME_AC(o_tid));
endif|#
directive|endif
name|pri
operator|=
name|TID_TO_WME_AC
argument_list|(
name|o_tid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're overiding the ADDBA destination, dump directly 	 * into the hardware queue, right after any pending 	 * frames to that node are. 	 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: dooverride=%d\n"
argument_list|,
name|__func__
argument_list|,
name|do_override
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_override
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|)
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Queue to software queue */
name|ath_tx_swq
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a raw frame.  *  * This can be called by net80211.  */
end_comment

begin_function
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: discard frame, %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|?
literal|"!running"
else|:
literal|"invalid"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 */
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
if|if
condition|(
name|ath_tx_raw_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw
operator|++
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw_fail
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Some helper functions */
end_comment

begin_comment
comment|/*  * ADDBA (and potentially others) need to be placed in the same  * hardware queue as the TID/node it's relating to. This is so  * it goes out after any pending non-aggregate frames to the  * same node/TID.  *  * If this isn't done, the ADDBA can go out before the frames  * queued in hardware. Even though these frames have a sequence  * number -earlier- than the ADDBA can be transmitted (but  * no frames whose sequence numbers are after the ADDBA should  * be!) they'll arrive after the ADDBA - and the receiving end  * will simply drop them as being out of the BAW.  *  * The frames can't be appended to the TID software queue - it'll  * never be sent out. So these frames have to be directly  * dispatched to the hardware, rather than queued in software.  * So if this function returns true, the TXQ has to be  * overridden and it has to be directly dispatched.  *  * It's a dirty hack, but someone's gotta do it.  */
end_comment

begin_comment
comment|/*  * XXX doesn't belong here!  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_is_action
parameter_list|(
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|)
block|{
comment|/* Type: Management frame? */
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_MGT
condition|)
return|return
literal|0
return|;
comment|/* Subtype: Action frame? */
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_SUBTYPE_ACTION
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_comment
comment|/*  * Return an alternate TID for ADDBA request frames.  *  * Yes, this likely should be done in the net80211 layer.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_action_frame_override_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_action_ba_addbarequest
modifier|*
name|ia
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|;
comment|/* Not action frame? Bail */
if|if
condition|(
operator|!
name|ieee80211_is_action
argument_list|(
name|wh
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* XXX Not needed for frames we send? */
if|#
directive|if
literal|0
comment|/* Correct length? */
block|if (! ieee80211_parse_action(ni, m)) 		return 0;
endif|#
directive|endif
comment|/* Extract out action frame */
name|frm
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
expr_stmt|;
name|ia
operator|=
operator|(
expr|struct
name|ieee80211_action_ba_addbarequest
operator|*
operator|)
name|frm
expr_stmt|;
comment|/* Not ADDBA? Bail */
if|if
condition|(
name|ia
operator|->
name|rq_header
operator|.
name|ia_category
operator|!=
name|IEEE80211_ACTION_CAT_BA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ia
operator|->
name|rq_header
operator|.
name|ia_action
operator|!=
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
condition|)
return|return
literal|0
return|;
comment|/* Extract TID, return it */
name|baparamset
operator|=
name|le16toh
argument_list|(
name|ia
operator|->
name|rq_baparamset
argument_list|)
expr_stmt|;
operator|*
name|tid
operator|=
operator|(
name|int
operator|)
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MS
end_undef

begin_comment
comment|/* Per-node software queue operations */
end_comment

begin_comment
comment|/*  * Add the current packet to the given BAW.  * It is assumed that the current packet  *  * + fits inside the BAW;  * + already has had a sequence number allocated.  *  * Since the BAW status may be modified by both the ath task and  * the net80211/ifnet contexts, the TID must be locked.  */
end_comment

begin_function
name|void
name|ath_tx_addto_baw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|cindex
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
condition|)
return|return;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: re-added? tid=%d, seqno %d; window %d:%d; baw head=%d tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
comment|/* 	 * ni->ni_txseqs[] is the currently allocated seqno. 	 * the txa state contains the current baw start. 	 */
name|index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|cindex
operator|=
operator|(
name|tid
operator|->
name|baw_head
operator|+
name|index
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: tid=%d, seqno %d; window %d:%d; index=%d cindex=%d baw head=%d tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|index
argument_list|,
name|cindex
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|assert(tid->tx_buf[cindex] == NULL);
endif|#
directive|endif
if|if
condition|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: ba packet dup (index=%d, cindex=%d, "
literal|"head=%d, tail=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|,
name|cindex
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: BA bf: %p; seqno=%d ; new bf: %p; seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
argument_list|,
name|SEQNO
argument_list|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|=
name|bf
expr_stmt|;
if|if
condition|(
name|index
operator|>=
operator|(
operator|(
name|tid
operator|->
name|baw_tail
operator|-
name|tid
operator|->
name|baw_head
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|tid
operator|->
name|baw_tail
operator|=
name|cindex
expr_stmt|;
name|INCR
argument_list|(
name|tid
operator|->
name|baw_tail
argument_list|,
name|ATH_TID_MAX_BUFS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * seq_start - left edge of BAW  * seq_next - current/next sequence number to allocate  *  * Since the BAW status may be modified by both the ath task and  * the net80211/ifnet contexts, the TID must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_update_baw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|cindex
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|seqno
init|=
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|cindex
operator|=
operator|(
name|tid
operator|->
name|baw_head
operator|+
name|index
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: tid=%d, baw=%d:%d, seqno=%d, index=%d, cindex=%d, baw head=%d, tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|seqno
argument_list|,
name|index
argument_list|,
name|cindex
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
comment|/* 	 * If this occurs then we have a big problem - something else 	 * has slid tap->txa_start along without updating the BAW 	 * tracking start/end pointers. Thus the TX BAW state is now 	 * completely busted. 	 * 	 * But for now, since I haven't yet fixed TDMA and buffer cloning, 	 * it's quite possible that a cloned buffer is making its way 	 * here and causing it to fire off. Disable TDMA for now. 	 */
if|if
condition|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|!=
name|bf
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: comp bf=%p, seq=%d; slot bf=%p, seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
argument_list|,
name|SEQNO
argument_list|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|tid
operator|->
name|baw_head
operator|!=
name|tid
operator|->
name|baw_tail
operator|&&
operator|!
name|tid
operator|->
name|tx_buf
index|[
name|tid
operator|->
name|baw_head
index|]
condition|)
block|{
name|INCR
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
name|tid
operator|->
name|baw_head
argument_list|,
name|ATH_TID_MAX_BUFS
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: baw is now %d:%d, baw head=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the current node/TID as ready to TX.  *  * This is done to make it easy for the software scheduler to  * find which nodes have data to send.  *  * The TXQ lock must be held.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
return|return;
comment|/* paused, can't schedule yet */
if|if
condition|(
name|tid
operator|->
name|sched
condition|)
return|return;
comment|/* already scheduled */
name|tid
operator|->
name|sched
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|,
name|tid
argument_list|,
name|axq_qelem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the current node as no longer needing to be polled for  * TX packets.  *  * The TXQ lock must be held.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_unsched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|sched
operator|==
literal|0
condition|)
return|return;
name|tid
operator|->
name|sched
operator|=
literal|0
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|,
name|tid
argument_list|,
name|axq_qelem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assign a sequence number manually to the given frame.  *  * This should only be called for A-MPDU TX frames.  */
end_comment

begin_function
specifier|static
name|ieee80211_seq
name|ath_tx_tid_seqno_assign
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|pri
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
comment|/* TID lookup */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* honor classification */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|pri
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: pri=%d, tid=%d, qos has seq=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pri
argument_list|,
name|tid
argument_list|,
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX Is it a control frame? Ignore */
comment|/* Does the packet require a sequence number? */
if|if
condition|(
operator|!
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Is it a QOS NULL Data frame? Give it a sequence number from 	 * the default TID (IEEE80211_NONQOS_TID.) 	 * 	 * The RX path of everything I've looked at doesn't include the NULL 	 * data frame sequence number in the aggregation state updates, so 	 * assigning it a sequence number there will cause a BAW hole on the 	 * RX side. 	 */
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
condition|)
block|{
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
expr_stmt|;
name|INCR
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Manually assign sequence number */
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
expr_stmt|;
name|INCR
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|M_SEQNO_SET
argument_list|(
name|m0
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
comment|/* Return so caller can do something with it if needed */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s:  -> seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
return|return
name|seqno
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to direct dispatch an aggregate frame to hardware.  * If the frame is out of BAW, queue.  * Otherwise, schedule it as a single frame.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_xmit_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
index|]
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txq
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
comment|/* paused? queue */
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
block|{
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* outside baw? queue */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|&&
operator|(
operator|!
name|BAW_WITHIN
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Direct dispatch to hardware */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Statistics */
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_low_hwq_single_pkt
operator|++
expr_stmt|;
comment|/* Track per-TID hardware queue depth correctly */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* Add to BAW */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_addto_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set completion handler, multi-frame aggregate or not */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_aggr_comp
expr_stmt|;
comment|/* Hand off to hardware */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to send the packet.  * If the queue isn't busy, direct-dispatch.  * If the queue is busy enough, queue the given packet on the  *  relevant software queue.  */
end_comment

begin_function
name|void
name|ath_tx_swq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
decl_stmt|;
name|int
name|pri
decl_stmt|,
name|tid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
comment|/* Fetch the TID - non-QoS frames get assigned to TID 16 */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pri
operator|=
name|ath_tx_getac
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|tid
operator|=
name|ath_tx_gettid
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|atid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p, pri=%d, tid=%d, qos=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|pri
argument_list|,
name|tid
argument_list|,
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set local packet state, used to queue packets to hardware */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
operator|=
name|tid
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txq
operator|=
name|txq
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pri
operator|=
name|pri
expr_stmt|;
comment|/* 	 * If the hardware queue isn't busy, queue it directly. 	 * If the hardware queue is busy, queue it. 	 * If the TID is paused or the traffic it outside BAW, software 	 * queue it. 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|paused
condition|)
block|{
comment|/* TID is paused, queue */
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ath_tx_ampdu_pending
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|)
condition|)
block|{
comment|/* AMPDU pending; queue */
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* XXX sched? */
block|}
elseif|else
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|)
condition|)
block|{
comment|/* AMPDU running, attempt direct dispatch if possible */
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|<
name|sc
operator|->
name|sc_hwq_limit
condition|)
name|ath_tx_xmit_aggr
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|bf
argument_list|)
expr_stmt|;
else|else
block|{
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|<
name|sc
operator|->
name|sc_hwq_limit
condition|)
block|{
comment|/* AMPDU not running, attempt direct dispatch */
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Busy; queue */
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the basic frame setup stuff that's required before the frame  * is added to a software queue.  *  * All frames get mostly the same treatment and it's done once.  * Retransmits fiddle with things like the rate control setup,  * setting the retransmit bit in the packet; doing relevant DMA/bus  * syncing and relinking it (back) into the hardware TX queue.  *  * Note that this may cause the mbuf to be reallocated, so  * m0 may not be valid.  */
end_comment

begin_comment
comment|/*  * Configure the per-TID node state.  *  * This likely belongs in if_ath_node.c but I can't think of anywhere  * else to put it just yet.  *  * This sets up the SLISTs and the mutex as appropriate.  */
end_comment

begin_function
name|void
name|ath_tx_tid_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|atid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|atid
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|atid
operator|->
name|tid
operator|=
name|i
expr_stmt|;
name|atid
operator|->
name|an
operator|=
name|an
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ATH_TID_MAX_BUFS
condition|;
name|j
operator|++
control|)
name|atid
operator|->
name|tx_buf
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|atid
operator|->
name|baw_head
operator|=
name|atid
operator|->
name|baw_tail
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|paused
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|sched
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|atid
operator|->
name|ac
operator|=
name|WME_AC_BE
expr_stmt|;
else|else
name|atid
operator|->
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pause the current TID. This stops packets from being transmitted  * on it.  *  * Since this is also called from upper layers as well as the driver,  * it will get the TID lock.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_pause
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|tid
operator|->
name|paused
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: paused = %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|paused
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unpause the current TID, and schedule it if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|tid
operator|->
name|paused
operator|--
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: unpaused = %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|paused
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|paused
operator|||
name|tid
operator|->
name|axq_depth
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* Punt some frames to the hardware if needed */
name|ath_txq_sched
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free any packets currently pending in the software TX queue.  *  * This will be called when a node is being deleted.  *  * It can also be called on an active node during an interface  * reset or state transition.  *  * (From Linux/reference):  *  * TODO: For frame(s) that are in the retry state, we will reuse the  * sequence number(s) without setting the retry bit. The  * alternative is to give up on these and BAR the receiver's window  * forward.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_drain
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_cq
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* Walk the queue, free frames */
for|for
control|(
init|;
condition|;
control|)
block|{
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tid
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: node %p: tid %d: txq_depth=%d, "
literal|"txq_aggr_depth=%d, sched=%d, paused=%d, "
literal|"hwq_depth=%d, incomp=%d, baw_head=%d, baw_tail=%d "
literal|"txa_start=%d, ni_txseqs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|,
name|txq
operator|->
name|axq_aggr_depth
argument_list|,
name|tid
operator|->
name|sched
argument_list|,
name|tid
operator|->
name|paused
argument_list|,
name|tid
operator|->
name|hwq_depth
argument_list|,
name|tid
operator|->
name|incomp
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|,
name|tap
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|tap
operator|->
name|txa_start
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
operator|->
name|tid
index|]
argument_list|)
expr_stmt|;
name|t
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If the current TID is running AMPDU, update 		 * the BAW. 		 */
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
operator|&&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
comment|/* 			 * Only remove the frame from the BAW if it's 			 * been transmitted at least once; this means 			 * the frame was in the BAW to begin with. 			 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>
literal|0
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * This has become a non-fatal error now 			 */
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that it's completed, grab the TID lock and update 	 * the sequence number and BAW window. 	 * Because sequence numbers have been assigned to frames 	 * that haven't been sent yet, it's entirely possible 	 * we'll be called with some pending frames that have not 	 * been transmitted. 	 * 	 * The cleaner solution is to do the sequence number allocation 	 * when the packet is first transmitted - and thus the "retries" 	 * check above would be enough to update the BAW/seqno. 	 */
comment|/* But don't do it for non-QoS TIDs */
if|if
condition|(
name|tap
condition|)
block|{
if|#
directive|if
literal|0
block|DPRINTF(sc, ATH_DEBUG_SW_TX_CTRL, 		    "%s: node %p: TID %d: sliding BAW left edge to %d\n", 		    __func__, an, tid->tid, tap->txa_start);
endif|#
directive|endif
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
operator|->
name|tid
index|]
operator|=
name|tap
operator|->
name|txa_start
expr_stmt|;
name|tid
operator|->
name|baw_tail
operator|=
name|tid
operator|->
name|baw_head
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flush all software queued packets for the given node.  *  * This occurs when a completion handler frees the last buffer  * for a node, and the node is thus freed. This causes the node  * to be cleaned up, which ends up calling ath_tx_node_flush.  */
end_comment

begin_function
name|void
name|ath_tx_node_flush
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|tid
operator|++
control|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
decl_stmt|;
comment|/* Remove this tid from the list of active tids */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ath_tx_tid_unsched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* Free packets */
name|ath_tx_tid_drain
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
comment|/* Handle completed frames */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain all the software TXQs currently with traffic queued.  */
end_comment

begin_function
name|void
name|ath_tx_txq_drain
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all active tids for the given txq, 	 * flushing and unsched'ing them 	 */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|)
condition|)
block|{
name|tid
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|)
expr_stmt|;
name|ath_tx_tid_drain
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ath_tx_tid_unsched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle completion of non-aggregate session frames.  */
end_comment

begin_function
name|void
name|ath_tx_normal_comp
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_tx_status
modifier|*
name|ts
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
decl_stmt|;
comment|/* The TID state is protected behind the TXQ lock */
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p: fail=%d, hwq_depth now %d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|,
name|atid
operator|->
name|hwq_depth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|hwq_depth
operator|<
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: hwq_depth< 0: %d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * punt to rate control if we're not being cleaned up 	 * during a hw queue drain and the frame wanted an ACK. 	 */
if|if
condition|(
name|fail
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|)
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
name|ts
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
literal|1
argument_list|,
operator|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle cleanup of aggregate session packets that aren't  * an A-MPDU.  *  * There's no need to update the BAW here - the session is being  * torn down.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_comp_cleanup_unaggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: incomp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|atid
operator|->
name|incomp
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|atid
operator|->
name|incomp
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|incomp
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: cleaned up! resume!\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|0
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs transmit side cleanup when TID changes from aggregated to  * unaggregated.  *  * - Discard all retry frames from the s/w queue.  * - Fix the tx completion function for all buffers in s/w queue.  * - Count the number of unacked frames, and let transmit completion  *   handle it later.  *  * The caller is responsible for pausing the TID.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: called\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Update the frames in the software TX queue: 	 * 	 * + Discard retry frames in the queue 	 * + Fix the completion function to be non-aggregate 	 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|atid
operator|->
name|axq_q
argument_list|)
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
condition|)
block|{
name|bf_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|atid
operator|->
name|axq_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|atid
operator|->
name|axq_depth
operator|--
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Call the default completion handler with "fail" just 			 * so upper levels are suitably notified about this. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|bf
operator|=
name|bf_next
expr_stmt|;
continue|continue;
block|}
comment|/* Give these the default completion handler */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_normal_comp
expr_stmt|;
name|bf
operator|=
name|TAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* The caller is required to pause the TID */
if|#
directive|if
literal|0
comment|/* Pause the TID */
block|ath_tx_tid_pause(sc, atid);
endif|#
directive|endif
comment|/* 	 * Calculate what hardware-queued frames exist based 	 * on the current BAW size. Ie, what frames have been 	 * added to the TX hardware queue for this TID but 	 * not yet ACKed. 	 */
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* Need the lock - fiddling with BAW */
while|while
condition|(
name|atid
operator|->
name|baw_head
operator|!=
name|atid
operator|->
name|baw_tail
condition|)
block|{
if|if
condition|(
name|atid
operator|->
name|tx_buf
index|[
name|atid
operator|->
name|baw_head
index|]
condition|)
block|{
name|atid
operator|->
name|incomp
operator|++
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|1
expr_stmt|;
name|atid
operator|->
name|tx_buf
index|[
name|atid
operator|->
name|baw_head
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|INCR
argument_list|(
name|atid
operator|->
name|baw_head
argument_list|,
name|ATH_TID_MAX_BUFS
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If cleanup is required, defer TID scheduling 	 * until all the HW queued packets have been 	 * sent. 	 */
if|if
condition|(
operator|!
name|atid
operator|->
name|cleanup_inprogress
condition|)
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|cleanup_inprogress
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: cleanup needed: %d packets\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|atid
operator|->
name|incomp
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* Handle completing frames and fail them */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_set_retry
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* Only update/resync if needed */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
operator|==
literal|0
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_RETRY
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretries
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
operator|=
literal|1
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_tx_retry_clone
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nbf
operator|=
name|ath_buf_clone
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|device_printf(sc->sc_dev, "%s: ATH_BUF_BUSY; cloning\n", 	    __func__);
endif|#
directive|endif
if|if
condition|(
name|nbf
operator|==
name|NULL
condition|)
block|{
comment|/* Failed to clone */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to clone a busy buffer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Setup the dma for the new buffer */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|nbf
argument_list|,
name|nbf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: failed to setup dma for clone\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * Put this at the head of the list, not tail; 		 * that way it doesn't interfere with the 		 * busy buffer logic (which uses the tail of 		 * the list.) 		 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|nbf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Free current buffer; return the older buffer */
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
name|ath_freebuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
name|nbf
return|;
block|}
end_function

begin_comment
comment|/*  * Handle retrying an unaggregate frame in an aggregate  * session.  *  * If too many retries occur, pause the TID, wait for  * any further retransmits (as there's no reason why  * non-aggregate frames in an aggregate session are  * transmitted in-order; they just have to be in-BAW)  * and then queue a BAR.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_aggr_retry_unaggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|txseq
decl_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * If the buffer is marked as busy, we can't directly 	 * reuse it. Instead, try to clone the buffer. 	 * If the clone is successful, recycle the old buffer. 	 * If the clone is unsuccessful, set bfs_retries to max 	 * to force the next bit of code to free the buffer 	 * for us. 	 */
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|<
name|SWMAX_RETRIES
operator|)
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|nbf
operator|=
name|ath_tx_retry_clone
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbf
condition|)
comment|/* bf has been freed at this point */
name|bf
operator|=
name|nbf
expr_stmt|;
else|else
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|=
name|SWMAX_RETRIES
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>=
name|SWMAX_RETRIES
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_RETRIES
argument_list|,
literal|"%s: exceeded retries; seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretrymax
operator|++
expr_stmt|;
comment|/* Update BAW anyway */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
comment|/* Send BAR frame */
comment|/* 		 * This'll end up going into net80211 and back out 		 * again, via ic->ic_raw_xmit(). 		 */
name|txseq
operator|=
name|tap
operator|->
name|txa_start
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TID %d: send BAR; seq %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|txseq
argument_list|)
expr_stmt|;
comment|/* XXX TODO: send BAR */
comment|/* Free buffer, bf is free after this call */
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This increments the retry counter as well as 	 * sets the retry flag in the ath_buf and packet 	 * body. 	 */
name|ath_tx_set_retry
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 	 * Insert this at the head of the queue, so it's 	 * retried before any current/subsequent frames. 	 */
name|ATH_TXQ_INSERT_HEAD
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common code for aggregate excessive retry/subframe retry.  * If retrying, queues buffers to bf_q. If not, frees the  * buffers.  *  * XXX should unify this with ath_tx_aggr_retry_unaggr()  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_retry_subframe
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_q
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
name|ath_hal_set11nburstduration
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ath_hal_set11n_virtualmorefrag(sc->sc_ah, bf->bf_desc, 0); */
comment|/* 	 * If the buffer is marked as busy, we can't directly 	 * reuse it. Instead, try to clone the buffer. 	 * If the clone is successful, recycle the old buffer. 	 * If the clone is unsuccessful, set bfs_retries to max 	 * to force the next bit of code to free the buffer 	 * for us. 	 */
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|<
name|SWMAX_RETRIES
operator|)
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|nbf
operator|=
name|ath_tx_retry_clone
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbf
condition|)
comment|/* bf has been freed at this point */
name|bf
operator|=
name|nbf
expr_stmt|;
else|else
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|=
name|SWMAX_RETRIES
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>=
name|SWMAX_RETRIES
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretrymax
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_RETRIES
argument_list|,
literal|"%s: max retries: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ath_tx_set_retry
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Just to make sure */
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * error pkt completion for an aggregate destination  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_comp_aggr_error
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf_first
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf_next
decl_stmt|,
modifier|*
name|bf
decl_stmt|;
name|ath_bufhead
name|bf_q
decl_stmt|;
name|int
name|drops
init|=
literal|0
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_aggrfail
operator|++
expr_stmt|;
comment|/* 	 * Update rate control - all frames have failed. 	 * 	 * XXX use the length in the first frame in the series; 	 * XXX just so things are consistent for now. 	 */
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
operator|&
name|bf_first
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
comment|/* Retry all subframes */
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Remove it from the aggr list */
if|if
condition|(
name|ath_tx_retry_subframe
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
operator|&
name|bf_q
argument_list|)
condition|)
block|{
name|drops
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
comment|/* Prepend all frames to the beginning of the queue */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bf_q
argument_list|,
name|ath_bufhead_s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXQ_INSERT_HEAD
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * send bar if we dropped any frames 	 * 	 * Keep the txq lock held for now, as we need to ensure 	 * that ni_txseqs[] is consistent (as it's being updated 	 * in the ifnet TX context or raw TX context.) 	 */
if|if
condition|(
name|drops
condition|)
block|{
name|int
name|txseq
init|=
name|tap
operator|->
name|txa_start
decl_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TID %d: send BAR; seq %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|txseq
argument_list|)
expr_stmt|;
comment|/* XXX TODO: send BAR */
block|}
else|else
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Complete frames which errored out */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle clean-up of packets from an aggregate list.  *  * There's no need to update the BAW here - the session is being  * torn down.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_comp_cleanup_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf_first
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|bf
operator|=
name|bf_first
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* update incomp */
while|while
condition|(
name|bf
condition|)
block|{
name|atid
operator|->
name|incomp
operator|--
expr_stmt|;
name|bf
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
block|}
if|if
condition|(
name|atid
operator|->
name|incomp
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: cleaned up! resume!\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|0
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* Handle frame completion */
while|while
condition|(
name|bf
condition|)
block|{
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle completion of an set of aggregate frames.  *  * XXX for now, simply complete each sub-frame.  *  * Note: the completion handler is the last descriptor in the aggregate,  * not the last descriptor in the first frame.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_aggr_comp_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
comment|//struct ath_desc *ds = bf->bf_lastds;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf_first
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_tx_status
name|ts
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ath_bufhead
name|bf_q
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|int
name|seq_st
decl_stmt|,
name|tx_ok
decl_stmt|;
name|int
name|hasba
decl_stmt|,
name|isaggr
decl_stmt|;
name|uint32_t
name|ba
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|;
name|int
name|ba_index
decl_stmt|;
name|int
name|drops
init|=
literal|0
decl_stmt|;
name|int
name|nframes
init|=
literal|0
decl_stmt|,
name|nbad
init|=
literal|0
decl_stmt|,
name|nf
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
comment|/* XXX there's too much on the stack? */
name|struct
name|ath_rc_series
name|rc
index|[
literal|4
index|]
decl_stmt|;
name|int
name|txseq
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: called; hwq_depth=%d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* The TID state is kept behind the TXQ lock */
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|hwq_depth
operator|<
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: hwq_depth< 0: %d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * Punt cleanup to the relevant function, not our problem now 	 */
if|if
condition|(
name|atid
operator|->
name|cleanup_inprogress
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_comp_cleanup_aggr
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Take a copy; this may be needed -after- bf_first 	 * has been completed and freed. 	 */
name|ts
operator|=
name|bf_first
operator|->
name|bf_status
operator|.
name|ds_txstat
expr_stmt|;
comment|/* 	 * XXX for now, use the first frame in the aggregate for 	 * XXX rate control completion; it's at least consistent. 	 */
name|pktlen
operator|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_pktlen
expr_stmt|;
comment|/* 	 * handle errors first 	 */
if|if
condition|(
name|ts
operator|.
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_comp_aggr_error
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|,
name|atid
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * extract starting sequence and block-ack bitmap 	 */
comment|/* XXX endian-ness of seq_st, ba? */
name|seq_st
operator|=
name|ts
operator|.
name|ts_seqnum
expr_stmt|;
name|hasba
operator|=
operator|!
operator|!
operator|(
name|ts
operator|.
name|ts_flags
operator|&
name|HAL_TX_BA
operator|)
expr_stmt|;
name|tx_ok
operator|=
operator|(
name|ts
operator|.
name|ts_status
operator|==
literal|0
operator|)
expr_stmt|;
name|isaggr
operator|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_aggr
expr_stmt|;
name|ba
index|[
literal|0
index|]
operator|=
name|ts
operator|.
name|ts_ba_low
expr_stmt|;
name|ba
index|[
literal|1
index|]
operator|=
name|ts
operator|.
name|ts_ba_high
expr_stmt|;
comment|/* 	 * Copy the TX completion status and the rate control 	 * series from the first descriptor, as it may be freed 	 * before the rate control code can get its grubby fingers 	 * into things. 	 */
name|memcpy
argument_list|(
name|rc
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: txa_start=%d, tx_ok=%d, status=%.8x, flags=%.8x, isaggr=%d, seq_st=%d, hasba=%d, ba=%.8x, %.8x\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tx_ok
argument_list|,
name|ts
operator|.
name|ts_status
argument_list|,
name|ts
operator|.
name|ts_flags
argument_list|,
name|isaggr
argument_list|,
name|seq_st
argument_list|,
name|hasba
argument_list|,
name|ba
index|[
literal|0
index|]
argument_list|,
name|ba
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Occasionally, the MAC sends a tx status for the wrong TID. */
if|if
condition|(
name|tid
operator|!=
name|ts
operator|.
name|ts_tid
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: tid %d != hw tid %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|ts
operator|.
name|ts_tid
argument_list|)
expr_stmt|;
name|tx_ok
operator|=
literal|0
expr_stmt|;
block|}
comment|/* AR5416 BA bug; this requires an interface reset */
if|if
condition|(
name|isaggr
operator|&&
name|tx_ok
operator|&&
operator|(
operator|!
name|hasba
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: AR5416 bug: hasba=%d; txok=%d, isaggr=%d, seq_st=%d\n"
argument_list|,
name|__func__
argument_list|,
name|hasba
argument_list|,
name|tx_ok
argument_list|,
name|isaggr
argument_list|,
name|seq_st
argument_list|)
expr_stmt|;
comment|/* XXX TODO: schedule an interface reset */
block|}
comment|/* 	 * Walk the list of frames, figure out which ones were correctly 	 * sent and which weren't. 	 */
name|bf
operator|=
name|bf_first
expr_stmt|;
name|nf
operator|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
expr_stmt|;
comment|/* bf_first is going to be invalid once this list is walked */
name|bf_first
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Walk the list of completed frames and determine 	 * which need to be completed and which need to be 	 * retransmitted. 	 * 	 * For completed frames, the completion functions need 	 * to be called at the end of this function as the last 	 * node reference may free the node. 	 * 	 * Finally, since the TXQ lock can't be held during the 	 * completion callback (to avoid lock recursion), 	 * the completion calls have to be done outside of the 	 * lock. 	 */
while|while
condition|(
name|bf
condition|)
block|{
name|nframes
operator|++
expr_stmt|;
name|ba_index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|seq_st
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Remove it from the aggr list */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: checking bf=%p seqno=%d; ack=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|ATH_BA_ISSET
argument_list|(
name|ba
argument_list|,
name|ba_index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ok
operator|&&
name|ATH_BA_ISSET
argument_list|(
name|ba
argument_list|,
name|ba_index
argument_list|)
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ath_tx_retry_subframe
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
operator|&
name|bf_q
argument_list|)
condition|)
block|{
name|drops
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|nbad
operator|++
expr_stmt|;
block|}
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
comment|/* 	 * Now that the BAW updates have been done, unlock 	 * 	 * txseq is grabbed before the lock is released so we 	 * have a consistent view of what -was- in the BAW. 	 * Anything after this point will not yet have been 	 * TXed. 	 */
name|txseq
operator|=
name|tap
operator|->
name|txa_start
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nframes
operator|!=
name|nf
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: num frames seen=%d; bf nframes=%d\n"
argument_list|,
name|__func__
argument_list|,
name|nframes
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* 	 * Now we know how many frames were bad, call the rate 	 * control code. 	 */
if|if
condition|(
name|fail
operator|==
literal|0
condition|)
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|rc
argument_list|,
operator|&
name|ts
argument_list|,
name|pktlen
argument_list|,
name|nframes
argument_list|,
name|nbad
argument_list|)
expr_stmt|;
comment|/* 	 * send bar if we dropped any frames 	 */
if|if
condition|(
name|drops
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TID %d: send BAR; seq %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|txseq
argument_list|)
expr_stmt|;
comment|/* XXX TODO: send BAR */
block|}
comment|/* Prepend all frames to the beginning of the queue */
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bf_q
argument_list|,
name|ath_bufhead_s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXQ_INSERT_HEAD
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: txa_start now %d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|)
expr_stmt|;
comment|/* Do deferred completion */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle completion of unaggregated frames in an ADDBA  * session.  *  * Fail is set to 1 if the entry is being freed via a call to  * ath_tx_draintxq().  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_aggr_comp_unaggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_tx_status
modifier|*
name|ts
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
decl_stmt|;
comment|/* 	 * Update rate control status here, before we possibly 	 * punt to retry or cleanup. 	 * 	 * Do it outside of the TXQ lock. 	 */
if|if
condition|(
name|fail
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bf
operator|->
name|bf_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|)
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
literal|1
argument_list|,
operator|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * This is called early so atid->hwq_depth can be tracked. 	 * This unfortunately means that it's released and regrabbed 	 * during retry and cleanup. That's rather inefficient. 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TID=16!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p: tid=%d, hwq_depth=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|hwq_depth
operator|<
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: hwq_depth< 0: %d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * If a cleanup is in progress, punt to comp_cleanup; 	 * rather than handling it here. It's thus their 	 * responsibility to clean up, call the completion 	 * function in net80211, etc. 	 */
if|if
condition|(
name|atid
operator|->
name|cleanup_inprogress
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_comp_cleanup_unaggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Don't bother with the retry check if all frames 	 * are being failed (eg during queue deletion.) 	 */
if|if
condition|(
name|fail
operator|==
literal|0
operator|&&
name|ts
operator|->
name|ts_status
operator|&
name|HAL_TXERR_XRETRY
condition|)
block|{
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_aggr_retry_unaggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success? Complete */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: TID=%d, seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
comment|/* bf is freed at this point */
block|}
end_function

begin_function
name|void
name|ath_tx_aggr_comp
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|ath_tx_aggr_comp_aggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
else|else
name|ath_tx_aggr_comp_unaggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Schedule some packets from the given node/TID to the hardware.  *  * This is the aggregate version.  */
end_comment

begin_function
name|void
name|ath_tx_tid_hw_queue_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|ATH_AGGR_STATUS
name|status
decl_stmt|;
name|ath_bufhead
name|bf_q
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: called for TID=NONQOS_TID?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|ATH_AGGR_DONE
expr_stmt|;
comment|/* 		 * If the upper layer has paused the TID, don't 		 * queue any further packets. 		 * 		 * This can also occur from the completion task because 		 * of packet loss; but as its serialised with this code, 		 * it won't "appear" half way through queuing packets. 		 */
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
break|break;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tid
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 		 * If the packet doesn't fall within the BAW (eg a NULL 		 * data frame), schedule it directly; continue. 		 */
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: non-baw packet\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TXQ_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_nonbaw_pkt
operator|++
expr_stmt|;
comment|/* Queue the packet; continue */
goto|goto
name|queuepkt
goto|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
comment|/* 		 * Do a rate control lookup on the first frame in the 		 * list. The rate control code needs that to occur 		 * before it can determine whether to TX. 		 * It's inaccurate because the rate control code doesn't 		 * really "do" aggregate lookups, so it only considers 		 * the size of the first frame. 		 */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|rix
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|tries
operator|=
literal|0
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|status
operator|=
name|ath_tx_form_aggr
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
operator|&
name|bf_q
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: ath_tx_form_aggr() status=%d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * No frames to be picked up - out of BAW 		 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|bf_q
argument_list|)
condition|)
break|break;
comment|/* 		 * This assumes that the descriptor list in the ath_bufhead 		 * are already linked together via bf_next pointers. 		 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
comment|/* 		 * If it's the only frame send as non-aggregate 		 * assume that ath_tx_form_aggr() has checked 		 * whether it's in the BAW and added it appropriately. 		 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: single-frame aggregate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ATH_AGGR_BAW_CLOSED
condition|)
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_baw_closed_single_pkt
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_single_pkt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: multi-frame aggregate: %d frames, length %d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_al
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_pkts
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_aggr_pkt
operator|++
expr_stmt|;
comment|/* 			 * Update the rate and rtscts information based on the 			 * rate decision made by the rate control code; 			 * the first frame in the aggregate needs it. 			 */
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 			 * Setup the relevant descriptor fields 			 * for aggregation. The first descriptor 			 * already points to the rest in the chain. 			 */
name|ath_tx_setds_11n
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 			 * setup first desc with rate and aggr info 			 */
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
name|queuepkt
label|:
comment|//txq = bf->bf_state.bfs_txq;
comment|/* Set completion handler, multi-frame aggregate or not */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_aggr_comp
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: TID=16?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Punt to txq */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Track outstanding buffer count to hardware */
comment|/* aggregates are "one" buffer */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* 		 * Break out if ath_tx_form_aggr() indicated 		 * there can't be any further progress (eg BAW is full.) 		 * Checking for an empty txq is done above. 		 * 		 * XXX locking on txq here? 		 */
if|if
condition|(
name|txq
operator|->
name|axq_aggr_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit
operator|||
name|status
operator|==
name|ATH_AGGR_BAW_CLOSED
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule some packets from the given node/TID to the hardware.  */
end_comment

begin_function
name|void
name|ath_tx_tid_hw_queue_norm
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: node %p: TID %d: called\n"
argument_list|,
name|__func__
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Check - is AMPDU pending or running? then print out something */
if|if
condition|(
name|ath_tx_ampdu_pending
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: tid=%d, ampdu pending?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: tid=%d, ampdu running?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If the upper layers have paused the TID, don't 		 * queue any further packets. 		 */
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
break|break;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tid
operator|->
name|axq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|ATH_TXQ_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|==
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txq
argument_list|,
operator|(
literal|"txqs not equal!\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Sanity check! */
if|if
condition|(
name|tid
operator|->
name|tid
operator|!=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: bfs_tid %d !="
literal|" tid %d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
comment|/* Normal completion handler */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_normal_comp
expr_stmt|;
comment|/* Program descriptors + rate control */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Track outstanding buffer count to hardware */
comment|/* aggregates are "one" buffer */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* Punt to hardware or software txq */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule some packets to the given hardware queue.  *  * This function walks the list of TIDs (ie, ath_node TIDs  * with queued traffic) and attempts to schedule traffic  * from them.  *  * TID scheduling is implemented as a FIFO, with TIDs being  * added to the end of the queue after some frames have been  * scheduled.  */
end_comment

begin_function
name|void
name|ath_txq_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 	 * Don't schedule if the hardware queue is busy. 	 * This (hopefully) gives some more time to aggregate 	 * some packets in the aggregation queue. 	 */
if|if
condition|(
name|txq
operator|->
name|axq_aggr_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit
condition|)
block|{
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_sched_nopkt
operator|++
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|,
name|axq_t_s
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tid
argument_list|,
argument|&txq->axq_tidq
argument_list|,
argument|axq_qelem
argument_list|,
argument|next
argument_list|)
block|{
comment|/* 		 * Suspend paused queues here; they'll be resumed 		 * once the addba completes or times out. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d, paused=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|paused
argument_list|)
expr_stmt|;
name|ath_tx_tid_unsched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
condition|)
name|ath_tx_tid_hw_queue_aggr
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
name|ath_tx_tid_hw_queue_norm
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* Not empty? Re-schedule */
if|if
condition|(
name|tid
operator|->
name|axq_depth
operator|!=
literal|0
condition|)
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* Give the software queue time to aggregate more packets */
if|if
condition|(
name|txq
operator|->
name|axq_aggr_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit
condition|)
block|{
break|break;
block|}
comment|/* 		 * If this was the last entry on the original list, stop. 		 * Otherwise nodes that have been rescheduled onto the end 		 * of the TID FIFO list will just keep being rescheduled. 		 */
if|if
condition|(
name|tid
operator|==
name|last
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * TX addba handling  */
end_comment

begin_comment
comment|/*  * Return net80211 TID struct pointer, or NULL for none  */
end_comment

begin_function
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|ath_tx_get_tx_tid
parameter_list|(
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|ac
decl_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
return|return
name|NULL
return|;
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
return|return
name|tap
return|;
block|}
end_function

begin_comment
comment|/*  * Is AMPDU-TX running?  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_ampdu_running
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
return|return
literal|0
return|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Not valid; default to not running */
return|return
operator|!
operator|!
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is AMPDU-TX negotiation pending?  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_ampdu_pending
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
return|return
literal|0
return|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Not valid; default to not pending */
return|return
operator|!
operator|!
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is AMPDU-TX pending for the given TID?  */
end_comment

begin_comment
comment|/*  * Method to handle sending an ADDBA request.  *  * We tap this so the relevant flags can be set to pause the TID  * whilst waiting for the response.  *  * XXX there's no timeout handler we can override?  */
end_comment

begin_function
name|int
name|ath_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
comment|/* 	 * XXX danger Will Robinson! 	 * 	 * Although the taskqueue may be running and scheduling some more 	 * packets, these should all be _before_ the addba sequence number. 	 * However, net80211 will keep self-assigning sequence numbers 	 * until addba has been negotiated. 	 * 	 * In the past, these packets would be "paused" (which still works 	 * fine, as they're being scheduled to the driver in the same 	 * serialised method which is calling the addba request routine) 	 * and when the aggregation session begins, they'll be dequeued 	 * as aggregate packets and added to the BAW. However, now there's 	 * a "bf->bf_state.bfs_dobaw" flag, and this isn't set for these 	 * packets. Thus they never get included in the BAW tracking and 	 * this can cause the initial burst of packets after the addba 	 * negotiation to "hang", as they quickly fall outside the BAW. 	 * 	 * The "eventual" solution should be to tag these packets with 	 * dobaw. Although net80211 has given us a sequence number, 	 * it'll be "after" the left edge of the BAW and thus it'll 	 * fall within it. 	 */
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: called; dialogtoken=%d, baparamset=%d, batimeout=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: txa_start=%d, ni_txseqs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
argument_list|)
expr_stmt|;
return|return
name|sc
operator|->
name|sc_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an ADDBA response.  *  * We unpause the queue so TX'ing can resume.  *  * Any packets TX'ed from this point should be "aggregate" (whether  * aggregate or not) so the BAW is updated.  *  * Note! net80211 keeps self-assigning sequence numbers until  * ampdu is negotiated. This means the initially-negotiated BAW left  * edge won't match the ni->ni_txseq.  *  * So, being very dirty, the BAW left edge is "slid" here to match  * ni->ni_txseq.  *  * What likely SHOULD happen is that all packets subsequent to the  * addba request should be tagged as aggregate and queued as non-aggregate  * frames; thus updating the BAW. For now though, I'll just slide the  * window.  */
end_comment

begin_function
name|int
name|ath_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: called; status=%d, code=%d, batimeout=%d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|,
name|code
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: txa_start=%d, ni_txseqs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Call this first, so the interface flags get updated 	 * before the TID is unpaused. Otherwise a race condition 	 * exists where the unpaused TID still doesn't yet have 	 * IEEE80211_AGGR_RUNNING set. 	 */
name|r
operator|=
name|sc
operator|->
name|sc_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|status
argument_list|,
name|code
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * XXX dirty! 	 * Slide the BAW left edge to wherever net80211 left it for us. 	 * Read above for more information. 	 */
name|tap
operator|->
name|txa_start
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Stop ADDBA on a queue.  */
end_comment

begin_function
name|void
name|ath_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Pause TID traffic early, so there aren't any races */
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* There's no need to hold the TXQ lock here */
name|sc
operator|->
name|sc_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
comment|/* 	 * ath_tx_cleanup will resume the TID if possible, otherwise 	 * it'll set the cleanup flag, and it'll be unpaused once 	 * things have been cleaned up. 	 */
name|ath_tx_cleanup
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note: net80211 bar_timeout() doesn't call this function on BAR failure;  * it simply tears down the aggregation session. Ew.  *  * It however will call ieee80211_ampdu_stop() which will call  * ic->ic_addba_stop().  *  * XXX This uses a hard-coded max BAR count value; the whole  * XXX BAR TX success or failure should be better handled!  */
end_comment

begin_function
name|void
name|ath_bar_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|int
name|attempts
init|=
name|tap
operator|->
name|txa_attempts
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: called; status=%d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Note: This may update the BAW details */
name|sc
operator|->
name|sc_bar_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Unpause the TID */
comment|/* 	 * XXX if this is attempt=50, the TID will be downgraded 	 * XXX to a non-aggregate session. So we must unpause the 	 * XXX TID here or it'll never be done. 	 */
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|attempts
operator|==
literal|50
condition|)
block|{
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called whenever the pending ADDBA request times out.  * Unpause and reschedule the TID.  */
end_comment

begin_function
name|void
name|ath_addba_response_timeout
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: called; resuming\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Note: This updates the aggregate state to (again) pending */
name|sc
operator|->
name|sc_addba_response_timeout
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
comment|/* Unpause the TID; which reschedules it */
name|ATH_TXQ_LOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

