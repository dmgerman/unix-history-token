begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2010-2012 Adrian Chadd, Xenion Pty Ltd  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_ht.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx_ht.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/if_ath_alq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * How many retries to perform in software  */
end_comment

begin_define
define|#
directive|define
name|SWMAX_RETRIES
value|10
end_define

begin_comment
comment|/*  * What queue to throw the non-QoS TID traffic into  */
end_comment

begin_define
define|#
directive|define
name|ATH_NONQOS_TID_AC
value|WME_AC_VO
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int ath_tx_node_is_asleep(struct ath_softc *sc, struct ath_node *an);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ath_tx_ampdu_pending
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_ampdu_running
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ieee80211_seq
name|ath_tx_tid_seqno_assign
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ath_tx_action_frame_override_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
modifier|*
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_tx_retry_clone
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
end_ifdef

begin_function
name|void
name|ath_tx_alq_post
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|ds
decl_stmt|;
comment|/* XXX we should skip out early if debugging isn't enabled! */
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX should ensure bf_nseg> 0! */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
break|break;
name|n
operator|=
operator|(
operator|(
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
operator|)
operator|/
name|sc
operator|->
name|sc_tx_nmaps
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ds
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|bf
operator|->
name|bf_desc
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|ds
operator|+=
name|sc
operator|->
name|sc_tx_desclen
control|)
block|{
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_TXDESC
argument_list|,
name|sc
operator|->
name|sc_tx_desclen
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
name|bf
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_DEBUG_ALQ */
end_comment

begin_comment
comment|/*  * Whether to use the 11n rate scenario functions or not  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ath_tx_is_11n
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|sc
operator|->
name|sc_ah
operator|->
name|ah_magic
operator|==
literal|0x20065416
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_ah
operator|->
name|ah_magic
operator|==
literal|0x19741014
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Obtain the current TID from the given frame.  *  * Non-QoS frames need to go into TID 16 (IEEE80211_NONQOS_TID.)  * This has implications for which AC/priority the packet is placed  * in.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_gettid
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|pri
init|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
name|IEEE80211_NONQOS_TID
return|;
else|else
return|return
name|WME_AC_TO_TID
argument_list|(
name|pri
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_set_retry
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* Only update/resync if needed */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
operator|==
literal|0
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_RETRY
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
operator|=
literal|1
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine what the correct AC queue for the given frame  * should be.  *  * This code assumes that the TIDs map consistently to  * the underlying hardware (or software) ath_txq.  * Since the sender may try to set an AC which is  * arbitrary, non-QoS TIDs may end up being put on  * completely different ACs. There's no way to put a  * TID into multiple ath_txq's for scheduling, so  * for now we override the AC/TXQ selection and set  * non-QOS TID frames into the BE queue.  *  * This may be completely incorrect - specifically,  * some management frames may end up out of order  * compared to the QoS traffic they're controlling.  * I'll look into this later.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_getac
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|pri
init|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
name|pri
return|;
return|return
name|ATH_NONQOS_TID_AC
return|;
block|}
end_function

begin_function
name|void
name|ath_txfrag_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|frags
argument_list|,
argument|bf_list
argument_list|,
argument|next
argument_list|)
block|{
comment|/* NB: bf assumed clean */
name|TAILQ_REMOVE
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_returnbuf_head
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup xmit of a fragmented frame.  Allocate a buffer  * for each frag and bump the node reference count to  * reflect the held reference to be setup by ath_tx_start.  */
end_comment

begin_function
name|int
name|ath_txfrag_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
comment|/* XXX non-management? */
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|,
name|ATH_BUFTYPE_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* out of buffers, cleanup */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: no buffer?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|ieee80211_node_incref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|!
name|TAILQ_EMPTY
argument_list|(
name|frags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim mbuf resources.  For fragmented frames we  * need to claim each frag chained with m_nextpkt.  */
end_comment

begin_function
name|void
name|ath_freetx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_dmasetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|ATH_MAX_SCATTER
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|>
name|ATH_MAX_SCATTER
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_linear
operator|++
expr_stmt|;
name|m
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_NOWAIT
argument_list|,
name|ATH_MAX_SCATTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|ATH_MAX_SCATTER
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodata
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Chain together segments+descriptors for a frame - 11n or otherwise.  *  * For aggregates, this is called on each frame in the aggregate.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_chaindesclist
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_desc
modifier|*
name|ds0
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|is_aggr
parameter_list|,
name|int
name|is_first_subframe
parameter_list|,
name|int
name|is_last_subframe
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|char
modifier|*
name|ds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bp
decl_stmt|,
name|dsp
decl_stmt|;
name|HAL_DMA_ADDR
name|bufAddrList
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|segLenList
index|[
literal|4
index|]
decl_stmt|;
name|int
name|numTxMaps
init|=
literal|1
decl_stmt|;
name|int
name|isFirstDesc
init|=
literal|1
decl_stmt|;
comment|/* 	 * XXX There's txdma and txdma_mgmt; the descriptor 	 * sizes must match. 	 */
name|struct
name|ath_descdma
modifier|*
name|dd
init|=
operator|&
name|sc
operator|->
name|sc_txdma
decl_stmt|;
comment|/* 	 * Fillin the remainder of the descriptor info. 	 */
comment|/* 	 * We need the number of TX data pointers in each descriptor. 	 * EDMA and later chips support 4 TX buffers per descriptor; 	 * previous chips just support one. 	 */
name|numTxMaps
operator|=
name|sc
operator|->
name|sc_tx_nmaps
expr_stmt|;
comment|/* 	 * For EDMA and later chips ensure the TX map is fully populated 	 * before advancing to the next descriptor. 	 */
name|ds
operator|=
operator|(
name|char
operator|*
operator|)
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|bp
operator|=
name|dsp
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|bufAddrList
argument_list|,
sizeof|sizeof
argument_list|(
name|bufAddrList
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|segLenList
argument_list|,
sizeof|sizeof
argument_list|(
name|segLenList
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
control|)
block|{
name|bufAddrList
index|[
name|bp
index|]
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|segLenList
index|[
name|bp
index|]
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* 		 * Go to the next segment if this isn't the last segment 		 * and there's space in the current TX map. 		 */
if|if
condition|(
operator|(
name|i
operator|!=
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
operator|)
operator|&&
operator|(
name|bp
operator|<
name|numTxMaps
operator|)
condition|)
continue|continue;
comment|/* 		 * Last segment or we're out of buffer pointers. 		 */
name|bp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ath_hal_settxdesclink
argument_list|(
name|ah
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ath_hal_settxdesclink
argument_list|(
name|ah
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
operator|+
name|dd
operator|->
name|dd_descsize
operator|*
operator|(
name|dsp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * XXX This assumes that bfs_txq is the actual destination 		 * hardware queue at this point.  It may not have been 		 * assigned, it may actually be pointing to the multicast 		 * software TXQ id.  These must be fixed! 		 */
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
argument_list|,
name|bufAddrList
argument_list|,
name|segLenList
argument_list|,
name|bf
operator|->
name|bf_descid
comment|/* XXX desc id */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
argument_list|,
name|isFirstDesc
comment|/* first segment */
argument_list|,
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds0
comment|/* first descriptor */
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure the 11n aggregate fields are cleared. 		 * 		 * XXX TODO: this doesn't need to be called for 		 * aggregate frames; as it'll be called on all 		 * sub-frames.  Since the descriptors are in 		 * non-cacheable memory, this leads to some 		 * rather slow writes on MIPS/ARM platforms. 		 */
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
argument_list|)
expr_stmt|;
comment|/* 		 * If 11n is enabled, set it up as if it's an aggregate 		 * frame. 		 */
if|if
condition|(
name|is_last_subframe
condition|)
block|{
name|ath_hal_set11n_aggr_last
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_aggr
condition|)
block|{
comment|/* 			 * This clears the aggrlen field; so 			 * the caller needs to call set_aggr_first()! 			 * 			 * XXX TODO: don't call this for the first 			 * descriptor in the first frame in an 			 * aggregate! 			 */
name|ath_hal_set11n_aggr_middle
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
argument_list|)
expr_stmt|;
block|}
name|isFirstDesc
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
expr_stmt|;
comment|/* 		 * Don't forget to skip to the next descriptor. 		 */
name|ds
operator|+=
name|sc
operator|->
name|sc_tx_desclen
expr_stmt|;
name|dsp
operator|++
expr_stmt|;
comment|/* 		 * .. and don't forget to blank these out! 		 */
name|bzero
argument_list|(
name|bufAddrList
argument_list|,
sizeof|sizeof
argument_list|(
name|bufAddrList
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|segLenList
argument_list|,
sizeof|sizeof
argument_list|(
name|segLenList
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the rate control fields in the given descriptor based on  * the bf_state fields and node state.  *  * The bfs fields should already be set with the relevant rate  * control information, including whether MRR is to be enabled.  *  * Since the FreeBSD HAL currently sets up the first TX rate  * in ath_hal_setuptxdesc(), this will setup the MRR  * conditionally for the pre-11n chips, and call ath_buf_set_rate  * unconditionally for 11n chips. These require the 11n rate  * scenario to be set if MCS rates are enabled, so it's easier  * to just always call it. The caller can then only set rates 2, 3  * and 4 if multi-rate retry is needed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_set_ratectrl
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_rc_series
modifier|*
name|rc
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
decl_stmt|;
comment|/* If mrr is disabled, blank tries 1, 2, 3 */
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
condition|)
name|rc
index|[
literal|1
index|]
operator|.
name|tries
operator|=
name|rc
index|[
literal|2
index|]
operator|.
name|tries
operator|=
name|rc
index|[
literal|3
index|]
operator|.
name|tries
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * If NOACK is set, just set ntries=1. 	 */
block|else if (bf->bf_state.bfs_txflags& HAL_TXDESC_NOACK) { 		rc[1].tries = rc[2].tries = rc[3].tries = 0; 		rc[0].tries = 1; 	}
endif|#
directive|endif
comment|/* 	 * Always call - that way a retried descriptor will 	 * have the MRR fields overwritten. 	 * 	 * XXX TODO: see if this is really needed - setting up 	 * the first descriptor should set the MRR fields to 0 	 * for us anyway. 	 */
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ath_buf_set_rate
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_hal_setupxtxdesc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|rc
index|[
literal|1
index|]
operator|.
name|ratecode
argument_list|,
name|rc
index|[
literal|1
index|]
operator|.
name|tries
argument_list|,
name|rc
index|[
literal|2
index|]
operator|.
name|ratecode
argument_list|,
name|rc
index|[
literal|2
index|]
operator|.
name|tries
argument_list|,
name|rc
index|[
literal|3
index|]
operator|.
name|ratecode
argument_list|,
name|rc
index|[
literal|3
index|]
operator|.
name|tries
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup segments+descriptors for an 11n aggregate.  * bf_first is the first buffer in the aggregate.  * The descriptor list must already been linked together using  * bf->bf_next.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_setds_11n
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_prev
init|=
name|NULL
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds0
init|=
name|bf_first
operator|->
name|bf_desc
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: nframes=%d, al=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_al
argument_list|)
expr_stmt|;
name|bf
operator|=
name|bf_first
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: bf=%p, txrate0=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: bf=%p, rix0=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Setup all descriptors of all subframes - this will 	 * call ath_hal_set11naggrmiddle() on every frame. 	 */
while|while
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: bf=%p, nseg=%d, pktlen=%d, seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_nseg
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Setup the initial fields for the first descriptor - all 		 * the non-11n specific stuff. 		 */
name|ath_hal_setuptxdesc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
comment|/* packet length */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
comment|/* header length */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
comment|/* Atheros packet type */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
comment|/* txpower */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
comment|/* series 0 rate/tries */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
comment|/* key cache index */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
comment|/* antenna mode */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||
name|HAL_TXDESC_INTREQ
comment|/* flags */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
comment|/* rts/cts rate */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* 		 * First descriptor? Setup the rate control and initial 		 * aggregate header information. 		 */
if|if
condition|(
name|bf
operator|==
name|bf_first
condition|)
block|{
comment|/* 			 * setup first desc with rate and aggr info 			 */
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Setup the descriptors for a multi-descriptor frame. 		 * This is both aggregate and non-aggregate aware. 		 */
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|ds0
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|,
comment|/* is_aggr */
operator|!
operator|!
operator|(
name|bf
operator|==
name|bf_first
operator|)
argument_list|,
comment|/* is_first_subframe */
operator|!
operator|!
operator|(
name|bf
operator|->
name|bf_next
operator|==
name|NULL
operator|)
comment|/* is_last_subframe */
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|bf_first
condition|)
block|{
comment|/* 			 * Initialise the first 11n aggregate with the 			 * aggregate length and aggregate enable bits. 			 */
name|ath_hal_set11n_aggr_first
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|ds0
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_al
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Link the last descriptor of the previous frame 		 * to the beginning descriptor of this frame. 		 */
if|if
condition|(
name|bf_prev
operator|!=
name|NULL
condition|)
name|ath_hal_settxdesclink
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf_prev
operator|->
name|bf_lastds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
comment|/* Save a copy so we can link the next descriptor in */
name|bf_prev
operator|=
name|bf
expr_stmt|;
name|bf
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
block|}
comment|/* 	 * Set the first descriptor bf_lastds field to point to 	 * the last descriptor in the last subframe, that's where 	 * the status update will occur. 	 */
name|bf_first
operator|->
name|bf_lastds
operator|=
name|bf_prev
operator|->
name|bf_lastds
expr_stmt|;
comment|/* 	 * And bf_last in the first descriptor points to the end of 	 * the aggregate list. 	 */
name|bf_first
operator|->
name|bf_last
operator|=
name|bf_prev
expr_stmt|;
comment|/* 	 * For non-AR9300 NICs, which require the rate control 	 * in the final descriptor - let's set that up now. 	 * 	 * This is because the filltxdesc() HAL call doesn't 	 * populate the last segment with rate control information 	 * if firstSeg is also true.  For non-aggregate frames 	 * that is fine, as the first frame already has rate control 	 * info.  But if the last frame in an aggregate has one 	 * descriptor, both firstseg and lastseg will be true and 	 * the rate info isn't copied. 	 * 	 * This is inefficient on MIPS/ARM platforms that have 	 * non-cachable memory for TX descriptors, but we'll just 	 * make do for now. 	 * 	 * As to why the rate table is stashed in the last descriptor 	 * rather than the first descriptor?  Because proctxdesc() 	 * is called on the final descriptor in an MPDU or A-MPDU - 	 * ie, the one that gets updated by the hardware upon 	 * completion.  That way proctxdesc() doesn't need to know 	 * about the first _and_ last TX descriptor. 	 */
name|ath_hal_setuplasttxdesc
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf_prev
operator|->
name|bf_lastds
argument_list|,
name|ds0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: end\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hand-off a frame to the multicast TX queue.  *  * This is a software TXQ which will be appended to the CAB queue  * during the beacon setup code.  *  * XXX TODO: since the AR9300 EDMA TX queue support wants the QCU ID  * as part of the TX descriptor, bf_state.bfs_tx_queue must be updated  * with the actual hardware txq, or all of this will fall apart.  *  * XXX It may not be a bad idea to just stuff the QCU ID into bf_state  * and retire bfs_tx_queue; then make sure the CABQ QCU ID is populated  * correctly.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_handoff_mcast
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: busy status 0x%x"
operator|,
name|__func__
operator|,
name|bf
operator|->
name|bf_flags
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the tx queue is the cabq, so things get 	 * mapped correctly. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|!=
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: bf=%p, bfs_tx_queue=%d, axq_qnum=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ATH_TXQ_LAST
argument_list|(
name|txq
argument_list|,
name|axq_q_s
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf_last
init|=
name|ATH_TXQ_LAST
argument_list|(
name|txq
argument_list|,
name|axq_q_s
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* mark previous frame */
name|wh
operator|=
name|mtod
argument_list|(
name|bf_last
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf_last
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* link descriptor */
name|ath_hal_settxdesclink
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf_last
operator|->
name|bf_lastds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
block|}
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hand-off packet to a hardware queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_handoff_hw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf_first
decl_stmt|;
comment|/* 	 * Insert the frame on the outbound list and pass it on 	 * to the hardware.  Multicast frames buffered for power 	 * save stations and transmit from the CAB queue are stored 	 * on a s/w only queue and loaded on to the CAB queue in 	 * the SWBA handler since frames only go out on DTIM and 	 * to avoid possible races. 	 */
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: busy status 0x%x"
operator|,
name|__func__
operator|,
name|bf
operator|->
name|bf_flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txq
operator|->
name|axq_qnum
operator|!=
name|ATH_TXQ_SWQ
argument_list|,
operator|(
literal|"ath_tx_handoff_hw called for mcast queue"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX racy, should hold the PCU lock when checking this, 	 * and also should ensure that the TX counter is>0! 	 */
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|sc_inreset_cnt
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: TX during reset?\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * This causes a LOR. Find out where the PCU lock is being 	 * held whilst the TXQ lock is grabbed - that shouldn't 	 * be occuring. 	 */
block|ATH_PCU_LOCK(sc); 	if (sc->sc_inreset_cnt) { 		ATH_PCU_UNLOCK(sc); 		DPRINTF(sc, ATH_DEBUG_RESET, 		    "%s: called with sc_in_reset != 0\n", 		    __func__); 		DPRINTF(sc, ATH_DEBUG_XMIT, 		    "%s: queued: TXDP[%u] = %p (%p) depth %d\n", 		    __func__, txq->axq_qnum, 		    (caddr_t)bf->bf_daddr, bf->bf_desc, 		    txq->axq_depth);
comment|/* XXX axq_link needs to be set and updated! */
block|ATH_TXQ_INSERT_TAIL(txq, bf, bf_list); 		if (bf->bf_state.bfs_aggr) 			txq->axq_aggr_depth++; 		return; 		} 	ATH_PCU_UNLOCK(sc);
endif|#
directive|endif
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: if there's a holdingbf, then 	 * ATH_TXQ_PUTRUNNING should be clear. 	 * 	 * If there is a holdingbf and the list is empty, 	 * then axq_link should be pointing to the holdingbf. 	 * 	 * Otherwise it should point to the last descriptor 	 * in the last ath_buf. 	 * 	 * In any case, we should really ensure that we 	 * update the previous descriptor link pointer to 	 * this descriptor, regardless of all of the above state. 	 * 	 * For now this is captured by having axq_link point 	 * to either the holdingbf (if the TXQ list is empty) 	 * or the end of the list (if the TXQ list isn't empty.) 	 * I'd rather just kill axq_link here and do it as above. 	 */
comment|/* 	 * Append the frame to the TX queue. 	 */
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|3
argument_list|,
literal|"ath_tx_handoff: non-tdma: txq=%u, add bf=%p "
literal|"depth=%d"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a link pointer, update it. 	 * 	 * XXX we should replace this with the above logic, just 	 * to kill axq_link with fire. 	 */
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|5
argument_list|,
literal|"ath_tx_handoff: non-tdma: link[%u](%p)=%p (%p) "
literal|"lastds=%d"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we've not pushed anything into the hardware yet, 	 * push the head of the queue into the TxDP. 	 * 	 * Once we've started DMA, there's no guarantee that 	 * updating the TxDP with a new value will actually work. 	 * So we just don't do that - if we hit the end of the list, 	 * we keep that buffer around (the "holding buffer") and 	 * re-start DMA by updating the link pointer of _that_ 	 * descriptor and then restart DMA. 	 */
if|if
condition|(
operator|!
operator|(
name|txq
operator|->
name|axq_flags
operator|&
name|ATH_TXQ_PUTRUNNING
operator|)
condition|)
block|{
name|bf_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTRUNNING
expr_stmt|;
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf_first
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf_first
operator|->
name|bf_daddr
argument_list|,
name|bf_first
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|5
argument_list|,
literal|"ath_tx_handoff: TXDP[%u] = %p (%p) "
literal|"lastds=%p depth %d"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf_first
operator|->
name|bf_daddr
argument_list|,
name|bf_first
operator|->
name|bf_desc
argument_list|,
name|bf_first
operator|->
name|bf_lastds
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ensure that the bf TXQ matches this TXQ, so later 	 * checking and holding buffer manipulation is sane. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|!=
name|txq
operator|->
name|axq_qnum
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: bf=%p, bfs_tx_queue=%d, axq_qnum=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Track aggregate queue depth. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|txq
operator|->
name|axq_aggr_depth
operator|++
expr_stmt|;
comment|/* 	 * Update the link pointer. 	 */
name|ath_hal_gettxdesclinkptr
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_lastds
argument_list|,
operator|&
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
comment|/* 	 * Start DMA. 	 * 	 * If we wrote a TxDP above, DMA will start from here. 	 * 	 * If DMA is running, it'll do nothing. 	 * 	 * If the DMA engine hit the end of the QCU list (ie LINK=NULL, 	 * or VEOL) then it stops at the last transmitted write. 	 * We then append a new frame by updating the link pointer 	 * in that descriptor and then kick TxE here; it will re-read 	 * that last descriptor and find the new descriptor to transmit. 	 * 	 * This is why we keep the holding descriptor around. 	 */
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|1
argument_list|,
literal|"ath_tx_handoff: txq=%u, txstart"
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart TX DMA for the given TXQ.  *  * This must be called whether the queue is empty or not.  */
end_comment

begin_function
specifier|static
name|void
name|ath_legacy_tx_dma_restart
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_last
decl_stmt|;
name|ATH_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* XXX make this ATH_TXQ_FIRST */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
expr_stmt|;
name|bf_last
operator|=
name|ATH_TXQ_LAST
argument_list|(
name|txq
argument_list|,
name|axq_q_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: Q%d: bf=%p, bf_last=%p, daddr=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
argument_list|,
name|bf_last
argument_list|,
operator|(
name|uint32_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RESET
condition|)
name|ath_tx_dump
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This is called from a restart, so DMA is known to be 	 * completely stopped. 	 */
name|KASSERT
argument_list|(
operator|(
operator|!
operator|(
name|txq
operator|->
name|axq_flags
operator|&
name|ATH_TXQ_PUTRUNNING
operator|)
operator|)
argument_list|,
operator|(
literal|"%s: Q%d: called with PUTRUNNING=1\n"
operator|,
name|__func__
operator|,
name|txq
operator|->
name|axq_qnum
operator|)
argument_list|)
expr_stmt|;
name|ath_hal_puttxbuf
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTRUNNING
expr_stmt|;
name|ath_hal_gettxdesclinkptr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf_last
operator|->
name|bf_lastds
argument_list|,
operator|&
name|txq
operator|->
name|axq_link
argument_list|)
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hand off a packet to the hardware (or mcast queue.)  *  * The relevant hardware txq should be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_legacy_xmit_handoff
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_TXDESC
argument_list|)
condition|)
name|ath_tx_alq_post
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|txq
operator|->
name|axq_qnum
operator|==
name|ATH_TXQ_SWQ
condition|)
name|ath_tx_handoff_mcast
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
else|else
name|ath_tx_handoff_hw
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_tag_crypto
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|iswep
parameter_list|,
name|int
name|isfrag
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|,
name|int
modifier|*
name|pktlen
parameter_list|,
name|int
modifier|*
name|keyix
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: hdrlen=%d, pktlen=%d, isfrag=%d, iswep=%d, m0=%p\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|hdrlen
argument_list|,
operator|*
name|pktlen
argument_list|,
name|isfrag
argument_list|,
name|iswep
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Adjust the packet + header lengths for the crypto 		 * additions and calculate the h/w key index.  When 		 * a s/w mic is done the frame will have had any mic 		 * added to it prior to entry so m0->m_pkthdr.len will 		 * account for it. Otherwise we need to add it to the 		 * packet length. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
operator|(
operator|*
name|hdrlen
operator|)
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
operator|(
operator|*
name|pktlen
operator|)
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
comment|/* NB: frags always have any TKIP MIC done in s/w */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|isfrag
condition|)
operator|(
operator|*
name|pktlen
operator|)
operator|+=
name|cip
operator|->
name|ic_miclen
expr_stmt|;
operator|(
operator|*
name|keyix
operator|)
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
operator|==
operator|&
name|ieee80211_cipher_none
condition|)
block|{
comment|/* 		 * Use station key cache slot, if assigned. 		 */
operator|(
operator|*
name|keyix
operator|)
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|keyix
operator|)
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
operator|(
operator|*
name|keyix
operator|)
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|keyix
operator|)
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate whether interoperability protection is required for  * this frame.  *  * This requires the rate control information be filled in,  * as the protection requirement depends upon the current  * operating mode / PHY.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_calc_protection
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint8_t
name|rix
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|int
name|shortPreamble
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|flags
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
expr_stmt|;
name|rix
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
expr_stmt|;
name|shortPreamble
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * If 802.11g protection is enabled, determine whether 	 * to use RTS/CTS or just CTS.  Note that this is only 	 * done for OFDM unicast frames. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doprot
operator|=
literal|1
expr_stmt|;
comment|/* XXX fragments must use CCK rates w/ protection */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
block|}
comment|/* 		 * For frags it would be desirable to use the 		 * highest CCK rate for RTS/CTS.  But stations 		 * farther away may detect it at a lower CCK rate 		 * so use the configured protection rate instead 		 * (for now). 		 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_protect
operator|++
expr_stmt|;
block|}
comment|/* 	 * If 11n protection is enabled and it's a HT frame, 	 * enable RTS. 	 * 	 * XXX ic_htprotmode or ic_curhtprotmode? 	 * XXX should it_htprotmode only matter if ic_curhtprotmode  	 * XXX indicates it's not a HT pure environment? 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htprotmode
operator|==
name|IEEE80211_PROT_RTSCTS
operator|)
operator|&&
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_htprotect
operator|++
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the frame duration given the currently selected rate.  *  * This also updates the frame duration value, so it will require  * a DMA flush.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_calc_duration
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint8_t
name|rix
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|int
name|shortPreamble
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|int
name|isfrag
init|=
name|bf
operator|->
name|bf_m
operator|->
name|m_flags
operator|&
name|M_FRAG
decl_stmt|;
name|flags
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
expr_stmt|;
name|rix
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
expr_stmt|;
name|shortPreamble
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate duration.  This logically belongs in the 802.11 	 * layer but it lacks sufficient information to calculate it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
name|u_int16_t
name|dur
decl_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
else|else
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_FRAG
condition|)
block|{
name|dur
operator|+=
name|dur
expr_stmt|;
comment|/* additional SIFS+ACK */
comment|/* 			 * Include the size of next fragment so NAV is 			 * updated properly.  The last fragment uses only 			 * the ACK duration 			 * 			 * XXX TODO: ensure that the rate lookup for each 			 * fragment is the same as the rate used by the 			 * first fragment! 			 */
name|dur
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|bf
operator|->
name|bf_nextfraglen
argument_list|,
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isfrag
condition|)
block|{
comment|/* 			 * Force hardware to use computed duration for next 			 * fragment by disabling multi-rate retry which updates 			 * duration based on the multi-rate duration table. 			 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX update bfs_rc[0].try? */
block|}
comment|/* Update the duration field itself */
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ath_tx_get_rtscts_rate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|cix
parameter_list|,
name|int
name|shortPreamble
parameter_list|)
block|{
name|uint8_t
name|ctsrate
decl_stmt|;
comment|/* 	 * CTS transmit rate is derived from the transmit rate 	 * by looking in the h/w rate table.  We must also factor 	 * in whether or not a short preamble is to be used. 	 */
comment|/* NB: cix is set above where RTS/CTS is enabled */
name|KASSERT
argument_list|(
name|cix
operator|!=
literal|0xff
argument_list|,
operator|(
literal|"cix not setup"
operator|)
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* XXX this should only matter for legacy rates */
if|if
condition|(
name|shortPreamble
condition|)
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
return|return
operator|(
name|ctsrate
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the RTS/CTS duration for legacy frames.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_calc_ctsduration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|rix
parameter_list|,
name|int
name|cix
parameter_list|,
name|int
name|shortPreamble
parameter_list|,
name|int
name|pktlen
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ctsduration
init|=
literal|0
decl_stmt|;
comment|/* This mustn't be called for HT modes */
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: HT rate where it shouldn't be (0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Compute the transmit duration based on the frame 	 * size and the size of an ACK frame.  We call into the 	 * HAL to do the computation since it depends on the 	 * characteristics of the actual PHY being used. 	 * 	 * NB: CTS is assumed the same size as an ACK so we can 	 *     use the precalculated ACK durations. 	 */
if|if
condition|(
name|shortPreamble
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
return|return
operator|(
name|ctsduration
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the given ath_buf with updated rts/cts setup and duration  * values.  *  * To support rate lookups for each software retry, the rts/cts rate  * and cts duration must be re-calculated.  *  * This function assumes the RTS/CTS flags have been set as needed;  * mrr has been disabled; and the rate control lookup has been done.  *  * XXX TODO: MRR need only be disabled for the pre-11n NICs.  * XXX The 11n NICs support per-rate RTS/CTS configuration.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_set_rtscts
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|uint16_t
name|ctsduration
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ctsrate
init|=
literal|0
decl_stmt|;
name|uint8_t
name|rix
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
decl_stmt|;
name|uint8_t
name|cix
init|=
literal|0
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
comment|/* 	 * No RTS/CTS enabled? Don't bother. 	 */
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX is this really needed? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * If protection is enabled, use the protection rix control 	 * rate. Otherwise use the rate0 control rate. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doprot
condition|)
name|rix
operator|=
name|sc
operator|->
name|sc_protrix
expr_stmt|;
else|else
name|rix
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
expr_stmt|;
comment|/* 	 * If the raw path has hard-coded ctsrate0 to something, 	 * use it. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
operator|!=
literal|0
condition|)
name|cix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
argument_list|)
expr_stmt|;
else|else
comment|/* Control rate from above */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|controlRate
expr_stmt|;
comment|/* Calculate the rtscts rate for the given cix */
name|ctsrate
operator|=
name|ath_tx_get_rtscts_rate
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rt
argument_list|,
name|cix
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
argument_list|)
expr_stmt|;
comment|/* The 11n chipsets do ctsduration calculations for you */
if|if
condition|(
operator|!
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
name|ctsduration
operator|=
name|ath_tx_calc_ctsduration
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|rix
argument_list|,
name|cix
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|rt
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
argument_list|)
expr_stmt|;
comment|/* Squirrel away in ath_buf */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
name|ctsrate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
name|ctsduration
expr_stmt|;
comment|/* 	 * Must disable multi-rate retry when using RTS/CTS. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_mrrprot
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX ew */
block|}
block|}
end_function

begin_comment
comment|/*  * Setup the descriptor chain for a normal or fast-frame  * frame.  *  * XXX TODO: extend to include the destination hardware QCU ID.  * Make sure that is correct.  Make sure that when being added  * to the mcastq, the CABQ QCUID is set or things will get a bit  * odd.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_setds
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: bf=%p, txrate0=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
comment|/* packet length */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
comment|/* header length */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
comment|/* Atheros packet type */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
comment|/* txpower */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
comment|/* series 0 rate/tries */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
comment|/* key cache index */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
comment|/* antenna mode */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
comment|/* flags */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
comment|/* rts/cts rate */
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
comment|/* 	 * This will be overriden when the descriptor chain is written. 	 */
name|bf
operator|->
name|bf_lastds
operator|=
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_last
operator|=
name|bf
expr_stmt|;
comment|/* Set rate control and descriptor chain for this frame */
name|ath_tx_set_ratectrl
argument_list|(
name|sc
argument_list|,
name|bf
operator|->
name|bf_node
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|ds
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do a rate lookup.  *  * This performs a rate lookup for the given ath_buf only if it's required.  * Non-data frames and raw frames don't require it.  *  * This populates the primary and MRR entries; MRR values are  * then disabled later on if something requires it (eg RTS/CTS on  * pre-11n chipsets.  *  * This needs to be done before the RTS/CTS fields are calculated  * as they may depend upon the rate chosen.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_do_ratelookup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|uint8_t
name|rate
decl_stmt|,
name|rix
decl_stmt|;
name|int
name|try0
decl_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doratelookup
condition|)
return|return;
comment|/* Get rid of any previous state */
name|bzero
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
argument_list|)
expr_stmt|;
name|ATH_NODE_LOCK
argument_list|(
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|)
expr_stmt|;
name|ath_rate_findrate
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
operator|&
name|rix
argument_list|,
operator|&
name|try0
argument_list|,
operator|&
name|rate
argument_list|)
expr_stmt|;
comment|/* In case MRR is disabled, make sure rc[0] is setup correctly */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|=
name|rate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|try0
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|&&
name|try0
operator|!=
name|ATH_TXMAXTRY
condition|)
name|ath_rate_getxtxrates
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|,
name|rix
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
expr_stmt|;
name|ATH_NODE_UNLOCK
argument_list|(
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
comment|/* for LED blinking */
name|sc
operator|->
name|sc_lastdatarix
operator|=
name|rix
expr_stmt|;
comment|/* for fast frames */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|=
name|rate
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the CLRDMASK bit in the ath_buf if it needs to be set.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_update_clrdmask
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|an
operator|->
name|clrdmask
operator|==
literal|1
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
name|an
operator|->
name|clrdmask
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return whether this frame should be software queued or  * direct dispatched.  *  * When doing powersave, BAR frames should be queued but other management  * frames should be directly sent.  *  * When not doing powersave, stick BAR frames into the hardware queue  * so it goes out even though the queue is paused.  *  * For now, management frames are also software queued by default.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_should_swq_frame
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
modifier|*
name|queue_to_head
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|subtype
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
operator|(
operator|*
name|queue_to_head
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* If it's not in powersave - direct-dispatch BAR */
if|if
condition|(
operator|(
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_is_powersave
operator|==
literal|0
operator|)
operator|&&
name|type
operator|==
name|IEEE80211_FC0_TYPE_CTL
operator|&&
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BAR
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: BAR: TX'ing direct\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_is_powersave
operator|==
literal|1
operator|)
operator|&&
name|type
operator|==
name|IEEE80211_FC0_TYPE_CTL
operator|&&
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BAR
condition|)
block|{
comment|/* BAR TX whilst asleep; queue */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: swq: TX'ing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|(
operator|*
name|queue_to_head
operator|)
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_is_powersave
operator|==
literal|1
operator|)
operator|&&
operator|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_MGT
operator|||
name|type
operator|==
name|IEEE80211_FC0_TYPE_CTL
operator|)
condition|)
block|{
comment|/* 		 * Other control/mgmt frame; bypass software queuing 		 * for now! 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %6D: Node is asleep; sending mgmt "
literal|"(type=%d, subtype=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|type
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit the given frame to the hardware.  *  * The frame must already be setup; rate control must already have  * been done.  *  * XXX since the TXQ lock is being held here (and I dislike holding  * it for this long when not doing software aggregation), later on  * break this function into "setup_normal" and "xmit_normal". The  * lock only needs to be held for the ath_tx_handoff call.  *  * XXX we don't update the leak count here - if we're doing  * direct frame dispatch, we need to be able to do it without  * decrementing the leak count (eg multicast queue frames.)  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_xmit_normal
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|bf
operator|->
name|bf_node
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|tid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
index|]
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * For now, just enable CLRDMASK. ath_tx_xmit_normal() does 	 * set a completion handler however it doesn't (yet) properly 	 * handle the strict ordering requirements needed for normal, 	 * non-aggregate session frames. 	 * 	 * Once this is implemented, only set CLRDMASK like this for 	 * frames that must go out - eg management/raw frames. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* Setup the descriptor before handoff */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_duration
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_protection
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Track per-TID hardware queue depth correctly */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* Assign the completion handler */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_normal_comp
expr_stmt|;
comment|/* Hand off to hardware */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the basic frame setup stuff that's required before the frame  * is added to a software queue.  *  * All frames get mostly the same treatment and it's done once.  * Retransmits fiddle with things like the rate control setup,  * setting the retransmit bit in the packet; doing relevant DMA/bus  * syncing and relinking it (back) into the hardware TX queue.  *  * Note that this may cause the mbuf to be reallocated, so  * m0 may not be valid.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_normal_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|chanAccParams
modifier|*
name|cap
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
decl_stmt|;
name|int
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|ismcast
decl_stmt|,
name|isfrag
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|rix
init|=
literal|0
decl_stmt|,
name|txrate
init|=
literal|0
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|subtype
decl_stmt|,
name|flags
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
comment|/* 	 * To ensure that both sequence numbers and the CCMP PN handling 	 * is "correct", make sure that the relevant TID queue is locked. 	 * Otherwise the CCMP PN and seqno may appear out of order, causing 	 * re-ordered frames to have out of order CCMP PN's, resulting 	 * in many, many frame drops. 	 */
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|isfrag
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* Handle encryption twiddling if needed */
if|if
condition|(
operator|!
name|ath_tx_tag_crypto
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|iswep
argument_list|,
name|isfrag
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|&
name|keyix
argument_list|)
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the 802.11 layer marks whether or not we should 	 * use short preamble based on the current mode and 	 * negotiated parameters. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
block|{
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortpre
operator|++
expr_stmt|;
block|}
else|else
block|{
name|shortPreamble
operator|=
name|AH_FALSE
expr_stmt|;
block|}
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|//flags = HAL_TXDESC_CLRDMASK;		/* XXX needed for crypto errs */
name|flags
operator|=
literal|0
expr_stmt|;
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* default no multi-rate retry*/
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* honor classification */
comment|/* XXX use txparams instead of fixed values */
comment|/* 	 * Calculate Atheros packet type from IEEE80211 packet header, 	 * setup for rate calculations, and select h/w transmit queue. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_BEACON
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PROBE_RESP
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ATIM
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_ATIM
expr_stmt|;
else|else
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* XXX */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
comment|/* stop setting of duration */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* default */
comment|/* 		 * Data frames: multicast frames go out at a fixed rate, 		 * EAPOL frames use the mgmt frame rate; otherwise consult 		 * the rate control module for the rate to use. 		 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|rix
operator|=
name|an
operator|->
name|an_mcastrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
block|{
comment|/* XXX? maybe always use long preamble? */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMAXTRY
expr_stmt|;
comment|/* XXX?too many? */
block|}
else|else
block|{
comment|/* 			 * Do rate lookup on each TX, rather than using 			 * the hard-coded TX information decided here. 			 */
name|ismrr
operator|=
literal|1
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doratelookup
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cap
operator|->
name|cap_wmeParams
index|[
name|pri
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX statistic */
comment|/* XXX free tx dmamap */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 	 * There are two known scenarios where the frame AC doesn't match 	 * what the destination TXQ is. 	 * 	 * + non-QoS frames (eg management?) that the net80211 stack has 	 *   assigned a higher AC to, but since it's a non-QoS TID, it's 	 *   being thrown into TID 16.  TID 16 gets the AC_BE queue. 	 *   It's quite possible that management frames should just be 	 *   direct dispatched to hardware rather than go via the software 	 *   queue; that should be investigated in the future.  There are 	 *   some specific scenarios where this doesn't make sense, mostly 	 *   surrounding ADDBA request/response - hence why that is special 	 *   cased. 	 * 	 * + Multicast frames going into the VAP mcast queue.  That shows up 	 *   as "TXQ 11". 	 * 	 * This driver should eventually support separate TID and TXQ locking, 	 * allowing for arbitrary AC frames to appear on arbitrary software 	 * queues, being queued to the "correct" hardware queue when needed. 	 */
if|#
directive|if
literal|0
block|if (txq != sc->sc_ac2q[pri]) { 		DPRINTF(sc, ATH_DEBUG_XMIT,  		    "%s: txq=%p (%d), pri=%d, pri txq=%p (%d)\n", 		    __func__, 		    txq, 		    txq->axq_qnum, 		    pri, 		    sc->sc_ac2q[pri], 		    sc->sc_ac2q[pri]->axq_qnum); 	}
endif|#
directive|endif
comment|/* 	 * Calculate miscellaneous flags. 	 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
comment|/* no ack on broad/multicast */
block|}
elseif|else
if|if
condition|(
name|pktlen
operator|>
name|vap
operator|->
name|iv_rtsthreshold
operator|&&
operator|(
name|ni
operator|->
name|ni_ath_flags
operator|&
name|IEEE80211_NODE_FF
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
comment|/* RTS based on frame length */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
condition|)
comment|/* NB: avoid double counting */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_noack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: discard frame, ACK required w/ TDMA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_ack
operator|++
expr_stmt|;
comment|/* XXX free tx dmamap */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Determine if a tx interrupt should be generated for 	 * this descriptor.  We take a tx interrupt to reap 	 * descriptors when the h/w hits an EOL condition or 	 * when the descriptor is specifically marked to generate 	 * an interrupt.  We periodically mark descriptors in this 	 * way to insure timely replenishing of the supply needed 	 * for sending frames.  Defering interrupts reduces system 	 * load and potentially allows more concurrent work to be 	 * done but if done to aggressively can cause senders to 	 * backup. 	 * 	 * NB: use>= to deal with sc_txintrperiod changing 	 *     dynamically through sysctl. 	 */
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_INTREQ
condition|)
block|{
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|txq
operator|->
name|axq_intrcnt
operator|>=
name|sc
operator|->
name|sc_txintrperiod
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* This point forward is actual TX bits */
comment|/* 	 * At this point we are committed to sending the frame 	 * and we don't need to look at m_nextpkt; clear it in 	 * case this frame is part of frag chain. 	 */
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|isfrag
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ieee80211_get_node_txpower
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* Blank the legacy rate array */
name|bzero
argument_list|(
operator|&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * ath_buf_set_rate needs at least one rate/try to setup 	 * the rate scenario. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|=
name|txrate
expr_stmt|;
comment|/* Store the decided rate index values away */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
operator|=
name|pktlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
operator|=
name|atype
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
operator|=
name|ieee80211_get_node_txpower
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|=
name|txrate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
operator|=
name|keyix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|=
name|flags
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
operator|=
name|shortPreamble
expr_stmt|;
comment|/* XXX this should be done in ath_tx_setrate() */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
operator|=
literal|0
expr_stmt|;
comment|/* ie, no hard-coded ctsrate */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
literal|0
expr_stmt|;
comment|/* calculated later */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
name|ismrr
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a frame to the hardware or software queue.  *  * This can be called by the net80211 code.  *  * XXX what about locking? Or, push the seqno assign into the  * XXX aggregate scheduler so its serialised?  *  * XXX When sending management frames via ath_raw_xmit(),  *     should CLRDMASK be set unconditionally?  */
end_comment

begin_function
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|ismcast
decl_stmt|;
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|is_ampdu
decl_stmt|,
name|is_ampdu_tx
decl_stmt|,
name|is_ampdu_pending
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|subtype
decl_stmt|;
name|int
name|queue_to_head
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the target hardware queue. 	 * 	 * For multicast frames, the txq gets overridden appropriately 	 * depending upon the state of PS. 	 * 	 * For any other frame, we do a TID/QoS lookup inside the frame 	 * to see what the TID should be. If it's a non-QoS frame, the 	 * AC and TID are overridden. The TID/TXQ code assumes the 	 * TID is on a predictable hardware TXQ, so we don't support 	 * having a node TID queued to multiple hardware TXQs. 	 * This may change in the future but would require some locking 	 * fudgery. 	 */
name|pri
operator|=
name|ath_tx_getac
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|tid
operator|=
name|ath_tx_gettid
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
comment|/* 	 * Enforce how deep the multicast queue can grow. 	 * 	 * XXX duplicated in ath_raw_xmit(). 	 */
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_depth
operator|+
name|sc
operator|->
name|sc_cabq
operator|->
name|fifo
operator|.
name|axq_depth
operator|>
name|sc
operator|->
name|sc_txq_mcastq_maxdepth
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_mcastq_overflow
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* 	 * Enforce how deep the unicast queue can grow. 	 * 	 * If the node is in power save then we don't want 	 * the software queue to grow too deep, or a node may 	 * end up consuming all of the ath_buf entries. 	 * 	 * For now, only do this for DATA frames. 	 * 	 * We will want to cap how many management/control 	 * frames get punted to the software queue so it doesn't 	 * fill up.  But the correct solution isn't yet obvious. 	 * In any case, this check should at least let frames pass 	 * that we are direct-dispatching. 	 * 	 * XXX TODO: duplicate this to the raw xmit path! 	 */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
operator|&&
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_is_powersave
operator|&&
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
operator|->
name|an_swq_depth
operator|>
name|sc
operator|->
name|sc_txq_node_psq_maxdepth
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_node_psq_overflow
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* A-MPDU TX */
name|is_ampdu_tx
operator|=
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|is_ampdu_pending
operator|=
name|ath_tx_ampdu_pending
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|is_ampdu
operator|=
name|is_ampdu_tx
operator||
name|is_ampdu_pending
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d, ac=%d, is_ampdu=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|pri
argument_list|,
name|is_ampdu
argument_list|)
expr_stmt|;
comment|/* Set local packet state, used to queue packets to hardware */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
operator|=
name|tid
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|=
name|txq
operator|->
name|axq_qnum
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pri
operator|=
name|pri
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * When servicing one or more stations in power-save mode 	 * (or) if there is some mcast data waiting on the mcast 	 * queue (to prevent out of order delivery) multicast frames 	 * must be bufferd until after the beacon. 	 * 	 * TODO: we should lock the mcastq before we check the length. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_cabq_enable
operator|&&
name|ismcast
operator|&&
operator|(
name|vap
operator|->
name|iv_ps_sta
operator|||
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
operator|)
condition|)
block|{
name|txq
operator|=
operator|&
name|avp
operator|->
name|av_mcastq
expr_stmt|;
comment|/* 		 * Mark the frame as eventually belonging on the CAB 		 * queue, so the descriptor setup functions will 		 * correctly initialise the descriptor 'qcuId' field. 		 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|=
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_qnum
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do the generic frame setup */
comment|/* XXX should just bzero the bf_state? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
comment|/* A-MPDU TX? Manually set sequence number */
comment|/* 	 * Don't do it whilst pending; the net80211 layer still 	 * assigns them. 	 */
if|if
condition|(
name|is_ampdu_tx
condition|)
block|{
comment|/* 		 * Always call; this function will 		 * handle making sure that null data frames 		 * don't get a sequence number from the current 		 * TID and thus mess with the BAW. 		 */
name|seqno
operator|=
name|ath_tx_tid_seqno_assign
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* 		 * Don't add QoS NULL frames to the BAW. 		 */
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
operator|&&
name|subtype
operator|!=
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If needed, the sequence number has been assigned. 	 * Squirrel it away somewhere easy to get to. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
operator|=
name|M_SEQNO_GET
argument_list|(
name|m0
argument_list|)
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
comment|/* Is ampdu pending? fetch the seqno and print it out */
if|if
condition|(
name|is_ampdu_pending
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid %d: ampdu pending, seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|M_SEQNO_GET
argument_list|(
name|m0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This also sets up the DMA map */
name|r
operator|=
name|ath_tx_normal_setup
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|,
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* At this point m0 could have changed! */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * If it's a multicast frame, do a direct-dispatch to the 	 * destination hardware queue. Don't bother software 	 * queuing it. 	 */
comment|/* 	 * If it's a BAR frame, do a direct dispatch to the 	 * destination hardware queue. Don't bother software 	 * queuing it, as the TID will now be paused. 	 * Sending a BAR frame can occur from the net80211 txa timer 	 * (ie, retries) or from the ath txtask (completion call.) 	 * It queues directly to hardware because the TID is paused 	 * at this point (and won't be unpaused until the BAR has 	 * either been TXed successfully or max retries has been 	 * reached.) 	 */
comment|/* 	 * Until things are better debugged - if this node is asleep 	 * and we're sending it a non-BAR frame, direct dispatch it. 	 * Why? Because we need to figure out what's actually being 	 * sent - eg, during reassociation/reauthentication after 	 * the node (last) disappeared whilst asleep, the driver should 	 * have unpaused/unsleep'ed the node.  So until that is 	 * sorted out, use this workaround. 	 */
if|if
condition|(
name|txq
operator|==
operator|&
name|avp
operator|->
name|av_mcastq
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p: mcastq: TX'ing\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ath_tx_should_swq_frame
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|m0
argument_list|,
operator|&
name|queue_to_head
argument_list|)
condition|)
block|{
name|ath_tx_swq
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|txq
argument_list|,
name|queue_to_head
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * For now, since there's no software queue, 	 * direct-dispatch to the hardware. 	 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* 	 * Update the current leak count if 	 * we're leaking frames; and set the 	 * MORE flag as appropriate. 	 */
name|ath_tx_leak_count_update
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|done
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_raw_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ismcast
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|,
name|txantenna
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|txrate
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|int
name|o_tid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|do_override
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|subtype
decl_stmt|;
name|int
name|queue_to_head
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
comment|/* XXX honor IEEE80211_BPF_DATAPAD */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|2
argument_list|,
literal|"ath_tx_raw_start: ni=%p, bf=%p, raw"
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: ismcast=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ismcast
argument_list|)
expr_stmt|;
name|pri
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
comment|/* Override pri if the frame isn't a QoS one */
if|if
condition|(
operator|!
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
name|pri
operator|=
name|ath_tx_getac
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX If it's an ADDBA, override the correct queue */
name|do_override
operator|=
name|ath_tx_action_frame_override_queue
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
operator|&
name|o_tid
argument_list|)
expr_stmt|;
comment|/* Map ADDBA to the correct priority */
if|if
condition|(
name|do_override
condition|)
block|{
if|#
directive|if
literal|0
block|DPRINTF(sc, ATH_DEBUG_XMIT,  		    "%s: overriding tid %d pri %d -> %d\n", 		    __func__, o_tid, pri, TID_TO_WME_AC(o_tid));
endif|#
directive|endif
name|pri
operator|=
name|TID_TO_WME_AC
argument_list|(
name|o_tid
argument_list|)
expr_stmt|;
block|}
comment|/* Handle encryption twiddling if needed */
if|if
condition|(
operator|!
name|ath_tx_tag_crypto
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CRYPTO
argument_list|,
literal|0
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|&
name|keyix
argument_list|)
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* Do the generic frame setup */
comment|/* XXX should just bzero the bf_state? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
comment|/* Always enable CLRDMASK for raw frames for now.. */
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
block|{
comment|/* XXX assume 11g/11n protection? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_doprot
operator|=
literal|1
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
block|}
comment|/* XXX leave ismcast to injector? */
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|||
name|ismcast
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
name|try0
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|ismrr
operator|=
operator|(
name|params
operator|->
name|ibp_try1
operator|!=
literal|0
operator|)
expr_stmt|;
name|txantenna
operator|=
name|params
operator|->
name|ibp_pri
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|txantenna
operator|==
literal|0
condition|)
comment|/* XXX? */
name|txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
comment|/* 	 * Since ctsrate is fixed, store it away for later 	 * use when the descriptor fields are being set. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate0
operator|=
name|params
operator|->
name|ibp_ctsrate
expr_stmt|;
comment|/* 	 * NB: we mark all packets as type PSPOLL so the h/w won't 	 * set the sequence number, duration, etc. 	 */
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|MIN
argument_list|(
name|params
operator|->
name|ibp_power
argument_list|,
name|ieee80211_get_node_txpower
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* XXX check return value? */
comment|/* Store the decided rate index values away */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
operator|=
name|pktlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_atype
operator|=
name|atype
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txpower
operator|=
name|MIN
argument_list|(
name|params
operator|->
name|ibp_power
argument_list|,
name|ieee80211_get_node_txpower
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txrate0
operator|=
name|txrate
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_try0
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_keyix
operator|=
name|keyix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txantenna
operator|=
name|txantenna
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|=
name|flags
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_shpream
operator|=
operator|!
operator|!
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
operator|)
expr_stmt|;
comment|/* Set local packet state, used to queue packets to hardware */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|pri
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
operator|->
name|axq_qnum
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pri
operator|=
name|pri
expr_stmt|;
comment|/* XXX this should be done in ath_tx_setrate() */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsrate
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ctsduration
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ismrr
operator|=
name|ismrr
expr_stmt|;
comment|/* Blank the legacy rate array */
name|bzero
argument_list|(
operator|&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|tries
operator|=
name|try0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|0
index|]
operator|.
name|ratecode
operator|=
name|txrate
expr_stmt|;
if|if
condition|(
name|ismrr
condition|)
block|{
name|int
name|rix
decl_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate1
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|1
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|1
index|]
operator|.
name|tries
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate2
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|2
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|2
index|]
operator|.
name|tries
operator|=
name|params
operator|->
name|ibp_try2
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate3
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|rix
operator|=
name|rix
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|tries
operator|=
name|params
operator|->
name|ibp_try3
expr_stmt|;
block|}
comment|/* 	 * All the required rate control decisions have been made; 	 * fill in the rc flags. 	 */
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* NB: no buffered multicast in power save support */
comment|/* 	 * If we're overiding the ADDBA destination, dump directly 	 * into the hardware queue, right after any pending 	 * frames to that node are. 	 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: dooverride=%d\n"
argument_list|,
name|__func__
argument_list|,
name|do_override
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * Put addba frames in the right place in the right TID/HWQ. 	 */
if|if
condition|(
name|do_override
condition|)
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* 		 * XXX if it's addba frames, should we be leaking 		 * them out via the frame leak method? 		 * XXX for now let's not risk it; but we may wish 		 * to investigate this later. 		 */
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ath_tx_should_swq_frame
argument_list|(
name|sc
argument_list|,
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|m0
argument_list|,
operator|&
name|queue_to_head
argument_list|)
condition|)
block|{
comment|/* Queue to software queue */
name|ath_tx_swq
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|queue_to_head
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Direct-dispatch to the hardware */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* 	 * Update the current leak count if 	 * we're leaking frames; and set the 	 * MORE flag as appropriate. 	 */
name|ath_tx_leak_count_update
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a raw frame.  *  * This can be called by net80211.  */
end_comment

begin_function
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: sc_inreset_cnt> 0; bailing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|bad0
goto|;
block|}
name|sc
operator|->
name|sc_txstart_cnt
operator|++
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: discard frame, %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|?
literal|"!running"
else|:
literal|"invalid"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Enforce how deep the multicast queue can grow. 	 * 	 * XXX duplicated in ath_tx_start(). 	 */
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cabq
operator|->
name|axq_depth
operator|+
name|sc
operator|->
name|sc_cabq
operator|->
name|fifo
operator|.
name|axq_depth
operator|>
name|sc
operator|->
name|sc_txq_mcastq_maxdepth
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_mcastq_overflow
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 */
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|,
name|ATH_BUFTYPE_MGMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|3
argument_list|,
literal|"ath_raw_xmit: m=%p, params=%p, bf=%p\n"
argument_list|,
name|m
argument_list|,
name|params
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
if|if
condition|(
name|ath_tx_raw_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw
operator|++
expr_stmt|;
comment|/* 	 * Update the TIM - if there's anything queued to the 	 * software queue and power save is enabled, we should 	 * set the TIM. 	 */
name|ath_tx_update_tim
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txstart_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|3
argument_list|,
literal|"ath_raw_xmit: bad2: m=%p, params=%p, "
literal|"bf=%p"
argument_list|,
name|m
argument_list|,
name|params
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_returnbuf_head
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txstart_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad0
label|:
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_TX
argument_list|,
literal|2
argument_list|,
literal|"ath_raw_xmit: bad0: m=%p, params=%p"
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw_fail
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Some helper functions */
end_comment

begin_comment
comment|/*  * ADDBA (and potentially others) need to be placed in the same  * hardware queue as the TID/node it's relating to. This is so  * it goes out after any pending non-aggregate frames to the  * same node/TID.  *  * If this isn't done, the ADDBA can go out before the frames  * queued in hardware. Even though these frames have a sequence  * number -earlier- than the ADDBA can be transmitted (but  * no frames whose sequence numbers are after the ADDBA should  * be!) they'll arrive after the ADDBA - and the receiving end  * will simply drop them as being out of the BAW.  *  * The frames can't be appended to the TID software queue - it'll  * never be sent out. So these frames have to be directly  * dispatched to the hardware, rather than queued in software.  * So if this function returns true, the TXQ has to be  * overridden and it has to be directly dispatched.  *  * It's a dirty hack, but someone's gotta do it.  */
end_comment

begin_comment
comment|/*  * XXX doesn't belong here!  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_is_action
parameter_list|(
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|)
block|{
comment|/* Type: Management frame? */
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_MGT
condition|)
return|return
literal|0
return|;
comment|/* Subtype: Action frame? */
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_SUBTYPE_ACTION
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_comment
comment|/*  * Return an alternate TID for ADDBA request frames.  *  * Yes, this likely should be done in the net80211 layer.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_action_frame_override_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_action_ba_addbarequest
modifier|*
name|ia
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|;
comment|/* Not action frame? Bail */
if|if
condition|(
operator|!
name|ieee80211_is_action
argument_list|(
name|wh
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* XXX Not needed for frames we send? */
if|#
directive|if
literal|0
comment|/* Correct length? */
block|if (! ieee80211_parse_action(ni, m)) 		return 0;
endif|#
directive|endif
comment|/* Extract out action frame */
name|frm
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
expr_stmt|;
name|ia
operator|=
operator|(
expr|struct
name|ieee80211_action_ba_addbarequest
operator|*
operator|)
name|frm
expr_stmt|;
comment|/* Not ADDBA? Bail */
if|if
condition|(
name|ia
operator|->
name|rq_header
operator|.
name|ia_category
operator|!=
name|IEEE80211_ACTION_CAT_BA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ia
operator|->
name|rq_header
operator|.
name|ia_action
operator|!=
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
condition|)
return|return
literal|0
return|;
comment|/* Extract TID, return it */
name|baparamset
operator|=
name|le16toh
argument_list|(
name|ia
operator|->
name|rq_baparamset
argument_list|)
expr_stmt|;
operator|*
name|tid
operator|=
operator|(
name|int
operator|)
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MS
end_undef

begin_comment
comment|/* Per-node software queue operations */
end_comment

begin_comment
comment|/*  * Add the current packet to the given BAW.  * It is assumed that the current packet  *  * + fits inside the BAW;  * + already has had a sequence number allocated.  *  * Since the BAW status may be modified by both the ath task and  * the net80211/ifnet contexts, the TID must be locked.  */
end_comment

begin_function
name|void
name|ath_tx_addto_baw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|cindex
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
condition|)
return|return;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: dobaw=0, seqno=%d, window %d:%d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: re-added? tid=%d, seqno %d; window %d:%d; "
literal|"baw head=%d tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that the given sequence number is not outside of the 	 * BAW.  Complain loudly if that's the case. 	 */
if|if
condition|(
operator|!
name|BAW_WITHIN
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: bf=%p: outside of BAW?? tid=%d, seqno %d; window %d:%d; "
literal|"baw head=%d tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * ni->ni_txseqs[] is the currently allocated seqno. 	 * the txa state contains the current baw start. 	 */
name|index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|cindex
operator|=
operator|(
name|tid
operator|->
name|baw_head
operator|+
name|index
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: tid=%d, seqno %d; window %d:%d; index=%d cindex=%d "
literal|"baw head=%d tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|index
argument_list|,
name|cindex
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|assert(tid->tx_buf[cindex] == NULL);
endif|#
directive|endif
if|if
condition|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|!=
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: ba packet dup (index=%d, cindex=%d, "
literal|"head=%d, tail=%d)\n"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|,
name|cindex
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: BA bf: %p; seqno=%d ; new bf: %p; seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
argument_list|,
name|SEQNO
argument_list|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|=
name|bf
expr_stmt|;
if|if
condition|(
name|index
operator|>=
operator|(
operator|(
name|tid
operator|->
name|baw_tail
operator|-
name|tid
operator|->
name|baw_head
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|tid
operator|->
name|baw_tail
operator|=
name|cindex
expr_stmt|;
name|INCR
argument_list|(
name|tid
operator|->
name|baw_tail
argument_list|,
name|ATH_TID_MAX_BUFS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flip the BAW buffer entry over from the existing one to the new one.  *  * When software retransmitting a (sub-)frame, it is entirely possible that  * the frame ath_buf is marked as BUSY and can't be immediately reused.  * In that instance the buffer is cloned and the new buffer is used for  * retransmit. We thus need to update the ath_buf slot in the BAW buf  * tracking array to maintain consistency.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_switch_baw_buf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|old_bf
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|new_bf
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|cindex
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|seqno
init|=
name|SEQNO
argument_list|(
name|old_bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|cindex
operator|=
operator|(
name|tid
operator|->
name|baw_head
operator|+
name|index
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Just warn for now; if it happens then we should find out 	 * about it. It's highly likely the aggregation session will 	 * soon hang. 	 */
if|if
condition|(
name|old_bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
operator|!=
name|new_bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: retransmitted buffer"
literal|" has mismatching seqno's, BA session may hang.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: old seqno=%d, new_seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|old_bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|,
name|new_bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|!=
name|old_bf
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: ath_buf pointer incorrect; "
literal|" has m BA session may hang.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: old bf=%p, new bf=%p\n"
argument_list|,
name|__func__
argument_list|,
name|old_bf
argument_list|,
name|new_bf
argument_list|)
expr_stmt|;
block|}
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|=
name|new_bf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * seq_start - left edge of BAW  * seq_next - current/next sequence number to allocate  *  * Since the BAW status may be modified by both the ath task and  * the net80211/ifnet contexts, the TID must be locked.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_update_baw
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
specifier|const
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|cindex
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|seqno
init|=
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
name|cindex
operator|=
operator|(
name|tid
operator|->
name|baw_head
operator|+
name|index
operator|)
operator|&
operator|(
name|ATH_TID_MAX_BUFS
operator|-
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: tid=%d, baw=%d:%d, seqno=%d, index=%d, cindex=%d, "
literal|"baw head=%d, tail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|seqno
argument_list|,
name|index
argument_list|,
name|cindex
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|)
expr_stmt|;
comment|/* 	 * If this occurs then we have a big problem - something else 	 * has slid tap->txa_start along without updating the BAW 	 * tracking start/end pointers. Thus the TX BAW state is now 	 * completely busted. 	 * 	 * But for now, since I haven't yet fixed TDMA and buffer cloning, 	 * it's quite possible that a cloned buffer is making its way 	 * here and causing it to fire off. Disable TDMA for now. 	 */
if|if
condition|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|!=
name|bf
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: comp bf=%p, seq=%d; slot bf=%p, seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
argument_list|,
operator|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|!=
name|NULL
operator|)
condition|?
name|SEQNO
argument_list|(
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|tid
operator|->
name|tx_buf
index|[
name|cindex
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|tid
operator|->
name|baw_head
operator|!=
name|tid
operator|->
name|baw_tail
operator|&&
operator|!
name|tid
operator|->
name|tx_buf
index|[
name|tid
operator|->
name|baw_head
index|]
condition|)
block|{
name|INCR
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
name|tid
operator|->
name|baw_head
argument_list|,
name|ATH_TID_MAX_BUFS
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: baw is now %d:%d, baw head=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_leak_count_update
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|an
operator|->
name|an_leak_count
operator|>
literal|0
condition|)
block|{
name|wh
operator|=
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * Update MORE based on the software/net80211 queue states. 		 */
if|if
condition|(
operator|(
name|tid
operator|->
name|an
operator|->
name|an_stack_psq
operator|>
literal|0
operator|)
operator|||
operator|(
name|tid
operator|->
name|an
operator|->
name|an_swq_depth
operator|>
literal|0
operator|)
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
else|else
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE_PWRSAVE
argument_list|,
literal|"%s: %6D: leak count = %d, psq=%d, swq=%d, MORE=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_leak_count
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_stack_psq
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_swq_depth
argument_list|,
operator|!
operator|!
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_DATA
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Re-sync the underlying buffer. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|tid
operator|->
name|an
operator|->
name|an_leak_count
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_tid_can_tx_or_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|an
operator|->
name|an_leak_count
operator|>
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the current node/TID as ready to TX.  *  * This is done to make it easy for the software scheduler to  * find which nodes have data to send.  *  * The TXQ lock must be held.  */
end_comment

begin_function
name|void
name|ath_tx_tid_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If we are leaking out a frame to this destination 	 * for PS-POLL, ensure that we allow scheduling to 	 * occur. 	 */
if|if
condition|(
operator|!
name|ath_tx_tid_can_tx_or_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
condition|)
return|return;
comment|/* paused, can't schedule yet */
if|if
condition|(
name|tid
operator|->
name|sched
condition|)
return|return;
comment|/* already scheduled */
name|tid
operator|->
name|sched
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * If this is a sleeping node we're leaking to, given 	 * it a higher priority.  This is so bad for QoS it hurts. 	 */
block|if (tid->an->an_leak_count) { 		TAILQ_INSERT_HEAD(&txq->axq_tidq, tid, axq_qelem); 	} else { 		TAILQ_INSERT_TAIL(&txq->axq_tidq, tid, axq_qelem); 	}
endif|#
directive|endif
comment|/* 	 * We can't do the above - it'll confuse the TXQ software 	 * scheduler which will keep checking the _head_ TID 	 * in the list to see if it has traffic.  If we queue 	 * a TID to the head of the list and it doesn't transmit, 	 * we'll check it again. 	 * 	 * So, get the rest of this leaking frames support working 	 * and reliable first and _then_ optimise it so they're 	 * pushed out in front of any other pending software 	 * queued nodes. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|,
name|tid
argument_list|,
name|axq_qelem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the current node as no longer needing to be polled for  * TX packets.  *  * The TXQ lock must be held.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_unsched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|sched
operator|==
literal|0
condition|)
return|return;
name|tid
operator|->
name|sched
operator|=
literal|0
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|,
name|tid
argument_list|,
name|axq_qelem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assign a sequence number manually to the given frame.  *  * This should only be called for A-MPDU TX frames.  */
end_comment

begin_function
specifier|static
name|ieee80211_seq
name|ath_tx_tid_seqno_assign
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|pri
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
comment|/* TID lookup */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* honor classification */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|pri
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: pri=%d, tid=%d, qos has seq=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pri
argument_list|,
name|tid
argument_list|,
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX Is it a control frame? Ignore */
comment|/* Does the packet require a sequence number? */
if|if
condition|(
operator|!
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Is it a QOS NULL Data frame? Give it a sequence number from 	 * the default TID (IEEE80211_NONQOS_TID.) 	 * 	 * The RX path of everything I've looked at doesn't include the NULL 	 * data frame sequence number in the aggregation state updates, so 	 * assigning it a sequence number there will cause a BAW hole on the 	 * RX side. 	 */
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
condition|)
block|{
comment|/* XXX no locking for this TID? This is a bit of a problem. */
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
expr_stmt|;
name|INCR
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Manually assign sequence number */
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
expr_stmt|;
name|INCR
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|M_SEQNO_SET
argument_list|(
name|m0
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
comment|/* Return so caller can do something with it if needed */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s:  -> seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
return|return
name|seqno
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to direct dispatch an aggregate frame to hardware.  * If the frame is out of BAW, queue.  * Otherwise, schedule it as a single frame.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_xmit_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
comment|/* paused? queue */
if|if
condition|(
operator|!
name|ath_tx_tid_can_tx_or_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
condition|)
block|{
name|ATH_TID_INSERT_HEAD
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* XXX don't sched - we're paused! */
return|return;
block|}
comment|/* outside baw? queue */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|&&
operator|(
operator|!
name|BAW_WITHIN
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ATH_TID_INSERT_HEAD
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This is a temporary check and should be removed once 	 * all the relevant code paths have been fixed. 	 * 	 * During aggregate retries, it's possible that the head 	 * frame will fail (which has the bfs_aggr and bfs_nframes 	 * fields set for said aggregate) and will be retried as 	 * a single frame.  In this instance, the values should 	 * be reset or the completion code will get upset with you. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|!=
literal|0
operator|||
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|>
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: bfs_aggr=%d, bfs_nframes=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Update CLRDMASK just before this frame is queued */
name|ath_tx_update_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Direct dispatch to hardware */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_duration
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_protection
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Statistics */
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_low_hwq_single_pkt
operator|++
expr_stmt|;
comment|/* Track per-TID hardware queue depth correctly */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* Add to BAW */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_addto_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set completion handler, multi-frame aggregate or not */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_aggr_comp
expr_stmt|;
comment|/* 	 * Update the current leak count if 	 * we're leaking frames; and set the 	 * MORE flag as appropriate. 	 */
name|ath_tx_leak_count_update
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Hand off to hardware */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to send the packet.  * If the queue isn't busy, direct-dispatch.  * If the queue is busy enough, queue the given packet on the  *  relevant software queue.  */
end_comment

begin_function
name|void
name|ath_tx_swq
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|int
name|queue_to_head
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
decl_stmt|;
name|int
name|pri
decl_stmt|,
name|tid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|bf
operator|->
name|bf_m
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Fetch the TID - non-QoS frames get assigned to TID 16 */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pri
operator|=
name|ath_tx_getac
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|tid
operator|=
name|ath_tx_gettid
argument_list|(
name|sc
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|atid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p, pri=%d, tid=%d, qos=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|pri
argument_list|,
name|tid
argument_list|,
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set local packet state, used to queue packets to hardware */
comment|/* XXX potentially duplicate info, re-check */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
operator|=
name|tid
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tx_queue
operator|=
name|txq
operator|->
name|axq_qnum
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pri
operator|=
name|pri
expr_stmt|;
comment|/* 	 * If the hardware queue isn't busy, queue it directly. 	 * If the hardware queue is busy, queue it. 	 * If the TID is paused or the traffic it outside BAW, software 	 * queue it. 	 * 	 * If the node is in power-save and we're leaking a frame, 	 * leak a single frame. 	 */
if|if
condition|(
operator|!
name|ath_tx_tid_can_tx_or_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
block|{
comment|/* TID is paused, queue */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: paused\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * If the caller requested that it be sent at a high 		 * priority, queue it at the head of the list. 		 */
if|if
condition|(
name|queue_to_head
condition|)
name|ATH_TID_INSERT_HEAD
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
else|else
name|ATH_TID_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ath_tx_ampdu_pending
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|)
condition|)
block|{
comment|/* AMPDU pending; queue */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: pending\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TID_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* XXX sched? */
block|}
elseif|else
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|)
condition|)
block|{
comment|/* AMPDU running, attempt direct dispatch if possible */
comment|/* 		 * Always queue the frame to the tail of the list. 		 */
name|ATH_TID_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* 		 * If the hardware queue isn't busy, direct dispatch 		 * the head frame in the list.  Don't schedule the 		 * TID - let it build some more frames first? 		 * 		 * When running A-MPDU, always just check the hardware 		 * queue depth against the aggregate frame limit. 		 * We don't want to burst a large number of single frames 		 * out to the hardware; we want to aggressively hold back. 		 * 		 * Otherwise, schedule the TID. 		 */
comment|/* XXX TXQ locking */
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|+
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
operator|<
name|sc
operator|->
name|sc_hwq_limit_aggr
condition|)
block|{
name|bf
operator|=
name|ATH_TID_FIRST
argument_list|(
name|atid
argument_list|)
expr_stmt|;
name|ATH_TID_REMOVE
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure it's definitely treated as a non-AMPDU 			 * frame - this information may have been left 			 * over from a previous attempt. 			 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|=
literal|1
expr_stmt|;
comment|/* Queue to the hardware */
name|ath_tx_xmit_aggr
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: xmit_aggr\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: ampdu; swq'ing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're not doing A-MPDU, be prepared to direct dispatch 	 * up to both limits if possible.  This particular corner 	 * case may end up with packet starvation between aggregate 	 * traffic and non-aggregate traffic: we wnat to ensure 	 * that non-aggregate stations get a few frames queued to the 	 * hardware before the aggregate station(s) get their chance. 	 * 	 * So if you only ever see a couple of frames direct dispatched 	 * to the hardware from a non-AMPDU client, check both here 	 * and in the software queue dispatcher to ensure that those 	 * non-AMPDU stations get a fair chance to transmit. 	 */
comment|/* XXX TXQ locking */
block|}
elseif|else
if|if
condition|(
operator|(
name|txq
operator|->
name|axq_depth
operator|+
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
operator|<
name|sc
operator|->
name|sc_hwq_limit_nonaggr
operator|)
operator|&&
operator|(
name|txq
operator|->
name|axq_aggr_depth
operator|<
name|sc
operator|->
name|sc_hwq_limit_aggr
operator|)
condition|)
block|{
comment|/* AMPDU not running, attempt direct dispatch */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: xmit_normal\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* See if clrdmask needs to be set */
name|ath_tx_update_clrdmask
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 		 * Update the current leak count if 		 * we're leaking frames; and set the 		 * MORE flag as appropriate. 		 */
name|ath_tx_leak_count_update
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 		 * Dispatch the frame. 		 */
name|ath_tx_xmit_normal
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Busy; queue */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: swq'ing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TID_INSERT_TAIL
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Only set the clrdmask bit if none of the nodes are currently  * filtered.  *  * XXX TODO: go through all the callers and check to see  * which are being called in the context of looping over all  * TIDs (eg, if all tids are being paused, resumed, etc.)  * That'll avoid O(n^2) complexity here.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_set_clrdmask
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|an
operator|->
name|an_tid
index|[
name|i
index|]
operator|.
name|isfiltered
operator|==
literal|1
condition|)
return|return;
block|}
name|an
operator|->
name|clrdmask
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure the per-TID node state.  *  * This likely belongs in if_ath_node.c but I can't think of anywhere  * else to put it just yet.  *  * This sets up the SLISTs and the mutex as appropriate.  */
end_comment

begin_function
name|void
name|ath_tx_tid_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|atid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|i
index|]
expr_stmt|;
comment|/* XXX now with this bzer(), is the field 0'ing needed? */
name|bzero
argument_list|(
name|atid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|atid
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|atid
operator|->
name|tid_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|atid
operator|->
name|filtq
operator|.
name|tid_q
argument_list|)
expr_stmt|;
name|atid
operator|->
name|tid
operator|=
name|i
expr_stmt|;
name|atid
operator|->
name|an
operator|=
name|an
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ATH_TID_MAX_BUFS
condition|;
name|j
operator|++
control|)
name|atid
operator|->
name|tx_buf
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
name|atid
operator|->
name|baw_head
operator|=
name|atid
operator|->
name|baw_tail
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|paused
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|sched
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|=
literal|0
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|atid
operator|->
name|ac
operator|=
name|ATH_NONQOS_TID_AC
expr_stmt|;
else|else
name|atid
operator|->
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|an
operator|->
name|clrdmask
operator|=
literal|1
expr_stmt|;
comment|/* Always start by setting this bit */
block|}
end_function

begin_comment
comment|/*  * Pause the current TID. This stops packets from being transmitted  * on it.  *  * Since this is also called from upper layers as well as the driver,  * it will get the TID lock.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_pause
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tid
operator|->
name|paused
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: paused = %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|paused
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unpause the current TID, and schedule it if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_resume
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * There's some odd places where ath_tx_tid_resume() is called 	 * when it shouldn't be; this works around that particular issue 	 * until it's actually resolved. 	 */
if|if
condition|(
name|tid
operator|->
name|paused
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: %6D: paused=0?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tid
operator|->
name|paused
operator|--
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: unpaused = %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|paused
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|paused
condition|)
return|return;
comment|/* 	 * Override the clrdmask configuration for the next frame 	 * from this TID, just to get the ball rolling. 	 */
name|ath_tx_set_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|axq_depth
operator|==
literal|0
condition|)
return|return;
comment|/* XXX isfiltered shouldn't ever be 0 at this point */
if|if
condition|(
name|tid
operator|->
name|isfiltered
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: filtered?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * Queue the software TX scheduler. 	 */
name|ath_tx_swq_kick
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the given ath_buf to the TID filtered frame list.  * This requires the TID be filtered.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_filt_addbuf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tid
operator|->
name|isfiltered
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: not filtered?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: bf=%p\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Set the retry bit and bump the retry counter */
name|ath_tx_set_retry
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swfiltered
operator|++
expr_stmt|;
name|ATH_TID_FILT_INSERT_TAIL
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a completed filtered frame from the given TID.  * This just enables/pauses the filtered frame state if required  * and appends the filtered frame to the filtered queue.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_filt_comp_buf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tid
operator|->
name|isfiltered
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: filter transition\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tid
operator|->
name|isfiltered
operator|=
literal|1
expr_stmt|;
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
comment|/* Add the frame to the filter queue */
name|ath_tx_tid_filt_addbuf
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the filtered frame TX completion.  *  * If there are no more frames in the hardware queue, unpause/unfilter  * the TID if applicable.  Otherwise we will wait for a node PS transition  * to unfilter.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_filt_comp_complete
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|hwq_depth
operator|!=
literal|0
condition|)
return|return;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: hwq=0, transition back\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tid
operator|->
name|isfiltered
operator|=
literal|0
expr_stmt|;
comment|/* XXX ath_tx_tid_resume() also calls ath_tx_set_clrdmask()! */
name|ath_tx_set_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|)
expr_stmt|;
comment|/* XXX this is really quite inefficient */
while|while
condition|(
operator|(
name|bf
operator|=
name|ATH_TID_FILT_LAST
argument_list|(
name|tid
argument_list|,
name|ath_bufhead_s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ATH_TID_FILT_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TID_INSERT_HEAD
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a single (aggregate or otherwise) frame is completed.  *  * Returns 1 if the buffer could be added to the filtered list  * (cloned or otherwise), 0 if the buffer couldn't be added to the  * filtered list (failed clone; expired retry) and the caller should  * free it and handle it like a failure (eg by sending a BAR.)  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_tid_filt_comp_single
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Don't allow a filtered frame to live forever. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>
name|SWMAX_RETRIES
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretrymax
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: bf=%p, seqno=%d, exceeded retries\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * A busy buffer can't be added to the retry list. 	 * It needs to be cloned. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
condition|)
block|{
name|nbf
operator|=
name|ath_tx_retry_clone
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: busy buffer clone: %p -> %p\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|nbf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbf
operator|=
name|bf
expr_stmt|;
block|}
if|if
condition|(
name|nbf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: busy buffer couldn't be cloned (%p)!\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ath_tx_tid_filt_comp_buf
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|nbf
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_tid_filt_comp_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_q
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|,
modifier|*
name|nbf
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Remove it from the aggr list */
comment|/* 		 * Don't allow a filtered frame to live forever. 		 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>
name|SWMAX_RETRIES
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretrymax
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: bf=%p, seqno=%d, exceeded retries\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
condition|)
block|{
name|nbf
operator|=
name|ath_tx_retry_clone
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: busy buffer cloned: %p -> %p"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|nbf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbf
operator|=
name|bf
expr_stmt|;
block|}
comment|/* 		 * If the buffer couldn't be cloned, add it to bf_q; 		 * the caller will free the buffer(s) as required. 		 */
if|if
condition|(
name|nbf
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_FILT
argument_list|,
literal|"%s: buffer couldn't be cloned! (%p)\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ath_tx_tid_filt_comp_buf
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|nbf
argument_list|)
expr_stmt|;
block|}
name|next
label|:
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Suspend the queue because we need to TX a BAR.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_bar_suspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: tid=%d, bar_wait=%d, bar_tx=%d, called\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|bar_wait
argument_list|,
name|tid
operator|->
name|bar_tx
argument_list|)
expr_stmt|;
comment|/* We shouldn't be called when bar_tx is 1 */
if|if
condition|(
name|tid
operator|->
name|bar_tx
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: bar_tx is 1?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* If we've already been called, just be patient. */
if|if
condition|(
name|tid
operator|->
name|bar_wait
condition|)
return|return;
comment|/* Wait! */
name|tid
operator|->
name|bar_wait
operator|=
literal|1
expr_stmt|;
comment|/* Only one pause, no matter how many frames fail */
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've finished with BAR handling - either we succeeded or  * failed. Either way, unsuspend TX.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_bar_unsuspend
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, called\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|bar_tx
operator|==
literal|0
operator|||
name|tid
operator|->
name|bar_wait
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, bar_tx=%d, bar_wait=%d: ?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|bar_tx
argument_list|,
name|tid
operator|->
name|bar_wait
argument_list|)
expr_stmt|;
block|}
name|tid
operator|->
name|bar_tx
operator|=
name|tid
operator|->
name|bar_wait
operator|=
literal|0
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return whether we're ready to TX a BAR frame.  *  * Requires the TID lock be held.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_tid_bar_tx_ready
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|bar_wait
operator|==
literal|0
operator|||
name|tid
operator|->
name|hwq_depth
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, bar ready\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether the current TID is ready to have a BAR  * TXed and if so, do the TX.  *  * Since the TID/TXQ lock can't be held during a call to  * ieee80211_send_bar(), we have to do the dirty thing of unlocking it,  * sending the BAR and locking it again.  *  * Eventually, the code to send the BAR should be broken out  * from this routine so the lock doesn't have to be reacquired  * just to be immediately dropped by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_bar_tx
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, called\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|tid
operator|->
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * This is an error condition! 	 */
if|if
condition|(
name|tid
operator|->
name|bar_wait
operator|==
literal|0
operator|||
name|tid
operator|->
name|bar_tx
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, bar_tx=%d, bar_wait=%d: ?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|bar_tx
argument_list|,
name|tid
operator|->
name|bar_wait
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Don't do anything if we still have pending frames */
if|if
condition|(
name|tid
operator|->
name|hwq_depth
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, hwq_depth=%d, waiting\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We're now about to TX */
name|tid
operator|->
name|bar_tx
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Override the clrdmask configuration for the next frame, 	 * just to get the ball rolling. 	 */
name|ath_tx_set_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate new BAW left edge, now that all frames have either 	 * succeeded or failed. 	 * 	 * XXX verify this is _actually_ the valid value to begin at! 	 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, new BAW left edge=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|)
expr_stmt|;
comment|/* Try sending the BAR frame */
comment|/* We can't hold the lock here! */
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_send_bar
argument_list|(
operator|&
name|tid
operator|->
name|an
operator|->
name|an_node
argument_list|,
name|tap
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Success? Now we wait for notification that it's done */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Failure? For now, warn loudly and continue */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: TID=%d, failed to TX BAR, continue!\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ath_tx_tid_bar_unsuspend
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_tid_drain_pkt
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_cq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If the current TID is running AMPDU, update 	 * the BAW. 	 */
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
operator|&&
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
comment|/* 		 * Only remove the frame from the BAW if it's 		 * been transmitted at least once; this means 		 * the frame was in the BAW to begin with. 		 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>
literal|0
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * This has become a non-fatal error now 		 */
block|if (! bf->bf_state.bfs_addedbaw) 			DPRINTF(sc, ATH_DEBUG_SW_TX_BAW 			    "%s: wasn't added: seqno %d\n", 			    __func__, SEQNO(bf->bf_state.bfs_seqno));
endif|#
directive|endif
block|}
comment|/* Strip it out of an aggregate list if it was in one */
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Insert on the free queue to be freed by the caller */
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_tid_drain_print
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
specifier|const
name|char
modifier|*
name|pfx
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: %s: %6D: bf=%p: addbaw=%d, dobaw=%d, "
literal|"seqno=%d, retry=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pfx
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: %s: %6D: bf=%p: txq[%d] axq_depth=%d, axq_aggr_depth=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pfx
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|bf
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|,
name|txq
operator|->
name|axq_aggr_depth
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: %s: %6D: bf=%p: tid txq_depth=%d hwq_depth=%d, bar_wait=%d, "
literal|"isfiltered=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pfx
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|bf
argument_list|,
name|tid
operator|->
name|axq_depth
argument_list|,
name|tid
operator|->
name|hwq_depth
argument_list|,
name|tid
operator|->
name|bar_wait
argument_list|,
name|tid
operator|->
name|isfiltered
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: %s: %6D: tid %d: "
literal|"sched=%d, paused=%d, "
literal|"incomp=%d, baw_head=%d, "
literal|"baw_tail=%d txa_start=%d, ni_txseqs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pfx
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|sched
argument_list|,
name|tid
operator|->
name|paused
argument_list|,
name|tid
operator|->
name|incomp
argument_list|,
name|tid
operator|->
name|baw_head
argument_list|,
name|tid
operator|->
name|baw_tail
argument_list|,
name|tap
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|tap
operator|->
name|txa_start
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
operator|->
name|tid
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Dump the frame, see what it is? */
name|ieee80211_dump_pkt
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|mtod
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|bf
operator|->
name|bf_m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free any packets currently pending in the software TX queue.  *  * This will be called when a node is being deleted.  *  * It can also be called on an active node during an interface  * reset or state transition.  *  * (From Linux/reference):  *  * TODO: For frame(s) that are in the retry state, we will reuse the  * sequence number(s) without setting the retry bit. The  * alternative is to give up on these and BAR the receiver's window  * forward.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_drain
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_cq
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|int
name|t
decl_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Walk the queue, free frames */
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bf
operator|=
name|ATH_TID_FIRST
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|ath_tx_tid_drain_print
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
literal|"norm"
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|t
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_TID_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_drain_pkt
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf_cq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
comment|/* And now, drain the filtered frame queue */
name|t
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bf
operator|=
name|ATH_TID_FILT_FIRST
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|ath_tx_tid_drain_print
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
literal|"filt"
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|t
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_TID_FILT_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_drain_pkt
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf_cq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Override the clrdmask configuration for the next frame 	 * in case there is some future transmission, just to get 	 * the ball rolling. 	 * 	 * This won't hurt things if the TID is about to be freed. 	 */
name|ath_tx_set_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|)
expr_stmt|;
comment|/* 	 * Now that it's completed, grab the TID lock and update 	 * the sequence number and BAW window. 	 * Because sequence numbers have been assigned to frames 	 * that haven't been sent yet, it's entirely possible 	 * we'll be called with some pending frames that have not 	 * been transmitted. 	 * 	 * The cleaner solution is to do the sequence number allocation 	 * when the packet is first transmitted - and thus the "retries" 	 * check above would be enough to update the BAW/seqno. 	 */
comment|/* But don't do it for non-QoS TIDs */
if|if
condition|(
name|tap
condition|)
block|{
if|#
directive|if
literal|1
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: %6D: node %p: TID %d: sliding BAW left edge to %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
operator|->
name|tid
index|]
operator|=
name|tap
operator|->
name|txa_start
expr_stmt|;
name|tid
operator|->
name|baw_tail
operator|=
name|tid
operator|->
name|baw_head
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the TID state.  This must be only called once the node has  * had its frames flushed from this TID, to ensure that no other  * pause / unpause logic can kick in.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_reset
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
if|#
directive|if
literal|0
block|tid->bar_wait = tid->bar_tx = tid->isfiltered = 0; 	tid->paused = tid->sched = tid->addba_tx_pending = 0; 	tid->incomp = tid->cleanup_inprogress = 0;
endif|#
directive|endif
comment|/* 	 * If we have a bar_wait set, we need to unpause the TID 	 * here.  Otherwise once cleanup has finished, the TID won't 	 * have the right paused counter. 	 * 	 * XXX I'm not going through resume here - I don't want the 	 * node to be rescheuled just yet.  This however should be 	 * methodized! 	 */
if|if
condition|(
name|tid
operator|->
name|bar_wait
condition|)
block|{
if|if
condition|(
name|tid
operator|->
name|paused
operator|>
literal|0
condition|)
block|{
name|tid
operator|->
name|paused
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * XXX same with a currently filtered TID. 	 * 	 * Since this is being called during a flush, we assume that 	 * the filtered frame list is actually empty. 	 * 	 * XXX TODO: add in a check to ensure that the filtered queue 	 * depth is actually 0! 	 */
if|if
condition|(
name|tid
operator|->
name|isfiltered
condition|)
block|{
if|if
condition|(
name|tid
operator|->
name|paused
operator|>
literal|0
condition|)
block|{
name|tid
operator|->
name|paused
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * Clear BAR, filtered frames, scheduled and ADDBA pending. 	 * The TID may be going through cleanup from the last association 	 * where things in the BAW are still in the hardware queue. 	 */
name|tid
operator|->
name|bar_wait
operator|=
literal|0
expr_stmt|;
name|tid
operator|->
name|bar_tx
operator|=
literal|0
expr_stmt|;
name|tid
operator|->
name|isfiltered
operator|=
literal|0
expr_stmt|;
name|tid
operator|->
name|sched
operator|=
literal|0
expr_stmt|;
name|tid
operator|->
name|addba_tx_pending
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX TODO: it may just be enough to walk the HWQs and mark 	 * frames for that node as non-aggregate; or mark the ath_node 	 * with something that indicates that aggregation is no longer 	 * occuring.  Then we can just toss the BAW complaints and 	 * do a complete hard reset of state here - no pause, no 	 * complete counter, etc. 	 */
block|}
end_function

begin_comment
comment|/*  * Flush all software queued packets for the given node.  *  * This occurs when a completion handler frees the last buffer  * for a node, and the node is thus freed. This causes the node  * to be cleaned up, which ends up calling ath_tx_node_flush.  */
end_comment

begin_function
name|void
name|ath_tx_node_flush
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_NODE
argument_list|,
literal|1
argument_list|,
literal|"ath_tx_node_flush: flush node; ni=%p"
argument_list|,
operator|&
name|an
operator|->
name|an_node
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: flush; is_powersave=%d, stack_psq=%d, tim=%d, "
literal|"swq_depth=%d, clrdmask=%d, leak_count=%d\n"
argument_list|,
name|__func__
argument_list|,
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|an
operator|->
name|an_is_powersave
argument_list|,
name|an
operator|->
name|an_stack_psq
argument_list|,
name|an
operator|->
name|an_tim_set
argument_list|,
name|an
operator|->
name|an_swq_depth
argument_list|,
name|an
operator|->
name|clrdmask
argument_list|,
name|an
operator|->
name|an_leak_count
argument_list|)
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|tid
operator|++
control|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
comment|/* Free packets */
name|ath_tx_tid_drain
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
comment|/* Remove this tid from the list of active tids */
name|ath_tx_tid_unsched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* Reset the per-TID pause, BAR, etc state */
name|ath_tx_tid_reset
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear global leak count 	 */
name|an
operator|->
name|an_leak_count
operator|=
literal|0
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle completed frames */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain all the software TXQs currently with traffic queued.  */
end_comment

begin_function
name|void
name|ath_tx_txq_drain
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all active tids for the given txq, 	 * flushing and unsched'ing them 	 */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|)
condition|)
block|{
name|tid
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|)
expr_stmt|;
name|ath_tx_tid_drain
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ath_tx_tid_unsched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle completion of non-aggregate session frames.  *  * This (currently) doesn't implement software retransmission of  * non-aggregate frames!  *  * Software retransmission of non-aggregate frames needs to obey  * the strict sequence number ordering, and drop any frames that  * will fail this.  *  * For now, filtered frames and frame transmission will cause  * all kinds of issues.  So we don't support them.  *  * So anyone queuing frames via ath_tx_normal_xmit() or  * ath_tx_hw_queue_norm() must override and set CLRDMASK.  */
end_comment

begin_function
name|void
name|ath_tx_normal_comp
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_tx_status
modifier|*
name|ts
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
decl_stmt|;
comment|/* The TID state is protected behind the TXQ lock */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p: fail=%d, hwq_depth now %d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|,
name|atid
operator|->
name|hwq_depth
operator|-
literal|1
argument_list|)
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|--
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * If the frame was filtered, stick it on the filter frame 	 * queue and complain about it.  It shouldn't happen! 	 */
block|if ((ts->ts_status& HAL_TXERR_FILT) || 	    (ts->ts_status != 0&& atid->isfiltered)) { 		DPRINTF(sc, ATH_DEBUG_SW_TX, 		    "%s: isfiltered=%d, ts_status=%d: huh?\n", 		    __func__, 		    atid->isfiltered, 		    ts->ts_status); 		ath_tx_tid_filt_comp_buf(sc, atid, bf); 	}
endif|#
directive|endif
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: filtered?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|hwq_depth
operator|<
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: hwq_depth< 0: %d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * If the queue is filtered, potentially mark it as complete 	 * and reschedule it as needed. 	 * 	 * This is required as there may be a subsequent TX descriptor 	 * for this end-node that has CLRDMASK set, so it's quite possible 	 * that a filtered frame will be followed by a non-filtered 	 * (complete or otherwise) frame. 	 * 	 * XXX should we do this before we complete the frame? 	 */
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * punt to rate control if we're not being cleaned up 	 * during a hw queue drain and the frame wanted an ACK. 	 */
if|if
condition|(
name|fail
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|)
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
name|ts
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
literal|1
argument_list|,
operator|(
name|ts
operator|->
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle cleanup of aggregate session packets that aren't  * an A-MPDU.  *  * There's no need to update the BAW here - the session is being  * torn down.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_comp_cleanup_unaggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: incomp=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|atid
operator|->
name|incomp
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atid
operator|->
name|incomp
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|incomp
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: cleaned up! resume!\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|0
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs transmit side cleanup when TID changes from aggregated to  * unaggregated.  *  * - Discard all retry frames from the s/w queue.  * - Fix the tx completion function for all buffers in s/w queue.  * - Count the number of unacked frames, and let transmit completion  *   handle it later.  *  * The caller is responsible for pausing the TID and unpausing the  * TID if no cleanup was required. Otherwise the cleanup path will  * unpause the TID once the last hardware queued frame is completed.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_tid_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_cq
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: TID %d: called\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * Move the filtered frames to the TX queue, before 	 * we run off and discard/process things. 	 */
comment|/* XXX this is really quite inefficient */
while|while
condition|(
operator|(
name|bf
operator|=
name|ATH_TID_FILT_LAST
argument_list|(
name|atid
argument_list|,
name|ath_bufhead_s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ATH_TID_FILT_REMOVE
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TID_INSERT_HEAD
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the frames in the software TX queue: 	 * 	 * + Discard retry frames in the queue 	 * + Fix the completion function to be non-aggregate 	 */
name|bf
operator|=
name|ATH_TID_FIRST
argument_list|(
name|atid
argument_list|)
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_isretried
condition|)
block|{
name|bf_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TID_REMOVE
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Call the default completion handler with "fail" just 			 * so upper levels are suitably notified about this. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|bf
operator|=
name|bf_next
expr_stmt|;
continue|continue;
block|}
comment|/* Give these the default completion handler */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_normal_comp
expr_stmt|;
name|bf
operator|=
name|TAILQ_NEXT
argument_list|(
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate what hardware-queued frames exist based 	 * on the current BAW size. Ie, what frames have been 	 * added to the TX hardware queue for this TID but 	 * not yet ACKed. 	 */
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* Need the lock - fiddling with BAW */
while|while
condition|(
name|atid
operator|->
name|baw_head
operator|!=
name|atid
operator|->
name|baw_tail
condition|)
block|{
if|if
condition|(
name|atid
operator|->
name|tx_buf
index|[
name|atid
operator|->
name|baw_head
index|]
condition|)
block|{
name|atid
operator|->
name|incomp
operator|++
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|1
expr_stmt|;
name|atid
operator|->
name|tx_buf
index|[
name|atid
operator|->
name|baw_head
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|INCR
argument_list|(
name|atid
operator|->
name|baw_head
argument_list|,
name|ATH_TID_MAX_BUFS
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_SEQ_RANGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atid
operator|->
name|cleanup_inprogress
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: cleanup needed: %d packets\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|atid
operator|->
name|incomp
argument_list|)
expr_stmt|;
comment|/* Owner now must free completed frames */
block|}
end_function

begin_function
specifier|static
name|struct
name|ath_buf
modifier|*
name|ath_tx_retry_clone
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Clone the buffer.  This will handle the dma unmap and 	 * copy the node reference to the new buffer.  If this 	 * works out, 'bf' will have no DMA mapping, no mbuf 	 * pointer and no node reference. 	 */
name|nbf
operator|=
name|ath_buf_clone
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DPRINTF(sc, ATH_DEBUG_XMIT, "%s: ATH_BUF_BUSY; cloning\n", 	    __func__);
endif|#
directive|endif
if|if
condition|(
name|nbf
operator|==
name|NULL
condition|)
block|{
comment|/* Failed to clone */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: failed to clone a busy buffer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Setup the dma for the new buffer */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|nbf
argument_list|,
name|nbf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: failed to setup dma for clone\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * Put this at the head of the list, not tail; 		 * that way it doesn't interfere with the 		 * busy buffer logic (which uses the tail of 		 * the list.) 		 */
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_returnbuf_head
argument_list|(
name|sc
argument_list|,
name|nbf
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Update BAW if required, before we free the original buf */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
name|ath_tx_switch_baw_buf
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|,
name|nbf
argument_list|)
expr_stmt|;
comment|/* Free original buffer; return new buffer */
name|ath_freebuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
name|nbf
return|;
block|}
end_function

begin_comment
comment|/*  * Handle retrying an unaggregate frame in an aggregate  * session.  *  * If too many retries occur, pause the TID, wait for  * any further retransmits (as there's no reason why  * non-aggregate frames in an aggregate session are  * transmitted in-order; they just have to be in-BAW)  * and then queue a BAR.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_aggr_retry_unaggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * If the buffer is marked as busy, we can't directly 	 * reuse it. Instead, try to clone the buffer. 	 * If the clone is successful, recycle the old buffer. 	 * If the clone is unsuccessful, set bfs_retries to max 	 * to force the next bit of code to free the buffer 	 * for us. 	 */
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|<
name|SWMAX_RETRIES
operator|)
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|nbf
operator|=
name|ath_tx_retry_clone
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbf
condition|)
comment|/* bf has been freed at this point */
name|bf
operator|=
name|nbf
expr_stmt|;
else|else
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|=
name|SWMAX_RETRIES
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>=
name|SWMAX_RETRIES
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_RETRIES
argument_list|,
literal|"%s: exceeded retries; seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretrymax
operator|++
expr_stmt|;
comment|/* Update BAW anyway */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
comment|/* Suspend the TX queue and get ready to send the BAR */
name|ath_tx_tid_bar_suspend
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* Send the BAR if there are no other frames waiting */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free buffer, bf is free after this call */
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This increments the retry counter as well as 	 * sets the retry flag in the ath_buf and packet 	 * body. 	 */
name|ath_tx_set_retry
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretries
operator|++
expr_stmt|;
comment|/* 	 * Insert this at the head of the queue, so it's 	 * retried before any current/subsequent frames. 	 */
name|ATH_TID_INSERT_HEAD
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* Send the BAR if there are no other frames waiting */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common code for aggregate excessive retry/subframe retry.  * If retrying, queues buffers to bf_q. If not, frees the  * buffers.  *  * XXX should unify this with ath_tx_aggr_retry_unaggr()  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_retry_subframe
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|ath_bufhead
modifier|*
name|bf_q
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX clr11naggr should be done for all subframes */
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
name|ath_hal_set11nburstduration
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ath_hal_set11n_virtualmorefrag(sc->sc_ah, bf->bf_desc, 0); */
comment|/* 	 * If the buffer is marked as busy, we can't directly 	 * reuse it. Instead, try to clone the buffer. 	 * If the clone is successful, recycle the old buffer. 	 * If the clone is unsuccessful, set bfs_retries to max 	 * to force the next bit of code to free the buffer 	 * for us. 	 */
if|if
condition|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|<
name|SWMAX_RETRIES
operator|)
operator|&&
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|nbf
decl_stmt|;
name|nbf
operator|=
name|ath_tx_retry_clone
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbf
condition|)
comment|/* bf has been freed at this point */
name|bf
operator|=
name|nbf
expr_stmt|;
else|else
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|=
name|SWMAX_RETRIES
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_retries
operator|>=
name|SWMAX_RETRIES
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretrymax
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_RETRIES
argument_list|,
literal|"%s: max retries: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAW
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ath_tx_set_retry
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_swretries
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Just to make sure */
comment|/* Clear the aggregate state */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
operator|=
literal|0
expr_stmt|;
comment|/* ??? needed? */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * error pkt completion for an aggregate destination  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_comp_aggr_error
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf_first
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf_next
decl_stmt|,
modifier|*
name|bf
decl_stmt|;
name|ath_bufhead
name|bf_q
decl_stmt|;
name|int
name|drops
init|=
literal|0
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
comment|/* 	 * Update rate control - all frames have failed. 	 * 	 * XXX use the length in the first frame in the series; 	 * XXX just so things are consistent for now. 	 */
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
operator|&
name|bf_first
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_aggr_failall
operator|++
expr_stmt|;
comment|/* Retry all subframes */
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Remove it from the aggr list */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_aggr_fail
operator|++
expr_stmt|;
if|if
condition|(
name|ath_tx_retry_subframe
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
operator|&
name|bf_q
argument_list|)
condition|)
block|{
name|drops
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
comment|/* Prepend all frames to the beginning of the queue */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bf_q
argument_list|,
name|ath_bufhead_s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TID_INSERT_HEAD
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Schedule the TID to be re-tried. 	 */
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * send bar if we dropped any frames 	 * 	 * Keep the txq lock held for now, as we need to ensure 	 * that ni_txseqs[] is consistent (as it's being updated 	 * in the ifnet TX context or raw TX context.) 	 */
if|if
condition|(
name|drops
condition|)
block|{
comment|/* Suspend the TX queue and get ready to send the BAR */
name|ath_tx_tid_bar_suspend
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send BAR if required 	 */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Complete frames which errored out */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle clean-up of packets from an aggregate list.  *  * There's no need to update the BAW here - the session is being  * torn down.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_comp_cleanup_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf_first
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* update incomp */
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
name|atid
operator|->
name|incomp
operator|--
expr_stmt|;
name|bf
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
block|}
if|if
condition|(
name|atid
operator|->
name|incomp
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: TID %d: cleaned up! resume!\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|atid
operator|->
name|cleanup_inprogress
operator|=
literal|0
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
comment|/* Send BAR if required */
comment|/* XXX why would we send a BAR when transitioning to non-aggregation? */
comment|/* 	 * XXX TODO: we should likely just tear down the BAR state here, 	 * rather than sending a BAR. 	 */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle frame completion */
name|bf
operator|=
name|bf_first
expr_stmt|;
while|while
condition|(
name|bf
condition|)
block|{
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle completion of an set of aggregate frames.  *  * Note: the completion handler is the last descriptor in the aggregate,  * not the last descriptor in the first frame.  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_aggr_comp_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf_first
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
comment|//struct ath_desc *ds = bf->bf_lastds;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf_first
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_tx_status
name|ts
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ath_bufhead
name|bf_q
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|int
name|seq_st
decl_stmt|,
name|tx_ok
decl_stmt|;
name|int
name|hasba
decl_stmt|,
name|isaggr
decl_stmt|;
name|uint32_t
name|ba
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|bf_next
decl_stmt|;
name|int
name|ba_index
decl_stmt|;
name|int
name|drops
init|=
literal|0
decl_stmt|;
name|int
name|nframes
init|=
literal|0
decl_stmt|,
name|nbad
init|=
literal|0
decl_stmt|,
name|nf
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
comment|/* XXX there's too much on the stack? */
name|struct
name|ath_rc_series
name|rc
index|[
name|ATH_RC_NUM
index|]
decl_stmt|;
name|int
name|txseq
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: called; hwq_depth=%d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * Take a copy; this may be needed -after- bf_first 	 * has been completed and freed. 	 */
name|ts
operator|=
name|bf_first
operator|->
name|bf_status
operator|.
name|ds_txstat
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
comment|/* The TID state is kept behind the TXQ lock */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|hwq_depth
operator|<
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: hwq_depth< 0: %d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * If the TID is filtered, handle completing the filter 	 * transition before potentially kicking it to the cleanup 	 * function. 	 * 	 * XXX this is duplicate work, ew. 	 */
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 	 * Punt cleanup to the relevant function, not our problem now 	 */
if|if
condition|(
name|atid
operator|->
name|cleanup_inprogress
condition|)
block|{
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: isfiltered=1, normal_comp?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_comp_cleanup_aggr
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the frame is filtered, transition to filtered frame 	 * mode and add this to the filtered frame list. 	 * 	 * XXX TODO: figure out how this interoperates with 	 * BAR, pause and cleanup states. 	 */
if|if
condition|(
operator|(
name|ts
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|||
operator|(
name|ts
operator|.
name|ts_status
operator|!=
literal|0
operator|&&
name|atid
operator|->
name|isfiltered
operator|)
condition|)
block|{
if|if
condition|(
name|fail
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: isfiltered=1, fail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|fail
argument_list|)
expr_stmt|;
name|ath_tx_tid_filt_comp_aggr
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|,
name|bf_first
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
comment|/* Remove from BAW */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|&bf_cq
argument_list|,
argument|bf_list
argument_list|,
argument|bf_next
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|drops
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If any intermediate frames in the BAW were dropped when 		 * handling filtering things, send a BAR. 		 */
if|if
condition|(
name|drops
condition|)
name|ath_tx_tid_bar_suspend
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 		 * Finish up by sending a BAR if required and freeing 		 * the frames outside of the TX lock. 		 */
goto|goto
name|finish_send_bar
goto|;
block|}
comment|/* 	 * XXX for now, use the first frame in the aggregate for 	 * XXX rate control completion; it's at least consistent. 	 */
name|pktlen
operator|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_pktlen
expr_stmt|;
comment|/* 	 * Handle errors first! 	 * 	 * Here, handle _any_ error as a "exceeded retries" error. 	 * Later on (when filtered frames are to be specially handled) 	 * it'll have to be expanded. 	 */
if|#
directive|if
literal|0
block|if (ts.ts_status& HAL_TXERR_XRETRY) {
endif|#
directive|endif
if|if
condition|(
name|ts
operator|.
name|ts_status
operator|!=
literal|0
condition|)
block|{
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_comp_aggr_error
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|,
name|atid
argument_list|)
expr_stmt|;
return|return;
block|}
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 	 * extract starting sequence and block-ack bitmap 	 */
comment|/* XXX endian-ness of seq_st, ba? */
name|seq_st
operator|=
name|ts
operator|.
name|ts_seqnum
expr_stmt|;
name|hasba
operator|=
operator|!
operator|!
operator|(
name|ts
operator|.
name|ts_flags
operator|&
name|HAL_TX_BA
operator|)
expr_stmt|;
name|tx_ok
operator|=
operator|(
name|ts
operator|.
name|ts_status
operator|==
literal|0
operator|)
expr_stmt|;
name|isaggr
operator|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_aggr
expr_stmt|;
name|ba
index|[
literal|0
index|]
operator|=
name|ts
operator|.
name|ts_ba_low
expr_stmt|;
name|ba
index|[
literal|1
index|]
operator|=
name|ts
operator|.
name|ts_ba_high
expr_stmt|;
comment|/* 	 * Copy the TX completion status and the rate control 	 * series from the first descriptor, as it may be freed 	 * before the rate control code can get its grubby fingers 	 * into things. 	 */
name|memcpy
argument_list|(
name|rc
argument_list|,
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
sizeof|sizeof
argument_list|(
name|rc
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: txa_start=%d, tx_ok=%d, status=%.8x, flags=%.8x, "
literal|"isaggr=%d, seq_st=%d, hasba=%d, ba=%.8x, %.8x\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|tx_ok
argument_list|,
name|ts
operator|.
name|ts_status
argument_list|,
name|ts
operator|.
name|ts_flags
argument_list|,
name|isaggr
argument_list|,
name|seq_st
argument_list|,
name|hasba
argument_list|,
name|ba
index|[
literal|0
index|]
argument_list|,
name|ba
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * The reference driver doesn't do this; it simply ignores 	 * this check in its entirety. 	 * 	 * I've seen this occur when using iperf to send traffic 	 * out tid 1 - the aggregate frames are all marked as TID 1, 	 * but the TXSTATUS has TID=0.  So, let's just ignore this 	 * check. 	 */
if|#
directive|if
literal|0
comment|/* Occasionally, the MAC sends a tx status for the wrong TID. */
block|if (tid != ts.ts_tid) { 		DPRINTF(sc, ATH_DEBUG_SW_TX_AGGR, "%s: tid %d != hw tid %d\n", 		    __func__, tid, ts.ts_tid); 		tx_ok = 0; 	}
endif|#
directive|endif
comment|/* AR5416 BA bug; this requires an interface reset */
if|if
condition|(
name|isaggr
operator|&&
name|tx_ok
operator|&&
operator|(
operator|!
name|hasba
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: AR5416 bug: hasba=%d; txok=%d, isaggr=%d, "
literal|"seq_st=%d\n"
argument_list|,
name|__func__
argument_list|,
name|hasba
argument_list|,
name|tx_ok
argument_list|,
name|isaggr
argument_list|,
name|seq_st
argument_list|)
expr_stmt|;
comment|/* XXX TODO: schedule an interface reset */
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|ath_printtxbuf
argument_list|(
name|sc
argument_list|,
name|bf_first
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
operator|->
name|axq_qnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Walk the list of frames, figure out which ones were correctly 	 * sent and which weren't. 	 */
name|bf
operator|=
name|bf_first
expr_stmt|;
name|nf
operator|=
name|bf_first
operator|->
name|bf_state
operator|.
name|bfs_nframes
expr_stmt|;
comment|/* bf_first is going to be invalid once this list is walked */
name|bf_first
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Walk the list of completed frames and determine 	 * which need to be completed and which need to be 	 * retransmitted. 	 * 	 * For completed frames, the completion functions need 	 * to be called at the end of this function as the last 	 * node reference may free the node. 	 * 	 * Finally, since the TXQ lock can't be held during the 	 * completion callback (to avoid lock recursion), 	 * the completion calls have to be done outside of the 	 * lock. 	 */
while|while
condition|(
name|bf
condition|)
block|{
name|nframes
operator|++
expr_stmt|;
name|ba_index
operator|=
name|ATH_BA_INDEX
argument_list|(
name|seq_st
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|bf_next
operator|=
name|bf
operator|->
name|bf_next
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
comment|/* Remove it from the aggr list */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: checking bf=%p seqno=%d; ack=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|,
name|ATH_BA_ISSET
argument_list|(
name|ba
argument_list|,
name|ba_index
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_ok
operator|&&
name|ATH_BA_ISSET
argument_list|(
name|ba
argument_list|,
name|ba_index
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_aggr_ok
operator|++
expr_stmt|;
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_aggr_fail
operator|++
expr_stmt|;
if|if
condition|(
name|ath_tx_retry_subframe
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
operator|&
name|bf_q
argument_list|)
condition|)
block|{
name|drops
operator|++
expr_stmt|;
name|bf
operator|->
name|bf_next
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|nbad
operator|++
expr_stmt|;
block|}
name|bf
operator|=
name|bf_next
expr_stmt|;
block|}
comment|/* 	 * Now that the BAW updates have been done, unlock 	 * 	 * txseq is grabbed before the lock is released so we 	 * have a consistent view of what -was- in the BAW. 	 * Anything after this point will not yet have been 	 * TXed. 	 */
name|txseq
operator|=
name|tap
operator|->
name|txa_start
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nframes
operator|!=
name|nf
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: num frames seen=%d; bf nframes=%d\n"
argument_list|,
name|__func__
argument_list|,
name|nframes
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* 	 * Now we know how many frames were bad, call the rate 	 * control code. 	 */
if|if
condition|(
name|fail
operator|==
literal|0
condition|)
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|rc
argument_list|,
operator|&
name|ts
argument_list|,
name|pktlen
argument_list|,
name|nframes
argument_list|,
name|nbad
argument_list|)
expr_stmt|;
comment|/* 	 * send bar if we dropped any frames 	 */
if|if
condition|(
name|drops
condition|)
block|{
comment|/* Suspend the TX queue and get ready to send the BAR */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_tid_bar_suspend
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: txa_start now %d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepend all frames to the beginning of the queue */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bf_q
argument_list|,
name|ath_bufhead_s
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_q
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TID_INSERT_HEAD
argument_list|(
name|atid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reschedule to grab some further frames. 	 */
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 	 * If the queue is filtered, re-schedule as required. 	 * 	 * This is required as there may be a subsequent TX descriptor 	 * for this end-node that has CLRDMASK set, so it's quite possible 	 * that a filtered frame will be followed by a non-filtered 	 * (complete or otherwise) frame. 	 * 	 * XXX should we do this before we complete the frame? 	 */
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|finish_send_bar
label|:
comment|/* 	 * Send BAR if required 	 */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Do deferred completion */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle completion of unaggregated frames in an ADDBA  * session.  *  * Fail is set to 1 if the entry is being freed via a call to  * ath_tx_draintxq().  */
end_comment

begin_function
specifier|static
name|void
name|ath_tx_aggr_comp_unaggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|bf
operator|->
name|bf_node
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|int
name|tid
init|=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|struct
name|ath_tx_status
name|ts
decl_stmt|;
name|int
name|drops
init|=
literal|0
decl_stmt|;
comment|/* 	 * Take a copy of this; filtering/cloning the frame may free the 	 * bf pointer. 	 */
name|ts
operator|=
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
expr_stmt|;
comment|/* 	 * Update rate control status here, before we possibly 	 * punt to retry or cleanup. 	 * 	 * Do it outside of the TXQ lock. 	 */
if|if
condition|(
name|fail
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|)
condition|)
name|ath_tx_update_ratectrl
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
argument_list|,
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_txstat
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_pktlen
argument_list|,
literal|1
argument_list|,
operator|(
name|ts
operator|.
name|ts_status
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * This is called early so atid->hwq_depth can be tracked. 	 * This unfortunately means that it's released and regrabbed 	 * during retry and cleanup. That's rather inefficient. 	 */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: TID=16!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bf=%p: tid=%d, hwq_depth=%d, seqno=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
name|atid
operator|->
name|hwq_depth
operator|--
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|hwq_depth
operator|<
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: hwq_depth< 0: %d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|hwq_depth
argument_list|)
expr_stmt|;
comment|/* 	 * If the TID is filtered, handle completing the filter 	 * transition before potentially kicking it to the cleanup 	 * function. 	 */
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 	 * If a cleanup is in progress, punt to comp_cleanup; 	 * rather than handling it here. It's thus their 	 * responsibility to clean up, call the completion 	 * function in net80211, etc. 	 */
if|if
condition|(
name|atid
operator|->
name|cleanup_inprogress
condition|)
block|{
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: isfiltered=1, normal_comp?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: cleanup_unaggr\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_tx_comp_cleanup_unaggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX TODO: how does cleanup, BAR and filtered frame handling 	 * overlap? 	 * 	 * If the frame is filtered OR if it's any failure but 	 * the TID is filtered, the frame must be added to the 	 * filtered frame list. 	 * 	 * However - a busy buffer can't be added to the filtered 	 * list as it will end up being recycled without having 	 * been made available for the hardware. 	 */
if|if
condition|(
operator|(
name|ts
operator|.
name|ts_status
operator|&
name|HAL_TXERR_FILT
operator|)
operator|||
operator|(
name|ts
operator|.
name|ts_status
operator|!=
literal|0
operator|&&
name|atid
operator|->
name|isfiltered
operator|)
condition|)
block|{
name|int
name|freeframe
decl_stmt|;
if|if
condition|(
name|fail
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: isfiltered=1, fail=%d\n"
argument_list|,
name|__func__
argument_list|,
name|fail
argument_list|)
expr_stmt|;
name|freeframe
operator|=
name|ath_tx_tid_filt_comp_single
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeframe
condition|)
block|{
comment|/* Remove from BAW */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|drops
operator|++
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If the frame couldn't be filtered, treat it as a drop and 		 * prepare to send a BAR. 		 */
if|if
condition|(
name|freeframe
operator|&&
name|drops
condition|)
name|ath_tx_tid_bar_suspend
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 		 * Send BAR if required 		 */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * If freeframe is set, then the frame couldn't be 		 * cloned and bf is still valid.  Just complete/free it. 		 */
if|if
condition|(
name|freeframe
condition|)
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Don't bother with the retry check if all frames 	 * are being failed (eg during queue deletion.) 	 */
if|#
directive|if
literal|0
block|if (fail == 0&& ts->ts_status& HAL_TXERR_XRETRY) {
endif|#
directive|endif
if|if
condition|(
name|fail
operator|==
literal|0
operator|&&
name|ts
operator|.
name|ts_status
operator|!=
literal|0
condition|)
block|{
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: retry_unaggr\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ath_tx_aggr_retry_unaggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success? Complete */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: TID=%d, seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|ath_tx_update_baw
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|atid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_addedbaw
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: wasn't added: seqno %d\n"
argument_list|,
name|__func__
argument_list|,
name|SEQNO
argument_list|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_seqno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the queue is filtered, re-schedule as required. 	 * 	 * This is required as there may be a subsequent TX descriptor 	 * for this end-node that has CLRDMASK set, so it's quite possible 	 * that a filtered frame will be followed by a non-filtered 	 * (complete or otherwise) frame. 	 * 	 * XXX should we do this before we complete the frame? 	 */
if|if
condition|(
name|atid
operator|->
name|isfiltered
condition|)
name|ath_tx_tid_filt_comp_complete
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
comment|/* 	 * Send BAR if required 	 */
if|if
condition|(
name|ath_tx_tid_bar_tx_ready
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
condition|)
name|ath_tx_tid_bar_tx
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
comment|/* bf is freed at this point */
block|}
end_function

begin_function
name|void
name|ath_tx_aggr_comp
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|int
name|fail
parameter_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
condition|)
name|ath_tx_aggr_comp_aggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
else|else
name|ath_tx_aggr_comp_unaggr
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|fail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Schedule some packets from the given node/TID to the hardware.  *  * This is the aggregate version.  */
end_comment

begin_function
name|void
name|ath_tx_tid_hw_queue_aggr
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|ATH_AGGR_STATUS
name|status
decl_stmt|;
name|ath_bufhead
name|bf_q
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: If we're called for a queue that we're leaking frames to, 	 * ensure we only leak one. 	 */
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: called for TID=NONQOS_TID?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|ATH_AGGR_DONE
expr_stmt|;
comment|/* 		 * If the upper layer has paused the TID, don't 		 * queue any further packets. 		 * 		 * This can also occur from the completion task because 		 * of packet loss; but as its serialised with this code, 		 * it won't "appear" half way through queuing packets. 		 */
if|if
condition|(
operator|!
name|ath_tx_tid_can_tx_or_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
condition|)
break|break;
name|bf
operator|=
name|ATH_TID_FIRST
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 		 * If the packet doesn't fall within the BAW (eg a NULL 		 * data frame), schedule it directly; continue. 		 */
if|if
condition|(
operator|!
name|bf
operator|->
name|bf_state
operator|.
name|bfs_dobaw
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: non-baw packet\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_TID_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|>
literal|1
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: aggr=%d, nframes=%d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|)
expr_stmt|;
comment|/* 			 * This shouldn't happen - such frames shouldn't 			 * ever have been queued as an aggregate in the 			 * first place.  However, make sure the fields 			 * are correctly setup just to be totally sure. 			 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|=
literal|1
expr_stmt|;
comment|/* Update CLRDMASK just before this frame is queued */
name|ath_tx_update_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_duration
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_protection
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_nonbaw_pkt
operator|++
expr_stmt|;
comment|/* Queue the packet; continue */
goto|goto
name|queuepkt
goto|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
comment|/* 		 * Do a rate control lookup on the first frame in the 		 * list. The rate control code needs that to occur 		 * before it can determine whether to TX. 		 * It's inaccurate because the rate control code doesn't 		 * really "do" aggregate lookups, so it only considers 		 * the size of the first frame. 		 */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|rix
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_rc
index|[
literal|3
index|]
operator|.
name|tries
operator|=
literal|0
expr_stmt|;
name|ath_tx_calc_duration
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_protection
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|status
operator|=
name|ath_tx_form_aggr
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
operator|&
name|bf_q
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: ath_tx_form_aggr() status=%d\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* 		 * No frames to be picked up - out of BAW 		 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|bf_q
argument_list|)
condition|)
break|break;
comment|/* 		 * This assumes that the descriptor list in the ath_bufhead 		 * are already linked together via bf_next pointers. 		 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ATH_AGGR_8K_LIMITED
condition|)
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_rts_aggr_limited
operator|++
expr_stmt|;
comment|/* 		 * If it's the only frame send as non-aggregate 		 * assume that ath_tx_form_aggr() has checked 		 * whether it's in the BAW and added it appropriately. 		 */
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
operator|==
literal|1
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: single-frame aggregate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Update CLRDMASK just before this frame is queued */
name|ath_tx_update_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_ndelim
operator|=
literal|0
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_hal_clr11n_aggr
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ATH_AGGR_BAW_CLOSED
condition|)
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_baw_closed_single_pkt
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_single_pkt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_AGGR
argument_list|,
literal|"%s: multi-frame aggregate: %d frames, "
literal|"length %d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_al
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_state
operator|.
name|bfs_aggr
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_pkts
index|[
name|bf
operator|->
name|bf_state
operator|.
name|bfs_nframes
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_aggr_pkt
operator|++
expr_stmt|;
comment|/* Update CLRDMASK just before this frame is queued */
name|ath_tx_update_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate the duration/protection as required. 			 */
name|ath_tx_calc_duration
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_protection
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 			 * Update the rate and rtscts information based on the 			 * rate decision made by the rate control code; 			 * the first frame in the aggregate needs it. 			 */
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 			 * Setup the relevant descriptor fields 			 * for aggregation. The first descriptor 			 * already points to the rest in the chain. 			 */
name|ath_tx_setds_11n
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
name|queuepkt
label|:
comment|/* Set completion handler, multi-frame aggregate or not */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_aggr_comp
expr_stmt|;
if|if
condition|(
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: TID=16?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * Update leak count and frame config if were leaking frames. 		 * 		 * XXX TODO: it should update all frames in an aggregate 		 * correctly! 		 */
name|ath_tx_leak_count_update
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Punt to txq */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Track outstanding buffer count to hardware */
comment|/* aggregates are "one" buffer */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* 		 * Break out if ath_tx_form_aggr() indicated 		 * there can't be any further progress (eg BAW is full.) 		 * Checking for an empty txq is done above. 		 * 		 * XXX locking on txq here? 		 */
comment|/* XXX TXQ locking */
if|if
condition|(
name|txq
operator|->
name|axq_aggr_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit_aggr
operator|||
operator|(
name|status
operator|==
name|ATH_AGGR_BAW_CLOSED
operator|||
name|status
operator|==
name|ATH_AGGR_LEAK_CLOSED
operator|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule some packets from the given node/TID to the hardware.  *  * XXX TODO: this routine doesn't enforce the maximum TXQ depth.  * It just dumps frames into the TXQ.  We should limit how deep  * the transmit queue can grow for frames dispatched to the given  * TXQ.  *  * To avoid locking issues, either we need to own the TXQ lock  * at this point, or we need to pass in the maximum frame count  * from the caller.  */
end_comment

begin_function
name|void
name|ath_tx_tid_hw_queue_norm
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|struct
name|ath_tid
modifier|*
name|tid
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
init|=
name|sc
operator|->
name|sc_ac2q
index|[
name|tid
operator|->
name|ac
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: node %p: TID %d: called\n"
argument_list|,
name|__func__
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check - is AMPDU pending or running? then print out something */
if|if
condition|(
name|ath_tx_ampdu_pending
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d, ampdu pending?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d, ampdu running?\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If the upper layers have paused the TID, don't 		 * queue any further packets. 		 * 		 * XXX if we are leaking frames, make sure we decrement 		 * that counter _and_ we continue here. 		 */
if|if
condition|(
operator|!
name|ath_tx_tid_can_tx_or_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
condition|)
break|break;
name|bf
operator|=
name|ATH_TID_FIRST
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|ATH_TID_REMOVE
argument_list|(
name|tid
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
comment|/* Sanity check! */
if|if
condition|(
name|tid
operator|->
name|tid
operator|!=
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: bfs_tid %d !="
literal|" tid %d\n"
argument_list|,
name|__func__
argument_list|,
name|bf
operator|->
name|bf_state
operator|.
name|bfs_tid
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
comment|/* Normal completion handler */
name|bf
operator|->
name|bf_comp
operator|=
name|ath_tx_normal_comp
expr_stmt|;
comment|/* 		 * Override this for now, until the non-aggregate 		 * completion handler correctly handles software retransmits. 		 */
name|bf
operator|->
name|bf_state
operator|.
name|bfs_txflags
operator||=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* Update CLRDMASK just before this frame is queued */
name|ath_tx_update_clrdmask
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Program descriptors + rate control */
name|ath_tx_do_ratelookup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_duration
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_calc_protection
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_set_rtscts
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_rate_fill_rcflags
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
name|ath_tx_setds
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 		 * Update the current leak count if 		 * we're leaking frames; and set the 		 * MORE flag as appropriate. 		 */
name|ath_tx_leak_count_update
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* Track outstanding buffer count to hardware */
comment|/* aggregates are "one" buffer */
name|tid
operator|->
name|hwq_depth
operator|++
expr_stmt|;
comment|/* Punt to hardware or software txq */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule some packets to the given hardware queue.  *  * This function walks the list of TIDs (ie, ath_node TIDs  * with queued traffic) and attempts to schedule traffic  * from them.  *  * TID scheduling is implemented as a FIFO, with TIDs being  * added to the end of the queue after some frames have been  * scheduled.  */
end_comment

begin_function
name|void
name|ath_txq_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Don't schedule if the hardware queue is busy. 	 * This (hopefully) gives some more time to aggregate 	 * some packets in the aggregation queue. 	 * 	 * XXX It doesn't stop a parallel sender from sneaking 	 * in transmitting a frame! 	 */
comment|/* XXX TXQ locking */
if|if
condition|(
name|txq
operator|->
name|axq_aggr_depth
operator|+
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit_aggr
condition|)
block|{
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_sched_nopkt
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit_nonaggr
condition|)
block|{
name|sc
operator|->
name|sc_aggr_stats
operator|.
name|aggr_sched_nopkt
operator|++
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|txq
operator|->
name|axq_tidq
argument_list|,
name|axq_t_s
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tid
argument_list|,
argument|&txq->axq_tidq
argument_list|,
argument|axq_qelem
argument_list|,
argument|next
argument_list|)
block|{
comment|/* 		 * Suspend paused queues here; they'll be resumed 		 * once the addba completes or times out. 		 */
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX
argument_list|,
literal|"%s: tid=%d, paused=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tid
operator|->
name|tid
argument_list|,
name|tid
operator|->
name|paused
argument_list|)
expr_stmt|;
name|ath_tx_tid_unsched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 		 * This node may be in power-save and we're leaking 		 * a frame; be careful. 		 */
if|if
condition|(
operator|!
name|ath_tx_tid_can_tx_or_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ath_tx_ampdu_running
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
operator|->
name|tid
argument_list|)
condition|)
name|ath_tx_tid_hw_queue_aggr
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
name|ath_tx_tid_hw_queue_norm
argument_list|(
name|sc
argument_list|,
name|tid
operator|->
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* Not empty? Re-schedule */
if|if
condition|(
name|tid
operator|->
name|axq_depth
operator|!=
literal|0
condition|)
name|ath_tx_tid_sched
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
comment|/* 		 * Give the software queue time to aggregate more 		 * packets.  If we aren't running aggregation then 		 * we should still limit the hardware queue depth. 		 */
comment|/* XXX TXQ locking */
if|if
condition|(
name|txq
operator|->
name|axq_aggr_depth
operator|+
name|txq
operator|->
name|fifo
operator|.
name|axq_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit_aggr
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|txq
operator|->
name|axq_depth
operator|>=
name|sc
operator|->
name|sc_hwq_limit_nonaggr
condition|)
block|{
break|break;
block|}
comment|/* 		 * If this was the last entry on the original list, stop. 		 * Otherwise nodes that have been rescheduled onto the end 		 * of the TID FIFO list will just keep being rescheduled. 		 * 		 * XXX What should we do about nodes that were paused 		 * but are pending a leaking frame in response to a ps-poll? 		 * They'll be put at the front of the list; so they'll 		 * prematurely trigger this condition! Ew. 		 */
if|if
condition|(
name|tid
operator|==
name|last
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * TX addba handling  */
end_comment

begin_comment
comment|/*  * Return net80211 TID struct pointer, or NULL for none  */
end_comment

begin_function
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|ath_tx_get_tx_tid
parameter_list|(
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|&
name|an
operator|->
name|an_node
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
return|return
name|NULL
return|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
return|return
name|tap
return|;
block|}
end_function

begin_comment
comment|/*  * Is AMPDU-TX running?  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_ampdu_running
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
return|return
literal|0
return|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Not valid; default to not running */
return|return
operator|!
operator|!
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is AMPDU-TX negotiation pending?  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_ampdu_pending
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|==
name|IEEE80211_NONQOS_TID
condition|)
return|return
literal|0
return|;
name|tap
operator|=
name|ath_tx_get_tx_tid
argument_list|(
name|an
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Not valid; default to not pending */
return|return
operator|!
operator|!
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is AMPDU-TX pending for the given TID?  */
end_comment

begin_comment
comment|/*  * Method to handle sending an ADDBA request.  *  * We tap this so the relevant flags can be set to pause the TID  * whilst waiting for the response.  *  * XXX there's no timeout handler we can override?  */
end_comment

begin_function
name|int
name|ath_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
comment|/* 	 * XXX danger Will Robinson! 	 * 	 * Although the taskqueue may be running and scheduling some more 	 * packets, these should all be _before_ the addba sequence number. 	 * However, net80211 will keep self-assigning sequence numbers 	 * until addba has been negotiated. 	 * 	 * In the past, these packets would be "paused" (which still works 	 * fine, as they're being scheduled to the driver in the same 	 * serialised method which is calling the addba request routine) 	 * and when the aggregation session begins, they'll be dequeued 	 * as aggregate packets and added to the BAW. However, now there's 	 * a "bf->bf_state.bfs_dobaw" flag, and this isn't set for these 	 * packets. Thus they never get included in the BAW tracking and 	 * this can cause the initial burst of packets after the addba 	 * negotiation to "hang", as they quickly fall outside the BAW. 	 * 	 * The "eventual" solution should be to tag these packets with 	 * dobaw. Although net80211 has given us a sequence number, 	 * it'll be "after" the left edge of the BAW and thus it'll 	 * fall within it. 	 */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * This is a bit annoying.  Until net80211 HT code inherits some 	 * (any) locking, we may have this called in parallel BUT only 	 * one response/timeout will be called.  Grr. 	 */
if|if
condition|(
name|atid
operator|->
name|addba_tx_pending
operator|==
literal|0
condition|)
block|{
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|atid
operator|->
name|addba_tx_pending
operator|=
literal|1
expr_stmt|;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: %6D: called; dialogtoken=%d, baparamset=%d, batimeout=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: txa_start=%d, ni_txseqs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
argument_list|)
expr_stmt|;
return|return
name|sc
operator|->
name|sc_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an ADDBA response.  *  * We unpause the queue so TX'ing can resume.  *  * Any packets TX'ed from this point should be "aggregate" (whether  * aggregate or not) so the BAW is updated.  *  * Note! net80211 keeps self-assigning sequence numbers until  * ampdu is negotiated. This means the initially-negotiated BAW left  * edge won't match the ni->ni_txseq.  *  * So, being very dirty, the BAW left edge is "slid" here to match  * ni->ni_txseq.  *  * What likely SHOULD happen is that all packets subsequent to the  * addba request should be tagged as aggregate and queued as non-aggregate  * frames; thus updating the BAW. For now though, I'll just slide the  * window.  */
end_comment

begin_function
name|int
name|ath_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: %6D: called; status=%d, code=%d, batimeout=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|status
argument_list|,
name|code
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: txa_start=%d, ni_txseqs=%d\n"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Call this first, so the interface flags get updated 	 * before the TID is unpaused. Otherwise a race condition 	 * exists where the unpaused TID still doesn't yet have 	 * IEEE80211_AGGR_RUNNING set. 	 */
name|r
operator|=
name|sc
operator|->
name|sc_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|status
argument_list|,
name|code
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atid
operator|->
name|addba_tx_pending
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX dirty! 	 * Slide the BAW left edge to wherever net80211 left it for us. 	 * Read above for more information. 	 */
name|tap
operator|->
name|txa_start
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Stop ADDBA on a queue.  *  * This can be called whilst BAR TX is currently active on the queue,  * so make sure this is unblocked before continuing.  */
end_comment

begin_function
name|void
name|ath_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: %6D: called\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* 	 * Pause TID traffic early, so there aren't any races 	 * Unblock the pending BAR held traffic, if it's currently paused. 	 */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|bar_wait
condition|)
block|{
comment|/* 		 * bar_unsuspend() expects bar_tx == 1, as it should be 		 * called from the TX completion path.  This quietens 		 * the warning.  It's cleared for us anyway. 		 */
name|atid
operator|->
name|bar_tx
operator|=
literal|1
expr_stmt|;
name|ath_tx_tid_bar_unsuspend
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* There's no need to hold the TXQ lock here */
name|sc
operator|->
name|sc_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
comment|/* 	 * ath_tx_tid_cleanup will resume the TID if possible, otherwise 	 * it'll set the cleanup flag, and it'll be unpaused once 	 * things have been cleaned up. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_tid_cleanup
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|tid
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
comment|/* 	 * Unpause the TID if no cleanup is required. 	 */
if|if
condition|(
operator|!
name|atid
operator|->
name|cleanup_inprogress
condition|)
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle completing frames and fail them */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle a node reassociation.  *  * We may have a bunch of frames queued to the hardware; those need  * to be marked as cleanup.  */
end_comment

begin_function
name|void
name|ath_tx_node_reassoc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|tid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ath_bufhead
name|bf_cq
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|tid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tid
operator|->
name|hwq_depth
operator|==
literal|0
condition|)
continue|continue;
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_NODE
argument_list|,
literal|"%s: %6D: TID %d: cleaning up TID\n"
argument_list|,
name|__func__
argument_list|,
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ath_tx_tid_cleanup
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|i
argument_list|,
operator|&
name|bf_cq
argument_list|)
expr_stmt|;
comment|/* 		 * Unpause the TID if no cleanup is required. 		 */
if|if
condition|(
operator|!
name|tid
operator|->
name|cleanup_inprogress
condition|)
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle completing frames and fail them */
while|while
condition|(
operator|(
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bf_cq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bf_cq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ath_tx_default_comp
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Note: net80211 bar_timeout() doesn't call this function on BAR failure;  * it simply tears down the aggregation session. Ew.  *  * It however will call ieee80211_ampdu_stop() which will call  * ic->ic_addba_stop().  *  * XXX This uses a hard-coded max BAR count value; the whole  * XXX BAR TX success or failure should be better handled!  */
end_comment

begin_function
name|void
name|ath_bar_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|int
name|attempts
init|=
name|tap
operator|->
name|txa_attempts
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: %6D: called; txa_tid=%d, atid->tid=%d, status=%d, attempts=%d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|atid
operator|->
name|tid
argument_list|,
name|status
argument_list|,
name|attempts
argument_list|)
expr_stmt|;
comment|/* Note: This may update the BAW details */
name|sc
operator|->
name|sc_bar_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* Unpause the TID */
comment|/* 	 * XXX if this is attempt=50, the TID will be downgraded 	 * XXX to a non-aggregate session. So we must unpause the 	 * XXX TID here or it'll never be done. 	 * 	 * Also, don't call it if bar_tx/bar_wait are 0; something 	 * has beaten us to the punch? (XXX figure out what?) 	 */
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|attempts
operator|==
literal|50
condition|)
block|{
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|atid
operator|->
name|bar_tx
operator|==
literal|0
operator|||
name|atid
operator|->
name|bar_wait
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_BAR
argument_list|,
literal|"%s: huh? bar_tx=%d, bar_wait=%d\n"
argument_list|,
name|__func__
argument_list|,
name|atid
operator|->
name|bar_tx
argument_list|,
name|atid
operator|->
name|bar_wait
argument_list|)
expr_stmt|;
else|else
name|ath_tx_tid_bar_unsuspend
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called whenever the pending ADDBA request times out.  * Unpause and reschedule the TID.  */
end_comment

begin_function
name|void
name|ath_addba_response_timeout
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|tid
init|=
name|tap
operator|->
name|txa_tid
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
init|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
decl_stmt|;
name|struct
name|ath_tid
modifier|*
name|atid
init|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_SW_TX_CTRL
argument_list|,
literal|"%s: %6D: TID=%d, called; resuming\n"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|":"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atid
operator|->
name|addba_tx_pending
operator|=
literal|0
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Note: This updates the aggregate state to (again) pending */
name|sc
operator|->
name|sc_addba_response_timeout
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
comment|/* Unpause the TID; which reschedules it */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if a node is asleep or not.  */
end_comment

begin_function
name|int
name|ath_tx_node_is_asleep
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|ATH_TX_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|an
operator|->
name|an_is_powersave
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark a node as currently "in powersaving."  * This suspends all traffic on the node.  *  * This must be called with the node/tx locks free.  *  * XXX TODO: the locking silliness below is due to how the node  * locking currently works.  Right now, the node lock is grabbed  * to do rate control lookups and these are done with the TX  * queue lock held.  This means the node lock can't be grabbed  * first here or a LOR will occur.  *  * Eventually (hopefully!) the TX path code will only grab  * the TXQ lock when transmitting and the ath_node lock when  * doing node/TID operations.  There are other complications -  * the sched/unsched operations involve walking the per-txq  * 'active tid' list and this requires both locks to be held.  */
end_comment

begin_function
name|void
name|ath_tx_node_sleep
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|ATH_TX_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Suspend all traffic on the node */
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|an
operator|->
name|an_is_powersave
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %6D: node was already asleep!\n"
argument_list|,
name|__func__
argument_list|,
name|an
operator|->
name|an_node
operator|.
name|ni_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|tid
operator|++
control|)
block|{
name|atid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
expr_stmt|;
name|ath_tx_tid_pause
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
comment|/* Mark node as in powersaving */
name|an
operator|->
name|an_is_powersave
operator|=
literal|1
expr_stmt|;
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark a node as currently "awake."  * This resumes all traffic to the node.  */
end_comment

begin_function
name|void
name|ath_tx_node_wakeup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_node
modifier|*
name|an
parameter_list|)
block|{
name|struct
name|ath_tid
modifier|*
name|atid
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|ATH_TX_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_TX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* !? */
if|if
condition|(
name|an
operator|->
name|an_is_powersave
operator|==
literal|0
condition|)
block|{
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: an=%p: node was already awake\n"
argument_list|,
name|__func__
argument_list|,
name|an
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mark node as awake */
name|an
operator|->
name|an_is_powersave
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Clear any pending leaked frame requests 	 */
name|an
operator|->
name|an_leak_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|IEEE80211_TID_SIZE
condition|;
name|tid
operator|++
control|)
block|{
name|atid
operator|=
operator|&
name|an
operator|->
name|an_tid
index|[
name|tid
index|]
expr_stmt|;
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|atid
operator|->
name|ac
index|]
expr_stmt|;
name|ath_tx_tid_resume
argument_list|(
name|sc
argument_list|,
name|atid
argument_list|)
expr_stmt|;
block|}
name|ATH_TX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_legacy_dma_txsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* nothing new needed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_legacy_dma_txteardown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* nothing new needed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ath_xmit_setup_legacy
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * For now, just set the descriptor length to sizeof(ath_desc); 	 * worry about extracting the real length out of the HAL later. 	 */
name|sc
operator|->
name|sc_tx_desclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_statuslen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_nmaps
operator|=
literal|1
expr_stmt|;
comment|/* only one buffer per TX desc */
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_setup
operator|=
name|ath_legacy_dma_txsetup
expr_stmt|;
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_teardown
operator|=
name|ath_legacy_dma_txteardown
expr_stmt|;
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_attach_comp_func
operator|=
name|ath_legacy_attach_comp_func
expr_stmt|;
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_dma_restart
operator|=
name|ath_legacy_tx_dma_restart
expr_stmt|;
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_handoff
operator|=
name|ath_legacy_xmit_handoff
expr_stmt|;
name|sc
operator|->
name|sc_tx
operator|.
name|xmit_drain
operator|=
name|ath_legacy_tx_drain
expr_stmt|;
block|}
end_function

end_unit

