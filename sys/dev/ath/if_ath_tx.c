begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx_ht.h>
end_include

begin_comment
comment|/*  * Whether to use the 11n rate scenario functions or not  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ath_tx_is_11n
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|sc_ah
operator|->
name|ah_magic
operator|==
literal|0x20065416
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ath_txfrag_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ATH_TXBUF_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|bf
argument_list|,
argument|frags
argument_list|,
argument|bf_list
argument_list|,
argument|next
argument_list|)
block|{
comment|/* NB: bf assumed clean */
name|STAILQ_REMOVE_HEAD
argument_list|(
name|frags
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup xmit of a fragmented frame.  Allocate a buffer  * for each frag and bump the node reference count to  * reflect the held reference to be setup by ath_tx_start.  */
end_comment

begin_function
name|int
name|ath_txfrag_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|ath_bufhead
modifier|*
name|frags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
name|bf
operator|=
name|_ath_getbuf_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* out of buffers, cleanup */
name|ath_txfrag_cleanup
argument_list|(
name|sc
argument_list|,
name|frags
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|ieee80211_node_incref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|frags
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|!
name|STAILQ_EMPTY
argument_list|(
name|frags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim mbuf resources.  For fragmented frames we  * need to claim each frag chained with m_nextpkt.  */
end_comment

begin_function
name|void
name|ath_freetx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_dmasetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
comment|/* XXX packet requires too many descriptors */
name|bf
operator|->
name|bf_nseg
operator|=
name|ATH_TXDESC
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Discard null packets and check for packets that 	 * require too many TX descriptors.  We try to convert 	 * the latter to a cluster. 	 */
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|>
name|ATH_TXDESC
condition|)
block|{
comment|/* too many desc's, linearize */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_linear
operator|++
expr_stmt|;
name|m
operator|=
name|m_collapse
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|ATH_TXDESC
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m0
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_busdma
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|<=
name|ATH_TXDESC
argument_list|,
operator|(
literal|"too many segments after defrag; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|0
condition|)
block|{
comment|/* null packet, discard */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nodata
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: m %p len %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_chaindesclist
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|,
modifier|*
name|ds0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Fillin the remainder of the descriptor info. 	 */
name|ds0
operator|=
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bf
operator|->
name|bf_nseg
condition|;
name|i
operator|++
operator|,
name|ds
operator|++
control|)
block|{
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
condition|)
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
else|else
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|ath_hal_filltxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_segs
index|[
name|i
index|]
operator|.
name|ds_len
comment|/* segment length */
argument_list|,
name|i
operator|==
literal|0
comment|/* first segment */
argument_list|,
name|i
operator|==
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
comment|/* last segment */
argument_list|,
name|ds0
comment|/* first descriptor */
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: %d: %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|,
name|ds
operator|->
name|ds_data
argument_list|,
name|ds
operator|->
name|ds_ctl0
argument_list|,
name|ds
operator|->
name|ds_ctl1
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|0
index|]
argument_list|,
name|ds
operator|->
name|ds_hw
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ath_tx_handoff
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
comment|/* Fill in the details in the descriptor list */
name|ath_tx_chaindesclist
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
comment|/* 	 * Insert the frame on the outbound list and pass it on 	 * to the hardware.  Multicast frames buffered for power 	 * save stations and transmit from the CAB queue are stored 	 * on a s/w only queue and loaded on to the CAB queue in 	 * the SWBA handler since frames only go out on DTIM and 	 * to avoid possible races. 	 */
name|ATH_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bf
operator|->
name|bf_flags
operator|&
name|ATH_BUF_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"busy status 0x%x"
operator|,
name|bf
operator|->
name|bf_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_qnum
operator|!=
name|ATH_TXQ_SWQ
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|int
name|qbusy
decl_stmt|;
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|qbusy
operator|=
name|ath_hal_txqenabled
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Be careful writing the address to TXDP.  If 			 * the tx q is enabled then this write will be 			 * ignored.  Normally this is not an issue but 			 * when tdma is in use and the q is beacon gated 			 * this race can occur.  If the q is busy then 			 * defer the work to later--either when another 			 * packet comes along or when we prepare a beacon 			 * frame at SWBA. 			 */
if|if
condition|(
operator|!
name|qbusy
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|->
name|axq_flags
operator||=
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
operator||
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: Q%u busy, defer enable\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txq
operator|->
name|axq_flags
operator|&
name|ATH_TXQ_PUTPENDING
operator|)
operator|&&
operator|!
name|qbusy
condition|)
block|{
comment|/* 				 * The q was busy when we previously tried 				 * to write the address of the first buffer 				 * in the chain.  Since it's not busy now 				 * handle this chore.  We are certain the 				 * buffer at the front is the right one since 				 * axq_link is NULL only when the buffer list 				 * is/was empty. 				 */
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|STAILQ_FIRST
argument_list|(
operator|&
name|txq
operator|->
name|axq_q
argument_list|)
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_flags
operator|&=
operator|~
name|ATH_TXQ_PUTPENDING
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
operator||
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: Q%u restarted\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|==
name|NULL
condition|)
block|{
name|ath_hal_puttxbuf
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: TXDP[%u] = %p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: link[%u](%p)=%p (%p) depth %d\n"
argument_list|,
name|__func__
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|,
name|txq
operator|->
name|axq_link
argument_list|,
operator|(
name|caddr_t
operator|)
name|bf
operator|->
name|bf_daddr
argument_list|,
name|bf
operator|->
name|bf_desc
argument_list|,
name|txq
operator|->
name|axq_depth
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_TDMA */
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
name|ath_hal_txstart
argument_list|(
name|ah
argument_list|,
name|txq
operator|->
name|axq_qnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|txq
operator|->
name|axq_link
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|last
init|=
name|ATH_TXQ_LAST
argument_list|(
name|txq
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
comment|/* mark previous frame */
name|wh
operator|=
name|mtod
argument_list|(
name|last
operator|->
name|bf_m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|last
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* link descriptor */
operator|*
name|txq
operator|->
name|axq_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
block|}
name|ATH_TXQ_INSERT_TAIL
argument_list|(
name|txq
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|txq
operator|->
name|axq_link
operator|=
operator|&
name|bf
operator|->
name|bf_desc
index|[
name|bf
operator|->
name|bf_nseg
operator|-
literal|1
index|]
operator|.
name|ds_link
expr_stmt|;
block|}
name|ATH_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_tag_crypto
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|iswep
parameter_list|,
name|int
name|isfrag
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|,
name|int
modifier|*
name|pktlen
parameter_list|,
name|int
modifier|*
name|keyix
parameter_list|)
block|{
if|if
condition|(
name|iswep
condition|)
block|{
specifier|const
name|struct
name|ieee80211_cipher
modifier|*
name|cip
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|k
decl_stmt|;
comment|/* 		 * Construct the 802.11 header+trailer for an encrypted 		 * frame. The only reason this can fail is because of an 		 * unknown or unsupported cipher/key type. 		 */
name|k
operator|=
name|ieee80211_crypto_encap
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This can happen when the key is yanked after the 			 * frame was queued.  Just discard the frame; the 			 * 802.11 layer counts failures and provides 			 * debugging/diagnostics. 			 */
return|return
literal|0
return|;
block|}
comment|/* 		 * Adjust the packet + header lengths for the crypto 		 * additions and calculate the h/w key index.  When 		 * a s/w mic is done the frame will have had any mic 		 * added to it prior to entry so m0->m_pkthdr.len will 		 * account for it. Otherwise we need to add it to the 		 * packet length. 		 */
name|cip
operator|=
name|k
operator|->
name|wk_cipher
expr_stmt|;
operator|(
operator|*
name|hdrlen
operator|)
operator|+=
name|cip
operator|->
name|ic_header
expr_stmt|;
operator|(
operator|*
name|pktlen
operator|)
operator|+=
name|cip
operator|->
name|ic_header
operator|+
name|cip
operator|->
name|ic_trailer
expr_stmt|;
comment|/* NB: frags always have any TKIP MIC done in s/w */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|isfrag
condition|)
operator|(
operator|*
name|pktlen
operator|)
operator|+=
name|cip
operator|->
name|ic_miclen
expr_stmt|;
operator|(
operator|*
name|keyix
operator|)
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_cipher
operator|==
operator|&
name|ieee80211_cipher_none
condition|)
block|{
comment|/* 		 * Use station key cache slot, if assigned. 		 */
operator|(
operator|*
name|keyix
operator|)
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|keyix
operator|)
operator|==
name|IEEE80211_KEYIX_NONE
condition|)
operator|(
operator|*
name|keyix
operator|)
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|keyix
operator|)
operator|=
name|HAL_TXKEYIX_INVALID
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ath_tx_get_rtscts_rate
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|rix
parameter_list|,
name|int
name|cix
parameter_list|,
name|int
name|shortPreamble
parameter_list|)
block|{
name|uint8_t
name|ctsrate
decl_stmt|;
comment|/* 	 * CTS transmit rate is derived from the transmit rate 	 * by looking in the h/w rate table.  We must also factor 	 * in whether or not a short preamble is to be used. 	 */
comment|/* NB: cix is set above where RTS/CTS is enabled */
name|KASSERT
argument_list|(
name|cix
operator|!=
literal|0xff
argument_list|,
operator|(
literal|"cix not setup"
operator|)
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
expr_stmt|;
comment|/* XXX this should only matter for legacy rates */
if|if
condition|(
name|shortPreamble
condition|)
name|ctsrate
operator||=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|shortPreamble
expr_stmt|;
return|return
name|ctsrate
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the RTS/CTS duration for legacy frames.  */
end_comment

begin_function
specifier|static
name|int
name|ath_tx_calc_ctsduration
parameter_list|(
name|struct
name|ath_hal
modifier|*
name|ah
parameter_list|,
name|int
name|rix
parameter_list|,
name|int
name|cix
parameter_list|,
name|int
name|shortPreamble
parameter_list|,
name|int
name|pktlen
parameter_list|,
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ctsduration
init|=
literal|0
decl_stmt|;
comment|/* This mustn't be called for HT modes */
if|if
condition|(
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_HT
condition|)
block|{
name|printf
argument_list|(
literal|"%s: HT rate where it shouldn't be (0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|rateCode
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Compute the transmit duration based on the frame 	 * size and the size of an ACK frame.  We call into the 	 * HAL to do the computation since it depends on the 	 * characteristics of the actual PHY being used. 	 * 	 * NB: CTS is assumed the same size as an ACK so we can 	 *     use the precalculated ACK durations. 	 */
if|if
condition|(
name|shortPreamble
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|spAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_RTSENA
condition|)
comment|/* SIFS + CTS */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|cix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
name|ctsduration
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|pktlen
argument_list|,
name|rix
argument_list|,
name|AH_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
comment|/* SIFS + ACK */
name|ctsduration
operator|+=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
block|}
return|return
name|ctsduration
return|;
block|}
end_function

begin_function
name|int
name|ath_tx_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_vap
modifier|*
name|avp
init|=
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
specifier|const
name|struct
name|chanAccParams
modifier|*
name|cap
init|=
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
decl_stmt|;
name|int
name|error
decl_stmt|,
name|iswep
decl_stmt|,
name|ismcast
decl_stmt|,
name|isfrag
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|;
name|u_int8_t
name|cix
init|=
literal|0xff
decl_stmt|;
comment|/* NB: silence compiler */
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|subtype
decl_stmt|,
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|HAL_BOOL
name|shortPreamble
decl_stmt|;
name|struct
name|ath_node
modifier|*
name|an
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|uint8_t
name|try
index|[
literal|4
index|]
decl_stmt|,
name|rate
index|[
literal|4
index|]
decl_stmt|;
name|bzero
argument_list|(
name|try
argument_list|,
sizeof|sizeof
argument_list|(
name|try
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rate
argument_list|,
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|iswep
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|isfrag
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* Handle encryption twiddling if needed */
if|if
condition|(
operator|!
name|ath_tx_tag_crypto
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|iswep
argument_list|,
name|isfrag
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|&
name|keyix
argument_list|)
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* 	 * Load the DMA map so any coalescing is done.  This 	 * also calculates the number of descriptors we need. 	 */
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* setup descriptors */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NB: the 802.11 layer marks whether or not we should 	 * use short preamble based on the current mode and 	 * negotiated parameters. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
condition|)
block|{
name|shortPreamble
operator|=
name|AH_TRUE
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_shortpre
operator|++
expr_stmt|;
block|}
else|else
block|{
name|shortPreamble
operator|=
name|AH_FALSE
expr_stmt|;
block|}
name|an
operator|=
name|ATH_NODE
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* default no multi-rate retry*/
name|pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* honor classification */
comment|/* XXX use txparams instead of fixed values */
comment|/* 	 * Calculate Atheros packet type from IEEE80211 packet header, 	 * setup for rate calculations, and select h/w transmit queue. 	 */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_BEACON
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_PROBE_RESP
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_ATIM
condition|)
name|atype
operator|=
name|HAL_PKT_TYPE_ATIM
expr_stmt|;
else|else
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* XXX */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
comment|/* stop setting of duration */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
break|break;
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|atype
operator|=
name|HAL_PKT_TYPE_NORMAL
expr_stmt|;
comment|/* default */
comment|/* 		 * Data frames: multicast frames go out at a fixed rate, 		 * EAPOL frames use the mgmt frame rate; otherwise consult 		 * the rate control module for the rate to use. 		 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|rix
operator|=
name|an
operator|->
name|an_mcastrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EAPOL
condition|)
block|{
comment|/* XXX? maybe always use long preamble? */
name|rix
operator|=
name|an
operator|->
name|an_mgmtrix
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|try0
operator|=
name|ATH_TXMAXTRY
expr_stmt|;
comment|/* XXX?too many? */
block|}
else|else
block|{
name|ath_rate_findrate
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|shortPreamble
argument_list|,
name|pktlen
argument_list|,
operator|&
name|rix
argument_list|,
operator|&
name|try0
argument_list|,
operator|&
name|txrate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
comment|/* for LED blinking */
name|sc
operator|->
name|sc_lastdatarix
operator|=
name|rix
expr_stmt|;
comment|/* for fast frames */
if|if
condition|(
name|try0
operator|!=
name|ATH_TXMAXTRY
condition|)
name|ismrr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cap
operator|->
name|cap_wmeParams
index|[
name|pri
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
break|break;
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bogus frame type 0x%x (%s)\n"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX statistic */
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|txq
operator|=
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
expr_stmt|;
comment|/* 	 * When servicing one or more stations in power-save mode 	 * (or) if there is some mcast data waiting on the mcast 	 * queue (to prevent out of order delivery) multicast 	 * frames must be buffered until after the beacon. 	 */
if|if
condition|(
name|ismcast
operator|&&
operator|(
name|vap
operator|->
name|iv_ps_sta
operator|||
name|avp
operator|->
name|av_mcastq
operator|.
name|axq_depth
operator|)
condition|)
name|txq
operator|=
operator|&
name|avp
operator|->
name|av_mcastq
expr_stmt|;
comment|/* 	 * Calculate miscellaneous flags. 	 */
if|if
condition|(
name|ismcast
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
comment|/* no ack on broad/multicast */
block|}
elseif|else
if|if
condition|(
name|pktlen
operator|>
name|vap
operator|->
name|iv_rtsthreshold
operator|&&
operator|(
name|ni
operator|->
name|ni_ath_flags
operator|&
name|IEEE80211_NODE_FF
operator|)
operator|==
literal|0
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
comment|/* RTS based on frame length */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|controlRate
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_rts
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
condition|)
comment|/* NB: avoid double counting */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_noack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|sc
operator|->
name|sc_tdma
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_TDMA
argument_list|,
literal|"%s: discard frame, ACK required w/ TDMA\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tdma_ack
operator|++
expr_stmt|;
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
endif|#
directive|endif
comment|/* 	 * If 802.11g protection is enabled, determine whether 	 * to use RTS/CTS or just CTS.  Note that this is only 	 * done for OFDM unicast frames. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
operator|)
operator|&&
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|phy
operator|==
name|IEEE80211_T_OFDM
operator|&&
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* XXX fragments must use CCK rates w/ protection */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_RTSCTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|==
name|IEEE80211_PROT_CTSONLY
condition|)
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
if|if
condition|(
name|isfrag
condition|)
block|{
comment|/* 			 * For frags it would be desirable to use the 			 * highest CCK rate for RTS/CTS.  But stations 			 * farther away may detect it at a lower CCK rate 			 * so use the configured protection rate instead 			 * (for now). 			 */
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_protrix
index|]
operator|.
name|controlRate
expr_stmt|;
block|}
else|else
name|cix
operator|=
name|rt
operator|->
name|info
index|[
name|sc
operator|->
name|sc_protrix
index|]
operator|.
name|controlRate
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_protect
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 	 * If 11n protection is enabled and it's a HT frame, 	 * enable RTS. 	 * 	 * XXX ic_htprotmode or ic_curhtprotmode? 	 * XXX should it_htprotmode only matter if ic_curhtprotmode  	 * XXX indicates it's not a HT pure environment? 	 */
block|if ((ic->ic_htprotmode == IEEE80211_PROT_RTSCTS)&& 	    rt->info[rix].phy == IEEE80211_T_HT&& 	    (flags& HAL_TXDESC_NOACK) == 0) { 		cix = rt->info[sc->sc_protrix].controlRate; 	    	flags |= HAL_TXDESC_RTSENA; 		sc->sc_stats.ast_tx_htprotect++; 	}
endif|#
directive|endif
comment|/* 	 * Calculate duration.  This logically belongs in the 802.11 	 * layer but it lacks sufficient information to calculate it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|HAL_TXDESC_NOACK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_TYPE_CTL
condition|)
block|{
name|u_int16_t
name|dur
decl_stmt|;
if|if
condition|(
name|shortPreamble
condition|)
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|spAckDuration
expr_stmt|;
else|else
name|dur
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|lpAckDuration
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_MORE_FRAG
condition|)
block|{
name|dur
operator|+=
name|dur
expr_stmt|;
comment|/* additional SIFS+ACK */
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no fragment"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Include the size of next fragment so NAV is 			 * updated properly.  The last fragment uses only 			 * the ACK duration 			 */
name|dur
operator|+=
name|ath_hal_computetxtime
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|m0
operator|->
name|m_nextpkt
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|rix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isfrag
condition|)
block|{
comment|/* 			 * Force hardware to use computed duration for next 			 * fragment by disabling multi-rate retry which updates 			 * duration based on the multi-rate duration table. 			 */
name|ismrr
operator|=
literal|0
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX? */
block|}
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate RTS/CTS rate and duration if needed. 	 */
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
block|{
name|ctsrate
operator|=
name|ath_tx_get_rtscts_rate
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|rix
argument_list|,
name|cix
argument_list|,
name|shortPreamble
argument_list|)
expr_stmt|;
comment|/* The 11n chipsets do ctsduration calculations for you */
if|if
condition|(
operator|!
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
name|ctsduration
operator|=
name|ath_tx_calc_ctsduration
argument_list|(
name|ah
argument_list|,
name|rix
argument_list|,
name|cix
argument_list|,
name|shortPreamble
argument_list|,
name|pktlen
argument_list|,
name|rt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Must disable multi-rate retry when using RTS/CTS. 		 */
name|ismrr
operator|=
literal|0
expr_stmt|;
name|try0
operator|=
name|ATH_TXMGTTRY
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
comment|/* 	 * At this point we are committed to sending the frame 	 * and we don't need to look at m_nextpkt; clear it in 	 * case this frame is part of frag chain. 	 */
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|iswep
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|isfrag
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Determine if a tx interrupt should be generated for 	 * this descriptor.  We take a tx interrupt to reap 	 * descriptors when the h/w hits an EOL condition or 	 * when the descriptor is specifically marked to generate 	 * an interrupt.  We periodically mark descriptors in this 	 * way to insure timely replenishing of the supply needed 	 * for sending frames.  Defering interrupts reduces system 	 * load and potentially allows more concurrent work to be 	 * done but if done to aggressively can cause senders to 	 * backup. 	 * 	 * NB: use>= to deal with sc_txintrperiod changing 	 *     dynamically through sysctl. 	 */
if|if
condition|(
name|flags
operator|&
name|HAL_TXDESC_INTREQ
condition|)
block|{
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|txq
operator|->
name|axq_intrcnt
operator|>=
name|sc
operator|->
name|sc_txintrperiod
condition|)
block|{
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
name|txq
operator|->
name|axq_intrcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rate
index|[
literal|0
index|]
operator|=
name|rix
expr_stmt|;
name|try
index|[
literal|0
index|]
operator|=
name|try0
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
comment|/* XXX check return value? */
comment|/* XXX is this ok to call for 11n descriptors? */
comment|/* XXX or should it go through the first, next, last 11n calls? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
name|ni
operator|->
name|ni_txpower
comment|/* txpower */
argument_list|,
name|txrate
argument_list|,
name|try0
comment|/* series 0 rate/tries */
argument_list|,
name|keyix
comment|/* key cache index */
argument_list|,
name|sc
operator|->
name|sc_txantenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_txflags
operator|=
name|flags
expr_stmt|;
comment|/* 	 * Setup the multi-rate retry state only when we're 	 * going to use it.  This assumes ath_hal_setuptxdesc 	 * initializes the descriptors (so we don't have to) 	 * when the hardware supports multi-rate retry and 	 * we don't use it. 	 */
if|if
condition|(
name|ismrr
condition|)
block|{
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
name|ath_rate_getxtxrates
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|rix
argument_list|,
name|rate
argument_list|,
name|try
argument_list|)
expr_stmt|;
else|else
name|ath_rate_setupxtxdesc
argument_list|(
name|sc
argument_list|,
name|an
argument_list|,
name|ds
argument_list|,
name|shortPreamble
argument_list|,
name|rix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ath_buf_set_rate
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|pktlen
argument_list|,
name|flags
argument_list|,
name|ctsrate
argument_list|,
operator|(
name|atype
operator|==
name|HAL_PKT_TYPE_PSPOLL
operator|)
argument_list|,
name|rate
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|txq
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_tx_raw_start
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ismcast
decl_stmt|,
name|ismrr
decl_stmt|;
name|int
name|keyix
decl_stmt|,
name|hdrlen
decl_stmt|,
name|pktlen
decl_stmt|,
name|try0
decl_stmt|,
name|txantenna
decl_stmt|;
name|u_int8_t
name|rix
decl_stmt|,
name|cix
decl_stmt|,
name|txrate
decl_stmt|,
name|ctsrate
decl_stmt|,
name|rate1
decl_stmt|,
name|rate2
decl_stmt|,
name|rate3
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|ctsduration
decl_stmt|;
name|HAL_PKT_TYPE
name|atype
decl_stmt|;
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|u_int
name|pri
decl_stmt|;
name|uint8_t
name|try
index|[
literal|4
index|]
decl_stmt|,
name|rate
index|[
literal|4
index|]
decl_stmt|;
name|bzero
argument_list|(
name|try
argument_list|,
sizeof|sizeof
argument_list|(
name|try
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rate
argument_list|,
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ismcast
operator|=
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_anyhdrsize
argument_list|(
name|wh
argument_list|)
expr_stmt|;
comment|/* 	 * Packet length must not include any 	 * pad bytes; deduct them here. 	 */
comment|/* XXX honor IEEE80211_BPF_DATAPAD */
name|pktlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|&
literal|3
operator|)
operator|+
name|IEEE80211_CRC_LEN
expr_stmt|;
comment|/* Handle encryption twiddling if needed */
if|if
condition|(
operator|!
name|ath_tx_tag_crypto
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|m0
argument_list|,
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CRYPTO
argument_list|,
literal|0
argument_list|,
operator|&
name|hdrlen
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|&
name|keyix
argument_list|)
condition|)
block|{
name|ath_freetx
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* packet header may have moved, reset our local pointer */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|ath_tx_dmasetup
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|m0
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
comment|/* NB: may have changed */
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|ni
expr_stmt|;
comment|/* NB: held reference */
name|flags
operator|=
name|HAL_TXDESC_CLRDMASK
expr_stmt|;
comment|/* XXX needed for crypto errs */
name|flags
operator||=
name|HAL_TXDESC_INTREQ
expr_stmt|;
comment|/* force interrupt */
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_RTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_RTSENA
expr_stmt|;
elseif|else
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CTS
condition|)
name|flags
operator||=
name|HAL_TXDESC_CTSENA
expr_stmt|;
comment|/* XXX leave ismcast to injector? */
if|if
condition|(
operator|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_NOACK
operator|)
operator|||
name|ismcast
condition|)
name|flags
operator||=
name|HAL_TXDESC_NOACK
expr_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|txrate
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|txrate
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
name|sc
operator|->
name|sc_txrix
operator|=
name|rix
expr_stmt|;
name|try0
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|ismrr
operator|=
operator|(
name|params
operator|->
name|ibp_try1
operator|!=
literal|0
operator|)
expr_stmt|;
name|txantenna
operator|=
name|params
operator|->
name|ibp_pri
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|txantenna
operator|==
literal|0
condition|)
comment|/* XXX? */
name|txantenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ctsduration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|HAL_TXDESC_RTSENA
operator||
name|HAL_TXDESC_CTSENA
operator|)
condition|)
block|{
name|cix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_ctsrate
argument_list|)
expr_stmt|;
name|ctsrate
operator|=
name|ath_tx_get_rtscts_rate
argument_list|(
name|ah
argument_list|,
name|rt
argument_list|,
name|rix
argument_list|,
name|cix
argument_list|,
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
argument_list|)
expr_stmt|;
comment|/* The 11n chipsets do ctsduration calculations for you */
if|if
condition|(
operator|!
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
name|ctsduration
operator|=
name|ath_tx_calc_ctsduration
argument_list|(
name|ah
argument_list|,
name|rix
argument_list|,
name|cix
argument_list|,
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
argument_list|,
name|pktlen
argument_list|,
name|rt
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Must disable multi-rate retry when using RTS/CTS. 		 */
name|ismrr
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
else|else
name|ctsrate
operator|=
literal|0
expr_stmt|;
name|pri
operator|=
name|params
operator|->
name|ibp_pri
operator|&
literal|3
expr_stmt|;
comment|/* 	 * NB: we mark all packets as type PSPOLL so the h/w won't 	 * set the sequence number, duration, etc. 	 */
name|atype
operator|=
name|HAL_PKT_TYPE_PSPOLL
expr_stmt|;
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|u_int64_t
name|tsf
init|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_tsf
operator|=
name|htole64
argument_list|(
name|tsf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|txflags
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_WEP
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_flags
operator||=
name|IEEE80211_RADIOTAP_F_FRAG
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_txpower
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|sc
operator|->
name|sc_tx_th
operator|.
name|wt_antenna
operator|=
name|sc
operator|->
name|sc_txantenna
expr_stmt|;
name|ieee80211_radiotap_tx
argument_list|(
name|vap
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Formulate first tx descriptor with tx controls. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* XXX check return value? */
name|ath_hal_setuptxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|pktlen
comment|/* packet length */
argument_list|,
name|hdrlen
comment|/* header length */
argument_list|,
name|atype
comment|/* Atheros packet type */
argument_list|,
name|params
operator|->
name|ibp_power
comment|/* txpower */
argument_list|,
name|txrate
argument_list|,
name|try0
comment|/* series 0 rate/tries */
argument_list|,
name|keyix
comment|/* key cache index */
argument_list|,
name|txantenna
comment|/* antenna mode */
argument_list|,
name|flags
comment|/* flags */
argument_list|,
name|ctsrate
comment|/* rts/cts rate */
argument_list|,
name|ctsduration
comment|/* rts/cts duration */
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_txflags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rate
index|[
literal|0
index|]
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|try
index|[
literal|0
index|]
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
if|if
condition|(
name|ismrr
condition|)
block|{
comment|/* Remember, rate[] is actually an array of rix's -adrian */
name|rate
index|[
literal|0
index|]
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate0
argument_list|)
expr_stmt|;
name|rate
index|[
literal|1
index|]
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate1
argument_list|)
expr_stmt|;
name|rate
index|[
literal|2
index|]
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate2
argument_list|)
expr_stmt|;
name|rate
index|[
literal|3
index|]
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate3
argument_list|)
expr_stmt|;
name|try
index|[
literal|0
index|]
operator|=
name|params
operator|->
name|ibp_try0
expr_stmt|;
name|try
index|[
literal|1
index|]
operator|=
name|params
operator|->
name|ibp_try1
expr_stmt|;
name|try
index|[
literal|2
index|]
operator|=
name|params
operator|->
name|ibp_try2
expr_stmt|;
name|try
index|[
literal|3
index|]
operator|=
name|params
operator|->
name|ibp_try3
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ismrr
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate1
argument_list|)
expr_stmt|;
name|rate1
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate1
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_try2
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate2
argument_list|)
expr_stmt|;
name|rate2
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate2
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
block|}
else|else
name|rate2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_try3
condition|)
block|{
name|rix
operator|=
name|ath_tx_findrix
argument_list|(
name|sc
argument_list|,
name|params
operator|->
name|ibp_rate3
argument_list|)
expr_stmt|;
name|rate3
operator|=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|rateCode
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_SHORTPRE
condition|)
name|rate3
operator||=
name|rt
operator|->
name|info
index|[
name|rix
index|]
operator|.
name|shortPreamble
expr_stmt|;
block|}
else|else
name|rate3
operator|=
literal|0
expr_stmt|;
name|ath_hal_setupxtxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|rate1
argument_list|,
name|params
operator|->
name|ibp_try1
comment|/* series 1 */
argument_list|,
name|rate2
argument_list|,
name|params
operator|->
name|ibp_try2
comment|/* series 2 */
argument_list|,
name|rate3
argument_list|,
name|params
operator|->
name|ibp_try3
comment|/* series 3 */
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ath_tx_is_11n
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 		 * notice that rix doesn't include any of the "magic" flags txrate 		 * does for communicating "other stuff" to the HAL. 		 */
name|ath_buf_set_rate
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|pktlen
argument_list|,
name|flags
argument_list|,
name|ctsrate
argument_list|,
operator|(
name|atype
operator|==
name|HAL_PKT_TYPE_PSPOLL
operator|)
argument_list|,
name|rate
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
comment|/* NB: no buffered multicast in power save support */
name|ath_tx_handoff
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_ac2q
index|[
name|pri
index|]
argument_list|,
name|bf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ath_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_invalid
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_XMIT
argument_list|,
literal|"%s: discard frame, %s"
argument_list|,
name|__func__
argument_list|,
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|?
literal|"!running"
else|:
literal|"invalid"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Grab a TX buffer and associated resources. 	 */
name|bf
operator|=
name|ath_getbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Legacy path; interpret frame contents to decide 		 * precisely how to send the frame. 		 */
if|if
condition|(
name|ath_tx_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Caller supplied explicit parameters to use in 		 * sending the frame. 		 */
if|if
condition|(
name|ath_tx_raw_start
argument_list|(
name|sc
argument_list|,
name|ni
argument_list|,
name|bf
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad2
goto|;
block|}
block|}
name|sc
operator|->
name|sc_wd_timer
operator|=
literal|5
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw
operator|++
expr_stmt|;
return|return
literal|0
return|;
name|bad2
label|:
name|ATH_TXBUF_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_txbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ATH_TXBUF_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bad
label|:
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_tx_raw_fail
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

