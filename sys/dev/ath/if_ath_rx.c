begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_comment
comment|/*  * This is needed for register operations which are performed  * by the driver - eg, calls to ath_hal_gettsf32().  *  * It's also required for any AH_DEBUG checks in here, eg the  * module dependencies.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* for mp_ncpus */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tsf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_led.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_keycache.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_beacon.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athdfs.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_descdma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TX99_DIAG
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/ath_tx99/ath_tx99.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
end_ifdef

begin_include
include|#
directive|include
file|<dev/ath/if_ath_alq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_lna_div.h>
end_include

begin_comment
comment|/*  * Calculate the receive filter according to the  * operating mode and state:  *  * o always accept unicast, broadcast, and multicast traffic  * o accept PHY error frames when hardware doesn't have MIB support  *   to count and we need them for ANI (sta mode only until recently)  *   and we are not scanning (ANI is disabled)  *   NB: older hal's add rx filter bits out of sight and we need to  *	 blindly preserve them  * o probe request frames are accepted only when operating in  *   hostap, adhoc, mesh, or monitor modes  * o enable promiscuous mode  *   - when in monitor mode  *   - if interface marked PROMISC (assumes bridge setting is filtered)  * o accept beacons:  *   - when operating in station mode for collecting rssi data when  *     the station is otherwise quiet, or  *   - when operating in adhoc mode so the 802.11 layer creates  *     node table entries for peers,  *   - when scanning  *   - when doing s/w beacon miss (e.g. for ap+sta)  *   - when operating in ap mode in 11g to detect overlapping bss that  *     require protection  *   - when operating in mesh mode to detect neighbors  * o accept control frames:  *   - when in monitor mode  * XXX HT protection for 11n  */
end_comment

begin_function
name|u_int32_t
name|ath_calcrxfilter
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|u_int32_t
name|rfilt
decl_stmt|;
name|rfilt
operator|=
name|HAL_RX_FILTER_UCAST
operator||
name|HAL_RX_FILTER_BCAST
operator||
name|HAL_RX_FILTER_MCAST
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_needmib
operator|&&
operator|!
name|sc
operator|->
name|sc_scanning
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PHYERR
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROBEREQ
expr_stmt|;
comment|/* XXX ic->ic_monvaps != 0? */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
name|ic
operator|->
name|ic_promisc
operator|>
literal|0
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
comment|/* 	 * Only listen to all beacons if we're scanning. 	 * 	 * Otherwise we only really need to hear beacons from 	 * our own BSSID. 	 * 	 * IBSS? software beacon miss? Just receive all beacons. 	 * We need to hear beacons/probe requests from everyone so 	 * we can merge ibss. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|sc
operator|->
name|sc_swbmiss
condition|)
block|{
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_do_mybeacon
operator|&&
operator|!
name|sc
operator|->
name|sc_scanning
condition|)
block|{
name|rfilt
operator||=
name|HAL_RX_FILTER_MYBEACON
expr_stmt|;
block|}
else|else
block|{
comment|/* scanning, non-mybeacon chips */
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
block|}
block|}
comment|/* 	 * NB: We don't recalculate the rx filter when 	 * ic_protmode changes; otherwise we could do 	 * this only when ic_protmode != NONE. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
comment|/* 	 * Enable hardware PS-POLL RX only for hostap mode; 	 * STA mode sends PS-POLL frames but never 	 * receives them. 	 */
if|if
condition|(
name|ath_hal_getcapability
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|HAL_CAP_PSPOLL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|==
name|HAL_OK
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PSPOLL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nmeshvaps
condition|)
block|{
name|rfilt
operator||=
name|HAL_RX_FILTER_BEACON
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hasbmatch
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_BSSID
expr_stmt|;
else|else
name|rfilt
operator||=
name|HAL_RX_FILTER_PROM
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_CONTROL
expr_stmt|;
comment|/* 	 * Enable RX of compressed BAR frames only when doing 	 * 802.11n. Required for A-MPDU. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_COMPBAR
expr_stmt|;
comment|/* 	 * Enable radar PHY errors if requested by the 	 * DFS module. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_dodfs
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PHYRADAR
expr_stmt|;
comment|/* 	 * Enable spectral PHY errors if requested by the 	 * spectral module. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_dospectral
condition|)
name|rfilt
operator||=
name|HAL_RX_FILTER_PHYRADAR
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_MODE
argument_list|,
literal|"%s: RX filter 0x%x, %s\n"
argument_list|,
name|__func__
argument_list|,
name|rfilt
argument_list|,
name|ieee80211_opmode_name
index|[
name|ic
operator|->
name|ic_opmode
index|]
argument_list|)
expr_stmt|;
return|return
name|rfilt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_legacy_rxbuf_init
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
comment|/* XXX TODO: ATH_RX_LOCK_ASSERT(sc); */
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * NB: by assigning a page to the rx dma buffer we 		 * implicitly satisfy the Atheros requirement that 		 * this buffer be cache-line-aligned and sized to be 		 * multiple of the cache line size.  Not doing this 		 * causes weird stuff to happen (for the 5210 at least). 		 */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: no mbuf/cluster\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_nombuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|m
argument_list|,
name|bf
operator|->
name|bf_segs
argument_list|,
operator|&
name|bf
operator|->
name|bf_nseg
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_ANY
argument_list|,
literal|"%s: bus_dmamap_load_mbuf_sg failed; error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_busdma
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|bf
operator|->
name|bf_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"multi-segment packet; nseg %u"
operator|,
name|bf
operator|->
name|bf_nseg
operator|)
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|m
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Setup descriptors.  For receive we always terminate 	 * the descriptor list with a self-linked entry so we'll 	 * not get overrun under high load (as can happen with a 	 * 5212 when ANI processing enables PHY error frames). 	 * 	 * To insure the last descriptor is self-linked we create 	 * each descriptor as self-linked and add it to the end.  As 	 * each additional descriptor is added the previous self-linked 	 * entry is ``fixed'' naturally.  This should be safe even 	 * if DMA is happening.  When processing RX interrupts we 	 * never remove/process the last, self-linked, entry on the 	 * descriptor list.  This insures the hardware always has 	 * someplace to write a new frame. 	 */
comment|/* 	 * 11N: we can no longer afford to self link the last descriptor. 	 * MAC acknowledges BA status as long as it copies frames to host 	 * buffer (or rx fifo). This can incorrectly acknowledge packets 	 * to a sender if last desc is self-linked. 	 */
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxslink
condition|)
name|ds
operator|->
name|ds_link
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
comment|/* link to self */
else|else
name|ds
operator|->
name|ds_link
operator|=
literal|0
expr_stmt|;
comment|/* terminate the list */
name|ds
operator|->
name|ds_data
operator|=
name|bf
operator|->
name|bf_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|ath_hal_setuprxdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|m
operator|->
name|m_len
comment|/* buffer size */
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxlink
operator|!=
name|NULL
condition|)
operator|*
name|sc
operator|->
name|sc_rxlink
operator|=
name|bf
operator|->
name|bf_daddr
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
operator|&
name|ds
operator|->
name|ds_link
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Intercept management frames to collect beacon rssi data  * and to do ibss merges.  */
end_comment

begin_function
name|void
name|ath_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|,
specifier|const
name|struct
name|ieee80211_rx_stats
modifier|*
name|rxs
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_softc
decl_stmt|;
name|uint64_t
name|tsf_beacon_old
decl_stmt|,
name|tsf_beacon
decl_stmt|;
name|uint64_t
name|nexttbtt
decl_stmt|;
name|int64_t
name|tsf_delta
decl_stmt|;
name|int32_t
name|tsf_delta_bmiss
decl_stmt|;
name|int32_t
name|tsf_remainder
decl_stmt|;
name|uint64_t
name|tsf_beacon_target
decl_stmt|;
name|int
name|tsf_intval
decl_stmt|;
name|tsf_beacon_old
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|le32dec
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
name|tsf_beacon_old
operator||=
name|le32dec
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
expr_stmt|;
define|#
directive|define
name|TU_TO_TSF
parameter_list|(
name|_tu
parameter_list|)
value|(((u_int64_t)(_tu))<< 10)
name|tsf_intval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_intval
operator|>
literal|0
condition|)
block|{
name|tsf_intval
operator|=
name|TU_TO_TSF
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|TU_TO_TSF
comment|/* 	 * Call up first so subsequent work can use information 	 * potentially stored in the node (e.g. for ibss merge). 	 */
name|ATH_VAP
argument_list|(
name|vap
argument_list|)
operator|->
name|av_recv_mgmt
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|subtype
argument_list|,
name|rxs
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_BEACON
case|:
comment|/* 		 * Only do the following processing if it's for 		 * the current BSS. 		 * 		 * In scan and IBSS mode we receive all beacons, 		 * which means we need to filter out stuff 		 * that isn't for us or we'll end up constantly 		 * trying to sync / merge to BSSes that aren't 		 * actually us. 		 */
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_bssid
argument_list|)
condition|)
block|{
comment|/* update rssi statistics for use by the hal */
comment|/* XXX unlocked check against vap->iv_bss? */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgbrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|tsf_beacon
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|le32dec
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
operator|+
literal|4
argument_list|)
operator|)
operator|<<
literal|32
expr_stmt|;
name|tsf_beacon
operator||=
name|le32dec
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
expr_stmt|;
name|nexttbtt
operator|=
name|ath_hal_getnexttbtt
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
expr_stmt|;
comment|/* 			 * Let's calculate the delta and remainder, so we can see 			 * if the beacon timer from the AP is varying by more than 			 * a few TU.  (Which would be a huge, huge problem.) 			 */
name|tsf_delta
operator|=
operator|(
name|long
name|long
operator|)
name|tsf_beacon
operator|-
operator|(
name|long
name|long
operator|)
name|tsf_beacon_old
expr_stmt|;
name|tsf_delta_bmiss
operator|=
name|tsf_delta
operator|/
name|tsf_intval
expr_stmt|;
comment|/* 			 * If our delta is greater than half the beacon interval, 			 * let's round the bmiss value up to the next beacon 			 * interval.  Ie, we're running really, really early 			 * on the next beacon. 			 */
if|if
condition|(
name|tsf_delta
operator|%
name|tsf_intval
operator|>
operator|(
name|tsf_intval
operator|/
literal|2
operator|)
condition|)
name|tsf_delta_bmiss
operator|++
expr_stmt|;
name|tsf_beacon_target
operator|=
name|tsf_beacon_old
operator|+
operator|(
operator|(
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_delta_bmiss
operator|)
operator|*
operator|(
name|long
name|long
operator|)
name|tsf_intval
operator|)
expr_stmt|;
comment|/* 			 * The remainder using '%' is between 0 .. intval-1. 			 * If we're actually running too fast, then the remainder 			 * will be some large number just under intval-1. 			 * So we need to look at whether we're running 			 * before or after the target beacon interval 			 * and if we are, modify how we do the remainder 			 * calculation. 			 */
if|if
condition|(
name|tsf_beacon
operator|<
name|tsf_beacon_target
condition|)
block|{
name|tsf_remainder
operator|=
operator|-
operator|(
name|tsf_intval
operator|-
operator|(
operator|(
name|tsf_beacon
operator|-
name|tsf_beacon_old
operator|)
operator|%
name|tsf_intval
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tsf_remainder
operator|=
operator|(
name|tsf_beacon
operator|-
name|tsf_beacon_old
operator|)
operator|%
name|tsf_intval
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: old_tsf=%llu (%u), new_tsf=%llu (%u), target_tsf=%llu (%u), delta=%lld, bmiss=%d, remainder=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_beacon_old
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|tsf_beacon_old
operator|>>
literal|10
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_beacon
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|tsf_beacon
operator|>>
literal|10
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_beacon_target
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|tsf_beacon_target
operator|>>
literal|10
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|tsf_delta
argument_list|,
name|tsf_delta_bmiss
argument_list|,
name|tsf_remainder
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: tsf=%llu (%u), nexttbtt=%llu (%u), delta=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|tsf_beacon
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|tsf_beacon
operator|>>
literal|10
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|nexttbtt
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|nexttbtt
operator|>>
literal|10
argument_list|)
argument_list|,
operator|(
name|int32_t
operator|)
name|tsf_beacon
operator|-
operator|(
name|int32_t
operator|)
name|nexttbtt
operator|+
name|tsf_intval
argument_list|)
expr_stmt|;
comment|/* We only do syncbeacon on STA VAPs; not on IBSS */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|sc
operator|->
name|sc_syncbeacon
operator|&&
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|&&
operator|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|||
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_SLEEP
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_BEACON
argument_list|,
literal|"%s: syncbeacon=1; syncing\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 				 * Resync beacon timers using the tsf of the beacon 				 * frame we just received. 				 */
name|ath_beacon_config
argument_list|(
name|sc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncbeacon
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* fall thru... */
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|ieee80211_ibss_merge_check
argument_list|(
name|ni
argument_list|)
condition|)
block|{
name|uint32_t
name|rstamp
init|=
name|sc
operator|->
name|sc_lastrs
operator|->
name|rs_tstamp
decl_stmt|;
name|uint64_t
name|tsf
init|=
name|ath_extend_tsf
argument_list|(
name|sc
argument_list|,
name|rstamp
argument_list|,
name|ath_hal_gettsf64
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 			 * Handle ibss merge as needed; check the tsf on the 			 * frame before attempting the merge.  The 802.11 spec 			 * says the station should change it's bssid to match 			 * the oldest station with the same ssid, where oldest 			 * is determined by the tsf.  Note that hardware 			 * reconfiguration happens through callback to 			 * ath_newstate as the state machine will go from 			 * RUN -> RUN when this happens. 			 */
if|if
condition|(
name|le64toh
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
operator|>=
name|tsf
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_STATE
argument_list|,
literal|"ibss merge, rstamp %u tsf %ju "
literal|"tstamp %ju\n"
argument_list|,
name|rstamp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tsf
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ibss_merge
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_ENABLE_RADIOTAP_VENDOR_EXT
end_ifdef

begin_function
specifier|static
name|void
name|ath_rx_tap_vendor
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
comment|/* Fill in the extension bitmap */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_ext_bitmap
operator|=
name|htole32
argument_list|(
literal|1
operator|<<
name|ATH_RADIOTAP_VENDOR_HEADER
argument_list|)
expr_stmt|;
comment|/* Fill in the vendor header */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_vh
operator|.
name|vh_oui
index|[
literal|0
index|]
operator|=
literal|0x7f
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_vh
operator|.
name|vh_oui
index|[
literal|1
index|]
operator|=
literal|0x03
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_vh
operator|.
name|vh_oui
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* XXX what should this be? */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_vh
operator|.
name|vh_sub_ns
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_vh
operator|.
name|vh_skip_len
operator|=
name|htole16
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ath_radiotap_vendor_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* General version info */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_version
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_rx_chainmask
operator|=
name|sc
operator|->
name|sc_rxchainmask
expr_stmt|;
comment|/* rssi */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|rssi_ctl
index|[
literal|0
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ctl
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|rssi_ctl
index|[
literal|1
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ctl
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|rssi_ctl
index|[
literal|2
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ctl
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|rssi_ext
index|[
literal|0
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ext
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|rssi_ext
index|[
literal|1
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ext
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|rssi_ext
index|[
literal|2
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ext
index|[
literal|2
index|]
expr_stmt|;
comment|/* evm */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|evm
index|[
literal|0
index|]
operator|=
name|rs
operator|->
name|rs_evm0
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|evm
index|[
literal|1
index|]
operator|=
name|rs
operator|->
name|rs_evm1
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|evm
index|[
literal|2
index|]
operator|=
name|rs
operator|->
name|rs_evm2
expr_stmt|;
comment|/* These are only populated from the AR9300 or later */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|evm
index|[
literal|3
index|]
operator|=
name|rs
operator|->
name|rs_evm3
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|evm
index|[
literal|4
index|]
operator|=
name|rs
operator|->
name|rs_evm4
expr_stmt|;
comment|/* direction */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_flags
operator|=
name|ATH_VENDOR_PKT_RX
expr_stmt|;
comment|/* RX rate */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_rx_hwrate
operator|=
name|rs
operator|->
name|rs_rate
expr_stmt|;
comment|/* RX flags */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_rs_flags
operator|=
name|rs
operator|->
name|rs_flags
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_isaggr
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_flags
operator||=
name|ATH_VENDOR_PKT_ISAGGR
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_moreaggr
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_flags
operator||=
name|ATH_VENDOR_PKT_MOREAGGR
expr_stmt|;
comment|/* phyerr info */
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_phyerr_code
operator|=
name|rs
operator|->
name|rs_phyerr
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_flags
operator||=
name|ATH_VENDOR_PKT_RXPHYERR
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_phyerr_code
operator|=
literal|0xff
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_rs_status
operator|=
name|rs
operator|->
name|rs_status
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_v
operator|.
name|vh_rssi
operator|=
name|rs
operator|->
name|rs_rssi
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_ENABLE_RADIOTAP_VENDOR_EXT */
end_comment

begin_function
specifier|static
name|void
name|ath_rx_tap
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ath_rx_status
modifier|*
name|rs
parameter_list|,
name|u_int64_t
name|tsf
parameter_list|,
name|int16_t
name|nf
parameter_list|)
block|{
define|#
directive|define
name|CHAN_HT20
value|htole32(IEEE80211_CHAN_HT20)
define|#
directive|define
name|CHAN_HT40U
value|htole32(IEEE80211_CHAN_HT40U)
define|#
directive|define
name|CHAN_HT40D
value|htole32(IEEE80211_CHAN_HT40D)
define|#
directive|define
name|CHAN_HT
value|(CHAN_HT20|CHAN_HT40U|CHAN_HT40D)
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
decl_stmt|;
name|uint8_t
name|rix
decl_stmt|;
name|rt
operator|=
name|sc
operator|->
name|sc_currates
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no rate table, mode %u"
operator|,
name|sc
operator|->
name|sc_curmode
operator|)
argument_list|)
expr_stmt|;
name|rix
operator|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator|=
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|rxflags
expr_stmt|;
comment|/* 802.11 specific flags */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator|&=
operator|~
name|CHAN_HT
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
comment|/* 		 * PHY error - make sure the channel flags 		 * reflect the actual channel configuration, 		 * not the received frame. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40U
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40D
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT20
argument_list|(
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT20
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
comment|/* HT rate */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_2040
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT20
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40U
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_chan_flags
operator||=
name|CHAN_HT40D
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_GI
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_SHORTGI
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_tsf
operator|=
name|htole64
argument_list|(
name|ath_extend_tsf
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_flags
operator||=
name|IEEE80211_RADIOTAP_F_BADFCS
expr_stmt|;
comment|/* XXX propagate other error flags from descriptor */
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antnoise
operator|=
name|nf
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antsignal
operator|=
name|nf
operator|+
name|rs
operator|->
name|rs_rssi
expr_stmt|;
name|sc
operator|->
name|sc_rx_th
operator|.
name|wr_antenna
operator|=
name|rs
operator|->
name|rs_antenna
expr_stmt|;
undef|#
directive|undef
name|CHAN_HT
undef|#
directive|undef
name|CHAN_HT20
undef|#
directive|undef
name|CHAN_HT40U
undef|#
directive|undef
name|CHAN_HT40D
block|}
end_function

begin_function
specifier|static
name|void
name|ath_handle_micerror
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|keyix
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* XXX recheck MIC to deal w/ chips that lie */
comment|/* XXX discard MIC errors on !data frames */
name|ni
operator|=
name|ieee80211_find_rxnode
argument_list|(
name|ic
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
operator|)
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_notify_michael_failure
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|wh
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a single packet.  *  * The mbuf must already be synced, unmapped and removed from bf->bf_m  * by this stage.  *  * The mbuf must be consumed by this routine - either passed up the  * net80211 stack, put on the holding queue, or freed.  */
end_comment

begin_function
name|int
name|ath_rx_pkt
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_rx_status
modifier|*
name|rs
parameter_list|,
name|HAL_STATUS
name|status
parameter_list|,
name|uint64_t
name|tsf
parameter_list|,
name|int
name|nf
parameter_list|,
name|HAL_RX_QUEUE
name|qtype
parameter_list|,
name|struct
name|ath_buf
modifier|*
name|bf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint64_t
name|rstamp
decl_stmt|;
comment|/* XXX TODO: make this an mbuf tag? */
name|struct
name|ieee80211_rx_stats
name|rxs
decl_stmt|;
name|int
name|len
decl_stmt|,
name|type
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|is_good
init|=
literal|0
decl_stmt|;
name|struct
name|ath_rx_edma
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_rxedma
index|[
name|qtype
index|]
decl_stmt|;
comment|/* 	 * Calculate the correct 64 bit TSF given 	 * the TSF64 register value and rs_tstamp. 	 */
name|rstamp
operator|=
name|ath_extend_tsf
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_tstamp
argument_list|,
name|tsf
argument_list|)
expr_stmt|;
comment|/* 802.11 return codes - These aren't specifically errors */
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_GI
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_halfgi
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_2040
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_2040
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_DELIM_CRC_PRE
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_pre_crc_err
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_DELIM_CRC_POST
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_post_crc_err
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_DECRYPT_BUSY
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_decrypt_busy_err
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_HI_RX_CHAIN
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_hi_rx_chain
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_flags
operator|&
name|HAL_RX_STBC
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_stbc
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_CRC
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_crcerr
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_FIFO
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_fifoerr
operator|++
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_PHY
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phyerr
operator|++
expr_stmt|;
comment|/* Process DFS radar events */
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_phyerr
operator|==
name|HAL_PHYERR_RADAR
operator|)
operator|||
operator|(
name|rs
operator|->
name|rs_phyerr
operator|==
name|HAL_PHYERR_FALSE_RADAR_EXT
operator|)
condition|)
block|{
comment|/* Now pass it to the radar processing code */
name|ath_dfs_process_phy_err
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|rstamp
argument_list|,
name|rs
argument_list|)
expr_stmt|;
block|}
comment|/* Be suitably paranoid about receiving phy errors out of the stats array bounds */
if|if
condition|(
name|rs
operator|->
name|rs_phyerr
operator|<
literal|64
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_phy
index|[
name|rs
operator|->
name|rs_phyerr
index|]
operator|++
expr_stmt|;
goto|goto
name|rx_error
goto|;
comment|/* NB: don't count in ierrors */
block|}
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_DECRYPT
condition|)
block|{
comment|/* 			 * Decrypt error.  If the error occurred 			 * because there was no hardware key, then 			 * let the frame through so the upper layers 			 * can process it.  This is necessary for 5210 			 * parts which have no way to setup a ``clear'' 			 * key cache entry. 			 * 			 * XXX do key cache faulting 			 */
if|if
condition|(
name|rs
operator|->
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|)
goto|goto
name|rx_accept
goto|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badcrypt
operator|++
expr_stmt|;
block|}
comment|/* 		 * Similar as above - if the failure was a keymiss 		 * just punt it up to the upper layers for now. 		 */
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_KEYMISS
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_keymiss
operator|++
expr_stmt|;
goto|goto
name|rx_accept
goto|;
block|}
if|if
condition|(
name|rs
operator|->
name|rs_status
operator|&
name|HAL_RXERR_MIC
condition|)
block|{
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_badmic
operator|++
expr_stmt|;
comment|/* 			 * Do minimal work required to hand off 			 * the 802.11 header for notification. 			 */
comment|/* XXX frag's and qos frames */
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|ath_handle_micerror
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_splitmic
condition|?
name|rs
operator|->
name|rs_keyix
operator|-
literal|32
else|:
name|rs
operator|->
name|rs_keyix
argument_list|)
expr_stmt|;
block|}
block|}
name|counter_u64_add
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rx_error
label|:
comment|/* 		 * Cleanup any pending partial frame. 		 */
if|if
condition|(
name|re
operator|->
name|m_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|re
operator|->
name|m_rxpending
argument_list|)
expr_stmt|;
name|re
operator|->
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * When a tap is present pass error frames 		 * that have been requested.  By default we 		 * pass decrypt+mic errors but others may be 		 * interesting (e.g. crc). 		 */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
operator|&&
operator|(
name|rs
operator|->
name|rs_status
operator|&
name|sc
operator|->
name|sc_monpass
operator|)
condition|)
block|{
comment|/* NB: bpf needs the mbuf length setup */
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|ath_rx_tap
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|rstamp
argument_list|,
name|nf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_ENABLE_RADIOTAP_VENDOR_EXT
name|ath_rx_tap_vendor
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|rstamp
argument_list|,
name|nf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_ENABLE_RADIOTAP_VENDOR_EXT */
name|ieee80211_radiotap_rx_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* XXX pass MIC errors up for s/w reclaculation */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
name|rx_accept
label|:
name|len
operator|=
name|rs
operator|->
name|rs_datalen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_more
condition|)
block|{
comment|/* 		 * Frame spans multiple descriptors; save 		 * it for the next completed descriptor, it 		 * will be used to construct a jumbogram. 		 */
if|if
condition|(
name|re
operator|->
name|m_rxpending
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: max frame size is currently 2 clusters */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_toobig
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|re
operator|->
name|m_rxpending
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|re
operator|->
name|m_rxpending
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
elseif|else
if|if
condition|(
name|re
operator|->
name|m_rxpending
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This is the second part of a jumbogram, 		 * chain it to the first mbuf, adjust the 		 * frame length, and clear the rxpending state. 		 */
name|re
operator|->
name|m_rxpending
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|re
operator|->
name|m_rxpending
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|m
operator|=
name|re
operator|->
name|m_rxpending
expr_stmt|;
name|re
operator|->
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Normal single-descriptor receive; setup packet length. 		 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
comment|/* 	 * Validate rs->rs_antenna. 	 * 	 * Some users w/ AR9285 NICs have reported crashes 	 * here because rs_antenna field is bogusly large. 	 * Let's enforce the maximum antenna limit of 8 	 * (and it shouldn't be hard coded, but that's a 	 * separate problem) and if there's an issue, print 	 * out an error and adjust rs_antenna to something 	 * sensible. 	 * 	 * This code should be removed once the actual 	 * root cause of the issue has been identified. 	 * For example, it may be that the rs_antenna 	 * field is only valid for the last frame of 	 * an aggregate and it just happens that it is 	 * "mostly" right. (This is a general statement - 	 * the majority of the statistics are only valid 	 * for the last frame in an aggregate. 	 */
if|if
condition|(
name|rs
operator|->
name|rs_antenna
operator|>
literal|7
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: rs_antenna> 7 (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|rs
operator|->
name|rs_antenna
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_DEBUG */
name|rs
operator|->
name|rs_antenna
operator|=
literal|0
expr_stmt|;
comment|/* XXX better than nothing */
block|}
comment|/* 	 * If this is an AR9285/AR9485, then the receive and LNA 	 * configuration is stored in RSSI[2] / EXTRSSI[2]. 	 * We can extract this out to build a much better 	 * receive antenna profile. 	 * 	 * Yes, this just blurts over the above RX antenna field 	 * for now.  It's fine, the AR9285 doesn't really use 	 * that. 	 * 	 * Later on we should store away the fine grained LNA 	 * information and keep separate counters just for 	 * that.  It'll help when debugging the AR9285/AR9485 	 * combined diversity code. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rx_lnamixer
condition|)
block|{
name|rs
operator|->
name|rs_antenna
operator|=
literal|0
expr_stmt|;
comment|/* Bits 0:1 - the LNA configuration used */
name|rs
operator|->
name|rs_antenna
operator||=
operator|(
operator|(
name|rs
operator|->
name|rs_rssi_ctl
index|[
literal|2
index|]
operator|&
name|HAL_RX_LNA_CFG_USED
operator|)
operator|>>
name|HAL_RX_LNA_CFG_USED_S
operator|)
expr_stmt|;
comment|/* Bit 2 - the external RX antenna switch */
if|if
condition|(
name|rs
operator|->
name|rs_rssi_ctl
index|[
literal|2
index|]
operator|&
name|HAL_RX_LNA_EXTCFG
condition|)
name|rs
operator|->
name|rs_antenna
operator||=
literal|0x4
expr_stmt|;
block|}
name|sc
operator|->
name|sc_stats
operator|.
name|ast_ant_rx
index|[
name|rs
operator|->
name|rs_antenna
index|]
operator|++
expr_stmt|;
comment|/* 	 * Populate the rx status block.  When there are bpf 	 * listeners we do the additional work to provide 	 * complete status.  Otherwise we fill in only the 	 * material required by ieee80211_input.  Note that 	 * noise setting is filled in above. 	 */
if|if
condition|(
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|ath_rx_tap
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|rstamp
argument_list|,
name|nf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_ENABLE_RADIOTAP_VENDOR_EXT
name|ath_rx_tap_vendor
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|rs
argument_list|,
name|rstamp
argument_list|,
name|nf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_ENABLE_RADIOTAP_VENDOR_EXT */
block|}
comment|/* 	 * From this point on we assume the frame is at least 	 * as large as ieee80211_frame_min; verify that. 	 */
if|if
condition|(
name|len
operator|<
name|IEEE80211_MIN_LEN
condition|)
block|{
if|if
condition|(
operator|!
name|ieee80211_radiotap_active
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: short packet %d\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_tooshort
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* NB: in particular this captures ack's */
name|ieee80211_radiotap_rx_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
goto|goto
name|rx_next
goto|;
block|}
if|if
condition|(
name|IFF_DUMPPKTS
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|)
condition|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|uint8_t
name|rix
init|=
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
decl_stmt|;
name|ieee80211_dump_pkt
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
name|sc
operator|->
name|sc_hwmap
index|[
name|rix
index|]
operator|.
name|ieeerate
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|)
expr_stmt|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|IEEE80211_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the node for sender, track state, and then 	 * pass the (referenced) node up to the 802.11 layer 	 * for its use. 	 */
name|ni
operator|=
name|ieee80211_find_rxnode_withkey
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
argument_list|,
name|rs
operator|->
name|rs_keyix
operator|==
name|HAL_RXKEYIX_INVALID
condition|?
name|IEEE80211_KEYIX_NONE
else|:
name|rs
operator|->
name|rs_keyix
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_lastrs
operator|=
name|rs
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_isaggr
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_agg
operator|++
expr_stmt|;
comment|/* 	 * Populate the per-chain RSSI values where appropriate. 	 */
name|bzero
argument_list|(
operator|&
name|rxs
argument_list|,
sizeof|sizeof
argument_list|(
name|rxs
argument_list|)
argument_list|)
expr_stmt|;
name|rxs
operator|.
name|r_flags
operator||=
name|IEEE80211_R_NF
operator||
name|IEEE80211_R_RSSI
operator||
name|IEEE80211_R_C_CHAIN
operator||
name|IEEE80211_R_C_NF
operator||
name|IEEE80211_R_C_RSSI
operator||
name|IEEE80211_R_TSF64
operator||
name|IEEE80211_R_TSF_START
expr_stmt|;
comment|/* XXX TODO: validate */
name|rxs
operator|.
name|c_rssi
operator|=
name|rs
operator|->
name|rs_rssi
expr_stmt|;
name|rxs
operator|.
name|c_nf
operator|=
name|nf
expr_stmt|;
name|rxs
operator|.
name|c_chain
operator|=
literal|3
expr_stmt|;
comment|/* XXX TODO: check */
name|rxs
operator|.
name|c_rx_tsf
operator|=
name|rstamp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|rxs
operator|.
name|c_rssi_ctl
index|[
name|i
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ctl
index|[
name|i
index|]
expr_stmt|;
name|rxs
operator|.
name|c_rssi_ext
index|[
name|i
index|]
operator|=
name|rs
operator|->
name|rs_rssi_ext
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * XXX note: we currently don't track 		 * per-chain noisefloor. 		 */
name|rxs
operator|.
name|c_nf_ctl
index|[
name|i
index|]
operator|=
name|nf
expr_stmt|;
name|rxs
operator|.
name|c_nf_ext
index|[
name|i
index|]
operator|=
name|nf
expr_stmt|;
block|}
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only punt packets for ampdu reorder processing for 		 * 11n nodes; net80211 enforces that M_AMPDU is only 		 * set for 11n nodes. 		 */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU
expr_stmt|;
comment|/* 		 * Sending station is known, dispatch directly. 		 */
operator|(
name|void
operator|)
name|ieee80211_add_rx_params
argument_list|(
name|m
argument_list|,
operator|&
name|rxs
argument_list|)
expr_stmt|;
name|type
operator|=
name|ieee80211_input_mimo
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Arrange to update the last rx timestamp only for 		 * frames from our ap when operating in station mode. 		 * This assumes the rx key is always setup when 		 * associated. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|rs
operator|->
name|rs_keyix
operator|!=
name|HAL_RXKEYIX_INVALID
condition|)
name|is_good
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ieee80211_add_rx_params
argument_list|(
name|m
argument_list|,
operator|&
name|rxs
argument_list|)
expr_stmt|;
name|type
operator|=
name|ieee80211_input_mimo_all
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * At this point we have passed the frame up the stack; thus 	 * the mbuf is no longer ours. 	 */
comment|/* 	 * Track rx rssi and do any rx antenna management. 	 */
name|ATH_RSSI_LPF
argument_list|(
name|sc
operator|->
name|sc_halstats
operator|.
name|ns_avgrssi
argument_list|,
name|rs
operator|->
name|rs_rssi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_diversity
condition|)
block|{
comment|/* 		 * When using fast diversity, change the default rx 		 * antenna if diversity chooses the other antenna 3 		 * times in a row. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_defant
operator|!=
name|rs
operator|->
name|rs_antenna
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_rxotherant
operator|>=
literal|3
condition|)
name|ath_setdefantenna
argument_list|(
name|sc
argument_list|,
name|rs
operator|->
name|rs_antenna
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_rxotherant
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Handle slow diversity if enabled */
if|if
condition|(
name|sc
operator|->
name|sc_dolnadiv
condition|)
block|{
name|ath_lna_rx_comb_scan
argument_list|(
name|sc
argument_list|,
name|rs
argument_list|,
name|ticks
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_softled
condition|)
block|{
comment|/* 		 * Blink for any data frame.  Otherwise do a 		 * heartbeat-style blink when idle.  The latter 		 * is mainly for station mode where we depend on 		 * periodic beacon frames to trigger the poll event. 		 */
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
specifier|const
name|HAL_RATE_TABLE
modifier|*
name|rt
init|=
name|sc
operator|->
name|sc_currates
decl_stmt|;
name|ath_led_event
argument_list|(
name|sc
argument_list|,
name|rt
operator|->
name|rateCodeToIndex
index|[
name|rs
operator|->
name|rs_rate
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ticks
operator|-
name|sc
operator|->
name|sc_ledevent
operator|>=
name|sc
operator|->
name|sc_ledidle
condition|)
name|ath_led_event
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rx_next
label|:
comment|/* 	 * Debugging - complain if we didn't NULL the mbuf pointer 	 * here. 	 */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: mbuf %p should've been freed!\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|is_good
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ATH_RX_MAX
value|128
end_define

begin_comment
comment|/*  * XXX TODO: break out the "get buffers" from "call ath_rx_pkt()" like  * the EDMA code does.  *  * XXX TODO: then, do all of the RX list management stuff inside  * ATH_RX_LOCK() so we don't end up potentially racing.  The EDMA  * code is doing it right.  */
end_comment

begin_function
specifier|static
name|void
name|ath_rx_proc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|resched
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|&
name|sc
operator|->
name|sc_ic
decl_stmt|;
endif|#
directive|endif
name|struct
name|ath_desc
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ngood
decl_stmt|;
name|HAL_STATUS
name|status
decl_stmt|;
name|int16_t
name|nf
decl_stmt|;
name|u_int64_t
name|tsf
decl_stmt|;
name|int
name|npkts
init|=
literal|0
decl_stmt|;
name|int
name|kickpcu
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* XXX we must not hold the ATH_LOCK here */
name|ATH_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|++
expr_stmt|;
name|kickpcu
operator|=
name|sc
operator|->
name|sc_kickpcu
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_set_power_state
argument_list|(
name|sc
argument_list|,
name|HAL_PM_AWAKE
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RX_PROC
argument_list|,
literal|"%s: called\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ngood
operator|=
literal|0
expr_stmt|;
name|nf
operator|=
name|ath_hal_getchannoise
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_noise
operator|=
name|nf
expr_stmt|;
name|tsf
operator|=
name|ath_hal_gettsf64
argument_list|(
name|ah
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 		 * Don't process too many packets at a time; give the 		 * TX thread time to also run - otherwise the TX 		 * latency can jump by quite a bit, causing throughput 		 * degredation. 		 */
if|if
condition|(
operator|!
name|kickpcu
operator|&&
name|npkts
operator|>=
name|ATH_RX_MAX
condition|)
break|break;
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxslink
operator|&&
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: no buffer!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * End of List: 			 * this can happen for non-self-linked RX chains 			 */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_hitqueueend
operator|++
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|bf
operator|->
name|bf_m
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: shouldn't happen */
comment|/* 			 * If mbuf allocation failed previously there 			 * will be no mbuf; try again to re-populate it. 			 */
comment|/* XXX make debug msg */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: no mbuf!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
goto|goto
name|rx_proc_next
goto|;
block|}
name|ds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_link
operator|==
name|bf
operator|->
name|bf_daddr
condition|)
block|{
comment|/* NB: never process the self-linked entry at the end */
name|sc
operator|->
name|sc_stats
operator|.
name|ast_rx_hitqueueend
operator|++
expr_stmt|;
break|break;
block|}
comment|/* XXX sync descriptor memory */
comment|/* 		 * Must provide the virtual address of the current 		 * descriptor, the physical address, and the virtual 		 * address of the next descriptor in the h/w chain. 		 * This allows the HAL to look ahead to see if the 		 * hardware is done with a descriptor by checking the 		 * done bit in the following descriptor and the address 		 * of the current descriptor the DMA engine is working 		 * on.  All this is necessary because of our use of 		 * a self-linked list to avoid rx overruns. 		 */
name|rs
operator|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
expr_stmt|;
name|status
operator|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|,
name|rs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_RECV_DESC
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
literal|0
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATH_DEBUG_ALQ
if|if
condition|(
name|if_ath_alq_checkdebug
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_RXSTATUS
argument_list|)
condition|)
name|if_ath_alq_post
argument_list|(
operator|&
name|sc
operator|->
name|sc_alq
argument_list|,
name|ATH_ALQ_EDMA_RXSTATUS
argument_list|,
name|sc
operator|->
name|sc_rx_statuslen
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ds
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATH_DEBUG_ALQ */
if|if
condition|(
name|status
operator|==
name|HAL_EINPROGRESS
condition|)
break|break;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|npkts
operator|++
expr_stmt|;
comment|/* 		 * Process a single frame. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ath_rx_pkt
argument_list|(
name|sc
argument_list|,
name|rs
argument_list|,
name|status
argument_list|,
name|tsf
argument_list|,
name|nf
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|,
name|bf
argument_list|,
name|m
argument_list|)
condition|)
name|ngood
operator|++
expr_stmt|;
name|rx_proc_next
label|:
comment|/* 		 * If there's a holding buffer, insert that onto 		 * the RX list; the hardware is now definitely not pointing 		 * to it now. 		 */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_holdbf
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_holdbf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_holdbf
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Next, throw our buffer into the holding entry.  The hardware 		 * may use the descriptor to read the link pointer before 		 * DMAing the next descriptor in to write out a packet. 		 */
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_holdbf
operator|=
name|bf
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
literal|0
condition|)
do|;
comment|/* rx signal state monitoring */
name|ath_hal_rxmonitor
argument_list|(
name|ah
argument_list|,
operator|&
name|sc
operator|->
name|sc_halstats
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngood
condition|)
name|sc
operator|->
name|sc_lastrx
operator|=
name|tsf
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_RXPROC
argument_list|,
literal|2
argument_list|,
literal|"ath_rx_proc: npkts=%d, ngood=%d"
argument_list|,
name|npkts
argument_list|,
name|ngood
argument_list|)
expr_stmt|;
comment|/* Queue DFS tasklet if needed */
if|if
condition|(
name|resched
operator|&&
name|ath_dfs_tasklet_needed
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_curchan
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_dfstask
argument_list|)
expr_stmt|;
comment|/* 	 * Now that all the RX frames were handled that 	 * need to be handled, kick the PCU if there's 	 * been an RXEOL condition. 	 */
if|if
condition|(
name|resched
operator|&&
name|kickpcu
condition|)
block|{
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_ERROR
argument_list|,
literal|0
argument_list|,
literal|"ath_rx_proc: kickpcu"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: kickpcu; handled %d packets\n"
argument_list|,
name|__func__
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
comment|/* 		 * Go through the process of fully tearing down 		 * the RX buffers and reinitialising them. 		 * 		 * There's a hardware bug that causes the RX FIFO 		 * to get confused under certain conditions and 		 * constantly write over the same frame, leading 		 * the RX driver code here to get heavily confused. 		 */
comment|/* 		 * XXX Has RX DMA stopped enough here to just call 		 *     ath_startrecv()? 		 * XXX Do we need to use the holding buffer to restart 		 *     RX DMA by appending entries to the final 		 *     descriptor?  Quite likely. 		 */
if|#
directive|if
literal|1
name|ath_startrecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * Disabled for now - it'd be nice to be able to do 		 * this in order to limit the amount of CPU time spent 		 * reinitialising the RX side (and thus minimise RX 		 * drops) however there's a hardware issue that 		 * causes things to get too far out of whack. 		 */
comment|/* 		 * XXX can we hold the PCU lock here? 		 * Are there any net80211 buffer calls involved? 		 */
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
endif|#
directive|endif
name|ath_hal_intrset
argument_list|(
name|ah
argument_list|,
name|sc
operator|->
name|sc_imask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_kickpcu
operator|=
literal|0
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|resched
condition|)
name|ieee80211_ff_age_all
argument_list|(
name|ic
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Put the hardware to sleep again if we're done with it. 	 */
name|ATH_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_power_restore_power_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ATH_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If we hit the maximum number of frames in this round, 	 * reschedule for another immediate pass.  This gives 	 * the TX and TX completion routines time to run, which 	 * will reduce latency. 	 */
if|if
condition|(
name|npkts
operator|>=
name|ATH_RX_MAX
condition|)
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched
argument_list|(
name|sc
argument_list|,
name|resched
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxproc_cnt
operator|--
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|PA2DESC
end_undef

begin_undef
undef|#
directive|undef
name|ATH_RX_MAX
end_undef

begin_comment
comment|/*  * Only run the RX proc if it's not already running.  * Since this may get run as part of the reset/flush path,  * the task can't clash with an existing, running tasklet.  */
end_comment

begin_function
specifier|static
name|void
name|ath_legacy_rx_tasklet
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ath_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|ATH_KTR
argument_list|(
name|sc
argument_list|,
name|ATH_KTR_RXPROC
argument_list|,
literal|1
argument_list|,
literal|"ath_rx_proc: pending=%d"
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RX_PROC
argument_list|,
literal|"%s: pending %u\n"
argument_list|,
name|__func__
argument_list|,
name|npending
argument_list|)
expr_stmt|;
name|ATH_PCU_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inreset_cnt
operator|>
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: sc_inreset_cnt> 0; skipping\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|ATH_PCU_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_rx_proc
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_legacy_flushrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ath_rx_proc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_legacy_flush_rxpending
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX ATH_RX_LOCK_ASSERT(sc); */
if|if
condition|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_rxpending
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_rxpending
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_rxpending
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ath_legacy_flush_rxholdbf
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
comment|/* XXX ATH_RX_LOCK_ASSERT(sc); */
comment|/* 	 * If there are RX holding buffers, free them here and return 	 * them to the list. 	 * 	 * XXX should just verify that bf->bf_m is NULL, as it must 	 * be at this point! 	 */
name|bf
operator|=
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_holdbf
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_HP
index|]
operator|.
name|m_holdbf
operator|=
name|NULL
expr_stmt|;
name|bf
operator|=
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_holdbf
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_rxedma
index|[
name|HAL_RX_QUEUE_LP
index|]
operator|.
name|m_holdbf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable the receive h/w in preparation for a reset.  */
end_comment

begin_function
specifier|static
name|void
name|ath_legacy_stoprecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dodelay
parameter_list|)
block|{
define|#
directive|define
name|PA2DESC
parameter_list|(
name|_sc
parameter_list|,
name|_pa
parameter_list|)
define|\
value|((struct ath_desc *)((caddr_t)(_sc)->sc_rxdma.dd_desc + \ 		((_pa) - (_sc)->sc_rxdma.dd_desc_paddr)))
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ath_hal_stoppcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable PCU */
name|ath_hal_setrxfilter
argument_list|(
name|ah
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear recv filter */
name|ath_hal_stopdmarecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* disable DMA engine */
comment|/* 	 * TODO: see if this particular DELAY() is required; it may be 	 * masking some missing FIFO flush or DMA sync. 	 */
if|#
directive|if
literal|0
block|if (dodelay)
endif|#
directive|endif
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* 3ms is long enough for 1 frame */
ifdef|#
directive|ifdef
name|ATH_DEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
operator|&
operator|(
name|ATH_DEBUG_RESET
operator||
name|ATH_DEBUG_FATAL
operator|)
condition|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|u_int
name|ix
decl_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: rx queue %p, link %p\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ath_hal_getrxbuf
argument_list|(
name|ah
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_rxlink
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|struct
name|ath_desc
modifier|*
name|ds
init|=
name|bf
operator|->
name|bf_desc
decl_stmt|;
name|struct
name|ath_rx_status
modifier|*
name|rs
init|=
operator|&
name|bf
operator|->
name|bf_status
operator|.
name|ds_rxstat
decl_stmt|;
name|HAL_STATUS
name|status
init|=
name|ath_hal_rxprocdesc
argument_list|(
name|ah
argument_list|,
name|ds
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|PA2DESC
argument_list|(
name|sc
argument_list|,
name|ds
operator|->
name|ds_link
argument_list|)
argument_list|,
name|rs
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|HAL_OK
operator|||
operator|(
name|sc
operator|->
name|sc_debug
operator|&
name|ATH_DEBUG_FATAL
operator|)
condition|)
name|ath_printrxbuf
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|,
name|ix
argument_list|,
name|status
operator|==
name|HAL_OK
argument_list|)
expr_stmt|;
name|ix
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|ath_legacy_flush_rxpending
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_legacy_flush_rxholdbf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
comment|/* just in case */
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PA2DESC
block|}
end_function

begin_comment
comment|/*  * XXX TODO: something was calling startrecv without calling  * stoprecv.  Let's figure out what/why.  It was showing up  * as a mbuf leak (rxpending) and ath_buf leak (holdbf.)  */
end_comment

begin_comment
comment|/*  * Enable the receive h/w following a reset.  */
end_comment

begin_function
specifier|static
name|int
name|ath_legacy_startrecv
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ath_hal
modifier|*
name|ah
init|=
name|sc
operator|->
name|sc_ah
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|ATH_RX_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX should verify these are already all NULL! 	 */
name|sc
operator|->
name|sc_rxlink
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|ath_legacy_flush_rxpending
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ath_legacy_flush_rxholdbf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Re-chain all of the buffers in the RX buffer list. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|&sc->sc_rxbuf
argument_list|,
argument|bf_list
argument_list|)
block|{
name|int
name|error
init|=
name|ath_rxbuf_init
argument_list|(
name|sc
argument_list|,
name|bf
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RECV
argument_list|,
literal|"%s: ath_rxbuf_init failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|bf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
name|ath_hal_putrxbuf
argument_list|(
name|ah
argument_list|,
name|bf
operator|->
name|bf_daddr
argument_list|,
name|HAL_RX_QUEUE_HP
argument_list|)
expr_stmt|;
name|ath_hal_rxena
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* enable recv descriptors */
name|ath_mode_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* set filters, etc. */
name|ath_hal_startpcurecv
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* re-enable PCU/DMA engine */
name|ATH_RX_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_legacy_dma_rxsetup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ath_descdma_setup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|,
literal|"rx"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
argument_list|,
name|ath_rxbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ath_legacy_dma_rxteardown
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rxdma
operator|.
name|dd_desc_len
operator|!=
literal|0
condition|)
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxdma
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_legacy_recv_sched
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ath_legacy_recv_sched_queue
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|HAL_RX_QUEUE
name|q
parameter_list|,
name|int
name|dosched
parameter_list|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|sc_tq
argument_list|,
operator|&
name|sc
operator|->
name|sc_rxtask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ath_recv_setup_legacy
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Sensible legacy defaults */
comment|/* 	 * XXX this should be changed to properly support the 	 * exact RX descriptor size for each HAL. 	 */
name|sc
operator|->
name|sc_rx_statuslen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_desc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_start
operator|=
name|ath_legacy_startrecv
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_stop
operator|=
name|ath_legacy_stoprecv
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_flush
operator|=
name|ath_legacy_flushrecv
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_tasklet
operator|=
name|ath_legacy_rx_tasklet
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_rxbuf_init
operator|=
name|ath_legacy_rxbuf_init
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_setup
operator|=
name|ath_legacy_dma_rxsetup
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_teardown
operator|=
name|ath_legacy_dma_rxteardown
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched
operator|=
name|ath_legacy_recv_sched
expr_stmt|;
name|sc
operator|->
name|sc_rx
operator|.
name|recv_sched_queue
operator|=
name|ath_legacy_recv_sched_queue
expr_stmt|;
block|}
end_function

end_unit

