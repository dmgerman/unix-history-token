begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for the Atheros Wireless LAN controller.  *  * This software is derived from work of Atsushi Onoe; his contribution  * is greatly appreciated.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ath.h"
end_include

begin_comment
comment|/*  * This is needed for register operations which are performed  * by the driver - eg, calls to ath_hal_gettsf32().  *  * It's also required for any AH_DEBUG checks in here, eg the  * module dependencies.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ah.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_comment
comment|/* for mp_ncpus */
end_comment

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_athvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_devid.h>
end_include

begin_comment
comment|/* XXX for softled */
end_comment

begin_include
include|#
directive|include
file|<dev/ath/ath_hal/ah_diagcodes.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_misc.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tsf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_led.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_keycache.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_rx_edma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_tx_edma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_beacon.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_btcoex.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_spectral.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_ath_lna_div.h>
end_include

begin_include
include|#
directive|include
file|<dev/ath/if_athdfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ath/if_ath_descdma.h>
end_include

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_ATHDEV
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This is the descriptor setup / busdma memory intialisation and  * teardown routines.  */
end_comment

begin_function
specifier|static
name|void
name|ath_load_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"error %u on bus_dma callback"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate the descriptors and appropriate DMA tag/setup.  *  * For some situations (eg EDMA TX completion), there isn't a requirement  * for the ath_buf entries to be allocated.  */
end_comment

begin_function
name|int
name|ath_descdma_alloc_desc
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|ds_size
parameter_list|,
name|int
name|ndesc
parameter_list|)
block|{
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
define|#
directive|define
name|ATH_DESC_4KB_BOUND_CHECK
parameter_list|(
name|_daddr
parameter_list|,
name|_len
parameter_list|)
define|\
value|((((u_int32_t)(_daddr)& 0xFFF)> (0x1000 - (_len))) ? 1 : 0)
name|int
name|error
decl_stmt|;
name|dd
operator|->
name|dd_descsize
operator|=
name|ds_size
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u desc, %d bytes per descriptor\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_descsize
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|=
name|dd
operator|->
name|dd_descsize
operator|*
name|ndesc
expr_stmt|;
comment|/* 	 * Merlin work-around: 	 * Descriptors that cross the 4KB boundary can't be used. 	 * Assume one skipped descriptor per 4KB page. 	 */
if|if
condition|(
operator|!
name|ath_hal_split4ktrans
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
name|int
name|numpages
init|=
name|dd
operator|->
name|dd_desc_len
operator|/
literal|4096
decl_stmt|;
name|dd
operator|->
name|dd_desc_len
operator|+=
name|ds_size
operator|*
name|numpages
expr_stmt|;
block|}
comment|/* 	 * Setup DMA descriptor area. 	 * 	 * BUS_DMA_ALLOCNOW is not used; we never use bounce 	 * buffers for the descriptors themselves. 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|dd
operator|->
name|dd_desc_len
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate %s DMA tag\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* allocate descriptors */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dd
operator|->
name|dd_desc
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to alloc memory for %u %s descriptors, error %u\n"
argument_list|,
name|ndesc
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_desc_len
argument_list|,
name|ath_load_cb
argument_list|,
operator|&
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to map %s descriptors, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA map: %p (%lu) -> %p (%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|dd
operator|->
name|dd_desc
argument_list|,
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|,
operator|(
name|caddr_t
operator|)
name|dd
operator|->
name|dd_desc_paddr
argument_list|,
comment|/*XXX*/
operator|(
name|u_long
operator|)
name|dd
operator|->
name|dd_desc_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|fail1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|DS2PHYS
undef|#
directive|undef
name|ATH_DESC_4KB_BOUND_CHECK
block|}
end_function

begin_function
name|int
name|ath_descdma_setup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|ds_size
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|int
name|ndesc
parameter_list|)
block|{
define|#
directive|define
name|DS2PHYS
parameter_list|(
name|_dd
parameter_list|,
name|_ds
parameter_list|)
define|\
value|((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))
define|#
directive|define
name|ATH_DESC_4KB_BOUND_CHECK
parameter_list|(
name|_daddr
parameter_list|,
name|_len
parameter_list|)
define|\
value|((((u_int32_t)(_daddr)& 0xFFF)> (0x1000 - (_len))) ? 1 : 0)
name|uint8_t
modifier|*
name|ds
decl_stmt|;
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
comment|/* Allocate descriptors */
name|error
operator|=
name|ath_descdma_alloc_desc
argument_list|(
name|sc
argument_list|,
name|dd
argument_list|,
name|head
argument_list|,
name|name
argument_list|,
name|ds_size
argument_list|,
name|nbuf
operator|*
name|ndesc
argument_list|)
expr_stmt|;
comment|/* Assume any errors during allocation were dealt with */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ds
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|dd
operator|->
name|dd_desc
expr_stmt|;
comment|/* allocate rx buffers */
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
argument_list|)
operator|*
name|nbuf
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_ATHDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"malloc of %s buffers failed, size %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|dd
operator|->
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
operator|,
name|ds
operator|+=
operator|(
name|ndesc
operator|*
name|dd
operator|->
name|dd_descsize
operator|)
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
name|dd
argument_list|,
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ath_hal_split4ktrans
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|)
condition|)
block|{
comment|/* 			 * Merlin WAR: Skip descriptor addresses which 			 * cause 4KB boundary crossing along any point 			 * in the descriptor. 			 */
if|if
condition|(
name|ATH_DESC_4KB_BOUND_CHECK
argument_list|(
name|bf
operator|->
name|bf_daddr
argument_list|,
name|dd
operator|->
name|dd_descsize
argument_list|)
condition|)
block|{
comment|/* Start at the next page */
name|ds
operator|+=
literal|0x1000
operator|-
operator|(
name|bf
operator|->
name|bf_daddr
operator|&
literal|0xFFF
operator|)
expr_stmt|;
name|bf
operator|->
name|bf_desc
operator|=
operator|(
expr|struct
name|ath_desc
operator|*
operator|)
name|ds
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
name|DS2PHYS
argument_list|(
name|dd
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create dmamap "
literal|"for %s buffer %u, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
name|dd
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bf
operator|->
name|bf_lastds
operator|=
name|bf
operator|->
name|bf_desc
expr_stmt|;
comment|/* Just an initial value */
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX TODO: ensure that ds doesn't overflow the descriptor 	 * allocation otherwise weird stuff will occur and crash your 	 * machine. 	 */
return|return
literal|0
return|;
comment|/* XXX this should likely just call ath_descdma_cleanup() */
name|fail3
label|:
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|DS2PHYS
undef|#
directive|undef
name|ATH_DESC_4KB_BOUND_CHECK
block|}
end_function

begin_comment
comment|/*  * Allocate ath_buf entries but no descriptor contents.  *  * This is for RX EDMA where the descriptors are the header part of  * the RX buffer.  */
end_comment

begin_function
name|int
name|ath_descdma_setup_rx_edma
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nbuf
parameter_list|,
name|int
name|rx_status_len
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bsize
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
argument_list|,
name|ATH_DEBUG_RESET
argument_list|,
literal|"%s: %s DMA: %u buffers\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_name
operator|=
name|name
expr_stmt|;
comment|/* 	 * This is (mostly) purely for show.  We're not allocating any actual 	 * descriptors here as EDMA RX has the descriptor be part 	 * of the RX buffer. 	 * 	 * However, dd_desc_len is used by ath_descdma_free() to determine 	 * whether we have already freed this DMA mapping. 	 */
name|dd
operator|->
name|dd_desc_len
operator|=
name|rx_status_len
operator|*
name|nbuf
expr_stmt|;
name|dd
operator|->
name|dd_descsize
operator|=
name|rx_status_len
expr_stmt|;
comment|/* allocate rx buffers */
name|bsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ath_buf
argument_list|)
operator|*
name|nbuf
expr_stmt|;
name|bf
operator|=
name|malloc
argument_list|(
name|bsize
argument_list|,
name|M_ATHDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"malloc of %s buffers failed, size %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|dd
operator|->
name|dd_bufptr
operator|=
name|bf
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
operator|,
name|bf
operator|++
control|)
block|{
name|bf
operator|->
name|bf_desc
operator|=
name|NULL
expr_stmt|;
name|bf
operator|->
name|bf_daddr
operator|=
literal|0
expr_stmt|;
name|bf
operator|->
name|bf_lastds
operator|=
name|NULL
expr_stmt|;
comment|/* Just an initial value */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unable to create dmamap "
literal|"for %s buffer %u, error %u\n"
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|,
name|i
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ath_descdma_cleanup
argument_list|(
name|sc
argument_list|,
name|dd
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|bf
argument_list|,
name|bf_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|fail3
label|:
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|ath_descdma_cleanup
parameter_list|(
name|struct
name|ath_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ath_descdma
modifier|*
name|dd
parameter_list|,
name|ath_bufhead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|ath_buf
modifier|*
name|bf
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|do_warning
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dd
operator|->
name|dd_dmamap
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|,
name|dd
operator|->
name|dd_desc
argument_list|,
name|dd
operator|->
name|dd_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dd
operator|->
name|dd_dmat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|bf
argument_list|,
argument|head
argument_list|,
argument|bf_list
argument_list|)
block|{
if|if
condition|(
name|bf
operator|->
name|bf_m
condition|)
block|{
comment|/* 				 * XXX warn if there's buffers here. 				 * XXX it should have been freed by the 				 * owner! 				 */
if|if
condition|(
name|do_warning
operator|==
literal|0
condition|)
block|{
name|do_warning
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %s: mbuf should've been"
literal|" unmapped/freed!\n"
argument_list|,
name|__func__
argument_list|,
name|dd
operator|->
name|dd_name
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bf
operator|->
name|bf_m
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bf
operator|->
name|bf_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|bf
operator|->
name|bf_dmamap
argument_list|)
expr_stmt|;
name|bf
operator|->
name|bf_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
name|ni
operator|=
name|bf
operator|->
name|bf_node
expr_stmt|;
name|bf
operator|->
name|bf_node
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Reclaim node reference. 				 */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
name|TAILQ_INIT
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|->
name|dd_bufptr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dd
operator|->
name|dd_bufptr
argument_list|,
name|M_ATHDEV
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

