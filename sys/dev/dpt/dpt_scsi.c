begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *       Copyright (c) 1997 by Simon Shapiro  *       All Rights Reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_empty
empty|#ident "$FreeBSD$"
end_empty

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * dpt_scsi.c: SCSI dependant code for the DPT driver  *  * credits:	Assisted by Mike Neuffer in the early low level DPT code  *		Thanx to Mark Salyzyn of DPT for his assistance.  *		Special thanx to Justin Gibbs for invaluable help in  *		making this driver look and work like a FreeBSD component.  *		Last but not least, many thanx to UCB and the FreeBSD  *		team for creating and maintaining such a wonderful O/S.  *  * TODO:     * Add ISA probe code.  *	     * Add driver-level RAID-0. This will allow interoperability with  *	       NiceTry, M$-Doze, Win-Dog, Slowlaris, etc., in recognizing RAID  *	       arrays that span controllers (Wow!).  */
end_comment

begin_define
define|#
directive|define
name|_DPT_C_
end_define

begin_include
include|#
directive|include
file|"opt_dpt.h"
end_include

begin_include
include|#
directive|include
file|"opt_eisa.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/dpt/dpt.h>
end_include

begin_comment
comment|/* dpt_isa.c, dpt_eisa.c, and dpt_pci.c need this in a central place */
end_comment

begin_decl_stmt
name|int
name|dpt_controllers_present
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|dpt_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|microtime_now
value|dpt_time_now()
end_define

begin_define
define|#
directive|define
name|dpt_inl
parameter_list|(
name|dpt
parameter_list|,
name|port
parameter_list|)
define|\
value|bus_space_read_4((dpt)->tag, (dpt)->bsh, port)
end_define

begin_define
define|#
directive|define
name|dpt_inb
parameter_list|(
name|dpt
parameter_list|,
name|port
parameter_list|)
define|\
value|bus_space_read_1((dpt)->tag, (dpt)->bsh, port)
end_define

begin_define
define|#
directive|define
name|dpt_outl
parameter_list|(
name|dpt
parameter_list|,
name|port
parameter_list|,
name|value
parameter_list|)
define|\
value|bus_space_write_4((dpt)->tag, (dpt)->bsh, port, value)
end_define

begin_define
define|#
directive|define
name|dpt_outb
parameter_list|(
name|dpt
parameter_list|,
name|port
parameter_list|,
name|value
parameter_list|)
define|\
value|bus_space_write_1((dpt)->tag, (dpt)->bsh, port, value)
end_define

begin_comment
comment|/*  * These will have to be setup by parameters passed at boot/load time. For  * perfromance reasons, we make them constants for the time being.  */
end_comment

begin_define
define|#
directive|define
name|dpt_min_segs
value|DPT_MAX_SEGS
end_define

begin_define
define|#
directive|define
name|dpt_max_segs
value|DPT_MAX_SEGS
end_define

begin_comment
comment|/* Definitions for our use of the SIM private CCB area */
end_comment

begin_define
define|#
directive|define
name|ccb_dccb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_dpt_ptr
value|spriv_ptr1
end_define

begin_comment
comment|/* ================= Private Inline Function declarations ===================*/
end_comment

begin_function_decl
specifier|static
name|__inline
name|int
name|dpt_just_reset
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|dpt_raid_busy
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_EISA
end_ifdef

begin_function_decl
specifier|static
name|__inline
name|int
name|dpt_pio_wait
parameter_list|(
name|u_int32_t
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|__inline
name|int
name|dpt_wait
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|u_int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|dpt_ccb
operator|*
name|dptgetccb
argument_list|(
expr|struct
name|dpt_softc
operator|*
name|dpt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|dptfreeccb
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|,
name|struct
name|dpt_ccb
modifier|*
name|dccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|bus_addr_t
name|dptccbvtop
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|,
name|struct
name|dpt_ccb
modifier|*
name|dccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|dpt_send_immediate
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int32_t
name|cmd_busaddr
parameter_list|,
name|u_int
name|retries
parameter_list|,
name|u_int
name|ifc
parameter_list|,
name|u_int
name|code
parameter_list|,
name|u_int
name|code2
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ==================== Private Function declarations =======================*/
end_comment

begin_function_decl
specifier|static
name|void
name|dptmapmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sg_map_node
modifier|*
name|dptallocsgmap
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dptallocccbs
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_get_conf
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|dccb
parameter_list|,
name|u_int32_t
name|dccb_busaddr
parameter_list|,
name|u_int
name|size
parameter_list|,
name|u_int
name|page
parameter_list|,
name|u_int
name|target
parameter_list|,
name|int
name|extent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_detect_cache
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|dccb
parameter_list|,
name|u_int32_t
name|dccb_busaddr
parameter_list|,
name|u_int8_t
modifier|*
name|buff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dptexecuteccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_send_eata_command
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd
parameter_list|,
name|u_int32_t
name|cmd_busaddr
parameter_list|,
name|u_int
name|command
parameter_list|,
name|u_int
name|retries
parameter_list|,
name|u_int
name|ifc
parameter_list|,
name|u_int
name|code
parameter_list|,
name|u_int
name|code2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dptprocesserror
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|dccb
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int
name|hba_stat
parameter_list|,
name|u_int
name|scsi_stat
parameter_list|,
name|u_int32_t
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dptshutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ================= Private Inline Function definitions ====================*/
end_comment

begin_function
specifier|static
name|__inline
name|int
name|dpt_just_reset
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|2
argument_list|)
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|3
argument_list|)
operator|==
literal|'P'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|4
argument_list|)
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|5
argument_list|)
operator|==
literal|'H'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|dpt_raid_busy
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|0
argument_list|)
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|1
argument_list|)
operator|==
literal|'P'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|2
argument_list|)
operator|==
literal|'T'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_EISA
end_ifdef

begin_function
specifier|static
name|__inline
name|int
name|dpt_pio_wait
parameter_list|(
name|u_int32_t
name|base
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|u_int
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20000
condition|;
name|i
operator|++
control|)
block|{
comment|/* wait 20ms for not busy */
name|c
operator|=
name|inb
argument_list|(
name|base
operator|+
name|reg
argument_list|)
operator|&
name|bits
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
name|state
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|int
name|dpt_wait
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int
name|bits
parameter_list|,
name|u_int
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20000
condition|;
name|i
operator|++
control|)
block|{
comment|/* wait 20ms for not busy */
name|c
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
operator|&
name|bits
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|dpt_ccb
operator|*
name|dptgetccb
argument_list|(
argument|struct dpt_softc *dpt
argument_list|)
block|{ 	struct
name|dpt_ccb
operator|*
name|dccb
block|;
name|int
name|s
block|;
name|s
operator|=
name|splcam
argument_list|()
block|;
if|if
condition|(
operator|(
name|dccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|free_dccbs
operator|--
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|dpt
operator|->
name|total_dccbs
operator|<
name|dpt
operator|->
name|max_dccbs
condition|)
block|{
name|dptallocccbs
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|dccb
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|dccb
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"dpt%d: Can't malloc DCCB\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
else|else
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|free_dccbs
operator|--
expr_stmt|;
block|}
block|}
end_elseif

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|dccb
operator|)
return|;
end_return

begin_function
unit|}  static
name|__inline
name|void
name|dptfreeccb
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|,
name|struct
name|dpt_ccb
modifier|*
name|dccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dccb
operator|->
name|state
operator|&
name|DCCB_ACTIVE
operator|)
operator|!=
literal|0
condition|)
name|LIST_REMOVE
argument_list|(
operator|&
name|dccb
operator|->
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dccb
operator|->
name|state
operator|&
name|DCCB_RELEASE_SIMQ
operator|)
operator|!=
literal|0
condition|)
name|dccb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
elseif|else
if|if
condition|(
name|dpt
operator|->
name|resource_shortage
operator|!=
literal|0
operator|&&
operator|(
name|dccb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_RELEASE_SIMQ
operator|)
operator|==
literal|0
condition|)
block|{
name|dccb
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|dpt
operator|->
name|resource_shortage
operator|=
name|FALSE
expr_stmt|;
block|}
name|dccb
operator|->
name|state
operator|=
name|DCCB_FREE
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|,
name|dccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|++
name|dpt
operator|->
name|free_dccbs
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|bus_addr_t
name|dptccbvtop
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|,
name|struct
name|dpt_ccb
modifier|*
name|dccb
parameter_list|)
block|{
return|return
operator|(
name|dpt
operator|->
name|dpt_ccb_busbase
operator|+
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|dccb
operator|-
operator|(
name|caddr_t
operator|)
name|dpt
operator|->
name|dpt_dccbs
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|dpt_ccb
operator|*
name|dptccbptov
argument_list|(
argument|struct dpt_softc *dpt
argument_list|,
argument|bus_addr_t busaddr
argument_list|)
block|{
return|return
operator|(
name|dpt
operator|->
name|dpt_dccbs
operator|+
operator|(
operator|(
expr|struct
name|dpt_ccb
operator|*
operator|)
name|busaddr
operator|-
operator|(
expr|struct
name|dpt_ccb
operator|*
operator|)
name|dpt
operator|->
name|dpt_ccb_busbase
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Send a command for immediate execution by the DPT  * See above function for IMPORTANT notes.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|dpt_send_immediate
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int32_t
name|cmd_busaddr
parameter_list|,
name|u_int
name|retries
parameter_list|,
name|u_int
name|ifc
parameter_list|,
name|u_int
name|code
parameter_list|,
name|u_int
name|code2
parameter_list|)
block|{
return|return
operator|(
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
name|cmd_block
argument_list|,
name|cmd_busaddr
argument_list|,
name|EATA_CMD_IMMEDIATE
argument_list|,
name|retries
argument_list|,
name|ifc
argument_list|,
name|code
argument_list|,
name|code2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ===================== Private Function definitions =======================*/
end_comment

begin_function
specifier|static
name|void
name|dptmapmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|busaddrp
decl_stmt|;
name|busaddrp
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|busaddrp
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sg_map_node
modifier|*
name|dptallocsgmap
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|)
block|{
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|sg_map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg_map
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Allocate S/G space for the next batch of CCBS */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|dpt
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|dpt
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|dptmapmem
argument_list|,
operator|&
name|sg_map
operator|->
name|sg_physaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|sg_maps
argument_list|,
name|sg_map
argument_list|,
name|links
argument_list|)
expr_stmt|;
return|return
operator|(
name|sg_map
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate another chunk of CCB's. Return count of entries added.  * Assumed to be called at splcam().  */
end_comment

begin_function
specifier|static
name|int
name|dptallocccbs
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|struct
name|dpt_ccb
modifier|*
name|next_ccb
decl_stmt|;
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|bus_addr_t
name|physaddr
decl_stmt|;
name|dpt_sg_t
modifier|*
name|segs
decl_stmt|;
name|int
name|newcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|next_ccb
operator|=
operator|&
name|dpt
operator|->
name|dpt_dccbs
index|[
name|dpt
operator|->
name|total_dccbs
index|]
expr_stmt|;
if|if
condition|(
name|next_ccb
operator|==
name|dpt
operator|->
name|dpt_dccbs
condition|)
block|{
comment|/* 		 * First time through.  Re-use the S/G 		 * space we allocated for initialization 		 * CCBS. 		 */
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sg_map
operator|=
name|dptallocsgmap
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|segs
operator|=
name|sg_map
operator|->
name|sg_vaddr
expr_stmt|;
name|physaddr
operator|=
name|sg_map
operator|->
name|sg_physaddr
expr_stmt|;
name|newcount
operator|=
operator|(
name|PAGE_SIZE
operator|/
operator|(
name|dpt
operator|->
name|sgsize
operator|*
sizeof|sizeof
argument_list|(
name|dpt_sg_t
argument_list|)
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dpt
operator|->
name|total_dccbs
operator|<
name|dpt
operator|->
name|max_dccbs
operator|&&
name|i
operator|<
name|newcount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
operator|&
name|next_ccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|next_ccb
operator|->
name|sg_list
operator|=
name|segs
expr_stmt|;
name|next_ccb
operator|->
name|sg_busaddr
operator|=
name|htonl
argument_list|(
name|physaddr
argument_list|)
expr_stmt|;
name|next_ccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|physaddr
argument_list|)
expr_stmt|;
name|next_ccb
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|dpt
operator|->
name|sp_physaddr
argument_list|)
expr_stmt|;
name|next_ccb
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|dptccbvtop
argument_list|(
name|dpt
argument_list|,
name|next_ccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|dpt_ccb
argument_list|,
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|next_ccb
operator|->
name|eata_ccb
operator|.
name|cp_busaddr
operator|=
name|dpt
operator|->
name|dpt_ccb_busend
expr_stmt|;
name|next_ccb
operator|->
name|state
operator|=
name|DCCB_FREE
expr_stmt|;
name|next_ccb
operator|->
name|tag
operator|=
name|dpt
operator|->
name|total_dccbs
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|,
name|next_ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|segs
operator|+=
name|dpt
operator|->
name|sgsize
expr_stmt|;
name|physaddr
operator|+=
operator|(
name|dpt
operator|->
name|sgsize
operator|*
sizeof|sizeof
argument_list|(
name|dpt_sg_t
argument_list|)
operator|)
expr_stmt|;
name|dpt
operator|->
name|dpt_ccb_busend
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|next_ccb
argument_list|)
expr_stmt|;
name|next_ccb
operator|++
expr_stmt|;
name|dpt
operator|->
name|total_dccbs
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_EISA
end_ifdef

begin_function
name|dpt_conf_t
modifier|*
name|dpt_pio_get_conf
parameter_list|(
name|u_int32_t
name|base
parameter_list|)
block|{
specifier|static
name|dpt_conf_t
modifier|*
name|conf
decl_stmt|;
name|u_int16_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Allocate a dpt_conf_t 	 */
if|if
condition|(
operator|!
name|conf
condition|)
block|{
name|conf
operator|=
operator|(
name|dpt_conf_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dpt_conf_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we didn't get one then we probably won't ever get one. 	 */
if|if
condition|(
operator|!
name|conf
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: unable to allocate dpt_conf_t\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If we have one, clean it up. 	 */
name|bzero
argument_list|(
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_conf_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the controller. 	 */
name|outb
argument_list|(
operator|(
name|base
operator|+
name|HA_WCOMMAND
operator|)
argument_list|,
name|EATA_CMD_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the controller to become ready. 	 * For some reason there can be -no- delays after calling reset 	 * before we wait on ready status. 	 */
if|if
condition|(
name|dpt_pio_wait
argument_list|(
name|base
argument_list|,
name|HA_RSTATUS
argument_list|,
name|HA_SBUSY
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: timeout waiting for controller to become ready\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dpt_pio_wait
argument_list|(
name|base
argument_list|,
name|HA_RAUXSTAT
argument_list|,
name|HA_ABUSY
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: timetout waiting for adapter ready.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Send the PIO_READ_CONFIG command. 	 */
name|outb
argument_list|(
operator|(
name|base
operator|+
name|HA_WCOMMAND
operator|)
argument_list|,
name|EATA_CMD_PIO_READ_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Read the data into the struct. 	 */
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|conf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|dpt_conf_t
argument_list|)
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dpt_pio_wait
argument_list|(
name|base
argument_list|,
name|HA_RSTATUS
argument_list|,
name|HA_SDRQ
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"dpt: timeout in data read.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
operator|*
name|p
operator|)
operator|=
name|inw
argument_list|(
name|base
operator|+
name|HA_RDATA
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|inb
argument_list|(
name|base
operator|+
name|HA_RSTATUS
argument_list|)
operator|&
name|HA_SERROR
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"dpt: error reading configuration data.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
define|#
directive|define
name|BE_EATA_SIGNATURE
value|0x45415441
define|#
directive|define
name|LE_EATA_SIGNATURE
value|0x41544145
comment|/* 	 * Test to see if we have a valid card. 	 */
if|if
condition|(
operator|(
name|conf
operator|->
name|signature
operator|==
name|BE_EATA_SIGNATURE
operator|)
operator|||
operator|(
name|conf
operator|->
name|signature
operator|==
name|LE_EATA_SIGNATURE
operator|)
condition|)
block|{
while|while
condition|(
name|inb
argument_list|(
name|base
operator|+
name|HA_RSTATUS
argument_list|)
operator|&
name|HA_SDRQ
condition|)
block|{
name|inw
argument_list|(
name|base
operator|+
name|HA_RDATA
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|conf
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read a configuration page into the supplied dpt_cont_t buffer.  */
end_comment

begin_function
specifier|static
name|int
name|dpt_get_conf
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|dccb
parameter_list|,
name|u_int32_t
name|dccb_busaddr
parameter_list|,
name|u_int
name|size
parameter_list|,
name|u_int
name|page
parameter_list|,
name|u_int
name|target
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|eata_ccb_t
modifier|*
name|cp
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|result
decl_stmt|;
name|cp
operator|=
operator|&
name|dccb
operator|->
name|eata_ccb
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|dpt
operator|->
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dpt
operator|->
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|Interpret
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|DataIn
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|reqlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cp_id
operator|=
name|target
expr_stmt|;
name|cp
operator|->
name|cp_LUN
operator|=
literal|0
expr_stmt|;
comment|/* In the EATA packet */
name|cp
operator|->
name|cp_lun
operator|=
literal|0
expr_stmt|;
comment|/* In the SCSI command */
name|cp
operator|->
name|cp_scsi_cmd
operator|=
name|INQUIRY
expr_stmt|;
name|cp
operator|->
name|cp_len
operator|=
name|size
expr_stmt|;
name|cp
operator|->
name|cp_extent
operator|=
name|extent
expr_stmt|;
name|cp
operator|->
name|cp_page
operator|=
name|page
expr_stmt|;
name|cp
operator|->
name|cp_channel
operator|=
literal|0
expr_stmt|;
comment|/* DNC, Interpret mode is set */
name|cp
operator|->
name|cp_identify
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|cp_datalen
operator|=
name|htonl
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * This could be a simple for loop, but we suspected the compiler To 	 * have optimized it a bit too much. Wait for the controller to 	 * become ready 	 */
while|while
condition|(
operator|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
operator|)
operator|!=
operator|(
name|HA_SREADY
operator||
name|HA_SSC
operator|)
operator|&&
operator|(
name|status
operator|!=
operator|(
name|HA_SREADY
operator||
name|HA_SSC
operator||
name|HA_SERROR
operator|)
operator|)
operator|&&
operator|(
name|status
operator|!=
operator|(
name|HA_SDRDY
operator||
name|HA_SERROR
operator||
name|HA_SDRQ
operator|)
operator|)
operator|)
operator|||
operator|(
name|dpt_wait
argument_list|(
name|dpt
argument_list|,
name|HA_SBUSY
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * RAID Drives still Spinning up? (This should only occur if 		 * the DPT controller is in a NON PC (PCI?) platform). 		 */
if|if
condition|(
name|dpt_raid_busy
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: Get_conf() RSUS failed.\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|DptStat_Reset_BUSY
argument_list|(
name|dpt
operator|->
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * XXXX We might want to do something more clever than aborting at 	 * this point, like resetting (rebooting) the controller and trying 	 * again. 	 */
if|if
condition|(
operator|(
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
name|cp
argument_list|,
name|dccb_busaddr
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: Get_conf() failed (%d) to send "
literal|"EATA_CMD_DMA_READ_CONFIG\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Wait for two seconds for a response.  This can be slow  */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
operator|(
name|ndx
operator|<
literal|20000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|)
operator|&
name|HA_AIRQ
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* Grab the status and clear interrupts */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* 	 * Check the status carefully.  Return only if the 	 * command was successful. 	 */
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|HA_SERROR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dpt
operator|->
name|sp
operator|->
name|hba_stat
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dpt
operator|->
name|sp
operator|->
name|scsi_stat
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dpt
operator|->
name|sp
operator|->
name|residue_len
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dpt
operator|->
name|sp
operator|->
name|scsi_stat
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Detect Cache parameters and size */
end_comment

begin_function
specifier|static
name|void
name|dpt_detect_cache
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|dccb
parameter_list|,
name|u_int32_t
name|dccb_busaddr
parameter_list|,
name|u_int8_t
modifier|*
name|buff
parameter_list|)
block|{
name|eata_ccb_t
modifier|*
name|cp
decl_stmt|;
name|u_int8_t
modifier|*
name|param
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
comment|/* 	 * Default setting, for best perfromance.. 	 * This is what virtually all cards default to.. 	 */
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_CACHE_WRITEBACK
expr_stmt|;
name|dpt
operator|->
name|cache_size
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|&
name|dccb
operator|->
name|eata_ccb
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|dpt
operator|->
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* Setup the command structure */
name|cp
operator|->
name|Interpret
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|DataIn
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|reqlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cp_id
operator|=
literal|0
expr_stmt|;
comment|/* who cares?  The HBA will interpret.. */
name|cp
operator|->
name|cp_LUN
operator|=
literal|0
expr_stmt|;
comment|/* In the EATA packet */
name|cp
operator|->
name|cp_lun
operator|=
literal|0
expr_stmt|;
comment|/* In the SCSI command */
name|cp
operator|->
name|cp_channel
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|cp_scsi_cmd
operator|=
name|EATA_CMD_DMA_SEND_CP
expr_stmt|;
name|cp
operator|->
name|cp_len
operator|=
literal|56
expr_stmt|;
name|cp
operator|->
name|cp_extent
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|cp_page
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|cp_identify
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|cp_dispri
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Build the EATA Command Packet structure 	 * for a Log Sense Command. 	 */
name|cp
operator|->
name|cp_cdb
index|[
literal|0
index|]
operator|=
literal|0x4d
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|2
index|]
operator|=
literal|0x40
operator||
literal|0x33
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|7
index|]
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|cp_datalen
operator|=
name|htonl
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
name|cp
argument_list|,
name|dccb_busaddr
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: detect_cache() failed (%d) to send "
literal|"EATA_CMD_DMA_SEND_CP\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait for two seconds for a response.  This can be slow... */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
operator|(
name|ndx
operator|<
literal|20000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|)
operator|&
name|HA_AIRQ
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* Grab the status and clear interrupts */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check 	 */
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|!=
literal|0x33
condition|)
block|{
return|return;
block|}
name|bytes
operator|=
name|DPT_HCP_LENGTH
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|param
operator|=
name|DPT_HCP_FIRST
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|DPT_HCP_CODE
argument_list|(
name|param
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* 		 * DPT Log Page layout error 		 */
name|printf
argument_list|(
literal|"dpt%d: NOTICE: Log Page (1) layout error\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|param
index|[
literal|4
index|]
operator|&
literal|0x4
operator|)
condition|)
block|{
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_NO_CACHE
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|DPT_HCP_CODE
argument_list|(
name|param
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|param
operator|=
name|DPT_HCP_NEXT
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|param
operator|<
name|buff
operator|)
operator|||
operator|(
name|param
operator|>=
operator|&
name|buff
index|[
name|bytes
index|]
operator|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|param
index|[
literal|4
index|]
operator|&
literal|0x2
condition|)
block|{
comment|/* 		 * Cache disabled 		 */
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_NO_CACHE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param
index|[
literal|4
index|]
operator|&
literal|0x4
condition|)
block|{
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_CACHE_WRITETHROUGH
expr_stmt|;
block|}
comment|/* XXX This isn't correct.  This log parameter only has two bytes.... */
if|#
directive|if
literal|0
block|dpt->cache_size = param[5] 			| (param[6]<< 8) 			| (param[7]<< 16) 			| (param[8]<< 24);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|dpt_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dptexecuteccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|dpt_ccb
modifier|*
name|dccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|dpt_softc
modifier|*
name|dpt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|dccb
operator|=
operator|(
expr|struct
name|dpt_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|dccb
operator|->
name|ccb
expr_stmt|;
name|dpt
operator|=
operator|(
expr|struct
name|dpt_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_dpt_ptr
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EFBIG
condition|)
name|printf
argument_list|(
literal|"dpt%d: Unexepected error 0x%x returned from "
literal|"bus_dmamap_load\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_TOO_BIG
operator||
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|dptfreeccb
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|dpt_sg_t
modifier|*
name|sg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|bus_dmasync_op_t
name|op
decl_stmt|;
name|end_seg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
comment|/* Copy the segments into our SG list */
name|sg
operator|=
name|dccb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|sg
operator|->
name|seg_len
operator|=
name|htonl
argument_list|(
name|dm_segs
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|sg
operator|->
name|seg_addr
operator|=
name|htonl
argument_list|(
name|dm_segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nseg
operator|>
literal|1
condition|)
block|{
name|dccb
operator|->
name|eata_ccb
operator|.
name|scatter
operator|=
literal|1
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|dccb
operator|->
name|sg_busaddr
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
name|htonl
argument_list|(
name|nseg
operator|*
sizeof|sizeof
argument_list|(
name|dpt_sg_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|dccb
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|seg_addr
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
name|dccb
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|seg_len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
name|dccb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
literal|0
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Last time we need to check if this CCB needs to 	 * be aborted. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
name|dccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|dptfreeccb
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|dccb
operator|->
name|state
operator||=
name|DCCB_ACTIVE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|pending_ccb_list
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|dpttimeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|dccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|dccb
operator|->
name|eata_ccb
argument_list|,
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_busaddr
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_NO_HBA
expr_stmt|;
comment|/* HBA dead or just busy?? */
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
name|dccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|dptfreeccb
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|dpt_softc
modifier|*
name|dpt
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"dpt_action\n"
operator|)
argument_list|)
expr_stmt|;
name|dpt
operator|=
operator|(
expr|struct
name|dpt_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"controller is shutdown. Aborting CCB.\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_NO_HBA
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccbh
decl_stmt|;
name|struct
name|dpt_ccb
modifier|*
name|dccb
decl_stmt|;
name|struct
name|eata_ccb
modifier|*
name|eccb
decl_stmt|;
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|ccbh
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
comment|/* Max CDB length is 12 bytes */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
literal|12
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dccb
operator|=
name|dptgetccb
argument_list|(
name|dpt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|resource_shortage
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
comment|/*count*/
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|eccb
operator|=
operator|&
name|dccb
operator|->
name|eata_ccb
expr_stmt|;
comment|/* Link dccb and ccb so we can find one from the other */
name|dccb
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_dccb_ptr
operator|=
name|dccb
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_dpt_ptr
operator|=
name|dpt
expr_stmt|;
comment|/* 		 * Explicitly set all flags so that the compiler can 		 * be smart about setting them. 		 */
name|eccb
operator|->
name|SCSI_Reset
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|HBA_Init
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|Auto_Req_Sen
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|eccb
operator|->
name|scatter
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|Quick
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|Interpret
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
name|dpt
operator|->
name|hostid
index|[
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
index|]
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|eccb
operator|->
name|DataOut
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|eccb
operator|->
name|DataIn
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|eccb
operator|->
name|reqlen
operator|=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|eccb
operator|->
name|cp_id
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|eccb
operator|->
name|cp_channel
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|eccb
operator|->
name|cp_LUN
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|eccb
operator|->
name|cp_luntar
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|cp_dispri
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_DISCONNECT
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|eccb
operator|->
name|cp_identify
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
operator|&&
name|csio
operator|->
name|tag_action
operator|!=
name|CAM_TAG_ACTION_NONE
condition|)
block|{
name|eccb
operator|->
name|cp_msg
index|[
literal|0
index|]
operator|=
name|csio
operator|->
name|tag_action
expr_stmt|;
name|eccb
operator|->
name|cp_msg
index|[
literal|1
index|]
operator|=
name|dccb
operator|->
name|tag
expr_stmt|;
block|}
else|else
block|{
name|eccb
operator|->
name|cp_msg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|cp_msg
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|eccb
operator|->
name|cp_msg
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|eccb
operator|->
name|cp_cdb
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I guess I could map it in... */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|dptfreeccb
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|eccb
operator|->
name|cp_cdb
argument_list|,
name|csio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we have any data to send with this command, 		 * map it into bus space. 		 */
comment|/* Only use S/G if there is a transfer */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * We've been given a pointer 				 * to a single buffer. 				 */
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|s
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
name|dccb
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|dptexecuteccb
argument_list|,
name|dccb
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
comment|/* 						 * So as to maintain ordering, 						 * freeze the controller queue 						 * until our mapping is 						 * returned. 						 */
name|xpt_freeze_simq
argument_list|(
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dccb
operator|->
name|state
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|dptexecuteccb
argument_list|(
name|dccb
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"dpt_action - Physical "
literal|"segment pointers "
literal|"unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccbh
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dpt_action - Virtual "
literal|"segment addresses "
literal|"unsupported"
argument_list|)
expr_stmt|;
comment|/* Just use the segments provided */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|dptexecuteccb
argument_list|(
name|dccb
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * XXX JGibbs. 			 * Does it want them both on or both off? 			 * CAM_DIR_NONE is both on, so this code can 			 * be removed if this is also what the DPT 			 * exptects. 			 */
name|eccb
operator|->
name|DataOut
operator|=
literal|0
expr_stmt|;
name|eccb
operator|->
name|DataIn
operator|=
literal|0
expr_stmt|;
name|dptexecuteccb
argument_list|(
name|dccb
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
operator|(
name|dpt
operator|->
name|max_id
operator|>
literal|7
operator|)
condition|?
name|MSG_EXT_WDTR_BUS_8_BIT
else|:
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|25
expr_stmt|;
comment|/* 10MHz */
if|if
condition|(
name|spi
operator|->
name|sync_period
operator|!=
literal|0
condition|)
name|spi
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
comment|/* 		 * XXX Use Adaptec translation until I find out how to 		 *     get this information from the card. 		 */
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
block|{
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|max_id
operator|>
literal|7
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|dpt
operator|->
name|max_id
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|dpt
operator|->
name|max_lun
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|dpt
operator|->
name|hostid
index|[
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
index|]
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"DPT"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine will try to send an EATA command to the DPT HBA.  * It will, by default, try 20,000 times, waiting 50us between tries.  * It returns 0 on success and 1 on failure.  * It is assumed to be called at splcam().  */
end_comment

begin_function
specifier|static
name|int
name|dpt_send_eata_command
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int32_t
name|cmd_busaddr
parameter_list|,
name|u_int
name|command
parameter_list|,
name|u_int
name|retries
parameter_list|,
name|u_int
name|ifc
parameter_list|,
name|u_int
name|code
parameter_list|,
name|u_int
name|code2
parameter_list|)
block|{
name|u_int
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|retries
condition|)
name|retries
operator|=
literal|20000
expr_stmt|;
comment|/* 	 * I hate this polling nonsense. Wish there was a way to tell the DPT 	 * to go get commands at its own pace,  or to interrupt when ready. 	 * In the mean time we will measure how many itterations it really 	 * takes. 	 */
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|retries
condition|;
name|loop
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|&
name|HA_ABUSY
operator|)
operator|==
literal|0
condition|)
break|break;
else|else
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|<
name|retries
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
if|if
condition|(
name|loop
operator|>
name|dpt
operator|->
name|performance
operator|.
name|max_eata_tries
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_eata_tries
operator|=
name|loop
expr_stmt|;
if|if
condition|(
name|loop
operator|<
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
condition|)
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
operator|=
name|loop
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|command_too_busy
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* The controller is alive, advance the wedge timer */
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
name|dpt
operator|->
name|last_contact
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd_block
operator|==
name|NULL
condition|)
name|cmd_busaddr
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
else|else
block|{
name|cmd_busaddr
operator|=
operator|(
operator|(
name|cmd_busaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
operator|)
operator||
operator|(
operator|(
name|cmd_busaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator||
operator|(
operator|(
name|cmd_busaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
operator||
operator|(
name|cmd_busaddr
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* And now the address */
name|dpt_outl
argument_list|(
name|dpt
argument_list|,
name|HA_WDMAADDR
argument_list|,
name|cmd_busaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|EATA_CMD_IMMEDIATE
condition|)
block|{
if|if
condition|(
name|cmd_block
operator|==
name|NULL
condition|)
block|{
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCODE2
argument_list|,
name|code2
argument_list|)
expr_stmt|;
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCODE
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WIFC
argument_list|,
name|ifc
argument_list|)
expr_stmt|;
block|}
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCOMMAND
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ==================== Exported Function definitions =======================*/
end_comment

begin_function
name|void
name|dpt_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dpt
operator|->
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|dpt
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|dpt
operator|->
name|io_res
argument_list|)
operator|+
name|dpt
operator|->
name|io_offset
expr_stmt|;
name|dpt
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|dpt
operator|->
name|free_dccb_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dpt
operator|->
name|pending_ccb_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|dpt
operator|->
name|resetlevel
index|[
name|i
index|]
operator|=
name|DPT_HA_OK
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt_reset_performance
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
return|return;
block|}
end_function

begin_function
name|void
name|dpt_free
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|)
block|{
switch|switch
condition|(
name|dpt
operator|->
name|init_level
condition|)
block|{
default|default:
case|case
literal|5
case|:
name|bus_dmamap_unload
argument_list|(
name|dpt
operator|->
name|dccb_dmat
argument_list|,
name|dpt
operator|->
name|dccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|bus_dmamem_free
argument_list|(
name|dpt
operator|->
name|dccb_dmat
argument_list|,
name|dpt
operator|->
name|dpt_dccbs
argument_list|,
name|dpt
operator|->
name|dccb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dpt
operator|->
name|dccb_dmat
argument_list|,
name|dpt
operator|->
name|dccb_dmamap
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|bus_dma_tag_destroy
argument_list|(
name|dpt
operator|->
name|dccb_dmat
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|bus_dma_tag_destroy
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
block|{
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
while|while
condition|(
operator|(
name|sg_map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|sg_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|sg_maps
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dpt
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dpt
operator|->
name|sg_dmat
argument_list|,
name|sg_map
operator|->
name|sg_vaddr
argument_list|,
name|sg_map
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg_map
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dpt
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
case|case
literal|0
case|:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|dpt_alloc_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dpt
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|io_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|dpt
operator|->
name|io_type
argument_list|,
operator|&
name|dpt
operator|->
name|io_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|io_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No I/O space?!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dpt
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|dpt
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No IRQ!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dpt_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dpt_softc
modifier|*
name|dpt
decl_stmt|;
name|dpt
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|dpt
operator|->
name|irq_res
argument_list|,
name|dpt
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|io_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|dpt
operator|->
name|io_type
argument_list|,
name|dpt
operator|->
name|io_rid
argument_list|,
name|dpt
operator|->
name|io_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|dpt
operator|->
name|irq_rid
argument_list|,
name|dpt
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|drq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|dpt
operator|->
name|drq_rid
argument_list|,
name|dpt
operator|->
name|drq_res
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_int8_t
name|string_sizes
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|dpt_inq_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|vendor
argument_list|)
block|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|dpt_inq_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|modelNum
argument_list|)
block|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|dpt_inq_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|firmware
argument_list|)
block|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|dpt_inq_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|protocol
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dpt_init
parameter_list|(
name|struct
name|dpt_softc
modifier|*
name|dpt
parameter_list|)
block|{
name|dpt_conf_t
name|conf
decl_stmt|;
name|struct
name|sg_map_node
modifier|*
name|sg_map
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|dccb
decl_stmt|;
name|u_int8_t
modifier|*
name|strp
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|dpt
operator|->
name|init_level
operator|=
literal|0
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|dpt
operator|->
name|sg_maps
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_RESET_BOARD
name|printf
argument_list|(
literal|"dpt%d: resetting HBA\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCOMMAND
argument_list|,
name|EATA_CMD_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|750000
argument_list|)
expr_stmt|;
comment|/* XXX Shouldn't we poll a status register or something??? */
endif|#
directive|endif
comment|/* DMA tag for our S/G structures.  We allocate in page sized chunks */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|dpt
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|PAGE_SIZE
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|dpt
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|error_exit
goto|;
block|}
name|dpt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* 	 * We allocate our DPT ccbs as a contiguous array of bus dma'able 	 * memory.  To get the allocation size, we need to know how many 	 * ccbs the card supports.  This requires a ccb.  We solve this 	 * chicken and egg problem by allocating some re-usable S/G space 	 * up front, and treating it as our status packet, CCB, and target 	 * memory space for these commands. 	 */
name|sg_map
operator|=
name|dptallocsgmap
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg_map
operator|==
name|NULL
condition|)
goto|goto
name|error_exit
goto|;
name|dpt
operator|->
name|sp
operator|=
operator|(
specifier|volatile
name|dpt_sp_t
operator|*
operator|)
name|sg_map
operator|->
name|sg_vaddr
expr_stmt|;
name|dccb
operator|=
operator|(
expr|struct
name|dpt_ccb
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
operator|&
name|dpt
operator|->
name|sp
index|[
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
name|dccb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dccb
argument_list|)
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|sp_physaddr
operator|=
name|sg_map
operator|->
name|sg_physaddr
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|sg_map
operator|->
name|sg_physaddr
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dccb
argument_list|)
argument_list|)
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_busaddr
operator|=
operator|~
literal|0
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|dpt
operator|->
name|sp_physaddr
argument_list|)
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|dpt
operator|->
name|sp_physaddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dccb
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|dpt_ccb
argument_list|,
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Okay.  Fetch our config */
name|bzero
argument_list|(
operator|&
name|dccb
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* data area */
name|retval
operator|=
name|dpt_get_conf
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|,
name|sg_map
operator|->
name|sg_physaddr
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|0xc1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Failed to get board configuration\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|dccb
index|[
literal|1
index|]
argument_list|,
operator|&
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dccb
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|board_data
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|dpt_get_conf
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|,
name|sg_map
operator|->
name|sg_physaddr
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|board_data
argument_list|)
argument_list|,
literal|0
argument_list|,
name|conf
operator|.
name|scsi_id0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Failed to get inquiry information\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|dccb
index|[
literal|1
index|]
argument_list|,
operator|&
name|dpt
operator|->
name|board_data
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|board_data
argument_list|)
argument_list|)
expr_stmt|;
name|dpt_detect_cache
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|,
name|sg_map
operator|->
name|sg_physaddr
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|dccb
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ntohl
argument_list|(
name|conf
operator|.
name|splen
argument_list|)
condition|)
block|{
case|case
name|DPT_EATA_REVA
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|DPT_EATA_REVB
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|DPT_EATA_REVC
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|DPT_EATA_REVZ
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'z'
expr_stmt|;
break|break;
default|default:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'?'
expr_stmt|;
block|}
name|dpt
operator|->
name|max_id
operator|=
name|conf
operator|.
name|MAX_ID
expr_stmt|;
name|dpt
operator|->
name|max_lun
operator|=
name|conf
operator|.
name|MAX_LUN
expr_stmt|;
name|dpt
operator|->
name|irq
operator|=
name|conf
operator|.
name|IRQ
expr_stmt|;
name|dpt
operator|->
name|dma_channel
operator|=
operator|(
literal|8
operator|-
name|conf
operator|.
name|DMA_channel
operator|)
operator|&
literal|7
expr_stmt|;
name|dpt
operator|->
name|channels
operator|=
name|conf
operator|.
name|MAX_CHAN
operator|+
literal|1
expr_stmt|;
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_OK
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|SECOND
condition|)
name|dpt
operator|->
name|primary
operator|=
name|FALSE
expr_stmt|;
else|else
name|dpt
operator|->
name|primary
operator|=
name|TRUE
expr_stmt|;
name|dpt
operator|->
name|more_support
operator|=
name|conf
operator|.
name|MORE_support
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|dpt
operator|->
name|board_data
operator|.
name|firmware
argument_list|,
literal|"07G0"
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
condition|)
name|dpt
operator|->
name|immediate_support
operator|=
literal|1
expr_stmt|;
else|else
name|dpt
operator|->
name|immediate_support
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|broken_INQUIRY
operator|=
name|FALSE
expr_stmt|;
name|dpt
operator|->
name|cplen
operator|=
name|ntohl
argument_list|(
name|conf
operator|.
name|cplen
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|cppadlen
operator|=
name|ntohs
argument_list|(
name|conf
operator|.
name|cppadlen
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|max_dccbs
operator|=
name|ntohs
argument_list|(
name|conf
operator|.
name|queuesiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|max_dccbs
operator|>
literal|256
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Max CCBs reduced from %d to "
literal|"256 due to tag algorithm\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|max_dccbs
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|max_dccbs
operator|=
literal|256
expr_stmt|;
block|}
name|dpt
operator|->
name|hostid
index|[
literal|0
index|]
operator|=
name|conf
operator|.
name|scsi_id0
expr_stmt|;
name|dpt
operator|->
name|hostid
index|[
literal|1
index|]
operator|=
name|conf
operator|.
name|scsi_id1
expr_stmt|;
name|dpt
operator|->
name|hostid
index|[
literal|2
index|]
operator|=
name|conf
operator|.
name|scsi_id2
expr_stmt|;
if|if
condition|(
name|conf
operator|.
name|SG_64K
condition|)
name|dpt
operator|->
name|sgsize
operator|=
literal|8192
expr_stmt|;
else|else
name|dpt
operator|->
name|sgsize
operator|=
name|ntohs
argument_list|(
name|conf
operator|.
name|SGsiz
argument_list|)
expr_stmt|;
comment|/* We can only get 64k buffers, so don't bother to waste space. */
if|if
condition|(
name|dpt
operator|->
name|sgsize
operator|<
literal|17
operator|||
name|dpt
operator|->
name|sgsize
operator|>
literal|32
condition|)
name|dpt
operator|->
name|sgsize
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|sgsize
operator|>
name|dpt_max_segs
condition|)
name|dpt
operator|->
name|sgsize
operator|=
name|dpt_max_segs
expr_stmt|;
comment|/* DMA tag for mapping buffers into device visible space. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|dpt
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|MAXBSIZE
argument_list|,
comment|/* nsegments	*/
name|dpt
operator|->
name|sgsize
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|dpt
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: bus_dma_tag_create(...,dpt->buffer_dmat) failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|dpt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* DMA tag for our ccb structures and interrupt status packet */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|dpt
operator|->
name|parent_dmat
argument_list|,
comment|/* alignment	*/
literal|1
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
operator|(
name|dpt
operator|->
name|max_dccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dpt_ccb
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|,
comment|/* nsegments	*/
literal|1
argument_list|,
comment|/* maxsegsz	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
literal|0
argument_list|,
comment|/* lockfunc	*/
name|busdma_lock_mutex
argument_list|,
comment|/* lockarg	*/
operator|&
name|Giant
argument_list|,
operator|&
name|dpt
operator|->
name|dccb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: bus_dma_tag_create(...,dpt->dccb_dmat) failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|dpt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocation for our ccbs and interrupt status packet */
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|dpt
operator|->
name|dccb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dpt
operator|->
name|dpt_dccbs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dpt
operator|->
name|dccb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: bus_dmamem_alloc(dpt->dccb_dmat,...) failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|dpt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* And permanently map them */
name|bus_dmamap_load
argument_list|(
name|dpt
operator|->
name|dccb_dmat
argument_list|,
name|dpt
operator|->
name|dccb_dmamap
argument_list|,
name|dpt
operator|->
name|dpt_dccbs
argument_list|,
operator|(
name|dpt
operator|->
name|max_dccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dpt_ccb
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|,
name|dptmapmem
argument_list|,
operator|&
name|dpt
operator|->
name|dpt_ccb_busbase
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear them out. */
name|bzero
argument_list|(
name|dpt
operator|->
name|dpt_dccbs
argument_list|,
operator|(
name|dpt
operator|->
name|max_dccbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dpt_ccb
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|dpt_ccb_busend
operator|=
name|dpt
operator|->
name|dpt_ccb_busbase
expr_stmt|;
name|dpt
operator|->
name|sp
operator|=
operator|(
name|dpt_sp_t
operator|*
operator|)
operator|&
name|dpt
operator|->
name|dpt_dccbs
index|[
name|dpt
operator|->
name|max_dccbs
index|]
expr_stmt|;
name|dpt
operator|->
name|sp_physaddr
operator|=
name|dpt
operator|->
name|dpt_ccb_busbase
operator|+
operator|(
name|dpt
operator|->
name|max_dccbs
operator|*
sizeof|sizeof
argument_list|(
name|dpt_ccb_t
argument_list|)
operator|)
expr_stmt|;
name|dpt
operator|->
name|init_level
operator|++
expr_stmt|;
comment|/* Allocate our first batch of ccbs */
if|if
condition|(
name|dptallocccbs
argument_list|(
name|dpt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt: dptallocccbs(dpt) == 0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
comment|/* Prepare for Target Mode */
name|dpt
operator|->
name|target_mode_enabled
operator|=
literal|1
expr_stmt|;
comment|/* Nuke excess spaces from inquiry information */
name|strp
operator|=
name|dpt
operator|->
name|board_data
operator|.
name|vendor
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|string_sizes
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|index
operator|=
name|string_sizes
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|index
operator|&&
operator|(
name|strp
index|[
name|index
index|]
operator|==
literal|' '
operator|)
condition|)
name|strp
index|[
name|index
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strp
operator|+=
name|string_sizes
index|[
name|i
index|]
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dpt%d: %.8s %.16s FW Rev. %.4s, "
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|vendor
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|modelNum
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|firmware
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d channel%s, "
argument_list|,
name|dpt
operator|->
name|channels
argument_list|,
name|dpt
operator|->
name|channels
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|cache_type
operator|!=
name|DPT_NO_CACHE
operator|&&
name|dpt
operator|->
name|cache_size
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s Cache, "
argument_list|,
name|dpt
operator|->
name|cache_type
operator|==
name|DPT_CACHE_WRITETHROUGH
condition|?
literal|"Write-Through"
else|:
literal|"Write-Back"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d CCBs\n"
argument_list|,
name|dpt
operator|->
name|max_dccbs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error_exit
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dpt_attach
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Create the device queue for our SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|dpt
operator|->
name|max_dccbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpt
operator|->
name|channels
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Construct our SIM entry 		 */
name|dpt
operator|->
name|sims
index|[
name|i
index|]
operator|=
name|cam_sim_alloc
argument_list|(
name|dpt_action
argument_list|,
name|dpt_poll
argument_list|,
literal|"dpt"
argument_list|,
name|dpt
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|&
name|Giant
argument_list|,
comment|/*untagged*/
literal|2
argument_list|,
comment|/*tagged*/
name|dpt
operator|->
name|max_dccbs
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s(): Unable to attach bus %d "
literal|"due to resource shortage\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
comment|/*free_devq*/
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|sims
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|dpt
operator|->
name|paths
index|[
name|i
index|]
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
comment|/*free_devq*/
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|sims
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|dptshutdown
argument_list|,
name|dpt
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dpt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dpt_softc
modifier|*
name|dpt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dpt
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dpt
operator|->
name|channels
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|xpt_async(AC_LOST_DEVICE, dpt->paths[i], NULL);
endif|#
directive|endif
name|xpt_free_path
argument_list|(
name|dpt
operator|->
name|paths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|dpt
operator|->
name|sims
index|[
name|i
index|]
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|dptshutdown
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dpt
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
name|dpt_release_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dpt_free
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the interrupt handler for the DPT driver.  */
end_comment

begin_function
name|void
name|dpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|dccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int
name|status
decl_stmt|;
name|u_int
name|aux_status
decl_stmt|;
name|u_int
name|hba_stat
decl_stmt|;
name|u_int
name|scsi_stat
decl_stmt|;
name|u_int32_t
name|residue_len
decl_stmt|;
comment|/* Number of bytes not transferred */
name|dpt
operator|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* First order of business is to check if this interrupt is for us */
while|while
condition|(
operator|(
operator|(
name|aux_status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|)
operator|&
name|HA_AIRQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * What we want to do now, is to capture the status, all of it, 		 * move it where it belongs, wake up whoever sleeps waiting to 		 * process this result, and get out of here. 		 */
if|if
condition|(
name|dpt
operator|->
name|sp
operator|->
name|ccb_busaddr
operator|<
name|dpt
operator|->
name|dpt_ccb_busbase
operator|||
name|dpt
operator|->
name|sp
operator|->
name|ccb_busaddr
operator|>=
name|dpt
operator|->
name|dpt_ccb_busend
condition|)
block|{
name|printf
argument_list|(
literal|"Encountered bogus status packet\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
return|return;
block|}
name|dccb
operator|=
name|dptccbptov
argument_list|(
name|dpt
argument_list|,
name|dpt
operator|->
name|sp
operator|->
name|ccb_busaddr
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|sp
operator|->
name|ccb_busaddr
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Ignore status packets with EOC not set */
if|if
condition|(
name|dpt
operator|->
name|sp
operator|->
name|EOC
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Request %d received with "
literal|"clear EOC.\n     Marking as LOST.\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dccb
operator|->
name|transaction_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
name|dccb
operator|->
name|state
operator||=
name|DPT_CCB_STATE_MARKED_LOST
expr_stmt|;
endif|#
directive|endif
comment|/* This CLEARS the interrupt! */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dpt
operator|->
name|sp
operator|->
name|EOC
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Double buffer the status information so the hardware can 		 * work on updating the status packet while we decifer the 		 * one we were just interrupted for. 		 * According to Mark Salyzyn, we only need few pieces of it. 		 */
name|hba_stat
operator|=
name|dpt
operator|->
name|sp
operator|->
name|hba_stat
expr_stmt|;
name|scsi_stat
operator|=
name|dpt
operator|->
name|sp
operator|->
name|scsi_stat
expr_stmt|;
name|residue_len
operator|=
name|dpt
operator|->
name|sp
operator|->
name|residue_len
expr_stmt|;
comment|/* Clear interrupts, check for error */
if|if
condition|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
operator|)
operator|&
name|HA_SERROR
condition|)
block|{
comment|/* 			 * Error Condition. Check for magic cookie. Exit 			 * this test on earliest sign of non-reset condition 			 */
comment|/* Check that this is not a board reset interrupt */
if|if
condition|(
name|dpt_just_reset
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: HBA rebooted.\n"
literal|"      All transactions should be "
literal|"resubmitted\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d:>>---->>  This is incomplete, "
literal|"fix me....<<----<<"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"DPT Rebooted"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process CCB */
name|ccb
operator|=
name|dccb
operator|->
name|ccb
expr_stmt|;
name|untimeout
argument_list|(
name|dpttimeout
argument_list|,
name|dccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
name|dccb
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dpt
operator|->
name|buffer_dmat
argument_list|,
name|dccb
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
comment|/* Common Case inline... */
if|if
condition|(
name|hba_stat
operator|==
name|HA_NO_ERROR
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|scsi_stat
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|scsi_stat
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
name|bcopy
argument_list|(
operator|&
name|dccb
operator|->
name|sense_data
argument_list|,
operator|&
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
comment|/* XXX Freeze DevQ */
break|break;
block|}
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|residue_len
expr_stmt|;
name|dptfreeccb
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dptprocesserror
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|,
name|ccb
argument_list|,
name|hba_stat
argument_list|,
name|scsi_stat
argument_list|,
name|residue_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dptprocesserror
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|dccb
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|u_int
name|hba_stat
parameter_list|,
name|u_int
name|scsi_stat
parameter_list|,
name|u_int32_t
name|resid
parameter_list|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|resid
expr_stmt|;
switch|switch
condition|(
name|hba_stat
condition|)
block|{
case|case
name|HA_ERR_SEL_TO
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|HA_ERR_CMD_TO
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
case|case
name|HA_SCSIBUS_RESET
case|:
case|case
name|HA_HBA_POWER_UP
case|:
comment|/* Similar effect to a bus reset??? */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUS_RESET
expr_stmt|;
break|break;
case|case
name|HA_CP_ABORTED
case|:
case|case
name|HA_CP_RESET
case|:
comment|/* XXX ??? */
case|case
name|HA_CP_ABORT_NA
case|:
comment|/* XXX ??? */
case|case
name|HA_CP_RESET_NA
case|:
comment|/* XXX ??? */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_ABORTED
expr_stmt|;
break|break;
case|case
name|HA_PCI_PARITY
case|:
case|case
name|HA_PCI_MABORT
case|:
case|case
name|HA_PCI_TABORT
case|:
case|case
name|HA_PCI_STABORT
case|:
case|case
name|HA_BUS_PARITY
case|:
case|case
name|HA_PARITY_ERR
case|:
case|case
name|HA_ECC_ERR
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
break|break;
case|case
name|HA_UNX_MSGRJCT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_MSG_REJECT_REC
expr_stmt|;
break|break;
case|case
name|HA_UNX_BUSPHASE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEQUENCE_FAIL
expr_stmt|;
break|break;
case|case
name|HA_UNX_BUS_FREE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
break|break;
case|case
name|HA_SCSI_HUNG
case|:
case|case
name|HA_RESET_STUCK
case|:
comment|/* 		 * Dead???  Can the controller get unstuck 		 * from these conditions 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_NO_HBA
expr_stmt|;
break|break;
case|case
name|HA_RSENSE_FAIL
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"dpt%d: Undocumented Error %x\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|hba_stat
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Please mail this message to shimon@simon-shapiro.org\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
break|break;
block|}
name|dptfreeccb
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dpttimeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dpt_ccb
modifier|*
name|dccb
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|dpt_softc
modifier|*
name|dpt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|dccb
operator|=
operator|(
expr|struct
name|dpt_ccb
operator|*
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|dccb
operator|->
name|ccb
expr_stmt|;
name|dpt
operator|=
operator|(
expr|struct
name|dpt_softc
operator|*
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_dpt_ptr
expr_stmt|;
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CCB %p - timed out\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 * Try to clear any pending jobs.  FreeBSD will lose interrupts, 	 * leaving the controller suspended, and commands timed-out. 	 * By calling the interrupt handler, any command thus stuck will be 	 * completed. 	 */
name|dpt_intr
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dccb
operator|->
name|state
operator|&
name|DCCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|xpt_print_path
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CCB %p - timed out CCB already completed\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Abort this particular command.  Leave all others running */
name|dpt_send_immediate
argument_list|(
name|dpt
argument_list|,
operator|&
name|dccb
operator|->
name|eata_ccb
argument_list|,
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_busaddr
argument_list|,
comment|/*retries*/
literal|20000
argument_list|,
name|EATA_SPECIFIC_ABORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shutdown the controller and ensure that the cache is completely flushed.  * Called from the shutdown_final event after all disk access has completed.  */
end_comment

begin_function
specifier|static
name|void
name|dptshutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt
operator|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d: Shutting down (mode %x) HBA.	Please wait...\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|howto
argument_list|)
expr_stmt|;
comment|/* 	 * What we do for a shutdown, is give the DPT early power loss warning 	 */
name|dpt_send_immediate
argument_list|(
name|dpt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EATA_POWER_OFF_WARN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|1000
operator|*
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d: Controller was warned of shutdown and is now "
literal|"disabled\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*============================================================================*/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
end_ifdef

begin_comment
comment|/* **	Function name : dpt_reset_hba ** **	Description : Reset the HBA and properly discard all pending work **	Input :       Softc **	Output :      Nothing */
end_comment

begin_comment
unit|static void dpt_reset_hba(dpt_softc_t *dpt) { 	eata_ccb_t       *ccb; 	int               ospl; 	dpt_ccb_t         dccb, *dccbp; 	int               result; 	struct scsi_xfer *xs;
comment|/* Prepare a control block.  The SCSI command part is immaterial */
end_comment

begin_comment
unit|dccb.xs = NULL; 	dccb.flags = 0; 	dccb.state = DPT_CCB_STATE_NEW; 	dccb.std_callback = NULL; 	dccb.wrbuff_callback = NULL;  	ccb =&dccb.eata_ccb; 	ccb->CP_OpCode = EATA_CMD_RESET; 	ccb->SCSI_Reset = 0; 	ccb->HBA_Init = 1; 	ccb->Auto_Req_Sen = 1; 	ccb->cp_id = 0;
comment|/* Should be ignored */
end_comment

begin_comment
unit|ccb->DataIn = 1; 	ccb->DataOut = 0; 	ccb->Interpret = 1; 	ccb->reqlen = htonl(sizeof(struct scsi_sense_data)); 	ccb->cp_statDMA = htonl(vtophys(&ccb->cp_statDMA)); 	ccb->cp_reqDMA = htonl(vtophys(&ccb->cp_reqDMA)); 	ccb->cp_viraddr = (u_int32_t)& ccb;  	ccb->cp_msg[0] = HA_IDENTIFY_MSG | HA_DISCO_RECO; 	ccb->cp_scsi_cmd = 0;
comment|/* Should be ignored */
end_comment

begin_comment
comment|/* Lock up the submitted queue.  We are very persistant here */
end_comment

begin_comment
unit|ospl = splcam(); 	while (dpt->queue_status& DPT_SUBMITTED_QUEUE_ACTIVE) { 		DELAY(100); 	} 	 	dpt->queue_status |= DPT_SUBMITTED_QUEUE_ACTIVE; 	splx(ospl);
comment|/* Send the RESET message */
end_comment

begin_ifdef
unit|if ((result = dpt_send_eata_command(dpt,&dccb.eata_ccb, 					    EATA_CMD_RESET, 0, 0, 0, 0)) != 0) { 		printf("dpt%d: Failed to send the RESET message.\n" 		       "      Trying cold boot (ouch!)\n", dpt->unit); 	 	 		if ((result = dpt_send_eata_command(dpt,&dccb.eata_ccb, 						    EATA_COLD_BOOT, 0, 0, 						    0, 0)) != 0) { 			panic("dpt%d:  Faild to cold boot the HBA\n", 			      dpt->unit); 		}
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_endif
unit|dpt->performance.cold_boots++;
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_MEASURE_PERFORMANCE */
end_comment

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_endif
unit|dpt->performance.warm_starts++;
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_MEASURE_PERFORMANCE */
end_comment

begin_comment
unit|printf("dpt%d:  Aborting pending requests.  O/S should re-submit\n", 	       dpt->unit);  	while ((dccbp = TAILQ_FIRST(&dpt->completed_ccbs)) != NULL) { 		struct scsi_xfer *xs = dccbp->xs;
comment|/* Not all transactions have xs structs */
end_comment

begin_comment
unit|if (xs != NULL) {
comment|/* Tell the kernel proper this did not complete well */
end_comment

begin_comment
unit|xs->error |= XS_SELTIMEOUT; 			xs->flags |= SCSI_ITSDONE; 			scsi_done(xs); 		} 	     		dpt_Qremove_submitted(dpt, dccbp);
comment|/* Remember, Callbacks are NOT in the standard queue */
end_comment

begin_endif
unit|if (dccbp->std_callback != NULL) { 			(dccbp->std_callback)(dpt, dccbp->eata_ccb.cp_channel, 					       dccbp); 		} else { 			ospl = splcam(); 			dpt_Qpush_free(dpt, dccbp); 			splx(ospl); 		} 	}  	printf("dpt%d: reset done aborting all pending commands\n", dpt->unit); 	dpt->queue_status&= ~DPT_SUBMITTED_QUEUE_ACTIVE; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_RESET_HBA */
end_comment

begin_comment
comment|/*  * Build a Command Block for target mode READ/WRITE BUFFER,  * with the ``sync'' bit ON.  *  * Although the length and offset are 24 bit fields in the command, they cannot  * exceed 8192 bytes, so we take them as short integers andcheck their range.  * If they are sensless, we round them to zero offset, maximum length and  * complain.  */
end_comment

begin_comment
unit|static void dpt_target_ccb(dpt_softc_t * dpt, int bus, u_int8_t target, u_int8_t lun, 	       dpt_ccb_t * ccb, int mode, u_int8_t command, 	       u_int16_t length, u_int16_t offset) { 	eata_ccb_t     *cp; 	int             ospl;  	if ((length + offset)> DPT_MAX_TARGET_MODE_BUFFER_SIZE) { 		printf("dpt%d:  Length of %d, and offset of %d are wrong\n", 		       dpt->unit, length, offset); 		length = DPT_MAX_TARGET_MODE_BUFFER_SIZE; 		offset = 0; 	} 	ccb->xs = NULL; 	ccb->flags = 0; 	ccb->state = DPT_CCB_STATE_NEW; 	ccb->std_callback = (ccb_callback) dpt_target_done; 	ccb->wrbuff_callback = NULL;  	cp =&ccb->eata_ccb; 	cp->CP_OpCode = EATA_CMD_DMA_SEND_CP; 	cp->SCSI_Reset = 0; 	cp->HBA_Init = 0; 	cp->Auto_Req_Sen = 1; 	cp->cp_id = target; 	cp->DataIn = 1; 	cp->DataOut = 0; 	cp->Interpret = 0; 	cp->reqlen = htonl(sizeof(struct scsi_sense_data)); 	cp->cp_statDMA = htonl(vtophys(&cp->cp_statDMA)); 	cp->cp_reqDMA = htonl(vtophys(&cp->cp_reqDMA)); 	cp->cp_viraddr = (u_int32_t)& ccb;  	cp->cp_msg[0] = HA_IDENTIFY_MSG | HA_DISCO_RECO;  	cp->cp_scsi_cmd = command; 	cp->cp_cdb[1] = (u_int8_t) (mode& SCSI_TM_MODE_MASK); 	cp->cp_lun = lun;
comment|/* Order is important here! */
end_comment

begin_comment
unit|cp->cp_cdb[2] = 0x00;
comment|/* Buffer Id, only 1 :-( */
end_comment

begin_comment
unit|cp->cp_cdb[3] = (length>> 16)& 0xFF;
comment|/* Buffer offset MSB */
end_comment

begin_comment
unit|cp->cp_cdb[4] = (length>> 8)& 0xFF; 	cp->cp_cdb[5] = length& 0xFF; 	cp->cp_cdb[6] = (length>> 16)& 0xFF;
comment|/* Length MSB */
end_comment

begin_comment
unit|cp->cp_cdb[7] = (length>> 8)& 0xFF; 	cp->cp_cdb[8] = length& 0xFF;
comment|/* Length LSB */
end_comment

begin_comment
unit|cp->cp_cdb[9] = 0;
comment|/* No sync, no match bits */
end_comment

begin_comment
comment|/* 	 * This could be optimized to live in dpt_register_buffer. 	 * We keep it here, just in case the kernel decides to reallocate pages 	 */
end_comment

begin_comment
unit|if (dpt_scatter_gather(dpt, ccb, DPT_RW_BUFFER_SIZE, 			       dpt->rw_buffer[bus][target][lun])) { 		printf("dpt%d: Failed to setup Scatter/Gather for " 		       "Target-Mode buffer\n", dpt->unit); 	} }
comment|/* Setup a target mode READ command */
end_comment

begin_ifdef
unit|static void dpt_set_target(int redo, dpt_softc_t * dpt, 	       u_int8_t bus, u_int8_t target, u_int8_t lun, int mode, 	       u_int16_t length, u_int16_t offset, dpt_ccb_t * ccb) { 	int ospl;  	if (dpt->target_mode_enabled) { 		ospl = splcam();  		if (!redo) 			dpt_target_ccb(dpt, bus, target, lun, ccb, mode, 				       SCSI_TM_READ_BUFFER, length, offset);  		ccb->transaction_id = ++dpt->commands_processed;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_endif
unit|dpt->performance.command_count[ccb->eata_ccb.cp_scsi_cmd]++; 		ccb->command_started = microtime_now;
endif|#
directive|endif
end_endif

begin_comment
unit|dpt_Qadd_waiting(dpt, ccb); 		dpt_sched_queue(dpt);  		splx(ospl); 	} else { 		printf("dpt%d:  Target Mode Request, but Target Mode is OFF\n", 		       dpt->unit); 	} }
comment|/*  * Schedule a buffer to be sent to another target.  * The work will be scheduled and the callback provided will be called when  * the work is actually done.  *  * Please NOTE:  ``Anyone'' can send a buffer, but only registered clients  * get notified of receipt of buffers.  */
end_comment

begin_comment
unit|int dpt_send_buffer(int unit, u_int8_t channel, u_int8_t target, u_int8_t lun, 		u_int8_t mode, u_int16_t length, u_int16_t offset, void *data, 		buff_wr_done callback) { 	dpt_softc_t    *dpt; 	dpt_ccb_t      *ccb = NULL; 	int             ospl;
comment|/* This is an external call.  Be a bit paranoid */
end_comment

begin_comment
unit|for (dpt = TAILQ_FIRST(&dpt_softc_list); 	     dpt != NULL; 	     dpt = TAILQ_NEXT(dpt, links)) { 		if (dpt->unit == unit) 			goto valid_unit; 	}  	return (INVALID_UNIT);  valid_unit:  	if (dpt->target_mode_enabled) { 		if ((channel>= dpt->channels) || (target> dpt->max_id) || 		    (lun> dpt->max_lun)) { 			return (INVALID_SENDER); 		} 		if ((dpt->rw_buffer[channel][target][lun] == NULL) || 		    (dpt->buffer_receiver[channel][target][lun] == NULL)) 			return (NOT_REGISTERED);  		ospl = splsoftcam();
comment|/* Process the free list */
end_comment

begin_comment
unit|if ((TAILQ_EMPTY(&dpt->free_ccbs))&& dpt_alloc_freelist(dpt)) { 			printf("dpt%d ERROR: Cannot allocate any more free CCB's.\n" 			       "             Please try later\n", 			       dpt->unit); 			splx(ospl); 			return (NO_RESOURCES); 		}
comment|/* Now grab the newest CCB */
end_comment

begin_comment
unit|if ((ccb = dpt_Qpop_free(dpt)) == NULL) { 			splx(ospl); 			panic("dpt%d: Got a NULL CCB from pop_free()\n", dpt->unit); 		} 		splx(ospl);  		bcopy(dpt->rw_buffer[channel][target][lun] + offset, data, length); 		dpt_target_ccb(dpt, channel, target, lun, ccb, mode,  					   SCSI_TM_WRITE_BUFFER, 					   length, offset); 		ccb->std_callback = (ccb_callback) callback;
comment|/* Potential trouble */
end_comment

begin_ifdef
unit|ospl = splcam(); 		ccb->transaction_id = ++dpt->commands_processed;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_endif
unit|dpt->performance.command_count[ccb->eata_ccb.cp_scsi_cmd]++; 		ccb->command_started = microtime_now;
endif|#
directive|endif
end_endif

begin_comment
unit|dpt_Qadd_waiting(dpt, ccb); 		dpt_sched_queue(dpt);  		splx(ospl); 		return (0); 	} 	return (DRIVER_DOWN); }  static void dpt_target_done(dpt_softc_t * dpt, int bus, dpt_ccb_t * ccb) { 	int             ospl; 	eata_ccb_t     *cp;  	cp =&ccb->eata_ccb;
comment|/* 	 * Remove the CCB from the waiting queue. 	 *  We do NOT put it back on the free, etc., queues as it is a special 	 * ccb, owned by the dpt_softc of this unit. 	 */
end_comment

begin_define
unit|ospl = splsoftcam(); 	dpt_Qremove_completed(dpt, ccb); 	splx(ospl);
define|#
directive|define
name|br_channel
value|(ccb->eata_ccb.cp_channel)
end_define

begin_define
define|#
directive|define
name|br_target
value|(ccb->eata_ccb.cp_id)
end_define

begin_define
define|#
directive|define
name|br_lun
value|(ccb->eata_ccb.cp_LUN)
end_define

begin_define
define|#
directive|define
name|br_index
value|[br_channel][br_target][br_lun]
end_define

begin_define
define|#
directive|define
name|read_buffer_callback
value|(dpt->buffer_receiver br_index )
end_define

begin_define
define|#
directive|define
name|read_buffer
value|(dpt->rw_buffer[br_channel][br_target][br_lun])
end_define

begin_define
define|#
directive|define
name|cb
parameter_list|(
name|offset
parameter_list|)
value|(ccb->eata_ccb.cp_cdb[offset])
end_define

begin_define
define|#
directive|define
name|br_offset
value|((cb(3)<< 16) | (cb(4)<< 8) | cb(5))
end_define

begin_define
define|#
directive|define
name|br_length
value|((cb(6)<< 16) | (cb(7)<< 8) | cb(8))
end_define

begin_comment
comment|/* Different reasons for being here, you know... */
end_comment

begin_comment
unit|switch (ccb->eata_ccb.cp_scsi_cmd) { 	case SCSI_TM_READ_BUFFER: 		if (read_buffer_callback != NULL) {
comment|/* This is a buffer generated by a kernel process */
end_comment

begin_comment
unit|read_buffer_callback(dpt->unit, br_channel, 					     br_target, br_lun, 					     read_buffer, 					     br_offset, br_length); 		} else {
comment|/* 			 * This is a buffer waited for by a user (sleeping) 			 * command 			 */
end_comment

begin_comment
unit|wakeup(ccb); 		}
comment|/* We ALWAYS re-issue the same command; args are don't-care  */
end_comment

begin_comment
unit|dpt_set_target(1, 0, 0, 0, 0, 0, 0, 0, 0); 		break;  	case SCSI_TM_WRITE_BUFFER: 		(ccb->wrbuff_callback) (dpt->unit, br_channel, br_target, 					br_offset, br_length, 					br_lun, ccb->status_packet.hba_stat); 		break; 	default: 		printf("dpt%d:  %s is an unsupported command for target mode\n", 		       dpt->unit, scsi_cmd_name(ccb->eata_ccb.cp_scsi_cmd)); 	} 	ospl = splsoftcam(); 	dpt->target_ccb[br_channel][br_target][br_lun] = NULL; 	dpt_Qpush_free(dpt, ccb); 	splx(ospl); }
comment|/*  * Use this function to register a client for a buffer read target operation.  * The function you register will be called every time a buffer is received  * by the target mode code.  */
end_comment

begin_comment
unit|dpt_rb_t dpt_register_buffer(int unit, u_int8_t channel, u_int8_t target, u_int8_t lun, 		    u_int8_t mode, u_int16_t length, u_int16_t offset, 		    dpt_rec_buff callback, dpt_rb_op_t op) { 	dpt_softc_t    *dpt; 	dpt_ccb_t      *ccb = NULL; 	int             ospl;  	for (dpt = TAILQ_FIRST(&dpt_softc_list); 	     dpt != NULL; 	     dpt = TAILQ_NEXT(dpt, links)) { 		if (dpt->unit == unit) 			goto valid_unit; 	}  	return (INVALID_UNIT);  valid_unit:  	if (dpt->state& DPT_HA_SHUTDOWN_ACTIVE) 		return (DRIVER_DOWN);  	if ((channel> (dpt->channels - 1)) || (target> (dpt->max_id - 1)) || 	    (lun> (dpt->max_lun - 1))) 		return (INVALID_SENDER);  	if (dpt->buffer_receiver[channel][target][lun] == NULL) { 		if (op == REGISTER_BUFFER) {
comment|/* Assign the requested callback */
end_comment

begin_comment
unit|dpt->buffer_receiver[channel][target][lun] = callback;
comment|/* Get a CCB */
end_comment

begin_comment
unit|ospl = splsoftcam();
comment|/* Process the free list */
end_comment

begin_comment
unit|if ((TAILQ_EMPTY(&dpt->free_ccbs))&& dpt_alloc_freelist(dpt)) { 				printf("dpt%d ERROR: Cannot allocate any more free CCB's.\n" 				       "             Please try later\n", 				       dpt->unit); 				splx(ospl); 				return (NO_RESOURCES); 			}
comment|/* Now grab the newest CCB */
end_comment

begin_comment
unit|if ((ccb = dpt_Qpop_free(dpt)) == NULL) { 				splx(ospl); 				panic("dpt%d: Got a NULL CCB from pop_free()\n", 				      dpt->unit); 			} 			splx(ospl);
comment|/* Clean up the leftover of the previous tenant */
end_comment

begin_comment
unit|ccb->status = DPT_CCB_STATE_NEW; 			dpt->target_ccb[channel][target][lun] = ccb;  			dpt->rw_buffer[channel][target][lun] = 				malloc(DPT_RW_BUFFER_SIZE, M_DEVBUF, M_NOWAIT); 			if (dpt->rw_buffer[channel][target][lun] == NULL) { 				printf("dpt%d: Failed to allocate " 				       "Target-Mode buffer\n", dpt->unit); 				ospl = splsoftcam(); 				dpt_Qpush_free(dpt, ccb); 				splx(ospl); 				return (NO_RESOURCES); 			} 			dpt_set_target(0, dpt, channel, target, lun, mode, 				       length, offset, ccb); 			return (SUCCESSFULLY_REGISTERED); 		} else 			return (NOT_REGISTERED); 	} else { 		if (op == REGISTER_BUFFER) { 			if (dpt->buffer_receiver[channel][target][lun] == callback) 				return (ALREADY_REGISTERED); 			else 				return (REGISTERED_TO_ANOTHER); 		} else { 			if (dpt->buffer_receiver[channel][target][lun] == callback) { 				dpt->buffer_receiver[channel][target][lun] = NULL; 				ospl = splsoftcam(); 				dpt_Qpush_free(dpt, ccb); 				splx(ospl); 				free(dpt->rw_buffer[channel][target][lun], M_DEVBUF); 				return (SUCCESSFULLY_REGISTERED); 			} else 				return (INVALID_CALLBACK); 		}  	} }
comment|/* Return the state of the blinking DPT LED's */
end_comment

begin_comment
unit|u_int8_t dpt_blinking_led(dpt_softc_t * dpt) { 	int             ndx; 	int             ospl; 	u_int32_t       state; 	u_int32_t       previous; 	u_int8_t        result;  	ospl = splcam();  	result = 0;  	for (ndx = 0, state = 0, previous = 0; 	     (ndx< 10)&& (state != previous); 	     ndx++) { 		previous = state; 		state = dpt_inl(dpt, 1); 	}  	if ((state == previous)&& (state == DPT_BLINK_INDICATOR)) 		result = dpt_inb(dpt, 5);  	splx(ospl); 	return (result); }
comment|/*  * Execute a command which did not come from the kernel's SCSI layer.  * The only way to map user commands to bus and target is to comply with the  * standard DPT wire-down scheme:  */
end_comment

begin_comment
unit|int dpt_user_cmd(dpt_softc_t * dpt, eata_pt_t * user_cmd, 	     caddr_t cmdarg, int minor_no) { 	dpt_ccb_t *ccb; 	void	  *data; 	int	   channel, target, lun; 	int	   huh; 	int	   result; 	int	   ospl; 	int	   submitted;  	data = NULL; 	channel = minor2hba(minor_no); 	target = minor2target(minor_no); 	lun = minor2lun(minor_no);  	if ((channel> (dpt->channels - 1)) 	 || (target> dpt->max_id) 	 || (lun> dpt->max_lun)) 		return (ENXIO);  	if (target == dpt->sc_scsi_link[channel].adapter_targ) {
comment|/* This one is for the controller itself */
end_comment

begin_comment
unit|if ((user_cmd->eataID[0] != 'E') 		 || (user_cmd->eataID[1] != 'A') 		 || (user_cmd->eataID[2] != 'T') 		 || (user_cmd->eataID[3] != 'A')) { 			return (ENXIO); 		} 	}
comment|/* Get a DPT CCB, so we can prepare a command */
end_comment

begin_comment
unit|ospl = splsoftcam();
comment|/* Process the free list */
end_comment

begin_comment
unit|if ((TAILQ_EMPTY(&dpt->free_ccbs))&& dpt_alloc_freelist(dpt)) { 		printf("dpt%d ERROR: Cannot allocate any more free CCB's.\n" 		       "             Please try later\n", 		       dpt->unit); 		splx(ospl); 		return (EFAULT); 	}
comment|/* Now grab the newest CCB */
end_comment

begin_comment
unit|if ((ccb = dpt_Qpop_free(dpt)) == NULL) { 		splx(ospl); 		panic("dpt%d: Got a NULL CCB from pop_free()\n", dpt->unit); 	} else { 		splx(ospl);
comment|/* Clean up the leftover of the previous tenant */
end_comment

begin_comment
unit|ccb->status = DPT_CCB_STATE_NEW; 	}  	bcopy((caddr_t)& user_cmd->command_packet, (caddr_t)& ccb->eata_ccb, 	      sizeof(eata_ccb_t));
comment|/* We do not want to do user specified scatter/gather.  Why?? */
end_comment

begin_comment
unit|if (ccb->eata_ccb.scatter == 1) 		return (EINVAL);  	ccb->eata_ccb.Auto_Req_Sen = 1; 	ccb->eata_ccb.reqlen = htonl(sizeof(struct scsi_sense_data)); 	ccb->eata_ccb.cp_datalen = htonl(sizeof(ccb->eata_ccb.cp_datalen)); 	ccb->eata_ccb.cp_dataDMA = htonl(vtophys(ccb->eata_ccb.cp_dataDMA)); 	ccb->eata_ccb.cp_statDMA = htonl(vtophys(&ccb->eata_ccb.cp_statDMA)); 	ccb->eata_ccb.cp_reqDMA = htonl(vtophys(&ccb->eata_ccb.cp_reqDMA)); 	ccb->eata_ccb.cp_viraddr = (u_int32_t)& ccb;  	if (ccb->eata_ccb.DataIn || ccb->eata_ccb.DataOut) {
comment|/* Data I/O is involved in this command.  Alocate buffer */
end_comment

begin_define
unit|if (ccb->eata_ccb.cp_datalen> PAGE_SIZE) { 			data = contigmalloc(ccb->eata_ccb.cp_datalen, 					    M_TEMP, M_WAITOK, 0, ~0, 					    ccb->eata_ccb.cp_datalen, 					    0x10000); 		} else { 			data = malloc(ccb->eata_ccb.cp_datalen, M_TEMP, 				      M_WAITOK); 		}  		if (data == NULL) { 			printf("dpt%d: Cannot allocate %d bytes " 			       "for EATA command\n", dpt->unit, 			       ccb->eata_ccb.cp_datalen); 			return (EFAULT); 		}
define|#
directive|define
name|usr_cmd_DMA
value|(caddr_t)user_cmd->command_packet.cp_dataDMA
end_define

begin_comment
unit|if (ccb->eata_ccb.DataIn == 1) { 			if (copyin(usr_cmd_DMA, 				   data, ccb->eata_ccb.cp_datalen) == -1) 				return (EFAULT); 		} 	} else {
comment|/* No data I/O involved here.  Make sure the DPT knows that */
end_comment

begin_comment
unit|ccb->eata_ccb.cp_datalen = 0; 		data = NULL; 	}  	if (ccb->eata_ccb.FWNEST == 1) 		ccb->eata_ccb.FWNEST = 0;  	if (ccb->eata_ccb.cp_datalen != 0) { 		if (dpt_scatter_gather(dpt, ccb, ccb->eata_ccb.cp_datalen, 				       data) != 0) { 			if (data != NULL) 				free(data, M_TEMP); 			return (EFAULT); 		} 	}
comment|/** 	 * We are required to quiet a SCSI bus. 	 * since we do not queue comands on a bus basis, 	 * we wait for ALL commands on a controller to complete. 	 * In the mean time, sched_queue() will not schedule new commands. 	 */
end_comment

begin_comment
unit|if ((ccb->eata_ccb.cp_cdb[0] == MULTIFUNCTION_CMD)&& (ccb->eata_ccb.cp_cdb[2] == BUS_QUIET)) {
comment|/* We wait for ALL traffic for this HBa to subside */
end_comment

begin_comment
unit|ospl = splsoftcam(); 		dpt->state |= DPT_HA_QUIET; 		splx(ospl);  		while ((submitted = dpt->submitted_ccbs_count) != 0) { 			huh = tsleep((void *) dpt, PCATCH | PRIBIO, "dptqt", 				     100 * hz); 			switch (huh) { 			case 0:
comment|/* Wakeup call received */
end_comment

begin_comment
unit|break; 			case EWOULDBLOCK:
comment|/* Timer Expired */
end_comment

begin_comment
unit|break; 			default:
comment|/* anything else */
end_comment

begin_comment
unit|break; 			} 		} 	}
comment|/* Resume normal operation */
end_comment

begin_comment
unit|if ((ccb->eata_ccb.cp_cdb[0] == MULTIFUNCTION_CMD)&& (ccb->eata_ccb.cp_cdb[2] == BUS_UNQUIET)) { 		ospl = splsoftcam(); 		dpt->state&= ~DPT_HA_QUIET; 		splx(ospl); 	}
comment|/** 	 * Schedule the command and submit it. 	 * We bypass dpt_sched_queue, as it will block on DPT_HA_QUIET 	 */
end_comment

begin_comment
unit|ccb->xs = NULL; 	ccb->flags = 0; 	ccb->eata_ccb.Auto_Req_Sen = 1;
comment|/* We always want this feature */
end_comment

begin_ifdef
unit|ccb->transaction_id = ++dpt->commands_processed; 	ccb->std_callback = (ccb_callback) dpt_user_cmd_done; 	ccb->result = (u_int32_t)& cmdarg; 	ccb->data = data;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_endif
unit|++dpt->performance.command_count[ccb->eata_ccb.cp_scsi_cmd]; 	ccb->command_started = microtime_now;
endif|#
directive|endif
end_endif

begin_comment
unit|ospl = splcam(); 	dpt_Qadd_waiting(dpt, ccb); 	splx(ospl);  	dpt_sched_queue(dpt);
comment|/* Wait for the command to complete */
end_comment

begin_comment
unit|(void) tsleep((void *) ccb, PCATCH | PRIBIO, "dptucw", 100 * hz);
comment|/* Free allocated memory */
end_comment

begin_comment
unit|if (data != NULL) 		free(data, M_TEMP);  	return (0); }  static void dpt_user_cmd_done(dpt_softc_t * dpt, int bus, dpt_ccb_t * ccb) { 	int             ospl = splsoftcam(); 	u_int32_t       result; 	caddr_t         cmd_arg;
comment|/** 	 * If Auto Request Sense is on, copyout the sense struct 	 */
end_comment

begin_define
define|#
directive|define
name|usr_pckt_DMA
value|(caddr_t)(intptr_t)ntohl(ccb->eata_ccb.cp_reqDMA)
end_define

begin_define
define|#
directive|define
name|usr_pckt_len
value|ntohl(ccb->eata_ccb.cp_datalen)
end_define

begin_comment
unit|if (ccb->eata_ccb.Auto_Req_Sen == 1) { 		if (copyout((caddr_t)& ccb->sense_data, usr_pckt_DMA, 			    sizeof(struct scsi_sense_data))) { 			ccb->result = EFAULT; 			dpt_Qpush_free(dpt, ccb); 			splx(ospl); 			wakeup(ccb); 			return; 		} 	}
comment|/* If DataIn is on, copyout the data */
end_comment

begin_comment
unit|if ((ccb->eata_ccb.DataIn == 1)&& (ccb->status_packet.hba_stat == HA_NO_ERROR)) { 		if (copyout(ccb->data, usr_pckt_DMA, usr_pckt_len)) { 			dpt_Qpush_free(dpt, ccb); 			ccb->result = EFAULT;  			splx(ospl); 			wakeup(ccb); 			return; 		} 	}
comment|/* Copyout the status */
end_comment

begin_comment
unit|result = ccb->status_packet.hba_stat; 	cmd_arg = (caddr_t) ccb->result;  	if (copyout((caddr_t)& result, cmd_arg, sizeof(result))) { 		dpt_Qpush_free(dpt, ccb); 		ccb->result = EFAULT; 		splx(ospl); 		wakeup(ccb); 		return; 	}
comment|/* Put the CCB back in the freelist */
end_comment

begin_comment
unit|ccb->state |= DPT_CCB_STATE_COMPLETED; 	dpt_Qpush_free(dpt, ccb);
comment|/* Free allocated memory */
end_comment

begin_ifdef
unit|splx(ospl); 	return; }
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
end_ifdef

begin_comment
comment|/**  * This function walks down the SUBMITTED queue.  * Every request that is too old gets aborted and marked.  * Since the DPT will complete (interrupt) immediately (what does that mean?),  * We just walk the list, aborting old commands and marking them as such.  * The dpt_complete function will get rid of the that were interrupted in the  * normal manner.  *  * This function needs to run at splcam(), as it interacts with the submitted  * queue, as well as the completed and free queues.  Just like dpt_intr() does.  * To run it at any ISPL other than that of dpt_intr(), will mean that dpt_intr  * willbe able to pre-empt it, grab a transaction in progress (towards  * destruction) and operate on it.  The state of this transaction will be not  * very clear.  * The only other option, is to lock it only as long as necessary but have  * dpt_intr() spin-wait on it. In a UP environment this makes no sense and in  * a SMP environment, the advantage is dubvious for a function that runs once  * every ten seconds for few microseconds and, on systems with healthy  * hardware, does not do anything anyway.  */
end_comment

begin_comment
unit|static void dpt_handle_timeouts(dpt_softc_t * dpt) { 	dpt_ccb_t      *ccb; 	int             ospl;  	ospl = splcam();  	if (dpt->state& DPT_HA_TIMEOUTS_ACTIVE) { 		printf("dpt%d WARNING: Timeout Handling Collision\n", 		       dpt->unit); 		splx(ospl); 		return; 	} 	dpt->state |= DPT_HA_TIMEOUTS_ACTIVE;
comment|/* Loop through the entire submitted queue, looking for lost souls */
end_comment

begin_define
unit|for (ccb = TAILQ_FIRST(&dpt->submitted_ccbs); 	     ccb != NULL; 	     ccb = TAILQ_NEXT(ccb, links)) { 		struct scsi_xfer *xs; 		u_int32_t       age, max_age;  		xs = ccb->xs; 		age = dpt_time_delta(ccb->command_started, microtime_now);
define|#
directive|define
name|TenSec
value|10000000
end_define

begin_comment
unit|if (xs == NULL) {
comment|/* Local, non-kernel call */
end_comment

begin_comment
unit|max_age = TenSec; 		} else { 			max_age = (((xs->timeout * (dpt->submitted_ccbs_count 						    + DPT_TIMEOUT_FACTOR))> TenSec) 				 ? (xs->timeout * (dpt->submitted_ccbs_count 						   + DPT_TIMEOUT_FACTOR)) 				   : TenSec); 		}
comment|/* 		 * If a transaction is marked lost and is TWICE as old as we 		 * care, then, and only then do we destroy it! 		 */
end_comment

begin_comment
unit|if (ccb->state& DPT_CCB_STATE_MARKED_LOST) {
comment|/* Remember who is next */
end_comment

begin_define
unit|if (age> (max_age * 2)) { 				dpt_Qremove_submitted(dpt, ccb); 				ccb->state&= ~DPT_CCB_STATE_MARKED_LOST; 				ccb->state |= DPT_CCB_STATE_ABORTED;
define|#
directive|define
name|cmd_name
value|scsi_cmd_name(ccb->eata_ccb.cp_scsi_cmd)
end_define

begin_define
unit|if (ccb->retries++> DPT_RETRIES) { 					printf("dpt%d ERROR: Destroying stale " 					       "%d (%s)\n" 					       "		on " 					       "c%db%dt%du%d (%d/%d)\n", 					     dpt->unit, ccb->transaction_id, 					       cmd_name, 					       dpt->unit, 					       ccb->eata_ccb.cp_channel, 					       ccb->eata_ccb.cp_id, 					       ccb->eata_ccb.cp_LUN, age, 					       ccb->retries);
define|#
directive|define
name|send_ccb
value|&ccb->eata_ccb
end_define

begin_define
define|#
directive|define
name|ESA
value|EATA_SPECIFIC_ABORT
end_define

begin_comment
unit|(void) dpt_send_immediate(dpt, 								  send_ccb, 								  ESA, 								  0, 0); 					dpt_Qpush_free(dpt, ccb);
comment|/* The SCSI layer should re-try */
end_comment

begin_comment
unit|xs->error |= XS_TIMEOUT; 					xs->flags |= SCSI_ITSDONE; 					scsi_done(xs); 				} else { 					printf("dpt%d ERROR: Stale %d (%s) on " 					       "c%db%dt%du%d (%d)\n" 					     "		gets another " 					       "chance(%d/%d)\n", 					     dpt->unit, ccb->transaction_id, 					       cmd_name, 					       dpt->unit, 					       ccb->eata_ccb.cp_channel, 					       ccb->eata_ccb.cp_id, 					       ccb->eata_ccb.cp_LUN, 					    age, ccb->retries, DPT_RETRIES);  					dpt_Qpush_waiting(dpt, ccb); 					dpt_sched_queue(dpt); 				} 			} 		} else {
comment|/* 			 * This is a transaction that is not to be destroyed 			 * (yet) But it is too old for our liking. We wait as 			 * long as the upper layer thinks. Not really, we 			 * multiply that by the number of commands in the 			 * submitted queue + 1. 			 */
end_comment

begin_endif
unit|if (!(ccb->state& DPT_CCB_STATE_MARKED_LOST)&& 			    (age != ~0)&& (age> max_age)) { 				printf("dpt%d ERROR: Marking %d (%s) on " 				       "c%db%dt%du%d \n" 				       "            as late after %dusec\n", 				       dpt->unit, ccb->transaction_id, 				       cmd_name, 				       dpt->unit, ccb->eata_ccb.cp_channel, 				       ccb->eata_ccb.cp_id, 				       ccb->eata_ccb.cp_LUN, age); 				ccb->state |= DPT_CCB_STATE_MARKED_LOST; 			} 		} 	}  	dpt->state&= ~DPT_HA_TIMEOUTS_ACTIVE; 	splx(ospl); }  static void dpt_timeout(void *arg) { 	dpt_softc_t    *dpt = (dpt_softc_t *) arg;  	if (!(dpt->state& DPT_HA_TIMEOUTS_ACTIVE)) 		dpt_handle_timeouts(dpt);  	timeout(dpt_timeout, (caddr_t) dpt, hz * 10); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_HANDLE_TIMEOUTS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

