begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  *       Copyright (c) 1997 by Simon Shapiro  *       All Rights Reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * dpt_scsi.c: SCSI dependant code for the DPT driver  *  * credits:	Assisted by Mike Neuffer in the early low level DPT code  *		Thanx to Mark Salyzyn of DPT for his assistance.  *		Special thanx to Justin Gibbs for invaluable help in  *		making this driver look and work like a FreeBSD component.  *		Last but not least, many thanx to UCB and the FreeBSD  *		team for creating and maintaining such a wonderful O/S.  *  * TODO: * Add ISA probe code.  *	     * Add driver-level RSID-0. This will allow interoperability with  *	       NiceTry, M$-Doze, Win-Dog, Slowlaris, etc., in recognizing RAID  *	       arrays that span controllers (Wow!).  */
end_comment

begin_comment
comment|/**  * IMPORTANT:  *	There are two critical section "levels" used in this driver:  *	splcam() and splsoftcam().  Splcam() protects us from re-entrancy  *	from both our software and hardware interrupt handler.  Splsoftcam()  *	protects us only from our software interrupt handler.  The two  *	main data structures that need protection are the submitted and  *	completed queue.  *  *	There are three places where the submitted queue is accessed:  *  *       1.  dpt_run_queue        inserts into the queue  *       2.  dpt_intr             removes from the queue  *       3   dpt_handle_timeouts  potentially removes from the queue.  *  *	There are three places where the the completed queue is accessed:  *       1.  dpt_intr()            inserts into the queue  *       2.  dpt_sintr()           removes from the queue  *       3.  dpt_handle_timeouts   potentially inserts into the queue  */
end_comment

begin_empty
empty|#ident "$Id: dpt_scsi.c,v 1.8 1998/08/05 00:54:36 eivind Exp $"
end_empty

begin_define
define|#
directive|define
name|_DPT_C_
end_define

begin_include
include|#
directive|include
file|"opt_dpt.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/ipl.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* The HBA reset option uses the same timer as the lost IRQ option*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|DPT_LOST_IRQ
end_ifndef

begin_define
define|#
directive|define
name|DPT_LOST_IRQ
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/dpt.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INLINE
end_ifdef

begin_undef
undef|#
directive|undef
name|INLINE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INLINE
value|__inline
end_define

begin_define
define|#
directive|define
name|INLINE_Q
end_define

begin_comment
comment|/* dpt_isa.c, dpt_eisa.c, and dpt_pci.c need this in a central place */
end_comment

begin_decl_stmt
name|int
name|dpt_controllers_present
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function Prototypes */
end_comment

begin_define
define|#
directive|define
name|microtime_now
value|dpt_time_now()
end_define

begin_function_decl
specifier|static
name|INLINE
name|u_int32_t
name|dpt_inl
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|u_int8_t
name|dpt_inb
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|void
name|dpt_outb
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|u_int8_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|void
name|dpt_outl
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qpush_free
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|dpt_ccb_t
modifier|*
name|dpt_Qpop_free
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qadd_waiting
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qpush_waiting
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qremove_waiting
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qadd_submitted
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qremove_submitted
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qadd_completed
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE_Q
name|void
name|dpt_Qremove_completed
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_send_eata_command
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|int32_t
name|retries
parameter_list|,
name|u_int8_t
name|ifc
parameter_list|,
name|u_int8_t
name|code
parameter_list|,
name|u_int8_t
name|code2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|int
name|dpt_send_immediate
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int8_t
name|ifc
parameter_list|,
name|u_int8_t
name|code
parameter_list|,
name|u_int8_t
name|code2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|int
name|dpt_just_reset
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|int
name|dpt_raid_busy
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|void
name|dpt_sched_queue
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_function_decl
specifier|static
name|void
name|dpt_IObySize
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|dpt_swi_register
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|dpt_handle_timeouts
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_timeout
parameter_list|(
name|void
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_LOST_IRQ
end_ifdef

begin_function_decl
specifier|static
name|void
name|dpt_irq_timeout
parameter_list|(
name|void
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|scsi_inquiry_data
name|s_inq_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|dpt_scatter_gather
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|data_length
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_alloc_freelist
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_run_queue
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|requests
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_complete
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_process_completion
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_set_target
parameter_list|(
name|int
name|redo
parameter_list|,
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int8_t
name|bus
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_target_ccb
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|bus
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_target_done
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|bus
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_user_cmd_done
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|bus
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int8_t
name|dpt_blinking_led
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_user_cmd
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_pt_t
modifier|*
name|user_cmd
parameter_list|,
name|caddr_t
name|cmdarg
parameter_list|,
name|int
name|minor_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dpt_detect_cache
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dpt_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hex_dump
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|length
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|i2bin
parameter_list|(
name|unsigned
name|int
name|no
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dpt_conf_t
modifier|*
name|dpt_get_conf
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|size
parameter_list|,
name|int
name|extent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dpt_inq_t
modifier|*
name|dpt_get_board_data
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|target_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_setup
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_conf_t
modifier|*
name|conf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_attach
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|dpt_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dptminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_sintr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|scsi_cmd_name
parameter_list|(
name|u_int8_t
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dpt_rb_t
name|dpt_register_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_int8_t
name|channel
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|u_int8_t
name|mode
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|dpt_rec_buff
name|callback
parameter_list|,
name|dpt_rb_op_t
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_send_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_int8_t
name|channel
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|u_int8_t
name|mode
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|buff_wr_done
name|callback
parameter_list|)
function_decl|;
end_function_decl

begin_extern
extern|extern void     (*ihandlers[32]
end_extern

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|dpt_unit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This one is kernel-related, do not touch! */
end_comment

begin_comment
comment|/* The linked list of softc structures */
end_comment

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|dpt_softc
argument_list|)
end_macro

begin_expr_stmt
name|dpt_softc_list
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|dpt_softc_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * These will have to be setup by parameters passed at boot/load time. For  * perfromance reasons, we make them constants for the time being.  */
end_comment

begin_define
define|#
directive|define
name|dpt_min_segs
value|DPT_MAX_SEGS
end_define

begin_define
define|#
directive|define
name|dpt_max_segs
value|DPT_MAX_SEGS
end_define

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|dpt_switch
init|=
block|{
name|dpt_scsi_cmd
block|,
name|dptminphys
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"dpt"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|dpt_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"dpt"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Software Interrupt Vector */
end_comment

begin_function
specifier|static
name|void
name|dpt_swi_register
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|ihandlers
index|[
name|SWI_CAMBIO
index|]
operator|=
name|dpt_sintr
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|dpt_camswi
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|dpt_swi_register
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/* These functions allows us to do memory mapped I/O, if hardware supported. */
end_comment

begin_function
specifier|static
name|INLINE
name|u_int8_t
name|dpt_inb
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|)
block|{
name|u_int8_t
name|result
decl_stmt|;
if|if
condition|(
name|dpt
operator|->
name|v_membase
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
name|dpt
operator|->
name|v_membase
index|[
name|offset
index|]
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|inb
argument_list|(
name|dpt
operator|->
name|io_base
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|u_int32_t
name|dpt_inl
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|)
block|{
name|u_int32_t
name|result
decl_stmt|;
if|if
condition|(
name|dpt
operator|->
name|v_membase
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
operator|(
operator|&
name|dpt
operator|->
name|v_membase
index|[
name|offset
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|inl
argument_list|(
name|dpt
operator|->
name|io_base
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dpt_outb
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|u_int8_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|dpt
operator|->
name|v_membase
operator|!=
name|NULL
condition|)
block|{
name|dpt
operator|->
name|v_membase
index|[
name|offset
index|]
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|dpt
operator|->
name|io_base
operator|+
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dpt_outl
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
if|if
condition|(
name|dpt
operator|->
name|v_membase
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
operator|(
operator|&
name|dpt
operator|->
name|v_membase
index|[
name|offset
index|]
operator|)
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|outl
argument_list|(
name|dpt
operator|->
name|io_base
operator|+
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|INLINE
name|void
name|dpt_sched_queue
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_QUIET
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Under Quiet Busses Condition.  "
literal|"No Commands are submitted\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|setsoftcambio
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|dpt_wait
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int8_t
name|bits
parameter_list|,
name|u_int8_t
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20000
condition|;
name|i
operator|++
control|)
block|{
comment|/* wait 20ms for not busy */
name|c
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
operator|&
name|bits
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|dpt_just_reset
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|2
argument_list|)
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|3
argument_list|)
operator|==
literal|'P'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|4
argument_list|)
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|5
argument_list|)
operator|==
literal|'H'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|INLINE
name|int
name|dpt_raid_busy
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|0
argument_list|)
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|1
argument_list|)
operator|==
literal|'P'
operator|)
operator|&&
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|2
argument_list|)
operator|==
literal|'T'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
end_ifdef

begin_comment
comment|/* **	Function name : dpt_reset_hba ** **	Description : Reset the HBA and properly discard all pending work **	Input :       Minor Device Number **	Output :      Nothing */
end_comment

begin_function
specifier|static
name|void
name|dpt_reset_hba
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|eata_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|dpt_ccb_t
name|dccb
decl_stmt|,
modifier|*
name|dccbp
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
comment|/* Prepare a control block.  The SCSI command part is immaterial */
name|dccb
operator|.
name|xs
operator|=
name|NULL
expr_stmt|;
name|dccb
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dccb
operator|.
name|state
operator|=
name|DPT_CCB_STATE_NEW
expr_stmt|;
name|dccb
operator|.
name|std_callback
operator|=
name|NULL
expr_stmt|;
name|dccb
operator|.
name|wrbuff_callback
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|=
operator|&
name|dccb
operator|.
name|eata_ccb
expr_stmt|;
name|ccb
operator|->
name|CP_OpCode
operator|=
name|EATA_CMD_RESET
expr_stmt|;
name|ccb
operator|->
name|SCSI_Reset
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|HBA_Init
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|cp_id
operator|=
literal|0
expr_stmt|;
comment|/* Should be ignored */
name|ccb
operator|->
name|DataIn
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|DataOut
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|Interpret
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|reqlen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ccb
operator|->
name|cp_statDMA
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ccb
operator|->
name|cp_reqDMA
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|ccb
expr_stmt|;
name|ccb
operator|->
name|cp_msg
index|[
literal|0
index|]
operator|=
name|HA_IDENTIFY_MSG
operator||
name|HA_DISCO_RECO
expr_stmt|;
name|ccb
operator|->
name|cp_scsi_cmd
operator|=
literal|0
expr_stmt|;
comment|/* Should be ignored */
comment|/* Lock up the submitted queue.  We are very persistant here */
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
name|dpt
operator|->
name|queue_status
operator|&
name|DPT_SUBMITTED_QUEUE_ACTIVE
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|dpt
operator|->
name|queue_status
operator||=
name|DPT_SUBMITTED_QUEUE_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* Send the RESET message */
if|if
condition|(
operator|(
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|dccb
operator|.
name|eata_ccb
argument_list|,
name|EATA_CMD_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Failed to send the RESET message.\n"
literal|"      Trying cold boot (ouch!)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|dccb
operator|.
name|eata_ccb
argument_list|,
name|EATA_COLD_BOOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"dpt%d:  Faild to cold boot the HBA\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt
operator|->
name|performance
operator|.
name|cold_boots
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
block|}
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt
operator|->
name|performance
operator|.
name|warm_starts
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
name|printf
argument_list|(
literal|"dpt%d:  Aborting pending requests.  O/S should re-submit\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dccbp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|completed_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|dccbp
operator|->
name|xs
decl_stmt|;
comment|/* Not all transactions have xs structs */
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
comment|/* Tell the kernel proper this did not complete well */
name|xs
operator|->
name|error
operator||=
name|XS_SELTIMEOUT
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|dpt_Qremove_submitted
argument_list|(
name|dpt
argument_list|,
name|dccbp
argument_list|)
expr_stmt|;
comment|/* Remember, Callbacks are NOT in the standard queue */
if|if
condition|(
name|dccbp
operator|->
name|std_callback
operator|!=
name|NULL
condition|)
block|{
call|(
name|dccbp
operator|->
name|std_callback
call|)
argument_list|(
name|dpt
argument_list|,
name|dccbp
operator|->
name|eata_ccb
operator|.
name|cp_channel
argument_list|,
name|dccbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|dccbp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"dpt%d: reset done aborting all pending commands\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|queue_status
operator|&=
operator|~
name|DPT_SUBMITTED_QUEUE_ACTIVE
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_RESET_HBA */
end_comment

begin_comment
comment|/**  * Build a Command Block for target mode READ/WRITE BUFFER,  * with the ``sync'' bit ON.  *  * Although the length and offset are 24 bit fields in the command, they cannot  * exceed 8192 bytes, so we take them as short integers andcheck their range.  *  If they are sensless, we round them to zero offset, maximum length and complain.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_target_ccb
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|bus
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|)
block|{
name|eata_ccb_t
modifier|*
name|cp
decl_stmt|;
name|int
name|ospl
decl_stmt|;
if|if
condition|(
operator|(
name|length
operator|+
name|offset
operator|)
operator|>
name|DPT_MAX_TARGET_MODE_BUFFER_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d:  Length of %d, and offset of %d are wrong\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|length
operator|=
name|DPT_MAX_TARGET_MODE_BUFFER_SIZE
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|ccb
operator|->
name|xs
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|state
operator|=
name|DPT_CCB_STATE_NEW
expr_stmt|;
name|ccb
operator|->
name|std_callback
operator|=
operator|(
name|ccb_callback
operator|)
name|dpt_target_done
expr_stmt|;
name|ccb
operator|->
name|wrbuff_callback
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
operator|&
name|ccb
operator|->
name|eata_ccb
expr_stmt|;
name|cp
operator|->
name|CP_OpCode
operator|=
name|EATA_CMD_DMA_SEND_CP
expr_stmt|;
name|cp
operator|->
name|SCSI_Reset
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|HBA_Init
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|cp_id
operator|=
name|target
expr_stmt|;
name|cp
operator|->
name|DataIn
operator|=
literal|1
expr_stmt|;
name|cp
operator|->
name|DataOut
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|Interpret
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|reqlen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|cp_statDMA
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|cp
operator|->
name|cp_reqDMA
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|ccb
expr_stmt|;
name|cp
operator|->
name|cp_msg
index|[
literal|0
index|]
operator|=
name|HA_IDENTIFY_MSG
operator||
name|HA_DISCO_RECO
expr_stmt|;
name|cp
operator|->
name|cp_scsi_cmd
operator|=
name|command
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|mode
operator|&
name|SCSI_TM_MODE_MASK
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cp_lun
operator|=
name|lun
expr_stmt|;
comment|/* Order is important here! */
name|cp
operator|->
name|cp_cdb
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* Buffer Id, only 1 :-( */
name|cp
operator|->
name|cp_cdb
index|[
literal|3
index|]
operator|=
operator|(
name|length
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* Buffer offset MSB */
name|cp
operator|->
name|cp_cdb
index|[
literal|4
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|5
index|]
operator|=
name|length
operator|&
literal|0xFF
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|6
index|]
operator|=
operator|(
name|length
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* Length MSB */
name|cp
operator|->
name|cp_cdb
index|[
literal|7
index|]
operator|=
operator|(
name|length
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|cp
operator|->
name|cp_cdb
index|[
literal|8
index|]
operator|=
name|length
operator|&
literal|0xFF
expr_stmt|;
comment|/* Length LSB */
name|cp
operator|->
name|cp_cdb
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
comment|/* No sync, no match bits */
comment|/** 	 * This could be optimized to live in dpt_register_buffer. 	 *  We keep it here, just in case the kernel decides to reallocate pages 	 */
if|if
condition|(
name|dpt_scatter_gather
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|DPT_RW_BUFFER_SIZE
argument_list|,
name|dpt
operator|->
name|rw_buffer
index|[
name|bus
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Failed to setup Scatter/Gather for Target-Mode buffer\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Setup a target mode READ command */
end_comment

begin_function
specifier|static
name|void
name|dpt_set_target
parameter_list|(
name|int
name|redo
parameter_list|,
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int8_t
name|bus
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|int
name|mode
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|ospl
decl_stmt|;
if|if
condition|(
name|dpt
operator|->
name|target_mode_enabled
condition|)
block|{
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|redo
condition|)
name|dpt_target_ccb
argument_list|(
name|dpt
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|ccb
argument_list|,
name|mode
argument_list|,
name|SCSI_TM_READ_BUFFER
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|transaction_id
operator|=
operator|++
name|dpt
operator|->
name|commands_processed
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
index|]
operator|++
expr_stmt|;
name|ccb
operator|->
name|command_started
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
name|dpt_Qadd_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dpt%d:  Target Mode Request, but Target Mode is OFF\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Schedule a buffer to be sent to another target.  * The work will be scheduled and the callback provided will be called when  * the work is actually done.  *  * Please NOTE:  ``Anyone'' can send a buffer, but only registered clients  * get notified of receipt of buffers.  */
end_comment

begin_function
name|int
name|dpt_send_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_int8_t
name|channel
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|u_int8_t
name|mode
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|buff_wr_done
name|callback
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|ospl
decl_stmt|;
comment|/* This is an external call.  Be a bit paranoid */
for|for
control|(
name|dpt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt_softc_list
argument_list|)
init|;
name|dpt
operator|!=
name|NULL
condition|;
name|dpt
operator|=
name|TAILQ_NEXT
argument_list|(
name|dpt
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|dpt
operator|->
name|unit
operator|==
name|unit
condition|)
goto|goto
name|valid_unit
goto|;
block|}
return|return
operator|(
name|INVALID_UNIT
operator|)
return|;
name|valid_unit
label|:
if|if
condition|(
name|dpt
operator|->
name|target_mode_enabled
condition|)
block|{
if|if
condition|(
operator|(
name|channel
operator|>=
name|dpt
operator|->
name|channels
operator|)
operator|||
operator|(
name|target
operator|>
name|dpt
operator|->
name|max_id
operator|)
operator|||
operator|(
name|lun
operator|>
name|dpt
operator|->
name|max_lun
operator|)
condition|)
block|{
return|return
operator|(
name|INVALID_SENDER
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dpt
operator|->
name|rw_buffer
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dpt
operator|->
name|buffer_receiver
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NOT_REGISTERED
operator|)
return|;
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* Process the free list */
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|)
operator|)
operator|&&
name|dpt_alloc_freelist
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Cannot allocate any more free CCB's.\n"
literal|"             Please try later\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO_RESOURCES
operator|)
return|;
block|}
comment|/* Now grab the newest CCB */
if|if
condition|(
operator|(
name|ccb
operator|=
name|dpt_Qpop_free
argument_list|(
name|dpt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"dpt%d: Got a NULL CCB from pop_free()\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dpt
operator|->
name|rw_buffer
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|+
name|offset
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|dpt_target_ccb
argument_list|(
name|dpt
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|ccb
argument_list|,
name|mode
argument_list|,
name|SCSI_TM_WRITE_BUFFER
argument_list|,
name|length
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|std_callback
operator|=
operator|(
name|ccb_callback
operator|)
name|callback
expr_stmt|;
comment|/* Potential trouble */
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|transaction_id
operator|=
operator|++
name|dpt
operator|->
name|commands_processed
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
index|]
operator|++
expr_stmt|;
name|ccb
operator|->
name|command_started
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
name|dpt_Qadd_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|DRIVER_DOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dpt_target_done
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|bus
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|ospl
init|=
name|splsoftcam
argument_list|()
decl_stmt|;
name|eata_ccb_t
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|&
name|ccb
operator|->
name|eata_ccb
expr_stmt|;
comment|/** 	 * Remove the CCB from the waiting queue. 	 *  We do NOT put it back on the free, etc., queues as it is a special 	 * ccb, owned by the dpt_softc of this unit. 	 */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qremove_completed
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
define|#
directive|define
name|br_channel
value|(ccb->eata_ccb.cp_channel)
define|#
directive|define
name|br_target
value|(ccb->eata_ccb.cp_id)
define|#
directive|define
name|br_lun
value|(ccb->eata_ccb.cp_LUN)
define|#
directive|define
name|br_index
value|[br_channel][br_target][br_lun]
define|#
directive|define
name|read_buffer_callback
value|(dpt->buffer_receiver br_index )
define|#
directive|define
name|read_buffer
value|(dpt->rw_buffer[br_channel][br_target][br_lun])
define|#
directive|define
name|cb
parameter_list|(
name|offset
parameter_list|)
value|(ccb->eata_ccb.cp_cdb[offset])
define|#
directive|define
name|br_offset
value|((cb(3)<< 16) | (cb(4)<< 8) | cb(5))
define|#
directive|define
name|br_length
value|((cb(6)<< 16) | (cb(7)<< 8) | cb(8))
comment|/* Different reasons for being here, you know... */
switch|switch
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
condition|)
block|{
case|case
name|SCSI_TM_READ_BUFFER
case|:
if|if
condition|(
name|read_buffer_callback
operator|!=
name|NULL
condition|)
block|{
comment|/* This is a buffer generated by a kernel process */
name|read_buffer_callback
argument_list|(
name|dpt
operator|->
name|unit
argument_list|,
name|br_channel
argument_list|,
name|br_target
argument_list|,
name|br_lun
argument_list|,
name|read_buffer
argument_list|,
name|br_offset
argument_list|,
name|br_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This is a buffer waited for by a user (sleeping) 			 * command 			 */
name|wakeup
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* We ALWAYS re-issue the same command; args are don't-care  */
name|dpt_set_target
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_TM_WRITE_BUFFER
case|:
call|(
name|ccb
operator|->
name|wrbuff_callback
call|)
argument_list|(
name|dpt
operator|->
name|unit
argument_list|,
name|br_channel
argument_list|,
name|br_target
argument_list|,
name|br_offset
argument_list|,
name|br_length
argument_list|,
name|br_lun
argument_list|,
name|ccb
operator|->
name|status_packet
operator|.
name|hba_stat
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"dpt%d:  %s is an unsupported command for target mode\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|scsi_cmd_name
argument_list|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|target_ccb
index|[
name|br_channel
index|]
index|[
name|br_target
index|]
index|[
name|br_lun
index|]
operator|=
name|NULL
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Use this function to register a client for a buffer read target operation.  * The function you register will be called every time a buffer is received  * by the target mode code.  */
end_comment

begin_function
name|dpt_rb_t
name|dpt_register_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_int8_t
name|channel
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|lun
parameter_list|,
name|u_int8_t
name|mode
parameter_list|,
name|u_int16_t
name|length
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|dpt_rec_buff
name|callback
parameter_list|,
name|dpt_rb_op_t
name|op
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|ccb
init|=
name|NULL
decl_stmt|;
name|int
name|ospl
decl_stmt|;
for|for
control|(
name|dpt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt_softc_list
argument_list|)
init|;
name|dpt
operator|!=
name|NULL
condition|;
name|dpt
operator|=
name|TAILQ_NEXT
argument_list|(
name|dpt
argument_list|,
name|links
argument_list|)
control|)
block|{
if|if
condition|(
name|dpt
operator|->
name|unit
operator|==
name|unit
condition|)
goto|goto
name|valid_unit
goto|;
block|}
return|return
operator|(
name|INVALID_UNIT
operator|)
return|;
name|valid_unit
label|:
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
return|return
operator|(
name|DRIVER_DOWN
operator|)
return|;
if|if
condition|(
operator|(
name|channel
operator|>
operator|(
name|dpt
operator|->
name|channels
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|target
operator|>
operator|(
name|dpt
operator|->
name|max_id
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|lun
operator|>
operator|(
name|dpt
operator|->
name|max_lun
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|INVALID_SENDER
operator|)
return|;
if|if
condition|(
name|dpt
operator|->
name|buffer_receiver
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|op
operator|==
name|REGISTER_BUFFER
condition|)
block|{
comment|/* Assign the requested callback */
name|dpt
operator|->
name|buffer_receiver
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|callback
expr_stmt|;
comment|/* Get a CCB */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* Process the free list */
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|)
operator|)
operator|&&
name|dpt_alloc_freelist
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Cannot allocate any more free CCB's.\n"
literal|"             Please try later\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO_RESOURCES
operator|)
return|;
block|}
comment|/* Now grab the newest CCB */
if|if
condition|(
operator|(
name|ccb
operator|=
name|dpt_Qpop_free
argument_list|(
name|dpt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"dpt%d: Got a NULL CCB from pop_free()\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* Clean up the leftover of the previous tenant */
name|ccb
operator|->
name|status
operator|=
name|DPT_CCB_STATE_NEW
expr_stmt|;
name|dpt
operator|->
name|target_ccb
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|ccb
expr_stmt|;
name|dpt
operator|->
name|rw_buffer
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|malloc
argument_list|(
name|DPT_RW_BUFFER_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|rw_buffer
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Failed to allocate Target-Mode buffer\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NO_RESOURCES
operator|)
return|;
block|}
name|dpt_set_target
argument_list|(
literal|0
argument_list|,
name|dpt
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|mode
argument_list|,
name|length
argument_list|,
name|offset
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_REGISTERED
operator|)
return|;
block|}
else|else
return|return
operator|(
name|NOT_REGISTERED
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|op
operator|==
name|REGISTER_BUFFER
condition|)
block|{
if|if
condition|(
name|dpt
operator|->
name|buffer_receiver
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|callback
condition|)
return|return
operator|(
name|ALREADY_REGISTERED
operator|)
return|;
else|else
return|return
operator|(
name|REGISTERED_TO_ANOTHER
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|dpt
operator|->
name|buffer_receiver
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|==
name|callback
condition|)
block|{
name|dpt
operator|->
name|buffer_receiver
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
operator|=
name|NULL
expr_stmt|;
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dpt
operator|->
name|rw_buffer
index|[
name|channel
index|]
index|[
name|target
index|]
index|[
name|lun
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_REGISTERED
operator|)
return|;
block|}
else|else
return|return
operator|(
name|INVALID_CALLBACK
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * This routine will try to send an EATA command to the DPT HBA.  * It will, by default, try AHZ times, waiting 10ms between tries.  * It returns 0 on success and 1 on failure.  * It assumes the caller protects it with splbio() or some such.  *  * IMPORTANT:  We do NOT protect the ports from multiple access in here.  *             You are expected to do it in the calling routine.  *             Here, we cannot have any clue as to the scope of your work.  */
end_comment

begin_function
specifier|static
name|int
name|dpt_send_eata_command
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|int32_t
name|retries
parameter_list|,
name|u_int8_t
name|ifc
parameter_list|,
name|u_int8_t
name|code
parameter_list|,
name|u_int8_t
name|code2
parameter_list|)
block|{
name|int32_t
name|loop
decl_stmt|;
name|u_int8_t
name|result
decl_stmt|;
name|u_int32_t
name|test
decl_stmt|;
name|u_int32_t
name|swapped_cmdaddr
decl_stmt|;
if|if
condition|(
operator|!
name|retries
condition|)
name|retries
operator|=
literal|10000
expr_stmt|;
comment|/* 	 * I hate this polling nonsense. Wish there was a way to tell the DPT 	 * to go get commands at its own pace,  or to interrupt when ready. 	 * In the mean time we will measure how many itterations it really 	 * takes. 	 */
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|retries
condition|;
name|loop
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|&
name|HA_ABUSY
operator|)
operator|==
literal|0
condition|)
break|break;
else|else
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loop
operator|<
name|retries
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
if|if
condition|(
name|loop
operator|>
name|dpt
operator|->
name|performance
operator|.
name|max_eata_tries
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_eata_tries
operator|=
name|loop
expr_stmt|;
if|if
condition|(
name|loop
operator|<
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
condition|)
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
operator|=
name|loop
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|command_too_busy
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* The controller is alive, advance the wedge timer */
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
name|dpt
operator|->
name|last_contact
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd_block
operator|!=
name|NULL
condition|)
block|{
name|swapped_cmdaddr
operator|=
name|vtophys
argument_list|(
name|cmd_block
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
name|swapped_cmdaddr
operator|=
operator|(
operator|(
name|swapped_cmdaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
operator|)
operator||
operator|(
operator|(
name|swapped_cmdaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator||
operator|(
operator|(
name|swapped_cmdaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
operator||
operator|(
name|swapped_cmdaddr
operator|&
literal|0xFF
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|swapped_cmdaddr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* And now the address */
name|dpt_outl
argument_list|(
name|dpt
argument_list|,
name|HA_WDMAADDR
argument_list|,
name|swapped_cmdaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|EATA_CMD_IMMEDIATE
condition|)
block|{
if|if
condition|(
name|cmd_block
operator|==
name|NULL
condition|)
block|{
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCODE2
argument_list|,
name|code2
argument_list|)
expr_stmt|;
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCODE
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WIFC
argument_list|,
name|ifc
argument_list|)
expr_stmt|;
block|}
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCOMMAND
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Send a command for immediate execution by the DPT  * See above function for IMPORTANT notes.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|dpt_send_immediate
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_ccb_t
modifier|*
name|cmd_block
parameter_list|,
name|u_int8_t
name|ifc
parameter_list|,
name|u_int8_t
name|code
parameter_list|,
name|u_int8_t
name|code2
parameter_list|)
block|{
return|return
operator|(
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
name|cmd_block
argument_list|,
name|EATA_CMD_IMMEDIATE
argument_list|,
comment|/* retries */
literal|1000000
argument_list|,
name|ifc
argument_list|,
name|code
argument_list|,
name|code2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the state of the blinking DPT LED's */
end_comment

begin_function
name|u_int8_t
name|dpt_blinking_led
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|u_int32_t
name|state
decl_stmt|;
name|u_int32_t
name|previous
decl_stmt|;
name|u_int8_t
name|result
decl_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
operator|,
name|state
operator|=
literal|0
operator|,
name|previous
operator|=
literal|0
init|;
operator|(
name|ndx
operator|<
literal|10
operator|)
operator|&&
operator|(
name|state
operator|!=
name|previous
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
name|previous
operator|=
name|state
expr_stmt|;
name|state
operator|=
name|dpt_inl
argument_list|(
name|dpt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|state
operator|==
name|previous
operator|)
operator|&&
operator|(
name|state
operator|==
name|DPT_BLINK_INDICATOR
operator|)
condition|)
name|result
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Execute a command which did not come from the kernel's SCSI layer.  * The only way to map user commands to bus and target is to comply with the  * standard DPT wire-down scheme:  */
end_comment

begin_function
name|int
name|dpt_user_cmd
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|eata_pt_t
modifier|*
name|user_cmd
parameter_list|,
name|caddr_t
name|cmdarg
parameter_list|,
name|int
name|minor_no
parameter_list|)
block|{
name|int
name|channel
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|int
name|huh
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|submitted
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
name|channel
operator|=
name|minor2hba
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
name|target
operator|=
name|minor2target
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
name|lun
operator|=
name|minor2lun
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|channel
operator|>
operator|(
name|dpt
operator|->
name|channels
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|target
operator|>
name|dpt
operator|->
name|max_id
operator|)
operator|||
operator|(
name|lun
operator|>
name|dpt
operator|->
name|max_lun
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|target
operator|==
name|dpt
operator|->
name|sc_scsi_link
index|[
name|channel
index|]
operator|.
name|adapter_targ
condition|)
block|{
comment|/* This one is for the controller itself */
if|if
condition|(
operator|(
name|user_cmd
operator|->
name|eataID
index|[
literal|0
index|]
operator|!=
literal|'E'
operator|)
operator|||
operator|(
name|user_cmd
operator|->
name|eataID
index|[
literal|1
index|]
operator|!=
literal|'A'
operator|)
operator|||
operator|(
name|user_cmd
operator|->
name|eataID
index|[
literal|2
index|]
operator|!=
literal|'T'
operator|)
operator|||
operator|(
name|user_cmd
operator|->
name|eataID
index|[
literal|3
index|]
operator|!=
literal|'A'
operator|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Get a DPT CCB, so we can prepare a command */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* Process the free list */
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|)
operator|)
operator|&&
name|dpt_alloc_freelist
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Cannot allocate any more free CCB's.\n"
literal|"             Please try later\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* Now grab the newest CCB */
if|if
condition|(
operator|(
name|ccb
operator|=
name|dpt_Qpop_free
argument_list|(
name|dpt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"dpt%d: Got a NULL CCB from pop_free()\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* Clean up the leftover of the previous tenant */
name|ccb
operator|->
name|status
operator|=
name|DPT_CCB_STATE_NEW
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|user_cmd
operator|->
name|command_packet
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ccb
operator|->
name|eata_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|eata_ccb_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not want to do user specified scatter/gather.  Why?? */
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|scatter
operator|==
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|reqlen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|ccb
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataIn
operator|||
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataOut
condition|)
block|{
comment|/* Data I/O is involved in this command.  Alocate buffer */
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|>
name|PAGE_SIZE
condition|)
block|{
name|data
operator|=
name|contigmalloc
argument_list|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|malloc
argument_list|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Cannot allocate %d bytes "
literal|"for EATA command\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
define|#
directive|define
name|usr_cmd_DMA
value|(caddr_t)user_cmd->command_packet.cp_dataDMA
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataIn
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|copyin
argument_list|(
name|usr_cmd_DMA
argument_list|,
name|data
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* No data I/O involved here.  Make sure the DPT knows that */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|FWNEST
operator|==
literal|1
condition|)
name|ccb
operator|->
name|eata_ccb
operator|.
name|FWNEST
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dpt_scatter_gather
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
comment|/** 	 * We are required to quiet a SCSI bus. 	 * since we do not queue comands on a bus basis, 	 * we wait for ALL commands on a controller to complete. 	 * In the mean time, sched_queue() will not schedule new commands. 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_cdb
index|[
literal|0
index|]
operator|==
name|MULTIFUNCTION_CMD
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_cdb
index|[
literal|2
index|]
operator|==
name|BUS_QUIET
operator|)
condition|)
block|{
comment|/* We wait for ALL traffic for this HBa to subside */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_QUIET
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|submitted
operator|=
name|dpt
operator|->
name|submitted_ccbs_count
operator|)
operator|!=
literal|0
condition|)
block|{
name|huh
operator|=
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dpt
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
literal|"dptqt"
argument_list|,
literal|100
operator|*
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|huh
condition|)
block|{
case|case
literal|0
case|:
comment|/* Wakeup call received */
break|break;
case|case
name|EWOULDBLOCK
case|:
comment|/* Timer Expired */
break|break;
default|default:
comment|/* anything else */
break|break;
block|}
block|}
block|}
comment|/* Resume normal operation */
if|if
condition|(
operator|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_cdb
index|[
literal|0
index|]
operator|==
name|MULTIFUNCTION_CMD
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_cdb
index|[
literal|2
index|]
operator|==
name|BUS_UNQUIET
operator|)
condition|)
block|{
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_HA_QUIET
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
comment|/** 	 * Schedule the command and submit it. 	 * We bypass dpt_sched_queue, as it will block on DPT_HA_QUIET 	 */
name|ccb
operator|->
name|xs
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
comment|/* We always want this feature */
name|ccb
operator|->
name|transaction_id
operator|=
operator|++
name|dpt
operator|->
name|commands_processed
expr_stmt|;
name|ccb
operator|->
name|std_callback
operator|=
operator|(
name|ccb_callback
operator|)
name|dpt_user_cmd_done
expr_stmt|;
name|ccb
operator|->
name|result
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|cmdarg
expr_stmt|;
name|ccb
operator|->
name|data
operator|=
name|data
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
index|]
expr_stmt|;
name|ccb
operator|->
name|command_started
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt_Qadd_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
comment|/* Wait for the command to complete */
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ccb
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
literal|"dptucw"
argument_list|,
literal|100
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* Free allocated memory */
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dpt_user_cmd_done
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|bus
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|ospl
init|=
name|splsoftcam
argument_list|()
decl_stmt|;
name|u_int32_t
name|result
decl_stmt|;
name|caddr_t
name|cmd_arg
decl_stmt|;
comment|/** 	 * If Auto Request Sense is on, copyout the sense struct 	 */
define|#
directive|define
name|usr_pckt_DMA
value|(caddr_t)ntohl(ccb->eata_ccb.cp_reqDMA)
define|#
directive|define
name|usr_pckt_len
value|ntohl(ccb->eata_ccb.cp_datalen)
if|if
condition|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|Auto_Req_Sen
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ccb
operator|->
name|sense_data
argument_list|,
name|usr_pckt_DMA
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|result
operator|=
name|EFAULT
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If DataIn is on, copyout the data */
if|if
condition|(
operator|(
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataIn
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|status_packet
operator|.
name|hba_stat
operator|==
name|HA_NO_ERROR
operator|)
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|ccb
operator|->
name|data
argument_list|,
name|usr_pckt_DMA
argument_list|,
name|usr_pckt_len
argument_list|)
condition|)
block|{
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|result
operator|=
name|EFAULT
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Copyout the status */
name|result
operator|=
name|ccb
operator|->
name|status_packet
operator|.
name|hba_stat
expr_stmt|;
name|cmd_arg
operator|=
operator|(
name|caddr_t
operator|)
name|ccb
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|result
argument_list|,
name|cmd_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|result
operator|=
name|EFAULT
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Put the CCB back in the freelist */
name|ccb
operator|->
name|state
operator||=
name|DPT_CCB_STATE_COMPLETED
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* Free allocated memory */
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Detect Cache parameters and size */
end_comment

begin_function
name|void
name|dpt_detect_cache
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|param
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|eata_ccb_t
name|cp
decl_stmt|;
name|dpt_sp_t
name|sp
decl_stmt|;
name|struct
name|scsi_sense_data
name|snp
decl_stmt|;
comment|/** 	 * We lock out the hardware early, so that we can either complete the 	 * operation or bust out right away. 	 */
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"FreeBSD DPT Driver, version %d.%d.%d"
argument_list|,
name|DPT_RELEASE
argument_list|,
name|DPT_VERSION
argument_list|,
name|DPT_PATCH
argument_list|)
expr_stmt|;
comment|/** 	 * Default setting, for best perfromance.. 	 * This is what virtually all cards default to.. 	 */
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_CACHE_WRITEBACK
expr_stmt|;
name|dpt
operator|->
name|cache_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|buff
operator|=
name|malloc
argument_list|(
literal|512
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Failed to allocate %d bytes for a work "
literal|"buffer\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
literal|512
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
operator|&
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|eata_ccb_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|int8_t
operator|*
operator|)
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|int8_t
operator|*
operator|)
operator|&
name|snp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* Setup the command structure */
name|cp
operator|.
name|Interpret
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|DataIn
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|reqlen
operator|=
operator|(
name|u_int8_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_id
operator|=
literal|0
expr_stmt|;
comment|/* who cares?  The HBA will interpret.. */
name|cp
operator|.
name|cp_LUN
operator|=
literal|0
expr_stmt|;
comment|/* In the EATA packet */
name|cp
operator|.
name|cp_lun
operator|=
literal|0
expr_stmt|;
comment|/* In the SCSI command */
name|cp
operator|.
name|cp_channel
operator|=
literal|0
expr_stmt|;
name|cp
operator|.
name|cp_scsi_cmd
operator|=
name|EATA_CMD_DMA_SEND_CP
expr_stmt|;
name|cp
operator|.
name|cp_len
operator|=
literal|56
expr_stmt|;
name|cp
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|snp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_identify
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|cp_dispri
operator|=
literal|1
expr_stmt|;
comment|/** 	 * Build the EATA Command Packet structure 	 * for a Log Sense Command. 	 */
name|cp
operator|.
name|cp_cdb
index|[
literal|0
index|]
operator|=
literal|0x4d
expr_stmt|;
name|cp
operator|.
name|cp_cdb
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|cp
operator|.
name|cp_cdb
index|[
literal|2
index|]
operator|=
literal|0x40
operator||
literal|0x33
expr_stmt|;
name|cp
operator|.
name|cp_cdb
index|[
literal|7
index|]
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|cp_datalen
operator|=
name|htonl
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|cp
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: detect_cache() failed (%d) to send "
literal|"EATA_CMD_DMA_SEND_CP\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait for two seconds for a response.  This can be slow... */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
operator|(
name|ndx
operator|<
literal|20000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|)
operator|&
name|HA_AIRQ
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* Grab the status and clear interrupts */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/** 	 * Sanity check 	 */
if|if
condition|(
name|buff
index|[
literal|0
index|]
operator|!=
literal|0x33
condition|)
block|{
return|return;
block|}
name|bytes
operator|=
name|DPT_HCP_LENGTH
argument_list|(
name|buff
argument_list|)
expr_stmt|;
name|param
operator|=
name|DPT_HCP_FIRST
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|DPT_HCP_CODE
argument_list|(
name|param
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/** 		 * DPT Log Page layout error 		 */
name|printf
argument_list|(
literal|"dpt%d: NOTICE: Log Page (1) layout error\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|param
index|[
literal|4
index|]
operator|&
literal|0x4
operator|)
condition|)
block|{
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_NO_CACHE
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|DPT_HCP_CODE
argument_list|(
name|param
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|param
operator|=
name|DPT_HCP_NEXT
argument_list|(
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|param
operator|<
name|buff
operator|)
operator|||
operator|(
name|param
operator|>=
operator|&
name|buff
index|[
name|bytes
index|]
operator|)
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|param
index|[
literal|4
index|]
operator|&
literal|0x2
condition|)
block|{
comment|/** 		 * Cache disabled 		 */
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_NO_CACHE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param
index|[
literal|4
index|]
operator|&
literal|0x4
condition|)
block|{
name|dpt
operator|->
name|cache_type
operator|=
name|DPT_CACHE_WRITETHROUGH
expr_stmt|;
return|return;
block|}
name|dpt
operator|->
name|cache_size
operator|=
name|param
index|[
literal|5
index|]
operator||
operator|(
name|param
index|[
literal|6
index|]
operator|<
literal|8
operator|)
operator||
operator|(
name|param
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|param
index|[
literal|8
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Initializes the softc structure and allocate all sorts of storage.  * Returns 0 on good luck, 1-n otherwise (error condition sensitive).  */
end_comment

begin_function
name|int
name|dpt_setup
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_conf_t
modifier|*
name|conf
parameter_list|)
block|{
name|dpt_inq_t
modifier|*
name|board_data
decl_stmt|;
name|u_long
name|rev
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|board_data
operator|=
name|dpt_get_board_data
argument_list|(
name|dpt
argument_list|,
name|conf
operator|->
name|scsi_id0
argument_list|)
expr_stmt|;
if|if
condition|(
name|board_data
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Get_board_data() failure. "
literal|"Setup ignored!\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dpt
operator|->
name|total_ccbs_count
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|free_ccbs_count
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|waiting_ccbs_count
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|submitted_ccbs_count
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|completed_ccbs_count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ntohl
argument_list|(
name|conf
operator|->
name|splen
argument_list|)
condition|)
block|{
case|case
name|DPT_EATA_REVA
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|DPT_EATA_REVB
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|DPT_EATA_REVC
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|DPT_EATA_REVZ
case|:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'z'
expr_stmt|;
break|break;
default|default:
name|dpt
operator|->
name|EATA_revision
operator|=
literal|'?'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|dpt
operator|->
name|board_data
argument_list|,
name|board_data
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_inq_t
argument_list|)
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|bustype
operator|=
name|IS_PCI
expr_stmt|;
comment|/* We only support and operate on PCI devices */
name|dpt
operator|->
name|channels
operator|=
name|conf
operator|->
name|MAX_CHAN
operator|+
literal|1
expr_stmt|;
name|dpt
operator|->
name|max_id
operator|=
name|conf
operator|->
name|MAX_ID
expr_stmt|;
name|dpt
operator|->
name|max_lun
operator|=
name|conf
operator|->
name|MAX_LUN
expr_stmt|;
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_OK
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|SECOND
condition|)
name|dpt
operator|->
name|primary
operator|=
name|FALSE
expr_stmt|;
else|else
name|dpt
operator|->
name|primary
operator|=
name|TRUE
expr_stmt|;
name|dpt
operator|->
name|more_support
operator|=
name|conf
operator|->
name|MORE_support
expr_stmt|;
if|if
condition|(
name|board_data
operator|==
name|NULL
condition|)
block|{
name|rev
operator|=
operator|(
literal|'?'
operator|<<
literal|24
operator|)
operator||
operator|(
literal|'-'
operator|<<
literal|16
operator|)
operator||
operator|(
literal|'?'
operator|<<
literal|8
operator|)
operator||
literal|'-'
expr_stmt|;
block|}
else|else
block|{
comment|/* Convert from network byte order to a "string" */
name|rev
operator|=
operator|(
name|dpt
operator|->
name|board_data
operator|.
name|firmware
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|dpt
operator|->
name|board_data
operator|.
name|firmware
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|dpt
operator|->
name|board_data
operator|.
name|firmware
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|dpt
operator|->
name|board_data
operator|.
name|firmware
index|[
literal|3
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rev
operator|>=
operator|(
operator|(
literal|'0'
operator|<<
literal|24
operator|)
operator|+
operator|(
literal|'7'
operator|<<
literal|16
operator|)
operator|+
operator|(
literal|'G'
operator|<<
literal|8
operator|)
operator|+
literal|'0'
operator|)
condition|)
name|dpt
operator|->
name|immediate_support
operator|=
literal|1
expr_stmt|;
else|else
name|dpt
operator|->
name|immediate_support
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|broken_INQUIRY
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|MAX_CHANNELS
condition|;
name|ndx
operator|++
control|)
name|dpt
operator|->
name|resetlevel
index|[
name|ndx
index|]
operator|=
name|DPT_HA_OK
expr_stmt|;
name|dpt
operator|->
name|cplen
operator|=
name|ntohl
argument_list|(
name|conf
operator|->
name|cplen
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|cppadlen
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|cppadlen
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|queuesize
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|queuesiz
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|hostid
index|[
literal|0
index|]
operator|=
name|conf
operator|->
name|scsi_id0
expr_stmt|;
name|dpt
operator|->
name|hostid
index|[
literal|1
index|]
operator|=
name|conf
operator|->
name|scsi_id1
expr_stmt|;
name|dpt
operator|->
name|hostid
index|[
literal|2
index|]
operator|=
name|conf
operator|->
name|scsi_id2
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|SG_64K
condition|)
block|{
name|dpt
operator|->
name|sgsize
operator|=
name|SG_SIZE_BIG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|conf
operator|->
name|SGsiz
argument_list|)
operator|<
literal|1
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|conf
operator|->
name|SGsiz
argument_list|)
operator|>
name|SG_SIZE
operator|)
condition|)
block|{
comment|/* Just a sanity check */
name|dpt
operator|->
name|sgsize
operator|=
name|SG_SIZE
expr_stmt|;
block|}
else|else
block|{
name|dpt
operator|->
name|sgsize
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|SGsiz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dpt
operator|->
name|sgsize
operator|>
name|dpt_max_segs
condition|)
name|dpt
operator|->
name|sgsize
operator|=
name|dpt_max_segs
expr_stmt|;
if|if
condition|(
name|dpt_alloc_freelist
argument_list|(
name|dpt
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|2
operator|)
return|;
block|}
comment|/* Prepare for Target Mode */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|target_mode_enabled
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * The following function returns a pointer to a buffer which MUST be freed by  * The caller, a la free(result, M_DEVBUF)  *  * This function (and its like) assumes it is only running during system  * initialization!  */
end_comment

begin_function
specifier|static
name|dpt_inq_t
modifier|*
name|dpt_get_board_data
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int32_t
name|target_id
parameter_list|)
block|{
comment|/* get_conf returns 512 bytes, most of which are zeros... */
return|return
operator|(
operator|(
name|dpt_inq_t
operator|*
operator|)
name|dpt_get_conf
argument_list|(
name|dpt
argument_list|,
literal|0
argument_list|,
name|target_id
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_inq_t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * The following function returns a pointer to a buffer which MUST be freed by  * the caller, a la ``free(result, M_TEMP);''  */
end_comment

begin_function
name|dpt_conf_t
modifier|*
name|dpt_get_conf
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|u_int8_t
name|page
parameter_list|,
name|u_int8_t
name|target
parameter_list|,
name|u_int8_t
name|size
parameter_list|,
name|int
name|extent
parameter_list|)
block|{
name|dpt_sp_t
name|sp
decl_stmt|;
name|eata_ccb_t
name|cp
decl_stmt|;
comment|/* Get_conf returns 512 bytes, most of which are zeros... */
name|dpt_conf_t
modifier|*
name|config
decl_stmt|;
name|u_short
modifier|*
name|ip
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|sig1
decl_stmt|,
name|sig2
decl_stmt|,
name|sig3
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|scsi_sense_data
name|snp
decl_stmt|;
if|if
condition|(
operator|(
name|config
operator|=
operator|(
name|dpt_conf_t
operator|*
operator|)
name|malloc
argument_list|(
literal|512
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|eata_ccb_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|int8_t
operator|*
operator|)
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sp_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|config
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cp
operator|.
name|Interpret
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|DataIn
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|reqlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_id
operator|=
name|target
expr_stmt|;
name|cp
operator|.
name|cp_LUN
operator|=
literal|0
expr_stmt|;
comment|/* In the EATA packet */
name|cp
operator|.
name|cp_lun
operator|=
literal|0
expr_stmt|;
comment|/* In the SCSI command */
name|cp
operator|.
name|cp_scsi_cmd
operator|=
name|INQUIRY
expr_stmt|;
name|cp
operator|.
name|cp_len
operator|=
name|size
expr_stmt|;
name|cp
operator|.
name|cp_extent
operator|=
name|extent
expr_stmt|;
name|cp
operator|.
name|cp_page
operator|=
name|page
expr_stmt|;
name|cp
operator|.
name|cp_channel
operator|=
literal|0
expr_stmt|;
comment|/* DNC, Interpret mode is set */
name|cp
operator|.
name|cp_identify
operator|=
literal|1
expr_stmt|;
name|cp
operator|.
name|cp_datalen
operator|=
name|htonl
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|snp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|.
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|cp
expr_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_RESET_BOARD
name|printf
argument_list|(
literal|"dpt%d: get_conf() resetting HBA at %x.\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|BaseRegister
argument_list|(
name|dpt
argument_list|)
argument_list|)
expr_stmt|;
name|dpt_outb
argument_list|(
name|dpt
argument_list|,
name|HA_WCOMMAND
argument_list|,
name|EATA_CMD_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|750000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/** 	 * This could be a simple for loop, but we suspected the compiler To 	 * have optimized it a bit too much. Wait for the controller to 	 * become ready 	 */
while|while
condition|(
operator|(
operator|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
operator|)
operator|!=
operator|(
name|HA_SREADY
operator||
name|HA_SSC
operator|)
operator|)
operator|&&
operator|(
name|status
operator|!=
operator|(
name|HA_SREADY
operator||
name|HA_SSC
operator||
name|HA_SERROR
operator|)
operator|)
operator|&&
comment|/* This results from the `wd' probe at our 				 * addresses */
operator|(
name|status
operator|!=
operator|(
name|HA_SDRDY
operator||
name|HA_SERROR
operator||
name|HA_SDRQ
operator|)
operator|)
operator|)
operator|||
operator|(
name|dpt_wait
argument_list|(
name|dpt
argument_list|,
name|HA_SBUSY
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/** 		 * RAID Drives still Spinning up? (This should only occur if 		 * the DPT controller is in a NON PC (PCI?) platform). 		 */
if|if
condition|(
name|dpt_raid_busy
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: Get_conf() RSUS failed for "
literal|"HBA at %x\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|BaseRegister
argument_list|(
name|dpt
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DptStat_Reset_BUSY
argument_list|(
operator|&
name|sp
argument_list|)
expr_stmt|;
comment|/** 	 * XXXX We might want to do something more clever than aborting at 	 * this point, like resetting (rebooting) the controller and trying 	 * again. 	 */
if|if
condition|(
operator|(
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|cp
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: Get_conf() failed (%d) to send "
literal|"EATA_CMD_DMA_READ_CONFIG\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|config
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Wait for two seconds for a response.  This can be slow  */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
operator|(
name|ndx
operator|<
literal|20000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|)
operator|&
name|HA_AIRQ
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/* Grab the status and clear interrupts */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/** 	 * Check the status carefully.  Return only if the 	 * command was successful. 	 */
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|HA_SERROR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|.
name|hba_stat
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|.
name|scsi_stat
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|.
name|residue_len
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|config
operator|)
return|;
block|}
name|free
argument_list|(
name|config
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This gets called once per SCSI bus defined in config! */
end_comment

begin_function
name|int
name|dpt_attach
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|dpt
operator|->
name|channels
condition|;
name|ndx
operator|++
control|)
block|{
comment|/** 		 * We do not setup target nor lun on the assumption that 		 * these are being set for individual devices that will be 		 * attached to the bus later. 		 */
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|adapter_unit
operator|=
name|dpt
operator|->
name|unit
expr_stmt|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|adapter_targ
operator|=
name|dpt
operator|->
name|hostid
index|[
name|ndx
index|]
expr_stmt|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|adapter_softc
operator|=
name|dpt
expr_stmt|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|adapter
operator|=
operator|&
name|dpt_switch
expr_stmt|;
comment|/* 		 * These appear to be the # of openings per that  DEVICE, not 		 * the DPT! 		 */
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|opennings
operator|=
name|dpt
operator|->
name|queuesize
expr_stmt|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|device
operator|=
operator|&
name|dpt_dev
expr_stmt|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|adapter_bus
operator|=
name|ndx
expr_stmt|;
comment|/** 		 * Prepare the scsibus_data area for the upperlevel scsi 		 * code. 		 */
if|if
condition|(
operator|(
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
operator|.
name|scsibus
operator|=
name|ndx
expr_stmt|;
name|scbus
operator|->
name|maxtarg
operator|=
name|dpt
operator|->
name|max_id
expr_stmt|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|dpt
operator|->
name|sc_scsi_link
index|[
name|ndx
index|]
expr_stmt|;
comment|/* 		 * Invite the SCSI control layer to probe the busses. 		 */
name|dpt
operator|->
name|handle_interrupts
operator|=
literal|1
expr_stmt|;
comment|/* Now we are ready to work */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
operator|(
expr|struct
name|scsibus_data
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Allocate another chunk of CCB's. Return 0 on success, 1 otherwise.  * If the free list is empty, we allocate a block of entries and add them  * to the list.	We obtain, at most, DPT_FREE_LIST_INCREMENT CCB's at a time.  * If we cannot, we will try fewer entries until we succeed.  * For every CCB, we allocate a maximal Scatter/Gather list.  * This routine also initializes all the static data that pertains to this CCB.  */
end_comment

begin_comment
comment|/**  * XXX JGibbs - How big are your SG lists?  Remeber that the kernel malloc  *		uses buckets and mallocs in powers of two.  So, if your  *		SG list is not a power of two (up to PAGESIZE), you might  *		waste a lot of memory.  This was the reason the ahc driver  *		allocats multiple SG lists at a time up to a PAGESIZE.  *		Just something to keep in mind.  * YYY Simon -  Up to 8192 entries, each entry is two ulongs, comes to 64K.  *              In reality they are much smaller, so you are right.  */
end_comment

begin_function
specifier|static
name|int
name|dpt_alloc_freelist
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|dpt_ccb_t
modifier|*
name|nccbp
decl_stmt|;
name|dpt_sg_t
modifier|*
name|sg
decl_stmt|;
name|u_int8_t
modifier|*
name|buff
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|incr
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|ccb_count
decl_stmt|;
name|ccb_count
operator|=
name|DPT_FREE_LIST_INCREMENT
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_RESTRICTED_FREELIST
if|if
condition|(
name|dpt
operator|->
name|total_ccbs_count
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Restricted FreeList, No more than %d entries "
literal|"allowed\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|total_ccbs_count
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/** 	 * Allocate a group of dpt_ccb's. Work on the CCB's, one at a time 	 */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|ccb_count
condition|;
name|ndx
operator|++
control|)
block|{
name|size_t
name|alloc_size
decl_stmt|;
name|dpt_sg_t
modifier|*
name|sgbuff
decl_stmt|;
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
name|dpt_ccb_t
argument_list|)
expr_stmt|;
comment|/* About 200 bytes */
if|if
condition|(
name|alloc_size
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* 			 * Does not fit in a page. we try to fit in a 			 * contigious block of memory. If not, we will, later 			 * try to allocate smaller, and smaller chunks. There 			 * is a tradeof between memory and performance here. 			 * We know.this (crude) algorithm works well on 			 * machines with plenty of memory. We have seen it 			 * allocate in excess of 8MB. 			 */
name|nccbp
operator|=
operator|(
name|dpt_ccb_t
operator|*
operator|)
name|contigmalloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fits all in one page */
name|nccbp
operator|=
operator|(
name|dpt_ccb_t
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nccbp
operator|==
operator|(
name|dpt_ccb_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Alloc_free_list() failed to "
literal|"allocate %d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
name|dpt_sg_t
argument_list|)
operator|*
name|dpt
operator|->
name|sgsize
expr_stmt|;
if|if
condition|(
name|alloc_size
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* Does not fit in a page */
name|sgbuff
operator|=
operator|(
name|dpt_sg_t
operator|*
operator|)
name|contigmalloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fits all in one page */
name|sgbuff
operator|=
operator|(
name|dpt_sg_t
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * If we cannot allocate sg lists, we do not want the entire 		 * list 		 */
if|if
condition|(
name|sgbuff
operator|==
operator|(
name|dpt_sg_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nccbp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
operator|--
name|ndx
expr_stmt|;
break|break;
block|}
comment|/* Clean up the mailboxes */
name|bzero
argument_list|(
name|sgbuff
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nccbp
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_ccb_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * this line is nullified by the one below. 		 * nccbp->eata_ccb.cp_dataDMA = (u_int32_t) sgbuff; Thanx, 		 * Mike! 		 */
name|nccbp
operator|->
name|sg_list
operator|=
name|sgbuff
expr_stmt|;
comment|/** 		 * Now that we have a new block of free CCB's, put them into 		 * the free list. We always add to the head of the list and 		 * always take form the head of the list (LIFO). Each ccb 		 * has its own Scatter/Gather list. They are all of the same 		 * size, Regardless of how much is used. 		 * 		 * While looping through all the new CCB's, we initialize them 		 * properly. These items NEVER change; They are mostly 		 * self-pointers, relative to the CCB itself. 		 */
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|nccbp
argument_list|)
expr_stmt|;
operator|++
name|dpt
operator|->
name|total_ccbs_count
expr_stmt|;
name|nccbp
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
name|nccbp
operator|->
name|sg_list
argument_list|)
argument_list|)
expr_stmt|;
name|nccbp
operator|->
name|eata_ccb
operator|.
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
name|nccbp
expr_stmt|;
comment|/* Unique */
name|nccbp
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|dpt
operator|->
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/** 		 * See dpt_intr for why we make ALL CCB's ``have the same'' 		 * Status Packet 		 */
name|nccbp
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|nccbp
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Prepare the data area for DMA.  */
end_comment

begin_function
specifier|static
name|int
name|dpt_scatter_gather
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|,
name|u_int32_t
name|data_length
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|seg
decl_stmt|;
name|int
name|thiskv
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|;
name|int
name|bytes_this_page
decl_stmt|;
name|u_int32_t
name|datalen
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|u_int32_t
name|paddr
decl_stmt|;
name|u_int32_t
name|nextpaddr
decl_stmt|;
name|dpt_sg_t
modifier|*
name|sg
decl_stmt|;
comment|/* we start with Scatter/Gather OFF */
name|ccb
operator|->
name|eata_ccb
operator|.
name|scatter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|data_length
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
condition|)
block|{
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataIn
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|flags
operator|&
name|SCSI_DATA_OUT
condition|)
block|{
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataOut
operator|=
literal|1
expr_stmt|;
block|}
name|seg
operator|=
literal|0
expr_stmt|;
name|datalen
operator|=
name|data_length
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|data
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
name|ccb
operator|->
name|sg_list
argument_list|)
argument_list|)
expr_stmt|;
name|sg
operator|=
name|ccb
operator|->
name|sg_list
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|seg
operator|<
name|dpt
operator|->
name|sgsize
operator|)
condition|)
block|{
comment|/* put in the base address and length */
name|sg
operator|->
name|seg_addr
operator|=
name|paddr
expr_stmt|;
name|sg
operator|->
name|seg_len
operator|=
literal|0
expr_stmt|;
comment|/* do it at least once */
name|nextpaddr
operator|=
name|paddr
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|paddr
operator|==
name|nextpaddr
operator|)
condition|)
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/** 				 * This page is contiguous (physically) with 				 * the the last, just extend the length 				 */
comment|/* how far to the end of the page */
name|nextpaddr
operator|=
name|trunc_page
argument_list|(
name|paddr
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* Compute the maximum size */
name|size
operator|=
name|nextpaddr
operator|-
name|paddr
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
name|sg
operator|->
name|seg_len
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
comment|/* Next page isn't contiguous, finish the seg */
name|sg
operator|->
name|seg_addr
operator|=
name|htonl
argument_list|(
name|sg
operator|->
name|seg_addr
argument_list|)
expr_stmt|;
name|sg
operator|->
name|seg_len
operator|=
name|htonl
argument_list|(
name|sg
operator|->
name|seg_len
argument_list|)
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|sg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* There's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"dpt%d: scsi_cmd() Too Many (%d) DMA segs "
literal|"(%d bytes left)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|sgsize
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|seg
operator|==
literal|1
condition|)
block|{
comment|/** 			 * After going through all this trouble, we 			 * still have only one segment. As an 			 * optimization measure, we will do the 			 * I/O as a single, non-S/G operation. 			 */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
name|ccb
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|seg_addr
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
name|ccb
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|seg_len
expr_stmt|;
block|}
else|else
block|{
comment|/** 			 * There is more than one segment. Use S/G. 			 */
name|ccb
operator|->
name|eata_ccb
operator|.
name|scatter
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
name|htonl
argument_list|(
name|seg
operator|*
sizeof|sizeof
argument_list|(
name|dpt_sg_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* datalen == 0 */
comment|/* No data xfer */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_datalen
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dataDMA
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This function obtains a CCB for a command and attempts to queue it to the  * Controller.  *  * CCB Obtaining: Is done by getting the first entry in the free list for the  * HBA. If we fail to get an scb, we send a TRY_LATER to the caller.  *  * XXX - JGibbs: XS_DRIVER_STUFFUP is equivalent to failing the I/O in the  *               current SCSI layer.  *  * Command Queuing: Is done by putting the command at the end of the waiting  * queue. This assures fair chance for all commands to be processed.  * If the queue was empty (has only this, current command in it, we try to  * submit it to the HBA. Otherwise we return SUCCESSFULLY_QUEUED.  */
end_comment

begin_function
specifier|static
name|int32_t
name|dpt_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|int
name|incr
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|huh
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|u_int32_t
name|aux_status
init|=
literal|0
decl_stmt|;
comment|/* Initialized to shut GCC up */
name|int
name|result
decl_stmt|;
name|int
name|channel
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inq
decl_stmt|;
name|dpt
operator|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
name|channel
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_bus
expr_stmt|;
name|target
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|lun
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_TIMEOUTS_SET
operator|)
operator|==
literal|0
condition|)
block|{
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_TIMEOUTS_SET
expr_stmt|;
name|timeout
argument_list|(
name|dpt_timeout
argument_list|,
name|dpt
argument_list|,
name|hz
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DPT_LOST_IRQ
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_LOST_IRQ_SET
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Initializing Lost IRQ Timer\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
name|printf
argument_list|(
literal|"dpt%d: HBA will reset if irresponsive for %d seconds\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|DPT_RESET_HBA
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|last_contact
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
name|dpt
operator|->
name|state
operator||=
name|DPT_LOST_IRQ_SET
expr_stmt|;
name|timeout
argument_list|(
name|dpt_irq_timeout
argument_list|,
name|dpt
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/** 	 * Examine the command flags and handle properly. XXXX We are not 	 * handling external resets right now.	Needs to be added. We do not 	 * care about the SCSI_NOSLEEP flag as we do not sleep here. We have 	 * to observe the SCSI_NOMASK flag, though. 	 */
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Unsupported option...\n"
literal|"      I refuse to Reset b%dt%du%d...!\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Command \"%s\" recieved for b%dt%du%d\n"
literal|"	    but controller is shutdown; Aborting...\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|scsi_cmd_name
argument_list|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: scsi_cmd(%s) already done on "
literal|"b%dt%du%d?!\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|scsi_cmd_name
argument_list|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: Unit not in use in scsi_cmd(%s) "
literal|"on b%dt%du%d?!\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|scsi_cmd_name
argument_list|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
comment|/** 	 * We do not want to be disrupted when doing this, or another caller 	 * may do the same thing. 	 */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
comment|/* Process the free list */
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|)
operator|)
operator|&&
name|dpt_alloc_freelist
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Cannot allocate any more free CCB's.\n"
literal|"            Will try later\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
comment|/* Now grab the newest CCB */
if|if
condition|(
operator|(
name|ccb
operator|=
name|dpt_Qpop_free
argument_list|(
name|dpt
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No need to panic here.  We can continue with only as many 		 * CCBs as we have. 		 */
name|printf
argument_list|(
literal|"dpt%d ERROR: Got a NULL CCB from pop_free()\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
name|ccb
operator|->
name|status
operator|&=
operator|~
operator|(
name|DPT_CCB_STATE_ABORTED
operator||
name|DPT_CCB_STATE_MARKED_LOST
operator|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_cdb
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
comment|/* Put all the CCB population stuff below */
name|ccb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* We NEVER reset the bus from a command   */
name|ccb
operator|->
name|eata_ccb
operator|.
name|SCSI_Reset
operator|=
literal|0
expr_stmt|;
comment|/* We NEVER re-boot the HBA from a * command */
name|ccb
operator|->
name|eata_ccb
operator|.
name|HBA_Init
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|Auto_Req_Sen
operator|=
literal|1
expr_stmt|;
comment|/* We always want this feature */
name|ccb
operator|->
name|eata_ccb
operator|.
name|reqlen
operator|=
name|htonl
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|std_callback
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|wrbuff_callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|xs
operator|->
name|sc_link
operator|->
name|adapter_targ
condition|)
block|{
name|ccb
operator|->
name|eata_ccb
operator|.
name|Interpret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|eata_ccb
operator|.
name|Interpret
operator|=
literal|0
expr_stmt|;
block|}
name|ccb
operator|->
name|eata_ccb
operator|.
name|scatter
operator|=
literal|0
expr_stmt|;
comment|/* S/G is OFF now */
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataIn
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|DataOut
operator|=
literal|0
expr_stmt|;
comment|/* At this time we do not deal with the RAID internals */
name|ccb
operator|->
name|eata_ccb
operator|.
name|FWNEST
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|Phsunit
operator|=
literal|0
expr_stmt|;
comment|/* We do not do SMARTROM kind of things */
name|ccb
operator|->
name|eata_ccb
operator|.
name|I_AT
operator|=
literal|0
expr_stmt|;
comment|/* We do not inhibit the cache at this time */
name|ccb
operator|->
name|eata_ccb
operator|.
name|Disable_Cache
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_channel
operator|=
name|channel
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_id
operator|=
name|target
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_LUN
operator|=
name|lun
expr_stmt|;
comment|/** 					 * In the EATA packet. We do not 					 * change the SCSI command yet 					 */
comment|/* We are currently dealing with target LUN's, not ROUTINEs */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_luntar
operator|=
literal|0
expr_stmt|;
comment|/** 	 * XXXX - We grant the target disconnect prvileges, except in polled 	 * mode (????). 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|||
operator|!
name|dpt
operator|->
name|handle_interrupts
condition|)
block|{
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dispri
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_dispri
operator|=
literal|1
expr_stmt|;
block|}
comment|/* we always ask for Identify */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_identify
operator|=
literal|1
expr_stmt|;
comment|/** 	 * These three are used for command queues and tags. How do we use 	 * them? 	 * 	 * XXX - JGibbs: Most likely like so: ccb->eata_ccb.cp_msg[0] = 	 * MSG_SIMPLEQ_TAG; ccb->eata_ccb.cp_msg[1] = tagid; 	 * ccb->eata_ccb.cp_msg[2] = 0; 	 * 	 * YYY - Shimon: Thanx!	We still do not do that as the current 	 * firmware does it automatically, including on RAID arrays. 	 */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_msg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_msg
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_msg
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* End of CCB population */
if|if
condition|(
name|dpt_scatter_gather
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
name|xs
operator|->
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/** 	 * This is the polled mode section. If we are here to honor 	 * SCSI_NOMASK, during scsi_attachdevs(), please notice that 	 * interrupts are ENABLED in the system (2.2.1) and that the DPT 	 * WILL generate them, unless we turn them off! 	 */
comment|/** 	 * XXX - JGibbs: Polled mode was a botch at best. It's nice to 	 *               know that it goes completely away with the CAM code. 	 * YYY - Simon:  Take it out once the rest is stable. Be careful about 	 *               how you wait for commands to complete when you switch 	 *               to interrupt mode in the scanning code (initiated by 	 *               scsi_attachdevs). 	 *               Disabling it in 2.2 causes a hung system. 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|||
operator|!
name|dpt
operator|->
name|handle_interrupts
condition|)
block|{
comment|/** 		 * This is an ``immediate'' command.	Poll it! We poll by 		 * partially bypassing the queues. We first submit the 		 * command by asking dpt_run_queue() to queue it. Then we 		 * poll its status packet, until it completes. Then we give 		 * it to dpt_process_completion() to analyze and then we 		 * return. 		 */
comment|/* 		 * Increase the number of commands queueable for a device. We 		 * force each device to the maximum allowed for its HBA. This 		 * appears wrong but all it will do is cause excessive 		 * commands to sit in our queue. On the other hand, we can 		 * burst as many commands as the DPT can take for a single 		 * device. We do it here, so only while in polled mode (early 		 * boot) do we waste time on it.	We have no clean way 		 * to overrule sdattach() zeal in depressing the opennings 		 * back to one if it is more than 1. 		 */
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|<
name|dpt
operator|->
name|queuesize
condition|)
block|{
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|=
name|dpt
operator|->
name|queuesize
expr_stmt|;
block|}
comment|/** 		 * This test only protects us from submitting polled 		 * commands during Non-polled times.  We assumed polled 		 * commands go in serially, one at a time. BTW, we have NOT 		 * checked, nor verified the scope of the disaster that WILL 		 * follow going into polled mode after being in interrupt 		 * mode for any length of time. 		 */
if|if
condition|(
name|dpt
operator|->
name|submitted_ccbs_count
operator|<
name|dpt
operator|->
name|queuesize
condition|)
block|{
comment|/** 			 * Submit the request to the DPT. Unfortunately, ALL 			 * this must be done as an atomic operation :-( 			 */
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
operator|&
name|ccb
expr_stmt|;
define|#
directive|define
name|dpt_SP
value|htonl(vtophys(&ccb->status_packet))
define|#
directive|define
name|dpt_sense
value|htonl(vtophys(&ccb->sense_data))
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
operator|=
name|dpt_SP
expr_stmt|;
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
operator|=
name|dpt_sense
expr_stmt|;
comment|/* Try to queue a command */
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|ccb
operator|->
name|eata_ccb
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
block|}
else|else
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
for|for
control|(
name|ndx
operator|=
literal|0
init|;
operator|(
name|ndx
operator|<
name|xs
operator|->
name|timeout
operator|)
operator|&&
operator|!
operator|(
operator|(
name|aux_status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
operator|)
operator|&
name|HA_AIRQ
operator|)
condition|;
name|ndx
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
comment|/** 		 * Get the status and clear the interrupt flag on the 		 * controller 		 */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|status_reg
operator|=
name|status
expr_stmt|;
name|ccb
operator|->
name|aux_status_reg
operator|=
name|aux_status
expr_stmt|;
comment|/* This will setup the xs flags */
name|dpt_process_completion
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|HA_SERROR
operator|)
operator|||
operator|(
name|ndx
operator|==
name|xs
operator|->
name|timeout
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
else|else
block|{
comment|/* 			 * We received a reply and did not time out. 			 * Advance the wedge counter. 			 */
name|dpt
operator|->
name|last_contact
operator|=
name|microtime_now
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DPT_RESET_HBA */
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
else|else
block|{
comment|/** 		 * Not a polled command. 		 * The command can be queued normally. 		 * We start a critical section PRIOR to submitting to the DPT, 		 * and end it AFTER it moves to the submitted queue. 		 * If not, we cal (and will!) be hit with a completion 		 * interrupt while the command is in suspense between states. 		 */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|transaction_id
operator|=
operator|++
name|dpt
operator|->
name|commands_processed
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
index|]
expr_stmt|;
name|ccb
operator|->
name|command_started
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
name|dpt_Qadd_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This function returns the transfer size in bytes,  * as a function of the maximum number of Scatter/Gather  * segments.  It should do so for a given HBA, but right now it returns  * dpt_min_segs, which is the SMALLEST number, from the ``weakest'' HBA found.  */
end_comment

begin_function
specifier|static
name|void
name|dptminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/** 	 * This IS a performance sensitive routine. 	 * It gets called at least once per I/O. Sometimes more 	 */
if|if
condition|(
name|dpt_min_segs
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"DPT:  Minphys without attach!\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|dpt_min_segs
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_MINPHYS
name|printf
argument_list|(
literal|"DPT: Block size of %lx is larger than %x. Truncating\n"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
operator|(
operator|(
name|dpt_min_segs
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|dpt_min_segs
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function goes to the waiting queue, peels off a request, gives it to  * the DPT HBA and returns. It takes care of some housekeeping details first.  * The requests argument tells us how many requests to try and send to the  * DPT. A requests = 0 will attempt to send as many as the controller can  * take.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_run_queue
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|int
name|requests
parameter_list|)
block|{
name|int
name|req
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|result
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|aux_status
decl_stmt|;
name|eata_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|dccb
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|)
condition|)
block|{
return|return;
comment|/* Nothing to do if the list is empty */
block|}
if|if
condition|(
operator|!
name|requests
condition|)
name|requests
operator|=
name|dpt
operator|->
name|queuesize
expr_stmt|;
comment|/* Main work loop */
for|for
control|(
name|req
operator|=
literal|0
init|;
operator|(
name|req
operator|<
name|requests
operator|)
operator|&&
name|dpt
operator|->
name|waiting_ccbs_count
operator|&&
operator|(
name|dpt
operator|->
name|submitted_ccbs_count
operator|<
name|dpt
operator|->
name|queuesize
operator|)
condition|;
name|req
operator|++
control|)
block|{
comment|/** 		 * Move the request from the waiting list to the submitted 		 * list, and submit to the DPT. 		 * We enter a critical section BEFORE even looking at the 		 * queue, and exit it AFTER the ccb has moved to a 		 * destination queue. 		 * This is normally the submitted queue but can be the waiting 		 * queue again, if pushing the command into the DPT failed. 		 */
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dccb
operator|==
name|NULL
condition|)
block|{
comment|/* We have yet to see one report of this condition */
name|panic
argument_list|(
literal|"dpt%d ERROR: Race condition in run_queue "
literal|"(w%ds%d)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|waiting_ccbs_count
argument_list|,
name|dpt
operator|->
name|submitted_ccbs_count
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt_Qremove_waiting
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/** 		 * Assign exact values here. We manipulate these values 		 * indirectly elsewhere, so BE CAREFUL! 		 */
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_viraddr
operator|=
operator|(
name|u_int32_t
operator|)
name|dccb
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_statDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|dpt
operator|->
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|dccb
operator|->
name|eata_ccb
operator|.
name|cp_reqDMA
operator|=
name|htonl
argument_list|(
name|vtophys
argument_list|(
operator|&
name|dccb
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dccb
operator|->
name|xs
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
operator|&
name|dccb
operator|->
name|xs
operator|->
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to queue a command */
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|dpt_send_eata_command
argument_list|(
name|dpt
argument_list|,
operator|&
name|dccb
operator|->
name|eata_ccb
argument_list|,
name|EATA_CMD_DMA_SEND_CP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dpt_Qpush_waiting
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt_Qadd_submitted
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * This is the interrupt handler for the DPT driver.  * This routine runs at splcam (or whatever was configured for this device).  */
end_comment

begin_function
name|void
name|dpt_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt_softc_t
modifier|*
name|ldpt
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|,
name|aux_status
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|dccb
decl_stmt|;
name|dpt_ccb_t
modifier|*
name|tccb
decl_stmt|;
name|eata_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|dpt
operator|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_INTR_DELAY
name|DELAY
argument_list|(
name|DPT_INTR_DELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt
operator|->
name|performance
operator|.
name|intr_started
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
comment|/* First order of business is to check if this interrupt is for us */
name|aux_status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RAUXSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aux_status
operator|&
name|HA_AIRQ
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_LOST_IRQ
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_LOST_IRQ_ACTIVE
condition|)
block|{
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_LOST_IRQ_ACTIVE
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|spurious_interrupts
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* The controller is alive, advance the wedge timer */
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
name|dpt
operator|->
name|last_contact
operator|=
name|microtime_now
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dpt
operator|->
name|handle_interrupts
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
comment|/* This CLEARS interrupts! */
return|return;
block|}
comment|/** 	 * What we want to do now, is to capture the status, all of it, move 	 * it where it belongs, wake up whoever sleeps waiting to process 	 * this result, and get out of here. 	 */
name|dccb
operator|=
name|dpt
operator|->
name|sp
operator|.
name|ccb
expr_stmt|;
comment|/** 				 * There is a very SERIOUS and dangerous 				 * assumption here. We assume that EVERY 				 * interrupt is in response to some request we 				 * put to the DPT. IOW, we assume that the 				 * Virtual Address of CP always has a valid 				 * pointer that we put in! How will the DPT 				 * behave if it is in Target mode? How does it 				 * (and our driver) know it switches from 				 * Initiator to target? What will the SP be 				 * when a target mode interrupt is received? 				 */
ifdef|#
directive|ifdef
name|DPT_VERIFY_HINTR
name|dpt
operator|->
name|sp
operator|.
name|ccb
operator|=
operator|(
name|dpt_ccb_t
operator|*
operator|)
literal|0x55555555
expr_stmt|;
else|#
directive|else
name|dpt
operator|->
name|sp
operator|.
name|ccb
operator|=
operator|(
name|dpt_ccb_t
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
if|if
condition|(
name|dccb
operator|->
name|state
operator|&
name|DPT_CCB_STATE_MARKED_LOST
condition|)
block|{
name|u_int32_t
name|age
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|dccb
operator|->
name|xs
decl_stmt|;
name|age
operator|=
name|dpt_time_delta
argument_list|(
name|dccb
operator|->
name|command_started
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d: Salvaging Tx %d from the jaws of destruction "
literal|"(%d/%d)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dccb
operator|->
name|transaction_id
argument_list|,
name|xs
operator|->
name|timeout
argument_list|,
name|age
argument_list|)
expr_stmt|;
name|dccb
operator|->
name|state
operator||=
name|DPT_CCB_STATE_MARKED_SALVAGED
expr_stmt|;
name|dccb
operator|->
name|state
operator|&=
operator|~
name|DPT_CCB_STATE_MARKED_LOST
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Ignore status packets with EOC not set */
if|if
condition|(
name|dpt
operator|->
name|sp
operator|.
name|EOC
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Request %d recieved with clear EOC.\n"
literal|"     Marking as LOST.\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dccb
operator|->
name|transaction_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_VERIFY_HINTR
name|dpt
operator|->
name|sp
operator|.
name|ccb
operator|=
operator|(
name|dpt_sp_t
operator|*
operator|)
literal|0x55555555
expr_stmt|;
else|#
directive|else
name|dpt
operator|->
name|sp
operator|.
name|ccb
operator|=
operator|(
name|dpt_sp_t
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
name|dccb
operator|->
name|state
operator||=
name|DPT_CCB_STATE_MARKED_LOST
expr_stmt|;
endif|#
directive|endif
comment|/* This CLEARS the interrupt! */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt
operator|->
name|sp
operator|.
name|EOC
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_VERIFY_HINTR
comment|/* 	 * Make SURE the next caller is legitimate. If they are not, we will 	 * find 0x55555555 here. We see 0x000000 or 0xffffffff when the PCi 	 * bus has DMA troubles (as when behing a PCI-PCI * bridge . 	 */
if|if
condition|(
operator|(
name|dccb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dccb
operator|==
operator|(
name|dpt_ccb_t
operator|*
operator|)
operator|~
literal|0
operator|)
operator|||
operator|(
name|dccb
operator|==
operator|(
name|dpt_ccb_t
operator|*
operator|)
literal|0x55555555
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: BAD (%p) CCB in SP (AUX status = %s).\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|,
name|i2bin
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|aux_status
argument_list|,
sizeof|sizeof
argument_list|(
name|aux_status
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
expr_stmt|;
endif|#
directive|endif
comment|/* This CLEARS the interrupt! */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|submitted_ccbs
argument_list|)
init|;
operator|(
name|tccb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tccb
operator|!=
name|dccb
operator|)
condition|;
name|tccb
operator|=
name|TAILQ_NEXT
argument_list|(
name|tccb
argument_list|,
name|links
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tccb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: %p is not in the SUBMITTED queue\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|)
expr_stmt|;
for|for
control|(
name|tccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|completed_ccbs
argument_list|)
init|;
operator|(
name|tccb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tccb
operator|!=
name|dccb
operator|)
condition|;
name|tccb
operator|=
name|TAILQ_NEXT
argument_list|(
name|tccb
argument_list|,
name|links
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tccb
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"dpt%d: %p is in the COMPLETED queue\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|)
expr_stmt|;
for|for
control|(
name|tccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|)
init|;
operator|(
name|tccb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tccb
operator|!=
name|dccb
operator|)
condition|;
name|tccb
operator|=
name|TAILQ_NEXT
argument_list|(
name|tccb
argument_list|,
name|links
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tccb
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"dpt%d: %p is in the WAITING queue\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|)
expr_stmt|;
for|for
control|(
name|tccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|)
init|;
operator|(
name|tccb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tccb
operator|!=
name|dccb
operator|)
condition|;
name|tccb
operator|=
name|TAILQ_NEXT
argument_list|(
name|tccb
argument_list|,
name|links
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|tccb
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"dpt%d: %p is in the FREE queue\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dccb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
expr_stmt|;
endif|#
directive|endif
comment|/* This CLEARS the interrupt! */
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* DPT_VERIFY_HINTR */
comment|/** 	 * Copy the status packet from the general area to the dpt_ccb. 	 * According to Mark Salyzyn, we only need few pieces of it. 	 * Originally we had: 	 * bcopy((void *)&dpt->sp, (void *)&dccb->status_packet, 	 *        sizeof(dpt_sp_t)); 	 */
name|dccb
operator|->
name|status_packet
operator|.
name|hba_stat
operator|=
name|dpt
operator|->
name|sp
operator|.
name|hba_stat
expr_stmt|;
name|dccb
operator|->
name|status_packet
operator|.
name|scsi_stat
operator|=
name|dpt
operator|->
name|sp
operator|.
name|scsi_stat
expr_stmt|;
name|dccb
operator|->
name|status_packet
operator|.
name|residue_len
operator|=
name|dpt
operator|->
name|sp
operator|.
name|residue_len
expr_stmt|;
comment|/* Make sure the EOC bit is OFF! */
name|dpt
operator|->
name|sp
operator|.
name|EOC
operator|=
literal|0
expr_stmt|;
comment|/* Clear interrupts, check for error */
if|if
condition|(
operator|(
name|status
operator|=
name|dpt_inb
argument_list|(
name|dpt
argument_list|,
name|HA_RSTATUS
argument_list|)
operator|)
operator|&
name|HA_SERROR
condition|)
block|{
comment|/** 		 * Error Condition. Check for magic cookie. Exit this test 		 * on earliest sign of non-reset condition 		 */
comment|/* Check that this is not a board reset interrupt */
if|if
condition|(
name|dpt_just_reset
argument_list|(
name|dpt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: HBA rebooted.\n"
literal|"      All transactions should be "
literal|"resubmitted\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d:>>---->>  This is incomplete, fix me"
literal|"....<<----<<"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Incomplete Code; Re-queue the lost "
literal|"commands\n"
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"DPT Rebooted"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
operator|++
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
name|dccb
operator|->
name|status_reg
operator|=
name|status
expr_stmt|;
name|dccb
operator|->
name|aux_status_reg
operator|=
name|aux_status
expr_stmt|;
comment|/* Mark BOTH queues as busy */
name|dpt
operator|->
name|queue_status
operator||=
operator|(
name|DPT_SUBMITTED_QUEUE_ACTIVE
operator||
name|DPT_COMPLETED_QUEUE_ACTIVE
operator|)
expr_stmt|;
name|dpt_Qremove_submitted
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|dpt_Qadd_completed
argument_list|(
name|dpt
argument_list|,
name|dccb
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|queue_status
operator|&=
operator|~
operator|(
name|DPT_SUBMITTED_QUEUE_ACTIVE
operator||
name|DPT_COMPLETED_QUEUE_ACTIVE
operator|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
block|{
name|u_int32_t
name|result
decl_stmt|;
name|result
operator|=
name|dpt_time_delta
argument_list|(
name|dpt
operator|->
name|performance
operator|.
name|intr_started
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_intr_time
operator|<
name|result
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_intr_time
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|result
operator|<
name|dpt
operator|->
name|performance
operator|.
name|min_intr_time
condition|)
block|{
name|dpt
operator|->
name|performance
operator|.
name|min_intr_time
operator|=
name|result
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This function is the DPT_ISR Software Interrupt Service Routine. When the  * DPT completes a SCSI command, it puts the results in a Status Packet, sets  * up two 1-byte registers and generates an interrupt.  We catch this  * interrupt in dpt_intr and copy the whole status to the proper CCB. Once  * this is done, we generate a software interrupt that calls this routine.  * The routine then scans ALL the complete queues of all the DPT HBA's and  * processes ALL the commands that are in the queue.  *   * XXXX REMEMBER:	We always scan ALL the queues of all the HBA's. Always  * starting with the first controller registered (dpt0).	This creates  * an ``unfair'' opportunity for the first controllers in being served.  * Careful instrumentation may prove a need to change this policy.  *   * This command rns at splSOFTcam.  Remember that.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_sintr
parameter_list|(
name|void
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|int
name|ospl
decl_stmt|;
comment|/* Find which DPT needs help */
for|for
control|(
name|dpt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt_softc_list
argument_list|)
init|;
name|dpt
operator|!=
name|NULL
condition|;
name|dpt
operator|=
name|TAILQ_NEXT
argument_list|(
name|dpt
argument_list|,
name|links
argument_list|)
control|)
block|{
comment|/* 		 * Drain the completed queue, to make room for new, " waiting 		 * requests. We change to splcam to block interrupts from 		 * mucking with " the completed queue 		 */
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|queue_status
operator|&
name|DPT_SINTR_ACTIVE
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dpt
operator|->
name|queue_status
operator||=
name|DPT_SINTR_ACTIVE
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|completed_ccbs
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_complete
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
block|}
comment|/* Submit as many waiting requests as the DPT can take */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|)
condition|)
block|{
name|dpt_run_queue
argument_list|(
name|dpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dpt
operator|->
name|queue_status
operator|&=
operator|~
name|DPT_SINTR_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Scan the complete queue for a given controller and process ALL the completed  * commands in the queue.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_complete
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|dpt_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|queue_status
operator|&
name|DPT_COMPLETED_QUEUE_ACTIVE
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt
operator|->
name|queue_status
operator||=
name|DPT_COMPLETED_QUEUE_ACTIVE
expr_stmt|;
while|while
condition|(
operator|(
name|ccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|completed_ccbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|dpt_Qremove_completed
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* Process this completed request */
if|if
condition|(
name|dpt_process_completion
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|xs
operator|=
name|ccb
operator|->
name|xs
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|std_callback
operator|!=
name|NULL
condition|)
block|{
call|(
name|ccb
operator|->
name|std_callback
call|)
argument_list|(
name|dpt
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_channel
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
block|{
name|u_int32_t
name|result
decl_stmt|;
define|#
directive|define
name|time_delta
value|dpt_time_delta(ccb->command_started,	ccb->command_ended)
define|#
directive|define
name|maxctime
value|dpt->performance.max_command_time[ccb->eata_ccb.cp_scsi_cmd]
define|#
directive|define
name|minctime
value|dpt->performance.min_command_time[ccb->eata_ccb.cp_scsi_cmd]
name|ccb
operator|->
name|command_ended
operator|=
name|microtime_now
expr_stmt|;
name|result
operator|=
name|time_delta
expr_stmt|;
if|if
condition|(
name|result
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|maxctime
operator|<
name|result
condition|)
block|{
name|maxctime
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minctime
operator|==
literal|0
operator|)
operator|||
operator|(
name|minctime
operator|>
name|result
operator|)
condition|)
name|minctime
operator|=
name|result
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/** 	 * As per Justin's suggestion, we now will call the run_queue for 	 * this HBA. This is done in case there are left-over requests that 	 * were not submitted yet. 	 */
name|dpt_run_queue
argument_list|(
name|dpt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|queue_status
operator|&=
operator|~
name|DPT_COMPLETED_QUEUE_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_comment
comment|/**  * Given a dpt_ccb and a scsi_xfr structures,  * this functions translates the result of a SCSI operation.  * It returns values in the structures pointed by the arguments.  * This function does NOT attempt to protect itself from bad influence!  */
end_comment

begin_define
define|#
directive|define
name|WRITE_OP
value|1
end_define

begin_define
define|#
directive|define
name|READ_OP
value|2
end_define

begin_define
define|#
directive|define
name|min_submitR
value|dpt->performance.read_by_size_min_time[index]
end_define

begin_define
define|#
directive|define
name|max_submitR
value|dpt->performance.read_by_size_max_time[index]
end_define

begin_define
define|#
directive|define
name|min_submitW
value|dpt->performance.write_by_size_min_time[index]
end_define

begin_define
define|#
directive|define
name|max_submitW
value|dpt->performance.write_by_size_max_time[index]
end_define

begin_function
specifier|static
name|void
name|dpt_IObySize
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|op
operator|==
name|READ_OP
condition|)
block|{
operator|++
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_count
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|submitted_time
operator|<
name|min_submitR
condition|)
name|min_submitR
operator|=
name|ccb
operator|->
name|submitted_time
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|submitted_time
operator|>
name|max_submitR
condition|)
name|max_submitR
operator|=
name|ccb
operator|->
name|submitted_time
expr_stmt|;
block|}
else|else
block|{
comment|/* WRITE operation */
operator|++
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_count
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|submitted_time
operator|<
name|min_submitW
condition|)
name|min_submitW
operator|=
name|ccb
operator|->
name|submitted_time
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|submitted_time
operator|>
name|max_submitW
condition|)
name|max_submitW
operator|=
name|ccb
operator|->
name|submitted_time
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dpt_process_completion
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|ospl
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"dpt%d: Improper argumet to process_completion (%p)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|=
name|ccb
operator|->
name|xs
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
block|{
name|u_int32_t
name|size
decl_stmt|;
name|struct
name|scsi_rw_big
modifier|*
name|cmd
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|scsi_rw_big
operator|*
operator|)
operator|&
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_scsi_cmd
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|op_code
condition|)
block|{
case|case
literal|0xa8
case|:
comment|/* 12-byte READ	 */
case|case
literal|0x08
case|:
comment|/* 6-byte READ	 */
case|case
literal|0x28
case|:
comment|/* 10-byte READ	 */
name|op_type
operator|=
name|READ_OP
expr_stmt|;
break|break;
case|case
literal|0x0a
case|:
comment|/* 6-byte WRITE */
case|case
literal|0xaa
case|:
comment|/* 12-byte WRITE */
case|case
literal|0x2a
case|:
comment|/* 10-byte WRITE */
name|op_type
operator|=
name|WRITE_OP
expr_stmt|;
break|break;
default|default:
name|op_type
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_type
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|cmd
operator|->
name|length2
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|cmd
operator|->
name|length1
operator|)
operator|)
operator|<<
literal|9
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|512
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_512
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_1K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2048
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_2K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4096
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_4K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_8K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_16K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_32K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|65536
case|:
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_64K
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|size
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_BIGGER
argument_list|)
expr_stmt|;
else|else
name|dpt_IObySize
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|,
name|op_type
argument_list|,
name|SIZE_OTHER
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
switch|switch
condition|(
operator|(
name|int
operator|)
name|ccb
operator|->
name|status_packet
operator|.
name|hba_stat
condition|)
block|{
case|case
name|HA_NO_ERROR
case|:
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
break|break;
case|case
name|HA_ERR_SEL_TO
case|:
case|case
name|HA_ERR_CMD_TO
case|:
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SELTIMEOUT
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
break|break;
case|case
name|HA_SCSIBUS_RESET
case|:
case|case
name|HA_CP_ABORTED
case|:
case|case
name|HA_CP_RESET
case|:
case|case
name|HA_PCI_PARITY
case|:
case|case
name|HA_PCI_MABORT
case|:
case|case
name|HA_PCI_TABORT
case|:
case|case
name|HA_PCI_STABORT
case|:
case|case
name|HA_BUS_PARITY
case|:
case|case
name|HA_UNX_MSGRJCT
case|:
if|if
condition|(
name|ccb
operator|->
name|retries
operator|++
operator|>
name|DPT_RETRIES
condition|)
block|{
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
block|}
else|else
block|{
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HA_HBA_POWER_UP
case|:
case|case
name|HA_UNX_BUSPHASE
case|:
case|case
name|HA_UNX_BUS_FREE
case|:
case|case
name|HA_SCSI_HUNG
case|:
case|case
name|HA_RESET_STUCK
case|:
if|if
condition|(
name|ccb
operator|->
name|retries
operator|++
operator|>
name|DPT_RETRIES
condition|)
block|{
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
block|}
else|else
block|{
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|HA_RSENSE_FAIL
case|:
if|if
condition|(
name|ccb
operator|->
name|status_packet
operator|.
name|EOC
condition|)
block|{
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ccb
operator|->
name|retries
operator|++
operator|>
name|DPT_RETRIES
condition|)
block|{
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
block|}
else|else
block|{
name|ospl
operator|=
name|splsoftcam
argument_list|()
expr_stmt|;
name|dpt_Qpush_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
case|case
name|HA_PARITY_ERR
case|:
case|case
name|HA_CP_ABORT_NA
case|:
case|case
name|HA_CP_RESET_NA
case|:
case|case
name|HA_ECC_ERR
case|:
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"dpt%d: Undocumented Error %x"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|status_packet
operator|.
name|hba_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator||=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
block|}
name|Debugger
argument_list|(
literal|"Please mail this message to shimon@i-connect.net"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|xs
operator|->
name|error
operator|&
name|XS_SENSE
operator|)
condition|)
name|bcopy
argument_list|(
operator|&
name|ccb
operator|->
name|sense_data
argument_list|,
operator|&
name|xs
operator|->
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|status_packet
operator|.
name|residue_len
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|ccb
operator|->
name|status_packet
operator|.
name|residue_len
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_LOST_IRQ
end_ifdef

begin_comment
comment|/**  * This functions handles the calling of the interrupt routine on a periodic  * basis.  * It is a completely ugly hack which purpose is to handle the problem of  * missing interrupts on certain platforms..  *  * An additional task is to optionally check if the controller is wedged.  * A wedeged controller is one which has not accepted a command, nor sent  * an interrupt in the last DPT_RESET_HBA seconds.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_irq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
init|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|ospl
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_LOST_IRQ_ACTIVE
operator|)
condition|)
block|{
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|state
operator||=
name|DPT_LOST_IRQ_ACTIVE
expr_stmt|;
name|dpt_intr
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_LOST_IRQ_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"dpt %d: %d lost Interrupts Recovered\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|++
name|dpt
operator|->
name|lost_interrupts
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DPT_RESET_HBA
block|{
name|int
name|max_wedge
decl_stmt|,
name|contact_delta
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|)
condition|)
block|{
name|dpt
operator|->
name|last_contact
operator|=
name|microtime_now
expr_stmt|;
block|}
else|else
block|{
comment|/* If nothing is waiting, we cannot assume we are wedged */
if|if
condition|(
name|DPT_RESET_HBA
operator|<
literal|1
condition|)
name|max_wedge
operator|=
literal|1000000
expr_stmt|;
else|else
name|max_wedge
operator|=
literal|1000000
operator|*
name|DPT_RESET_HBA
expr_stmt|;
name|contact_delta
operator|=
name|dpt_time_delta
argument_list|(
name|dpt
operator|->
name|last_contact
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|contact_delta
operator|>
name|max_wedge
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: Appears wedged for %d.%d (%d.0)seconds.\n"
literal|"      Resetting\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|contact_delta
operator|/
literal|1000000
argument_list|,
operator|(
name|contact_delta
operator|%
literal|1000000
operator|)
operator|/
literal|100000
argument_list|,
name|DPT_RESET_HBA
argument_list|)
expr_stmt|;
name|dpt_reset_hba
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DPT_RESET_HBA */
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_LOST_IRQ_ACTIVE
expr_stmt|;
block|}
name|timeout
argument_list|(
name|dpt_irq_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|dpt
argument_list|,
name|hz
operator|*
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_LOST_IRQ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_HANDLE_TIMEOUTS
end_ifdef

begin_comment
comment|/**  * This function walks down the SUBMITTED queue.  * Every request that is too old gets aborted and marked.  * Since the DPT will complete (interrupt) immediately (what does that mean?),  * We just walk the list, aborting old commands and marking them as such.  * The dpt_complete function will get rid of the that were interrupted in the  * normal manner.  *  * This function needs to run at splcam(), as it interacts with the submitted  * queue, as well as the completed and free queues.  Just like dpt_intr() does.  * To run it at any ISPL other than that of dpt_intr(), will mean that dpt_intr  * willbe able to pre-empt it, grab a transaction in progress (towards  * destruction) and operate on it.  The state of this transaction will be not  * very clear.  * The only other option, is to lock it only as long as necessary but have  * dpt_intr() spin-wait on it. In a UP environment this makes no sense and in  * a SMP environment, the advantage is dubvious for a function that runs once  * every ten seconds for few microseconds and, on systems with healthy  * hardware, does not do anything anyway.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_handle_timeouts
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|dpt_ccb_t
modifier|*
name|ccb
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_TIMEOUTS_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d WARNING: Timeout Handling Collision\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_TIMEOUTS_ACTIVE
expr_stmt|;
comment|/* Loop through the entire submitted queue, looking for lost souls */
for|for
control|(
name|ccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|submitted_ccbs
argument_list|)
init|;
name|ccb
operator|!=
name|NULL
condition|;
name|ccb
operator|=
name|TAILQ_NEXT
argument_list|(
name|ccb
argument_list|,
name|links
argument_list|)
control|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|u_int32_t
name|age
decl_stmt|,
name|max_age
decl_stmt|;
name|xs
operator|=
name|ccb
operator|->
name|xs
expr_stmt|;
name|age
operator|=
name|dpt_time_delta
argument_list|(
name|ccb
operator|->
name|command_started
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
define|#
directive|define
name|TenSec
value|10000000
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
comment|/* Local, non-kernel call */
name|max_age
operator|=
name|TenSec
expr_stmt|;
block|}
else|else
block|{
name|max_age
operator|=
operator|(
operator|(
operator|(
name|xs
operator|->
name|timeout
operator|*
operator|(
name|dpt
operator|->
name|submitted_ccbs_count
operator|+
name|DPT_TIMEOUT_FACTOR
operator|)
operator|)
operator|>
name|TenSec
operator|)
condition|?
operator|(
name|xs
operator|->
name|timeout
operator|*
operator|(
name|dpt
operator|->
name|submitted_ccbs_count
operator|+
name|DPT_TIMEOUT_FACTOR
operator|)
operator|)
else|:
name|TenSec
operator|)
expr_stmt|;
block|}
comment|/* 		 * If a transaction is marked lost and is TWICE as old as we 		 * care, then, and only then do we destroy it! 		 */
if|if
condition|(
name|ccb
operator|->
name|state
operator|&
name|DPT_CCB_STATE_MARKED_LOST
condition|)
block|{
comment|/* Remember who is next */
if|if
condition|(
name|age
operator|>
operator|(
name|max_age
operator|*
literal|2
operator|)
condition|)
block|{
name|dpt_Qremove_submitted
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|state
operator|&=
operator|~
name|DPT_CCB_STATE_MARKED_LOST
expr_stmt|;
name|ccb
operator|->
name|state
operator||=
name|DPT_CCB_STATE_ABORTED
expr_stmt|;
define|#
directive|define
name|cmd_name
value|scsi_cmd_name(ccb->eata_ccb.cp_scsi_cmd)
if|if
condition|(
name|ccb
operator|->
name|retries
operator|++
operator|>
name|DPT_RETRIES
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Destroying stale "
literal|"%d (%s)\n"
literal|"		on "
literal|"c%db%dt%du%d (%d/%d)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|transaction_id
argument_list|,
name|cmd_name
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_channel
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_id
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_LUN
argument_list|,
name|age
argument_list|,
name|ccb
operator|->
name|retries
argument_list|)
expr_stmt|;
define|#
directive|define
name|send_ccb
value|&ccb->eata_ccb
define|#
directive|define
name|ESA
value|EATA_SPECIFIC_ABORT
operator|(
name|void
operator|)
name|dpt_send_immediate
argument_list|(
name|dpt
argument_list|,
name|send_ccb
argument_list|,
name|ESA
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dpt_Qpush_free
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* The SCSI layer should re-try */
name|xs
operator|->
name|error
operator||=
name|XS_TIMEOUT
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Stale %d (%s) on "
literal|"c%db%dt%du%d (%d)\n"
literal|"		gets another "
literal|"chance(%d/%d)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|transaction_id
argument_list|,
name|cmd_name
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_channel
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_id
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_LUN
argument_list|,
name|age
argument_list|,
name|ccb
operator|->
name|retries
argument_list|,
name|DPT_RETRIES
argument_list|)
expr_stmt|;
name|dpt_Qpush_waiting
argument_list|(
name|dpt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|dpt_sched_queue
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * This is a transaction that is not to be destroyed 			 * (yet) But it is too old for our liking. We wait as 			 * long as the upper layer thinks. Not really, we 			 * multiply that by the number of commands in the 			 * submitted queue + 1. 			 */
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|state
operator|&
name|DPT_CCB_STATE_MARKED_LOST
operator|)
operator|&&
operator|(
name|age
operator|!=
operator|~
literal|0
operator|)
operator|&&
operator|(
name|age
operator|>
name|max_age
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d ERROR: Marking %d (%s) on "
literal|"c%db%dt%du%d \n"
literal|"            as late after %dusec\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|transaction_id
argument_list|,
name|cmd_name
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_channel
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_id
argument_list|,
name|ccb
operator|->
name|eata_ccb
operator|.
name|cp_LUN
argument_list|,
name|age
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|state
operator||=
name|DPT_CCB_STATE_MARKED_LOST
expr_stmt|;
block|}
block|}
block|}
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_HA_TIMEOUTS_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dpt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
init|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_TIMEOUTS_ACTIVE
operator|)
condition|)
name|dpt_handle_timeouts
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|dpt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|dpt
argument_list|,
name|hz
operator|*
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_HANDLE_TIMEOUTS */
end_comment

begin_comment
comment|/*  * Remove a ccb from the completed queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qremove_completed
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|u_int32_t
name|complete_time
decl_stmt|;
name|complete_time
operator|=
name|dpt_time_delta
argument_list|(
name|ccb
operator|->
name|command_ended
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|complete_time
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_complete_time
operator|<
name|complete_time
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_complete_time
operator|=
name|complete_time
expr_stmt|;
if|if
condition|(
name|complete_time
operator|<
name|dpt
operator|->
name|performance
operator|.
name|min_complete_time
condition|)
name|dpt
operator|->
name|performance
operator|.
name|min_complete_time
operator|=
name|complete_time
expr_stmt|;
block|}
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dpt
operator|->
name|completed_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|--
name|dpt
operator|->
name|completed_ccbs_count
expr_stmt|;
comment|/* One less completed ccb in the 					 * queue */
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Pop the most recently used ccb off the (HEAD of the) FREE ccb queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|dpt_ccb_t
modifier|*
name|dpt_Qpop_free
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|dpt_ccb_t
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dpt_alloc_freelist
argument_list|(
name|dpt
argument_list|)
condition|)
return|return
operator|(
name|ccb
operator|)
return|;
else|else
return|return
operator|(
name|dpt_Qpop_free
argument_list|(
name|dpt
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|--
name|dpt
operator|->
name|free_ccbs_count
expr_stmt|;
block|}
return|return
operator|(
name|ccb
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Put a (now freed) ccb back into the HEAD of the FREE ccb queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qpush_free
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DPT_FREELIST_IS_STACK
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
else|#
directive|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dpt
operator|->
name|free_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|dpt
operator|->
name|free_ccbs_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	Add a request to the TAIL of the WAITING ccb queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qadd_waiting
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|++
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|ccb
operator|->
name|command_ended
operator|=
name|microtime_now
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|waiting_ccbs_count
operator|>
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_count
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_count
operator|=
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	Add a request to the HEAD of the WAITING ccb queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qpush_waiting
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|++
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|ccb
operator|->
name|command_ended
operator|=
name|microtime_now
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_count
operator|<
name|dpt
operator|->
name|waiting_ccbs_count
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_count
operator|=
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Remove a ccb from the waiting queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qremove_waiting
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|u_int32_t
name|waiting_time
decl_stmt|;
name|waiting_time
operator|=
name|dpt_time_delta
argument_list|(
name|ccb
operator|->
name|command_ended
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|waiting_time
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_time
operator|<
name|waiting_time
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_time
operator|=
name|waiting_time
expr_stmt|;
if|if
condition|(
name|waiting_time
operator|<
name|dpt
operator|->
name|performance
operator|.
name|min_waiting_time
condition|)
name|dpt
operator|->
name|performance
operator|.
name|min_waiting_time
operator|=
name|waiting_time
expr_stmt|;
block|}
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dpt
operator|->
name|waiting_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|--
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
comment|/* One less waiting ccb in the queue	 */
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Add a request to the TAIL of the SUBMITTED ccb queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qadd_submitted
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dpt
operator|->
name|submitted_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|++
name|dpt
operator|->
name|submitted_ccbs_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|ccb
operator|->
name|command_ended
operator|=
name|microtime_now
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_submit_count
operator|<
name|dpt
operator|->
name|submitted_ccbs_count
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_submit_count
operator|=
name|dpt
operator|->
name|submitted_ccbs_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Add a request to the TAIL of the Completed ccb queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qadd_completed
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dpt
operator|->
name|completed_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|++
name|dpt
operator|->
name|completed_ccbs_count
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|ccb
operator|->
name|command_ended
operator|=
name|microtime_now
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_complete_count
operator|<
name|dpt
operator|->
name|completed_ccbs_count
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_complete_count
operator|=
name|dpt
operator|->
name|completed_ccbs_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Remove a ccb from the submitted queue  */
end_comment

begin_function
specifier|static
name|INLINE_Q
name|void
name|dpt_Qremove_submitted
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|,
name|dpt_ccb_t
modifier|*
name|ccb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|u_int32_t
name|submit_time
decl_stmt|;
name|submit_time
operator|=
name|dpt_time_delta
argument_list|(
name|ccb
operator|->
name|command_ended
argument_list|,
name|microtime_now
argument_list|)
expr_stmt|;
if|if
condition|(
name|submit_time
operator|!=
operator|~
literal|0
condition|)
block|{
name|ccb
operator|->
name|submitted_time
operator|=
name|submit_time
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|max_submit_time
operator|<
name|submit_time
condition|)
name|dpt
operator|->
name|performance
operator|.
name|max_submit_time
operator|=
name|submit_time
expr_stmt|;
if|if
condition|(
name|submit_time
operator|<
name|dpt
operator|->
name|performance
operator|.
name|min_submit_time
condition|)
name|dpt
operator|->
name|performance
operator|.
name|min_submit_time
operator|=
name|submit_time
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|submitted_time
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dpt
operator|->
name|submitted_ccbs
argument_list|,
name|ccb
argument_list|,
name|links
argument_list|)
expr_stmt|;
operator|--
name|dpt
operator|->
name|submitted_ccbs_count
expr_stmt|;
comment|/* One less submitted ccb in the 					 * queue */
if|if
condition|(
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
operator|)
operator|||
operator|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_QUIET
operator|)
condition|)
name|wakeup
argument_list|(
operator|&
name|dpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Handle Shutdowns.  * Gets registered by the dpt_pci.c registar and called AFTER the system did  * all its sync work.  */
end_comment

begin_function
name|void
name|dpt_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|arg_dpt
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|ldpt
decl_stmt|;
name|u_int8_t
name|channel
decl_stmt|;
name|u_int32_t
name|target
decl_stmt|;
name|u_int32_t
name|lun
decl_stmt|;
name|int
name|waiting
decl_stmt|;
name|int
name|submitted
decl_stmt|;
name|int
name|completed
decl_stmt|;
name|int
name|huh
decl_stmt|;
name|int
name|wait_is_over
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt
operator|=
operator|(
name|dpt_softc_t
operator|*
operator|)
name|arg_dpt
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d: Shutting down (mode %d) HBA.	Please wait..."
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|howto
argument_list|)
expr_stmt|;
name|wait_is_over
operator|=
literal|0
expr_stmt|;
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_SHUTDOWN_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
operator|(
name|waiting
operator|=
name|dpt
operator|->
name|waiting_ccbs_count
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|submitted
operator|=
name|dpt
operator|->
name|submitted_ccbs_count
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|completed
operator|=
name|dpt
operator|->
name|completed_ccbs_count
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|wait_is_over
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_SHUTDOWN
name|printf
argument_list|(
literal|"dpt%d: Waiting for queues w%ds%dc%d to deplete\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|waiting_ccbs_count
argument_list|,
name|dpt
operator|->
name|submitted_ccbs_count
argument_list|,
name|dpt
operator|->
name|completed_ccbs_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|huh
operator|=
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dpt
argument_list|,
name|PCATCH
operator||
name|PRIBIO
argument_list|,
literal|"dptoff"
argument_list|,
literal|100
operator|*
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|huh
condition|)
block|{
case|case
literal|0
case|:
comment|/* Wakeup call received */
goto|goto
name|checkit
goto|;
break|break;
case|case
name|EWOULDBLOCK
case|:
comment|/* Timer Expired */
name|printf
argument_list|(
literal|"dpt%d: Shutdown timer expired with queues at "
literal|"w%ds%dc%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|waiting_ccbs_count
argument_list|,
name|dpt
operator|->
name|submitted_ccbs_count
argument_list|,
name|dpt
operator|->
name|completed_ccbs_count
argument_list|)
expr_stmt|;
operator|++
name|wait_is_over
expr_stmt|;
break|break;
default|default:
comment|/* anything else */
name|printf
argument_list|(
literal|"dpt%d: Shutdown UNKNOWN with qeueues at "
literal|"w%ds%dc%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|waiting_ccbs_count
argument_list|,
name|dpt
operator|->
name|submitted_ccbs_count
argument_list|,
name|dpt
operator|->
name|completed_ccbs_count
argument_list|)
expr_stmt|;
operator|++
name|wait_is_over
expr_stmt|;
break|break;
block|}
name|checkit
label|:
block|}
comment|/** 	 * What we do for a shutdown, is give the DPT early power loss 	 * warning      */
ifdef|#
directive|ifdef
name|DPT_SHUTDOWN_SLEEP
name|DELAY
argument_list|(
name|DPT_SHUTDOWN_SLEEP
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_SHUTDOWN_ACTIVE
condition|)
block|{
name|ospl
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_HA_SHUTDOWN_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d: WARNING:  After sleeping for %d seconds, "
literal|"I am re-enabled\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                Any further I/O is NOT guranteed to "
literal|"complete!\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|dpt_send_immediate
argument_list|(
name|dpt
argument_list|,
name|NULL
argument_list|,
name|EATA_POWER_OFF_WARN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dpt%d: Controller was warned of shutdown and is now "
literal|"disabled\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* A primitive subset of isgraph.	Used by hex_dump below */
end_comment

begin_define
define|#
directive|define
name|IsGraph
parameter_list|(
name|val
parameter_list|)
value|((((val)>= ' ')&& ((val)<= '~')))
end_define

begin_comment
comment|/**  * This function dumps bytes to the screen in hex format.  */
end_comment

begin_function
specifier|static
name|void
name|hex_dump
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|length
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|no
parameter_list|)
block|{
name|int
name|line
decl_stmt|,
name|column
decl_stmt|,
name|ndx
decl_stmt|;
name|printf
argument_list|(
literal|"Kernel Hex Dump for %s-%d at %p (%d bytes)\n"
argument_list|,
name|name
argument_list|,
name|no
argument_list|,
name|data
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Zero out all the counters and repeat for as many bytes as we have */
for|for
control|(
name|ndx
operator|=
literal|0
operator|,
name|column
operator|=
literal|0
operator|,
name|line
operator|=
literal|0
init|;
name|ndx
operator|<
name|length
condition|;
name|ndx
operator|++
control|)
block|{
comment|/* Print relative offset at the beginning of every line */
if|if
condition|(
name|column
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|ndx
argument_list|)
expr_stmt|;
comment|/* Print the byte as two hex digits, followed by a space */
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|data
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
comment|/* Split the row of 16 bytes in half */
if|if
condition|(
operator|++
name|column
operator|==
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
comment|/* St the end of each row of 16 bytes, put a space ... */
if|if
condition|(
name|column
operator|==
literal|16
condition|)
block|{
name|printf
argument_list|(
literal|"	"
argument_list|)
expr_stmt|;
comment|/* ... and then print the ASCII-visible on a line. */
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
literal|16
condition|;
name|column
operator|++
control|)
block|{
name|int
name|ascii_pos
init|=
name|ndx
operator|-
literal|15
operator|+
name|column
decl_stmt|;
comment|/** 				 * Non-printable and non-ASCII are just a 				 * dot. ;-( 				 */
if|if
condition|(
name|IsGraph
argument_list|(
name|data
index|[
name|ascii_pos
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|data
index|[
name|ascii_pos
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|/* Each line ends with a new line */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
comment|/** 			 * Every 256 bytes (16 lines of 16 bytes each) have 			 * an empty line, separating them from the next 			 * ``page''. Yes, I programmed on a Z-80, where a 			 * page was 256 bytes :-) 			 */
if|if
condition|(
operator|++
name|line
operator|>
literal|15
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|line
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/** 	 * We are basically done. We do want, however, to handle the ASCII 	 * translation of fractional lines. 	 */
if|if
condition|(
operator|(
name|ndx
operator|==
name|length
operator|)
operator|&&
operator|(
name|column
operator|!=
literal|0
operator|)
condition|)
block|{
name|int
name|modulus
init|=
literal|16
operator|-
name|column
decl_stmt|,
name|spaces
init|=
name|modulus
operator|*
literal|3
decl_stmt|,
name|skip
decl_stmt|;
comment|/** 		 * Skip to the right, as many spaces as there are bytes 		 * ``missing'' ... 		 */
for|for
control|(
name|skip
operator|=
literal|0
init|;
name|skip
operator|<
name|spaces
condition|;
name|skip
operator|++
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* ... And the gap separating the hex dump from the ASCII */
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
comment|/** 		 * Do not forget the extra space that splits the hex dump 		 * vertically 		 */
if|if
condition|(
name|column
operator|<
literal|8
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|column
operator|=
literal|0
init|;
name|column
operator|<
operator|(
literal|16
operator|-
name|modulus
operator|)
condition|;
name|column
operator|++
control|)
block|{
name|int
name|ascii_pos
init|=
name|ndx
operator|-
operator|(
literal|16
operator|-
name|modulus
operator|)
operator|+
name|column
decl_stmt|;
if|if
condition|(
name|IsGraph
argument_list|(
name|data
index|[
name|ascii_pos
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|data
index|[
name|ascii_pos
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * and this one presents an integer as ones and zeros  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|i2bin_bitmap
index|[
literal|48
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for binary dump of registers */
end_comment

begin_function
name|char
modifier|*
name|i2bin
parameter_list|(
name|unsigned
name|int
name|no
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|,
name|rind
decl_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
operator|,
name|rind
operator|=
literal|0
init|;
name|ndx
operator|<
literal|32
condition|;
name|ndx
operator|++
operator|,
name|rind
operator|++
control|)
block|{
name|i2bin_bitmap
index|[
name|rind
index|]
operator|=
operator|(
operator|(
operator|(
name|no
operator|<<
name|ndx
operator|)
operator|&
literal|0x80000000
operator|)
condition|?
literal|'1'
else|:
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ndx
operator|%
literal|4
operator|)
operator|==
literal|3
operator|)
condition|)
name|i2bin_bitmap
index|[
operator|++
name|rind
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ndx
operator|%
literal|4
operator|)
operator|==
literal|3
condition|)
name|i2bin_bitmap
index|[
name|rind
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|i2bin_bitmap
index|[
name|rind
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|8
case|:
return|return
operator|(
name|i2bin_bitmap
operator|+
literal|30
operator|)
return|;
break|break;
case|case
literal|16
case|:
return|return
operator|(
name|i2bin_bitmap
operator|+
literal|20
operator|)
return|;
break|break;
case|case
literal|24
case|:
return|return
operator|(
name|i2bin_bitmap
operator|+
literal|10
operator|)
return|;
break|break;
case|case
literal|32
case|:
return|return
operator|(
name|i2bin_bitmap
operator|)
return|;
default|default:
return|return
operator|(
literal|"i2bin: Invalid length Specs"
operator|)
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * This function translates a SCSI command numeric code to a human readable  * string.  * The string contains the class of devices, scope, description, (length),  * and [SCSI III documentation section].  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|scsi_cmd_name
parameter_list|(
name|u_int8_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|0x40
case|:
return|return
operator|(
literal|"Change Definition [7.1]"
operator|)
return|;
break|break;
case|case
literal|0x39
case|:
return|return
operator|(
literal|"Compare [7,2]"
operator|)
return|;
break|break;
case|case
literal|0x18
case|:
return|return
operator|(
literal|"Copy [7.3]"
operator|)
return|;
break|break;
case|case
literal|0x3a
case|:
return|return
operator|(
literal|"Copy and Verify [7.4]"
operator|)
return|;
break|break;
case|case
literal|0x04
case|:
return|return
operator|(
literal|"Format Unit [6.1.1]"
operator|)
return|;
break|break;
case|case
literal|0x12
case|:
return|return
operator|(
literal|"Inquiry [7.5]"
operator|)
return|;
break|break;
case|case
literal|0x36
case|:
return|return
operator|(
literal|"lock/Unlock Cache [6.1.2]"
operator|)
return|;
break|break;
case|case
literal|0x4c
case|:
return|return
operator|(
literal|"Log Select [7.6]"
operator|)
return|;
break|break;
case|case
literal|0x4d
case|:
return|return
operator|(
literal|"Log Sense [7.7]"
operator|)
return|;
break|break;
case|case
literal|0x15
case|:
return|return
operator|(
literal|"Mode select (6) [7.8]"
operator|)
return|;
break|break;
case|case
literal|0x55
case|:
return|return
operator|(
literal|"Mode Select (10) [7.9]"
operator|)
return|;
break|break;
case|case
literal|0x1a
case|:
return|return
operator|(
literal|"Mode Sense (6) [7.10]"
operator|)
return|;
break|break;
case|case
literal|0x5a
case|:
return|return
operator|(
literal|"Mode Sense (10) [7.11]"
operator|)
return|;
break|break;
case|case
literal|0xa7
case|:
return|return
operator|(
literal|"Move Medium Attached [SMC]"
operator|)
return|;
break|break;
case|case
literal|0x5e
case|:
return|return
operator|(
literal|"Persistent Reserve In [7.12]"
operator|)
return|;
break|break;
case|case
literal|0x5f
case|:
return|return
operator|(
literal|"Persistent Reserve Out [7.13]"
operator|)
return|;
break|break;
case|case
literal|0x1e
case|:
return|return
operator|(
literal|"Prevent/Allow Medium Removal [7.14]"
operator|)
return|;
break|break;
case|case
literal|0x08
case|:
return|return
operator|(
literal|"Read, Receive (6) [6.1.5]"
operator|)
return|;
break|break;
case|case
literal|0x28
case|:
return|return
operator|(
literal|"Read (10) [6.1.5]"
operator|)
return|;
break|break;
case|case
literal|0xa8
case|:
return|return
operator|(
literal|"Read (12) [6.1.5]"
operator|)
return|;
break|break;
case|case
literal|0x3c
case|:
return|return
operator|(
literal|"Read Buffer [7.15]"
operator|)
return|;
break|break;
case|case
literal|0x25
case|:
return|return
operator|(
literal|"Read Capacity [6.1.6]"
operator|)
return|;
break|break;
case|case
literal|0x37
case|:
return|return
operator|(
literal|"Read Defect Data (10) [6.1.7]"
operator|)
return|;
break|break;
case|case
literal|0xb7
case|:
return|return
operator|(
literal|"Read Defect Data (12) [6.2.5]"
operator|)
return|;
break|break;
case|case
literal|0xb4
case|:
return|return
operator|(
literal|"Read Element Status Attached [SMC]"
operator|)
return|;
break|break;
case|case
literal|0x3e
case|:
return|return
operator|(
literal|"Read Long [6.1.8]"
operator|)
return|;
break|break;
case|case
literal|0x07
case|:
return|return
operator|(
literal|"Reassign Blocks [6.1.9]"
operator|)
return|;
break|break;
case|case
literal|0x81
case|:
return|return
operator|(
literal|"Rebuild [6.1.10]"
operator|)
return|;
break|break;
case|case
literal|0x1c
case|:
return|return
operator|(
literal|"Receive Diagnostics Result [7.16]"
operator|)
return|;
break|break;
case|case
literal|0x82
case|:
return|return
operator|(
literal|"Regenerate [6.1.11]"
operator|)
return|;
break|break;
case|case
literal|0x17
case|:
return|return
operator|(
literal|"Release(6) [7.17]"
operator|)
return|;
break|break;
case|case
literal|0x57
case|:
return|return
operator|(
literal|"Release(10) [7.18]"
operator|)
return|;
break|break;
case|case
literal|0xa0
case|:
return|return
operator|(
literal|"Report LUNs [7.19]"
operator|)
return|;
break|break;
case|case
literal|0x03
case|:
return|return
operator|(
literal|"Request Sense [7.20]"
operator|)
return|;
break|break;
case|case
literal|0x16
case|:
return|return
operator|(
literal|"Resereve (6) [7.21]"
operator|)
return|;
break|break;
case|case
literal|0x56
case|:
return|return
operator|(
literal|"Reserve(10) [7.22]"
operator|)
return|;
break|break;
case|case
literal|0x2b
case|:
return|return
operator|(
literal|"Reserve(10) [6.1.12]"
operator|)
return|;
break|break;
case|case
literal|0x1d
case|:
return|return
operator|(
literal|"Send Disagnostics [7.23]"
operator|)
return|;
break|break;
case|case
literal|0x33
case|:
return|return
operator|(
literal|"Set Limit (10) [6.1.13]"
operator|)
return|;
break|break;
case|case
literal|0xb3
case|:
return|return
operator|(
literal|"Set Limit (12) [6.2.8]"
operator|)
return|;
break|break;
case|case
literal|0x1b
case|:
return|return
operator|(
literal|"Start/Stop Unit [6.1.14]"
operator|)
return|;
break|break;
case|case
literal|0x35
case|:
return|return
operator|(
literal|"Synchronize Cache [6.1.15]"
operator|)
return|;
break|break;
case|case
literal|0x00
case|:
return|return
operator|(
literal|"Test Unit Ready [7.24]"
operator|)
return|;
break|break;
case|case
literal|0x3d
case|:
return|return
operator|(
literal|"Update Block (6.2.9"
operator|)
return|;
break|break;
case|case
literal|0x2f
case|:
return|return
operator|(
literal|"Verify (10) [6.1.16, 6.2.10]"
operator|)
return|;
break|break;
case|case
literal|0xaf
case|:
return|return
operator|(
literal|"Verify (12) [6.2.11]"
operator|)
return|;
break|break;
case|case
literal|0x0a
case|:
return|return
operator|(
literal|"Write, Send (6) [6.1.17, 9.2]"
operator|)
return|;
break|break;
case|case
literal|0x2a
case|:
return|return
operator|(
literal|"Write (10) [6.1.18]"
operator|)
return|;
break|break;
case|case
literal|0xaa
case|:
return|return
operator|(
literal|"Write (12) [6.2.13]"
operator|)
return|;
break|break;
case|case
literal|0x2e
case|:
return|return
operator|(
literal|"Write and Verify (10) [6.1.19, 6.2.14]"
operator|)
return|;
break|break;
case|case
literal|0xae
case|:
return|return
operator|(
literal|"Write and Verify (12) [6.1.19, 6.2.15]"
operator|)
return|;
break|break;
case|case
literal|0x03b
case|:
return|return
operator|(
literal|"Write Buffer [7.25]"
operator|)
return|;
break|break;
case|case
literal|0x03f
case|:
return|return
operator|(
literal|"Write Long [6.1.20]"
operator|)
return|;
break|break;
case|case
literal|0x041
case|:
return|return
operator|(
literal|"Write Same [6.1.21]"
operator|)
return|;
break|break;
case|case
literal|0x052
case|:
return|return
operator|(
literal|"XD Read [6.1.22]"
operator|)
return|;
break|break;
case|case
literal|0x050
case|:
return|return
operator|(
literal|"XD Write [6.1.22]"
operator|)
return|;
break|break;
case|case
literal|0x080
case|:
return|return
operator|(
literal|"XD Write Extended [6.1.22]"
operator|)
return|;
break|break;
case|case
literal|0x051
case|:
return|return
operator|(
literal|"XO Write [6.1.22]"
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|"Unknown SCSI Command"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* End of the DPT driver */
end_comment

begin_comment
comment|/**  * Hello emacs, these are the  * Local Variables:  *  c-indent-level:               8  *  c-continued-statement-offset: 8  *  c-continued-brace-offset:     0  *  c-brace-offset:              -8  *  c-brace-imaginary-offset:     0  *  c-argdecl-indent:             8  *  c-label-offset:              -8  *  c++-hanging-braces:           1  *  c++-access-specifier-offset: -8  *  c++-empty-arglist-indent:     8  *  c++-friend-offset:            0  * End:  */
end_comment

end_unit

