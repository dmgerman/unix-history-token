begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  *       Copyright (c) 1997 by Simon Shapiro  *       All Rights Reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/**  * dpt_control.c: Control Functions and /dev entry points for /dev/dpt*  *  * Caveat Emptor!	This is work in progress.	The interfaces and  * functionality of this code will change (possibly radically) in the  * future.  */
end_comment

begin_empty
empty|#ident "$Id: dpt_control.c,v 1.7 1998/07/13 09:52:51 bde Exp $"
end_empty

begin_include
include|#
directive|include
file|"opt_dpt.h"
end_include

begin_include
include|#
directive|include
file|<i386/include/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dpt.h>
end_include

begin_define
define|#
directive|define
name|INLINE
value|__inline
end_define

begin_decl_stmt
specifier|extern
name|char
name|osrelease
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dpt_sysinfo_t
name|dpt_sysinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry points and other prototypes */
end_comment

begin_function_decl
specifier|static
name|vm_offset_t
name|dpt_physmap
parameter_list|(
name|u_int32_t
name|paddr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_unphysmap
parameter_list|(
name|u_int8_t
modifier|*
name|vaddr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_get_sysinfo
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dpt_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|cmdarg
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This has to be modified as the processor and CPU are not known yet */
end_comment

begin_decl_stmt
specifier|static
name|dpt_sig_t
name|dpt_sig
init|=
block|{
literal|'d'
block|,
literal|'P'
block|,
literal|'t'
block|,
literal|'S'
block|,
literal|'i'
block|,
literal|'G'
block|,
name|SIG_VERSION
block|,
name|PROC_INTEL
block|,
name|PROC_386
block|,
name|FT_HBADRVR
block|,
name|FTF_PROTECTED
block|,
name|OEM_DPT
block|,
name|OS_FREEBSD
block|,
name|CAP_PASS
operator||
name|CAP_OVERLAP
operator||
name|CAP_RAID0
operator||
name|CAP_RAID1
operator||
name|CAP_RAID5
operator||
name|CAP_ASPI
block|,
name|DEV_ALL
block|,
name|ADF_SC4_PCI
operator||
name|ADF_SC3_PCI
block|,
literal|0
block|,
literal|0
block|,
name|DPT_RELEASE
block|,
name|DPT_VERSION
block|,
name|DPT_PATCH
block|,
name|DPT_MONTH
block|,
name|DPT_DAY
block|,
name|DPT_YEAR
block|,
literal|"DPT FreeBSD Driver (c) 1997 Simon Shapiro"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|DPT_CDEV_MAJOR
end_define

begin_comment
comment|/* Normally, this is a static structure.  But we need it in pci/dpt_pci.c */
end_comment

begin_decl_stmt
name|struct
name|cdevsw
name|dpt_cdevsw
init|=
block|{
name|dpt_open
block|,
name|dpt_close
block|,
name|dpt_read
block|,
name|dpt_write
block|,
name|dpt_ioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"dpt"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
modifier|*
name|dpt_inbuf
index|[
name|DPT_MAX_ADAPTERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dpt_rw_command
index|[
name|DPT_MAX_ADAPTERS
index|]
index|[
name|DPT_RW_CMD_LEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
end_ifdef

begin_function
name|void
name|dpt_reset_performance
parameter_list|(
name|dpt_softc_t
modifier|*
name|dpt
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
comment|/* Zero out all command counters */
name|bzero
argument_list|(
operator|&
name|dpt
operator|->
name|performance
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_perf_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|256
condition|;
name|ndx
operator|++
control|)
name|dpt
operator|->
name|performance
operator|.
name|min_command_time
index|[
name|ndx
index|]
operator|=
name|BIG_ENOUGH
expr_stmt|;
name|dpt
operator|->
name|performance
operator|.
name|min_intr_time
operator|=
name|BIG_ENOUGH
expr_stmt|;
name|dpt
operator|->
name|performance
operator|.
name|min_waiting_time
operator|=
name|BIG_ENOUGH
expr_stmt|;
name|dpt
operator|->
name|performance
operator|.
name|min_submit_time
operator|=
name|BIG_ENOUGH
expr_stmt|;
name|dpt
operator|->
name|performance
operator|.
name|min_complete_time
operator|=
name|BIG_ENOUGH
expr_stmt|;
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
operator|=
name|BIG_ENOUGH
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|10
condition|;
name|ndx
operator|++
control|)
block|{
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_min_time
index|[
name|ndx
index|]
operator|=
name|BIG_ENOUGH
expr_stmt|;
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_min_time
index|[
name|ndx
index|]
operator|=
name|BIG_ENOUGH
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DPT_MEASURE_PERFORMANCE */
end_comment

begin_comment
comment|/**  * Given a minor device number,  * return the pointer to its softc structure  */
end_comment

begin_function
name|dpt_softc_t
modifier|*
name|dpt_minor2softc
parameter_list|(
name|int
name|minor_no
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
if|if
condition|(
name|dpt_minor2unit
argument_list|(
name|minor_no
operator|&
operator|~
name|SCSI_CONTROL_MASK
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|dpt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt_softc_list
argument_list|)
init|;
operator|(
name|dpt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dpt
operator|->
name|unit
operator|!=
operator|(
name|minor_no
operator|&
operator|~
name|SCSI_CONTROL_MASK
operator|)
operator|)
condition|;
name|dpt
operator|=
name|TAILQ_NEXT
argument_list|(
name|dpt
argument_list|,
name|links
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|dpt
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Map a physical address to virtual one.  * This is a first cut, experimental thing  *  * Paddr is the physical address to map  * size is the size of the region, in bytes.  * Because of alignment problems, we actually round up the size requested to  * the next page count.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|dpt_physmap
parameter_list|(
name|u_int32_t
name|req_paddr
parameter_list|,
name|vm_size_t
name|req_size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|u_int32_t
name|paddr
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|size
operator|=
operator|(
name|req_size
operator|/
name|PAGE_SIZE
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|paddr
operator|=
name|req_paddr
operator|&
literal|0xfffff000
expr_stmt|;
name|offset
operator|=
name|req_paddr
operator|-
name|paddr
expr_stmt|;
name|va
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
operator|(
name|vm_offset_t
operator|)
literal|0
condition|)
return|return
operator|(
name|va
operator|)
return|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|size
condition|;
name|ndx
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pmap_kenter
argument_list|(
name|va
operator|+
name|ndx
argument_list|,
name|paddr
operator|+
name|ndx
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|va
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release virtual space allocated by physmap We ASSUME that the correct  * srart address and the correct LENGTH are given.  *   * Disaster will follow if these assumptions are false!  */
end_comment

begin_function
specifier|static
name|void
name|dpt_unphysmap
parameter_list|(
name|u_int8_t
modifier|*
name|vaddr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|size
condition|;
name|ndx
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pmap_kremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vaddr
operator|+
name|ndx
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Collect interesting system information  * The following is one of the worst hacks I have ever allowed my  * name to be associated with.  * There MUST be a system structure that provides this data.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_get_sysinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dpt_sysinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sysinfo_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/**          * This is really silly, but we better run this in splhigh as we          * have no clue what we bump into.          * Let's hope anyone else who does this sort of things protects them          * with splhigh too.          */
name|ospl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cpu_class
condition|)
block|{
case|case
name|CPUCLASS_386
case|:
name|dpt_sig
operator|.
name|Processor
operator|=
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_386
expr_stmt|;
break|break;
case|case
name|CPUCLASS_486
case|:
name|dpt_sig
operator|.
name|Processor
operator|=
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_486
expr_stmt|;
break|break;
case|case
name|CPUCLASS_586
case|:
name|dpt_sig
operator|.
name|Processor
operator|=
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_PENTIUM
expr_stmt|;
break|break;
case|case
name|CPUCLASS_686
case|:
name|dpt_sig
operator|.
name|Processor
operator|=
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_P6
expr_stmt|;
break|break;
default|default:
name|dpt_sig
operator|.
name|Processor
operator|=
name|dpt_sysinfo
operator|.
name|flags
operator|&=
operator|~
name|SI_ProcessorValid
expr_stmt|;
break|break;
block|}
comment|/* Get The First Drive Type From CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|i
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|dpt_sysinfo
operator|.
name|drive0CMOS
operator|=
name|j
expr_stmt|;
comment|/* Get The Second Drive Type From CMOS */
name|j
operator|=
name|i
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|dpt_sysinfo
operator|.
name|drive1CMOS
operator|=
name|j
expr_stmt|;
comment|/* Get The Number Of Drives From The Bios Data Area */
if|if
condition|(
operator|(
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0x0475
argument_list|,
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"DPT:  Cannot map BIOS address 0x0475.  No sysinfo... :-(\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt_sysinfo
operator|.
name|numDrives
operator|=
operator|*
name|addr
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* Get the processor fields from the SIG structure, and set the flags */
name|dpt_sysinfo
operator|.
name|processorFamily
operator|=
name|dpt_sig
operator|.
name|ProcessorFamily
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator|=
name|SI_CMOS_Valid
operator||
name|SI_NumDrivesValid
expr_stmt|;
comment|/* Go out and look for SmartROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0xC8000
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0xD8000
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
default|default:
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0xDC000
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|addr
operator|)
operator|==
literal|0xaa55
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|addr
operator|+
literal|6
operator|)
operator|)
operator|==
literal|0x00202053
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|addr
operator|+
literal|10
operator|)
operator|)
operator|==
literal|0x00545044
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/**          * If i< 3, we founday it so set up a pointer to the starting          * version digit by searching for it.          */
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|+=
literal|0x15
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|addr
index|[
name|i
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|addr
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'v'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
block|{
name|addr
operator|+=
operator|(
name|i
operator|+
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If all is well, set up the SmartROM version fields */
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|dpt_sysinfo
operator|.
name|smartROMMajorVersion
operator|=
operator|*
name|addr
operator|-
literal|'0'
expr_stmt|;
comment|/* Assumes ASCII */
name|dpt_sysinfo
operator|.
name|smartROMMinorVersion
operator|=
operator|*
operator|(
name|addr
operator|+
literal|2
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|smartROMRevision
operator|=
operator|*
operator|(
name|addr
operator|+
literal|3
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_SmartROMverValid
expr_stmt|;
block|}
else|else
block|{
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_NO_SmartROM
expr_stmt|;
block|}
comment|/* Get the conventional memory size from CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x15
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|conventionalMemSize
operator|=
name|j
expr_stmt|;
comment|/**          * Get the extended memory found at power on from CMOS          */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|extendedMemSize
operator|=
name|j
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_MemorySizeValid
expr_stmt|;
comment|/* If there is 1 or 2 drives found, set up the drive parameters */
if|if
condition|(
name|dpt_sysinfo
operator|.
name|numDrives
operator|>
literal|0
condition|)
block|{
comment|/* Get the pointer from int 41 for the first drive parameters */
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0x0104
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|j
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
name|j
operator|*=
literal|16
expr_stmt|;
name|j
operator|+=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|)
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
name|j
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|cylinders
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|heads
operator|=
operator|*
operator|(
name|addr
operator|+
literal|2
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|sectors
operator|=
operator|*
operator|(
name|addr
operator|+
literal|14
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dpt_sysinfo
operator|.
name|numDrives
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Get the pointer from Int 46 for the second drive 			 * parameters 			 */
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0x01118
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|j
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
name|j
operator|*=
literal|16
expr_stmt|;
name|j
operator|+=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|)
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
name|j
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|cylinders
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|heads
operator|=
operator|*
operator|(
name|addr
operator|+
literal|2
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|sectors
operator|=
operator|*
operator|(
name|addr
operator|+
literal|14
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_DriveParamsValid
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* Get the processor information */
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_ProcessorValid
expr_stmt|;
comment|/* Get the bus I/O bus information */
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_BusTypeValid
expr_stmt|;
name|dpt_sysinfo
operator|.
name|busType
operator|=
name|HBA_BUS_PCI
expr_stmt|;
warning|#
directive|warning
literal|"O/S Version determination is an ugly hack"
name|dpt_sysinfo
operator|.
name|osType
operator|=
name|OS_FREEBSD
expr_stmt|;
name|dpt_sysinfo
operator|.
name|osMajorVersion
operator|=
name|osrelease
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|osrelease
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|dpt_sysinfo
operator|.
name|osMinorVersion
operator|=
name|osrelease
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
else|else
name|dpt_sysinfo
operator|.
name|osMinorVersion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|osrelease
index|[
literal|3
index|]
operator|==
literal|'.'
condition|)
name|dpt_sysinfo
operator|.
name|osRevision
operator|=
name|osrelease
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
else|else
name|dpt_sysinfo
operator|.
name|osMinorVersion
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|osrelease
index|[
literal|5
index|]
operator|==
literal|'.'
condition|)
name|dpt_sysinfo
operator|.
name|osSubRevision
operator|=
name|osrelease
index|[
literal|6
index|]
operator|-
literal|'0'
expr_stmt|;
else|else
name|dpt_sysinfo
operator|.
name|osMinorVersion
operator|=
literal|0
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_OSversionValid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dpt_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ospl
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_CONTROL_ACTIVE
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|dpt_inbuf
index|[
name|minor_no
operator|&
operator|~
name|SCSI_CONTROL_MASK
index|]
operator|=
name|geteblk
argument_list|(
name|PAGE_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: Failed to obtain an I/O buffer\n"
argument_list|,
name|minor_no
operator|&
operator|~
name|SCSI_CONTROL_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_CONTROL_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dpt_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|dpt
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
block|{
name|brelse
argument_list|(
name|dpt_inbuf
index|[
name|minor_no
operator|&
operator|~
name|SCSI_CONTROL_MASK
index|]
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_HA_CONTROL_ACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dpt_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor_no
operator|&
name|SCSI_CONTROL_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d:  I/O attempted to control channel (%x)\n"
argument_list|,
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
argument_list|,
name|minor_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|unit
operator|=
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|DPT_RW_CMD_LEN
condition|)
block|{
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|length
decl_stmt|;
name|cp
operator|=
name|dpt_inbuf
index|[
name|minor_no
index|]
operator|->
name|b_data
expr_stmt|;
name|length
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* uiomove will change it! */
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: uiomove(%x, %d, %x) failed (%d)\n"
argument_list|,
name|minor_no
argument_list|,
name|cp
argument_list|,
name|length
argument_list|,
name|uio
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|cp
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* A real kludge, to allow plain echo(1) to work */
if|if
condition|(
name|cp
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|cp
index|[
name|length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|dpt_rw_command
index|[
name|unit
index|]
argument_list|,
name|cp
argument_list|,
name|DPT_RW_CMD_LEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
comment|/** 			 * For lack of anything better to do; 			 * For now, dump the data so we can look at it and rejoice 			 */
name|printf
argument_list|(
literal|"dpt%d: Command \"%s\" arrived\n"
argument_list|,
name|unit
argument_list|,
name|dpt_rw_command
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dpt_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|minor_no
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: read, count = %d, dev = %08x\n"
argument_list|,
name|minor_no
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|minor_no
operator|&
name|SCSI_CONTROL_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d:  I/O attempted to control channel (%x)\n"
argument_list|,
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
argument_list|,
name|minor_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * else if ( uio->uio_resid> PAGE_SIZE ) { return(E2BIG); } 	 */
else|else
block|{
name|char
modifier|*
name|work_buffer
decl_stmt|;
name|char
modifier|*
name|wbp
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|work_size
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|work_buffer
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|wbp
operator|=
name|work_buffer
expr_stmt|;
name|work_size
operator|=
literal|0
expr_stmt|;
name|ospl
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|command
operator|=
name|dpt_rw_command
index|[
name|dpt
operator|->
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_DUMP_SOFTC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%s:%s:%s:%s:%x\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|vendor
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|modelNum
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|firmware
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|protocol
argument_list|,
name|dpt
operator|->
name|EATA_revision
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_DUMP_SYSINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d:%d:%d:%d:%d:%s:"
literal|"%d:%d:%d:%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt_sysinfo
operator|.
name|drive0CMOS
argument_list|,
name|dpt_sysinfo
operator|.
name|drive1CMOS
argument_list|,
name|dpt_sysinfo
operator|.
name|numDrives
argument_list|,
name|dpt_sysinfo
operator|.
name|processorFamily
argument_list|,
name|dpt_sysinfo
operator|.
name|processorType
argument_list|,
name|dpt_sysinfo
operator|.
name|smartROMMajorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|smartROMMinorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|smartROMRevision
argument_list|,
name|i2bin
argument_list|(
name|dpt_sysinfo
operator|.
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|queue_status
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|dpt_sysinfo
operator|.
name|conventionalMemSize
argument_list|,
name|dpt_sysinfo
operator|.
name|extendedMemSize
argument_list|,
name|dpt_sysinfo
operator|.
name|osType
argument_list|,
name|dpt_sysinfo
operator|.
name|osMajorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|osMinorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|osRevision
argument_list|,
name|dpt_sysinfo
operator|.
name|osSubRevision
argument_list|,
name|dpt_sysinfo
operator|.
name|busType
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|16
condition|;
name|ndx
operator|++
control|)
block|{
if|if
condition|(
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|cylinders
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:d%dc%dh%ds%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ndx
argument_list|,
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|cylinders
argument_list|,
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|heads
argument_list|,
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|sectors
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_DUMP_METRICS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d: No metrics available.\n"
literal|"Run the dpt_dm command, or use the\n"
literal|"DPT_IOCTL_INTERNAL_METRICS ioctl system call\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_CLEAR_METRICS
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|dpt_reset_performance
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d: Metrics have been cleared\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_SHOW_LED
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%s\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|i2bin
argument_list|(
name|dpt_blinking_led
argument_list|(
name|dpt
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: Bad READ state (%s)\n"
argument_list|,
name|minor_no
argument_list|,
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|work_buffer
index|[
name|work_size
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|work_buffer
argument_list|,
name|work_size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: READ uimove failed (%d)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * This is the control syscall interface.  * It should be binary compatible with UnixWare,  * if not totally syntatically so.  */
end_comment

begin_function
specifier|static
name|int
name|dpt_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|cmdarg
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|dpt_user_softc_t
name|udpt
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|eata_pt_t
modifier|*
name|eata_pass_thru
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|minor_no
operator|&
name|SCSI_CONTROL_MASK
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d:  Control attempted to I/O channel (%x)\n"
argument_list|,
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
argument_list|,
name|minor_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
name|minor_no
operator|&=
operator|~
name|SCSI_CONTROL_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: IOCTL(%x, %x, %p, %x, %p)\n"
argument_list|,
name|minor_no
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|cmdarg
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|result
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
case|case
name|DPT_IOCTL_INTERNAL_METRICS
case|:
name|memcpy
argument_list|(
name|cmdarg
argument_list|,
operator|&
name|dpt
operator|->
name|performance
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|performance
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
case|case
name|DPT_IOCTL_SOFTC
case|:
name|udpt
operator|.
name|unit
operator|=
name|dpt
operator|->
name|unit
expr_stmt|;
name|udpt
operator|.
name|handle_interrupts
operator|=
name|dpt
operator|->
name|handle_interrupts
expr_stmt|;
name|udpt
operator|.
name|target_mode_enabled
operator|=
name|dpt
operator|->
name|target_mode_enabled
expr_stmt|;
name|udpt
operator|.
name|spare
operator|=
name|dpt
operator|->
name|spare
expr_stmt|;
name|udpt
operator|.
name|total_ccbs_count
operator|=
name|dpt
operator|->
name|total_ccbs_count
expr_stmt|;
name|udpt
operator|.
name|free_ccbs_count
operator|=
name|dpt
operator|->
name|free_ccbs_count
expr_stmt|;
name|udpt
operator|.
name|waiting_ccbs_count
operator|=
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
name|udpt
operator|.
name|submitted_ccbs_count
operator|=
name|dpt
operator|->
name|submitted_ccbs_count
expr_stmt|;
name|udpt
operator|.
name|completed_ccbs_count
operator|=
name|dpt
operator|->
name|completed_ccbs_count
expr_stmt|;
name|udpt
operator|.
name|queue_status
operator|=
name|dpt
operator|->
name|queue_status
expr_stmt|;
name|udpt
operator|.
name|free_lock
operator|=
name|dpt
operator|->
name|free_lock
expr_stmt|;
name|udpt
operator|.
name|waiting_lock
operator|=
name|dpt
operator|->
name|waiting_lock
expr_stmt|;
name|udpt
operator|.
name|submitted_lock
operator|=
name|dpt
operator|->
name|submitted_lock
expr_stmt|;
name|udpt
operator|.
name|completed_lock
operator|=
name|dpt
operator|->
name|completed_lock
expr_stmt|;
name|udpt
operator|.
name|commands_processed
operator|=
name|dpt
operator|->
name|commands_processed
expr_stmt|;
name|udpt
operator|.
name|lost_interrupts
operator|=
name|dpt
operator|->
name|lost_interrupts
expr_stmt|;
name|udpt
operator|.
name|channels
operator|=
name|dpt
operator|->
name|channels
expr_stmt|;
name|udpt
operator|.
name|max_id
operator|=
name|dpt
operator|->
name|max_id
expr_stmt|;
name|udpt
operator|.
name|max_lun
operator|=
name|dpt
operator|->
name|max_lun
expr_stmt|;
name|udpt
operator|.
name|io_base
operator|=
name|dpt
operator|->
name|io_base
expr_stmt|;
name|udpt
operator|.
name|v_membase
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|dpt
operator|->
name|v_membase
expr_stmt|;
name|udpt
operator|.
name|p_membase
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|dpt
operator|->
name|p_membase
expr_stmt|;
name|udpt
operator|.
name|irq
operator|=
name|dpt
operator|->
name|irq
expr_stmt|;
name|udpt
operator|.
name|dma_channel
operator|=
name|dpt
operator|->
name|dma_channel
expr_stmt|;
name|udpt
operator|.
name|board_data
operator|=
name|dpt
operator|->
name|board_data
expr_stmt|;
name|udpt
operator|.
name|EATA_revision
operator|=
name|dpt
operator|->
name|EATA_revision
expr_stmt|;
name|udpt
operator|.
name|bustype
operator|=
name|dpt
operator|->
name|bustype
expr_stmt|;
name|udpt
operator|.
name|state
operator|=
name|dpt
operator|->
name|state
expr_stmt|;
name|udpt
operator|.
name|primary
operator|=
name|dpt
operator|->
name|primary
expr_stmt|;
name|udpt
operator|.
name|more_support
operator|=
name|dpt
operator|->
name|more_support
expr_stmt|;
name|udpt
operator|.
name|immediate_support
operator|=
name|dpt
operator|->
name|immediate_support
expr_stmt|;
name|udpt
operator|.
name|broken_INQUIRY
operator|=
name|dpt
operator|->
name|broken_INQUIRY
expr_stmt|;
name|udpt
operator|.
name|spare2
operator|=
name|dpt
operator|->
name|spare2
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|MAX_CHANNELS
condition|;
name|ndx
operator|++
control|)
block|{
name|udpt
operator|.
name|resetlevel
index|[
name|ndx
index|]
operator|=
name|dpt
operator|->
name|resetlevel
index|[
name|ndx
index|]
expr_stmt|;
name|udpt
operator|.
name|hostid
index|[
name|ndx
index|]
operator|=
name|dpt
operator|->
name|hostid
index|[
name|ndx
index|]
expr_stmt|;
block|}
name|udpt
operator|.
name|last_ccb
operator|=
name|dpt
operator|->
name|last_ccb
expr_stmt|;
name|udpt
operator|.
name|cplen
operator|=
name|dpt
operator|->
name|cplen
expr_stmt|;
name|udpt
operator|.
name|cppadlen
operator|=
name|dpt
operator|->
name|cppadlen
expr_stmt|;
name|udpt
operator|.
name|queuesize
operator|=
name|dpt
operator|->
name|queuesize
expr_stmt|;
name|udpt
operator|.
name|sgsize
operator|=
name|dpt
operator|->
name|sgsize
expr_stmt|;
name|udpt
operator|.
name|cache_type
operator|=
name|dpt
operator|->
name|cache_type
expr_stmt|;
name|udpt
operator|.
name|cache_size
operator|=
name|dpt
operator|->
name|cache_size
expr_stmt|;
name|memcpy
argument_list|(
name|cmdarg
argument_list|,
operator|&
name|udpt
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_user_softc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SDI_SEND
case|:
case|case
name|DPT_IOCTL_SEND
case|:
name|eata_pass_thru
operator|=
operator|(
name|eata_pt_t
operator|*
operator|)
name|cmdarg
expr_stmt|;
if|if
condition|(
operator|(
name|eata_pass_thru
operator|->
name|eataID
index|[
literal|0
index|]
operator|!=
literal|'E'
operator|)
operator|||
operator|(
name|eata_pass_thru
operator|->
name|eataID
index|[
literal|1
index|]
operator|!=
literal|'A'
operator|)
operator|||
operator|(
name|eata_pass_thru
operator|->
name|eataID
index|[
literal|2
index|]
operator|!=
literal|'T'
operator|)
operator|||
operator|(
name|eata_pass_thru
operator|->
name|eataID
index|[
literal|3
index|]
operator|!=
literal|'A'
operator|)
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
switch|switch
condition|(
name|eata_pass_thru
operator|->
name|command
condition|)
block|{
case|case
name|DPT_SIGNATURE
case|:
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_sig
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
name|eata_pass_thru
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|DPT_NUMCTRLS
case|:
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_controllers_present
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
name|eata_pass_thru
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_controllers_present
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|DPT_CTRLINFO
case|:
block|{
name|dpt_compat_ha_t
name|compat_softc
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|compat_softc
operator|.
name|ha_state
operator|=
name|dpt
operator|->
name|state
expr_stmt|;
comment|/* Different Meaning! */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|MAX_CHANNELS
condition|;
name|ndx
operator|++
control|)
name|compat_softc
operator|.
name|ha_id
index|[
name|ndx
index|]
operator|=
name|dpt
operator|->
name|hostid
index|[
name|ndx
index|]
expr_stmt|;
name|compat_softc
operator|.
name|ha_vect
operator|=
name|dpt
operator|->
name|irq
expr_stmt|;
name|compat_softc
operator|.
name|ha_base
operator|=
name|BaseRegister
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|compat_softc
operator|.
name|ha_max_jobs
operator|=
name|dpt
operator|->
name|total_ccbs_count
expr_stmt|;
name|compat_softc
operator|.
name|ha_cache
operator|=
name|dpt
operator|->
name|cache_type
expr_stmt|;
name|compat_softc
operator|.
name|ha_cachesize
operator|=
name|dpt
operator|->
name|cache_size
expr_stmt|;
name|compat_softc
operator|.
name|ha_nbus
operator|=
name|dpt
operator|->
name|dma_channel
operator|+
literal|1
expr_stmt|;
name|compat_softc
operator|.
name|ha_ntargets
operator|=
name|dpt
operator|->
name|max_id
operator|+
literal|1
expr_stmt|;
name|compat_softc
operator|.
name|ha_nluns
operator|=
name|dpt
operator|->
name|max_lun
operator|+
literal|1
expr_stmt|;
name|compat_softc
operator|.
name|ha_tshift
operator|=
operator|(
name|dpt
operator|->
name|max_id
operator|==
literal|7
operator|)
condition|?
literal|3
else|:
literal|4
expr_stmt|;
name|compat_softc
operator|.
name|ha_bshift
operator|=
literal|2
expr_stmt|;
name|compat_softc
operator|.
name|ha_npend
operator|=
name|dpt
operator|->
name|submitted_ccbs_count
expr_stmt|;
name|compat_softc
operator|.
name|ha_active_jobs
operator|=
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
name|strncpy
argument_list|(
name|compat_softc
operator|.
name|ha_fw_version
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|firmware
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|compat_softc
operator|.
name|ha_ccb
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_cblist
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_dev
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_StPkt_lock
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_ccb_lock
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_LuQWaiting
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_QWait_lock
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_QWait_opri
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|compat_softc
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
name|eata_pass_thru
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_compat_ha_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
break|break;
case|case
name|DPT_SYSINFO
case|:
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_sysinfo
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
name|eata_pass_thru
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sysinfo
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|EATAUSRCMD
case|:
name|result
operator|=
name|dpt_user_cmd
argument_list|(
name|dpt
argument_list|,
name|eata_pass_thru
argument_list|,
name|cmdarg
argument_list|,
name|minor_no
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
case|case
name|DPT_BLINKLED
case|:
name|result
operator|=
name|dpt_blinking_led
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|result
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
name|eata_pass_thru
operator|->
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"dpt%d: Invalid (%x) pass-throu command\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|eata_pass_thru
operator|->
name|command
argument_list|)
expr_stmt|;
name|result
operator|=
name|EINVAL
expr_stmt|;
block|}
default|default:
name|printf
argument_list|(
literal|"dpt%d: Invalid (%lx) IOCTL\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|dpt_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|dpt_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|dpt_devsw_installed
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"DPT:  RAID Manager driver, Version %d.%d.%d\n"
argument_list|,
name|DPT_CTL_RELEASE
argument_list|,
name|DPT_CTL_VERSION
argument_list|,
name|DPT_CTL_PATCH
argument_list|)
expr_stmt|;
comment|/* Add the I/O (data) channel */
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|dpt_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Add the Control (IOCTL) channel */
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|SCSI_CONTROL_MASK
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|dpt_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dpt_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
name|dpt_get_sysinfo
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|dpt_dev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE + CDEV_MAJOR
argument_list|,
argument|dpt_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/* End of the dpt_control driver */
end_comment

end_unit

