begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *       Copyright (c) 1997 by Simon Shapiro  *       All Rights Reserved  *  * This is a proprietary, unpublished source code.  No publishing, copying,  * distribution or use permission is granted to anyone.  *  * If you want to use this product in any way, please contact the author by  * sending email to shimon@i-connect.net  *  */
end_comment

begin_comment
comment|/*  * dpt_control.c: Control Functions and /dev entry points for /dev/dpt  *  * Caveat Emptor!	This is work in progress.	The interfaces and  * functionality of this code will change (possibly radically) in the  * future.  */
end_comment

begin_empty
empty|#ident "$Id: dpt_control.c,v 1.5 1997/08/27 02:24:54 ShimonR Exp $"
end_empty

begin_include
include|#
directive|include
file|"opt_dpt.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/speaker.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_decl_stmt
name|void
modifier|*
name|devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/dpt/dpt.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_define
define|#
directive|define
name|INLINE
value|__inline
end_define

begin_decl_stmt
name|dpt_sysinfo_t
name|dpt_sysinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry points and other prototypes */
end_comment

begin_function_decl
specifier|static
name|vm_offset_t
name|dpt_physmap
parameter_list|(
name|u_int32_t
name|paddr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_unphysmap
parameter_list|(
name|u_int8_t
modifier|*
name|vaddr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dpt_get_sysinfo
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|dpt_softc_t
modifier|*
name|dpt_minor2softc
parameter_list|(
name|int
name|minor_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|INLINE
name|int
name|dpt_minor2unit
parameter_list|(
name|int
name|minor_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dpt_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|cmdarg
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|dpt_sig_t
name|dpt_sig
init|=
block|{
literal|'d'
block|,
literal|'P'
block|,
literal|'t'
block|,
literal|'S'
block|,
literal|'i'
block|,
literal|'G'
block|,
name|SIG_VERSION
block|,
name|PROC_INTEL
block|,
name|PROC_PENTIUM
operator||
name|PROC_P6
block|,
name|FT_HBADRVR
block|,
literal|0
block|,
name|OEM_DPT
block|,
name|OS_FREEBSD
block|,
name|CAP_PASS
operator||
name|CAP_OVERLAP
block|,
name|DEV_ALL
block|,
name|ADF_ALL_MASTER
block|,
literal|0
block|,
literal|0
block|,
name|DPT_RELEASE
block|,
name|DPT_VERSION
block|,
name|DPT_PATCH
block|,
name|DPT_MONTH
block|,
name|DPT_DAY
block|,
name|DPT_YEAR
block|,
literal|"DPT FreeBSD Driver (c) 1997 Simon Shapiro"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|130
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|dpt_cdevsw
init|=
block|{
name|dpt_open
block|,
name|dpt_close
block|,
name|dpt_read
block|,
name|dpt_write
block|,
name|dpt_ioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"dpt"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
modifier|*
name|dpt_inbuf
index|[
name|DPT_MAX_ADAPTERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dpt_rw_command
index|[
name|DPT_MAX_ADAPTERS
index|]
index|[
name|DPT_RW_CMD_LEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map a physical address to virtual one.  * This is a first vut, experimental thing  *  * Paddr is the physical address to map  * size is the size of the region, in bytes.  * Because of alignment problems, we actually round up thesize requested to  * the next page count.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|dpt_physmap
parameter_list|(
name|u_int32_t
name|req_paddr
parameter_list|,
name|vm_size_t
name|req_size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|u_int32_t
name|paddr
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|size
operator|=
operator|(
name|req_size
operator|/
name|PAGE_SIZE
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|paddr
operator|=
name|req_paddr
operator|&
literal|0xfffff000
expr_stmt|;
name|offset
operator|=
name|req_paddr
operator|-
name|paddr
expr_stmt|;
name|va
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
operator|(
name|vm_offset_t
operator|)
literal|0
condition|)
return|return
operator|(
name|va
operator|)
return|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|size
condition|;
name|ndx
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pmap_kenter
argument_list|(
name|va
operator|+
name|ndx
argument_list|,
name|paddr
operator|+
name|ndx
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|va
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Release virtual space allocated by physmap  * We ASSUME that the correct srart address and the correct LENGTH  * are given.  *  * Disaster will follow if these assumptions are false!  */
end_comment

begin_function
specifier|static
name|void
name|dpt_unphysmap
parameter_list|(
name|u_int8_t
modifier|*
name|vaddr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|size
condition|;
name|ndx
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pmap_kremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vaddr
operator|+
name|ndx
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a minor device number, get its SCSI Unit.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|dpt_minor2unit
parameter_list|(
name|int
name|minor
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|minor2hba
argument_list|(
name|minor
argument_list|)
expr_stmt|;
return|return
operator|(
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a minor device number,  * return the pointer to it's softc structure  */
end_comment

begin_function
specifier|static
name|INLINE
name|dpt_softc_t
modifier|*
name|dpt_minor2softc
parameter_list|(
name|int
name|minor_no
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
if|if
condition|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|dpt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|dpt_softc_list
argument_list|)
init|;
operator|(
name|dpt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dpt
operator|->
name|unit
operator|!=
name|minor_no
operator|)
condition|;
name|dpt
operator|=
name|TAILQ_NEXT
argument_list|(
name|dpt
argument_list|,
name|links
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|dpt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect interesting system information  * The following is one of the worst hacks I have ever allowed my   * name to be associated with.  * There MUST be a system structure that provides this data.  */
end_comment

begin_function
specifier|static
name|void
name|dpt_get_sysinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dpt_sysinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sysinfo_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * This is really silly, but we better run this in splhigh as we      * have no clue what we bump into.      * Let's hope anyone else who does this sort of things protects them      * with splhigh too.      */
name|ospl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* Get The First Drive Type From CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|i
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|dpt_sysinfo
operator|.
name|drive0CMOS
operator|=
name|j
expr_stmt|;
comment|/* Get The Second Drive Type From CMOS */
name|j
operator|=
name|i
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|dpt_sysinfo
operator|.
name|drive1CMOS
operator|=
name|j
expr_stmt|;
comment|/* Get The Number Of Drives From The Bios Data Area */
if|if
condition|(
operator|(
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0x0475
argument_list|,
literal|1024
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"DPT:  Cannot map BIOS address 0x0475.  No sysinfo... :-(\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dpt_sysinfo
operator|.
name|numDrives
operator|=
operator|*
name|addr
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* Get the processor fields from the SIG structure, and set the flags */
name|dpt_sysinfo
operator|.
name|processorFamily
operator|=
name|dpt_sig
operator|.
name|ProcessorFamily
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator|=
name|SI_CMOS_Valid
operator||
name|SI_NumDrivesValid
expr_stmt|;
comment|/* Go out and look for SmartROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0xC8000
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0xD8000
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
default|default:
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0xDC000
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|addr
operator|)
operator|==
literal|0xaa55
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|addr
operator|+
literal|6
operator|)
operator|)
operator|==
literal|0x00202053
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|addr
operator|+
literal|10
operator|)
operator|)
operator|==
literal|0x00545044
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*      * If i< 3, we found it so set up a pointer to the starting      * version diget by searching for it.      */
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|+=
literal|0x15
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|addr
index|[
name|i
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|addr
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'v'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
block|{
name|addr
operator|+=
operator|(
name|i
operator|+
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If all is well, set up the SmartROM version fields */
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|dpt_sysinfo
operator|.
name|smartROMMajorVersion
operator|=
operator|*
name|addr
operator|-
literal|'0'
expr_stmt|;
name|dpt_sysinfo
operator|.
name|smartROMMinorVersion
operator|=
operator|*
operator|(
name|addr
operator|+
literal|2
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|smartROMRevision
operator|=
operator|*
operator|(
name|addr
operator|+
literal|3
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_SmartROMverValid
expr_stmt|;
block|}
else|else
block|{
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_NO_SmartROM
expr_stmt|;
block|}
comment|/* Get the conventional memory size from CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x15
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|conventionalMemSize
operator|=
name|j
expr_stmt|;
comment|/*      * Get the extended memory found at power on from CMOS      */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|extendedMemSize
operator|=
name|j
expr_stmt|;
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_MemorySizeValid
expr_stmt|;
comment|/* If there is 1 or 2 drives found, set up the drive parameters */
if|if
condition|(
name|dpt_sysinfo
operator|.
name|numDrives
operator|>
literal|0
condition|)
block|{
comment|/* Get the pointer from int 41 for the first drive parameters */
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0x0104
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|j
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
name|j
operator|*=
literal|16
expr_stmt|;
name|j
operator|+=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|)
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
name|j
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|cylinders
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|heads
operator|=
operator|*
operator|(
name|addr
operator|+
literal|2
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|sectors
operator|=
operator|*
operator|(
name|addr
operator|+
literal|14
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dpt_sysinfo
operator|.
name|numDrives
operator|>
literal|1
condition|)
block|{
comment|/* Get the pointer from Int 46 for the second drive parameters */
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
literal|0x01118
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|j
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
name|j
operator|*=
literal|16
expr_stmt|;
name|j
operator|+=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|addr
operator|)
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|dpt_physmap
argument_list|(
name|j
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|cylinders
operator|=
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
name|addr
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|heads
operator|=
operator|*
operator|(
name|addr
operator|+
literal|2
operator|)
expr_stmt|;
name|dpt_sysinfo
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|sectors
operator|=
operator|*
operator|(
name|addr
operator|+
literal|14
operator|)
expr_stmt|;
name|dpt_unphysmap
argument_list|(
name|addr
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_DriveParamsValid
expr_stmt|;
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
comment|/* Get the processor information */
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_ProcessorValid
expr_stmt|;
switch|switch
condition|(
name|cpu_class
condition|)
block|{
case|case
name|CPUCLASS_386
case|:
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_386
expr_stmt|;
break|break;
case|case
name|CPUCLASS_486
case|:
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_486
expr_stmt|;
break|break;
case|case
name|CPUCLASS_586
case|:
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_PENTIUM
expr_stmt|;
break|break;
case|case
name|CPUCLASS_686
case|:
name|dpt_sysinfo
operator|.
name|processorType
operator|=
name|PROC_P6
expr_stmt|;
break|break;
default|default :
name|dpt_sysinfo
operator|.
name|flags
operator|&=
operator|~
name|SI_ProcessorValid
expr_stmt|;
break|break;
block|}
comment|/* Get the bus I/O bus information */
name|dpt_sysinfo
operator|.
name|flags
operator||=
name|SI_BusTypeValid
expr_stmt|;
name|dpt_sysinfo
operator|.
name|busType
operator|=
name|SI_PCI_BUS
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dpt_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ospl
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|dpt
operator|->
name|state
operator|&
name|DPT_HA_CONTROL_ACTIVE
condition|)
block|{
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
name|dpt
operator|->
name|state
operator||=
name|DPT_HA_CONTROL_ACTIVE
expr_stmt|;
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|dpt_inbuf
index|[
name|minor_no
index|]
operator|=
name|geteblk
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dpt_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|dpt
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
block|{
name|brelse
argument_list|(
name|dpt_inbuf
index|[
name|minor_no
index|]
argument_list|)
expr_stmt|;
name|dpt
operator|->
name|state
operator|&=
operator|~
name|DPT_HA_CONTROL_ACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|dpt_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|DPT_RW_CMD_LEN
condition|)
block|{
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|length
decl_stmt|;
name|cp
operator|=
name|dpt_inbuf
index|[
name|minor_no
index|]
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|length
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* uiomove will change it! */
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|cp
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|dpt_rw_command
index|[
name|unit
index|]
argument_list|,
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: WRITE uimove failed (%d)\n"
argument_list|,
name|minor_no
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * For lack of anything better to do; 	     * For now, dump the data so we can look at it and rejoice 	     */
name|printf
argument_list|(
literal|"dpt%d: Command \"%s\" arrived\n"
argument_list|,
name|unit
argument_list|,
name|dpt_rw_command
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dpt_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|minor_no
decl_stmt|;
name|int
name|ospl
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: read, count = %d, dev = %08x\n"
argument_list|,
name|minor_no
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dpt_minor2unit
argument_list|(
name|minor_no
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* DEV_BSIZE = 512 */
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|work_buffer
decl_stmt|;
name|char
modifier|*
name|wbp
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|work_size
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|work_buffer
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|wbp
operator|=
name|work_buffer
expr_stmt|;
name|work_size
operator|=
literal|0
expr_stmt|;
name|ospl
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|command
operator|=
name|dpt_rw_command
index|[
name|dpt
operator|->
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_DUMP_SOFTC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%s:%d:%d:%d:%d:%d:%s:%s:%s:%s:%s:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|handle_interrupts
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|dpt
operator|->
name|total_ccbs_count
argument_list|,
name|dpt
operator|->
name|free_ccbs_count
argument_list|,
name|dpt
operator|->
name|waiting_ccbs_count
argument_list|,
name|dpt
operator|->
name|submitted_ccbs_count
argument_list|,
name|dpt
operator|->
name|completed_ccbs_count
argument_list|,
name|i2bin
argument_list|(
name|dpt
operator|->
name|queue_status
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|queue_status
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|i2bin
argument_list|(
name|dpt
operator|->
name|free_lock
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|free_lock
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|i2bin
argument_list|(
name|dpt
operator|->
name|waiting_lock
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|waiting_lock
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|i2bin
argument_list|(
name|dpt
operator|->
name|submitted_lock
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|submitted_lock
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|i2bin
argument_list|(
name|dpt
operator|->
name|completed_lock
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|completed_lock
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|dpt
operator|->
name|commands_processed
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
comment|/* Interrupt related measurements */
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|spurious_interrupts
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_intr_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_intr_time
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
comment|/* SCSI Commands, can be no more than 256 of them */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|256
condition|;
name|ndx
operator|++
control|)
block|{
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ndx
index|]
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%s:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ndx
argument_list|,
name|scsi_cmd_name
argument_list|(
operator|(
name|u_int8_t
operator|)
name|ndx
argument_list|)
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_command_time
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_command_time
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
block|}
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
comment|/* READ/WRITE statistics, per block size */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|10
condition|;
name|ndx
operator|++
control|)
block|{
name|char
modifier|*
name|mask
decl_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_count
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_min_time
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_max_time
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|10
condition|;
name|ndx
operator|++
control|)
block|{
name|char
modifier|*
name|mask
decl_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_count
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_min_time
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_max_time
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d:%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_count
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_waiting_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_submit_count
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_submit_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_submit_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_complete_count
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_complete_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_complete_time
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|command_collisions
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|command_too_busy
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_eata_tries
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%x:%x:%x:%d:%d:%p:%p:%p\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|max_id
argument_list|,
name|dpt
operator|->
name|max_lun
argument_list|,
name|dpt
operator|->
name|io_base
argument_list|,
name|dpt
operator|->
name|v_membase
argument_list|,
name|dpt
operator|->
name|p_membase
argument_list|,
name|dpt
operator|->
name|irq
argument_list|,
name|dpt
operator|->
name|dma_channel
argument_list|,
name|dpt
operator|->
name|sc_scsi_link
index|[
literal|0
index|]
argument_list|,
name|dpt
operator|->
name|sc_scsi_link
index|[
literal|1
index|]
argument_list|,
name|dpt
operator|->
name|sc_scsi_link
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%x:%x:%s:%s:%s:%s:%x\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|deviceType
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|rm_dtq
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|vendor
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|modelNum
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|firmware
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|protocol
argument_list|,
name|dpt
operator|->
name|EATA_revision
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%x:%d:%s:%s:%s:%s:%s\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|bustype
argument_list|,
name|dpt
operator|->
name|channels
argument_list|,
name|i2bin
argument_list|(
operator|(
name|u_int32_t
operator|)
name|dpt
operator|->
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|state
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|dpt
operator|->
name|primary
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|dpt
operator|->
name|more_support
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|dpt
operator|->
name|immediate_support
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
name|dpt
operator|->
name|broken_INQUIRY
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|resetlevel
index|[
literal|0
index|]
argument_list|,
name|dpt
operator|->
name|resetlevel
index|[
literal|1
index|]
argument_list|,
name|dpt
operator|->
name|resetlevel
index|[
literal|2
index|]
argument_list|,
name|dpt
operator|->
name|cplen
argument_list|,
name|dpt
operator|->
name|cppadlen
argument_list|,
name|dpt
operator|->
name|queuesize
argument_list|,
name|dpt
operator|->
name|sgsize
argument_list|,
name|dpt
operator|->
name|hostid
index|[
literal|0
index|]
argument_list|,
name|dpt
operator|->
name|hostid
index|[
literal|1
index|]
argument_list|,
name|dpt
operator|->
name|hostid
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%s CACHE:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
operator|(
name|dpt
operator|->
name|cache_type
operator|==
name|DPT_NO_CACHE
operator|)
condition|?
literal|"No"
else|:
operator|(
name|dpt
operator|->
name|cache_type
operator|==
name|DPT_CACHE_WRITETHROUGH
operator|)
condition|?
literal|"Write-Through"
else|:
literal|"Write-Back"
argument_list|,
name|dpt
operator|->
name|cache_size
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_DUMP_SYSINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d:%d:%d:%d:%d:%s:"
literal|"%d:%d:%d:%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt_sysinfo
operator|.
name|drive0CMOS
argument_list|,
name|dpt_sysinfo
operator|.
name|drive1CMOS
argument_list|,
name|dpt_sysinfo
operator|.
name|numDrives
argument_list|,
name|dpt_sysinfo
operator|.
name|processorFamily
argument_list|,
name|dpt_sysinfo
operator|.
name|processorType
argument_list|,
name|dpt_sysinfo
operator|.
name|smartROMMajorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|smartROMMinorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|smartROMRevision
argument_list|,
name|i2bin
argument_list|(
name|dpt_sysinfo
operator|.
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|queue_status
argument_list|)
operator|*
literal|8
argument_list|)
argument_list|,
name|dpt_sysinfo
operator|.
name|conventionalMemSize
argument_list|,
name|dpt_sysinfo
operator|.
name|extendedMemSize
argument_list|,
name|dpt_sysinfo
operator|.
name|osType
argument_list|,
name|dpt_sysinfo
operator|.
name|osMajorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|osMinorVersion
argument_list|,
name|dpt_sysinfo
operator|.
name|osRevision
argument_list|,
name|dpt_sysinfo
operator|.
name|osSubRevision
argument_list|,
name|dpt_sysinfo
operator|.
name|busType
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|16
condition|;
name|ndx
operator|++
control|)
block|{
if|if
condition|(
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|cylinders
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:d%dc%dh%ds%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ndx
argument_list|,
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|cylinders
argument_list|,
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|heads
argument_list|,
name|dpt_sysinfo
operator|.
name|drives
index|[
name|ndx
index|]
operator|.
name|sectors
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_DUMP_METRICS
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
comment|/* Interrupt related measurements */
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|aborted_interrupts
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|spurious_interrupts
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_intr_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_intr_time
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
comment|/* SCSI Commands, can be no more than 256 of them */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|256
condition|;
name|ndx
operator|++
control|)
block|{
if|if
condition|(
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ndx
index|]
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%s:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|ndx
argument_list|,
name|scsi_cmd_name
argument_list|(
operator|(
name|u_int8_t
operator|)
name|ndx
argument_list|)
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|command_count
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_command_time
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_command_time
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
block|}
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
comment|/* READ/WRITE statistics, per block size */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|10
condition|;
name|ndx
operator|++
control|)
block|{
name|char
modifier|*
name|mask
decl_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_count
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_min_time
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|read_by_size_max_time
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|10
condition|;
name|ndx
operator|++
control|)
block|{
name|char
modifier|*
name|mask
decl_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%dd\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_count
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_min_time
index|[
name|ndx
index|]
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|write_by_size_max_time
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d:%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_count
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_waiting_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_waiting_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_submit_count
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_submit_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_submit_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_complete_count
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_complete_time
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_complete_time
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%d:%d:%d:%d\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|command_collisions
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|command_too_busy
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|max_eata_tries
argument_list|,
name|dpt
operator|->
name|performance
operator|.
name|min_eata_tries
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
else|#
directive|else
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"No metrics available.\n"
literal|"You must compile the driver with the "
literal|"DPT_MEASURE_PERFORMANCE"
literal|"option enabled\n"
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_CLEAR_METRICS
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|bzero
argument_list|(
operator|&
name|dpt
operator|->
name|performance
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|performance
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d: Metrics have been cleared\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
name|DPT_RW_CMD_SHOW_LED
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|bzero
argument_list|(
operator|&
name|dpt
operator|->
name|performance
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt
operator|->
name|performance
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
name|x
operator|=
name|sprintf
argument_list|(
name|wbp
argument_list|,
literal|"dpt%d:%s\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|i2bin
argument_list|(
name|dpt_blinking_led
argument_list|(
name|dpt
argument_list|)
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|work_size
operator|+=
name|x
expr_stmt|;
name|wbp
operator|+=
name|x
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: Bad READ state (%s)\n"
argument_list|,
name|minor_no
argument_list|,
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|work_buffer
index|[
name|work_size
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|work_buffer
argument_list|,
name|work_size
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"dpt%d: READ uimove failed (%d)\n"
argument_list|,
name|dpt
operator|->
name|unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|splx
argument_list|(
name|ospl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the control syscall interface.  * It should be binary compatible with UnixWare, if not totally syntatically so.  */
end_comment

begin_function
name|int
name|dpt_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|cmdarg
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|minor_no
decl_stmt|;
name|dpt_softc_t
modifier|*
name|dpt
decl_stmt|;
name|int
name|result
decl_stmt|;
name|eata_pt_t
name|eata_pass_thru
decl_stmt|;
name|minor_no
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DPT_DEBUG_CONTROL
name|printf
argument_list|(
literal|"dpt%d: ioctl cmd = %x\n"
argument_list|,
name|minor_no
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|(
name|dpt
operator|=
name|dpt_minor2softc
argument_list|(
name|minor_no
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DPT_IOCTL_INTERNAL_METRICS
case|:
ifdef|#
directive|ifdef
name|DPT_MEASURE_PERFORMANCE
name|result
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt
operator|->
name|performance
argument_list|,
operator|(
name|dpt_softc_t
operator|*
operator|)
operator|(
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|cmdarg
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_perf_t
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|ENXIO
expr_stmt|;
endif|#
directive|endif
comment|/* DPT_MEASURE_PERFORMANCE */
break|break;
case|case
name|DPT_IOCTL_SOFTC
case|:
name|result
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt
argument_list|,
operator|(
name|dpt_softc_t
operator|*
operator|)
operator|(
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|cmdarg
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_softc_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DPT_IOCTL_SEND
case|:
if|if
condition|(
operator|(
name|result
operator|=
name|copyin
argument_list|(
name|cmdarg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eata_pass_thru
argument_list|,
sizeof|sizeof
argument_list|(
name|eata_pt_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|eata_pass_thru
operator|.
name|eataID
index|[
literal|0
index|]
operator|!=
literal|'E'
operator|)
operator|||
operator|(
name|eata_pass_thru
operator|.
name|eataID
index|[
literal|1
index|]
operator|!=
literal|'A'
operator|)
operator|||
operator|(
name|eata_pass_thru
operator|.
name|eataID
index|[
literal|2
index|]
operator|!=
literal|'T'
operator|)
operator|||
operator|(
name|eata_pass_thru
operator|.
name|eataID
index|[
literal|3
index|]
operator|!=
literal|'A'
operator|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|eata_pass_thru
operator|.
name|command
condition|)
block|{
case|case
name|DPT_SIGNATURE
case|:
if|if
condition|(
operator|(
name|result
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_sig
argument_list|,
name|eata_pass_thru
operator|.
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
break|break;
case|case
name|DPT_NUMCTRLS
case|:
if|if
condition|(
operator|(
name|result
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_controllers_present
argument_list|,
name|eata_pass_thru
operator|.
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_controllers_present
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
break|break;
case|case
name|DPT_CTRLINFO
case|:
block|{
name|dpt_compat_ha_t
name|compat_softc
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|compat_softc
operator|.
name|ha_state
operator|=
name|dpt
operator|->
name|state
expr_stmt|;
comment|/*Different Meaning! */
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
literal|4
condition|;
name|ndx
operator|++
control|)
name|compat_softc
operator|.
name|ha_id
index|[
name|ndx
index|]
operator|=
name|dpt
operator|->
name|hostid
index|[
name|ndx
index|]
expr_stmt|;
name|compat_softc
operator|.
name|ha_vect
operator|=
name|dpt
operator|->
name|irq
expr_stmt|;
name|compat_softc
operator|.
name|ha_base
operator|=
name|BaseRegister
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
name|compat_softc
operator|.
name|ha_max_jobs
operator|=
name|dpt
operator|->
name|total_ccbs_count
expr_stmt|;
name|compat_softc
operator|.
name|ha_cache
operator|=
name|dpt
operator|->
name|cache_type
expr_stmt|;
name|compat_softc
operator|.
name|ha_cachesize
operator|=
name|dpt
operator|->
name|cache_size
expr_stmt|;
name|compat_softc
operator|.
name|ha_nbus
operator|=
name|dpt
operator|->
name|dma_channel
operator|+
literal|1
expr_stmt|;
name|compat_softc
operator|.
name|ha_ntargets
operator|=
name|dpt
operator|->
name|max_id
operator|+
literal|1
expr_stmt|;
name|compat_softc
operator|.
name|ha_nluns
operator|=
name|dpt
operator|->
name|max_lun
operator|+
literal|1
expr_stmt|;
name|compat_softc
operator|.
name|ha_tshift
operator|=
operator|(
name|dpt
operator|->
name|max_id
operator|==
literal|7
operator|)
condition|?
literal|3
else|:
literal|4
expr_stmt|;
name|compat_softc
operator|.
name|ha_bshift
operator|=
literal|2
expr_stmt|;
name|compat_softc
operator|.
name|ha_npend
operator|=
name|dpt
operator|->
name|submitted_ccbs_count
expr_stmt|;
name|compat_softc
operator|.
name|ha_active_jobs
operator|=
name|dpt
operator|->
name|waiting_ccbs_count
expr_stmt|;
name|strncpy
argument_list|(
name|compat_softc
operator|.
name|ha_fw_version
argument_list|,
name|dpt
operator|->
name|board_data
operator|.
name|firmware
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|compat_softc
operator|.
name|ha_ccb
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_cblist
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_dev
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_StPkt_lock
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_ccb_lock
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_LuQWaiting
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_QWait_lock
operator|=
name|NULL
expr_stmt|;
name|compat_softc
operator|.
name|ha_QWait_opri
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_sig
argument_list|,
name|eata_pass_thru
operator|.
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
break|break;
case|case
name|DPT_SYSINFO
case|:
comment|/* Copy out the info structure to the user */
if|if
condition|(
operator|(
name|result
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dpt_sysinfo
argument_list|,
name|eata_pass_thru
operator|.
name|command_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sysinfo_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
break|break;
case|case
name|EATAUSRCMD
case|:
return|return
operator|(
name|dpt_user_cmd
argument_list|(
name|dpt
argument_list|,
operator|&
name|eata_pass_thru
argument_list|,
name|cmdarg
argument_list|,
name|minor_no
argument_list|)
operator|)
return|;
case|case
name|DPT_BLINKLED
case|:
name|result
operator|=
name|dpt_blinking_led
argument_list|(
name|dpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|result
argument_list|,
name|eata_pass_thru
operator|.
name|command_buffer
argument_list|,
literal|4
argument_list|)
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
break|break;
default|default:
name|result
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|dpt_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|dpt_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|dpt_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|dpt_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dpt_devsw_installed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"DPT:  RAID Manager driver, Version %d.%d.%d\n"
argument_list|,
name|DPT_CTL_RELEASE
argument_list|,
name|DPT_CTL_VERSION
argument_list|,
name|DPT_CTL_PATCH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|dpt_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"dpt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|dpt_get_sysinfo
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|dpt_dev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE + CDEV_MAJOR
argument_list|,
argument|dpt_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/* End of the dpt_control driver */
end_comment

end_unit

