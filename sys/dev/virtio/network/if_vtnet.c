begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011, Bryan Venteicher<bryanv@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Driver for VirtIO network devices. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/virtio.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/virtqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/network/virtio_net.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/network/if_vtnetvar.h>
end_include

begin_include
include|#
directive|include
file|"virtio_if.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_function_decl
specifier|static
name|int
name|vtnet_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_attach_completed
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_config_change
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_negotiate_features
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_setup_features
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_init_rxq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_init_txq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_alloc_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_alloc_rx_filters
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_rx_filters
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_alloc_virtqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_setup_interface
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_change_mtu
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|vtnet_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_populate
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rxq_free_mbufs
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_rx_alloc_buf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_replace_lro_nomgr_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_replace_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_enqueue_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_new_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_csum
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rxq_discard_merged_bufs
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rxq_discard_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_merged_eof
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rxq_input
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_eof
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_vq_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rxq_tq_intr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_below_threshold
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_notify
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_txq_free_mbufs
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_offload_ctx
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_offload_tso
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_txq_offload
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_enqueue_buf
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|vtnet_tx_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_encap
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|VTNET_LEGACY_TX
end_ifdef

begin_function_decl
specifier|static
name|void
name|vtnet_start_locked
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|vtnet_txq_mq_start_locked
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_txq_tq_deferred
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|vtnet_txq_start
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_txq_tq_intr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_eof
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_tx_vq_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_tx_start_all
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
end_ifndef

begin_function_decl
specifier|static
name|void
name|vtnet_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vtnet_watchdog
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_accum_stats
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|vtnet_rxq_stats
modifier|*
parameter_list|,
name|struct
name|vtnet_txq_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_start_taskqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_taskqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_drain_taskqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_drain_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_stop_rendezvous
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_stop
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_virtio_reinit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_init_rx_filters
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_init_rx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_init_tx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_init_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_set_active_vq_pairs
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_reinit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_init_locked
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_ctrl_vq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_exec_ctrl_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|sglist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ctrl_mac_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ctrl_mq_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ctrl_rx_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_set_promisc
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_set_allmulti
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_attach_disable_promisc
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_filter_mac
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_exec_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_filter_vlan
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_update_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_is_link_up
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_update_link_status
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_get_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_set_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_vlan_tag_remove
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_set_rx_process_limit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_set_tx_intr_threshold
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_setup_rxq_sysctl
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|,
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_setup_txq_sysctl
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
parameter_list|,
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_setup_queue_sysctl
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_setup_sysctl
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxq_enable_intr
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rxq_disable_intr
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_txq_enable_intr
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_txq_disable_intr
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_enable_rx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_enable_tx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_enable_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_disable_rx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_disable_tx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_disable_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_tunable_int
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vtnet_csum_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.csum_disable"
argument_list|,
operator|&
name|vtnet_csum_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_tso_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.tso_disable"
argument_list|,
operator|&
name|vtnet_tso_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_lro_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.lro_disable"
argument_list|,
operator|&
name|vtnet_lro_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_mq_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.mq_disable"
argument_list|,
operator|&
name|vtnet_mq_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_mq_max_pairs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.mq_max_pairs"
argument_list|,
operator|&
name|vtnet_mq_max_pairs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_rx_process_limit
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.rx_process_limit"
argument_list|,
operator|&
name|vtnet_rx_process_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|vtnet_tx_header_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|virtio_feature_desc
name|vtnet_feature_desc
index|[]
init|=
block|{
block|{
name|VIRTIO_NET_F_CSUM
block|,
literal|"TxChecksum"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_CSUM
block|,
literal|"RxChecksum"
block|}
block|,
block|{
name|VIRTIO_NET_F_MAC
block|,
literal|"MacAddress"
block|}
block|,
block|{
name|VIRTIO_NET_F_GSO
block|,
literal|"TxAllGSO"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_TSO4
block|,
literal|"RxTSOv4"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_TSO6
block|,
literal|"RxTSOv6"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_ECN
block|,
literal|"RxECN"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_UFO
block|,
literal|"RxUFO"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_TSO4
block|,
literal|"TxTSOv4"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_TSO6
block|,
literal|"TxTSOv6"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_ECN
block|,
literal|"TxTSOECN"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_UFO
block|,
literal|"TxUFO"
block|}
block|,
block|{
name|VIRTIO_NET_F_MRG_RXBUF
block|,
literal|"MrgRxBuf"
block|}
block|,
block|{
name|VIRTIO_NET_F_STATUS
block|,
literal|"Status"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_VQ
block|,
literal|"ControlVq"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_RX
block|,
literal|"RxMode"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_VLAN
block|,
literal|"VLanFilter"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_RX_EXTRA
block|,
literal|"RxModeExtra"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_ANNOUNCE
block|,
literal|"GuestAnnounce"
block|}
block|,
block|{
name|VIRTIO_NET_F_MQ
block|,
literal|"Multiqueue"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_MAC_ADDR
block|,
literal|"SetMacAddress"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|vtnet_methods
index|[]
init|=
block|{
comment|/* Device methods. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|vtnet_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|vtnet_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|vtnet_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|vtnet_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|vtnet_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|vtnet_shutdown
argument_list|)
block|,
comment|/* VirtIO methods. */
name|DEVMETHOD
argument_list|(
name|virtio_attach_completed
argument_list|,
name|vtnet_attach_completed
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|virtio_config_change
argument_list|,
name|vtnet_config_change
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_include
include|#
directive|include
file|<dev/netmap/if_vtnet_netmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEV_NETMAP */
end_comment

begin_decl_stmt
specifier|static
name|driver_t
name|vtnet_driver
init|=
block|{
literal|"vtnet"
block|,
name|vtnet_methods
block|,
expr|sizeof
operator|(
expr|struct
name|vtnet_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vtnet_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vtnet
argument_list|,
name|virtio_mmio
argument_list|,
name|vtnet_driver
argument_list|,
name|vtnet_devclass
argument_list|,
name|vtnet_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vtnet
argument_list|,
name|virtio_pci
argument_list|,
name|vtnet_driver
argument_list|,
name|vtnet_devclass
argument_list|,
name|vtnet_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|vtnet
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vtnet
argument_list|,
name|virtio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|vtnet_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|vtnet_tx_header_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"vtnet_tx_hdr"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_tx_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|uma_zone_get_cur
argument_list|(
name|vtnet_tx_header_zone
argument_list|)
operator|>
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|MOD_UNLOAD
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|vtnet_tx_header_zone
argument_list|)
expr_stmt|;
name|vtnet_tx_header_zone
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|virtio_get_device_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|VIRTIO_ID_NETWORK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"VirtIO Networking Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_dev
operator|=
name|dev
expr_stmt|;
comment|/* Register our feature descriptions. */
name|virtio_set_feature_desc
argument_list|(
name|dev
argument_list|,
name|vtnet_feature_desc
argument_list|)
expr_stmt|;
name|VTNET_CORE_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|,
name|VTNET_CORE_MTX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vtnet_setup_sysctl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_setup_features
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_alloc_rx_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate Rx filters\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|vtnet_alloc_rxtx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate queues\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|vtnet_alloc_virtqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate virtqueues\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|vtnet_setup_interface
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interface\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|virtio_setup_intr
argument_list|(
name|dev
argument_list|,
name|INTR_TYPE_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup virtqueue interrupts\n"
argument_list|)
expr_stmt|;
comment|/* BMV: This will crash if during boot! */
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|vtnet_ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|vtnet_netmap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|vtnet_start_taskqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|error
condition|)
name|vtnet_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|)
expr_stmt|;
name|vtnet_drain_taskqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_NETMAP
name|netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|vtnet_free_taskqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_vlan_attach
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|sc
operator|->
name|vtnet_vlan_attach
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_attach
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_vlan_detach
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|sc
operator|->
name|vtnet_vlan_detach
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_detach
operator|=
name|NULL
expr_stmt|;
block|}
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|vtnet_free_rxtx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_free_rx_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_ctrl_vq
operator|!=
name|NULL
condition|)
name|vtnet_free_ctrl_vq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_CORE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_SUSPENDED
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_flags
operator|&=
operator|~
name|VTNET_FLAG_SUSPENDED
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Suspend already does all of what we need to 	 * do here; we just never expect to be resumed. 	 */
return|return
operator|(
name|vtnet_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_attach_completed
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|vtnet_attach_disable_promisc
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_config_change
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_link_active
operator|!=
literal|0
condition|)
name|vtnet_tx_start_all
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_negotiate_features
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|,
name|features
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
comment|/* 	 * TSO and LRO are only available when their corresponding checksum 	 * offload feature is also negotiated. 	 */
if|if
condition|(
name|vtnet_tunable_int
argument_list|(
name|sc
argument_list|,
literal|"csum_disable"
argument_list|,
name|vtnet_csum_disable
argument_list|)
condition|)
block|{
name|mask
operator||=
name|VIRTIO_NET_F_CSUM
operator||
name|VIRTIO_NET_F_GUEST_CSUM
expr_stmt|;
name|mask
operator||=
name|VTNET_TSO_FEATURES
operator||
name|VTNET_LRO_FEATURES
expr_stmt|;
block|}
if|if
condition|(
name|vtnet_tunable_int
argument_list|(
name|sc
argument_list|,
literal|"tso_disable"
argument_list|,
name|vtnet_tso_disable
argument_list|)
condition|)
name|mask
operator||=
name|VTNET_TSO_FEATURES
expr_stmt|;
if|if
condition|(
name|vtnet_tunable_int
argument_list|(
name|sc
argument_list|,
literal|"lro_disable"
argument_list|,
name|vtnet_lro_disable
argument_list|)
condition|)
name|mask
operator||=
name|VTNET_LRO_FEATURES
expr_stmt|;
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
if|if
condition|(
name|vtnet_tunable_int
argument_list|(
name|sc
argument_list|,
literal|"mq_disable"
argument_list|,
name|vtnet_mq_disable
argument_list|)
condition|)
name|mask
operator||=
name|VIRTIO_NET_F_MQ
expr_stmt|;
else|#
directive|else
name|mask
operator||=
name|VIRTIO_NET_F_MQ
expr_stmt|;
endif|#
directive|endif
name|features
operator|=
name|VTNET_FEATURES
operator|&
operator|~
name|mask
expr_stmt|;
name|sc
operator|->
name|vtnet_features
operator|=
name|virtio_negotiate_features
argument_list|(
name|dev
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VTNET_LRO_FEATURES
argument_list|)
operator|&&
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MRG_RXBUF
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * LRO without mergeable buffers requires special care. This 		 * is not ideal because every receive buffer must be large 		 * enough to hold the maximum TCP packet, the Ethernet header, 		 * and the header. This requires up to 34 descriptors with 		 * MCLBYTES clusters. If we do not have indirect descriptors, 		 * LRO is disabled since the virtqueue will not contain very 		 * many receive buffers. 		 */
if|if
condition|(
operator|!
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_RING_F_INDIRECT_DESC
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO disabled due to both mergeable buffers and "
literal|"indirect descriptors not negotiated\n"
argument_list|)
expr_stmt|;
name|features
operator|&=
operator|~
name|VTNET_LRO_FEATURES
expr_stmt|;
name|sc
operator|->
name|vtnet_features
operator|=
name|virtio_negotiate_features
argument_list|(
name|dev
argument_list|,
name|features
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_LRO_NOMRG
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_setup_features
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|max_pairs
decl_stmt|,
name|max
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|vtnet_negotiate_features
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_RING_F_INDIRECT_DESC
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_INDIRECT
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_RING_F_EVENT_IDX
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_EVENT_IDX
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MAC
argument_list|)
condition|)
block|{
comment|/* This feature should always be negotiated. */
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_MAC
expr_stmt|;
block|}
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MRG_RXBUF
argument_list|)
condition|)
block|{
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_MRG_RXBUFS
expr_stmt|;
name|sc
operator|->
name|vtnet_hdr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr_mrg_rxbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|vtnet_hdr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
condition|)
name|sc
operator|->
name|vtnet_rx_nsegs
operator|=
name|VTNET_MRG_RX_SEGS
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
condition|)
name|sc
operator|->
name|vtnet_rx_nsegs
operator|=
name|VTNET_MAX_RX_SEGS
expr_stmt|;
else|else
name|sc
operator|->
name|vtnet_rx_nsegs
operator|=
name|VTNET_MIN_RX_SEGS
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GSO
argument_list|)
operator|||
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_TSO4
argument_list|)
operator|||
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_TSO6
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_tx_nsegs
operator|=
name|VTNET_MAX_TX_SEGS
expr_stmt|;
else|else
name|sc
operator|->
name|vtnet_tx_nsegs
operator|=
name|VTNET_MIN_TX_SEGS
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_VQ
argument_list|)
condition|)
block|{
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_CTRL_VQ
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_RX
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_CTRL_RX
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_VLAN
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_VLAN_FILTER
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_MAC_ADDR
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_CTRL_MAC
expr_stmt|;
block|}
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MQ
argument_list|)
operator|&&
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
condition|)
block|{
name|max_pairs
operator|=
name|virtio_read_dev_config_2
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|max_virtqueue_pairs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_pairs
operator|<
name|VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN
operator|||
name|max_pairs
operator|>
name|VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX
condition|)
name|max_pairs
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|max_pairs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|max_pairs
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Limit the maximum number of queue pairs to the number of 		 * CPUs or the configured maximum. The actual number of 		 * queues that get used may be less. 		 */
name|max
operator|=
name|vtnet_tunable_int
argument_list|(
name|sc
argument_list|,
literal|"mq_max_pairs"
argument_list|,
name|vtnet_mq_max_pairs
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|>
literal|0
operator|&&
name|max_pairs
operator|>
name|max
condition|)
name|max_pairs
operator|=
name|max
expr_stmt|;
if|if
condition|(
name|max_pairs
operator|>
name|mp_ncpus
condition|)
name|max_pairs
operator|=
name|mp_ncpus
expr_stmt|;
if|if
condition|(
name|max_pairs
operator|>
name|VTNET_MAX_QUEUE_PAIRS
condition|)
name|max_pairs
operator|=
name|VTNET_MAX_QUEUE_PAIRS
expr_stmt|;
if|if
condition|(
name|max_pairs
operator|>
literal|1
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_MULTIQ
expr_stmt|;
block|}
name|sc
operator|->
name|vtnet_max_vq_pairs
operator|=
name|max_pairs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_init_rxq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|id
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|rxq
operator|->
name|vtnrx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rxq
operator|->
name|vtnrx_name
argument_list|)
argument_list|,
literal|"%s-rx%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|rxq
operator|->
name|vtnrx_mtx
argument_list|,
name|rxq
operator|->
name|vtnrx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|vtnrx_sc
operator|=
name|sc
expr_stmt|;
name|rxq
operator|->
name|vtnrx_id
operator|=
name|id
expr_stmt|;
name|rxq
operator|->
name|vtnrx_sg
operator|=
name|sglist_alloc
argument_list|(
name|sc
operator|->
name|vtnet_rx_nsegs
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|vtnrx_sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TASK_INIT
argument_list|(
operator|&
name|rxq
operator|->
name|vtnrx_intrtask
argument_list|,
literal|0
argument_list|,
name|vtnet_rxq_tq_intr
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|vtnrx_tq
operator|=
name|taskqueue_create
argument_list|(
name|rxq
operator|->
name|vtnrx_name
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|rxq
operator|->
name|vtnrx_tq
argument_list|)
expr_stmt|;
return|return
operator|(
name|rxq
operator|->
name|vtnrx_tq
operator|==
name|NULL
condition|?
name|ENOMEM
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_init_txq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|id
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|txq
operator|->
name|vtntx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|txq
operator|->
name|vtntx_name
argument_list|)
argument_list|,
literal|"%s-tx%d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|)
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txq
operator|->
name|vtntx_mtx
argument_list|,
name|txq
operator|->
name|vtntx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vtntx_sc
operator|=
name|sc
expr_stmt|;
name|txq
operator|->
name|vtntx_id
operator|=
name|id
expr_stmt|;
name|txq
operator|->
name|vtntx_sg
operator|=
name|sglist_alloc
argument_list|(
name|sc
operator|->
name|vtnet_tx_nsegs
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
name|txq
operator|->
name|vtntx_br
operator|=
name|buf_ring_alloc
argument_list|(
name|VTNET_DEFAULT_BUFRING_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_br
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TASK_INIT
argument_list|(
operator|&
name|txq
operator|->
name|vtntx_defrtask
argument_list|,
literal|0
argument_list|,
name|vtnet_txq_tq_deferred
argument_list|,
name|txq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TASK_INIT
argument_list|(
operator|&
name|txq
operator|->
name|vtntx_intrtask
argument_list|,
literal|0
argument_list|,
name|vtnet_txq_tq_intr
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vtntx_tq
operator|=
name|taskqueue_create
argument_list|(
name|txq
operator|->
name|vtntx_name
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_tq
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_alloc_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|npairs
decl_stmt|,
name|error
decl_stmt|;
name|npairs
operator|=
name|sc
operator|->
name|vtnet_max_vq_pairs
expr_stmt|;
name|sc
operator|->
name|vtnet_rxqs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rxq
argument_list|)
operator|*
name|npairs
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_txqs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_txq
argument_list|)
operator|*
name|npairs
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_rxqs
operator|==
name|NULL
operator|||
name|sc
operator|->
name|vtnet_txqs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npairs
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|vtnet_init_rxq
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vtnet_init_txq
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vtnet_setup_queue_sysctl
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_destroy_rxq
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|rxq
operator|->
name|vtnrx_sc
operator|=
name|NULL
expr_stmt|;
name|rxq
operator|->
name|vtnrx_id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|vtnrx_sg
operator|!=
name|NULL
condition|)
block|{
name|sglist_free
argument_list|(
name|rxq
operator|->
name|vtnrx_sg
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|vtnrx_sg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|rxq
operator|->
name|vtnrx_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|rxq
operator|->
name|vtnrx_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_destroy_txq
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|txq
operator|->
name|vtntx_sc
operator|=
name|NULL
expr_stmt|;
name|txq
operator|->
name|vtntx_id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_sg
operator|!=
name|NULL
condition|)
block|{
name|sglist_free
argument_list|(
name|txq
operator|->
name|vtntx_sg
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vtntx_sg
operator|=
name|NULL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
if|if
condition|(
name|txq
operator|->
name|vtntx_br
operator|!=
name|NULL
condition|)
block|{
name|buf_ring_free
argument_list|(
name|txq
operator|->
name|vtntx_br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vtntx_br
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mtx_initialized
argument_list|(
operator|&
name|txq
operator|->
name|vtntx_mtx
argument_list|)
operator|!=
literal|0
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|txq
operator|->
name|vtntx_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_rxqs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
name|vtnet_destroy_rxq
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|vtnet_rxqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_rxqs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_txqs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
name|vtnet_destroy_txq
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|vtnet_txqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_txqs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_alloc_rx_filters
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
condition|)
block|{
name|sc
operator|->
name|vtnet_mac_filter
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_mac_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_mac_filter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_VLAN_FILTER
condition|)
block|{
name|sc
operator|->
name|vtnet_vlan_filter
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|VTNET_VLAN_FILTER_NWORDS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_vlan_filter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_rx_filters
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|vtnet_mac_filter
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|vtnet_mac_filter
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_mac_filter
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_vlan_filter
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|vtnet_vlan_filter
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_filter
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_alloc_virtqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|vq_alloc_info
modifier|*
name|info
decl_stmt|;
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|flags
decl_stmt|,
name|nvqs
decl_stmt|,
name|error
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|nvqs
operator|=
name|sc
operator|->
name|vtnet_max_vq_pairs
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
condition|)
name|nvqs
operator|++
expr_stmt|;
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vq_alloc_info
argument_list|)
operator|*
name|nvqs
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|idx
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
operator|,
name|idx
operator|+=
literal|2
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
name|VQ_ALLOC_INFO_INIT
argument_list|(
operator|&
name|info
index|[
name|idx
index|]
argument_list|,
name|sc
operator|->
name|vtnet_rx_nsegs
argument_list|,
name|vtnet_rx_vq_intr
argument_list|,
name|rxq
argument_list|,
operator|&
name|rxq
operator|->
name|vtnrx_vq
argument_list|,
literal|"%s-%d rx"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rxq
operator|->
name|vtnrx_id
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|VQ_ALLOC_INFO_INIT
argument_list|(
operator|&
name|info
index|[
name|idx
operator|+
literal|1
index|]
argument_list|,
name|sc
operator|->
name|vtnet_tx_nsegs
argument_list|,
name|vtnet_tx_vq_intr
argument_list|,
name|txq
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_vq
argument_list|,
literal|"%s-%d tx"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txq
operator|->
name|vtntx_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
condition|)
block|{
name|VQ_ALLOC_INFO_INIT
argument_list|(
operator|&
name|info
index|[
name|idx
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_ctrl_vq
argument_list|,
literal|"%s ctrl"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enable interrupt binding if this is multiqueue. This only matters 	 * when per-vq MSIX is available. 	 */
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MULTIQ
condition|)
name|flags
operator||=
literal|0
expr_stmt|;
name|error
operator|=
name|virtio_alloc_virtqueues
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|,
name|nvqs
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_setup_interface
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Approx. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|vtnet_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|vtnet_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|vtnet_get_counter
expr_stmt|;
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
name|ifp
operator|->
name|if_transmit
operator|=
name|vtnet_txq_mq_start
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|vtnet_qflush
expr_stmt|;
else|#
directive|else
name|struct
name|virtqueue
modifier|*
name|vq
init|=
name|sc
operator|->
name|vtnet_txqs
index|[
literal|0
index|]
operator|.
name|vtntx_vq
decl_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|vtnet_start
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|virtqueue_size
argument_list|(
name|vq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|virtqueue_size
argument_list|(
name|vq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|vtnet_ifmedia_upd
argument_list|,
name|vtnet_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|VTNET_MEDIATYPE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|VTNET_MEDIATYPE
argument_list|)
expr_stmt|;
comment|/* Read (or generate) the MAC address for the adapter. */
name|vtnet_get_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_STATUS
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LINKSTATE
expr_stmt|;
comment|/* Tell the upper layer(s) we support long frames. */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CSUM
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TXCSUM
operator||
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GSO
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
operator||
name|IFCAP_TSO6
expr_stmt|;
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_TSO_ECN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_TSO4
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_TSO6
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_ECN
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_TSO_ECN
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
block|}
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GUEST_CSUM
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GUEST_TSO4
argument_list|)
operator|||
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GUEST_TSO6
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
comment|/* 		 * VirtIO does not support VLAN tagging, but we can fake 		 * it by inserting and removing the 802.1Q header during 		 * transmit and receive. We are then able to do checksum 		 * offloading of VLAN frames. 		 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Capabilities after here are not enabled by default. 	 */
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_VLAN_FILTER
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vtnet_register_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vtnet_unregister_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
block|}
name|vtnet_set_rx_process_limit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_set_tx_intr_threshold
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_change_mtu
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|frame_size
decl_stmt|,
name|clsize
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
name|new_mtu
operator|<
name|ETHERMIN
operator|||
name|new_mtu
operator|>
name|VTNET_MAX_MTU
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|frame_size
operator|=
name|sc
operator|->
name|vtnet_hdr_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
operator|+
name|new_mtu
expr_stmt|;
comment|/* 	 * Based on the new MTU (and hence frame size) determine which 	 * cluster size is most appropriate for the receive queues. 	 */
if|if
condition|(
name|frame_size
operator|<=
name|MCLBYTES
condition|)
block|{
name|clsize
operator|=
name|MCLBYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Avoid going past 9K jumbos. */
if|if
condition|(
name|frame_size
operator|>
name|MJUM9BYTES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|clsize
operator|=
name|MJUM9BYTES
expr_stmt|;
block|}
else|else
name|clsize
operator|=
name|MJUMPAGESIZE
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|new_mtu
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_new_clsize
operator|=
name|clsize
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|reinit
decl_stmt|,
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_change_mtu
argument_list|(
name|sc
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|vtnet_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
condition|)
name|vtnet_rx_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
block|}
else|else
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|vtnet_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
operator|)
operator|==
literal|0
condition|)
break|break;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|vtnet_rx_filter_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator||
name|IFCAP_LRO
operator||
name|IFCAP_VLAN_HWFILTER
operator|)
condition|)
block|{
comment|/* These Rx features require us to renegotiate. */
name|reinit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
block|}
else|else
name|reinit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|reinit
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|VTNET_CORE_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_populate
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|int
name|nbufs
decl_stmt|,
name|error
decl_stmt|;
name|vq
operator|=
name|rxq
operator|->
name|vtnrx_vq
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
for|for
control|(
name|nbufs
operator|=
literal|0
init|;
operator|!
name|virtqueue_full
argument_list|(
name|vq
argument_list|)
condition|;
name|nbufs
operator|++
control|)
block|{
name|error
operator|=
name|vtnet_rxq_new_buf
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|nbufs
operator|>
literal|0
condition|)
block|{
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
comment|/* 		 * EMSGSIZE signifies the virtqueue did not have enough 		 * entries available to hold the last mbuf. This is not 		 * an error. 		 */
if|if
condition|(
name|error
operator|==
name|EMSGSIZE
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rxq_free_mbufs
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|last
decl_stmt|;
name|vq
operator|=
name|rxq
operator|->
name|vtnrx_vq
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|virtqueue_drain
argument_list|(
name|vq
argument_list|,
operator|&
name|last
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
argument_list|,
operator|(
literal|"%s: mbufs remaining in rx queue %p"
operator|,
name|__func__
operator|,
name|rxq
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_rx_alloc_buf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbufs
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_tailp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clsize
decl_stmt|;
name|clsize
operator|=
name|sc
operator|->
name|vtnet_rx_clsize
expr_stmt|;
name|KASSERT
argument_list|(
name|nbufs
operator|==
literal|1
operator|||
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
argument_list|,
operator|(
literal|"%s: chained mbuf %d request without LRO_NOMRG"
operator|,
name|__func__
operator|,
name|nbufs
operator|)
argument_list|)
expr_stmt|;
name|m_head
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|clsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|m_head
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
name|m_tail
operator|=
name|m_head
expr_stmt|;
comment|/* Allocate the rest of the chain. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nbufs
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|,
name|clsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|m
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
name|m_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_tail
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|m_tailp
operator|!=
name|NULL
condition|)
operator|*
name|m_tailp
operator|=
name|m_tail
expr_stmt|;
return|return
operator|(
name|m_head
operator|)
return|;
name|fail
label|:
name|sc
operator|->
name|vtnet_stats
operator|.
name|mbuf_alloc_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Slow path for when LRO without mergeable buffers is negotiated.  */
end_comment

begin_function
specifier|static
name|int
name|vtnet_rxq_replace_lro_nomgr_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|len0
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|int
name|len
decl_stmt|,
name|clsize
decl_stmt|,
name|nreplace
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|clsize
operator|=
name|sc
operator|->
name|vtnet_rx_clsize
expr_stmt|;
name|m_prev
operator|=
name|NULL
expr_stmt|;
name|m_tail
operator|=
name|NULL
expr_stmt|;
name|nreplace
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|len
operator|=
name|len0
expr_stmt|;
comment|/* 	 * Since these mbuf chains are so large, we avoid allocating an 	 * entire replacement chain if possible. When the received frame 	 * did not consume the entire chain, the unused mbufs are moved 	 * to the replacement chain. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Something is seriously wrong if we received a frame 		 * larger than the chain. Drop it. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_frame_too_large
operator|++
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* We always allocate the same cluster size. */
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|==
name|clsize
argument_list|,
operator|(
literal|"%s: mbuf size %d is not the cluster size %d"
operator|,
name|__func__
operator|,
name|m
operator|->
name|m_len
operator|,
name|clsize
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|nreplace
operator|++
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|nreplace
operator|<=
name|sc
operator|->
name|vtnet_rx_nmbufs
argument_list|,
operator|(
literal|"%s: too many replacement mbufs %d max %d"
operator|,
name|__func__
operator|,
name|nreplace
operator|,
name|sc
operator|->
name|vtnet_rx_nmbufs
operator|)
argument_list|)
expr_stmt|;
name|m_new
operator|=
name|vtnet_rx_alloc_buf
argument_list|(
name|sc
argument_list|,
name|nreplace
argument_list|,
operator|&
name|m_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|m_prev
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * Move any unused mbufs from the received chain onto the end 	 * of the new chain. 	 */
if|if
condition|(
name|m_prev
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|m_tail
operator|->
name|m_next
operator|=
name|m_prev
operator|->
name|m_next
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|vtnet_rxq_enqueue_buf
argument_list|(
name|rxq
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * BAD! We could not enqueue the replacement mbuf chain. We 		 * must restore the m0 chain to the original state if it was 		 * modified so we can subsequently discard it. 		 * 		 * NOTE: The replacement is suppose to be an identical copy 		 * to the one just dequeued so this is an unexpected error. 		 */
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_enq_replacement_failed
operator|++
expr_stmt|;
if|if
condition|(
name|m_tail
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|m_prev
operator|->
name|m_next
operator|=
name|m_tail
operator|->
name|m_next
expr_stmt|;
name|m_tail
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|m_prev
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_replace_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
operator|||
name|m
operator|->
name|m_next
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: chained mbuf without LRO_NOMRG"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
comment|/* Fast-path for the common case of just one mbuf. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|m_new
operator|=
name|vtnet_rx_alloc_buf
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|error
operator|=
name|vtnet_rxq_enqueue_buf
argument_list|(
name|rxq
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * The new mbuf is suppose to be an identical 			 * copy of the one just dequeued so this is an 			 * unexpected error. 			 */
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_enq_replacement_failed
operator|++
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|error
operator|=
name|vtnet_rxq_replace_lro_nomgr_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_enqueue_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|struct
name|vtnet_rx_header
modifier|*
name|rxhdr
decl_stmt|;
name|uint8_t
modifier|*
name|mdata
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|sg
operator|=
name|rxq
operator|->
name|vtnrx_sg
expr_stmt|;
name|mdata
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|VTNET_RXQ_LOCK_ASSERT
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
operator|||
name|m
operator|->
name|m_next
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: chained mbuf without LRO_NOMRG"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|==
name|sc
operator|->
name|vtnet_rx_clsize
argument_list|,
operator|(
literal|"%s: unexpected cluster size %d/%d"
operator|,
name|__func__
operator|,
name|m
operator|->
name|m_len
operator|,
name|sc
operator|->
name|vtnet_rx_clsize
operator|)
argument_list|)
expr_stmt|;
name|sglist_reset
argument_list|(
name|sg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
name|MPASS
argument_list|(
name|sc
operator|->
name|vtnet_hdr_size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|rxhdr
operator|=
operator|(
expr|struct
name|vtnet_rx_header
operator|*
operator|)
name|mdata
expr_stmt|;
name|sglist_append
argument_list|(
name|sg
argument_list|,
operator|&
name|rxhdr
operator|->
name|vrh_hdr
argument_list|,
name|sc
operator|->
name|vtnet_hdr_size
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rx_header
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|sglist_append
argument_list|(
name|sg
argument_list|,
name|mdata
operator|+
name|offset
argument_list|,
name|m
operator|->
name|m_len
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|sglist_append_mbuf
argument_list|(
name|sg
argument_list|,
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|virtqueue_enqueue
argument_list|(
name|rxq
operator|->
name|vtnrx_vq
argument_list|,
name|m
argument_list|,
name|sg
argument_list|,
literal|0
argument_list|,
name|sg
operator|->
name|sg_nseg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_new_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|m
operator|=
name|vtnet_rx_alloc_buf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vtnet_rx_nmbufs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|error
operator|=
name|vtnet_rxq_enqueue_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use the checksum offset in the VirtIO header to set the  * correct CSUM_* flags.  */
end_comment

begin_function
specifier|static
name|int
name|vtnet_rxq_csum_by_offset
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|eth_type
parameter_list|,
name|int
name|ip_start
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|offset
init|=
name|hdr
operator|->
name|csum_start
operator|+
name|hdr
operator|->
name|csum_offset
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
comment|/* Only do a basic sanity check on the offset. */
switch|switch
condition|(
name|eth_type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
case|case
name|ETHERTYPE_IP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|offset
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|offset
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_ethtype
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Use the offset to determine the appropriate CSUM_* flags. This is 	 * a bit dirty, but we can get by with it since the checksum offsets 	 * happen to be different. We assume the host host does not do IPv4 	 * header checksum offloading. 	 */
switch|switch
condition|(
name|hdr
operator|->
name|csum_offset
condition|)
block|{
case|case
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
case|:
case|case
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_offset
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_csum_by_parse
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|eth_type
parameter_list|,
name|int
name|ip_start
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|proto
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
switch|switch
condition|(
name|eth_type
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
case|case
name|ETHERTYPE_IP
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|ip_start
operator|)
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|offset
operator|=
name|ip_start
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|offset
operator|=
name|ip6_lasthdr
argument_list|(
name|m
argument_list|,
name|ip_start
argument_list|,
name|IPPROTO_IPV6
argument_list|,
operator|&
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|offset
operator|<
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_ethtype
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
default|default:
comment|/* 		 * For the remaining protocols, FreeBSD does not support 		 * checksum offloading, so the checksum will be recomputed. 		 */
if|#
directive|if
literal|0
block|if_printf(sc->vtnet_ifp, "cksum offload of unsupported " 		    "protocol eth_type=%#x proto=%d csum_start=%d " 		    "csum_offset=%d\n", __func__, eth_type, proto, 		    hdr->csum_start, hdr->csum_offset);
endif|#
directive|endif
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the appropriate CSUM_* flags. Unfortunately, the information  * provided is not directly useful to us. The VirtIO header gives the  * offset of the checksum, which is all Linux needs, but this is not  * how FreeBSD does things. We are forced to peek inside the packet  * a bit.  *  * It would be nice if VirtIO gave us the L4 protocol or if FreeBSD  * could accept the offsets and let the stack figure it out.  */
end_comment

begin_function
specifier|static
name|int
name|vtnet_rxq_csum
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|uint16_t
name|eth_type
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|error
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_type
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
comment|/* BMV: We should handle nested VLAN tags too. */
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
condition|)
name|error
operator|=
name|vtnet_rxq_csum_by_offset
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|eth_type
argument_list|,
name|offset
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|vtnet_rxq_csum_by_parse
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|eth_type
argument_list|,
name|offset
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rxq_discard_merged_bufs
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|int
name|nbufs
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
while|while
condition|(
operator|--
name|nbufs
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|virtqueue_dequeue
argument_list|(
name|rxq
operator|->
name|vtnrx_vq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|vtnet_rxq_discard_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rxq_discard_buf
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Requeue the discarded mbuf. This should always be successful 	 * since it was just dequeued. 	 */
name|error
operator|=
name|vtnet_rxq_enqueue_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: cannot requeue discarded mbuf %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_merged_eof
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|int
name|nbufs
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|int
name|len
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|vq
operator|=
name|rxq
operator|->
name|vtnrx_vq
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|m_tail
operator|=
name|m_head
expr_stmt|;
while|while
condition|(
operator|--
name|nbufs
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_ierrors
operator|++
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|vtnet_rxq_new_buf
argument_list|(
name|rxq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_iqdrops
operator|++
expr_stmt|;
name|vtnet_rxq_discard_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
name|vtnet_rxq_discard_merged_bufs
argument_list|(
name|rxq
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|m_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_tail
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_mergeable_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rxq_input
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|vtnet_vlan_tag_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * With the 802.1Q header removed, update the 			 * checksum starting location accordingly. 			 */
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
condition|)
name|hdr
operator|->
name|csum_start
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|rxq
operator|->
name|vtnrx_id
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
comment|/* 	 * BMV: FreeBSD does not have the UNNECESSARY and PARTIAL checksum 	 * distinction that Linux does. Need to reevaluate if performing 	 * offloading for the NEEDS_CSUM case is really appropriate. 	 */
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
operator|(
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
operator||
name|VIRTIO_NET_HDR_F_DATA_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|vtnet_rxq_csum
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
operator|==
literal|0
condition|)
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_csum
operator|++
expr_stmt|;
else|else
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_csum_failed
operator|++
expr_stmt|;
block|}
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_ipackets
operator|++
expr_stmt|;
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VTNET_RXQ_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_eof
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|virtio_net_hdr
name|lhdr
decl_stmt|,
modifier|*
name|hdr
decl_stmt|;
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|virtio_net_hdr_mrg_rxbuf
modifier|*
name|mhdr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|deq
decl_stmt|,
name|nbufs
decl_stmt|,
name|adjsz
decl_stmt|,
name|count
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|vq
operator|=
name|rxq
operator|->
name|vtnrx_vq
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|hdr
operator|=
operator|&
name|lhdr
expr_stmt|;
name|deq
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|sc
operator|->
name|vtnet_rx_process_limit
expr_stmt|;
name|VTNET_RXQ_LOCK_ASSERT
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
operator|&
name|deq
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|deq
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|sc
operator|->
name|vtnet_hdr_size
operator|+
name|ETHER_HDR_LEN
condition|)
block|{
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_ierrors
operator|++
expr_stmt|;
name|vtnet_rxq_discard_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
name|nbufs
operator|=
literal|1
expr_stmt|;
name|adjsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rx_header
argument_list|)
expr_stmt|;
comment|/* 			 * Account for our pad inserted between the header 			 * and the actual start of the frame. 			 */
name|len
operator|+=
name|VTNET_RX_HEADER_PAD
expr_stmt|;
block|}
else|else
block|{
name|mhdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|virtio_net_hdr_mrg_rxbuf
operator|*
argument_list|)
expr_stmt|;
name|nbufs
operator|=
name|mhdr
operator|->
name|num_buffers
expr_stmt|;
name|adjsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr_mrg_rxbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vtnet_rxq_replace_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_iqdrops
operator|++
expr_stmt|;
name|vtnet_rxq_discard_buf
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
name|vtnet_rxq_discard_merged_bufs
argument_list|(
name|rxq
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
block|{
comment|/* Dequeue the rest of chain. */
if|if
condition|(
name|vtnet_rxq_merged_eof
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|nbufs
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
comment|/* 		 * Save copy of header before we strip it. For both mergeable 		 * and non-mergeable, the header is at the beginning of the 		 * mbuf data. We no longer need num_buffers, so always use a 		 * regular header. 		 * 		 * BMV: Is this memcpy() expensive? We know the mbuf data is 		 * still valid even after the m_adj(). 		 */
name|memcpy
argument_list|(
name|hdr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|adjsz
argument_list|)
expr_stmt|;
name|vtnet_rxq_input
argument_list|(
name|rxq
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
comment|/* Must recheck after dropping the Rx lock. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|deq
operator|>
literal|0
condition|)
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|>
literal|0
condition|?
literal|0
else|:
name|EAGAIN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_vq_intr
parameter_list|(
name|void
modifier|*
name|xrxq
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|tries
decl_stmt|,
name|more
decl_stmt|;
name|rxq
operator|=
name|xrxq
expr_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|rxq
operator|->
name|vtnrx_id
operator|>=
name|sc
operator|->
name|vtnet_act_vq_pairs
argument_list|)
condition|)
block|{
comment|/* 		 * Ignore this interrupt. Either this is a spurious interrupt 		 * or multiqueue without per-VQ MSIX so every queue needs to 		 * be polled (a brain dead configuration we could try harder 		 * to avoid). 		 */
name|vtnet_rxq_disable_intr
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
return|return;
block|}
name|VTNET_RXQ_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
return|return;
block|}
name|more
operator|=
name|vtnet_rxq_eof
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
operator|||
name|vtnet_rxq_enable_intr
argument_list|(
name|rxq
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|more
condition|)
name|vtnet_rxq_disable_intr
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
comment|/* 		 * This is an occasional condition or race (when !more), 		 * so retry a few times before scheduling the taskqueue. 		 */
if|if
condition|(
name|tries
operator|++
operator|<
name|VTNET_INTR_DISABLE_RETRIES
condition|)
goto|goto
name|again
goto|;
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_rescheduled
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|rxq
operator|->
name|vtnrx_tq
argument_list|,
operator|&
name|rxq
operator|->
name|vtnrx_intrtask
argument_list|)
expr_stmt|;
block|}
else|else
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rxq_tq_intr
parameter_list|(
name|void
modifier|*
name|xrxq
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|more
decl_stmt|;
name|rxq
operator|=
name|xrxq
expr_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|vtnrx_sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_RXQ_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
return|return;
block|}
name|more
operator|=
name|vtnet_rxq_eof
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
operator|||
name|vtnet_rxq_enable_intr
argument_list|(
name|rxq
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|more
condition|)
name|vtnet_rxq_disable_intr
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|vtnrx_stats
operator|.
name|vrxs_rescheduled
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|rxq
operator|->
name|vtnrx_tq
argument_list|,
operator|&
name|rxq
operator|->
name|vtnrx_intrtask
argument_list|)
expr_stmt|;
block|}
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_below_threshold
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
return|return
operator|(
name|virtqueue_nfree
argument_list|(
name|vq
argument_list|)
operator|<=
name|sc
operator|->
name|vtnet_tx_intr_thresh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_notify
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
name|txq
operator|->
name|vtntx_watchdog
operator|=
name|VTNET_TX_TIMEOUT
expr_stmt|;
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_txq_enable_intr
argument_list|(
name|txq
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Drain frames that were completed since last checked. If this 	 * causes the queue to go above the threshold, the caller should 	 * continue transmitting. 	 */
if|if
condition|(
name|vtnet_txq_eof
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
operator|&&
name|vtnet_txq_below_threshold
argument_list|(
name|txq
argument_list|)
operator|==
literal|0
condition|)
block|{
name|virtqueue_disable_intr
argument_list|(
name|vq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_txq_free_mbufs
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
decl_stmt|;
name|int
name|last
decl_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|txhdr
operator|=
name|virtqueue_drain
argument_list|(
name|vq
argument_list|,
operator|&
name|last
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txhdr
operator|->
name|vth_mbuf
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
argument_list|,
operator|(
literal|"%s: mbufs remaining in tx queue %p"
operator|,
name|__func__
operator|,
name|txq
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BMV: Much of this can go away once we finally have offsets in  * the mbuf packet header. Bug andre@.  */
end_comment

begin_function
specifier|static
name|int
name|vtnet_txq_offload_ctx
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|etype
parameter_list|,
name|int
modifier|*
name|proto
parameter_list|,
name|int
modifier|*
name|start
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|evh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
comment|/* BMV: We should handle nested VLAN tags too. */
operator|*
name|etype
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|etype
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|etype
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
case|case
name|ETHERTYPE_IP
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|,
name|iphdr
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|iphdr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|iphdr
expr_stmt|;
block|}
else|else
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|)
expr_stmt|;
operator|*
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
operator|*
name|start
operator|=
name|offset
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|ETHERTYPE_IPV6
case|:
operator|*
name|proto
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|start
operator|=
name|ip6_lasthdr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|proto
argument_list|)
expr_stmt|;
comment|/* Assert the network stack sent us a valid packet. */
name|KASSERT
argument_list|(
operator|*
name|start
operator|>
name|offset
argument_list|,
operator|(
literal|"%s: mbuf %p start %d offset %d proto %d"
operator|,
name|__func__
operator|,
name|m
operator|,
operator|*
name|start
operator|,
name|offset
operator|,
operator|*
name|proto
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_csum_bad_ethtype
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_offload_tso
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|eth_type
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|lastecn
decl_stmt|;
specifier|static
name|int
name|curecn
decl_stmt|;
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|,
name|tcphdr
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tcphdr
argument_list|)
expr_stmt|;
name|tcp
operator|=
operator|&
name|tcphdr
expr_stmt|;
block|}
else|else
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|offset
operator|)
expr_stmt|;
name|hdr
operator|->
name|hdr_len
operator|=
name|offset
operator|+
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
name|hdr
operator|->
name|gso_size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
name|hdr
operator|->
name|gso_type
operator|=
name|eth_type
operator|==
name|ETHERTYPE_IP
condition|?
name|VIRTIO_NET_HDR_GSO_TCPV4
else|:
name|VIRTIO_NET_HDR_GSO_TCPV6
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_CWR
condition|)
block|{
comment|/* 		 * Drop if VIRTIO_NET_F_HOST_ECN was not negotiated. In FreeBSD, 		 * ECN support is not on a per-interface basis, but globally via 		 * the net.inet.tcp.ecn.enable sysctl knob. The default is off. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_TSO_ECN
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|lastecn
argument_list|,
operator|&
name|curecn
argument_list|,
literal|1
argument_list|)
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|vtnet_ifp
argument_list|,
literal|"TSO with ECN not negotiated with host\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|hdr
operator|->
name|gso_type
operator||=
name|VIRTIO_NET_HDR_GSO_ECN
expr_stmt|;
block|}
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_tso
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_txq_offload
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|etype
decl_stmt|,
name|csum_start
decl_stmt|,
name|proto
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|flags
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|error
operator|=
name|vtnet_txq_offload_ctx
argument_list|(
name|txq
argument_list|,
name|m
argument_list|,
operator|&
name|etype
argument_list|,
operator|&
name|proto
argument_list|,
operator|&
name|csum_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|(
name|etype
operator|==
name|ETHERTYPE_IP
operator|&&
name|flags
operator|&
name|VTNET_CSUM_OFFLOAD
operator|)
operator|||
operator|(
name|etype
operator|==
name|ETHERTYPE_IPV6
operator|&&
name|flags
operator|&
name|VTNET_CSUM_OFFLOAD_IPV6
operator|)
condition|)
block|{
comment|/* 		 * We could compare the IP protocol vs the CSUM_ flag too, 		 * but that really should not be necessary. 		 */
name|hdr
operator|->
name|flags
operator||=
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
expr_stmt|;
name|hdr
operator|->
name|csum_start
operator|=
name|csum_start
expr_stmt|;
name|hdr
operator|->
name|csum_offset
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_csum
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CSUM_TSO
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|proto
operator|!=
name|IPPROTO_TCP
argument_list|)
condition|)
block|{
comment|/* Likely failed to correctly parse the mbuf. */
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_tso_not_tcp
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|KASSERT
argument_list|(
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
argument_list|,
operator|(
literal|"%s: mbuf %p TSO without checksum offload %#x"
operator|,
name|__func__
operator|,
name|m
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_txq_offload_tso
argument_list|(
name|txq
argument_list|,
name|m
argument_list|,
name|etype
argument_list|,
name|csum_start
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|drop
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_enqueue_buf
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|,
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|sglist
modifier|*
name|sg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
name|sg
operator|=
name|txq
operator|->
name|vtntx_sg
expr_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
name|sglist_reset
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append
argument_list|(
name|sg
argument_list|,
operator|&
name|txhdr
operator|->
name|vth_uhdr
argument_list|,
name|sc
operator|->
name|vtnet_hdr_size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|->
name|sg_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: error %d adding header to sglist"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append_mbuf
argument_list|(
name|sg
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_defragged
operator|++
expr_stmt|;
name|error
operator|=
name|sglist_append_mbuf
argument_list|(
name|sg
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
block|}
name|txhdr
operator|->
name|vth_mbuf
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|virtqueue_enqueue
argument_list|(
name|vq
argument_list|,
name|txhdr
argument_list|,
name|sg
argument_list|,
name|sg
operator|->
name|sg_nseg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|fail
label|:
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_defrag_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_encap
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
decl_stmt|;
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|txhdr
operator|=
name|uma_zalloc
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|txhdr
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Always use the non-mergeable header, regardless if the feature 	 * was negotiated. For transmit, num_buffers is always zero. The 	 * vtnet_hdr_size is used to enqueue the correct header size. 	 */
name|hdr
operator|=
operator|&
name|txhdr
operator|->
name|vth_uhdr
operator|.
name|hdr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|m
operator|=
name|ether_vlanencap
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m_head
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|VTNET_CSUM_ALL_OFFLOAD
condition|)
block|{
name|m
operator|=
name|vtnet_txq_offload
argument_list|(
name|txq
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m_head
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|error
operator|=
name|vtnet_txq_enqueue_buf
argument_list|(
name|txq
argument_list|,
name|m_head
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|uma_zfree
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VTNET_LEGACY_TX
end_ifdef

begin_function
specifier|static
name|void
name|vtnet_start_locked
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|tries
decl_stmt|,
name|enq
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|VTNET_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|vtnet_link_active
operator|==
literal|0
condition|)
return|return;
name|vtnet_txq_eof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|again
label|:
name|enq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
if|if
condition|(
name|virtqueue_full
argument_list|(
name|vq
argument_list|)
condition|)
break|break;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|vtnet_txq_encap
argument_list|(
name|txq
argument_list|,
operator|&
name|m0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
operator|&&
name|vtnet_txq_notify
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tries
operator|++
operator|<
name|VTNET_NOTIFY_RETRIES
condition|)
goto|goto
name|again
goto|;
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_rescheduled
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txq
operator|->
name|vtntx_tq
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_intrtask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
literal|0
index|]
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|vtnet_start_locked
argument_list|(
name|txq
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !VTNET_LEGACY_TX */
end_comment

begin_function
specifier|static
name|int
name|vtnet_txq_mq_start_locked
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|buf_ring
modifier|*
name|br
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|enq
decl_stmt|,
name|tries
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
name|br
operator|=
name|txq
operator|->
name|vtntx_br
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|tries
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|VTNET_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|vtnet_link_active
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vtnet_txq_eof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|again
label|:
name|enq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|drbr_peek
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|virtqueue_full
argument_list|(
name|vq
argument_list|)
condition|)
block|{
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vtnet_txq_encap
argument_list|(
name|txq
argument_list|,
operator|&
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|drbr_putback
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
break|break;
block|}
name|drbr_advance
argument_list|(
name|ifp
argument_list|,
name|br
argument_list|)
expr_stmt|;
name|enq
operator|++
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
operator|&&
name|vtnet_txq_notify
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tries
operator|++
operator|<
name|VTNET_NOTIFY_RETRIES
condition|)
goto|goto
name|again
goto|;
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_rescheduled
operator|++
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txq
operator|->
name|vtntx_tq
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_intrtask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_mq_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|npairs
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|npairs
operator|=
name|sc
operator|->
name|vtnet_act_vq_pairs
expr_stmt|;
comment|/* check if flowid is set */
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|i
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|%
name|npairs
expr_stmt|;
else|else
name|i
operator|=
name|curcpu
operator|%
name|npairs
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|VTNET_TXQ_TRYLOCK
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|vtnet_txq_mq_start_locked
argument_list|(
name|txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|txq
operator|->
name|vtntx_br
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|txq
operator|->
name|vtntx_tq
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_defrtask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_txq_tq_deferred
parameter_list|(
name|void
modifier|*
name|xtxq
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|txq
operator|=
name|xtxq
expr_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|sc
operator|->
name|vtnet_ifp
argument_list|,
name|txq
operator|->
name|vtntx_br
argument_list|)
condition|)
name|vtnet_txq_mq_start_locked
argument_list|(
name|txq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VTNET_LEGACY_TX */
end_comment

begin_function
specifier|static
name|void
name|vtnet_txq_start
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|VTNET_LEGACY_TX
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|vtnet_start_locked
argument_list|(
name|txq
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|txq
operator|->
name|vtntx_br
argument_list|)
condition|)
name|vtnet_txq_mq_start_locked
argument_list|(
name|txq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_txq_tq_intr
parameter_list|(
name|void
modifier|*
name|xtxq
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|txq
operator|=
name|xtxq
expr_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return;
block|}
name|vtnet_txq_eof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|vtnet_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_eof
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|deq
decl_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
name|deq
operator|=
literal|0
expr_stmt|;
name|VTNET_TXQ_LOCK_ASSERT
argument_list|(
name|txq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|netmap_tx_irq
argument_list|(
name|txq
operator|->
name|vtntx_sc
operator|->
name|vtnet_ifp
argument_list|,
name|txq
operator|->
name|vtntx_id
argument_list|)
condition|)
block|{
name|virtqueue_disable_intr
argument_list|(
name|vq
argument_list|)
expr_stmt|;
comment|// XXX luigi
return|return
literal|0
return|;
comment|// XXX or 1 ?
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
while|while
condition|(
operator|(
name|txhdr
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|txhdr
operator|->
name|vth_mbuf
expr_stmt|;
name|deq
operator|++
expr_stmt|;
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_opackets
operator|++
expr_stmt|;
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|txq
operator|->
name|vtntx_stats
operator|.
name|vtxs_omcasts
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
condition|)
name|txq
operator|->
name|vtntx_watchdog
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|deq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_tx_vq_intr
parameter_list|(
name|void
modifier|*
name|xtxq
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|txq
operator|=
name|xtxq
expr_stmt|;
name|sc
operator|=
name|txq
operator|->
name|vtntx_sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|txq
operator|->
name|vtntx_id
operator|>=
name|sc
operator|->
name|vtnet_act_vq_pairs
argument_list|)
condition|)
block|{
comment|/* 		 * Ignore this interrupt. Either this is a spurious interrupt 		 * or multiqueue without per-VQ MSIX so every queue needs to 		 * be polled (a brain dead configuration we could try harder 		 * to avoid). 		 */
name|vtnet_txq_disable_intr
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return;
block|}
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return;
block|}
name|vtnet_txq_eof
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|vtnet_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_tx_start_all
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|vtnet_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
end_ifndef

begin_function
specifier|static
name|void
name|vtnet_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|txq
operator|->
name|vtntx_br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vtnet_watchdog
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|txq
operator|->
name|vtntx_sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_watchdog
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Only drain completed frames if the watchdog is about to 		 * expire. If any frames were drained, there may be enough 		 * free descriptors now available to transmit queued frames. 		 * In that case, the timer will immediately be decremented 		 * below, but the timeout is generous enough that should not 		 * be a problem. 		 */
if|if
condition|(
name|vtnet_txq_eof
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
condition|)
name|vtnet_txq_start
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|vtntx_watchdog
operator|==
literal|0
operator|||
operator|--
name|txq
operator|->
name|vtntx_watchdog
condition|)
block|{
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"watchdog timeout on queue %d\n"
argument_list|,
name|txq
operator|->
name|vtntx_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_accum_stats
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vtnet_rxq_stats
modifier|*
name|rxacc
parameter_list|,
name|struct
name|vtnet_txq_stats
modifier|*
name|txacc
parameter_list|)
block|{
name|bzero
argument_list|(
name|rxacc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rxq_stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|txacc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_txq_stats
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|vtnet_rxq_stats
modifier|*
name|rxst
decl_stmt|;
name|struct
name|vtnet_txq_stats
modifier|*
name|txst
decl_stmt|;
name|rxst
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
operator|.
name|vtnrx_stats
expr_stmt|;
name|rxacc
operator|->
name|vrxs_ipackets
operator|+=
name|rxst
operator|->
name|vrxs_ipackets
expr_stmt|;
name|rxacc
operator|->
name|vrxs_ibytes
operator|+=
name|rxst
operator|->
name|vrxs_ibytes
expr_stmt|;
name|rxacc
operator|->
name|vrxs_iqdrops
operator|+=
name|rxst
operator|->
name|vrxs_iqdrops
expr_stmt|;
name|rxacc
operator|->
name|vrxs_csum
operator|+=
name|rxst
operator|->
name|vrxs_csum
expr_stmt|;
name|rxacc
operator|->
name|vrxs_csum_failed
operator|+=
name|rxst
operator|->
name|vrxs_csum_failed
expr_stmt|;
name|rxacc
operator|->
name|vrxs_rescheduled
operator|+=
name|rxst
operator|->
name|vrxs_rescheduled
expr_stmt|;
name|txst
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
operator|.
name|vtntx_stats
expr_stmt|;
name|txacc
operator|->
name|vtxs_opackets
operator|+=
name|txst
operator|->
name|vtxs_opackets
expr_stmt|;
name|txacc
operator|->
name|vtxs_obytes
operator|+=
name|txst
operator|->
name|vtxs_obytes
expr_stmt|;
name|txacc
operator|->
name|vtxs_csum
operator|+=
name|txst
operator|->
name|vtxs_csum
expr_stmt|;
name|txacc
operator|->
name|vtxs_tso
operator|+=
name|txst
operator|->
name|vtxs_tso
expr_stmt|;
name|txacc
operator|->
name|vtxs_rescheduled
operator|+=
name|txst
operator|->
name|vtxs_rescheduled
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vtnet_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vtnet_rxq_stats
name|rxaccum
decl_stmt|;
name|struct
name|vtnet_txq_stats
name|txaccum
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|vtnet_accum_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|rxaccum
argument_list|,
operator|&
name|txaccum
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|rxaccum
operator|.
name|vrxs_ipackets
operator|)
return|;
case|case
name|IFCOUNTER_IQDROPS
case|:
return|return
operator|(
name|rxaccum
operator|.
name|vrxs_iqdrops
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|rxaccum
operator|.
name|vrxs_ierrors
operator|)
return|;
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|txaccum
operator|.
name|vtxs_opackets
operator|)
return|;
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
case|case
name|IFCOUNTER_OBYTES
case|:
return|return
operator|(
name|txaccum
operator|.
name|vtxs_obytes
operator|)
return|;
case|case
name|IFCOUNTER_OMCASTS
case|:
return|return
operator|(
name|txaccum
operator|.
name|vtxs_omcasts
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|timedout
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|timedout
operator|=
literal|0
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
name|timedout
operator||=
name|vtnet_watchdog
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|timedout
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|callout_schedule
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_start_taskqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
comment|/* 	 * Errors here are very difficult to recover from - we cannot 	 * easily fail because, if this is during boot, we will hang 	 * when freeing any successfully started taskqueues because 	 * the scheduler isn't up yet. 	 * 	 * Most drivers just ignore the return value - it only fails 	 * with ENOMEM so an error is not likely. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|rxq
operator|->
name|vtnrx_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s rxq %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rxq
operator|->
name|vtnrx_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to start rx taskq %d\n"
argument_list|,
name|rxq
operator|->
name|vtnrx_id
argument_list|)
expr_stmt|;
block|}
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|taskqueue_start_threads
argument_list|(
operator|&
name|txq
operator|->
name|vtntx_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s txq %d"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txq
operator|->
name|vtntx_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to start tx taskq %d\n"
argument_list|,
name|txq
operator|->
name|vtntx_id
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_taskqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|vtnrx_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|rxq
operator|->
name|vtnrx_tq
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|vtnrx_vq
operator|=
name|NULL
expr_stmt|;
block|}
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_free
argument_list|(
name|txq
operator|->
name|vtntx_tq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|vtntx_tq
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_drain_taskqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|vtnrx_tq
operator|!=
name|NULL
condition|)
name|taskqueue_drain
argument_list|(
name|rxq
operator|->
name|vtnrx_tq
argument_list|,
operator|&
name|rxq
operator|->
name|vtnrx_intrtask
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|vtntx_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|txq
operator|->
name|vtntx_tq
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_intrtask
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VTNET_LEGACY_TX
name|taskqueue_drain
argument_list|(
name|txq
operator|->
name|vtntx_tq
argument_list|,
operator|&
name|txq
operator|->
name|vtntx_defrtask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_drain_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|nm_native_on
argument_list|(
name|NA
argument_list|(
name|sc
operator|->
name|vtnet_ifp
argument_list|)
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DEV_NETMAP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
name|vtnet_rxq_free_mbufs
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|vtnet_txq_free_mbufs
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_stop_rendezvous
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Lock and unlock the per-queue mutex so we known the stop 	 * state is visible. Doing only the active queues should be 	 * sufficient, but it does not cost much extra to do all the 	 * queues. Note we hold the core mutex here too. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
name|VTNET_RXQ_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|VTNET_TXQ_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|VTNET_TXQ_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_stop
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|vtnet_link_active
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|)
expr_stmt|;
comment|/* Only advisory. */
name|vtnet_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the host adapter. This resets it to the pre-initialized 	 * state. It will not generate any interrupts until after it is 	 * reinitialized. 	 */
name|virtio_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vtnet_stop_rendezvous
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Free any mbufs left in the virtqueues. */
name|vtnet_drain_rxtx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_virtio_reinit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint64_t
name|features
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|features
operator|=
name|sc
operator|->
name|vtnet_features
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
name|mask
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
name|mask
operator||=
name|IFCAP_RXCSUM_IPV6
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Re-negotiate with the host, removing any disabled receive 	 * features. Transmit features are disabled only on our side 	 * via if_capenable and if_hwassist. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|mask
condition|)
block|{
comment|/* 		 * We require both IPv4 and IPv6 offloading to be enabled 		 * in order to negotiated it: VirtIO does not distinguish 		 * between the two. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
name|features
operator|&=
operator|~
name|VIRTIO_NET_F_GUEST_CSUM
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_LRO
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|==
literal|0
condition|)
name|features
operator|&=
operator|~
name|VTNET_LRO_FEATURES
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
operator|==
literal|0
condition|)
name|features
operator|&=
operator|~
name|VIRTIO_NET_F_CTRL_VLAN
expr_stmt|;
block|}
name|error
operator|=
name|virtio_reinit
argument_list|(
name|dev
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"virtio reinit error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_init_rx_filters
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
condition|)
block|{
comment|/* Restore promiscuous and all-multicast modes. */
name|vtnet_rx_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Restore filtered MAC addresses. */
name|vtnet_rx_filter_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|vtnet_rx_filter_vlan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_init_rx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|vtnet_rxq
modifier|*
name|rxq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clsize
decl_stmt|,
name|error
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
comment|/* 	 * Use the new cluster size if one has been set (via a MTU 	 * change). Otherwise, use the standard 2K clusters. 	 * 	 * BMV: It might make sense to use page sized clusters as 	 * the default (depending on the features negotiated). 	 */
if|if
condition|(
name|sc
operator|->
name|vtnet_rx_new_clsize
operator|!=
literal|0
condition|)
block|{
name|clsize
operator|=
name|sc
operator|->
name|vtnet_rx_new_clsize
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_new_clsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|clsize
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_clsize
operator|=
name|clsize
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_nmbufs
operator|=
name|VTNET_NEEDED_RX_MBUFS
argument_list|(
name|sc
argument_list|,
name|clsize
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|||
name|sc
operator|->
name|vtnet_rx_nmbufs
operator|<
name|sc
operator|->
name|vtnet_rx_nsegs
argument_list|,
operator|(
literal|"%s: too many rx mbufs %d for %d segments"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|vtnet_rx_nmbufs
operator|,
name|sc
operator|->
name|vtnet_rx_nsegs
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|vtnet_netmap_init_rx_buffers
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* DEV_NETMAP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|rxq
operator|=
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
expr_stmt|;
comment|/* Hold the lock to satisfy asserts. */
name|VTNET_RXQ_LOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_rxq_populate
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|VTNET_RXQ_UNLOCK
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate mbufs for Rx queue %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_init_tx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_txq
modifier|*
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|txq
operator|=
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
expr_stmt|;
name|txq
operator|->
name|vtntx_watchdog
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_init_rxtx_queues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vtnet_init_rx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vtnet_init_tx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_set_active_vq_pairs
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|npairs
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MULTIQ
operator|)
operator|==
literal|0
condition|)
block|{
name|MPASS
argument_list|(
name|sc
operator|->
name|vtnet_max_vq_pairs
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_act_vq_pairs
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* BMV: Just use the maximum configured for now. */
name|npairs
operator|=
name|sc
operator|->
name|vtnet_max_vq_pairs
expr_stmt|;
if|if
condition|(
name|vtnet_ctrl_mq_cmd
argument_list|(
name|sc
argument_list|,
name|npairs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot set active queue pairs to %d\n"
argument_list|,
name|npairs
argument_list|)
expr_stmt|;
name|npairs
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|vtnet_act_vq_pairs
operator|=
name|npairs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_reinit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
comment|/* Use the current MAC address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|vtnet_set_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_set_active_vq_pairs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|VTNET_CSUM_OFFLOAD
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|VTNET_CSUM_OFFLOAD_IPV6
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP_TSO
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO6
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_IP6_TSO
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
condition|)
name|vtnet_init_rx_filters
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_init_rxtx_queues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vtnet_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_init_locked
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reinitialize with the host. */
if|if
condition|(
name|vtnet_virtio_reinit
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|vtnet_reinit
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|virtio_reinit_complete
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vtnet_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|,
name|hz
argument_list|,
name|vtnet_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
operator|!
name|NA
argument_list|(
name|sc
operator|->
name|vtnet_ifp
argument_list|)
condition|)
block|{
name|D
argument_list|(
literal|"try to attach again"
argument_list|)
expr_stmt|;
name|vtnet_netmap_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEV_NETMAP */
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_ctrl_vq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_ctrl_vq
expr_stmt|;
comment|/* 	 * The control virtqueue is only polled and therefore it should 	 * already be empty. 	 */
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
argument_list|,
operator|(
literal|"%s: ctrl vq %p not empty"
operator|,
name|__func__
operator|,
name|vq
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_exec_ctrl_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|int
name|readable
parameter_list|,
name|int
name|writable
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_ctrl_vq
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
argument_list|,
operator|(
literal|"%s: CTRL_VQ feature not negotiated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
condition|)
return|return;
if|if
condition|(
name|virtqueue_enqueue
argument_list|(
name|vq
argument_list|,
name|cookie
argument_list|,
name|sg
argument_list|,
name|readable
argument_list|,
name|writable
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Poll for the response, but the command is likely already 	 * done when we return from the notify. 	 */
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
name|virtqueue_poll
argument_list|(
name|vq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ctrl_mac_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|hwaddr
parameter_list|)
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
name|__aligned
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
name|int
name|error
decl_stmt|;
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_MAC
expr_stmt|;
name|hdr
operator|.
name|cmd
operator|=
name|VIRTIO_NET_CTRL_MAC_ADDR_SET
expr_stmt|;
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|3
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
name|hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|3
argument_list|,
operator|(
literal|"%s: error %d adding set MAC msg to sglist"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ack
operator|==
name|VIRTIO_NET_OK
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ctrl_mq_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|npairs
parameter_list|)
block|{
name|struct
name|sglist_seg
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
struct|struct
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
decl_stmt|;
name|uint8_t
name|pad1
decl_stmt|;
name|struct
name|virtio_net_ctrl_mq
name|mq
decl_stmt|;
name|uint8_t
name|pad2
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
block|}
name|s
name|__aligned
argument_list|(
literal|2
argument_list|)
struct|;
name|int
name|error
decl_stmt|;
name|s
operator|.
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_MQ
expr_stmt|;
name|s
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET
expr_stmt|;
name|s
operator|.
name|mq
operator|.
name|virtqueue_pairs
operator|=
name|npairs
expr_stmt|;
name|s
operator|.
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|3
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|mq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_mq
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|3
argument_list|,
operator|(
literal|"%s: error %d adding MQ message to sglist"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|s
operator|.
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|.
name|ack
operator|==
name|VIRTIO_NET_OK
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ctrl_rx_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|struct
name|sglist_seg
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
struct|struct
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
decl_stmt|;
name|uint8_t
name|pad1
decl_stmt|;
name|uint8_t
name|onoff
decl_stmt|;
name|uint8_t
name|pad2
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
block|}
name|s
name|__aligned
argument_list|(
literal|2
argument_list|)
struct|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
argument_list|,
operator|(
literal|"%s: CTRL_RX feature not negotiated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|s
operator|.
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_RX
expr_stmt|;
name|s
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|s
operator|.
name|onoff
operator|=
operator|!
operator|!
name|on
expr_stmt|;
name|s
operator|.
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|3
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|onoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|3
argument_list|,
operator|(
literal|"%s: error %d adding Rx message to sglist"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|s
operator|.
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|.
name|ack
operator|==
name|VIRTIO_NET_OK
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_set_promisc
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
return|return
operator|(
name|vtnet_ctrl_rx_cmd
argument_list|(
name|sc
argument_list|,
name|VIRTIO_NET_CTRL_RX_PROMISC
argument_list|,
name|on
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_set_allmulti
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
return|return
operator|(
name|vtnet_ctrl_rx_cmd
argument_list|(
name|sc
argument_list|,
name|VIRTIO_NET_CTRL_RX_ALLMULTI
argument_list|,
name|on
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The device defaults to promiscuous mode for backwards compatibility.  * Turn it off at attach time if possible.  */
end_comment

begin_function
specifier|static
name|void
name|vtnet_attach_disable_promisc
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vtnet_set_promisc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|,
literal|"cannot disable default promiscuous mode\n"
argument_list|)
expr_stmt|;
block|}
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_set_promisc
argument_list|(
name|sc
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot %s promiscuous mode\n"
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_set_allmulti
argument_list|(
name|sc
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot %s all-multicast mode\n"
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_filter_mac
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
name|__aligned
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|struct
name|vtnet_mac_filter
modifier|*
name|filter
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|ucnt
decl_stmt|,
name|mcnt
decl_stmt|,
name|promisc
decl_stmt|,
name|allmulti
decl_stmt|,
name|error
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|filter
operator|=
name|sc
operator|->
name|vtnet_mac_filter
expr_stmt|;
name|ucnt
operator|=
literal|0
expr_stmt|;
name|mcnt
operator|=
literal|0
expr_stmt|;
name|promisc
operator|=
literal|0
expr_stmt|;
name|allmulti
operator|=
literal|0
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
argument_list|,
operator|(
literal|"%s: CTRL_RX feature not negotiated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Unicast MAC addresses: */
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ucnt
operator|==
name|VTNET_MAX_MAC_ENTRIES
condition|)
block|{
name|promisc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
operator|&
name|filter
operator|->
name|vmf_unicast
operator|.
name|macs
index|[
name|ucnt
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ucnt
operator|++
expr_stmt|;
block|}
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|promisc
operator|!=
literal|0
condition|)
block|{
name|filter
operator|->
name|vmf_unicast
operator|.
name|nentries
operator|=
literal|0
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"more than %d MAC addresses assigned, "
literal|"falling back to promiscuous mode\n"
argument_list|,
name|VTNET_MAX_MAC_ENTRIES
argument_list|)
expr_stmt|;
block|}
else|else
name|filter
operator|->
name|vmf_unicast
operator|.
name|nentries
operator|=
name|ucnt
expr_stmt|;
comment|/* Multicast MAC addresses: */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|mcnt
operator|==
name|VTNET_MAX_MAC_ENTRIES
condition|)
block|{
name|allmulti
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|filter
operator|->
name|vmf_multicast
operator|.
name|macs
index|[
name|mcnt
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|allmulti
operator|!=
literal|0
condition|)
block|{
name|filter
operator|->
name|vmf_multicast
operator|.
name|nentries
operator|=
literal|0
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"more than %d multicast MAC addresses "
literal|"assigned, falling back to all-multicast mode\n"
argument_list|,
name|VTNET_MAX_MAC_ENTRIES
argument_list|)
expr_stmt|;
block|}
else|else
name|filter
operator|->
name|vmf_multicast
operator|.
name|nentries
operator|=
name|mcnt
expr_stmt|;
if|if
condition|(
name|promisc
operator|!=
literal|0
operator|&&
name|allmulti
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_MAC
expr_stmt|;
name|hdr
operator|.
name|cmd
operator|=
name|VIRTIO_NET_CTRL_MAC_TABLE_SET
expr_stmt|;
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|4
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|filter
operator|->
name|vmf_unicast
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|filter
operator|->
name|vmf_unicast
operator|.
name|nentries
operator|*
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|filter
operator|->
name|vmf_multicast
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|filter
operator|->
name|vmf_multicast
operator|.
name|nentries
operator|*
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|4
argument_list|,
operator|(
literal|"%s: error %d adding MAC filter msg to sglist"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|!=
name|VIRTIO_NET_OK
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"error setting host MAC filter table\n"
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|promisc
operator|!=
literal|0
operator|&&
name|vtnet_set_promisc
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot enable promiscuous mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allmulti
operator|!=
literal|0
operator|&&
name|vtnet_set_allmulti
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot enable all-multicast mode\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_exec_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|add
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
name|struct
name|sglist_seg
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
struct|struct
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
decl_stmt|;
name|uint8_t
name|pad1
decl_stmt|;
name|uint16_t
name|tag
decl_stmt|;
name|uint8_t
name|pad2
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
block|}
name|s
name|__aligned
argument_list|(
literal|2
argument_list|)
struct|;
name|int
name|error
decl_stmt|;
name|s
operator|.
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_VLAN
expr_stmt|;
name|s
operator|.
name|hdr
operator|.
name|cmd
operator|=
name|add
condition|?
name|VIRTIO_NET_CTRL_VLAN_ADD
else|:
name|VIRTIO_NET_CTRL_VLAN_DEL
expr_stmt|;
name|s
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
name|s
operator|.
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|3
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|s
operator|.
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|3
argument_list|,
operator|(
literal|"%s: error %d adding VLAN message to sglist"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|s
operator|.
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|.
name|ack
operator|==
name|VIRTIO_NET_OK
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_filter_vlan
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|w
decl_stmt|;
name|uint16_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_VLAN_FILTER
argument_list|,
operator|(
literal|"%s: VLAN_FILTER feature not negotiated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable the filter for each configured VLAN. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTNET_VLAN_FILTER_NWORDS
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|sc
operator|->
name|vtnet_vlan_filter
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|bit
operator|=
name|ffs
argument_list|(
name|w
argument_list|)
operator|-
literal|1
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|w
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
name|tag
operator|=
sizeof|sizeof
argument_list|(
name|w
argument_list|)
operator|*
name|CHAR_BIT
operator|*
name|i
operator|+
name|bit
expr_stmt|;
if|if
condition|(
name|vtnet_exec_vlan_filter
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|,
literal|"cannot enable VLAN %d filter\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_update_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|add
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|bit
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|idx
operator|=
operator|(
name|tag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|tag
operator|&
literal|0x1F
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
name|tag
operator|>
literal|4095
condition|)
return|return;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
name|sc
operator|->
name|vtnet_vlan_filter
index|[
name|idx
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
else|else
name|sc
operator|->
name|vtnet_vlan_filter
index|[
name|idx
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
operator|&&
name|vtnet_exec_vlan_filter
argument_list|(
name|sc
argument_list|,
name|add
argument_list|,
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|,
literal|"cannot %s VLAN %d %s the host filter table\n"
argument_list|,
name|add
condition|?
literal|"add"
else|:
literal|"remove"
argument_list|,
name|tag
argument_list|,
name|add
condition|?
literal|"to"
else|:
literal|"from"
argument_list|)
expr_stmt|;
block|}
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
name|vtnet_update_vlan_filter
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
name|vtnet_update_vlan_filter
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_is_link_up
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_LINKSTATE
operator|)
operator|==
literal|0
condition|)
name|status
operator|=
name|VIRTIO_NET_S_LINK_UP
expr_stmt|;
else|else
name|status
operator|=
name|virtio_read_dev_config_2
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|status
operator|&
name|VIRTIO_NET_S_LINK_UP
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_update_link_status
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|link
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_CORE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|link
operator|=
name|vtnet_is_link_up
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Notify if the link status has changed. */
if|if
condition|(
name|link
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|vtnet_link_active
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|vtnet_link_active
operator|=
literal|1
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link
operator|==
literal|0
operator|&&
name|sc
operator|->
name|vtnet_link_active
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|vtnet_link_active
operator|=
literal|0
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|vtnet_media
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|VTNET_CORE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_is_link_up
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|VTNET_MEDIATYPE
expr_stmt|;
block|}
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
name|VTNET_CORE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_set_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_MAC
condition|)
block|{
if|if
condition|(
name|vtnet_ctrl_mac_cmd
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to set MAC address\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MAC
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|virtio_write_dev_config_1
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|mac
argument_list|)
operator|+
name|i
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_get_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MAC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Generate a random locally administered unicast address. 		 * 		 * It would be nice to generate the same MAC address across 		 * reboots, but it seems all the hosts currently available 		 * support the MAC feature, so this isn't too important. 		 */
name|sc
operator|->
name|vtnet_hwaddr
index|[
literal|0
index|]
operator|=
literal|0xB2
expr_stmt|;
name|arc4rand
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_hwaddr
index|[
literal|1
index|]
argument_list|,
name|ETHER_ADDR_LEN
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vtnet_set_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|vtnet_hwaddr
index|[
name|i
index|]
operator|=
name|virtio_read_dev_config_1
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|mac
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_vlan_tag_remove
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_tag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
comment|/* Strip the 802.1Q header. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evh
argument_list|,
operator|(
name|char
operator|*
operator|)
name|evh
operator|+
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|ETHER_HDR_LEN
operator|-
name|ETHER_TYPE_LEN
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_VLAN_ENCAP_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_set_rx_process_limit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|limit
decl_stmt|;
name|limit
operator|=
name|vtnet_tunable_int
argument_list|(
name|sc
argument_list|,
literal|"rx_process_limit"
argument_list|,
name|vtnet_rx_process_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
name|limit
operator|=
name|INT_MAX
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_process_limit
operator|=
name|limit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_set_tx_intr_threshold
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|size
decl_stmt|,
name|thresh
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|size
operator|=
name|virtqueue_size
argument_list|(
name|sc
operator|->
name|vtnet_txqs
index|[
literal|0
index|]
operator|.
name|vtntx_vq
argument_list|)
expr_stmt|;
comment|/* 	 * The Tx interrupt is disabled until the queue free count falls 	 * below our threshold. Completed frames are drained from the Tx 	 * virtqueue before transmitting new frames and in the watchdog 	 * callout, so the frequency of Tx interrupts is greatly reduced, 	 * at the cost of not freeing mbufs as quickly as they otherwise 	 * would be. 	 * 	 * N.B. We assume all the Tx queues are the same size. 	 */
name|thresh
operator|=
name|size
operator|/
literal|4
expr_stmt|;
comment|/* 	 * Without indirect descriptors, leave enough room for the most 	 * segments we handle. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_INDIRECT
operator|)
operator|==
literal|0
operator|&&
name|thresh
operator|<
name|sc
operator|->
name|vtnet_tx_nsegs
condition|)
name|thresh
operator|=
name|sc
operator|->
name|vtnet_tx_nsegs
expr_stmt|;
name|sc
operator|->
name|vtnet_tx_intr_thresh
operator|=
name|thresh
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_setup_rxq_sysctl
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|list
decl_stmt|;
name|struct
name|vtnet_rxq_stats
modifier|*
name|stats
decl_stmt|;
name|char
name|namebuf
index|[
literal|16
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|,
literal|"rxq%d"
argument_list|,
name|rxq
operator|->
name|vtnrx_id
argument_list|)
expr_stmt|;
name|node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Receive Queue"
argument_list|)
expr_stmt|;
name|list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|&
name|rxq
operator|->
name|vtnrx_stats
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ipackets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_ipackets
argument_list|,
literal|"Receive packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ibytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_ibytes
argument_list|,
literal|"Receive bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"iqdrops"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_iqdrops
argument_list|,
literal|"Receive drops"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ierrors"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_ierrors
argument_list|,
literal|"Receive errors"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_csum
argument_list|,
literal|"Receive checksum offloaded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_csum_failed
argument_list|,
literal|"Receive checksum offload failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rescheduled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vrxs_rescheduled
argument_list|,
literal|"Receive interrupt handler rescheduled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_setup_txq_sysctl
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|list
decl_stmt|;
name|struct
name|vtnet_txq_stats
modifier|*
name|stats
decl_stmt|;
name|char
name|namebuf
index|[
literal|16
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|,
literal|"txq%d"
argument_list|,
name|txq
operator|->
name|vtntx_id
argument_list|)
expr_stmt|;
name|node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Transmit Queue"
argument_list|)
expr_stmt|;
name|list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|&
name|txq
operator|->
name|vtntx_stats
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"opackets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vtxs_opackets
argument_list|,
literal|"Transmit packets"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"obytes"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vtxs_obytes
argument_list|,
literal|"Transmit bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"omcasts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vtxs_omcasts
argument_list|,
literal|"Transmit multicasts"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"csum"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vtxs_csum
argument_list|,
literal|"Transmit checksum offloaded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tso"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vtxs_tso
argument_list|,
literal|"Transmit segmentation offloaded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rescheduled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|vtxs_rescheduled
argument_list|,
literal|"Transmit interrupt handler rescheduled"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_setup_queue_sysctl
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_max_vq_pairs
condition|;
name|i
operator|++
control|)
block|{
name|vtnet_setup_rxq_sysctl
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vtnet_setup_txq_sysctl
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_setup_stat_sysctl
parameter_list|(
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
parameter_list|,
name|struct
name|sysctl_oid_list
modifier|*
name|child
parameter_list|,
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vtnet_statistics
modifier|*
name|stats
decl_stmt|;
name|struct
name|vtnet_rxq_stats
name|rxaccum
decl_stmt|;
name|struct
name|vtnet_txq_stats
name|txaccum
decl_stmt|;
name|vtnet_accum_stats
argument_list|(
name|sc
argument_list|,
operator|&
name|rxaccum
argument_list|,
operator|&
name|txaccum
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|&
name|sc
operator|->
name|vtnet_stats
expr_stmt|;
name|stats
operator|->
name|rx_csum_offloaded
operator|=
name|rxaccum
operator|.
name|vrxs_csum
expr_stmt|;
name|stats
operator|->
name|rx_csum_failed
operator|=
name|rxaccum
operator|.
name|vrxs_csum_failed
expr_stmt|;
name|stats
operator|->
name|rx_task_rescheduled
operator|=
name|rxaccum
operator|.
name|vrxs_rescheduled
expr_stmt|;
name|stats
operator|->
name|tx_csum_offloaded
operator|=
name|txaccum
operator|.
name|vtxs_csum
expr_stmt|;
name|stats
operator|->
name|tx_tso_offloaded
operator|=
name|txaccum
operator|.
name|vtxs_tso
expr_stmt|;
name|stats
operator|->
name|tx_task_rescheduled
operator|=
name|txaccum
operator|.
name|vtxs_rescheduled
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_alloc_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mbuf_alloc_failed
argument_list|,
literal|"Mbuf cluster allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frame_too_large"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_frame_too_large
argument_list|,
literal|"Received frame larger than the mbuf chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_enq_replacement_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_enq_replacement_failed
argument_list|,
literal|"Enqueuing the replacement receive mbuf failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_mergeable_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_mergeable_failed
argument_list|,
literal|"Mergeable buffers receive failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_ethtype"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_ethtype
argument_list|,
literal|"Received checksum offloaded buffer with unsupported "
literal|"Ethernet type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_ipproto"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_ipproto
argument_list|,
literal|"Received checksum offloaded buffer with incorrect IP protocol"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_offset"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_offset
argument_list|,
literal|"Received checksum offloaded buffer with incorrect offset"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_proto"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_proto
argument_list|,
literal|"Received checksum offloaded buffer with incorrect protocol"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_failed
argument_list|,
literal|"Received buffer checksum offload failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_offloaded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_offloaded
argument_list|,
literal|"Received buffer checksum offload succeeded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_task_rescheduled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_task_rescheduled
argument_list|,
literal|"Times the receive interrupt task rescheduled itself"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_csum_bad_ethtype"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_csum_bad_ethtype
argument_list|,
literal|"Aborted transmit of checksum offloaded buffer with unknown "
literal|"Ethernet type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_tso_bad_ethtype"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_tso_bad_ethtype
argument_list|,
literal|"Aborted transmit of TSO buffer with unknown Ethernet type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_tso_not_tcp"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_tso_not_tcp
argument_list|,
literal|"Aborted transmit of TSO buffer with non TCP protocol"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_defragged"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_defragged
argument_list|,
literal|"Transmit mbufs defragged"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_defrag_failed
argument_list|,
literal|"Aborted transmit of buffer because defrag failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_csum_offloaded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_csum_offloaded
argument_list|,
literal|"Offloaded checksum of transmitted buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_tso_offloaded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_tso_offloaded
argument_list|,
literal|"Segmentation offload of transmitted buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_task_rescheduled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_task_rescheduled
argument_list|,
literal|"Times the transmit interrupt task rescheduled itself"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_setup_sysctl
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_vq_pairs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_max_vq_pairs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of supported virtqueue pairs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"act_vq_pairs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_act_vq_pairs
argument_list|,
literal|0
argument_list|,
literal|"Number of active virtqueue pairs"
argument_list|)
expr_stmt|;
name|vtnet_setup_stat_sysctl
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxq_enable_intr
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
return|return
operator|(
name|virtqueue_enable_intr
argument_list|(
name|rxq
operator|->
name|vtnrx_vq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rxq_disable_intr
parameter_list|(
name|struct
name|vtnet_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|virtqueue_disable_intr
argument_list|(
name|rxq
operator|->
name|vtnrx_vq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_txq_enable_intr
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|vq
operator|=
name|txq
operator|->
name|vtntx_vq
expr_stmt|;
if|if
condition|(
name|vtnet_txq_below_threshold
argument_list|(
name|txq
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|virtqueue_postpone_intr
argument_list|(
name|vq
argument_list|,
name|VQ_POSTPONE_LONG
argument_list|)
operator|)
return|;
comment|/* 	 * The free count is above our threshold. Keep the Tx interrupt 	 * disabled until the queue is fuller. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_txq_disable_intr
parameter_list|(
name|struct
name|vtnet_txq
modifier|*
name|txq
parameter_list|)
block|{
name|virtqueue_disable_intr
argument_list|(
name|txq
operator|->
name|vtntx_vq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_enable_rx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
name|vtnet_rxq_enable_intr
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_enable_tx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
name|vtnet_txq_enable_intr
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_enable_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vtnet_enable_rx_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_enable_tx_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_disable_rx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
name|vtnet_rxq_disable_intr
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_rxqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_disable_tx_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|vtnet_act_vq_pairs
condition|;
name|i
operator|++
control|)
name|vtnet_txq_disable_intr
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_txqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_disable_interrupts
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vtnet_disable_rx_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_disable_tx_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_tunable_int
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|knob
parameter_list|,
name|int
name|def
parameter_list|)
block|{
name|char
name|path
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"hw.vtnet.%d.%s"
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|)
argument_list|,
name|knob
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
name|path
argument_list|,
operator|&
name|def
argument_list|)
expr_stmt|;
return|return
operator|(
name|def
operator|)
return|;
block|}
end_function

end_unit

