begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011, Bryan Venteicher<bryanv@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Driver for VirtIO network devices. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sglist.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/virtio.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/virtqueue.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/network/virtio_net.h>
end_include

begin_include
include|#
directive|include
file|<dev/virtio/network/if_vtnetvar.h>
end_include

begin_include
include|#
directive|include
file|"virtio_if.h"
end_include

begin_function_decl
specifier|static
name|int
name|vtnet_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_config_change
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_negotiate_features
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_alloc_virtqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_get_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_set_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_is_link_up
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_update_link_status
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_watchdog
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_change_mtu
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_init_rx_vq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_rx_mbufs
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_tx_mbufs
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_free_ctrl_vq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|vtnet_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_alloc_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_replace_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_newbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_discard_merged_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_discard_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_enqueue_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_vlan_tag_remove
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rx_csum
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxeof_merged
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_rxeof
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_vq_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_txeof
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_tx_offload
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_enqueue_txbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|vtnet_tx_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_encap
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_tx_vq_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_stop
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_reinit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_init_locked
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_exec_ctrl_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|sglist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ctrl_rx_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_set_promisc
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_set_allmulti
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_filter_mac
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_exec_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_rx_filter_vlan
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_set_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_register_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_unregister_vlan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_add_statistics
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_enable_rx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vtnet_enable_tx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_disable_rx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vtnet_disable_tx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vtnet_csum_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.csum_disable"
argument_list|,
operator|&
name|vtnet_csum_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_tso_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.tso_disable"
argument_list|,
operator|&
name|vtnet_tso_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|vtnet_lro_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vtnet.lro_disable"
argument_list|,
operator|&
name|vtnet_lro_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Reducing the number of transmit completed interrupts can  * improve performance. To do so, the define below keeps the  * Tx vq interrupt disabled and adds calls to vtnet_txeof()  * in the start and watchdog paths. The price to pay for this  * is the m_free'ing of transmitted mbufs may be delayed until  * the watchdog fires.  */
end_comment

begin_define
define|#
directive|define
name|VTNET_TX_INTR_MODERATION
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|vtnet_tx_header_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|virtio_feature_desc
name|vtnet_feature_desc
index|[]
init|=
block|{
block|{
name|VIRTIO_NET_F_CSUM
block|,
literal|"TxChecksum"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_CSUM
block|,
literal|"RxChecksum"
block|}
block|,
block|{
name|VIRTIO_NET_F_MAC
block|,
literal|"MacAddress"
block|}
block|,
block|{
name|VIRTIO_NET_F_GSO
block|,
literal|"TxAllGSO"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_TSO4
block|,
literal|"RxTSOv4"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_TSO6
block|,
literal|"RxTSOv6"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_ECN
block|,
literal|"RxECN"
block|}
block|,
block|{
name|VIRTIO_NET_F_GUEST_UFO
block|,
literal|"RxUFO"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_TSO4
block|,
literal|"TxTSOv4"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_TSO6
block|,
literal|"TxTSOv6"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_ECN
block|,
literal|"TxTSOECN"
block|}
block|,
block|{
name|VIRTIO_NET_F_HOST_UFO
block|,
literal|"TxUFO"
block|}
block|,
block|{
name|VIRTIO_NET_F_MRG_RXBUF
block|,
literal|"MrgRxBuf"
block|}
block|,
block|{
name|VIRTIO_NET_F_STATUS
block|,
literal|"Status"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_VQ
block|,
literal|"ControlVq"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_RX
block|,
literal|"RxMode"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_VLAN
block|,
literal|"VLanFilter"
block|}
block|,
block|{
name|VIRTIO_NET_F_CTRL_RX_EXTRA
block|,
literal|"RxModeExtra"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|vtnet_methods
index|[]
init|=
block|{
comment|/* Device methods. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|vtnet_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|vtnet_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|vtnet_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|vtnet_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|vtnet_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|vtnet_shutdown
argument_list|)
block|,
comment|/* VirtIO methods. */
name|DEVMETHOD
argument_list|(
name|virtio_config_change
argument_list|,
name|vtnet_config_change
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|vtnet_driver
init|=
block|{
literal|"vtnet"
block|,
name|vtnet_methods
block|,
expr|sizeof
operator|(
expr|struct
name|vtnet_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vtnet_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vtnet
argument_list|,
name|virtio_pci
argument_list|,
name|vtnet_driver
argument_list|,
name|vtnet_devclass
argument_list|,
name|vtnet_modevent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|vtnet
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vtnet
argument_list|,
name|virtio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|vtnet_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|vtnet_tx_header_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"vtnet_tx_hdr"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_tx_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_QUIESCE
case|:
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|uma_zone_get_cur
argument_list|(
name|vtnet_tx_header_zone
argument_list|)
operator|>
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|MOD_UNLOAD
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|vtnet_tx_header_zone
argument_list|)
expr_stmt|;
name|vtnet_tx_header_zone
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|virtio_get_device_type
argument_list|(
name|dev
argument_list|)
operator|!=
name|VIRTIO_ID_NETWORK
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"VirtIO Networking Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|tx_size
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_dev
operator|=
name|dev
expr_stmt|;
name|VTNET_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|,
name|VTNET_MTX
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|vtnet_ifmedia_upd
argument_list|,
name|vtnet_ifmedia_sts
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|VTNET_MEDIATYPE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|VTNET_MEDIATYPE
argument_list|)
expr_stmt|;
name|vtnet_add_statistics
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|virtio_set_feature_desc
argument_list|(
name|dev
argument_list|,
name|vtnet_feature_desc
argument_list|)
expr_stmt|;
name|vtnet_negotiate_features
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MRG_RXBUF
argument_list|)
condition|)
block|{
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_MRG_RXBUFS
expr_stmt|;
name|sc
operator|->
name|vtnet_hdr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr_mrg_rxbuf
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|vtnet_hdr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_mbuf_size
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_mbuf_count
operator|=
name|VTNET_NEEDED_RX_MBUFS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_VQ
argument_list|)
condition|)
block|{
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_CTRL_VQ
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_RX
argument_list|)
condition|)
block|{
name|sc
operator|->
name|vtnet_mac_filter
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_mac_filter
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_mac_filter
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate mac filter table\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_CTRL_RX
expr_stmt|;
block|}
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CTRL_VLAN
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_VLAN_FILTER
expr_stmt|;
block|}
name|vtnet_get_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_alloc_virtqueues
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate virtqueues\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate ifnet structure\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|vtnet_init
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|vtnet_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|vtnet_ioctl
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_size
operator|=
name|virtqueue_size
argument_list|(
name|sc
operator|->
name|vtnet_rx_vq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_process_limit
operator|=
name|sc
operator|->
name|vtnet_rx_size
expr_stmt|;
name|tx_size
operator|=
name|virtqueue_size
argument_list|(
name|sc
operator|->
name|vtnet_tx_vq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_tx_size
operator|=
name|tx_size
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|tx_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|tx_size
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_STATUS
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LINKSTATE
expr_stmt|;
comment|/* Tell the upper layer(s) we support long frames. */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_CSUM
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_TSO4
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_TSO6
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_TSO6
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_TSO
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_HOST_ECN
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_TSO_ECN
expr_stmt|;
block|}
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GUEST_CSUM
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GUEST_TSO4
argument_list|)
operator|||
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_GUEST_TSO6
argument_list|)
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_HWCSUM
condition|)
block|{
comment|/* 		 * VirtIO does not support VLAN tagging, but we can fake 		 * it by inserting and removing the 802.1Q header during 		 * transmit and receive. We are then able to do checksum 		 * offloading of VLAN frames. 		 */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* 	 * Capabilities after here are not enabled by default. 	 */
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_VLAN_FILTER
condition|)
block|{
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|vtnet_register_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|vtnet_unregister_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|virtio_setup_intr
argument_list|(
name|dev
argument_list|,
name|INTR_TYPE_NET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup virtqueue interrupts\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Device defaults to promiscuous mode for backwards 	 * compatibility. Turn it off if possible. 	 */
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
condition|)
block|{
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_set_promisc
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot disable promiscuous mode\n"
argument_list|)
expr_stmt|;
block|}
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|error
condition|)
name|vtnet_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
name|VTNET_MTX
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"vtnet mutex not initialized"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_vlan_attach
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|sc
operator|->
name|vtnet_vlan_attach
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_attach
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_vlan_detach
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfg
argument_list|,
name|sc
operator|->
name|vtnet_vlan_detach
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_detach
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_mac_filter
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|vtnet_mac_filter
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_mac_filter
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_ifp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_rx_vq
operator|!=
name|NULL
condition|)
name|vtnet_free_rx_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_tx_vq
operator|!=
name|NULL
condition|)
name|vtnet_free_tx_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_ctrl_vq
operator|!=
name|NULL
condition|)
name|vtnet_free_ctrl_vq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|)
expr_stmt|;
name|VTNET_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_SUSPENDED
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_flags
operator|&=
operator|~
name|VTNET_FLAG_SUSPENDED
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Suspend already does all of what we need to 	 * do here; we just never expect to be resumed. 	 */
return|return
operator|(
name|vtnet_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_config_change
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_negotiate_features
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|,
name|features
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vtnet_csum_disable
condition|)
name|mask
operator||=
name|VIRTIO_NET_F_CSUM
operator||
name|VIRTIO_NET_F_GUEST_CSUM
expr_stmt|;
comment|/* 	 * TSO and LRO are only available when their corresponding 	 * checksum offload feature is also negotiated. 	 */
if|if
condition|(
name|vtnet_csum_disable
operator|||
name|vtnet_tso_disable
condition|)
name|mask
operator||=
name|VIRTIO_NET_F_HOST_TSO4
operator||
name|VIRTIO_NET_F_HOST_TSO6
operator||
name|VIRTIO_NET_F_HOST_ECN
expr_stmt|;
if|if
condition|(
name|vtnet_csum_disable
operator|||
name|vtnet_lro_disable
condition|)
name|mask
operator||=
name|VTNET_LRO_FEATURES
expr_stmt|;
name|features
operator|=
name|VTNET_FEATURES
operator|&
operator|~
name|mask
expr_stmt|;
ifdef|#
directive|ifdef
name|VTNET_TX_INTR_MODERATION
name|features
operator||=
name|VIRTIO_F_NOTIFY_ON_EMPTY
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|vtnet_features
operator|=
name|virtio_negotiate_features
argument_list|(
name|dev
argument_list|,
name|features
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MRG_RXBUF
argument_list|)
operator|==
literal|0
operator|&&
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VTNET_LRO_FEATURES
argument_list|)
condition|)
block|{
comment|/* 		 * LRO without mergeable buffers requires special care. This 		 * is not ideal because every receive buffer must be large 		 * enough to hold the maximum TCP packet, the Ethernet header, 		 * and the vtnet_rx_header. This requires up to 34 descriptors 		 * when using MCLBYTES clusters. If we do not have indirect 		 * descriptors, LRO is disabled since the virtqueue will not 		 * be able to contain very many receive buffers. 		 */
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_RING_F_INDIRECT_DESC
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LRO disabled due to lack of both mergeable "
literal|"buffers and indirect descriptors\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_features
operator|=
name|virtio_negotiate_features
argument_list|(
name|dev
argument_list|,
name|features
operator|&
operator|~
name|VTNET_LRO_FEATURES
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_LRO_NOMRG
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_alloc_virtqueues
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|vq_alloc_info
name|vq_info
index|[
literal|3
index|]
decl_stmt|;
name|int
name|nvqs
decl_stmt|,
name|rxsegs
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|nvqs
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Indirect descriptors are not needed for the Rx 	 * virtqueue when mergeable buffers are negotiated. 	 * The header is placed inline with the data, not 	 * in a separate descriptor, and mbuf clusters are 	 * always physically contiguous. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
name|rxsegs
operator|=
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
condition|?
name|VTNET_MAX_RX_SEGS
else|:
name|VTNET_MIN_RX_SEGS
expr_stmt|;
block|}
else|else
name|rxsegs
operator|=
literal|0
expr_stmt|;
name|VQ_ALLOC_INFO_INIT
argument_list|(
operator|&
name|vq_info
index|[
literal|0
index|]
argument_list|,
name|rxsegs
argument_list|,
name|vtnet_rx_vq_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_rx_vq
argument_list|,
literal|"%s receive"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|VQ_ALLOC_INFO_INIT
argument_list|(
operator|&
name|vq_info
index|[
literal|1
index|]
argument_list|,
name|VTNET_MAX_TX_SEGS
argument_list|,
name|vtnet_tx_vq_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_tx_vq
argument_list|,
literal|"%s transmit"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
condition|)
block|{
name|nvqs
operator|++
expr_stmt|;
name|VQ_ALLOC_INFO_INIT
argument_list|(
operator|&
name|vq_info
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_ctrl_vq
argument_list|,
literal|"%s control"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|virtio_alloc_virtqueues
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|nvqs
argument_list|,
name|vq_info
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_get_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
if|if
condition|(
name|virtio_with_feature
argument_list|(
name|dev
argument_list|,
name|VIRTIO_NET_F_MAC
argument_list|)
condition|)
block|{
name|virtio_read_device_config
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|mac
argument_list|)
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Generate random locally administered unicast address. */
name|sc
operator|->
name|vtnet_hwaddr
index|[
literal|0
index|]
operator|=
literal|0xB2
expr_stmt|;
name|arc4rand
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_hwaddr
index|[
literal|1
index|]
argument_list|,
name|ETHER_ADDR_LEN
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vtnet_set_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_set_hwaddr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|virtio_write_device_config
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|mac
argument_list|)
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_is_link_up
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LINKSTATE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|status
operator|=
name|virtio_read_dev_config_2
argument_list|(
name|dev
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|virtio_net_config
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|status
operator|&
name|VIRTIO_NET_S_LINK_UP
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_update_link_status
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|link
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|link
operator|=
name|vtnet_is_link_up
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|&&
operator|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LINK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|vtnet_flags
operator||=
name|VTNET_FLAG_LINK
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|vtnet_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|link
operator|&&
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LINK
operator|)
condition|)
block|{
name|sc
operator|->
name|vtnet_flags
operator|&=
operator|~
name|VTNET_FLAG_LINK
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_watchdog
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|VTNET_TX_INTR_MODERATION
name|vtnet_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|vtnet_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|vtnet_watchdog_timer
condition|)
return|return;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VTNET_DEBUG
name|virtqueue_dump
argument_list|(
name|sc
operator|->
name|vtnet_tx_vq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|reinit
decl_stmt|,
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|reinit
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|VTNET_MAX_MTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vtnet_change_mtu
argument_list|(
name|sc
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|vtnet_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
condition|)
name|vtnet_rx_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
block|}
else|else
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|vtnet_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|vtnet_rx_filter_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|vtnet_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|vtnet_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_disable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_disable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupts even in error case. */
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_enable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_enable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_POLLING
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|VTNET_CSUM_OFFLOAD
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|VTNET_CSUM_OFFLOAD
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_LRO
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWFILTER
expr_stmt|;
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTSO
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTSO
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
if|if
condition|(
name|reinit
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|VTNET_LOCK_ASSERT_NOTOWNED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_change_mtu
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|new_mtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|new_frame_size
decl_stmt|,
name|clsize
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
name|new_frame_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rx_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
operator|+
name|new_mtu
expr_stmt|;
if|if
condition|(
name|new_frame_size
operator|>
name|MJUM9BYTES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|new_frame_size
operator|<=
name|MCLBYTES
condition|)
name|clsize
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|clsize
operator|=
name|MJUM9BYTES
expr_stmt|;
block|}
else|else
block|{
name|new_frame_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr_mrg_rxbuf
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
operator|+
name|new_mtu
expr_stmt|;
if|if
condition|(
name|new_frame_size
operator|<=
name|MCLBYTES
condition|)
name|clsize
operator|=
name|MCLBYTES
expr_stmt|;
else|else
name|clsize
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
name|sc
operator|->
name|vtnet_rx_mbuf_size
operator|=
name|clsize
expr_stmt|;
name|sc
operator|->
name|vtnet_rx_mbuf_count
operator|=
name|VTNET_NEEDED_RX_MBUFS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_rx_mbuf_count
operator|<
name|VTNET_MAX_RX_SEGS
argument_list|,
operator|(
literal|"too many rx mbufs: %d"
operator|,
name|sc
operator|->
name|vtnet_rx_mbuf_count
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|new_mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_init_rx_vq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|int
name|nbufs
decl_stmt|,
name|error
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_rx_vq
expr_stmt|;
name|nbufs
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
while|while
condition|(
operator|!
name|virtqueue_full
argument_list|(
name|vq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|vtnet_newbuf
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|nbufs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nbufs
operator|>
literal|0
condition|)
block|{
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
comment|/* 		 * EMSGSIZE signifies the virtqueue did not have enough 		 * entries available to hold the last mbuf. This is not 		 * an error. We should not get ENOSPC since we check if 		 * the virtqueue is full before attempting to add a 		 * buffer. 		 */
if|if
condition|(
name|error
operator|==
name|EMSGSIZE
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_rx_mbufs
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|last
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_rx_vq
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|virtqueue_drain
argument_list|(
name|vq
argument_list|,
operator|&
name|last
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
argument_list|,
operator|(
literal|"mbufs remaining in Rx Vq"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_tx_mbufs
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
decl_stmt|;
name|int
name|last
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_tx_vq
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|txhdr
operator|=
name|virtqueue_drain
argument_list|(
name|vq
argument_list|,
operator|&
name|last
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|txhdr
operator|->
name|vth_mbuf
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
argument_list|,
operator|(
literal|"mbufs remaining in Tx Vq"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_free_ctrl_vq
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * The control virtqueue is only polled, therefore 	 * it should already be empty. 	 */
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|sc
operator|->
name|vtnet_ctrl_vq
argument_list|)
argument_list|,
operator|(
literal|"Ctrl Vq not empty"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|int
name|vtnet_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rx_done
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|rx_done
operator|=
literal|0
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
name|vtnet_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtqueue_nused
argument_list|(
name|sc
operator|->
name|vtnet_rx_vq
argument_list|)
operator|>
literal|0
condition|)
name|vtnet_rxeof
argument_list|(
name|sc
argument_list|,
name|count
argument_list|,
operator|&
name|rx_done
argument_list|)
expr_stmt|;
name|vtnet_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|vtnet_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_done
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_alloc_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbufs
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_tailp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clsize
decl_stmt|;
name|clsize
operator|=
name|sc
operator|->
name|vtnet_rx_mbuf_size
expr_stmt|;
name|m_head
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|clsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|m_head
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
name|m_tail
operator|=
name|m_head
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
argument_list|,
operator|(
literal|"chained Rx mbuf requested without LRO_NOMRG"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nbufs
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|,
name|clsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|m
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
name|m_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_tail
operator|=
name|m
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m_tailp
operator|!=
name|NULL
condition|)
operator|*
name|m_tailp
operator|=
name|m_tail
expr_stmt|;
return|return
operator|(
name|m_head
operator|)
return|;
name|fail
label|:
name|sc
operator|->
name|vtnet_stats
operator|.
name|mbuf_alloc_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_replace_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|len0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_new
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|int
name|len
decl_stmt|,
name|clsize
decl_stmt|,
name|nreplace
decl_stmt|,
name|error
decl_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|m_prev
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|len0
expr_stmt|;
name|m_tail
operator|=
name|NULL
expr_stmt|;
name|clsize
operator|=
name|sc
operator|->
name|vtnet_rx_mbuf_size
expr_stmt|;
name|nreplace
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
operator|||
name|m
operator|->
name|m_next
operator|==
name|NULL
argument_list|,
operator|(
literal|"chained Rx mbuf without LRO_NOMRG"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Since LRO_NOMRG mbuf chains are so large, we want to avoid 	 * allocating an entire chain for each received frame. When 	 * the received frame's length is less than that of the chain, 	 * the unused mbufs are reassigned to the new chain. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Something is seriously wrong if we received 		 * a frame larger than the mbuf chain. Drop it. 		 */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_frame_too_large
operator|++
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|==
name|clsize
argument_list|,
operator|(
literal|"mbuf length not expected cluster size: %d"
operator|,
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MIN
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|nreplace
operator|++
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|m_prev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"m_prev == NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nreplace
operator|<=
name|sc
operator|->
name|vtnet_rx_mbuf_count
argument_list|,
operator|(
literal|"too many replacement mbufs: %d/%d"
operator|,
name|nreplace
operator|,
name|sc
operator|->
name|vtnet_rx_mbuf_count
operator|)
argument_list|)
expr_stmt|;
name|m_new
operator|=
name|vtnet_alloc_rxbuf
argument_list|(
name|sc
argument_list|,
name|nreplace
argument_list|,
operator|&
name|m_tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_new
operator|==
name|NULL
condition|)
block|{
name|m_prev
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * Move unused mbufs, if any, from the original chain 	 * onto the end of the new chain. 	 */
if|if
condition|(
name|m_prev
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|m_tail
operator|->
name|m_next
operator|=
name|m_prev
operator|->
name|m_next
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|vtnet_enqueue_rxbuf
argument_list|(
name|sc
argument_list|,
name|m_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * BAD! We could not enqueue the replacement mbuf chain. We 		 * must restore the m0 chain to the original state if it was 		 * modified so we can subsequently discard it. 		 * 		 * NOTE: The replacement is suppose to be an identical copy 		 * to the one just dequeued so this is an unexpected error. 		 */
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_enq_replacement_failed
operator|++
expr_stmt|;
if|if
condition|(
name|m_tail
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|m_prev
operator|->
name|m_next
operator|=
name|m_tail
operator|->
name|m_next
expr_stmt|;
name|m_tail
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
name|m_prev
operator|->
name|m_len
operator|=
name|clsize
expr_stmt|;
name|m_freem
argument_list|(
name|m_new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_newbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
name|vtnet_alloc_rxbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vtnet_rx_mbuf_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|error
operator|=
name|vtnet_enqueue_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_discard_merged_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|nbufs
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_rx_vq
expr_stmt|;
while|while
condition|(
operator|--
name|nbufs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|vtnet_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_discard_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Requeue the discarded mbuf. This should always be 	 * successful since it was just dequeued. 	 */
name|error
operator|=
name|vtnet_enqueue_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"cannot requeue discarded mbuf"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_enqueue_rxbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sglist
name|sg
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
name|VTNET_MAX_RX_SEGS
index|]
decl_stmt|;
name|struct
name|vtnet_rx_header
modifier|*
name|rxhdr
decl_stmt|;
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
decl_stmt|;
name|uint8_t
modifier|*
name|mdata
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|error
decl_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LRO_NOMRG
operator|||
name|m
operator|->
name|m_next
operator|==
name|NULL
argument_list|,
operator|(
literal|"chained Rx mbuf without LRO_NOMRG"
operator|)
argument_list|)
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
name|VTNET_MAX_RX_SEGS
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|mdata
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
name|rxhdr
operator|=
operator|(
expr|struct
name|vtnet_rx_header
operator|*
operator|)
name|mdata
expr_stmt|;
name|hdr
operator|=
operator|&
name|rxhdr
operator|->
name|vrh_hdr
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rx_header
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
name|hdr
argument_list|,
name|sc
operator|->
name|vtnet_hdr_size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"cannot add header to sglist"
operator|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
name|mdata
operator|+
name|offset
argument_list|,
name|m
operator|->
name|m_len
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|sglist_append_mbuf
argument_list|(
operator|&
name|sg
argument_list|,
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|virtqueue_enqueue
argument_list|(
name|sc
operator|->
name|vtnet_rx_vq
argument_list|,
name|m
argument_list|,
operator|&
name|sg
argument_list|,
literal|0
argument_list|,
name|sg
operator|.
name|sg_nseg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_vlan_tag_remove
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
name|evl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|evl
operator|->
name|evl_tag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
comment|/* Strip the 802.1Q header. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|evl
operator|+
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|ETHER_HDR_LEN
operator|-
name|ETHER_TYPE_LEN
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_VLAN_ENCAP_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|vtnet_rx_csum
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|int
name|ip_offset
decl_stmt|,
name|csum_start
decl_stmt|,
name|csum_offset
decl_stmt|,
name|hlen
decl_stmt|;
name|uint16_t
name|eth_type
decl_stmt|;
name|uint8_t
name|ip_proto
decl_stmt|;
comment|/* 	 * Convert the VirtIO checksum interface to FreeBSD's interface. 	 * The host only provides us with the offset at which to start 	 * checksumming, and the offset from that to place the completed 	 * checksum. While this maps well with how Linux does checksums, 	 * for FreeBSD, we must parse the received packet in order to set 	 * the appropriate CSUM_* flags. 	 */
comment|/* 	 * Every mbuf added to the receive virtqueue is always at least 	 * MCLBYTES big, so assume something is amiss if the first mbuf 	 * does not contain both the Ethernet and protocol headers. 	 */
name|ip_offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_type
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|ip_offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|eth_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ip_offset
operator|)
expr_stmt|;
comment|/* Sanity check the IP header. */
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|<
name|hlen
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|!=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|ip_offset
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ip_proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|csum_start
operator|=
name|ip_offset
operator|+
name|hlen
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * XXX FreeBSD does not handle any IPv6 checksum offloading 		 * at the moment. 		 */
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ip_offset
operator|)
expr_stmt|;
comment|/* XXX Assume no extension headers are present. */
name|ip_proto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|csum_start
operator|=
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_ethtype
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Assume checksum begins right after the IP header. */
if|if
condition|(
name|hdr
operator|->
name|csum_start
operator|!=
name|csum_start
condition|)
block|{
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_start
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|ip_proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|csum_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|csum_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|csum_offset
operator|=
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_ipproto
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|hdr
operator|->
name|csum_offset
operator|!=
name|csum_offset
condition|)
block|{
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_offset
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * The IP header checksum is almost certainly valid but I'm 	 * uncertain if that is guaranteed. 	 * 	 * m->m_pkthdr.csum_flags |= CSUM_IP_CHECKED | CSUM_IP_VALID; 	 */
switch|switch
condition|(
name|ip_proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|csum_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|udp
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|csum_start
operator|)
expr_stmt|;
if|if
condition|(
name|udp
operator|->
name|uh_sum
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|IPPROTO_TCP
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_offloaded
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Alternative method of doing receive checksum offloading. Rather  * than parsing the received frame down to the IP header, use the  * csum_offset to determine which CSUM_* flags are appropriate. We  * can get by with doing this only because the checksum offsets are  * unique for the things we care about.  */
end_comment

begin_function
specifier|static
name|int
name|vtnet_rx_csum
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|int
name|csum_len
decl_stmt|;
name|uint16_t
name|eth_type
decl_stmt|;
name|csum_len
operator|=
name|hdr
operator|->
name|csum_start
operator|+
name|hdr
operator|->
name|csum_offset
expr_stmt|;
if|if
condition|(
name|csum_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|csum_len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_type
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_type
operator|!=
name|ETHERTYPE_IP
operator|&&
name|eth_type
operator|!=
name|ETHERTYPE_IPV6
condition|)
block|{
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_ethtype
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Use the offset to determine the appropriate CSUM_* flags. */
switch|switch
condition|(
name|hdr
operator|->
name|csum_offset
condition|)
block|{
case|case
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hdr
operator|->
name|csum_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|udp
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdr
operator|->
name|csum_start
operator|)
expr_stmt|;
if|if
condition|(
name|udp
operator|->
name|uh_sum
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|offsetof
argument_list|(
expr|struct
name|tcphdr
argument_list|,
name|th_sum
argument_list|)
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xFFFF
expr_stmt|;
break|break;
case|case
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
case|:
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_SCTP_VALID
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_bad_offset
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_offloaded
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxeof_merged
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|int
name|nbufs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|int
name|len
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_rx_vq
expr_stmt|;
name|m_tail
operator|=
name|m_head
expr_stmt|;
while|while
condition|(
operator|--
name|nbufs
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|vtnet_newbuf
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
name|vtnet_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
name|vtnet_discard_merged_rxbuf
argument_list|(
name|sc
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len
condition|)
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|m_tail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_tail
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_mergeable_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_rxeof
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|rx_npktsp
parameter_list|)
block|{
name|struct
name|virtio_net_hdr
name|lhdr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|virtio_net_hdr_mrg_rxbuf
modifier|*
name|mhdr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|deq
decl_stmt|,
name|nbufs
decl_stmt|,
name|adjsz
decl_stmt|,
name|rx_npkts
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_rx_vq
expr_stmt|;
name|hdr
operator|=
operator|&
name|lhdr
expr_stmt|;
name|deq
operator|=
literal|0
expr_stmt|;
name|rx_npkts
operator|=
literal|0
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|count
operator|>=
literal|0
condition|)
block|{
name|m
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|deq
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|sc
operator|->
name|vtnet_hdr_size
operator|+
name|ETHER_HDR_LEN
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|vtnet_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_MRG_RXBUFS
operator|)
operator|==
literal|0
condition|)
block|{
name|nbufs
operator|=
literal|1
expr_stmt|;
name|adjsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|vtnet_rx_header
argument_list|)
expr_stmt|;
comment|/* 			 * Account for our pad between the header and 			 * the actual start of the frame. 			 */
name|len
operator|+=
name|VTNET_RX_HEADER_PAD
expr_stmt|;
block|}
else|else
block|{
name|mhdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|virtio_net_hdr_mrg_rxbuf
operator|*
argument_list|)
expr_stmt|;
name|nbufs
operator|=
name|mhdr
operator|->
name|num_buffers
expr_stmt|;
name|adjsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr_mrg_rxbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vtnet_replace_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
name|vtnet_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
name|vtnet_discard_merged_rxbuf
argument_list|(
name|sc
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nbufs
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|vtnet_rxeof_merged
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|nbufs
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* 		 * Save copy of header before we strip it. For both mergeable 		 * and non-mergeable, the VirtIO header is placed first in the 		 * mbuf's data. We no longer need num_buffers, so always use a 		 * virtio_net_hdr. 		 */
name|memcpy
argument_list|(
name|hdr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|adjsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
block|{
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|vtnet_vlan_tag_remove
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 				 * With the 802.1Q header removed, update the 				 * checksum starting location accordingly. 				 */
if|if
condition|(
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
condition|)
name|hdr
operator|->
name|csum_start
operator|-=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|&&
name|hdr
operator|->
name|flags
operator|&
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
condition|)
block|{
if|if
condition|(
name|vtnet_rx_csum
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_csum_failed
operator|++
expr_stmt|;
block|}
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx_npkts
operator|++
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * The interface may have been stopped while we were 		 * passing the packet up the network stack. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|deq
operator|>
literal|0
condition|)
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_npktsp
operator|!=
name|NULL
condition|)
operator|*
name|rx_npktsp
operator|=
name|rx_npkts
expr_stmt|;
return|return
operator|(
name|count
operator|>
literal|0
condition|?
literal|0
else|:
name|EAGAIN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_vq_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|more
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|again
label|:
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|vtnet_enable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|more
operator|=
name|vtnet_rxeof
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vtnet_rx_process_limit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
operator|||
name|vtnet_enable_rx_intr
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|more
condition|)
name|vtnet_disable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_stats
operator|.
name|rx_task_rescheduled
operator|++
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_txeof
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
decl_stmt|;
name|int
name|deq
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_tx_vq
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|deq
operator|=
literal|0
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|txhdr
operator|=
name|virtqueue_dequeue
argument_list|(
name|vq
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|deq
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|txhdr
operator|->
name|vth_mbuf
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|deq
operator|>
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
if|if
condition|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
condition|)
name|sc
operator|->
name|vtnet_watchdog_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vtnet_tx_offload
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|evh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|int
name|ip_offset
decl_stmt|;
name|uint16_t
name|eth_type
decl_stmt|,
name|csum_start
decl_stmt|;
name|uint8_t
name|ip_proto
decl_stmt|,
name|gso_type
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|ip_offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ip_offset
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_type
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|ip_offset
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ip_offset
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|evh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|eth_type
operator|=
name|ntohs
argument_list|(
name|evh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|eth_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ip_offset
operator|)
expr_stmt|;
name|ip_proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|csum_start
operator|=
name|ip_offset
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|gso_type
operator|=
name|VIRTIO_NET_HDR_GSO_TCPV4
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ip_offset
operator|)
expr_stmt|;
comment|/* 		 * XXX Assume no extension headers are present. Presently, 		 * this will always be true in the case of TSO, and FreeBSD 		 * does not perform checksum offloading of IPv6 yet. 		 */
name|ip_proto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|csum_start
operator|=
name|ip_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|gso_type
operator|=
name|VIRTIO_NET_HDR_GSO_TCPV6
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|VTNET_CSUM_OFFLOAD
condition|)
block|{
name|hdr
operator|->
name|flags
operator||=
name|VIRTIO_NET_HDR_F_NEEDS_CSUM
expr_stmt|;
name|hdr
operator|->
name|csum_start
operator|=
name|csum_start
expr_stmt|;
name|hdr
operator|->
name|csum_offset
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_csum_offloaded
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
if|if
condition|(
name|ip_proto
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|m
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|csum_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|csum_start
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|csum_start
operator|)
expr_stmt|;
name|hdr
operator|->
name|gso_type
operator|=
name|gso_type
expr_stmt|;
name|hdr
operator|->
name|hdr_len
operator|=
name|csum_start
operator|+
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
expr_stmt|;
name|hdr
operator|->
name|gso_size
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
if|if
condition|(
name|tcp
operator|->
name|th_flags
operator|&
name|TH_CWR
condition|)
block|{
comment|/* 			 * Drop if we did not negotiate VIRTIO_NET_F_HOST_ECN. 			 * ECN support is only configurable globally with the 			 * net.inet.tcp.ecn.enable sysctl knob. 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_TSO_ECN
operator|)
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TSO with ECN not supported "
literal|"by host\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hdr
operator|->
name|flags
operator||=
name|VIRTIO_NET_HDR_GSO_ECN
expr_stmt|;
block|}
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_tso_offloaded
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_enqueue_txbuf
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|,
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
parameter_list|)
block|{
name|struct
name|sglist
name|sg
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
name|VTNET_MAX_TX_SEGS
index|]
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|collapsed
decl_stmt|,
name|error
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_tx_vq
expr_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
name|collapsed
operator|=
literal|0
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
name|VTNET_MAX_TX_SEGS
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator|=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|txhdr
operator|->
name|vth_uhdr
argument_list|,
name|sc
operator|->
name|vtnet_hdr_size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: cannot add header to sglist error %d"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|again
label|:
name|error
operator|=
name|sglist_append_mbuf
argument_list|(
operator|&
name|sg
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|collapsed
condition|)
goto|goto
name|fail
goto|;
name|m
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|VTNET_MAX_TX_SEGS
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|collapsed
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|txhdr
operator|->
name|vth_mbuf
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|virtqueue_enqueue
argument_list|(
name|vq
argument_list|,
name|txhdr
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|fail
label|:
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_encap
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|vtnet_tx_header
modifier|*
name|txhdr
decl_stmt|;
name|struct
name|virtio_net_hdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|txhdr
operator|=
name|uma_zalloc
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|txhdr
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Always use the non-mergeable header to simplify things. When 	 * the mergeable feature is negotiated, the num_buffers field 	 * must be set to zero. We use vtnet_hdr_size later to enqueue 	 * the correct header size to the host. 	 */
name|hdr
operator|=
operator|&
name|txhdr
operator|->
name|vth_uhdr
operator|.
name|hdr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|m
operator|=
name|ether_vlanencap
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m_head
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|vtnet_tx_offload
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|m_head
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|error
operator|=
name|vtnet_enqueue_txbuf
argument_list|(
name|sc
argument_list|,
name|m_head
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|error
condition|)
name|uma_zfree
argument_list|(
name|vtnet_tx_header_zone
argument_list|,
name|txhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|enq
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_tx_vq
expr_stmt|;
name|enq
operator|=
literal|0
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_LINK
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|VTNET_TX_INTR_MODERATION
if|if
condition|(
name|virtqueue_nused
argument_list|(
name|vq
argument_list|)
operator|>=
name|sc
operator|->
name|vtnet_tx_size
operator|/
literal|2
condition|)
name|vtnet_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
if|if
condition|(
name|virtqueue_full
argument_list|(
name|vq
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|vtnet_encap
argument_list|(
name|sc
argument_list|,
operator|&
name|m0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_watchdog_timer
operator|=
name|VTNET_WATCHDOG_TIMEOUT
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VTNET_DEBUG
name|virtqueue_dump
argument_list|(
name|sc
operator|->
name|vtnet_rx_vq
argument_list|)
expr_stmt|;
name|virtqueue_dump
argument_list|(
name|sc
operator|->
name|vtnet_tx_vq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vtnet_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|,
name|hz
argument_list|,
name|vtnet_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_tx_vq_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|again
label|:
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|vtnet_enable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|vtnet_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|vtnet_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_enable_tx_intr
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vtnet_disable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_stats
operator|.
name|tx_task_rescheduled
operator|++
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_stop
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_watchdog_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|vtnet_disable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_disable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Stop the host VirtIO adapter. Note this will reset the host 	 * adapter's state back to the pre-initialized state, so in 	 * order to make the device usable again, we must drive it 	 * through virtio_reinit() and virtio_reinit_complete(). 	 */
name|virtio_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vtnet_flags
operator|&=
operator|~
name|VTNET_FLAG_LINK
expr_stmt|;
name|vtnet_free_rx_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_free_tx_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_reinit
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint64_t
name|features
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|features
operator|=
name|sc
operator|->
name|vtnet_features
expr_stmt|;
comment|/* 	 * Re-negotiate with the host, removing any disabled receive 	 * features. Transmit features are disabled only on our side 	 * via if_capenable and if_hwassist. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|==
literal|0
condition|)
name|features
operator|&=
operator|~
name|VIRTIO_NET_F_GUEST_CSUM
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_LRO
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
operator|==
literal|0
condition|)
name|features
operator|&=
operator|~
name|VTNET_LRO_FEATURES
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
operator|)
operator|==
literal|0
condition|)
name|features
operator|&=
operator|~
name|VIRTIO_NET_F_CTRL_VLAN
expr_stmt|;
block|}
return|return
operator|(
name|virtio_reinit
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|,
name|features
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_init_locked
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
comment|/* Stop host's adapter, cancel any pending I/O. */
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reinitialize the host device. */
name|error
operator|=
name|vtnet_reinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"reinitialization failed, stopping device...\n"
argument_list|)
expr_stmt|;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Update host with assigned MAC address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|vtnet_hwaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|vtnet_set_hwaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|VTNET_CSUM_OFFLOAD
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TSO4
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
name|error
operator|=
name|vtnet_init_rx_vq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate mbufs for Rx virtqueue\n"
argument_list|)
expr_stmt|;
name|vtnet_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
condition|)
block|{
comment|/* Restore promiscuous and all-multicast modes. */
name|vtnet_rx_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Restore filtered MAC addresses. */
name|vtnet_rx_filter_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Restore VLAN filters. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|vtnet_rx_filter_vlan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|vtnet_disable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_disable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|vtnet_enable_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_enable_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|virtio_reinit_complete
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|vtnet_update_link_status
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vtnet_tick_ch
argument_list|,
name|hz
argument_list|,
name|vtnet_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vtnet_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_exec_ctrl_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
name|struct
name|sglist
modifier|*
name|sg
parameter_list|,
name|int
name|readable
parameter_list|,
name|int
name|writable
parameter_list|)
block|{
name|struct
name|virtqueue
modifier|*
name|vq
decl_stmt|;
name|void
modifier|*
name|c
decl_stmt|;
name|vq
operator|=
name|sc
operator|->
name|vtnet_ctrl_vq
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_VQ
argument_list|,
operator|(
literal|"no control virtqueue"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|virtqueue_empty
argument_list|(
name|vq
argument_list|)
argument_list|,
operator|(
literal|"control command already enqueued"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtqueue_enqueue
argument_list|(
name|vq
argument_list|,
name|cookie
argument_list|,
name|sg
argument_list|,
name|readable
argument_list|,
name|writable
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|virtqueue_notify
argument_list|(
name|vq
argument_list|)
expr_stmt|;
comment|/* 	 * Poll until the command is complete. Previously, we would 	 * sleep until the control virtqueue interrupt handler woke 	 * us up, but dropping the VTNET_MTX leads to serialization 	 * difficulties. 	 * 	 * Furthermore, it appears QEMU/KVM only allocates three MSIX 	 * vectors. Two of those vectors are needed for the Rx and Tx 	 * virtqueues. We do not support sharing both a Vq and config 	 * changed notification on the same MSIX vector. 	 */
name|c
operator|=
name|virtqueue_poll
argument_list|(
name|vq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|c
operator|==
name|cookie
argument_list|,
operator|(
literal|"unexpected control command response"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
argument_list|,
operator|(
literal|"CTRL_RX feature not negotiated"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_set_promisc
argument_list|(
name|sc
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot %s promiscuous mode\n"
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_set_allmulti
argument_list|(
name|sc
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
argument_list|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot %s all-multicast mode\n"
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|?
literal|"enable"
else|:
literal|"disable"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ctrl_rx_cmd
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
name|uint8_t
name|onoff
decl_stmt|,
name|ack
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_RX
expr_stmt|;
name|hdr
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|onoff
operator|=
operator|!
operator|!
name|on
expr_stmt|;
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|3
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|onoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|3
argument_list|,
operator|(
literal|"error adding Rx filter message to sglist"
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ack
operator|==
name|VIRTIO_NET_OK
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_set_promisc
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
return|return
operator|(
name|vtnet_ctrl_rx_cmd
argument_list|(
name|sc
argument_list|,
name|VIRTIO_NET_CTRL_RX_PROMISC
argument_list|,
name|on
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_set_allmulti
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|on
parameter_list|)
block|{
return|return
operator|(
name|vtnet_ctrl_rx_cmd
argument_list|(
name|sc
argument_list|,
name|VIRTIO_NET_CTRL_RX_ALLMULTI
argument_list|,
name|on
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_filter_mac
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
decl_stmt|;
name|struct
name|vtnet_mac_filter
modifier|*
name|filter
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|ucnt
decl_stmt|,
name|mcnt
decl_stmt|,
name|promisc
decl_stmt|,
name|allmulti
decl_stmt|,
name|error
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|filter
operator|=
name|sc
operator|->
name|vtnet_mac_filter
expr_stmt|;
name|ucnt
operator|=
literal|0
expr_stmt|;
name|mcnt
operator|=
literal|0
expr_stmt|;
name|promisc
operator|=
literal|0
expr_stmt|;
name|allmulti
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_CTRL_RX
argument_list|,
operator|(
literal|"CTRL_RX feature not negotiated"
operator|)
argument_list|)
expr_stmt|;
comment|/* Unicast MAC addresses: */
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ucnt
operator|==
name|VTNET_MAX_MAC_ENTRIES
condition|)
break|break;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
argument_list|)
argument_list|,
operator|&
name|filter
operator|->
name|vmf_unicast
operator|.
name|macs
index|[
name|ucnt
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|ucnt
operator|++
expr_stmt|;
block|}
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucnt
operator|>=
name|VTNET_MAX_MAC_ENTRIES
condition|)
block|{
name|promisc
operator|=
literal|1
expr_stmt|;
name|filter
operator|->
name|vmf_unicast
operator|.
name|nentries
operator|=
literal|0
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"more than %d MAC addresses assigned, "
literal|"falling back to promiscuous mode\n"
argument_list|,
name|VTNET_MAX_MAC_ENTRIES
argument_list|)
expr_stmt|;
block|}
else|else
name|filter
operator|->
name|vmf_unicast
operator|.
name|nentries
operator|=
name|ucnt
expr_stmt|;
comment|/* Multicast MAC addresses: */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|mcnt
operator|==
name|VTNET_MAX_MAC_ENTRIES
condition|)
break|break;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|filter
operator|->
name|vmf_multicast
operator|.
name|macs
index|[
name|mcnt
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mcnt
operator|++
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcnt
operator|>=
name|VTNET_MAX_MAC_ENTRIES
condition|)
block|{
name|allmulti
operator|=
literal|1
expr_stmt|;
name|filter
operator|->
name|vmf_multicast
operator|.
name|nentries
operator|=
literal|0
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"more than %d multicast MAC addresses "
literal|"assigned, falling back to all-multicast mode\n"
argument_list|,
name|VTNET_MAX_MAC_ENTRIES
argument_list|)
expr_stmt|;
block|}
else|else
name|filter
operator|->
name|vmf_multicast
operator|.
name|nentries
operator|=
name|mcnt
expr_stmt|;
if|if
condition|(
name|promisc
operator|&&
name|allmulti
condition|)
goto|goto
name|out
goto|;
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_MAC
expr_stmt|;
name|hdr
operator|.
name|cmd
operator|=
name|VIRTIO_NET_CTRL_MAC_TABLE_SET
expr_stmt|;
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|4
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|filter
operator|->
name|vmf_unicast
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|filter
operator|->
name|vmf_unicast
operator|.
name|nentries
operator|*
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|filter
operator|->
name|vmf_multicast
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
name|filter
operator|->
name|vmf_multicast
operator|.
name|nentries
operator|*
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|4
argument_list|,
operator|(
literal|"error adding MAC filtering message to sglist"
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|!=
name|VIRTIO_NET_OK
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"error setting host MAC filter table\n"
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|promisc
condition|)
if|if
condition|(
name|vtnet_set_promisc
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot enable promiscuous mode\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allmulti
condition|)
if|if
condition|(
name|vtnet_set_allmulti
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"cannot enable all-multicast mode\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_exec_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|add
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
name|struct
name|virtio_net_ctrl_hdr
name|hdr
decl_stmt|;
name|struct
name|sglist_seg
name|segs
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|sglist
name|sg
decl_stmt|;
name|uint8_t
name|ack
decl_stmt|;
name|int
name|error
decl_stmt|;
name|hdr
operator|.
name|class
operator|=
name|VIRTIO_NET_CTRL_VLAN
expr_stmt|;
name|hdr
operator|.
name|cmd
operator|=
name|add
condition|?
name|VIRTIO_NET_CTRL_VLAN_ADD
else|:
name|VIRTIO_NET_CTRL_VLAN_DEL
expr_stmt|;
name|ack
operator|=
name|VIRTIO_NET_ERR
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sglist_init
argument_list|(
operator|&
name|sg
argument_list|,
literal|3
argument_list|,
name|segs
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|virtio_net_ctrl_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|tag
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator||=
name|sglist_append
argument_list|(
operator|&
name|sg
argument_list|,
operator|&
name|ack
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|&&
name|sg
operator|.
name|sg_nseg
operator|==
literal|3
argument_list|,
operator|(
literal|"error adding VLAN control message to sglist"
operator|)
argument_list|)
expr_stmt|;
name|vtnet_exec_ctrl_cmd
argument_list|(
name|sc
argument_list|,
operator|&
name|ack
argument_list|,
operator|&
name|sg
argument_list|,
name|sg
operator|.
name|sg_nseg
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ack
operator|==
name|VIRTIO_NET_OK
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_rx_filter_vlan
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|uint32_t
name|w
decl_stmt|,
name|mask
decl_stmt|;
name|uint16_t
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nvlans
decl_stmt|,
name|error
decl_stmt|;
name|VTNET_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_VLAN_FILTER
argument_list|,
operator|(
literal|"VLAN_FILTER feature not negotiated"
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|nvlans
operator|=
name|sc
operator|->
name|vtnet_nvlans
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Enable filtering for each configured VLAN. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTNET_VLAN_SHADOW_SIZE
operator|&&
name|nvlans
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|sc
operator|->
name|vtnet_vlan_shadow
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|mask
operator|=
literal|1
operator|,
name|tag
operator|=
name|i
operator|*
literal|32
init|;
name|w
operator|!=
literal|0
condition|;
name|mask
operator|<<=
literal|1
operator|,
name|tag
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|w
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|w
operator|&=
operator|~
name|mask
expr_stmt|;
name|nvlans
operator|--
expr_stmt|;
if|if
condition|(
name|vtnet_exec_vlan_filter
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|tag
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|++
expr_stmt|;
block|}
block|}
block|}
name|KASSERT
argument_list|(
name|nvlans
operator|==
literal|0
argument_list|,
operator|(
literal|"VLAN count incorrect"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot restore VLAN filter table\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_set_vlan_filter
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|,
name|int
name|add
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|bit
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|vtnet_flags
operator|&
name|VTNET_FLAG_VLAN_FILTER
argument_list|,
operator|(
literal|"VLAN_FILTER feature not negotiated"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tag
operator|==
literal|0
operator|)
operator|||
operator|(
name|tag
operator|>
literal|4095
operator|)
condition|)
return|return;
name|ifp
operator|=
name|sc
operator|->
name|vtnet_ifp
expr_stmt|;
name|idx
operator|=
operator|(
name|tag
operator|>>
literal|5
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|bit
operator|=
name|tag
operator|&
literal|0x1F
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Update shadow VLAN table. */
if|if
condition|(
name|add
condition|)
block|{
name|sc
operator|->
name|vtnet_nvlans
operator|++
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_shadow
index|[
name|idx
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|vtnet_nvlans
operator|--
expr_stmt|;
name|sc
operator|->
name|vtnet_vlan_shadow
index|[
name|idx
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
block|{
if|if
condition|(
name|vtnet_exec_vlan_filter
argument_list|(
name|sc
argument_list|,
name|add
argument_list|,
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vtnet_dev
argument_list|,
literal|"cannot %s VLAN %d %s the host filter table\n"
argument_list|,
name|add
condition|?
literal|"add"
else|:
literal|"remove"
argument_list|,
name|tag
argument_list|,
name|add
condition|?
literal|"to"
else|:
literal|"from"
argument_list|)
expr_stmt|;
block|}
block|}
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
name|vtnet_set_vlan_filter
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint16_t
name|tag
parameter_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
return|return;
name|vtnet_set_vlan_filter
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifm
operator|=
operator|&
name|sc
operator|->
name|vtnet_media
expr_stmt|;
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifm
operator|->
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|vtnet_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|VTNET_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtnet_is_link_up
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|VTNET_MEDIATYPE
expr_stmt|;
block|}
else|else
name|ifmr
operator|->
name|ifm_active
operator||=
name|IFM_NONE
expr_stmt|;
name|VTNET_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_add_statistics
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|vtnet_statistics
modifier|*
name|stats
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|vtnet_dev
expr_stmt|;
name|stats
operator|=
operator|&
name|sc
operator|->
name|vtnet_stats
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_alloc_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|mbuf_alloc_failed
argument_list|,
literal|"Mbuf cluster allocation failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_frame_too_large"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_frame_too_large
argument_list|,
literal|"Received frame larger than the mbuf chain"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_enq_replacement_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_enq_replacement_failed
argument_list|,
literal|"Enqueuing the replacement receive mbuf failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_mergeable_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_mergeable_failed
argument_list|,
literal|"Mergeable buffers receive failures"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_ethtype"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_ethtype
argument_list|,
literal|"Received checksum offloaded buffer with unsupported "
literal|"Ethernet type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_start"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_start
argument_list|,
literal|"Received checksum offloaded buffer with incorrect start offset"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_ipproto"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_ipproto
argument_list|,
literal|"Received checksum offloaded buffer with incorrect IP protocol"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_bad_offset"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_bad_offset
argument_list|,
literal|"Received checksum offloaded buffer with incorrect offset"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_failed
argument_list|,
literal|"Received buffer checksum offload failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_csum_offloaded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_csum_offloaded
argument_list|,
literal|"Received buffer checksum offload succeeded"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_task_rescheduled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|rx_task_rescheduled
argument_list|,
literal|"Times the receive interrupt task rescheduled itself"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_csum_offloaded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_csum_offloaded
argument_list|,
literal|"Offloaded checksum of transmitted buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_tso_offloaded"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_tso_offloaded
argument_list|,
literal|"Segmentation offload of transmitted buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_csum_bad_ethtype"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_csum_bad_ethtype
argument_list|,
literal|"Aborted transmit of checksum offloaded buffer with unknown "
literal|"Ethernet type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_tso_bad_ethtype"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_tso_bad_ethtype
argument_list|,
literal|"Aborted transmit of TSO buffer with unknown Ethernet type"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_ULONG
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_task_rescheduled"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|stats
operator|->
name|tx_task_rescheduled
argument_list|,
literal|"Times the transmit interrupt task rescheduled itself"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_enable_rx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|virtqueue_enable_intr
argument_list|(
name|sc
operator|->
name|vtnet_rx_vq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_disable_rx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|virtqueue_disable_intr
argument_list|(
name|sc
operator|->
name|vtnet_rx_vq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vtnet_enable_tx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VTNET_TX_INTR_MODERATION
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|virtqueue_enable_intr
argument_list|(
name|sc
operator|->
name|vtnet_tx_vq
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vtnet_disable_tx_intr
parameter_list|(
name|struct
name|vtnet_softc
modifier|*
name|sc
parameter_list|)
block|{
name|virtqueue_disable_intr
argument_list|(
name|sc
operator|->
name|vtnet_tx_vq
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

