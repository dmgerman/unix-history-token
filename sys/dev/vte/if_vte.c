begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010, Pyun YongHyeon<yongari@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Driver for DM&P Electronics, Inc, Vortex86 RDC R6040 FastEthernet. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/vte/if_vtereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/vte/if_vtevar.h>
end_include

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vte
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vte
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|vte
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tx_deep_copy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.vte.tx_deep_copy"
argument_list|,
operator|&
name|tx_deep_copy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Devices supported by this driver.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|vte_ident
name|vte_ident_table
index|[]
init|=
block|{
block|{
name|VENDORID_RDC
block|,
name|DEVICEID_RDC_R6040
block|,
literal|"RDC R6040 FastEthernet"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|vte_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_dma_alloc
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_dma_free
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|vte_txdesc
modifier|*
name|vte_encap
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|vte_ident
modifier|*
name|vte_find_ident
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|vte_fixup_rx
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|vte_get_macaddr
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_init_locked
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_init_rx_ring
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_init_tx_ring
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|vte_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_mac_config
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_mediachange_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_newbuf
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|,
name|struct
name|vte_rxdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_reset
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_rxeof
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_rxfilter
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_start_locked
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_start_mac
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_stats_clear
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_stats_update
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_stop
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_stop_mac
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vte_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_sysctl_node
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_txeof
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vte_watchdog
parameter_list|(
name|struct
name|vte_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_vte_int_mod
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|vte_methods
index|[]
init|=
block|{
comment|/* Device interface. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|vte_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|vte_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|vte_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|vte_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|vte_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|vte_resume
argument_list|)
block|,
comment|/* MII interface. */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|vte_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|vte_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|vte_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|vte_driver
init|=
block|{
literal|"vte"
block|,
name|vte_methods
block|,
expr|sizeof
operator|(
expr|struct
name|vte_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|vte_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|vte
argument_list|,
name|pci
argument_list|,
name|vte_driver
argument_list|,
name|vte_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|vte
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|vte_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MMDIO
argument_list|,
name|MMDIO_READ
operator||
operator|(
name|phy
operator|<<
name|MMDIO_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|MMDIO_REG_ADDR_SHIFT
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTE_PHY_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MMDIO
argument_list|)
operator|&
name|MMDIO_READ
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"phy read timeout : %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MMRD
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MMWD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MMDIO
argument_list|,
name|MMDIO_WRITE
operator||
operator|(
name|phy
operator|<<
name|MMDIO_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|MMDIO_REG_ADDR_SHIFT
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTE_PHY_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MMDIO
argument_list|)
operator|&
name|MMDIO_WRITE
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"phy write timeout : %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|sc
operator|->
name|vte_flags
operator|&=
operator|~
name|VTE_FLAG_LINK
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
operator|)
operator|==
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
case|case
name|IFM_100_TX
case|:
name|sc
operator|->
name|vte_flags
operator||=
name|VTE_FLAG_LINK
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* Stop RX/TX MACs. */
name|vte_stop_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program MACs with resolved duplex and flow control. */
if|if
condition|(
operator|(
name|sc
operator|->
name|vte_flags
operator|&
name|VTE_FLAG_LINK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Timer waiting time : (63 + TIMER * 64) MII clock. 		 * MII clock : 25MHz(100Mbps) or 2.5MHz(10Mbps). 		 */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_100_TX
condition|)
name|val
operator|=
literal|18
operator|<<
name|VTE_IM_TIMER_SHIFT
expr_stmt|;
else|else
name|val
operator|=
literal|1
operator|<<
name|VTE_IM_TIMER_SHIFT
expr_stmt|;
name|val
operator||=
name|sc
operator|->
name|vte_int_rx_mod
operator|<<
name|VTE_IM_BUNDLE_SHIFT
expr_stmt|;
comment|/* 48.6us for 100Mbps, 50.8us for 10Mbps */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRICR
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_100_TX
condition|)
name|val
operator|=
literal|18
operator|<<
name|VTE_IM_TIMER_SHIFT
expr_stmt|;
else|else
name|val
operator|=
literal|1
operator|<<
name|VTE_IM_TIMER_SHIFT
expr_stmt|;
name|val
operator||=
name|sc
operator|->
name|vte_int_tx_mod
operator|<<
name|VTE_IM_BUNDLE_SHIFT
expr_stmt|;
comment|/* 48.6us for 100Mbps, 50.8us for 10Mbps */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MTICR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|vte_mac_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vte_start_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vte_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|vte_mediachange_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_mediachange_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|PHY_RESET
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|vte_ident
modifier|*
name|vte_find_ident
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|vte_ident
modifier|*
name|ident
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|,
name|devid
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|ident
operator|=
name|vte_ident_table
init|;
name|ident
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ident
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|ident
operator|->
name|vendorid
operator|&&
name|devid
operator|==
name|ident
operator|->
name|deviceid
condition|)
return|return
operator|(
name|ident
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|vte_ident
modifier|*
name|ident
decl_stmt|;
name|ident
operator|=
name|vte_find_ident
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ident
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|ident
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_get_macaddr
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|mid
decl_stmt|;
comment|/* 	 * It seems there is no way to reload station address and 	 * it is supposed to be set by BIOS. 	 */
name|mid
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MID0L
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_eaddr
index|[
literal|0
index|]
operator|=
operator|(
name|mid
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|vte_eaddr
index|[
literal|1
index|]
operator|=
operator|(
name|mid
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|mid
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MID0M
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_eaddr
index|[
literal|2
index|]
operator|=
operator|(
name|mid
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|vte_eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|mid
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|mid
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MID0H
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_eaddr
index|[
literal|4
index|]
operator|=
operator|(
name|mid
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|vte_eaddr
index|[
literal|5
index|]
operator|=
operator|(
name|mid
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|macid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|vte_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|vte_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|vte_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_ident
operator|=
name|vte_find_ident
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Map the device. */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_res_id
operator|=
name|PCIR_BAR
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_res_type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|sc
operator|->
name|vte_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|vte_res_type
argument_list|,
operator|&
name|sc
operator|->
name|vte_res_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_res
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|vte_res_id
operator|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_res_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|sc
operator|->
name|vte_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|vte_res_type
argument_list|,
operator|&
name|sc
operator|->
name|vte_res_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map memory/ports.\n"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|vte_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %s space register mapping\n"
argument_list|,
name|sc
operator|->
name|vte_res_type
operator|==
name|SYS_RES_MEMORY
condition|?
literal|"memory"
else|:
literal|"I/O"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MAC Identifier : 0x%04x\n"
argument_list|,
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MACID
argument_list|)
argument_list|)
expr_stmt|;
name|macid
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MACID_REV
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MAC Id. 0x%02x, Rev. 0x%02x\n"
argument_list|,
operator|(
name|macid
operator|&
name|VTE_MACID_MASK
operator|)
operator|>>
name|VTE_MACID_SHIFT
argument_list|,
operator|(
name|macid
operator|&
name|VTE_MACID_REV_MASK
operator|)
operator|>>
name|VTE_MACID_REV_SHIFT
argument_list|)
expr_stmt|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vte_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate IRQ resources.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Reset the ethernet controller. */
name|vte_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vte_dma_alloc
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Create device sysctl node. */
name|vte_sysctl_node
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Load station address. */
name|vte_get_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate ifnet structure.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|vte_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|vte_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|vte_init
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|vte_get_counter
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|VTE_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Set up MII bus. 	 * BIOS would have initialized VTE_MPSCCR to catch PHY 	 * status changes so driver may be able to extract 	 * configured PHY address.  Since it's common to see BIOS 	 * fails to initialize the register(including the sample 	 * board I have), let mii(4) probe it.  This is more 	 * reliable than relying on BIOS's initialization. 	 * 	 * Advertising flow control capability to mii(4) was 	 * intentionally disabled due to severe problems in TX 	 * pause frame generation.  See vte_rxeof() for more 	 * details. 	 */
name|error
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|vte_miibus
argument_list|,
name|ifp
argument_list|,
name|vte_mediachange
argument_list|,
name|vte_mediastatus
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attaching PHYs failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|vte_eaddr
argument_list|)
expr_stmt|;
comment|/* VLAN capability setup. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Tell the upper layer we support VLAN over-sized frames. */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|vte_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|vte_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|vte_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set up interrupt handler.\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|vte_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vte_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|vte_tick_ch
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vte_miibus
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_miibus
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_intrhand
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|vte_irq
argument_list|,
name|sc
operator|->
name|vte_intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_intrhand
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vte_irq
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|vte_irq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_irq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vte_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|vte_res_type
argument_list|,
name|sc
operator|->
name|vte_res_id
argument_list|,
name|sc
operator|->
name|vte_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|vte_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|vte_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VTE_SYSCTL_STAT_ADD32
parameter_list|(
name|c
parameter_list|,
name|h
parameter_list|,
name|n
parameter_list|,
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|SYSCTL_ADD_UINT(c, h, OID_AUTO, n, CTLFLAG_RD, p, 0, d)
end_define

begin_function
specifier|static
name|void
name|vte_sysctl_node
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|vte_hw_stats
modifier|*
name|stats
decl_stmt|;
name|int
name|error
decl_stmt|;
name|stats
operator|=
operator|&
name|sc
operator|->
name|vte_stats
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"int_rx_mod"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|vte_int_rx_mod
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_vte_int_mod
argument_list|,
literal|"I"
argument_list|,
literal|"vte RX interrupt moderation"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"int_tx_mod"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|vte_int_tx_mod
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_vte_int_mod
argument_list|,
literal|"I"
argument_list|,
literal|"vte TX interrupt moderation"
argument_list|)
expr_stmt|;
comment|/* Pull in device tunables. */
name|sc
operator|->
name|vte_int_rx_mod
operator|=
name|VTE_IM_RX_BUNDLE_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|,
literal|"int_rx_mod"
argument_list|,
operator|&
name|sc
operator|->
name|vte_int_rx_mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vte_int_rx_mod
operator|<
name|VTE_IM_BUNDLE_MIN
operator|||
name|sc
operator|->
name|vte_int_rx_mod
operator|>
name|VTE_IM_BUNDLE_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"int_rx_mod value out of "
literal|"range; using default: %d\n"
argument_list|,
name|VTE_IM_RX_BUNDLE_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_int_rx_mod
operator|=
name|VTE_IM_RX_BUNDLE_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|vte_int_tx_mod
operator|=
name|VTE_IM_TX_BUNDLE_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|,
literal|"int_tx_mod"
argument_list|,
operator|&
name|sc
operator|->
name|vte_int_tx_mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vte_int_tx_mod
operator|<
name|VTE_IM_BUNDLE_MIN
operator|||
name|sc
operator|->
name|vte_int_tx_mod
operator|>
name|VTE_IM_BUNDLE_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"int_tx_mod value out of "
literal|"range; using default: %d\n"
argument_list|,
name|VTE_IM_TX_BUNDLE_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_int_tx_mod
operator|=
name|VTE_IM_TX_BUNDLE_DEFAULT
expr_stmt|;
block|}
block|}
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"VTE statistics"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* RX statistics. */
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|parent
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"RX MAC statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"good_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_frames
argument_list|,
literal|"Good frames"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"good_bcast_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_bcast_frames
argument_list|,
literal|"Good broadcast frames"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"good_mcast_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_mcast_frames
argument_list|,
literal|"Good multicast frames"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"runt"
argument_list|,
operator|&
name|stats
operator|->
name|rx_runts
argument_list|,
literal|"Too short frames"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"crc_errs"
argument_list|,
operator|&
name|stats
operator|->
name|rx_crcerrs
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"long_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_long_frames
argument_list|,
literal|"Frames that have longer length than maximum packet length"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"fifo_full"
argument_list|,
operator|&
name|stats
operator|->
name|rx_fifo_full
argument_list|,
literal|"FIFO full"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"desc_unavail"
argument_list|,
operator|&
name|stats
operator|->
name|rx_desc_unavail
argument_list|,
literal|"Descriptor unavailable frames"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"pause_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_pause_frames
argument_list|,
literal|"Pause control frames"
argument_list|)
expr_stmt|;
comment|/* TX statistics. */
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|parent
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"TX MAC statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"good_frames"
argument_list|,
operator|&
name|stats
operator|->
name|tx_frames
argument_list|,
literal|"Good frames"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"underruns"
argument_list|,
operator|&
name|stats
operator|->
name|tx_underruns
argument_list|,
literal|"FIFO underruns"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"late_colls"
argument_list|,
operator|&
name|stats
operator|->
name|tx_late_colls
argument_list|,
literal|"Late collisions"
argument_list|)
expr_stmt|;
name|VTE_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"pause_frames"
argument_list|,
operator|&
name|stats
operator|->
name|tx_pause_frames
argument_list|,
literal|"Pause control frames"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|VTE_SYSCTL_STAT_ADD32
end_undef

begin_struct
struct|struct
name|vte_dmamap_arg
block|{
name|bus_addr_t
name|vte_busaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|vte_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|vte_dmamap_arg
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|vte_dmamap_arg
operator|*
operator|)
name|arg
expr_stmt|;
name|ctx
operator|->
name|vte_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_dma_alloc
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|vte_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|vte_dmamap_arg
name|ctx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* Create parent DMA tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_parent_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create parent DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create DMA tag for TX descriptor ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_parent_tag
argument_list|,
comment|/* parent */
name|VTE_TX_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|VTE_TX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|VTE_TX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create TX ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create DMA tag for RX free descriptor ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_parent_tag
argument_list|,
comment|/* parent */
name|VTE_RX_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|VTE_RX_RING_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|VTE_RX_RING_SZ
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create RX ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for TX ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not allocate DMA'able memory for TX ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|vte_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
argument_list|,
name|VTE_TX_RING_SZ
argument_list|,
name|vte_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|vte_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not load DMA'able memory for TX ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_paddr
operator|=
name|ctx
operator|.
name|vte_busaddr
expr_stmt|;
comment|/* Allocate DMA'able memory and load the DMA map for RX ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not allocate DMA'able memory for RX ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|vte_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
argument_list|,
name|VTE_RX_RING_SZ
argument_list|,
name|vte_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|vte_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not load DMA'able memory for RX ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_paddr
operator|=
name|ctx
operator|.
name|vte_busaddr
expr_stmt|;
comment|/* Create TX buffer parent tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_buffer_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create parent buffer DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create DMA tag for TX buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_buffer_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create TX DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create DMA tag for RX buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_buffer_tag
argument_list|,
comment|/* parent */
name|VTE_RX_BUF_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create RX DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create DMA maps for TX buffers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create TX dmamap.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Create DMA maps for RX buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create spare RX dmamap.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not create RX dmamap.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_dma_free
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|vte_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* TX buffers. */
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* RX buffers */
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* TX descriptor ring. */
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_paddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_paddr
operator|=
literal|0
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* RX ring. */
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_paddr
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_paddr
operator|=
literal|0
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_buffer_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_buffer_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_buffer_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_parent_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_parent_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_parent_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vte_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|vte_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|vte_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vte_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|vte_txdesc
modifier|*
name|vte_encap
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|bus_dma_segment_t
name|txsegs
index|[
literal|1
index|]
decl_stmt|;
name|int
name|copy
decl_stmt|,
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|padlen
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
operator|(
operator|*
name|m_head
operator|)
argument_list|)
expr_stmt|;
name|txd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txdesc
index|[
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_prod
index|]
expr_stmt|;
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
comment|/* 	 * Controller doesn't auto-pad, so we have to make sure pad 	 * short frames out to the minimum frame length. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|VTE_MIN_FRAMELEN
condition|)
name|padlen
operator|=
name|VTE_MIN_FRAMELEN
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
else|else
name|padlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Controller does not support multi-fragmented TX buffers. 	 * Controller spends most of its TX processing time in 	 * de-fragmenting TX buffers.  Either faster CPU or more 	 * advanced controller DMA engine is required to speed up 	 * TX path processing. 	 * To mitigate the de-fragmenting issue, perform deep copy 	 * from fragmented mbuf chains to a pre-allocated mbuf 	 * cluster with extra cost of kernel memory.  For frames 	 * that is composed of single TX buffer, the deep copy is 	 * bypassed. 	 */
if|if
condition|(
name|tx_deep_copy
operator|!=
literal|0
condition|)
block|{
name|copy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
name|copy
operator|++
expr_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|0
operator|&&
operator|(
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|||
name|padlen
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|)
condition|)
name|copy
operator|++
expr_stmt|;
if|if
condition|(
name|copy
operator|!=
literal|0
condition|)
block|{
comment|/* Avoid expensive m_defrag(9) and do deep copy. */
name|n
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_prod
index|]
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
name|txd
operator|->
name|tx_flags
operator||=
name|VTE_TXMBUF
expr_stmt|;
block|}
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
comment|/* Zero out the bytes in the pad area. */
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|padlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
operator|||
name|padlen
operator|>
literal|0
condition|)
block|{
comment|/* Get a writable copy. */
name|m
operator|=
name|m_dup
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Release original mbuf chains. */
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|padlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|padlen
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
comment|/* Zero out the bytes in the pad area. */
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|padlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|m
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|txd
operator|->
name|tx_flags
operator|&=
operator|~
name|VTE_TXMBUF
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_desc
operator|->
name|dtlen
operator|=
name|htole16
argument_list|(
name|VTE_TX_LEN
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_desc
operator|->
name|dtbp
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|++
expr_stmt|;
comment|/* Update producer index. */
name|VTE_DESC_INC
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_prod
argument_list|,
name|VTE_TX_RING_CNT
argument_list|)
expr_stmt|;
comment|/* Finally hand over ownership to controller. */
name|txd
operator|->
name|tx_desc
operator|->
name|dtst
operator|=
name|htole16
argument_list|(
name|VTE_DTST_TX_OWN
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|txd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vte_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_start_locked
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|enq
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc
operator|->
name|vte_flags
operator|&
name|VTE_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|enq
operator|=
literal|0
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|;
control|)
block|{
comment|/* Reserve one free TX descriptor. */
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|>=
name|VTE_TX_RING_CNT
operator|-
literal|1
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, set the OACTIVE flag and wait 		 * for the NIC to drain the ring. 		 */
if|if
condition|(
operator|(
name|txd
operator|=
name|vte_encap
argument_list|(
name|sc
argument_list|,
operator|&
name|m_head
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|m_head
operator|!=
name|NULL
condition|)
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame 		 * to him. 		 */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
comment|/* Free consumed TX frame. */
if|if
condition|(
operator|(
name|txd
operator|->
name|tx_flags
operator|&
name|VTE_TXMBUF
operator|)
operator|!=
literal|0
condition|)
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_TX_POLL
argument_list|,
name|TX_POLL_START
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_watchdog_timer
operator|=
name|VTE_TX_TIMEOUT
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vte_watchdog
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|vte_watchdog_timer
condition|)
return|return;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|vte_ifp
argument_list|,
literal|"watchdog timeout -- resetting\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|vte_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|vte_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|vte_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
name|vte_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|vte_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|vte_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|vte_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_mac_config
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint16_t
name|mcr
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
name|mcr
operator|&=
operator|~
operator|(
name|MCR0_FC_ENB
operator||
name|MCR0_FULL_DUPLEX
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
block|{
name|mcr
operator||=
name|MCR0_FULL_DUPLEX
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|mcr
operator||=
name|MCR0_FC_ENB
expr_stmt|;
comment|/* 		 * The data sheet is not clear whether the controller 		 * honors received pause frames or not.  The is no 		 * separate control bit for RX pause frame so just 		 * enable MCR0_FC_ENB bit. 		 */
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|mcr
operator||=
name|MCR0_FC_ENB
expr_stmt|;
endif|#
directive|endif
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_stats_clear
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Reading counter registers clears its contents. */
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_RX_DONE
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT0
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT1
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT2
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT3
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_TX_DONE
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT4
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_PAUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_stats_update
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vte_hw_stats
modifier|*
name|stat
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
operator|&
name|sc
operator|->
name|vte_stats
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MECISR
argument_list|)
expr_stmt|;
comment|/* RX stats. */
name|stat
operator|->
name|rx_frames
operator|+=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_RX_DONE
argument_list|)
expr_stmt|;
name|value
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT0
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_bcast_frames
operator|+=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
name|stat
operator|->
name|rx_mcast_frames
operator|+=
operator|(
name|value
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|value
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT1
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_runts
operator|+=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
name|stat
operator|->
name|rx_crcerrs
operator|+=
operator|(
name|value
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|value
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT2
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_long_frames
operator|+=
operator|(
name|value
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|value
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT3
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_fifo_full
operator|+=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
name|stat
operator|->
name|rx_desc_unavail
operator|+=
operator|(
name|value
operator|&
literal|0xFF
operator|)
expr_stmt|;
comment|/* TX stats. */
name|stat
operator|->
name|tx_frames
operator|+=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_TX_DONE
argument_list|)
expr_stmt|;
name|value
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_MECNT4
argument_list|)
expr_stmt|;
name|stat
operator|->
name|tx_underruns
operator|+=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
name|stat
operator|->
name|tx_late_colls
operator|+=
operator|(
name|value
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|value
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_CNT_PAUSE
argument_list|)
expr_stmt|;
name|stat
operator|->
name|tx_pause_frames
operator|+=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
name|stat
operator|->
name|rx_pause_frames
operator|+=
operator|(
name|value
operator|&
literal|0xFF
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vte_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|vte_hw_stats
modifier|*
name|stat
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|stat
operator|=
operator|&
name|sc
operator|->
name|vte_stats
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_OPACKETS
case|:
return|return
operator|(
name|stat
operator|->
name|tx_frames
operator|)
return|;
case|case
name|IFCOUNTER_COLLISIONS
case|:
return|return
operator|(
name|stat
operator|->
name|tx_late_colls
operator|)
return|;
case|case
name|IFCOUNTER_OERRORS
case|:
return|return
operator|(
name|stat
operator|->
name|tx_late_colls
operator|+
name|stat
operator|->
name|tx_underruns
operator|)
return|;
case|case
name|IFCOUNTER_IPACKETS
case|:
return|return
operator|(
name|stat
operator|->
name|rx_frames
operator|)
return|;
case|case
name|IFCOUNTER_IERRORS
case|:
return|return
operator|(
name|stat
operator|->
name|rx_crcerrs
operator|+
name|stat
operator|->
name|rx_runts
operator|+
name|stat
operator|->
name|rx_long_frames
operator|+
name|stat
operator|->
name|rx_fifo_full
operator|)
return|;
default|default:
return|return
operator|(
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vte_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|n
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vte_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
comment|/* Reading VTE_MISR acknowledges interrupts. */
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MISR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|VTE_INTRS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Not ours. */
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MIER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|8
init|;
operator|(
name|status
operator|&
name|VTE_INTRS
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|MISR_RX_DONE
operator||
name|MISR_RX_DESC_UNAVAIL
operator||
name|MISR_RX_FIFO_FULL
operator|)
operator|)
operator|!=
literal|0
condition|)
name|vte_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MISR_TX_DONE
operator|)
operator|!=
literal|0
condition|)
name|vte_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|MISR_EVENT_CNT_OFLOW
operator|)
operator|!=
literal|0
condition|)
name|vte_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|vte_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MISR
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MIER
argument_list|,
name|VTE_INTRS
argument_list|)
expr_stmt|;
block|}
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_txeof
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|uint16_t
name|status
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|prog
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|==
literal|0
condition|)
return|return;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cons
expr_stmt|;
comment|/* 	 * Go through our TX list and free mbufs for those 	 * frames which have been transmitted. 	 */
for|for
control|(
name|prog
operator|=
literal|0
init|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|>
literal|0
condition|;
name|prog
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txdesc
index|[
name|cons
index|]
expr_stmt|;
name|status
operator|=
name|le16toh
argument_list|(
name|txd
operator|->
name|tx_desc
operator|->
name|dtst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|VTE_DTST_TX_OWN
operator|)
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|--
expr_stmt|;
comment|/* Reclaim transmitted mbufs. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txd
operator|->
name|tx_flags
operator|&
name|VTE_TXMBUF
operator|)
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_flags
operator|&=
operator|~
name|VTE_TXMBUF
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|prog
operator|++
expr_stmt|;
name|VTE_DESC_INC
argument_list|(
name|cons
argument_list|,
name|VTE_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|>
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cons
operator|=
name|cons
expr_stmt|;
comment|/* 		 * Unarm watchdog timer only when there is no pending 		 * frames in TX queue. 		 */
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|==
literal|0
condition|)
name|sc
operator|->
name|vte_watchdog_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vte_newbuf
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|vte_rxdesc
modifier|*
name|rxd
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|->
name|drbp
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|->
name|drlen
operator|=
name|htole16
argument_list|(
name|VTE_RX_LEN
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|->
name|drst
operator|=
name|htole16
argument_list|(
name|VTE_DRST_RX_OWN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * It's not supposed to see this controller on strict-alignment  * architectures but make it work for completeness.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|vte_fixup_rx
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint16_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|;
name|src
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint16_t
operator|*
argument_list|)
expr_stmt|;
name|dst
operator|=
name|src
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|m
operator|->
name|m_len
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
name|ETHER_ALIGN
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|vte_rxeof
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|vte_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint16_t
name|status
decl_stmt|,
name|total_len
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|prog
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cons
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_cons
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
for|for
control|(
name|prog
operator|=
literal|0
init|;
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|;
name|prog
operator|++
operator|,
name|VTE_DESC_INC
argument_list|(
name|cons
argument_list|,
name|VTE_RX_RING_CNT
argument_list|)
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rxdesc
index|[
name|cons
index|]
expr_stmt|;
name|status
operator|=
name|le16toh
argument_list|(
name|rxd
operator|->
name|rx_desc
operator|->
name|drst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|VTE_DRST_RX_OWN
operator|)
operator|!=
literal|0
condition|)
break|break;
name|total_len
operator|=
name|VTE_RX_LEN
argument_list|(
name|le16toh
argument_list|(
name|rxd
operator|->
name|rx_desc
operator|->
name|drlen
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|VTE_DRST_RX_OK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Discard errored frame. */
name|rxd
operator|->
name|rx_desc
operator|->
name|drlen
operator|=
name|htole16
argument_list|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|->
name|drst
operator|=
name|htole16
argument_list|(
name|VTE_DRST_RX_OWN
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vte_newbuf
argument_list|(
name|sc
argument_list|,
name|rxd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|->
name|drlen
operator|=
name|htole16
argument_list|(
name|MCLBYTES
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|->
name|drst
operator|=
name|htole16
argument_list|(
name|VTE_DRST_RX_OWN
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * It seems there is no way to strip FCS bytes. 		 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|total_len
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
name|vte_fixup_rx
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|>
literal|0
condition|)
block|{
comment|/* Update the consumer index. */
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_cons
operator|=
name|cons
expr_stmt|;
comment|/* 		 * Sync updated RX descriptors such that controller see 		 * modified RX buffer addresses. 		 */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * Update residue counter.  Controller does not 		 * keep track of number of available RX descriptors 		 * such that driver should have to update VTE_MRDCR 		 * to make controller know how many free RX 		 * descriptors were added to controller.  This is 		 * a similar mechanism used in VIA velocity 		 * controllers and it indicates controller just 		 * polls OWN bit of current RX descriptor pointer. 		 * A couple of severe issues were seen on sample 		 * board where the controller continuously emits TX 		 * pause frames once RX pause threshold crossed. 		 * Once triggered it never recovered form that 		 * state, I couldn't find a way to make it back to 		 * work at least.  This issue effectively 		 * disconnected the system from network.  Also, the 		 * controller used 00:00:00:00:00:00 as source 		 * station address of TX pause frame. Probably this 		 * is one of reason why vendor recommends not to 		 * enable flow control on R6040 controller. 		 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRDCR
argument_list|,
name|prog
operator||
operator|(
operator|(
operator|(
name|VTE_RX_RING_CNT
operator|*
literal|2
operator|)
operator|/
literal|10
operator|)
operator|<<
name|VTE_MRDCR_RX_PAUSE_THRESH_SHIFT
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vte_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vte_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|vte_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|vte_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vte_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vte_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vte_tick_ch
argument_list|,
name|hz
argument_list|,
name|vte_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_reset
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|mcr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR1
argument_list|,
name|mcr
operator||
name|MCR1_MAC_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTE_RESET_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR1
argument_list|)
operator|&
name|MCR1_MAC_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"reset timeout(0x%04x)!\n"
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
comment|/* 	 * Follow the guide of vendor recommended way to reset MAC. 	 * Vendor confirms relying on MCR1_MAC_RESET of VTE_MCR1 is 	 * not reliable so manually reset internal state machine. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MACSM
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MACSM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|vte_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|vte_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|VTE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vte_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VTE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_init_locked
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Cancel any pending I/O. 	 */
name|vte_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the chip to a known state. 	 */
name|vte_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize RX descriptors. */
if|if
condition|(
name|vte_init_rx_ring
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"no memory for RX buffers.\n"
argument_list|)
expr_stmt|;
name|vte_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vte_init_tx_ring
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"no memory for TX buffers.\n"
argument_list|)
expr_stmt|;
name|vte_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Reprogram the station address.  Controller supports up 	 * to 4 different station addresses so driver programs the 	 * first station address as its own ethernet address and 	 * configure the remaining three addresses as perfect 	 * multicast addresses. 	 */
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|vte_ifp
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MID0L
argument_list|,
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MID0M
argument_list|,
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MID0H
argument_list|,
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Set TX descriptor base addresses. */
name|paddr
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_paddr
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MTDSA1
argument_list|,
name|paddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MTDSA0
argument_list|,
name|paddr
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Set RX descriptor base addresses. */
name|paddr
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_paddr
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRDSA1
argument_list|,
name|paddr
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRDSA0
argument_list|,
name|paddr
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize RX descriptor residue counter and set RX 	 * pause threshold to 20% of available RX descriptors. 	 * See comments on vte_rxeof() for details on flow control 	 * issues. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRDCR
argument_list|,
operator|(
name|VTE_RX_RING_CNT
operator|&
name|VTE_MRDCR_RESIDUE_MASK
operator|)
operator||
operator|(
operator|(
operator|(
name|VTE_RX_RING_CNT
operator|*
literal|2
operator|)
operator|/
literal|10
operator|)
operator|<<
name|VTE_MRDCR_RX_PAUSE_THRESH_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Always use maximum frame size that controller can 	 * support.  Otherwise received frames that has longer 	 * frame length than vte(4) MTU would be silently dropped 	 * in controller.  This would break path-MTU discovery as 	 * sender wouldn't get any responses from receiver. The 	 * RX buffer size should be multiple of 4. 	 * Note, jumbo frames are silently ignored by controller 	 * and even MAC counters do not detect them. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRBSR
argument_list|,
name|VTE_RX_BUF_SIZE_MAX
argument_list|)
expr_stmt|;
comment|/* Configure FIFO. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MBCR
argument_list|,
name|MBCR_FIFO_XFER_LENGTH_16
operator||
name|MBCR_TX_FIFO_THRESH_64
operator||
name|MBCR_RX_FIFO_THRESH_16
operator||
name|MBCR_SDRAM_BUS_REQ_TIMER_DEFAULT
argument_list|)
expr_stmt|;
comment|/* 	 * Configure TX/RX MACs.  Actual resolved duplex and flow 	 * control configuration is done after detecting a valid 	 * link.  Note, we don't generate early interrupt here 	 * as well since FreeBSD does not have interrupt latency 	 * problems like Windows. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|,
name|MCR0_ACCPT_LONG_PKT
argument_list|)
expr_stmt|;
comment|/* 	 * We manually keep track of PHY status changes to 	 * configure resolved duplex and flow control since only 	 * duplex configuration can be automatically reflected to 	 * MCR0. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR1
argument_list|,
name|MCR1_PKT_LENGTH_1537
operator||
name|MCR1_EXCESS_COL_RETRY_16
argument_list|)
expr_stmt|;
comment|/* Initialize RX filter. */
name|vte_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable TX/RX interrupt moderation control. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MRICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MTICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable MAC event counter interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MECIER
argument_list|,
name|VTE_MECIER_INTRS
argument_list|)
expr_stmt|;
comment|/* Clear MAC statistics. */
name|vte_stats_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Acknowledge all pending interrupts and clear it. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MIER
argument_list|,
name|VTE_INTRS
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MISR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_flags
operator|&=
operator|~
name|VTE_FLAG_LINK
expr_stmt|;
comment|/* Switch to the current media. */
name|vte_mediachange_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|vte_tick_ch
argument_list|,
name|hz
argument_list|,
name|vte_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_stop
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|vte_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|vte_flags
operator|&=
operator|~
name|VTE_FLAG_LINK
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|vte_tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_watchdog_timer
operator|=
literal|0
expr_stmt|;
name|vte_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MIER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MECIER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop RX/TX MACs. */
name|vte_stop_mac
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear interrupts. */
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MISR
argument_list|)
expr_stmt|;
comment|/* 	 * Free TX/RX mbufs still in the queues. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txd
operator|->
name|tx_flags
operator|&
name|VTE_TXMBUF
operator|)
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_flags
operator|&=
operator|~
name|VTE_TXMBUF
expr_stmt|;
block|}
block|}
comment|/* Free TX mbuf pools used for deep copy. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vte_start_mac
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|mcr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable RX/TX MACs. */
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcr
operator|&
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
operator|)
operator|!=
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
condition|)
block|{
name|mcr
operator||=
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTE_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcr
operator|&
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
operator|)
operator|==
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not enable RX/TX MAC(0x%04x)!\n"
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vte_stop_mac
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint16_t
name|mcr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable RX/TX MACs. */
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcr
operator|&
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mcr
operator|&=
operator|~
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VTE_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcr
operator|&
operator|(
name|MCR0_RX_ENB
operator||
name|MCR0_TX_ENB
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|vte_dev
argument_list|,
literal|"could not disable RX/TX MAC(0x%04x)!\n"
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vte_init_tx_ring
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vte_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|vte_txdesc
modifier|*
name|txd
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_cnt
operator|=
literal|0
expr_stmt|;
comment|/* Pre-allocate TX mbufs for deep copy. */
if|if
condition|(
name|tx_deep_copy
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txmbufs
index|[
name|i
index|]
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
block|}
name|desc
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
name|VTE_TX_RING_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|VTE_TX_RING_CNT
operator|-
literal|1
condition|)
name|addr
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vte_tx_desc
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|addr
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vte_tx_desc
argument_list|)
operator|*
literal|0
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|dtnp
operator|=
name|htole32
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_desc
operator|=
name|desc
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vte_init_rx_ring
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|vte_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|vte_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_cons
operator|=
literal|0
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
expr_stmt|;
name|bzero
argument_list|(
name|desc
argument_list|,
name|VTE_RX_RING_SZ
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|VTE_RX_RING_CNT
operator|-
literal|1
condition|)
name|addr
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vte_rx_desc
argument_list|)
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|addr
operator|=
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_paddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vte_rx_desc
argument_list|)
operator|*
literal|0
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring
index|[
name|i
index|]
expr_stmt|;
name|desc
operator|->
name|drnp
operator|=
name|htole32
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|=
name|desc
expr_stmt|;
if|if
condition|(
name|vte_newbuf
argument_list|(
name|sc
argument_list|,
name|rxd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_tag
argument_list|,
name|sc
operator|->
name|vte_cdata
operator|.
name|vte_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vte_rxfilter
parameter_list|(
name|struct
name|vte_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint16_t
name|rxfilt_perf
index|[
name|VTE_RXFILT_PERFECT_CNT
index|]
index|[
literal|3
index|]
decl_stmt|;
name|uint16_t
name|mchash
index|[
literal|4
index|]
decl_stmt|,
name|mcr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nperf
decl_stmt|;
name|VTE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|vte_ifp
expr_stmt|;
name|bzero
argument_list|(
name|mchash
argument_list|,
sizeof|sizeof
argument_list|(
name|mchash
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_RXFILT_PERFECT_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxfilt_perf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|rxfilt_perf
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|rxfilt_perf
index|[
name|i
index|]
index|[
literal|2
index|]
operator|=
literal|0xFFFF
expr_stmt|;
block|}
name|mcr
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
name|mcr
operator|&=
operator|~
operator|(
name|MCR0_PROMISC
operator||
name|MCR0_MULTICAST
operator|)
expr_stmt|;
name|mcr
operator||=
name|MCR0_BROADCAST_DIS
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|!=
literal|0
condition|)
name|mcr
operator|&=
operator|~
name|MCR0_BROADCAST_DIS
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|mcr
operator||=
name|MCR0_PROMISC
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
name|mcr
operator||=
name|MCR0_MULTICAST
expr_stmt|;
name|mchash
index|[
literal|0
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|mchash
index|[
literal|1
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|mchash
index|[
literal|2
index|]
operator|=
literal|0xFFFF
expr_stmt|;
name|mchash
index|[
literal|3
index|]
operator|=
literal|0xFFFF
expr_stmt|;
goto|goto
name|chipit
goto|;
block|}
name|nperf
operator|=
literal|0
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->vte_ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
comment|/* 		 * Program the first 3 multicast groups into 		 * the perfect filter.  For all others, use the 		 * hash table. 		 */
if|if
condition|(
name|nperf
operator|<
name|VTE_RXFILT_PERFECT_CNT
condition|)
block|{
name|eaddr
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|rxfilt_perf
index|[
name|nperf
index|]
index|[
literal|0
index|]
operator|=
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|0
index|]
expr_stmt|;
name|rxfilt_perf
index|[
name|nperf
index|]
index|[
literal|1
index|]
operator|=
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|2
index|]
expr_stmt|;
name|rxfilt_perf
index|[
name|nperf
index|]
index|[
literal|2
index|]
operator|=
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|4
index|]
expr_stmt|;
name|nperf
operator|++
expr_stmt|;
continue|continue;
block|}
name|crc
operator|=
name|ether_crc32_be
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|mchash
index|[
name|crc
operator|>>
literal|30
index|]
operator||=
literal|1
operator|<<
operator|(
operator|(
name|crc
operator|>>
literal|26
operator|)
operator|&
literal|0x0F
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mchash
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|mchash
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|mchash
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|mchash
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|mcr
operator||=
name|MCR0_MULTICAST
expr_stmt|;
name|chipit
label|:
comment|/* Program multicast hash table. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MAR0
argument_list|,
name|mchash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MAR1
argument_list|,
name|mchash
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MAR2
argument_list|,
name|mchash
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MAR3
argument_list|,
name|mchash
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Program perfect filter table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VTE_RXFILT_PERFECT_CNT
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_RXFILTER_PEEFECT_BASE
operator|+
literal|8
operator|*
name|i
operator|+
literal|0
argument_list|,
name|rxfilt_perf
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_RXFILTER_PEEFECT_BASE
operator|+
literal|8
operator|*
name|i
operator|+
literal|2
argument_list|,
name|rxfilt_perf
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_RXFILTER_PEEFECT_BASE
operator|+
literal|8
operator|*
name|i
operator|+
literal|4
argument_list|,
name|rxfilt_perf
index|[
name|i
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|VTE_MCR0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
name|low
operator|||
name|value
operator|>
name|high
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_vte_int_mod
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|VTE_IM_BUNDLE_MIN
argument_list|,
name|VTE_IM_BUNDLE_MAX
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

