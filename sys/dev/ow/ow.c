begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 M. Warner Losh<imp@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<dev/ow/ow.h>
end_include

begin_include
include|#
directive|include
file|<dev/ow/owll.h>
end_include

begin_include
include|#
directive|include
file|<dev/ow/own.h>
end_include

begin_comment
comment|/*  * lldev - link level device  * ndev - network / transport device (this module)  * pdev - presentation device (children of this module)  */
end_comment

begin_typedef
typedef|typedef
name|int
name|ow_enum_fn
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|ow_found_fn
parameter_list|(
name|device_t
parameter_list|,
name|romid_t
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|ow_softc
block|{
name|device_t
name|dev
decl_stmt|;
comment|/* Newbus driver back pointer */
name|struct
name|mtx
name|mtx
decl_stmt|;
comment|/* bus mutex */
name|device_t
name|owner
decl_stmt|;
comment|/* bus owner, if != NULL */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ow_devinfo
block|{
name|romid_t
name|romid
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|ow_acquire_bus
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|,
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ow_release_bus
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|OW_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->mtx)
end_define

begin_define
define|#
directive|define
name|OW_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->mtx)
end_define

begin_define
define|#
directive|define
name|OW_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&_sc->mtx)
end_define

begin_define
define|#
directive|define
name|OW_ASSERT_LOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&_sc->mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|OW_ASSERT_UNLOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&_sc->mtx, MA_NOTOWNED)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_OW
argument_list|,
literal|"ow"
argument_list|,
literal|"House keeping data for 1wire bus"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|ow_timing
name|timing_regular
init|=
block|{
operator|.
name|t_slot
operator|=
literal|60
block|,
comment|/* 60 to 120 */
operator|.
name|t_low0
operator|=
literal|60
block|,
comment|/* really 60 to 120 */
operator|.
name|t_low1
operator|=
literal|1
block|,
comment|/* really 1 to 15 */
operator|.
name|t_release
operator|=
literal|45
block|,
comment|/*<= 45us */
operator|.
name|t_rec
operator|=
literal|1
block|,
comment|/* at least 1us */
operator|.
name|t_rdv
operator|=
literal|15
block|,
comment|/* 15us */
operator|.
name|t_rstl
operator|=
literal|480
block|,
comment|/* 480us or more */
operator|.
name|t_rsth
operator|=
literal|480
block|,
comment|/* 480us or more */
operator|.
name|t_pdl
operator|=
literal|60
block|,
comment|/* 60us to 240us */
operator|.
name|t_pdh
operator|=
literal|60
block|,
comment|/* 15us to 60us */
operator|.
name|t_lowr
operator|=
literal|1
block|,
comment|/* 1us */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NB: Untested */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ow_timing
name|timing_overdrive
init|=
block|{
operator|.
name|t_slot
operator|=
literal|11
block|,
comment|/* 6us to 16us */
operator|.
name|t_low0
operator|=
literal|6
block|,
comment|/* really 6 to 16 */
operator|.
name|t_low1
operator|=
literal|1
block|,
comment|/* really 1 to 2 */
operator|.
name|t_release
operator|=
literal|4
block|,
comment|/*<= 4us */
operator|.
name|t_rec
operator|=
literal|1
block|,
comment|/* at least 1us */
operator|.
name|t_rdv
operator|=
literal|2
block|,
comment|/* 2us */
operator|.
name|t_rstl
operator|=
literal|48
block|,
comment|/* 48us to 80us */
operator|.
name|t_rsth
operator|=
literal|48
block|,
comment|/* 48us or more  */
operator|.
name|t_pdl
operator|=
literal|8
block|,
comment|/* 8us to 24us */
operator|.
name|t_pdh
operator|=
literal|2
block|,
comment|/* 2us to 6us */
operator|.
name|t_lowr
operator|=
literal|1
block|,
comment|/* 1us */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ow_send_byte
parameter_list|(
name|device_t
name|lldev
parameter_list|,
name|struct
name|ow_timing
modifier|*
name|t
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|byte
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|OWLL_WRITE_ONE
argument_list|(
name|lldev
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|OWLL_WRITE_ZERO
argument_list|(
name|lldev
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ow_read_byte
parameter_list|(
name|device_t
name|lldev
parameter_list|,
name|struct
name|ow_timing
modifier|*
name|t
parameter_list|,
name|uint8_t
modifier|*
name|bytep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|byte
init|=
literal|0
decl_stmt|;
name|int
name|bit
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|OWLL_READ_DATA
argument_list|(
name|lldev
argument_list|,
name|t
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
name|byte
operator||=
name|bit
operator|<<
name|i
expr_stmt|;
block|}
operator|*
name|bytep
operator|=
name|byte
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_send_command
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|,
name|struct
name|ow_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|present
decl_stmt|,
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|tries
decl_stmt|;
name|device_t
name|lldev
decl_stmt|;
name|struct
name|ow_timing
modifier|*
name|t
decl_stmt|;
name|lldev
operator|=
name|device_get_parent
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
comment|/* 	 * Retry the reset a couple of times before giving up. 	 */
name|tries
operator|=
literal|4
expr_stmt|;
do|do
block|{
name|OWLL_RESET_AND_PRESENCE
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|,
operator|&
name|present
argument_list|)
expr_stmt|;
if|if
condition|(
name|present
operator|==
literal|1
condition|)
name|device_printf
argument_list|(
name|ndev
argument_list|,
literal|"Reset said no device on bus?.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|present
operator|==
literal|1
operator|&&
name|tries
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|present
operator|==
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|ndev
argument_list|,
literal|"Reset said the device wasn't there.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
comment|/* No devices acked the RESET */
block|}
if|if
condition|(
name|present
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|ndev
argument_list|,
literal|"Reset discovered bus wired wrong.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|rom_len
condition|;
name|i
operator|++
control|)
name|ow_send_byte
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|,
name|cmd
operator|->
name|rom_cmd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|rom_read_len
condition|;
name|i
operator|++
control|)
name|ow_read_byte
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|,
name|cmd
operator|->
name|rom_read
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|xpt_len
condition|)
block|{
comment|/* 		 * Per AN937, the reset pulse and ROM level are always 		 * done with the regular timings. Certain ROM commands 		 * put the device into overdrive mode for the remainder 		 * of the data transfer, which is why we have to pass the 		 * timings here. Commands that need to be handled like this 		 * are expected to be flagged by the client. 		 */
name|t
operator|=
operator|(
name|cmd
operator|->
name|flags
operator|&
name|OW_FLAG_OVERDRIVE
operator|)
condition|?
operator|&
name|timing_overdrive
else|:
operator|&
name|timing_regular
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|xpt_len
condition|;
name|i
operator|++
control|)
name|ow_send_byte
argument_list|(
name|lldev
argument_list|,
name|t
argument_list|,
name|cmd
operator|->
name|xpt_cmd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|OW_FLAG_READ_BIT
condition|)
block|{
name|memset
argument_list|(
name|cmd
operator|->
name|xpt_read
argument_list|,
literal|0
argument_list|,
operator|(
name|cmd
operator|->
name|xpt_read_len
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|xpt_read_len
condition|;
name|i
operator|++
control|)
block|{
name|OWLL_READ_DATA
argument_list|(
name|lldev
argument_list|,
name|t
argument_list|,
operator|&
name|bit
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|xpt_read
index|[
name|i
operator|/
literal|8
index|]
operator||=
name|bit
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|xpt_read_len
condition|;
name|i
operator|++
control|)
name|ow_read_byte
argument_list|(
name|lldev
argument_list|,
name|t
argument_list|,
name|cmd
operator|->
name|xpt_read
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_search_rom
parameter_list|(
name|device_t
name|lldev
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ow_cmd
name|cmd
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|rom_cmd
index|[
literal|0
index|]
operator|=
name|SEARCH_ROM
expr_stmt|;
name|cmd
operator|.
name|rom_len
operator|=
literal|1
expr_stmt|;
return|return
name|ow_send_command
argument_list|(
name|lldev
argument_list|,
name|dev
argument_list|,
operator|&
name|cmd
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int ow_alarm_search(device_t lldev, device_t dev) { 	struct ow_cmd cmd;  	memset(&cmd, 0, sizeof(cmd)); 	cmd.rom_cmd[0] = ALARM_SEARCH; 	cmd.rom_len = 1; 	return ow_send_command(lldev, dev,&cmd); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ow_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|romid_t
name|romid
parameter_list|)
block|{
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|di
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|di
argument_list|)
argument_list|,
name|M_OW
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|di
operator|->
name|romid
operator|=
name|romid
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|di
argument_list|,
name|M_OW
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|di
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|device_t
name|ow_child_by_romid
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|romid_t
name|romid
parameter_list|)
block|{
name|device_t
modifier|*
name|children
decl_stmt|,
name|retval
decl_stmt|,
name|child
decl_stmt|;
name|int
name|nkid
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nkid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|retval
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkid
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|children
index|[
name|i
index|]
expr_stmt|;
name|di
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|->
name|romid
operator|==
name|romid
condition|)
block|{
name|retval
operator|=
name|child
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CRC generator table -- taken from AN937 DOW CRC LOOKUP FUNCTION Table 2  */
end_comment

begin_decl_stmt
specifier|const
name|uint8_t
name|ow_crc_table
index|[]
init|=
block|{
literal|0
block|,
literal|94
block|,
literal|188
block|,
literal|226
block|,
literal|97
block|,
literal|63
block|,
literal|221
block|,
literal|131
block|,
literal|194
block|,
literal|156
block|,
literal|126
block|,
literal|32
block|,
literal|163
block|,
literal|253
block|,
literal|31
block|,
literal|65
block|,
literal|157
block|,
literal|195
block|,
literal|33
block|,
literal|127
block|,
literal|252
block|,
literal|162
block|,
literal|64
block|,
literal|30
block|,
literal|95
block|,
literal|1
block|,
literal|227
block|,
literal|189
block|,
literal|62
block|,
literal|96
block|,
literal|130
block|,
literal|220
block|,
literal|35
block|,
literal|125
block|,
literal|159
block|,
literal|193
block|,
literal|66
block|,
literal|28
block|,
literal|254
block|,
literal|160
block|,
literal|225
block|,
literal|191
block|,
literal|93
block|,
literal|3
block|,
literal|128
block|,
literal|222
block|,
literal|60
block|,
literal|98
block|,
literal|190
block|,
literal|224
block|,
literal|2
block|,
literal|92
block|,
literal|223
block|,
literal|129
block|,
literal|99
block|,
literal|61
block|,
literal|124
block|,
literal|34
block|,
literal|192
block|,
literal|158
block|,
literal|29
block|,
literal|67
block|,
literal|161
block|,
literal|255
block|,
literal|70
block|,
literal|24
block|,
literal|250
block|,
literal|164
block|,
literal|39
block|,
literal|121
block|,
literal|155
block|,
literal|197
block|,
literal|132
block|,
literal|218
block|,
literal|56
block|,
literal|102
block|,
literal|229
block|,
literal|187
block|,
literal|89
block|,
literal|7
block|,
literal|219
block|,
literal|133
block|,
literal|103
block|,
literal|57
block|,
literal|186
block|,
literal|228
block|,
literal|6
block|,
literal|88
block|,
literal|25
block|,
literal|71
block|,
literal|165
block|,
literal|251
block|,
literal|120
block|,
literal|38
block|,
literal|196
block|,
literal|154
block|,
literal|101
block|,
literal|59
block|,
literal|217
block|,
literal|135
block|,
literal|4
block|,
literal|90
block|,
literal|184
block|,
literal|230
block|,
literal|167
block|,
literal|249
block|,
literal|27
block|,
literal|69
block|,
literal|198
block|,
literal|152
block|,
literal|122
block|,
literal|36
block|,
literal|248
block|,
literal|166
block|,
literal|68
block|,
literal|26
block|,
literal|153
block|,
literal|199
block|,
literal|37
block|,
literal|123
block|,
literal|58
block|,
literal|100
block|,
literal|134
block|,
literal|216
block|,
literal|91
block|,
literal|5
block|,
literal|231
block|,
literal|185
block|,
literal|140
block|,
literal|210
block|,
literal|48
block|,
literal|110
block|,
literal|237
block|,
literal|179
block|,
literal|81
block|,
literal|15
block|,
literal|78
block|,
literal|16
block|,
literal|242
block|,
literal|172
block|,
literal|47
block|,
literal|113
block|,
literal|147
block|,
literal|205
block|,
literal|17
block|,
literal|79
block|,
literal|173
block|,
literal|243
block|,
literal|112
block|,
literal|46
block|,
literal|204
block|,
literal|146
block|,
literal|211
block|,
literal|141
block|,
literal|111
block|,
literal|49
block|,
literal|178
block|,
literal|236
block|,
literal|14
block|,
literal|80
block|,
literal|175
block|,
literal|241
block|,
literal|19
block|,
literal|77
block|,
literal|206
block|,
literal|144
block|,
literal|114
block|,
literal|44
block|,
literal|109
block|,
literal|51
block|,
literal|209
block|,
literal|143
block|,
literal|12
block|,
literal|82
block|,
literal|176
block|,
literal|238
block|,
literal|50
block|,
literal|108
block|,
literal|142
block|,
literal|208
block|,
literal|83
block|,
literal|13
block|,
literal|239
block|,
literal|177
block|,
literal|240
block|,
literal|174
block|,
literal|76
block|,
literal|18
block|,
literal|145
block|,
literal|207
block|,
literal|45
block|,
literal|115
block|,
literal|202
block|,
literal|148
block|,
literal|118
block|,
literal|40
block|,
literal|171
block|,
literal|245
block|,
literal|23
block|,
literal|73
block|,
literal|8
block|,
literal|86
block|,
literal|180
block|,
literal|234
block|,
literal|105
block|,
literal|55
block|,
literal|213
block|,
literal|139
block|,
literal|87
block|,
literal|9
block|,
literal|235
block|,
literal|181
block|,
literal|54
block|,
literal|104
block|,
literal|138
block|,
literal|212
block|,
literal|149
block|,
literal|203
block|,
literal|41
block|,
literal|119
block|,
literal|244
block|,
literal|170
block|,
literal|72
block|,
literal|22
block|,
literal|233
block|,
literal|183
block|,
literal|85
block|,
literal|11
block|,
literal|136
block|,
literal|214
block|,
literal|52
block|,
literal|106
block|,
literal|43
block|,
literal|117
block|,
literal|151
block|,
literal|201
block|,
literal|74
block|,
literal|20
block|,
literal|246
block|,
literal|168
block|,
literal|116
block|,
literal|42
block|,
literal|200
block|,
literal|150
block|,
literal|21
block|,
literal|75
block|,
literal|169
block|,
literal|247
block|,
literal|182
block|,
literal|232
block|,
literal|10
block|,
literal|84
block|,
literal|215
block|,
literal|137
block|,
literal|107
block|,
literal|53
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Converted from DO_CRC page 131 ANN937  */
end_comment

begin_function
specifier|static
name|uint8_t
name|ow_crc
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|,
name|uint8_t
modifier|*
name|buffer
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uint8_t
name|crc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|crc
operator|=
name|ow_crc_table
index|[
name|crc
operator|^
name|buffer
index|[
name|i
index|]
index|]
expr_stmt|;
return|return
name|crc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_check_crc
parameter_list|(
name|romid_t
name|romid
parameter_list|)
block|{
return|return
name|ow_crc
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|romid
argument_list|,
sizeof|sizeof
argument_list|(
name|romid
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_device_found
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|romid_t
name|romid
parameter_list|)
block|{
comment|/* XXX Move this up into enumerate? */
comment|/* 	 * All valid ROM IDs have a valid CRC. Check that first. 	 */
if|if
condition|(
operator|!
name|ow_check_crc
argument_list|(
name|romid
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Device romid %8D failed CRC.\n"
argument_list|,
operator|&
name|romid
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * If we've seen this child before, don't add a new one for it. 	 */
if|if
condition|(
name|ow_child_by_romid
argument_list|(
name|dev
argument_list|,
name|romid
argument_list|)
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|ow_add_child
argument_list|(
name|dev
argument_list|,
name|romid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_enumerate
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|ow_enum_fn
modifier|*
name|enumfp
parameter_list|,
name|ow_found_fn
modifier|*
name|foundfp
parameter_list|)
block|{
name|device_t
name|lldev
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|first
decl_stmt|,
name|second
decl_stmt|,
name|i
decl_stmt|,
name|dir
decl_stmt|,
name|prior
decl_stmt|,
name|last
decl_stmt|,
name|err
decl_stmt|,
name|retries
decl_stmt|;
name|uint64_t
name|probed
decl_stmt|,
name|last_mask
decl_stmt|;
name|int
name|sanity
init|=
literal|10
decl_stmt|;
name|prior
operator|=
operator|-
literal|1
expr_stmt|;
name|last_mask
operator|=
literal|0
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
name|last
operator|=
operator|-
literal|2
expr_stmt|;
name|err
operator|=
name|ow_acquire_bus
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|,
name|OWN_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
while|while
condition|(
name|last
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|sanity
operator|--
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Reached the sanity limit\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|again
label|:
name|probed
operator|=
literal|0
expr_stmt|;
name|last
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * See AN397 section 5.II.C.3 for the algorithm (though a bit 		 * poorly stated). The search command forces each device to 		 * send ROM ID bits one at a time (first the bit, then the 		 * complement) the the master (us) sends back a bit. If the 		 * device's bit doesn't match what we send back, that device 		 * stops sending bits back. So each time through we remember 		 * where we made the last decision (always 0). If there's a 		 * conflict there this time (and there will be in the absence 		 * of a hardware failure) we go with 1. This way, we prune the 		 * devices on the bus and wind up with a unique ROM. We know 		 * we're done when we detect no new conflicts. The same 		 * algorithm is used for devices in alarm state as well. 		 * 		 * In addition, experience has shown that sometimes devices 		 * stop responding in the middle of enumeration, so try this 		 * step again a few times when that happens. It is unclear if 		 * this is due to a nosiy electrical environment or some odd 		 * timing issue. 		 */
comment|/* 		 * The enumeration command should be successfully sent, if not, 		 * we have big issues on the bus so punt. Lower layers report 		 * any unusual errors, so we don't need to here. 		 */
name|err
operator|=
name|enumfp
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|OWLL_READ_DATA
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|,
operator|&
name|first
argument_list|)
expr_stmt|;
name|OWLL_READ_DATA
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|,
operator|&
name|second
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|first
operator||
name|second
operator|<<
literal|1
condition|)
block|{
case|case
literal|0
case|:
comment|/* Conflict */
if|if
condition|(
name|i
operator|<
name|prior
condition|)
name|dir
operator|=
operator|(
name|last_mask
operator|>>
name|i
operator|)
operator|&
literal|1
expr_stmt|;
else|else
name|dir
operator|=
name|i
operator|==
name|prior
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|last
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 1 then 0 -> 1 for all */
name|dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 0 then 1 -> 0 for all */
name|dir
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 				 * No device responded. This is unexpected, but 				 * experience has shown that on some platforms 				 * we miss a timing window, or otherwise have 				 * an issue. Start this step over. Since we've 				 * not updated prior yet, we can just jump to 				 * the top of the loop for a re-do of this step. 				 */
name|printf
argument_list|(
literal|"oops, starting over\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retries
operator|>
literal|5
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|dir
condition|)
block|{
name|OWLL_WRITE_ONE
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|)
expr_stmt|;
name|probed
operator||=
literal|1ull
operator|<<
name|i
expr_stmt|;
block|}
else|else
block|{
name|OWLL_WRITE_ZERO
argument_list|(
name|lldev
argument_list|,
operator|&
name|timing_regular
argument_list|)
expr_stmt|;
block|}
block|}
name|retries
operator|=
literal|0
expr_stmt|;
name|foundfp
argument_list|(
name|dev
argument_list|,
name|probed
argument_list|)
expr_stmt|;
name|last_mask
operator|=
name|probed
expr_stmt|;
name|prior
operator|=
name|last
expr_stmt|;
block|}
name|ow_release_bus
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"1 Wire Bus"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_attach
parameter_list|(
name|device_t
name|ndev
parameter_list|)
block|{
name|struct
name|ow_softc
modifier|*
name|sc
decl_stmt|;
comment|/* 	 * Find all the devices on the bus. We don't probe / attach them in the 	 * enumeration phase. We do this because we want to allow the probe / 	 * attach routines of the child drivers to have as full an access to the 	 * bus as possible. While we reset things before the next step of the 	 * search (so it would likely be OK to allow access by the clients to 	 * the bus), it is more conservative to find them all, then to do the 	 * attach of the devices. This also allows the child devices to have 	 * more knowledge of the bus. We also ignore errors from the enumeration 	 * because they might happen after we've found a few devices. 	 */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|ndev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|"ow"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ow_enumerate
argument_list|(
name|ndev
argument_list|,
name|ow_search_rom
argument_list|,
name|ow_device_found
argument_list|)
expr_stmt|;
return|return
name|bus_generic_attach
argument_list|(
name|ndev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_detach
parameter_list|(
name|device_t
name|ndev
parameter_list|)
block|{
name|device_t
modifier|*
name|children
decl_stmt|,
name|child
decl_stmt|;
name|int
name|nkid
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
name|struct
name|ow_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
comment|/* 	 * detach all the children first. This is blocking until any threads 	 * have stopped, etc. 	 */
name|bus_generic_detach
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
comment|/* 	 * We delete all the children, and free up the ivars  	 */
if|if
condition|(
name|device_get_children
argument_list|(
name|ndev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nkid
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkid
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|children
index|[
name|i
index|]
expr_stmt|;
name|di
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|di
argument_list|,
name|M_OW
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|ndev
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|OW_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Not sure this is really needed. I'm having trouble figuring out what  * location means in the context of the one wire bus.  */
end_comment

begin_function
specifier|static
name|int
name|ow_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_child_pnpinfo_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
name|di
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"romid=%8D"
argument_list|,
operator|&
name|di
operator|->
name|romid
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
name|romid_t
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|di
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|OW_IVAR_FAMILY
case|:
operator|*
name|result
operator|=
name|di
operator|->
name|romid
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
name|OW_IVAR_ROMID
case|:
name|ptr
operator|=
operator|(
name|romid_t
operator|*
operator|*
operator|)
name|result
expr_stmt|;
operator|*
name|ptr
operator|=
operator|&
name|di
operator|->
name|romid
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_write_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_print_child
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
name|di
operator|=
name|device_get_ivars
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|ndev
argument_list|,
name|pdev
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" romid %8D"
argument_list|,
operator|&
name|di
operator|->
name|romid
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|ndev
argument_list|,
name|pdev
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ow_probe_nomatch
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|)
block|{
name|struct
name|ow_devinfo
modifier|*
name|di
decl_stmt|;
name|di
operator|=
name|device_get_ivars
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|ndev
argument_list|,
literal|"romid %8D: no driver\n"
argument_list|,
operator|&
name|di
operator|->
name|romid
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ow_acquire_bus
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|ow_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|OW_ASSERT_UNLOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|OW_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|owner
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|owner
operator|==
name|pdev
condition|)
name|panic
argument_list|(
literal|"%s: %s recursively acquiring the bus.\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|ndev
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|OWN_DONTWAIT
condition|)
block|{
name|OW_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EWOULDBLOCK
return|;
block|}
while|while
condition|(
name|sc
operator|->
name|owner
operator|!=
name|NULL
condition|)
name|mtx_sleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|,
literal|"owbuswait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|owner
operator|=
name|pdev
expr_stmt|;
name|OW_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ow_release_bus
parameter_list|(
name|device_t
name|ndev
parameter_list|,
name|device_t
name|pdev
parameter_list|)
block|{
name|struct
name|ow_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
name|OW_ASSERT_UNLOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|OW_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|owner
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: %s releasing unowned bus."
argument_list|,
name|device_get_nameunit
argument_list|(
name|ndev
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|owner
operator|!=
name|pdev
condition|)
name|panic
argument_list|(
literal|"%s: %s don't own the bus. %s does. game over."
argument_list|,
name|device_get_nameunit
argument_list|(
name|ndev
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|owner
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|OW_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|ow_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ow_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ow_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ow_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ow_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_child_pnpinfo_str
argument_list|,
name|ow_child_pnpinfo_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|ow_child_location_str
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|ow_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|ow_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ow_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_probe_nomatch
argument_list|,
name|ow_probe_nomatch
argument_list|)
block|,
comment|/* One Wire Network/Transport layer interface */
name|DEVMETHOD
argument_list|(
name|own_send_command
argument_list|,
name|ow_send_command
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|own_acquire_bus
argument_list|,
name|ow_acquire_bus
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|own_release_bus
argument_list|,
name|ow_release_bus
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|own_crc
argument_list|,
name|ow_crc
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ow_driver
init|=
block|{
literal|"ow"
block|,
name|ow_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ow_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ow
argument_list|,
name|owc
argument_list|,
name|ow_driver
argument_list|,
name|ow_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ow
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

