begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 M. Warner Losh<imp@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/gpio/gpiobusvar.h>
end_include

begin_include
include|#
directive|include
file|"gpiobus_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/ow/owll.h>
end_include

begin_define
define|#
directive|define
name|OW_PIN
value|0
end_define

begin_define
define|#
directive|define
name|OWC_GPIOBUS_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|OWC_GPIOBUS_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|OWC_GPIOBUS_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|mtx_init(&_sc->sc_mtx, device_get_nameunit(_sc->sc_dev), \ 	    "owc_gpiobus", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|OWC_GPIOBUS_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&_sc->sc_mtx);
end_define

begin_struct
struct|struct
name|owc_gpiobus_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|device_t
name|sc_busdev
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|owc_gpiobus_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|owc_gpiobus_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|owc_gpiobus_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_function
specifier|static
name|void
name|owc_gpiobus_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|bus
parameter_list|)
block|{
name|phandle_t
name|w1
decl_stmt|,
name|root
decl_stmt|;
comment|/* 	 * Find all the 1-wire bus pseudo-nodes that are 	 * at the top level of the FDT. Would be nice to 	 * somehow preserve the node name of these busses, 	 * but there's no good place to put it. The driver's 	 * name is used for the device name, and the 1-wire 	 * bus overwrites the description. 	 */
name|root
operator|=
name|OF_finddevice
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|w1
operator|=
name|OF_child
argument_list|(
name|root
argument_list|)
init|;
name|w1
operator|!=
literal|0
condition|;
name|w1
operator|=
name|OF_peer
argument_list|(
name|w1
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|fdt_is_compatible_strict
argument_list|(
name|w1
argument_list|,
literal|"w1-gpio"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|OF_hasprop
argument_list|(
name|w1
argument_list|,
literal|"gpios"
argument_list|)
condition|)
continue|continue;
name|ofw_gpiobus_add_fdt_child
argument_list|(
name|bus
argument_list|,
name|driver
operator|->
name|name
argument_list|,
name|w1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|owc_gpiobus_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FDT
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"w1-gpio"
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"FDT GPIO attached one-wire bus"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
else|#
directive|else
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"GPIO attached one-wire bus"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|owc_gpiobus_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|owc_gpiobus_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
modifier|*
name|kids
decl_stmt|;
name|int
name|nkid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_busdev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|OWC_GPIOBUS_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nkid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|nkid
argument_list|)
operator|==
literal|0
condition|)
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkid
operator|==
literal|0
condition|)
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ow"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|owc_gpiobus_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|owc_gpiobus_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|OWC_GPIOBUS_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In the diagrams below, R is driven by the resistor pullup, M is driven by the  * master, and S is driven by the slave / target.  */
end_comment

begin_comment
comment|/*  * These macros let what why we're doing stuff shine in the code  * below, and let the how be confined to here.  */
end_comment

begin_define
define|#
directive|define
name|GETBUS
parameter_list|(
name|sc
parameter_list|)
value|GPIOBUS_ACQUIRE_BUS((sc)->sc_busdev,	\ 			    (sc)->sc_dev, GPIOBUS_WAIT)
end_define

begin_define
define|#
directive|define
name|RELBUS
parameter_list|(
name|sc
parameter_list|)
value|GPIOBUS_RELEASE_BUS((sc)->sc_busdev,	\ 			    (sc)->sc_dev)
end_define

begin_define
define|#
directive|define
name|OUTPIN
parameter_list|(
name|sc
parameter_list|)
value|GPIOBUS_PIN_SETFLAGS((sc)->sc_busdev, \ 			    (sc)->sc_dev, OW_PIN, GPIO_PIN_OUTPUT)
end_define

begin_define
define|#
directive|define
name|INPIN
parameter_list|(
name|sc
parameter_list|)
value|GPIOBUS_PIN_SETFLAGS((sc)->sc_busdev, \ 			    (sc)->sc_dev, OW_PIN, GPIO_PIN_INPUT)
end_define

begin_define
define|#
directive|define
name|GETPIN
parameter_list|(
name|sc
parameter_list|,
name|bit
parameter_list|)
value|GPIOBUS_PIN_GET((sc)->sc_busdev, \ 			    (sc)->sc_dev, OW_PIN, bit)
end_define

begin_define
define|#
directive|define
name|LOW
parameter_list|(
name|sc
parameter_list|)
value|GPIOBUS_PIN_SET((sc)->sc_busdev, \ 			    (sc)->sc_dev, OW_PIN, GPIO_PIN_LOW)
end_define

begin_comment
comment|/*  * WRITE-ONE (see owll_if.m for timings) From Figure 4-1 AN-937  *  *		       |<---------tSLOT---->|<-tREC->|  *	High	RRRRM  | 	RRRRRRRRRRRR|RRRRRRRRM  *		     M |       R |     |  |	      M  *		      M|      R	 |     |  |	       M  *	Low	       MMMMMMM	 |     |  |    	        MMMMMM...  *		       |<-tLOW1->|     |  |  *		       |<------15us--->|  |  *                     |<--------60us---->|  */
end_comment

begin_function
specifier|static
name|int
name|owc_gpiobus_write_one
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ow_timing
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|owc_gpiobus_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|GETBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* Force low */
name|OUTPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LOW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_low1
argument_list|)
expr_stmt|;
comment|/* Allow resistor to float line high */
name|INPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_slot
operator|-
name|t
operator|->
name|t_low1
operator|+
name|t
operator|->
name|t_rec
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|RELBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * WRITE-ZERO (see owll_if.m for timings) From Figure 4-2 AN-937  *  *		       |<---------tSLOT------>|<-tREC->|  *	High	RRRRM  | 	            | |RRRRRRRM  *		     M |                    | R	       M  *		      M|       	 |     |    |R 	        M  *	Low	       MMMMMMMMMMMMMMMMMMMMMR  	         MMMMMM...  *     	       	       |<--15us->|     |    |  *     	       	       |<------60us--->|    |  *                     |<-------tLOW0------>|  */
end_comment

begin_function
specifier|static
name|int
name|owc_gpiobus_write_zero
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ow_timing
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|owc_gpiobus_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|GETBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* Force low */
name|OUTPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LOW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_low0
argument_list|)
expr_stmt|;
comment|/* Allow resistor to float line high */
name|INPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_slot
operator|-
name|t
operator|->
name|t_low0
operator|+
name|t
operator|->
name|t_rec
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|RELBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * READ-DATA (see owll_if.m for timings) From Figure 4-3 AN-937  *  *		       |<---------tSLOT------>|<-tREC->|  *	High	RRRRM  |        rrrrrrrrrrrrrrrRRRRRRRM  *		     M |       r            | R	       M  *		      M|      r	        |   |R 	        M  *	Low	       MMMMMMMSSSSSSSSSSSSSSR  	         MMMMMM...  *     	       	       |<tLOWR>< sample>   |  *     	       	       |<------tRDV---->|   |  *                                    ->|   |<-tRELEASE  *  * r -- allowed to pull high via the resitor when slave writes a 1-bit  *  */
end_comment

begin_function
specifier|static
name|int
name|owc_gpiobus_read_data
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ow_timing
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|bit
parameter_list|)
block|{
name|struct
name|owc_gpiobus_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sample
decl_stmt|;
name|sbintime_t
name|then
decl_stmt|,
name|now
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|GETBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Force low for t_lowr microseconds */
name|then
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|OUTPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LOW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_lowr
argument_list|)
expr_stmt|;
comment|/* 	 * Slave is supposed to hold the line low for t_rdv microseconds for 0 	 * and immediately float it high for a 1. This is measured from the 	 * master's pushing the line low. 	 */
name|INPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
do|do
block|{
name|now
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
name|GETPIN
argument_list|(
name|sc
argument_list|,
operator|&
name|sample
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|now
operator|-
name|then
operator|)
operator|/
name|SBT_1US
operator|<
name|t
operator|->
name|t_rdv
operator|+
literal|2
operator|&&
name|sample
operator|==
literal|0
condition|)
do|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|now
operator|-
name|then
operator|)
operator|/
name|SBT_1NS
operator|<
name|t
operator|->
name|t_rdv
operator|*
literal|1000
condition|)
operator|*
name|bit
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|bit
operator|=
literal|0
expr_stmt|;
comment|/* Wait out the rest of t_slot */
do|do
block|{
name|now
operator|=
name|sbinuptime
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|now
operator|-
name|then
operator|)
operator|/
name|SBT_1US
operator|<
name|t
operator|->
name|t_slot
condition|)
do|;
name|RELBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * RESET AND PRESENCE PULSE (see owll_if.m for timings) From Figure 4-4 AN-937  *  *				    |<---------tRSTH------------>|  *	High RRRM  |		  | RRRRRRRS	       |  RRRR RRM  *		 M |		  |R|  	   |S  	       | R	  M  *		  M|		  R |	   | S	       |R	   M  *	Low	   MMMMMMMM MMMMMM| |	   |  SSSSSSSSSS	    MMMMMM  *     	       	   |<----tRSTL--->| |  	   |<-tPDL---->|  *		   |   	       	->| |<-tR  |	       |  *				    |<tPDH>|  *  * Note: for Regular Speed operations, tRSTL + tR should be less than 960us to  * avoid interferring with other devices on the bus  */
end_comment

begin_function
specifier|static
name|int
name|owc_gpiobus_reset_and_presence
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ow_timing
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|bit
parameter_list|)
block|{
name|struct
name|owc_gpiobus_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|buf
init|=
operator|-
literal|1
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|error
operator|=
name|GETBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/*  	 * Read the current state of the bus. The steady state of an idle bus is 	 * high. Badly wired buses that are missing the required pull up, or 	 * that have a short circuit to ground cause all kinds of mischief when 	 * we try to read them later. Return EIO and release the bus if the bus 	 * is currently low. 	 */
name|INPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GETPIN
argument_list|(
name|sc
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
operator|*
name|bit
operator|=
operator|-
literal|1
expr_stmt|;
name|RELBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* Force low */
name|OUTPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LOW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_rstl
argument_list|)
expr_stmt|;
comment|/* Allow resistor to float line high and then wait for reset pulse */
name|INPIN
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_pdh
operator|+
name|t
operator|->
name|t_pdl
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Read presence pulse  */
name|GETPIN
argument_list|(
name|sc
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
operator|*
name|bit
operator|=
operator|!
operator|!
name|buf
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
name|t
operator|->
name|t_rsth
operator|-
operator|(
name|t
operator|->
name|t_pdh
operator|+
name|t
operator|->
name|t_pdl
operator|/
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* Timing not critical for this one */
comment|/* 	 * Read the state of the bus after we've waited past the end of the rest 	 * window. It should return to high. If it is low, then we have some 	 * problem and should abort the reset. 	 */
name|GETPIN
argument_list|(
name|sc
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
operator|*
name|bit
operator|=
operator|-
literal|1
expr_stmt|;
name|RELBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|RELBUS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|devclass_t
name|owc_gpiobus_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|owc_gpiobus_methods
index|[]
init|=
block|{
comment|/* Device interface */
ifdef|#
directive|ifdef
name|FDT
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|owc_gpiobus_identify
argument_list|)
block|,
endif|#
directive|endif
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|owc_gpiobus_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|owc_gpiobus_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|owc_gpiobus_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|owll_write_one
argument_list|,
name|owc_gpiobus_write_one
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|owll_write_zero
argument_list|,
name|owc_gpiobus_write_zero
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|owll_read_data
argument_list|,
name|owc_gpiobus_read_data
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|owll_reset_and_presence
argument_list|,
name|owc_gpiobus_reset_and_presence
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|owc_gpiobus_driver
init|=
block|{
literal|"owc"
block|,
name|owc_gpiobus_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|owc_gpiobus_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|owc_gpiobus_fdt
argument_list|,
name|gpiobus
argument_list|,
name|owc_gpiobus_driver
argument_list|,
name|owc_gpiobus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|owc_gpiobus_fdt
argument_list|,
name|ow
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

