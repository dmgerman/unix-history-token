begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2015, Mellanox Technologies, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"icl_iser.h"
end_include

begin_function
specifier|static
name|struct
name|fast_reg_descriptor
modifier|*
name|iser_reg_desc_get
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|)
block|{
name|struct
name|fast_reg_descriptor
modifier|*
name|desc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ib_conn
operator|->
name|lock
argument_list|)
expr_stmt|;
name|desc
operator|=
name|list_first_entry
argument_list|(
operator|&
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool
argument_list|,
expr|struct
name|fast_reg_descriptor
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|desc
operator|->
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ib_conn
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iser_reg_desc_put
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|,
name|struct
name|fast_reg_descriptor
modifier|*
name|desc
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ib_conn
operator|->
name|lock
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|desc
operator|->
name|list
argument_list|,
operator|&
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ib_conn
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_4K_ALIGNED
parameter_list|(
name|addr
parameter_list|)
value|((((unsigned long)addr)& ~MASK_4K) == 0)
end_define

begin_comment
comment|/**  * iser_data_buf_aligned_len - Tries to determine the maximal correctly aligned  * for RDMA sub-list of a scatter-gather list of memory buffers, and  returns  * the number of entries which are aligned correctly. Supports the case where  * consecutive SG elements are actually fragments of the same physcial page.  */
end_comment

begin_function
specifier|static
name|int
name|iser_data_buf_aligned_len
parameter_list|(
name|struct
name|iser_data_buf
modifier|*
name|data
parameter_list|,
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|)
block|{
name|struct
name|scatterlist
modifier|*
name|sg
decl_stmt|,
modifier|*
name|sgl
decl_stmt|,
modifier|*
name|next_sg
init|=
name|NULL
decl_stmt|;
name|u64
name|start_addr
decl_stmt|,
name|end_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret_len
decl_stmt|,
name|start_check
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|dma_nents
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sgl
operator|=
name|data
operator|->
name|sgl
expr_stmt|;
name|start_addr
operator|=
name|ib_sg_dma_address
argument_list|(
name|ibdev
argument_list|,
name|sgl
argument_list|)
expr_stmt|;
name|for_each_sg
argument_list|(
argument|sgl
argument_list|,
argument|sg
argument_list|,
argument|data->dma_nents
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|start_check
operator|&&
operator|!
name|IS_4K_ALIGNED
argument_list|(
name|start_addr
argument_list|)
condition|)
break|break;
name|next_sg
operator|=
name|sg_next
argument_list|(
name|sg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_sg
condition|)
break|break;
name|end_addr
operator|=
name|start_addr
operator|+
name|ib_sg_dma_len
argument_list|(
name|ibdev
argument_list|,
name|sg
argument_list|)
expr_stmt|;
name|start_addr
operator|=
name|ib_sg_dma_address
argument_list|(
name|ibdev
argument_list|,
name|next_sg
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_addr
operator|==
name|start_addr
condition|)
block|{
name|start_check
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
else|else
name|start_check
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|IS_4K_ALIGNED
argument_list|(
name|end_addr
argument_list|)
condition|)
break|break;
block|}
name|ret_len
operator|=
operator|(
name|next_sg
operator|)
condition|?
name|i
else|:
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|ret_len
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iser_dma_unmap_task_data
parameter_list|(
name|struct
name|icl_iser_pdu
modifier|*
name|iser_pdu
parameter_list|,
name|struct
name|iser_data_buf
modifier|*
name|data
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|iser_pdu
operator|->
name|iser_conn
operator|->
name|ib_conn
operator|.
name|device
operator|->
name|ib_device
expr_stmt|;
name|ib_dma_unmap_sg
argument_list|(
name|dev
argument_list|,
name|data
operator|->
name|sgl
argument_list|,
name|data
operator|->
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iser_reg_dma
parameter_list|(
name|struct
name|iser_device
modifier|*
name|device
parameter_list|,
name|struct
name|iser_data_buf
modifier|*
name|mem
parameter_list|,
name|struct
name|iser_mem_reg
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|scatterlist
modifier|*
name|sg
init|=
name|mem
operator|->
name|sgl
decl_stmt|;
name|reg
operator|->
name|sge
operator|.
name|lkey
operator|=
name|device
operator|->
name|mr
operator|->
name|lkey
expr_stmt|;
name|reg
operator|->
name|rkey
operator|=
name|device
operator|->
name|mr
operator|->
name|rkey
expr_stmt|;
name|reg
operator|->
name|sge
operator|.
name|length
operator|=
name|ib_sg_dma_len
argument_list|(
name|device
operator|->
name|ib_device
argument_list|,
operator|&
name|sg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|reg
operator|->
name|sge
operator|.
name|addr
operator|=
name|ib_sg_dma_address
argument_list|(
name|device
operator|->
name|ib_device
argument_list|,
operator|&
name|sg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * TODO: This should be a verb  * iser_ib_inc_rkey - increments the key portion of the given rkey. Can be used  * for calculating a new rkey for type 2 memory windows.  * @rkey - the rkey to increment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u32
name|iser_ib_inc_rkey
parameter_list|(
name|u32
name|rkey
parameter_list|)
block|{
specifier|const
name|u32
name|mask
init|=
literal|0x000000ff
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|rkey
operator|+
literal|1
operator|)
operator|&
name|mask
operator|)
operator||
operator|(
name|rkey
operator|&
operator|~
name|mask
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iser_inv_rkey
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|inv_wr
parameter_list|,
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
block|{
name|u32
name|rkey
decl_stmt|;
name|memset
argument_list|(
name|inv_wr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inv_wr
argument_list|)
argument_list|)
expr_stmt|;
name|inv_wr
operator|->
name|opcode
operator|=
name|IB_WR_LOCAL_INV
expr_stmt|;
name|inv_wr
operator|->
name|wr_id
operator|=
name|ISER_FASTREG_LI_WRID
expr_stmt|;
name|inv_wr
operator|->
name|ex
operator|.
name|invalidate_rkey
operator|=
name|mr
operator|->
name|rkey
expr_stmt|;
name|rkey
operator|=
name|iser_ib_inc_rkey
argument_list|(
name|mr
operator|->
name|rkey
argument_list|)
expr_stmt|;
name|ib_update_fast_reg_key
argument_list|(
name|mr
argument_list|,
name|rkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iser_fast_reg_mr
parameter_list|(
name|struct
name|icl_iser_pdu
modifier|*
name|iser_pdu
parameter_list|,
name|struct
name|iser_data_buf
modifier|*
name|mem
parameter_list|,
name|struct
name|iser_reg_resources
modifier|*
name|rsc
parameter_list|,
name|struct
name|iser_mem_reg
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_pdu
operator|->
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|struct
name|iser_device
modifier|*
name|device
init|=
name|ib_conn
operator|->
name|device
decl_stmt|;
name|struct
name|ib_mr
modifier|*
name|mr
init|=
name|rsc
operator|->
name|mr
decl_stmt|;
name|struct
name|ib_reg_wr
name|fastreg_wr
decl_stmt|;
name|struct
name|ib_send_wr
name|inv_wr
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad_wr
decl_stmt|,
modifier|*
name|wr
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|n
decl_stmt|;
comment|/* if there a single dma entry, dma mr suffices */
if|if
condition|(
name|mem
operator|->
name|dma_nents
operator|==
literal|1
condition|)
return|return
name|iser_reg_dma
argument_list|(
name|device
argument_list|,
name|mem
argument_list|,
name|reg
argument_list|)
return|;
if|if
condition|(
operator|!
name|rsc
operator|->
name|mr_valid
condition|)
block|{
name|iser_inv_rkey
argument_list|(
operator|&
name|inv_wr
argument_list|,
name|mr
argument_list|)
expr_stmt|;
name|wr
operator|=
operator|&
name|inv_wr
expr_stmt|;
block|}
name|n
operator|=
name|ib_map_mr_sg
argument_list|(
name|mr
argument_list|,
name|mem
operator|->
name|sg
argument_list|,
name|mem
operator|->
name|size
argument_list|,
name|NULL
argument_list|,
name|SIZE_4K
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|n
operator|!=
name|mem
operator|->
name|size
argument_list|)
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"failed to map sg (%d/%d)\n"
argument_list|,
name|n
argument_list|,
name|mem
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|n
operator|<
literal|0
condition|?
name|n
else|:
operator|-
name|EINVAL
return|;
block|}
comment|/* Prepare FASTREG WR */
name|memset
argument_list|(
operator|&
name|fastreg_wr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fastreg_wr
argument_list|)
argument_list|)
expr_stmt|;
name|fastreg_wr
operator|.
name|wr
operator|.
name|opcode
operator|=
name|IB_WR_REG_MR
expr_stmt|;
name|fastreg_wr
operator|.
name|wr
operator|.
name|wr_id
operator|=
name|ISER_FASTREG_LI_WRID
expr_stmt|;
name|fastreg_wr
operator|.
name|wr
operator|.
name|num_sge
operator|=
literal|0
expr_stmt|;
name|fastreg_wr
operator|.
name|mr
operator|=
name|mr
expr_stmt|;
name|fastreg_wr
operator|.
name|key
operator|=
name|mr
operator|->
name|rkey
expr_stmt|;
name|fastreg_wr
operator|.
name|access
operator|=
name|IB_ACCESS_LOCAL_WRITE
operator||
name|IB_ACCESS_REMOTE_WRITE
operator||
name|IB_ACCESS_REMOTE_READ
expr_stmt|;
if|if
condition|(
operator|!
name|wr
condition|)
name|wr
operator|=
operator|&
name|fastreg_wr
operator|.
name|wr
expr_stmt|;
else|else
name|wr
operator|->
name|next
operator|=
operator|&
name|fastreg_wr
operator|.
name|wr
expr_stmt|;
name|ret
operator|=
name|ib_post_send
argument_list|(
name|ib_conn
operator|->
name|qp
argument_list|,
name|wr
argument_list|,
operator|&
name|bad_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"fast registration failed, ret:%d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|rsc
operator|->
name|mr_valid
operator|=
literal|0
expr_stmt|;
name|reg
operator|->
name|sge
operator|.
name|lkey
operator|=
name|mr
operator|->
name|lkey
expr_stmt|;
name|reg
operator|->
name|rkey
operator|=
name|mr
operator|->
name|rkey
expr_stmt|;
name|reg
operator|->
name|sge
operator|.
name|addr
operator|=
name|mr
operator|->
name|iova
expr_stmt|;
name|reg
operator|->
name|sge
operator|.
name|length
operator|=
name|mr
operator|->
name|length
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * iser_reg_rdma_mem - Registers memory intended for RDMA,  * using Fast Registration WR (if possible) obtaining rkey and va  *  * returns 0 on success, errno code on failure  */
end_comment

begin_function
name|int
name|iser_reg_rdma_mem
parameter_list|(
name|struct
name|icl_iser_pdu
modifier|*
name|iser_pdu
parameter_list|,
name|enum
name|iser_data_dir
name|cmd_dir
parameter_list|)
block|{
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_pdu
operator|->
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|struct
name|iser_device
modifier|*
name|device
init|=
name|ib_conn
operator|->
name|device
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|ibdev
init|=
name|device
operator|->
name|ib_device
decl_stmt|;
name|struct
name|iser_data_buf
modifier|*
name|mem
init|=
operator|&
name|iser_pdu
operator|->
name|data
index|[
name|cmd_dir
index|]
decl_stmt|;
name|struct
name|iser_mem_reg
modifier|*
name|mem_reg
init|=
operator|&
name|iser_pdu
operator|->
name|rdma_reg
index|[
name|cmd_dir
index|]
decl_stmt|;
name|struct
name|fast_reg_descriptor
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|,
name|aligned_len
decl_stmt|;
name|aligned_len
operator|=
name|iser_data_buf_aligned_len
argument_list|(
name|mem
argument_list|,
name|ibdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|aligned_len
operator|!=
name|mem
operator|->
name|dma_nents
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"bounce buffer is not supported"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|dma_nents
operator|!=
literal|1
condition|)
block|{
name|desc
operator|=
name|iser_reg_desc_get
argument_list|(
name|ib_conn
argument_list|)
expr_stmt|;
name|mem_reg
operator|->
name|mem_h
operator|=
name|desc
expr_stmt|;
block|}
name|err
operator|=
name|iser_fast_reg_mr
argument_list|(
name|iser_pdu
argument_list|,
name|mem
argument_list|,
name|desc
condition|?
operator|&
name|desc
operator|->
name|rsc
else|:
name|NULL
argument_list|,
name|mem_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_reg
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|err_reg
label|:
if|if
condition|(
name|desc
condition|)
name|iser_reg_desc_put
argument_list|(
name|ib_conn
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iser_unreg_rdma_mem
parameter_list|(
name|struct
name|icl_iser_pdu
modifier|*
name|iser_pdu
parameter_list|,
name|enum
name|iser_data_dir
name|cmd_dir
parameter_list|)
block|{
name|struct
name|iser_mem_reg
modifier|*
name|reg
init|=
operator|&
name|iser_pdu
operator|->
name|rdma_reg
index|[
name|cmd_dir
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|reg
operator|->
name|mem_h
condition|)
return|return;
name|iser_reg_desc_put
argument_list|(
operator|&
name|iser_pdu
operator|->
name|iser_conn
operator|->
name|ib_conn
argument_list|,
name|reg
operator|->
name|mem_h
argument_list|)
expr_stmt|;
name|reg
operator|->
name|mem_h
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iser_dma_map_task_data
parameter_list|(
name|struct
name|icl_iser_pdu
modifier|*
name|iser_pdu
parameter_list|,
name|struct
name|iser_data_buf
modifier|*
name|data
parameter_list|,
name|enum
name|iser_data_dir
name|iser_dir
parameter_list|,
name|enum
name|dma_data_direction
name|dma_dir
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|dev
decl_stmt|;
name|iser_pdu
operator|->
name|dir
index|[
name|iser_dir
index|]
operator|=
literal|1
expr_stmt|;
name|dev
operator|=
name|iser_pdu
operator|->
name|iser_conn
operator|->
name|ib_conn
operator|.
name|device
operator|->
name|ib_device
expr_stmt|;
name|data
operator|->
name|dma_nents
operator|=
name|ib_dma_map_sg
argument_list|(
name|dev
argument_list|,
name|data
operator|->
name|sgl
argument_list|,
name|data
operator|->
name|size
argument_list|,
name|dma_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|dma_nents
operator|==
literal|0
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"dma_map_sg failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

