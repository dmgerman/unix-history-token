begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2015, Mellanox Technologies, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"icl_iser.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ISER_VERBS
argument_list|,
literal|"iser_verbs"
argument_list|,
literal|"iser verbs backend"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iser_cq_poll_limit
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|iser_cq_event_callback
parameter_list|(
name|struct
name|ib_event
modifier|*
name|cause
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ISER_ERR
argument_list|(
literal|"got cq event %d"
argument_list|,
name|cause
operator|->
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iser_qp_event_callback
parameter_list|(
name|struct
name|ib_event
modifier|*
name|cause
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ISER_ERR
argument_list|(
literal|"got qp event %d"
argument_list|,
name|cause
operator|->
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iser_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|handler
parameter_list|,
name|struct
name|ib_event
modifier|*
name|event
parameter_list|)
block|{
name|ISER_ERR
argument_list|(
literal|"async event %d on device %s port %d"
argument_list|,
name|event
operator|->
name|event
argument_list|,
name|event
operator|->
name|device
operator|->
name|name
argument_list|,
name|event
operator|->
name|element
operator|.
name|port_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * is_iser_tx_desc - Indicate if the completion wr_id  *     is a TX descriptor or not.  * @iser_conn: iser connection  * @wr_id: completion WR identifier  *  * Since we cannot rely on wc opcode in FLUSH errors  * we must work around it by checking if the wr_id address  * falls in the iser connection rx_descs buffer. If so  * it is an RX descriptor, otherwize it is a TX.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_iser_tx_desc
parameter_list|(
name|struct
name|iser_conn
modifier|*
name|iser_conn
parameter_list|,
name|void
modifier|*
name|wr_id
parameter_list|)
block|{
name|void
modifier|*
name|start
init|=
name|iser_conn
operator|->
name|rx_descs
decl_stmt|;
name|u64
name|len
init|=
name|iser_conn
operator|->
name|num_rx_descs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iser_conn
operator|->
name|rx_descs
argument_list|)
decl_stmt|;
name|void
modifier|*
name|end
init|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|start
operator|+
operator|(
name|uintptr_t
operator|)
name|len
operator|)
decl_stmt|;
if|if
condition|(
name|start
condition|)
block|{
if|if
condition|(
name|wr_id
operator|>=
name|start
operator|&&
name|wr_id
operator|<
name|end
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|wr_id
operator|!=
operator|(
name|uintptr_t
operator|)
name|iser_conn
operator|->
name|login_resp_buf
operator|)
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/**  * iser_handle_comp_error() - Handle error completion  * @ib_conn:   connection RDMA resources  * @wc:        work completion  *  * Notes: Update post_recv_buf_count in case of recv error completion.  *        For non-FLUSH error completion we should also notify iscsi layer that  *        connection is failed (in case we passed bind stage).  */
end_comment

begin_function
specifier|static
name|void
name|iser_handle_comp_error
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|void
modifier|*
name|wr_id
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|wc
operator|->
name|wr_id
decl_stmt|;
name|struct
name|iser_conn
modifier|*
name|iser_conn
init|=
name|container_of
argument_list|(
name|ib_conn
argument_list|,
expr|struct
name|iser_conn
argument_list|,
name|ib_conn
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_iser_tx_desc
argument_list|(
name|iser_conn
argument_list|,
name|wr_id
argument_list|)
condition|)
block|{
name|ISER_DBG
argument_list|(
literal|"conn %p got send comp error"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISER_DBG
argument_list|(
literal|"conn %p got recv comp error"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|post_recv_buf_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|wc
operator|->
name|status
operator|!=
name|IB_WC_WR_FLUSH_ERR
condition|)
name|iser_conn
operator|->
name|icl_conn
operator|.
name|ic_error
argument_list|(
operator|&
name|iser_conn
operator|->
name|icl_conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * iser_handle_wc - handle a single work completion  * @wc: work completion  *  * Soft-IRQ context, work completion can be either  * SEND or RECV, and can turn out successful or  * with error (or flush error).  */
end_comment

begin_function
specifier|static
name|void
name|iser_handle_wc
parameter_list|(
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|ib_conn
modifier|*
name|ib_conn
decl_stmt|;
name|struct
name|iser_tx_desc
modifier|*
name|tx_desc
decl_stmt|;
name|struct
name|iser_rx_desc
modifier|*
name|rx_desc
decl_stmt|;
name|ib_conn
operator|=
name|wc
operator|->
name|qp
operator|->
name|qp_context
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|wc
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
argument_list|)
condition|)
block|{
if|if
condition|(
name|wc
operator|->
name|opcode
operator|==
name|IB_WC_RECV
condition|)
block|{
name|rx_desc
operator|=
operator|(
expr|struct
name|iser_rx_desc
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|wc
operator|->
name|wr_id
expr_stmt|;
name|iser_rcv_completion
argument_list|(
name|rx_desc
argument_list|,
name|wc
operator|->
name|byte_len
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|->
name|opcode
operator|==
name|IB_WC_SEND
condition|)
block|{
name|tx_desc
operator|=
operator|(
expr|struct
name|iser_tx_desc
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|wc
operator|->
name|wr_id
expr_stmt|;
name|iser_snd_completion
argument_list|(
name|tx_desc
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISER_ERR
argument_list|(
literal|"Unknown wc opcode %d"
argument_list|,
name|wc
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|iser_conn
modifier|*
name|iser_conn
init|=
name|container_of
argument_list|(
name|ib_conn
argument_list|,
expr|struct
name|iser_conn
argument_list|,
name|ib_conn
argument_list|)
decl_stmt|;
if|if
condition|(
name|wc
operator|->
name|status
operator|!=
name|IB_WC_WR_FLUSH_ERR
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"conn %p wr id %llx status %d vend_err %x"
argument_list|,
name|iser_conn
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|wc
operator|->
name|wr_id
argument_list|,
name|wc
operator|->
name|status
argument_list|,
name|wc
operator|->
name|vendor_err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ISER_DBG
argument_list|(
literal|"flush error: conn %p wr id %llx"
argument_list|,
name|iser_conn
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|wc
operator|->
name|wr_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wc
operator|->
name|wr_id
operator|==
name|ISER_BEACON_WRID
condition|)
block|{
comment|/* all flush errors were consumed */
name|mtx_lock
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
name|ISER_DBG
argument_list|(
literal|"conn %p got ISER_BEACON_WRID"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iser_handle_comp_error
argument_list|(
name|ib_conn
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iser_cq_tasklet_fn
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|iser_comp
modifier|*
name|comp
init|=
operator|(
expr|struct
name|iser_comp
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
init|=
name|comp
operator|->
name|cq
decl_stmt|;
name|struct
name|ib_wc
modifier|*
specifier|const
name|wcs
init|=
name|comp
operator|->
name|wcs
decl_stmt|;
name|int
name|completed
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|ib_poll_cq
argument_list|(
name|cq
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|comp
operator|->
name|wcs
argument_list|)
argument_list|,
name|wcs
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|iser_handle_wc
argument_list|(
operator|&
name|wcs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|completed
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|completed
operator|>=
name|iser_cq_poll_limit
condition|)
break|break;
block|}
comment|/* 	 * It is assumed here that arming CQ only once its empty 	 * would not cause interrupts to be missed. 	 */
name|ib_req_notify_cq
argument_list|(
name|cq
argument_list|,
name|IB_CQ_NEXT_COMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iser_cq_callback
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|void
modifier|*
name|cq_context
parameter_list|)
block|{
name|struct
name|iser_comp
modifier|*
name|comp
init|=
name|cq_context
decl_stmt|;
name|taskqueue_enqueue
argument_list|(
name|comp
operator|->
name|tq
argument_list|,
operator|&
name|comp
operator|->
name|task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * iser_create_device_ib_res - creates Protection Domain (PD), Completion  * Queue (CQ), DMA Memory Region (DMA MR) with the device associated with  * the adapator.  *  * returns 0 on success, -1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|iser_create_device_ib_res
parameter_list|(
name|struct
name|iser_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|ib_dev
init|=
name|device
operator|->
name|ib_device
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_cqe
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ib_dev
operator|->
name|attrs
operator|.
name|device_cap_flags
operator|&
name|IB_DEVICE_MEM_MGT_EXTENSIONS
operator|)
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"device %s doesn't support Fastreg, "
literal|"can't register memory"
argument_list|,
name|device
operator|->
name|ib_device
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|device
operator|->
name|comps_used
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
name|device
operator|->
name|ib_device
operator|->
name|num_comp_vectors
argument_list|)
expr_stmt|;
name|device
operator|->
name|comps
operator|=
name|malloc
argument_list|(
name|device
operator|->
name|comps_used
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|device
operator|->
name|comps
argument_list|)
argument_list|,
name|M_ISER_VERBS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|comps
condition|)
goto|goto
name|comps_err
goto|;
name|max_cqe
operator|=
name|min
argument_list|(
name|ISER_MAX_CQ_LEN
argument_list|,
name|ib_dev
operator|->
name|attrs
operator|.
name|max_cqe
argument_list|)
expr_stmt|;
name|ISER_DBG
argument_list|(
literal|"using %d CQs, device %s supports %d vectors max_cqe %d"
argument_list|,
name|device
operator|->
name|comps_used
argument_list|,
name|device
operator|->
name|ib_device
operator|->
name|name
argument_list|,
name|device
operator|->
name|ib_device
operator|->
name|num_comp_vectors
argument_list|,
name|max_cqe
argument_list|)
expr_stmt|;
name|device
operator|->
name|pd
operator|=
name|ib_alloc_pd
argument_list|(
name|device
operator|->
name|ib_device
argument_list|,
name|IB_PD_UNSAFE_GLOBAL_RKEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|device
operator|->
name|pd
argument_list|)
condition|)
goto|goto
name|pd_err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|comps_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iser_comp
modifier|*
name|comp
init|=
operator|&
name|device
operator|->
name|comps
index|[
name|i
index|]
decl_stmt|;
name|struct
name|ib_cq_init_attr
name|cq_attr
init|=
block|{
operator|.
name|cqe
operator|=
name|max_cqe
block|,
operator|.
name|comp_vector
operator|=
name|i
block|, 		}
decl_stmt|;
name|comp
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|comp
operator|->
name|cq
operator|=
name|ib_create_cq
argument_list|(
name|device
operator|->
name|ib_device
argument_list|,
name|iser_cq_callback
argument_list|,
name|iser_cq_event_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|comp
argument_list|,
operator|&
name|cq_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|comp
operator|->
name|cq
argument_list|)
condition|)
block|{
name|comp
operator|->
name|cq
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cq_err
goto|;
block|}
if|if
condition|(
name|ib_req_notify_cq
argument_list|(
name|comp
operator|->
name|cq
argument_list|,
name|IB_CQ_NEXT_COMP
argument_list|)
condition|)
goto|goto
name|cq_err
goto|;
name|TASK_INIT
argument_list|(
operator|&
name|comp
operator|->
name|task
argument_list|,
literal|0
argument_list|,
name|iser_cq_tasklet_fn
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|comp
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"iser_taskq"
argument_list|,
name|M_NOWAIT
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|comp
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comp
operator|->
name|tq
condition|)
goto|goto
name|tq_err
goto|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|comp
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"iser taskq"
argument_list|)
expr_stmt|;
block|}
name|device
operator|->
name|mr
operator|=
name|device
operator|->
name|pd
operator|->
name|__internal_mr
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|device
operator|->
name|mr
argument_list|)
condition|)
goto|goto
name|tq_err
goto|;
name|INIT_IB_EVENT_HANDLER
argument_list|(
operator|&
name|device
operator|->
name|event_handler
argument_list|,
name|device
operator|->
name|ib_device
argument_list|,
name|iser_event_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_register_event_handler
argument_list|(
operator|&
name|device
operator|->
name|event_handler
argument_list|)
condition|)
goto|goto
name|tq_err
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|tq_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|comps_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iser_comp
modifier|*
name|comp
init|=
operator|&
name|device
operator|->
name|comps
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|comp
operator|->
name|tq
condition|)
name|taskqueue_free
argument_list|(
name|comp
operator|->
name|tq
argument_list|)
expr_stmt|;
block|}
name|cq_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|comps_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iser_comp
modifier|*
name|comp
init|=
operator|&
name|device
operator|->
name|comps
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|comp
operator|->
name|cq
condition|)
name|ib_destroy_cq
argument_list|(
name|comp
operator|->
name|cq
argument_list|)
expr_stmt|;
block|}
name|ib_dealloc_pd
argument_list|(
name|device
operator|->
name|pd
argument_list|)
expr_stmt|;
name|pd_err
label|:
name|free
argument_list|(
name|device
operator|->
name|comps
argument_list|,
name|M_ISER_VERBS
argument_list|)
expr_stmt|;
name|comps_err
label|:
name|ISER_ERR
argument_list|(
literal|"failed to allocate an IB resource"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * iser_free_device_ib_res - destroy/dealloc/dereg the DMA MR,  * CQ and PD created with the device associated with the adapator.  */
end_comment

begin_function
specifier|static
name|void
name|iser_free_device_ib_res
parameter_list|(
name|struct
name|iser_device
modifier|*
name|device
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|comps_used
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|iser_comp
modifier|*
name|comp
init|=
operator|&
name|device
operator|->
name|comps
index|[
name|i
index|]
decl_stmt|;
name|taskqueue_free
argument_list|(
name|comp
operator|->
name|tq
argument_list|)
expr_stmt|;
name|ib_destroy_cq
argument_list|(
name|comp
operator|->
name|cq
argument_list|)
expr_stmt|;
name|comp
operator|->
name|cq
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ib_unregister_event_handler
argument_list|(
operator|&
name|device
operator|->
name|event_handler
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ib_dealloc_pd
argument_list|(
name|device
operator|->
name|pd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
operator|->
name|comps
argument_list|,
name|M_ISER_VERBS
argument_list|)
expr_stmt|;
name|device
operator|->
name|comps
operator|=
name|NULL
expr_stmt|;
name|device
operator|->
name|mr
operator|=
name|NULL
expr_stmt|;
name|device
operator|->
name|pd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iser_alloc_reg_res
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ib_device
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|iser_reg_resources
modifier|*
name|res
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|res
operator|->
name|mr
operator|=
name|ib_alloc_mr
argument_list|(
name|pd
argument_list|,
name|IB_MR_TYPE_MEM_REG
argument_list|,
name|ISCSI_ISER_SG_TABLESIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|res
operator|->
name|mr
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|PTR_ERR
argument_list|(
name|res
operator|->
name|mr
argument_list|)
expr_stmt|;
name|ISER_ERR
argument_list|(
literal|"Failed to allocate  fast reg mr err=%d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|res
operator|->
name|mr_valid
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iser_free_reg_res
parameter_list|(
name|struct
name|iser_reg_resources
modifier|*
name|rsc
parameter_list|)
block|{
name|ib_dereg_mr
argument_list|(
name|rsc
operator|->
name|mr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fast_reg_descriptor
modifier|*
name|iser_create_fastreg_desc
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ib_device
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|)
block|{
name|struct
name|fast_reg_descriptor
modifier|*
name|desc
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|desc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|,
name|M_ISER_VERBS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"Failed to allocate a new fastreg descriptor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|=
name|iser_alloc_reg_res
argument_list|(
name|ib_device
argument_list|,
name|pd
argument_list|,
operator|&
name|desc
operator|->
name|rsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"failed to allocate reg_resources"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|desc
argument_list|,
name|M_ISER_VERBS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * iser_create_fmr_pool - Creates FMR pool and page_vector  *  * returns 0 on success, or errno code on failure  */
end_comment

begin_function
name|int
name|iser_create_fastreg_pool
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|,
name|unsigned
name|cmds_max
parameter_list|)
block|{
name|struct
name|iser_device
modifier|*
name|device
init|=
name|ib_conn
operator|->
name|device
decl_stmt|;
name|struct
name|fast_reg_descriptor
modifier|*
name|desc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmds_max
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|=
name|iser_create_fastreg_desc
argument_list|(
name|device
operator|->
name|ib_device
argument_list|,
name|device
operator|->
name|pd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"Failed to create fastreg descriptor"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|desc
operator|->
name|list
argument_list|,
operator|&
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool_size
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|iser_free_fastreg_pool
argument_list|(
name|ib_conn
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * iser_free_fmr_pool - releases the FMR pool and page vec  */
end_comment

begin_function
name|void
name|iser_free_fastreg_pool
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|)
block|{
name|struct
name|fast_reg_descriptor
modifier|*
name|desc
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool
argument_list|)
condition|)
return|return;
name|ISER_DBG
argument_list|(
literal|"freeing conn %p fr pool"
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|desc
argument_list|,
argument|tmp
argument_list|,
argument|&ib_conn->fastreg.pool
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|desc
operator|->
name|list
argument_list|)
expr_stmt|;
name|iser_free_reg_res
argument_list|(
operator|&
name|desc
operator|->
name|rsc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|,
name|M_ISER_VERBS
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool_size
condition|)
name|ISER_WARN
argument_list|(
literal|"pool still has %d regions registered"
argument_list|,
name|ib_conn
operator|->
name|fastreg
operator|.
name|pool_size
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * iser_create_ib_conn_res - Queue-Pair (QP)  *  * returns 0 on success, 1 on failure  */
end_comment

begin_function
specifier|static
name|int
name|iser_create_ib_conn_res
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|)
block|{
name|struct
name|iser_conn
modifier|*
name|iser_conn
decl_stmt|;
name|struct
name|iser_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_device_attr
modifier|*
name|dev_attr
decl_stmt|;
name|struct
name|ib_qp_init_attr
name|init_attr
decl_stmt|;
name|int
name|index
decl_stmt|,
name|min_index
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|iser_conn
operator|=
name|container_of
argument_list|(
name|ib_conn
argument_list|,
expr|struct
name|iser_conn
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
name|device
operator|=
name|ib_conn
operator|->
name|device
expr_stmt|;
name|dev_attr
operator|=
operator|&
name|device
operator|->
name|dev_attr
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ig
operator|.
name|connlist_mutex
argument_list|)
expr_stmt|;
comment|/* select the CQ with the minimal number of usages */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|device
operator|->
name|comps_used
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|device
operator|->
name|comps
index|[
name|index
index|]
operator|.
name|active_qps
operator|<
name|device
operator|->
name|comps
index|[
name|min_index
index|]
operator|.
name|active_qps
condition|)
name|min_index
operator|=
name|index
expr_stmt|;
block|}
name|ib_conn
operator|->
name|comp
operator|=
operator|&
name|device
operator|->
name|comps
index|[
name|min_index
index|]
expr_stmt|;
name|ib_conn
operator|->
name|comp
operator|->
name|active_qps
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ig
operator|.
name|connlist_mutex
argument_list|)
expr_stmt|;
name|ISER_INFO
argument_list|(
literal|"cq index %d used for ib_conn %p"
argument_list|,
name|min_index
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|init_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|init_attr
argument_list|)
expr_stmt|;
name|init_attr
operator|.
name|event_handler
operator|=
name|iser_qp_event_callback
expr_stmt|;
name|init_attr
operator|.
name|qp_context
operator|=
operator|(
name|void
operator|*
operator|)
name|ib_conn
expr_stmt|;
name|init_attr
operator|.
name|send_cq
operator|=
name|ib_conn
operator|->
name|comp
operator|->
name|cq
expr_stmt|;
name|init_attr
operator|.
name|recv_cq
operator|=
name|ib_conn
operator|->
name|comp
operator|->
name|cq
expr_stmt|;
name|init_attr
operator|.
name|cap
operator|.
name|max_recv_wr
operator|=
name|ISER_QP_MAX_RECV_DTOS
expr_stmt|;
name|init_attr
operator|.
name|cap
operator|.
name|max_send_sge
operator|=
literal|2
expr_stmt|;
name|init_attr
operator|.
name|cap
operator|.
name|max_recv_sge
operator|=
literal|1
expr_stmt|;
name|init_attr
operator|.
name|sq_sig_type
operator|=
name|IB_SIGNAL_REQ_WR
expr_stmt|;
name|init_attr
operator|.
name|qp_type
operator|=
name|IB_QPT_RC
expr_stmt|;
if|if
condition|(
name|dev_attr
operator|->
name|max_qp_wr
operator|>
name|ISER_QP_MAX_REQ_DTOS
condition|)
block|{
name|init_attr
operator|.
name|cap
operator|.
name|max_send_wr
operator|=
name|ISER_QP_MAX_REQ_DTOS
expr_stmt|;
name|iser_conn
operator|->
name|max_cmds
operator|=
name|ISER_GET_MAX_XMIT_CMDS
argument_list|(
name|ISER_QP_MAX_REQ_DTOS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|init_attr
operator|.
name|cap
operator|.
name|max_send_wr
operator|=
name|dev_attr
operator|->
name|max_qp_wr
expr_stmt|;
name|iser_conn
operator|->
name|max_cmds
operator|=
name|ISER_GET_MAX_XMIT_CMDS
argument_list|(
name|dev_attr
operator|->
name|max_qp_wr
argument_list|)
expr_stmt|;
block|}
name|ISER_DBG
argument_list|(
literal|"device %s supports max_send_wr %d"
argument_list|,
name|device
operator|->
name|ib_device
operator|->
name|name
argument_list|,
name|dev_attr
operator|->
name|max_qp_wr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rdma_create_qp
argument_list|(
name|ib_conn
operator|->
name|cma_id
argument_list|,
name|device
operator|->
name|pd
argument_list|,
operator|&
name|init_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out_err
goto|;
name|ib_conn
operator|->
name|qp
operator|=
name|ib_conn
operator|->
name|cma_id
operator|->
name|qp
expr_stmt|;
name|ISER_DBG
argument_list|(
literal|"setting conn %p cma_id %p qp %p"
argument_list|,
name|ib_conn
argument_list|,
name|ib_conn
operator|->
name|cma_id
argument_list|,
name|ib_conn
operator|->
name|cma_id
operator|->
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|out_err
label|:
name|mtx_lock
argument_list|(
operator|&
name|ig
operator|.
name|connlist_mutex
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|comp
operator|->
name|active_qps
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ig
operator|.
name|connlist_mutex
argument_list|)
expr_stmt|;
name|ISER_ERR
argument_list|(
literal|"unable to alloc mem or create resource, err %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * based on the resolved device node GUID see if there already allocated  * device for this device. If there's no such, create one.  */
end_comment

begin_function
specifier|static
name|struct
name|iser_device
modifier|*
name|iser_device_find_by_ib_device
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|)
block|{
name|struct
name|iser_device
modifier|*
name|device
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ig
operator|.
name|device_list_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|device
argument_list|,
argument|&ig.device_list
argument_list|,
argument|ig_list
argument_list|)
comment|/* find if there's a match using the node GUID */
if|if
condition|(
name|device
operator|->
name|ib_device
operator|->
name|node_guid
operator|==
name|cma_id
operator|->
name|device
operator|->
name|node_guid
condition|)
goto|goto
name|inc_refcnt
goto|;
name|device
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|device
argument_list|,
name|M_ISER_VERBS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* assign this device to the device */
name|device
operator|->
name|ib_device
operator|=
name|cma_id
operator|->
name|device
expr_stmt|;
comment|/* init the device and link it into ig device list */
if|if
condition|(
name|iser_create_device_ib_res
argument_list|(
name|device
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|device
argument_list|,
name|M_ISER_VERBS
argument_list|)
expr_stmt|;
name|device
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|list_add
argument_list|(
operator|&
name|device
operator|->
name|ig_list
argument_list|,
operator|&
name|ig
operator|.
name|device_list
argument_list|)
expr_stmt|;
name|inc_refcnt
label|:
name|device
operator|->
name|refcount
operator|++
expr_stmt|;
name|ISER_INFO
argument_list|(
literal|"device %p refcount %d"
argument_list|,
name|device
argument_list|,
name|device
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|ig
operator|.
name|device_list_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|device
operator|)
return|;
block|}
end_function

begin_comment
comment|/* if there's no demand for this device, release it */
end_comment

begin_function
specifier|static
name|void
name|iser_device_try_release
parameter_list|(
name|struct
name|iser_device
modifier|*
name|device
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|ig
operator|.
name|device_list_mutex
argument_list|)
expr_stmt|;
name|device
operator|->
name|refcount
operator|--
expr_stmt|;
name|ISER_INFO
argument_list|(
literal|"device %p refcount %d"
argument_list|,
name|device
argument_list|,
name|device
operator|->
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|refcount
condition|)
block|{
name|iser_free_device_ib_res
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|device
operator|->
name|ig_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|device
argument_list|,
name|M_ISER_VERBS
argument_list|)
expr_stmt|;
name|device
operator|=
name|NULL
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|ig
operator|.
name|device_list_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called with state mutex held  **/
end_comment

begin_function
specifier|static
name|int
name|iser_conn_state_comp_exch
parameter_list|(
name|struct
name|iser_conn
modifier|*
name|iser_conn
parameter_list|,
name|enum
name|iser_conn_state
name|comp
parameter_list|,
name|enum
name|iser_conn_state
name|exch
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|iser_conn
operator|->
name|state
operator|==
name|comp
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|iser_conn
operator|->
name|state
operator|=
name|exch
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * iser_free_ib_conn_res - release IB related resources  * @iser_conn: iser connection struct  * @destroy: indicator if we need to try to release the  *     iser device and memory regoins pool (only iscsi  *     shutdown and DEVICE_REMOVAL will use this).  *  * This routine is called with the iser state mutex held  * so the cm_id removal is out of here. It is Safe to  * be invoked multiple times.  */
end_comment

begin_function
name|void
name|iser_free_ib_conn_res
parameter_list|(
name|struct
name|iser_conn
modifier|*
name|iser_conn
parameter_list|,
name|bool
name|destroy
parameter_list|)
block|{
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|struct
name|iser_device
modifier|*
name|device
init|=
name|ib_conn
operator|->
name|device
decl_stmt|;
name|ISER_INFO
argument_list|(
literal|"freeing conn %p cma_id %p qp %p"
argument_list|,
name|iser_conn
argument_list|,
name|ib_conn
operator|->
name|cma_id
argument_list|,
name|ib_conn
operator|->
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_conn
operator|->
name|qp
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ig
operator|.
name|connlist_mutex
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|comp
operator|->
name|active_qps
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ig
operator|.
name|connlist_mutex
argument_list|)
expr_stmt|;
name|rdma_destroy_qp
argument_list|(
name|ib_conn
operator|->
name|cma_id
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|destroy
condition|)
block|{
if|if
condition|(
name|iser_conn
operator|->
name|login_buf
condition|)
name|iser_free_login_buf
argument_list|(
name|iser_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|iser_conn
operator|->
name|rx_descs
condition|)
name|iser_free_rx_descriptors
argument_list|(
name|iser_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|!=
name|NULL
condition|)
block|{
name|iser_device_try_release
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|device
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * triggers start of the disconnect procedures and wait for them to be done  * Called with state mutex held  */
end_comment

begin_function
name|int
name|iser_conn_terminate
parameter_list|(
name|struct
name|iser_conn
modifier|*
name|iser_conn
parameter_list|)
block|{
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad_send_wr
decl_stmt|;
name|struct
name|ib_recv_wr
modifier|*
name|bad_recv_wr
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* terminate the iser conn only if the conn state is UP */
if|if
condition|(
operator|!
name|iser_conn_state_comp_exch
argument_list|(
name|iser_conn
argument_list|,
name|ISER_CONN_UP
argument_list|,
name|ISER_CONN_TERMINATING
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ISER_INFO
argument_list|(
literal|"iser_conn %p state %d\n"
argument_list|,
name|iser_conn
argument_list|,
name|iser_conn
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_conn
operator|->
name|qp
operator|==
name|NULL
condition|)
block|{
comment|/* HOW can this be??? */
name|ISER_WARN
argument_list|(
literal|"qp wasn't created"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Todo: This is a temporary workaround. 	 * We serialize the connection closure using global lock in order to 	 * receive all posted beacons completions. 	 * Without Serialization, in case we open many connections (QPs) on 	 * the same CQ, we might miss beacons because of missing interrupts. 	 */
name|sx_xlock
argument_list|(
operator|&
name|ig
operator|.
name|close_conns_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * In case we didn't already clean up the cma_id (peer initiated 	 * a disconnection), we need to Cause the CMA to change the QP 	 * state to ERROR. 	 */
if|if
condition|(
name|ib_conn
operator|->
name|cma_id
condition|)
block|{
name|err
operator|=
name|rdma_disconnect
argument_list|(
name|ib_conn
operator|->
name|cma_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|ISER_ERR
argument_list|(
literal|"Failed to disconnect, conn: 0x%p err %d"
argument_list|,
name|iser_conn
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|send
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_send_wr
argument_list|)
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|beacon
operator|.
name|send
operator|.
name|wr_id
operator|=
name|ISER_BEACON_WRID
expr_stmt|;
name|ib_conn
operator|->
name|beacon
operator|.
name|send
operator|.
name|opcode
operator|=
name|IB_WR_SEND
expr_stmt|;
comment|/* post an indication that all send flush errors were consumed */
name|err
operator|=
name|ib_post_send
argument_list|(
name|ib_conn
operator|->
name|qp
argument_list|,
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|send
argument_list|,
operator|&
name|bad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"conn %p failed to post send_beacon"
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ISER_DBG
argument_list|(
literal|"before send cv_wait: %p"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_cv
argument_list|,
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
name|ISER_DBG
argument_list|(
literal|"after send cv_wait: %p"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|recv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_recv_wr
argument_list|)
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|beacon
operator|.
name|recv
operator|.
name|wr_id
operator|=
name|ISER_BEACON_WRID
expr_stmt|;
comment|/* post an indication that all recv flush errors were consumed */
name|err
operator|=
name|ib_post_recv
argument_list|(
name|ib_conn
operator|->
name|qp
argument_list|,
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|recv
argument_list|,
operator|&
name|bad_recv_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"conn %p failed to post recv_beacon"
argument_list|,
name|ib_conn
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ISER_DBG
argument_list|(
literal|"before recv cv_wait: %p"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_cv
argument_list|,
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ib_conn
operator|->
name|beacon
operator|.
name|flush_lock
argument_list|)
expr_stmt|;
name|ISER_DBG
argument_list|(
literal|"after recv cv_wait: %p"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|ig
operator|.
name|close_conns_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Called with state mutex held  **/
end_comment

begin_function
specifier|static
name|void
name|iser_connect_error
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|)
block|{
name|struct
name|iser_conn
modifier|*
name|iser_conn
decl_stmt|;
name|iser_conn
operator|=
name|cma_id
operator|->
name|context
expr_stmt|;
name|ISER_ERR
argument_list|(
literal|"conn %p"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|iser_conn
operator|->
name|state
operator|=
name|ISER_CONN_TERMINATING
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|iser_conn
operator|->
name|up_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called with state mutex held  **/
end_comment

begin_function
specifier|static
name|void
name|iser_addr_handler
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|)
block|{
name|struct
name|iser_device
modifier|*
name|device
decl_stmt|;
name|struct
name|iser_conn
modifier|*
name|iser_conn
decl_stmt|;
name|struct
name|ib_conn
modifier|*
name|ib_conn
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|iser_conn
operator|=
name|cma_id
operator|->
name|context
expr_stmt|;
name|ib_conn
operator|=
operator|&
name|iser_conn
operator|->
name|ib_conn
expr_stmt|;
name|device
operator|=
name|iser_device_find_by_ib_device
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"conn %p device lookup/creation failed"
argument_list|,
name|iser_conn
argument_list|)
expr_stmt|;
name|iser_connect_error
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|ib_conn
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|ret
operator|=
name|rdma_resolve_route
argument_list|(
name|cma_id
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"conn %p resolve route failed: %d"
argument_list|,
name|iser_conn
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|iser_connect_error
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/**  * Called with state mutex held  **/
end_comment

begin_function
specifier|static
name|void
name|iser_route_handler
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|)
block|{
name|struct
name|rdma_conn_param
name|conn_param
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|iser_cm_hdr
name|req_hdr
decl_stmt|;
name|struct
name|iser_conn
modifier|*
name|iser_conn
init|=
name|cma_id
operator|->
name|context
decl_stmt|;
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|struct
name|iser_device
modifier|*
name|device
init|=
name|ib_conn
operator|->
name|device
decl_stmt|;
name|ret
operator|=
name|iser_create_ib_conn_res
argument_list|(
name|ib_conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|failure
goto|;
name|memset
argument_list|(
operator|&
name|conn_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|conn_param
argument_list|)
expr_stmt|;
name|conn_param
operator|.
name|responder_resources
operator|=
name|device
operator|->
name|dev_attr
operator|.
name|max_qp_rd_atom
expr_stmt|;
name|conn_param
operator|.
name|retry_count
operator|=
literal|7
expr_stmt|;
name|conn_param
operator|.
name|rnr_retry_count
operator|=
literal|6
expr_stmt|;
comment|/* 	 * Initiaotr depth should not be set, but in order to compat 	 * with old targets, we keep this value set. 	 */
name|conn_param
operator|.
name|initiator_depth
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|req_hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|req_hdr
operator|.
name|flags
operator|=
operator|(
name|ISER_ZBVA_NOT_SUPPORTED
operator||
name|ISER_SEND_W_INV_NOT_SUPPORTED
operator|)
expr_stmt|;
name|conn_param
operator|.
name|private_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|req_hdr
expr_stmt|;
name|conn_param
operator|.
name|private_data_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iser_cm_hdr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rdma_connect
argument_list|(
name|cma_id
argument_list|,
operator|&
name|conn_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"conn %p failure connecting: %d"
argument_list|,
name|iser_conn
argument_list|,
name|ret
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
return|return;
name|failure
label|:
name|iser_connect_error
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called with state mutex held  **/
end_comment

begin_function
specifier|static
name|void
name|iser_connected_handler
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|)
block|{
name|struct
name|iser_conn
modifier|*
name|iser_conn
decl_stmt|;
name|struct
name|ib_qp_attr
name|attr
decl_stmt|;
name|struct
name|ib_qp_init_attr
name|init_attr
decl_stmt|;
name|iser_conn
operator|=
name|cma_id
operator|->
name|context
expr_stmt|;
operator|(
name|void
operator|)
name|ib_query_qp
argument_list|(
name|cma_id
operator|->
name|qp
argument_list|,
operator|&
name|attr
argument_list|,
operator|~
literal|0
argument_list|,
operator|&
name|init_attr
argument_list|)
expr_stmt|;
name|ISER_INFO
argument_list|(
literal|"remote qpn:%x my qpn:%x"
argument_list|,
name|attr
operator|.
name|dest_qp_num
argument_list|,
name|cma_id
operator|->
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
name|iser_conn
operator|->
name|state
operator|=
name|ISER_CONN_UP
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|iser_conn
operator|->
name|up_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called with state mutex held  **/
end_comment

begin_function
specifier|static
name|void
name|iser_cleanup_handler
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|,
name|bool
name|destroy
parameter_list|)
block|{
name|struct
name|iser_conn
modifier|*
name|iser_conn
init|=
name|cma_id
operator|->
name|context
decl_stmt|;
if|if
condition|(
name|iser_conn_terminate
argument_list|(
name|iser_conn
argument_list|)
condition|)
name|iser_conn
operator|->
name|icl_conn
operator|.
name|ic_error
argument_list|(
operator|&
name|iser_conn
operator|->
name|icl_conn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iser_cma_handler
parameter_list|(
name|struct
name|rdma_cm_id
modifier|*
name|cma_id
parameter_list|,
name|struct
name|rdma_cm_event
modifier|*
name|event
parameter_list|)
block|{
name|struct
name|iser_conn
modifier|*
name|iser_conn
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|iser_conn
operator|=
name|cma_id
operator|->
name|context
expr_stmt|;
name|ISER_INFO
argument_list|(
literal|"event %d status %d conn %p id %p"
argument_list|,
name|event
operator|->
name|event
argument_list|,
name|event
operator|->
name|status
argument_list|,
name|cma_id
operator|->
name|context
argument_list|,
name|cma_id
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|iser_conn
operator|->
name|state_mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|event
condition|)
block|{
case|case
name|RDMA_CM_EVENT_ADDR_RESOLVED
case|:
name|iser_addr_handler
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDMA_CM_EVENT_ROUTE_RESOLVED
case|:
name|iser_route_handler
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDMA_CM_EVENT_ESTABLISHED
case|:
name|iser_connected_handler
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDMA_CM_EVENT_ADDR_ERROR
case|:
case|case
name|RDMA_CM_EVENT_ROUTE_ERROR
case|:
case|case
name|RDMA_CM_EVENT_CONNECT_ERROR
case|:
case|case
name|RDMA_CM_EVENT_UNREACHABLE
case|:
case|case
name|RDMA_CM_EVENT_REJECTED
case|:
name|iser_connect_error
argument_list|(
name|cma_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RDMA_CM_EVENT_DISCONNECTED
case|:
case|case
name|RDMA_CM_EVENT_ADDR_CHANGE
case|:
case|case
name|RDMA_CM_EVENT_TIMEWAIT_EXIT
case|:
name|iser_cleanup_handler
argument_list|(
name|cma_id
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ISER_ERR
argument_list|(
literal|"Unexpected RDMA CM event (%d)"
argument_list|,
name|event
operator|->
name|event
argument_list|)
expr_stmt|;
break|break;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|iser_conn
operator|->
name|state_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iser_post_recvl
parameter_list|(
name|struct
name|iser_conn
modifier|*
name|iser_conn
parameter_list|)
block|{
name|struct
name|ib_recv_wr
name|rx_wr
decl_stmt|,
modifier|*
name|rx_wr_failed
decl_stmt|;
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|struct
name|ib_sge
name|sge
decl_stmt|;
name|int
name|ib_ret
decl_stmt|;
name|sge
operator|.
name|addr
operator|=
name|iser_conn
operator|->
name|login_resp_dma
expr_stmt|;
name|sge
operator|.
name|length
operator|=
name|ISER_RX_LOGIN_SIZE
expr_stmt|;
name|sge
operator|.
name|lkey
operator|=
name|ib_conn
operator|->
name|device
operator|->
name|mr
operator|->
name|lkey
expr_stmt|;
name|rx_wr
operator|.
name|wr_id
operator|=
operator|(
name|uintptr_t
operator|)
name|iser_conn
operator|->
name|login_resp_buf
expr_stmt|;
name|rx_wr
operator|.
name|sg_list
operator|=
operator|&
name|sge
expr_stmt|;
name|rx_wr
operator|.
name|num_sge
operator|=
literal|1
expr_stmt|;
name|rx_wr
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|ib_conn
operator|->
name|post_recv_buf_count
operator|++
expr_stmt|;
name|ib_ret
operator|=
name|ib_post_recv
argument_list|(
name|ib_conn
operator|->
name|qp
argument_list|,
operator|&
name|rx_wr
argument_list|,
operator|&
name|rx_wr_failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_ret
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"ib_post_recv failed ret=%d"
argument_list|,
name|ib_ret
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|post_recv_buf_count
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|ib_ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iser_post_recvm
parameter_list|(
name|struct
name|iser_conn
modifier|*
name|iser_conn
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ib_recv_wr
modifier|*
name|rx_wr
decl_stmt|,
modifier|*
name|rx_wr_failed
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ib_ret
decl_stmt|;
name|struct
name|ib_conn
modifier|*
name|ib_conn
init|=
operator|&
name|iser_conn
operator|->
name|ib_conn
decl_stmt|;
name|unsigned
name|int
name|my_rx_head
init|=
name|iser_conn
operator|->
name|rx_desc_head
decl_stmt|;
name|struct
name|iser_rx_desc
modifier|*
name|rx_desc
decl_stmt|;
for|for
control|(
name|rx_wr
operator|=
name|ib_conn
operator|->
name|rx_wr
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|rx_wr
operator|++
control|)
block|{
name|rx_desc
operator|=
operator|&
name|iser_conn
operator|->
name|rx_descs
index|[
name|my_rx_head
index|]
expr_stmt|;
name|rx_wr
operator|->
name|wr_id
operator|=
operator|(
name|uintptr_t
operator|)
name|rx_desc
expr_stmt|;
name|rx_wr
operator|->
name|sg_list
operator|=
operator|&
name|rx_desc
operator|->
name|rx_sg
expr_stmt|;
name|rx_wr
operator|->
name|num_sge
operator|=
literal|1
expr_stmt|;
name|rx_wr
operator|->
name|next
operator|=
name|rx_wr
operator|+
literal|1
expr_stmt|;
name|my_rx_head
operator|=
operator|(
name|my_rx_head
operator|+
literal|1
operator|)
operator|%
name|iser_conn
operator|->
name|qp_max_recv_dtos
expr_stmt|;
block|}
name|rx_wr
operator|--
expr_stmt|;
name|rx_wr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* mark end of work requests list */
name|ib_conn
operator|->
name|post_recv_buf_count
operator|+=
name|count
expr_stmt|;
name|ib_ret
operator|=
name|ib_post_recv
argument_list|(
name|ib_conn
operator|->
name|qp
argument_list|,
name|ib_conn
operator|->
name|rx_wr
argument_list|,
operator|&
name|rx_wr_failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_ret
condition|)
block|{
name|ISER_ERR
argument_list|(
literal|"ib_post_recv failed ret=%d"
argument_list|,
name|ib_ret
argument_list|)
expr_stmt|;
name|ib_conn
operator|->
name|post_recv_buf_count
operator|-=
name|count
expr_stmt|;
block|}
else|else
name|iser_conn
operator|->
name|rx_desc_head
operator|=
name|my_rx_head
expr_stmt|;
return|return
operator|(
name|ib_ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * iser_start_send - Initiate a Send DTO operation  *  * returns 0 on success, -1 on failure  */
end_comment

begin_function
name|int
name|iser_post_send
parameter_list|(
name|struct
name|ib_conn
modifier|*
name|ib_conn
parameter_list|,
name|struct
name|iser_tx_desc
modifier|*
name|tx_desc
parameter_list|,
name|bool
name|signal
parameter_list|)
block|{
name|int
name|ib_ret
decl_stmt|;
name|struct
name|ib_send_wr
name|send_wr
decl_stmt|,
modifier|*
name|send_wr_failed
decl_stmt|;
name|ib_dma_sync_single_for_device
argument_list|(
name|ib_conn
operator|->
name|device
operator|->
name|ib_device
argument_list|,
name|tx_desc
operator|->
name|dma_addr
argument_list|,
name|ISER_HEADERS_LEN
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|send_wr
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|send_wr
operator|.
name|wr_id
operator|=
operator|(
name|uintptr_t
operator|)
name|tx_desc
expr_stmt|;
name|send_wr
operator|.
name|sg_list
operator|=
name|tx_desc
operator|->
name|tx_sg
expr_stmt|;
name|send_wr
operator|.
name|num_sge
operator|=
name|tx_desc
operator|->
name|num_sge
expr_stmt|;
name|send_wr
operator|.
name|opcode
operator|=
name|IB_WR_SEND
expr_stmt|;
name|send_wr
operator|.
name|send_flags
operator|=
name|signal
condition|?
name|IB_SEND_SIGNALED
else|:
literal|0
expr_stmt|;
name|ib_ret
operator|=
name|ib_post_send
argument_list|(
name|ib_conn
operator|->
name|qp
argument_list|,
operator|&
name|send_wr
argument_list|,
operator|&
name|send_wr_failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_ret
condition|)
name|ISER_ERR
argument_list|(
literal|"ib_post_send failed, ret:%d"
argument_list|,
name|ib_ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ib_ret
operator|)
return|;
block|}
end_function

end_unit

