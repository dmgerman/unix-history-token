begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) Comtrol Corporation<support@comtrol.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted prodived that the follwoing conditions  * are met.  * 1. Redistributions of source code must retain the above copyright   *    notive, this list of conditions and the following disclainer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials prodided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *       This product includes software developed by Comtrol Corporation.  * 4. The name of Comtrol Corporation may not be used to endorse or   *    promote products derived from this software without specific   *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY COMTROL CORPORATION ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL COMTROL CORPORATION BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*   * rp.c - for RocketPort FreeBSD  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_define
define|#
directive|define
name|ROCKET_C
end_define

begin_include
include|#
directive|include
file|<dev/rp/rpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/rp/rpvar.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|RocketPortVersion
index|[]
init|=
literal|"3.02"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Byte_t
name|RData
index|[
name|RDATASIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|,
literal|0xf6
block|,
literal|0x82
block|,
literal|0x02
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0xfb
block|,
literal|0x04
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x01
block|,
literal|0x0a
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x13
block|,
literal|0x0a
block|,
literal|0x09
block|,
literal|0xc5
block|,
literal|0x11
block|,
literal|0x0c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x85
block|,
literal|0x0e
block|,
literal|0x09
block|,
literal|0x20
block|,
literal|0x0a
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x21
block|,
literal|0x0a
block|,
literal|0x12
block|,
literal|0x09
block|,
literal|0x41
block|,
literal|0xff
block|,
literal|0x14
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x00
block|,
literal|0x16
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7b
block|,
literal|0x18
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x7d
block|,
literal|0x1a
block|,
literal|0x09
block|,
literal|0x88
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x7a
block|,
literal|0x1e
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x81
block|,
literal|0x20
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7c
block|,
literal|0x22
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Byte_t
name|RRegData
index|[
name|RREGDATASIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|,
literal|0xf6
block|,
literal|0x82
block|,
comment|/* 00: Stop Rx processor */
literal|0x08
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x13
block|,
comment|/* 04: Tx software flow control */
literal|0x0a
block|,
literal|0x09
block|,
literal|0xc5
block|,
literal|0x11
block|,
comment|/* 08: XON char */
literal|0x0c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x85
block|,
comment|/* 0c: XANY */
literal|0x12
block|,
literal|0x09
block|,
literal|0x41
block|,
literal|0xff
block|,
comment|/* 10: Rx mask char */
literal|0x14
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x00
block|,
comment|/* 14: Compare/Ignore #0 */
literal|0x16
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7b
block|,
comment|/* 18: Compare #1 */
literal|0x18
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x7d
block|,
comment|/* 1c: Compare #2 */
literal|0x1a
block|,
literal|0x09
block|,
literal|0x88
block|,
literal|0x81
block|,
comment|/* 20: Interrupt #1 */
literal|0x1c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x7a
block|,
comment|/* 24: Ignore/Replace #1 */
literal|0x1e
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x81
block|,
comment|/* 28: Interrupt #2 */
literal|0x20
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7c
block|,
comment|/* 2c: Ignore/Replace #2 */
literal|0x22
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
comment|/* 30: Rx FIFO Enable */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* IRQ number to MUDBAC register 2 mapping */
end_comment

begin_endif
unit|Byte_t sIRQMap[16] = {    0,0,0,0x10,0x20,0x30,0,0,0,0x40,0x50,0x60,0x70,0,0,0x80 };
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Byte_t
name|rp_sBitMapClrTbl
index|[
literal|8
index|]
init|=
block|{
literal|0xfe
block|,
literal|0xfd
block|,
literal|0xfb
block|,
literal|0xf7
block|,
literal|0xef
block|,
literal|0xdf
block|,
literal|0xbf
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Byte_t
name|rp_sBitMapSetTbl
index|[
literal|8
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Actually not used */
end_comment

begin_if
if|#
directive|if
name|notdef
end_if

begin_decl_stmt
name|struct
name|termios
name|deftermios
init|=
block|{
name|TTYDEF_IFLAG
block|,
name|TTYDEF_OFLAG
block|,
name|TTYDEF_CFLAG
block|,
name|TTYDEF_LFLAG
block|,
block|{
name|CEOF
block|,
name|CEOL
block|,
name|CEOL
block|,
name|CERASE
block|,
name|CWERASE
block|,
name|CKILL
block|,
name|CREPRINT
block|,
name|_POSIX_VDISABLE
block|,
name|CINTR
block|,
name|CQUIT
block|,
name|CSUSP
block|,
name|CDSUSP
block|,
name|CSTART
block|,
name|CSTOP
block|,
name|CLNEXT
block|,
name|CDISCARD
block|,
name|CMIN
block|,
name|CTIME
block|,
name|CSTATUS
block|,
name|_POSIX_VDISABLE
block|}
block|,
name|TTYDEF_SPEED
block|,
name|TTYDEF_SPEED
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************************************************** Function: sReadAiopID Purpose:  Read the AIOP idenfication number directly from an AIOP. Call:	  sReadAiopID(CtlP, aiop) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int aiop: AIOP index Return:   int: Flag AIOPID_XXXX if a valid AIOP is found, where X 		 is replace by an identifying number. 	  Flag AIOPID_NULL if no valid AIOP is found Warnings: No context switches are allowed while executing this function.  */
end_comment

begin_function
name|int
name|sReadAiopID
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|int
name|aiop
parameter_list|)
block|{
name|Byte_t
name|AiopID
decl_stmt|;
comment|/* ID byte from AIOP */
name|rp_writeaiop1
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_CMD_REG
argument_list|,
name|RESET_ALL
argument_list|)
expr_stmt|;
comment|/* reset AIOP */
name|rp_writeaiop1
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_CMD_REG
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|AiopID
operator|=
name|rp_readaiop1
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_CHN_STAT0
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|AiopID
operator|==
literal|0x06
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
comment|/* AIOP does not exist */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sReadAiopNumChan Purpose:  Read the number of channels available in an AIOP directly from 	  an AIOP. Call:	  sReadAiopNumChan(CtlP, aiop) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int aiop: AIOP index Return:   int: The number of channels available Comments: The number of channels is determined by write/reads from identical 	  offsets within the SRAM address spaces for channels 0 and 4. 	  If the channel 4 space is mirrored to channel 0 it is a 4 channel 	  AIOP, otherwise it is an 8 channel. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sReadAiopNumChan
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|int
name|aiop
parameter_list|)
block|{
name|Word_t
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rp_writeaiop4
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_ADDR
argument_list|,
literal|0x12340000L
argument_list|)
expr_stmt|;
comment|/* write to chan 0 SRAM */
name|rp_writeaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read from SRAM, chan 0 */
name|x
operator|=
name|rp_readaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_DATA
argument_list|)
expr_stmt|;
name|rp_writeaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_ADDR
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
comment|/* read from SRAM, chan 4 */
name|y
operator|=
name|rp_readaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|y
condition|)
comment|/* if different must be 8 chan */
return|return
operator|(
literal|8
operator|)
return|;
else|else
return|return
operator|(
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sInitChan Purpose:  Initialization of a channel and channel structure Call:	  sInitChan(CtlP,ChP,AiopNum,ChanNum) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  CHANNEL_T *ChP; Ptr to channel structure 	  int AiopNum; AIOP number within controller 	  int ChanNum; Channel number within AIOP Return:   int: TRUE if initialization succeeded, FALSE if it fails because channel 	       number exceeds number of channels available in AIOP. Comments: This function must be called before a channel can be used. Warnings: No range checking on any of the parameters is done.  	  No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sInitChan
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|int
name|AiopNum
parameter_list|,
name|int
name|ChanNum
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ChOff
decl_stmt|;
name|Byte_t
modifier|*
name|ChR
decl_stmt|;
specifier|static
name|Byte_t
name|R
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|ChanNum
operator|>=
name|CtlP
operator|->
name|AiopNumChan
index|[
name|AiopNum
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* exceeds num chans in AIOP */
comment|/* Channel, AIOP, and controller identifiers */
name|ChP
operator|->
name|CtlP
operator|=
name|CtlP
expr_stmt|;
name|ChP
operator|->
name|ChanID
operator|=
name|CtlP
operator|->
name|AiopID
index|[
name|AiopNum
index|]
expr_stmt|;
name|ChP
operator|->
name|AiopNum
operator|=
name|AiopNum
expr_stmt|;
name|ChP
operator|->
name|ChanNum
operator|=
name|ChanNum
expr_stmt|;
comment|/* Initialize the channel from the RData array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RDATASIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|R
index|[
literal|0
index|]
operator|=
name|RData
index|[
name|i
index|]
expr_stmt|;
name|R
index|[
literal|1
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|0x10
operator|*
name|ChanNum
expr_stmt|;
name|R
index|[
literal|2
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|R
index|[
literal|3
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|R
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|ChR
operator|=
name|ChP
operator|->
name|R
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RREGDATASIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ChR
index|[
name|i
index|]
operator|=
name|RRegData
index|[
name|i
index|]
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|0x10
operator|*
name|ChanNum
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
comment|/* Indexed registers */
name|ChOff
operator|=
operator|(
name|Word_t
operator|)
name|ChanNum
operator|*
literal|0x1000
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_BAUD
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_BAUD
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|2
index|]
operator|=
operator|(
name|Byte_t
operator|)
name|BRD9600
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|3
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|BRD9600
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|BaudDiv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TX_CTRL
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TX_CTRL
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_RX_CTRL
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_RX_CTRL
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TX_ENBLS
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TX_ENBLS
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxEnables
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXCMP1
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXCMP1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxCompare
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXREP1B1
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXREP1B1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxReplace1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXREP2
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXREP2
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxReplace2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxFIFOPtrs
operator|=
name|ChOff
operator|+
name|_TXF_OUTP
expr_stmt|;
name|ChP
operator|->
name|TxFIFO
operator|=
name|ChOff
operator|+
name|_TX_FIFO
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
operator||
name|RESTXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Tx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
argument_list|)
expr_stmt|;
comment|/* remove reset Tx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Tx in/out ptrs */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxFIFOPtrs
operator|=
name|ChOff
operator|+
name|_RXF_OUTP
expr_stmt|;
name|ChP
operator|->
name|RxFIFO
operator|=
name|ChOff
operator|+
name|_RX_FIFO
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
operator||
name|RESRXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Rx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
argument_list|)
expr_stmt|;
comment|/* remove reset Rx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Rx out ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* clear Rx in ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioCnt
operator|=
name|ChOff
operator|+
name|_TXP_CNT
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioPtr
operator|=
name|ChOff
operator|+
name|_TXP_PNTR
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxPrioPtr
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioBuf
operator|=
name|ChOff
operator|+
name|_TXP_BUF
expr_stmt|;
name|sEnRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* start the Rx processor */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sStopRxProcessor Purpose:  Stop the receive processor from processing a channel. Call:	  sStopRxProcessor(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure  Comments: The receive processor can be started again with sStartRxProcessor(). 	  This function causes the receive processor to skip over the 	  stopped channel.  It does not stop it from processing other channels.  Warnings: No context switches are allowed while executing this function.  	  Do not leave the receive processor stopped for more than one 	  character time.  	  After calling this function a delay of 4 uS is required to ensure 	  that the receive processor is no longer processing this channel. */
end_comment

begin_function
name|void
name|sStopRxProcessor
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|Byte_t
name|R
index|[
literal|4
index|]
decl_stmt|;
name|R
index|[
literal|0
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|0
index|]
expr_stmt|;
name|R
index|[
literal|1
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|1
index|]
expr_stmt|;
name|R
index|[
literal|2
index|]
operator|=
literal|0x0a
expr_stmt|;
name|R
index|[
literal|3
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|3
index|]
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|R
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sFlushRxFIFO Purpose:  Flush the Rx FIFO Call:	  sFlushRxFIFO(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure Return:   void Comments: To prevent data from being enqueued or dequeued in the Tx FIFO 	  while it is being flushed the receive processor is stopped 	  and the transmitter is disabled.  After these operations a 	  4 uS delay is done before clearing the pointers to allow 	  the receive processor to stop.  These items are handled inside 	  this function. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|void
name|sFlushRxFIFO
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Byte_t
name|Ch
decl_stmt|;
comment|/* channel number within AIOP */
name|int
name|RxFIFOEnabled
decl_stmt|;
comment|/* TRUE if Rx FIFO enabled */
if|if
condition|(
name|sGetRxCnt
argument_list|(
name|ChP
argument_list|)
operator|==
literal|0
condition|)
comment|/* Rx FIFO empty */
return|return;
comment|/* don't need to flush */
name|RxFIFOEnabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ChP
operator|->
name|R
index|[
literal|0x32
index|]
operator|==
literal|0x08
condition|)
comment|/* Rx FIFO is enabled */
block|{
name|RxFIFOEnabled
operator|=
name|TRUE
expr_stmt|;
name|sDisRxFIFO
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* disable it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2000
operator|/
literal|200
condition|;
name|i
operator|++
control|)
comment|/* delay 2 uS to allow proc to disable FIFO*/
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_CHAN
argument_list|)
expr_stmt|;
comment|/* depends on bus i/o timing */
block|}
name|sGetChanStatus
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* clear any pending Rx errors in chan stat */
name|Ch
operator|=
operator|(
name|Byte_t
operator|)
name|sGetChanNum
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
operator||
name|RESRXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Rx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
argument_list|)
expr_stmt|;
comment|/* remove reset Rx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Rx out ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* clear Rx in ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RxFIFOEnabled
condition|)
name|sEnRxFIFO
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* enable Rx FIFO */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sFlushTxFIFO Purpose:  Flush the Tx FIFO Call:	  sFlushTxFIFO(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure Return:   void Comments: To prevent data from being enqueued or dequeued in the Tx FIFO 	  while it is being flushed the receive processor is stopped 	  and the transmitter is disabled.  After these operations a 	  4 uS delay is done before clearing the pointers to allow 	  the receive processor to stop.  These items are handled inside 	  this function. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|void
name|sFlushTxFIFO
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Byte_t
name|Ch
decl_stmt|;
comment|/* channel number within AIOP */
name|int
name|TxEnabled
decl_stmt|;
comment|/* TRUE if transmitter enabled */
if|if
condition|(
name|sGetTxCnt
argument_list|(
name|ChP
argument_list|)
operator|==
literal|0
condition|)
comment|/* Tx FIFO empty */
return|return;
comment|/* don't need to flush */
name|TxEnabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ChP
operator|->
name|TxControl
index|[
literal|3
index|]
operator|&
name|TX_ENABLE
condition|)
block|{
name|TxEnabled
operator|=
name|TRUE
expr_stmt|;
name|sDisTransmit
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* disable transmitter */
block|}
name|sStopRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* stop Rx processor */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4000
operator|/
literal|200
condition|;
name|i
operator|++
control|)
comment|/* delay 4 uS to allow proc to stop */
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_CHAN
argument_list|)
expr_stmt|;
comment|/* depends on bus i/o timing */
name|Ch
operator|=
operator|(
name|Byte_t
operator|)
name|sGetChanNum
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
operator||
name|RESTXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Tx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
argument_list|)
expr_stmt|;
comment|/* remove reset Tx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Tx in/out ptrs */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TxEnabled
condition|)
name|sEnTransmit
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* enable transmitter */
name|sStartRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* restart Rx processor */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sWriteTxPrioByte Purpose:  Write a byte of priority transmit data to a channel Call:	  sWriteTxPrioByte(ChP,Data) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Byte_t Data; The transmit data byte  Return:   int: 1 if the bytes is successfully written, otherwise 0.  Comments: The priority byte is transmitted before any data in the Tx FIFO.  Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sWriteTxPrioByte
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Byte_t
name|Data
parameter_list|)
block|{
name|Byte_t
name|DWBuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* buffer for double word writes */
name|Word_t
modifier|*
name|WordPtr
decl_stmt|;
comment|/* must be far because Win SS != DS */
if|if
condition|(
name|sGetTxCnt
argument_list|(
name|ChP
argument_list|)
operator|>
literal|1
condition|)
comment|/* write it to Tx priority buffer */
block|{
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
comment|/* get priority buffer status */
if|if
condition|(
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|)
operator|&
name|PRI_PEND
condition|)
comment|/* priority buffer busy */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing sent */
name|WordPtr
operator|=
operator|(
name|Word_t
operator|*
operator|)
operator|(
operator|&
name|DWBuf
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|*
name|WordPtr
operator|=
name|ChP
operator|->
name|TxPrioBuf
expr_stmt|;
comment|/* data byte address */
name|DWBuf
index|[
literal|2
index|]
operator|=
name|Data
expr_stmt|;
comment|/* data byte value */
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
operator|(
name|DWord_t
operator|*
operator|)
operator|(
operator|&
name|DWBuf
index|[
literal|0
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* write it out */
operator|*
name|WordPtr
operator|=
name|ChP
operator|->
name|TxPrioCnt
expr_stmt|;
comment|/* Tx priority count address */
name|DWBuf
index|[
literal|2
index|]
operator|=
name|PRI_PEND
operator|+
literal|1
expr_stmt|;
comment|/* indicate 1 byte pending */
name|DWBuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* priority buffer pointer */
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
operator|(
name|DWord_t
operator|*
operator|)
operator|(
operator|&
name|DWBuf
index|[
literal|0
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* write it out */
block|}
else|else
comment|/* write it to Tx FIFO */
block|{
name|sWriteTxByte
argument_list|(
name|ChP
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|ChP
argument_list|)
argument_list|,
name|Data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 1 byte sent */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sEnInterrupts Purpose:  Enable one or more interrupts for a channel Call:	  sEnInterrupts(ChP,Flags) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Word_t Flags: Interrupt enable flags, can be any combination 	     of the following flags: 		TXINT_EN:   Interrupt on Tx FIFO empty 		RXINT_EN:   Interrupt on Rx FIFO at trigger level (see 			    sSetRxTrigger()) 		SRCINT_EN:  Interrupt on SRC (Special Rx Condition) 		MCINT_EN:   Interrupt on modem input change 		CHANINT_EN: Allow channel interrupt signal to the AIOP's 			    Interrupt Channel Register. Return:   void Comments: If an interrupt enable flag is set in Flags, that interrupt will be 	  enabled.  If an interrupt enable flag is not set in Flags, that 	  interrupt will not be changed.  Interrupts can be disabled with 	  function sDisInterrupts().  	  This function sets the appropriate bit for the channel in the AIOP's 	  Interrupt Mask Register if the CHANINT_EN flag is set.  This allows 	  this channel's bit to be set in the AIOP's Interrupt Channel Register.  	  Interrupts must also be globally enabled before channel interrupts 	  will be passed on to the host.  This is done with function 	  sEnGlobalInt().  	  In some cases it may be desirable to disable interrupts globally but 	  enable channel interrupts.  This would allow the global interrupt 	  status register to be used to determine which AIOPs need service. */
end_comment

begin_function
name|void
name|sEnInterrupts
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Word_t
name|Flags
parameter_list|)
block|{
name|Byte_t
name|Mask
decl_stmt|;
comment|/* Interrupt Mask Register */
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
operator|(
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|MCINT_EN
operator|)
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
name|TXINT_EN
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|CHANINT_EN
condition|)
block|{
name|Mask
operator|=
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|)
operator||
name|rp_sBitMapSetTbl
index|[
name|ChP
operator|->
name|ChanNum
index|]
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sDisInterrupts Purpose:  Disable one or more interrupts for a channel Call:	  sDisInterrupts(ChP,Flags) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Word_t Flags: Interrupt flags, can be any combination 	     of the following flags: 		TXINT_EN:   Interrupt on Tx FIFO empty 		RXINT_EN:   Interrupt on Rx FIFO at trigger level (see 			    sSetRxTrigger()) 		SRCINT_EN:  Interrupt on SRC (Special Rx Condition) 		MCINT_EN:   Interrupt on modem input change 		CHANINT_EN: Disable channel interrupt signal to the 			    AIOP's Interrupt Channel Register. Return:   void Comments: If an interrupt flag is set in Flags, that interrupt will be 	  disabled.  If an interrupt flag is not set in Flags, that 	  interrupt will not be changed.  Interrupts can be enabled with 	  function sEnInterrupts().  	  This function clears the appropriate bit for the channel in the AIOP's 	  Interrupt Mask Register if the CHANINT_EN flag is set.  This blocks 	  this channel's bit from being set in the AIOP's Interrupt Channel 	  Register. */
end_comment

begin_function
name|void
name|sDisInterrupts
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Word_t
name|Flags
parameter_list|)
block|{
name|Byte_t
name|Mask
decl_stmt|;
comment|/* Interrupt Mask Register */
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
operator|(
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|MCINT_EN
operator|)
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
name|TXINT_EN
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|CHANINT_EN
condition|)
block|{
name|Mask
operator|=
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|)
operator|&
name|rp_sBitMapClrTbl
index|[
name|ChP
operator|->
name|ChanNum
index|]
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************   Begin FreeBsd-specific driver code **********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|timeout_t
name|rpdtrwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|rpopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|rpclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|rpwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|rpioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|81
end_define

begin_decl_stmt
name|struct
name|cdevsw
name|rp_cdevsw
init|=
block|{
comment|/* open */
name|rpopen
block|,
comment|/* close */
name|rpclose
block|,
comment|/* read */
name|ttyread
block|,
comment|/* write */
name|rpwrite
block|,
comment|/* ioctl */
name|rpioctl
block|,
comment|/* poll */
name|ttypoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"rp"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rp_num_ports_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rp_ndevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|minor_to_unit
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rp_num_ports
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ports on each controller */
end_comment

begin_define
define|#
directive|define
name|_INLINE_
value|__inline
end_define

begin_define
define|#
directive|define
name|POLL_INTERVAL
value|1
end_define

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|DEV_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev))& ~MINOR_MAGIC_MASK)
end_define

begin_define
define|#
directive|define
name|IS_CALLOUT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& CALLOUT_MASK)
end_define

begin_define
define|#
directive|define
name|IS_CONTROL
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|RP_ISMULTIPORT
parameter_list|(
name|dev
parameter_list|)
value|((dev)->id_flags& 0x1)
end_define

begin_define
define|#
directive|define
name|RP_MPMASTER
parameter_list|(
name|dev
parameter_list|)
value|(((dev)->id_flags>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|RP_NOTAST4
parameter_list|(
name|dev
parameter_list|)
value|((dev)->id_flags& 0x04)
end_define

begin_decl_stmt
specifier|static
name|struct
name|rp_port
modifier|*
name|p_rp_addr
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rp_port
modifier|*
name|p_rp_table
index|[
name|MAX_RP_PORTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rp_addr
parameter_list|(
name|unit
parameter_list|)
value|(p_rp_addr[unit])
end_define

begin_define
define|#
directive|define
name|rp_table
parameter_list|(
name|port
parameter_list|)
value|(p_rp_table[port])
end_define

begin_comment
comment|/*  * The top-level routines begin here  */
end_comment

begin_function_decl
specifier|static
name|int
name|rpparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpstart
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpstop
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rphardclose
parameter_list|(
name|struct
name|rp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rp_disc_optim
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|_INLINE_
name|void
name|rp_do_receive
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|CHANNEL_t
modifier|*
name|cp
parameter_list|,
name|unsigned
name|int
name|ChanStatus
parameter_list|)
block|{
name|int
name|spl
decl_stmt|;
name|unsigned
name|int
name|CharNStat
decl_stmt|;
name|int
name|ToRecv
decl_stmt|,
name|wRecv
decl_stmt|,
name|ch
decl_stmt|,
name|ttynocopy
decl_stmt|;
name|ToRecv
operator|=
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ToRecv
operator|==
literal|0
condition|)
return|return;
comment|/*	If status indicates there are errored characters in the 	FIFO, then enter status mode (a word in FIFO holds 	characters and status) */
if|if
condition|(
name|ChanStatus
operator|&
operator|(
name|RXFOVERFL
operator||
name|RXBREAK
operator||
name|RXFRAME
operator||
name|RXPARITY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ChanStatus
operator|&
name|STATMODE
operator|)
condition|)
block|{
name|ChanStatus
operator||=
name|STATMODE
expr_stmt|;
name|sEnRxStatusMode
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	if we previously entered status mode then read down the 	FIFO one word at a time, pulling apart the character and 	the status. Update error counters depending on status. */
if|if
condition|(
name|ChanStatus
operator|&
name|STATMODE
condition|)
block|{
while|while
condition|(
name|ToRecv
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
break|break;
block|}
name|CharNStat
operator|=
name|rp_readch2
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
name|CharNStat
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|CharNStat
operator|&
name|STMBREAK
operator|)
operator|||
operator|(
name|CharNStat
operator|&
name|STMFRAMEH
operator|)
condition|)
name|ch
operator||=
name|TTY_FE
expr_stmt|;
elseif|else
if|if
condition|(
name|CharNStat
operator|&
name|STMPARITYH
condition|)
name|ch
operator||=
name|TTY_PE
expr_stmt|;
elseif|else
if|if
condition|(
name|CharNStat
operator|&
name|STMRCVROVRH
condition|)
name|rp
operator|->
name|rp_overflows
operator|++
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|ch
operator|,
name|tp
operator|)
expr_stmt|;
name|ToRecv
operator|--
expr_stmt|;
block|}
comment|/* 	After emtying FIFO in status mode, turn off status mode */
if|if
condition|(
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sDisRxStatusMode
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Avoid the grotesquely inefficient lineswitch routine 		 * (ttyinput) in "raw" mode.  It usually takes about 450 		 * instructions (that's without canonical processing or echo!). 		 * slinput is reasonably fast (usually 40 instructions plus 		 * call overhead). 		 */
name|ToRecv
operator|=
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
if|if
condition|(
name|ToRecv
operator|>
name|RXFIFO_SIZE
condition|)
block|{
name|ToRecv
operator|=
name|RXFIFO_SIZE
expr_stmt|;
block|}
name|wRecv
operator|=
name|ToRecv
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|wRecv
condition|)
block|{
name|rp_readmultich2
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|rp
operator|->
name|RxBuf
argument_list|,
name|wRecv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ToRecv
operator|&
literal|1
condition|)
block|{
name|rp
operator|->
name|RxBuf
index|[
operator|(
name|ToRecv
operator|-
literal|1
operator|)
index|]
operator|=
operator|(
name|u_char
operator|)
name|rp_readch1
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tk_nin
operator|+=
name|ToRecv
expr_stmt|;
name|tk_rawcc
operator|+=
name|ToRecv
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|ToRecv
expr_stmt|;
name|ttynocopy
operator|=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp
operator|->
name|RxBuf
argument_list|,
name|ToRecv
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ToRecv
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
break|break;
block|}
name|ch
operator|=
operator|(
name|u_char
operator|)
name|rp_readch1
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|spl
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|ch
operator|,
name|tp
operator|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|ToRecv
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|_INLINE_
name|void
name|rp_handle_port
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|)
block|{
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|IntMask
decl_stmt|,
name|ChanStatus
decl_stmt|;
if|if
condition|(
operator|!
name|rp
condition|)
return|return;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|IntMask
operator|=
name|sGetChanIntID
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|IntMask
operator|=
name|IntMask
operator|&
name|rp
operator|->
name|rp_intmask
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IntMask
operator|&
name|RXF_TRIG
condition|)
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|rp_do_receive
argument_list|(
name|rp
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
name|ChanStatus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IntMask
operator|&
name|DELTA_CD
condition|)
block|{
if|if
condition|(
name|ChanStatus
operator|&
name|CD_ACT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|rphardclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*	oldcts = rp->rp_cts; 	rp->rp_cts = ((ChanStatus& CTS_ACT) != 0); 	if(oldcts != rp->rp_cts) { 		printf("CTS change (now %s)... on port %d\n", rp->rp_cts ? "on" : "off", rp->rp_port); 	} */
block|}
end_function

begin_function
specifier|static
name|void
name|rp_do_poll
parameter_list|(
name|void
modifier|*
name|not_used
parameter_list|)
block|{
name|CONTROLLER_t
modifier|*
name|ctl
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|aiop
decl_stmt|,
name|ch
decl_stmt|,
name|line
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|char
name|CtlMask
decl_stmt|,
name|AiopMask
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|rp_ndevs
condition|;
name|unit
operator|++
control|)
block|{
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|rp
operator|->
name|rp_ctlp
expr_stmt|;
name|CtlMask
operator|=
name|ctl
operator|->
name|ctlmask
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|CtlMask
condition|;
name|CtlMask
operator|>>=
literal|1
operator|,
name|aiop
operator|++
control|)
block|{
if|if
condition|(
name|CtlMask
operator|&
literal|1
condition|)
block|{
name|AiopMask
operator|=
name|sGetAiopIntStatus
argument_list|(
name|ctl
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|AiopMask
condition|;
name|AiopMask
operator|>>=
literal|1
operator|,
name|ch
operator|++
control|)
block|{
if|if
condition|(
name|AiopMask
operator|&
literal|1
condition|)
block|{
name|line
operator|=
operator|(
name|unit
operator|<<
literal|5
operator|)
operator||
operator|(
name|aiop
operator|<<
literal|3
operator|)
operator||
name|ch
expr_stmt|;
name|rp
operator|=
name|rp_table
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|rp_handle_port
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|line
operator|=
literal|0
operator|,
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
init|;
name|line
operator|<
name|rp_num_ports
index|[
name|unit
index|]
condition|;
name|line
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|count
operator|=
name|sGetTxCnt
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|&&
operator|(
name|count
operator|<=
name|rp
operator|->
name|rp_restart
operator|)
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|rp_num_ports_open
condition|)
name|timeout
argument_list|(
name|rp_do_poll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|POLL_INTERVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rp_attachcommon
parameter_list|(
name|CONTROLLER_T
modifier|*
name|ctlp
parameter_list|,
name|int
name|num_aiops
parameter_list|,
name|int
name|num_ports
parameter_list|)
block|{
name|int
name|oldspl
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|num_chan
decl_stmt|;
name|int
name|aiop
decl_stmt|,
name|chan
decl_stmt|,
name|port
decl_stmt|;
name|int
name|ChanStatus
decl_stmt|,
name|line
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|dev_t
modifier|*
name|dev_nodes
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RocketPort%d (Version %s) %d ports.\n"
argument_list|,
name|unit
argument_list|,
name|RocketPortVersion
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
name|rp_num_ports
index|[
name|unit
index|]
operator|=
name|num_ports
expr_stmt|;
name|ctlp
operator|->
name|rp
operator|=
name|rp
operator|=
operator|(
expr|struct
name|rp_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
literal|"rp_attachcommon: Could not malloc rp_ports structures.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|count
operator|=
name|unit
operator|*
literal|32
expr_stmt|;
comment|/* board times max ports per card SG */
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|<
operator|(
name|count
operator|+
name|rp_num_ports
index|[
name|unit
index|]
operator|)
condition|;
name|i
operator|++
control|)
name|minor_to_unit
index|[
name|i
index|]
operator|=
name|unit
expr_stmt|;
name|bzero
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|tty
operator|=
name|tty
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
literal|"rp_attachcommon: Could not malloc tty structures.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|=
name|rp
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|dev_nodes
operator|=
name|ctlp
operator|->
name|dev_nodes
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ctlp
operator|->
name|dev_nodes
operator|)
argument_list|)
operator|*
name|rp_num_ports
index|[
name|unit
index|]
operator|*
literal|6
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlp
operator|->
name|dev_nodes
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
literal|"rp_attachcommon: Could not malloc device node structures.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp_num_ports
index|[
name|unit
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|dev_nodes
operator|++
operator|)
operator|=
name|make_dev
argument_list|(
operator|&
name|rp_cdevsw
argument_list|,
operator|(
operator|(
name|unit
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
name|i
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"ttyR%c"
argument_list|,
name|i
operator|<=
literal|9
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dev_nodes
operator|++
operator|)
operator|=
name|make_dev
argument_list|(
operator|&
name|rp_cdevsw
argument_list|,
operator|(
operator|(
name|unit
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
name|i
operator||
literal|0x20
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"ttyiR%c"
argument_list|,
name|i
operator|<=
literal|9
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dev_nodes
operator|++
operator|)
operator|=
name|make_dev
argument_list|(
operator|&
name|rp_cdevsw
argument_list|,
operator|(
operator|(
name|unit
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
name|i
operator||
literal|0x40
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"ttylR%c"
argument_list|,
name|i
operator|<=
literal|9
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dev_nodes
operator|++
operator|)
operator|=
name|make_dev
argument_list|(
operator|&
name|rp_cdevsw
argument_list|,
operator|(
operator|(
name|unit
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
name|i
operator||
literal|0x80
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"cuaR%c"
argument_list|,
name|i
operator|<=
literal|9
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dev_nodes
operator|++
operator|)
operator|=
name|make_dev
argument_list|(
operator|&
name|rp_cdevsw
argument_list|,
operator|(
operator|(
name|unit
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
name|i
operator||
literal|0xa0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"cuaiR%c"
argument_list|,
name|i
operator|<=
literal|9
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
argument_list|)
expr_stmt|;
operator|*
operator|(
name|dev_nodes
operator|++
operator|)
operator|=
name|make_dev
argument_list|(
operator|&
name|rp_cdevsw
argument_list|,
operator|(
operator|(
name|unit
operator|+
literal|1
operator|)
operator|<<
literal|16
operator|)
operator||
name|i
operator||
literal|0xc0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"cualR%c"
argument_list|,
name|i
operator|<=
literal|9
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|num_chan
operator|=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|num_chan
condition|;
name|chan
operator|++
operator|,
name|port
operator|++
operator|,
name|rp
operator|++
operator|,
name|tty
operator|++
control|)
block|{
name|rp
operator|->
name|rp_tty
operator|=
name|tty
expr_stmt|;
name|rp
operator|->
name|rp_port
operator|=
name|port
expr_stmt|;
name|rp
operator|->
name|rp_ctlp
operator|=
name|ctlp
expr_stmt|;
name|rp
operator|->
name|rp_unit
operator|=
name|unit
expr_stmt|;
name|rp
operator|->
name|rp_chan
operator|=
name|chan
expr_stmt|;
name|rp
operator|->
name|rp_aiop
operator|=
name|aiop
expr_stmt|;
name|tty
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
comment|/*		tty->t_termios = deftermios; 	*/
name|rp
operator|->
name|dtr_wait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|rp
operator|->
name|it_in
argument_list|)
expr_stmt|;
comment|/*		termioschars(&tty->t_termios); 	*/
name|rp
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|rp
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|rp
operator|->
name|it_out
operator|=
name|rp
operator|->
name|it_in
expr_stmt|;
name|rp
operator|->
name|rp_intmask
operator|=
name|RXF_TRIG
operator||
name|TXFIFO_MT
operator||
name|SRC_INT
operator||
name|DELTA_CD
operator||
name|DELTA_CTS
operator||
name|DELTA_DSR
expr_stmt|;
if|#
directive|if
name|notdef
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
name|sInitChan
argument_list|(
name|ctlp
argument_list|,
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
literal|"RocketPort sInitChan(%d, %d, %d) failed.\n"
argument_list|,
name|unit
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_cts
operator|=
operator|(
name|ChanStatus
operator|&
name|CTS_ACT
operator|)
operator|!=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|unit
operator|<<
literal|5
operator|)
operator||
operator|(
name|aiop
operator|<<
literal|3
operator|)
operator||
name|chan
expr_stmt|;
name|rp_table
argument_list|(
name|line
argument_list|)
operator|=
name|rp
expr_stmt|;
block|}
block|}
name|rp_ndevs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
name|rp_releaseresource
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rp_releaseresource
parameter_list|(
name|CONTROLLER_t
modifier|*
name|ctlp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|unit
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlp
operator|->
name|rp
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|p_rp_addr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p_rp_addr
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_rp_addr
index|[
name|i
index|]
operator|==
name|ctlp
operator|->
name|rp
condition|)
name|p_rp_addr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|p_rp_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p_rp_table
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_rp_table
index|[
name|i
index|]
operator|==
name|ctlp
operator|->
name|rp
condition|)
name|p_rp_table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctlp
operator|->
name|rp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|->
name|tty
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ctlp
operator|->
name|tty
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|tty
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|->
name|dev
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rp_num_ports
index|[
name|unit
index|]
operator|*
literal|6
condition|;
name|i
operator|++
control|)
name|destroy_dev
argument_list|(
name|ctlp
operator|->
name|dev_nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctlp
operator|->
name|dev_nodes
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|dev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|rpopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|port
decl_stmt|,
name|mynor
decl_stmt|,
name|umynor
decl_stmt|,
name|flags
decl_stmt|;
comment|/* SG */
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|error
decl_stmt|;
name|unsigned
name|int
name|IntMask
decl_stmt|,
name|ChanStatus
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
if|if
condition|(
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
comment|/*	rp->rp_tty =&rp_tty[rp->rp_port]; */
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|dev
operator|->
name|si_tty
operator|=
name|tp
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|open_top
label|:
while|while
condition|(
name|rp
operator|->
name|state
operator|&
operator|~
name|SET_DTR
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|rp
operator|->
name|dtr_wait
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"rpdtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
if|if
condition|(
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rp
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|rp
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"rpbi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|suser
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
else|else
block|{
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|rpparam
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|rpstart
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|rpstop
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
name|rp
operator|->
name|it_out
else|:
name|rp
operator|->
name|it_in
expr_stmt|;
name|tp
operator|->
name|t_ififosize
operator|=
literal|512
expr_stmt|;
name|tp
operator|->
name|t_ispeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|t_ospeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|SET_RTS
expr_stmt|;
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&
operator|~
operator|(
name|SET_RTS
operator||
name|SET_DTR
operator|)
operator|)
operator||
name|flags
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|sSetRxTrigger
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|TRIG_1
argument_list|)
expr_stmt|;
name|sDisRxStatusMode
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sFlushRxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sFlushTxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnInterrupts
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
operator|(
name|TXINT_EN
operator||
name|MCINT_EN
operator||
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|CHANINT_EN
operator|)
argument_list|)
expr_stmt|;
name|sSetRxTrigger
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|TRIG_1
argument_list|)
expr_stmt|;
name|sDisRxStatusMode
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sClrTxXOFF
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
comment|/*		sDisRTSFlowCtl(&rp->rp_channel); 		sDisCTSFlowCtl(&rp->rp_channel); */
name|sDisTxSoftFlowCtl
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sStartRxProcessor
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnRxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnTransmit
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
comment|/*		sSetDTR(&rp->rp_channel); 		sSetRTS(&rp->rp_channel); */
operator|++
name|rp
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|rpparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|--
name|rp
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rp_num_ports_open
operator|++
expr_stmt|;
name|IntMask
operator|=
name|sGetChanIntID
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|IntMask
operator|=
name|IntMask
operator|&
name|rp
operator|->
name|rp_intmask
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IntMask
operator|&
name|DELTA_CD
operator|)
operator|||
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ChanStatus
operator|&
name|CD_ACT
operator|)
operator|||
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rp_num_ports_open
operator|==
literal|1
condition|)
name|timeout
argument_list|(
name|rp_do_poll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|POLL_INTERVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
operator|++
name|rp
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"rpdcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|rp
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
name|rp
operator|->
name|active_out
operator|=
name|TRUE
expr_stmt|;
comment|/*	if(rp_num_ports_open == 1) 		timeout(rp_do_poll, (void *)NULL, POLL_INTERVAL); */
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|rp
operator|->
name|wopeners
operator|==
literal|0
condition|)
block|{
name|rphardclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|out2
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|device_busy
argument_list|(
name|rp
operator|->
name|rp_ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rpclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|oldspl
decl_stmt|,
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|umynor
decl_stmt|,
name|port
decl_stmt|;
comment|/* SG */
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
comment|/* SG */
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|rpstop
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|rphardclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|device_unbusy
argument_list|(
name|rp
operator|->
name|rp_ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rphardclose
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|mynor
operator|=
name|MINOR_MAGIC
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|sFlushRxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sFlushTxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisInterrupts
argument_list|(
name|cp
argument_list|,
name|TXINT_EN
operator||
name|MCINT_EN
operator||
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|CHANINT_EN
argument_list|)
expr_stmt|;
name|sDisRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisTxSoftFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sClrTxXOFF
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|!
name|rp
operator|->
name|active_out
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_CALLOUT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|dtr_wait
operator|!=
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|rpdtrwakeup
argument_list|,
name|rp
argument_list|,
name|rp
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
name|rp
operator|->
name|state
operator||=
operator|~
name|SET_DTR
expr_stmt|;
block|}
name|rp
operator|->
name|active_out
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rp
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rpwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* SG */
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
comment|/* SG */
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|rp_disable_writes
condition|)
block|{
name|rp
operator|->
name|rp_waiting
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"rp_write"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpdtrwakeup
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|rp_port
operator|*
operator|)
name|chan
expr_stmt|;
name|rp
operator|->
name|state
operator|&=
name|SET_DTR
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rp
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rpioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|int
name|oldspl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|flags
decl_stmt|,
name|result
decl_stmt|,
name|ChanStatus
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|u_long
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
operator|&
name|rp
operator|->
name|it_out
else|:
operator|&
name|rp
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
operator|&
name|rp
operator|->
name|lt_out
else|:
operator|&
name|rp
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
block|{
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|cmd
operator|==
name|TIOCSETA
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAW
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAF
operator|)
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
operator|&
name|rp
operator|->
name|lt_out
else|:
operator|&
name|rp
operator|->
name|lt_in
decl_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
name|t
operator|=
operator|&
name|tp
operator|->
name|t_termios
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|td
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|sSendBreak
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|sClrBreak
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
name|sSetDTR
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sSetRTS
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|sClrDTR
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_RTS
condition|)
name|flags
operator||=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_DTR
condition|)
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&
operator|~
operator|(
name|SET_RTS
operator||
name|SET_DTR
operator|)
operator|)
operator||
name|flags
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_RTS
condition|)
name|flags
operator||=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_DTR
condition|)
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator||=
name|flags
expr_stmt|;
name|rp_writech4
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_RTS
condition|)
name|flags
operator||=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_DTR
condition|)
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&=
operator|~
name|flags
expr_stmt|;
name|rp_writech4
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|_INDX_ADDR
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
name|ChanStatus
operator|=
name|sGetChanStatusLo
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|result
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* always on while open for some reason */
name|result
operator||=
operator|(
operator|(
operator|(
name|flags
operator|&
name|SET_DTR
operator|)
condition|?
name|TIOCM_DTR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|flags
operator|&
name|SET_RTS
operator|)
condition|?
name|TIOCM_RTS
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ChanStatus
operator|&
name|CD_ACT
operator|)
condition|?
name|TIOCM_CAR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ChanStatus
operator|&
name|DSR_ACT
operator|)
condition|?
name|TIOCM_DSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ChanStatus
operator|&
name|CTS_ACT
operator|)
condition|?
name|TIOCM_CTS
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rp_channel
operator|.
name|RxControl
index|[
literal|2
index|]
operator|&
name|RTSFC_EN
condition|)
block|{
name|result
operator||=
name|TIOCM_RTS
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|result
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rp
operator|->
name|dtr_wait
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|rp
operator|->
name|dtr_wait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
default|default:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|baud_table
index|[]
init|=
block|{
block|{
name|B0
block|,
literal|0
block|}
block|,
block|{
name|B50
block|,
name|BRD50
block|}
block|,
block|{
name|B75
block|,
name|BRD75
block|}
block|,
block|{
name|B110
block|,
name|BRD110
block|}
block|,
block|{
name|B134
block|,
name|BRD134
block|}
block|,
block|{
name|B150
block|,
name|BRD150
block|}
block|,
block|{
name|B200
block|,
name|BRD200
block|}
block|,
block|{
name|B300
block|,
name|BRD300
block|}
block|,
block|{
name|B600
block|,
name|BRD600
block|}
block|,
block|{
name|B1200
block|,
name|BRD1200
block|}
block|,
block|{
name|B1800
block|,
name|BRD1800
block|}
block|,
block|{
name|B2400
block|,
name|BRD2400
block|}
block|,
block|{
name|B4800
block|,
name|BRD4800
block|}
block|,
block|{
name|B9600
block|,
name|BRD9600
block|}
block|,
block|{
name|B19200
block|,
name|BRD19200
block|}
block|,
block|{
name|B38400
block|,
name|BRD38400
block|}
block|,
block|{
name|B7200
block|,
name|BRD7200
block|}
block|,
block|{
name|B14400
block|,
name|BRD14400
block|}
block|,
block|{
name|B57600
block|,
name|BRD57600
block|}
block|,
block|{
name|B76800
block|,
name|BRD76800
block|}
block|,
block|{
name|B115200
block|,
name|BRD115200
block|}
block|,
block|{
name|B230400
block|,
name|BRD230400
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rpparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|int
name|oldspl
decl_stmt|,
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|lflag
decl_stmt|;
name|int
name|ospeed
decl_stmt|;
ifdef|#
directive|ifdef
name|RPCLOCAL
name|int
name|devshift
decl_stmt|;
endif|#
directive|endif
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
ifdef|#
directive|ifdef
name|RPCLOCAL
name|devshift
operator|=
name|umynor
operator|/
literal|32
expr_stmt|;
name|devshift
operator|=
literal|1
operator|<<
name|devshift
expr_stmt|;
if|if
condition|(
name|devshift
operator|&
name|RPCLOCAL
condition|)
block|{
name|cflag
operator||=
name|CLOCAL
expr_stmt|;
block|}
endif|#
directive|endif
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|baud_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|iflag
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|oflag
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|lflag
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rp
operator|->
name|rp_fifo_lw
operator|=
operator|(
operator|(
name|t
operator|->
name|c_ospeed
operator|*
literal|2
operator|)
operator|/
literal|1000
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Set baud rate ----- we only pay attention to ispeed */
name|sSetDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sSetRTS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sSetBaud
argument_list|(
name|cp
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
block|{
name|sSetStop2
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sSetStop1
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
name|sEnParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
block|{
name|sSetOddParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sSetEvenParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sDisParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS8
condition|)
block|{
name|sSetData8
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_imask
operator|=
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|sSetData7
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_imask
operator|=
literal|0x7F
expr_stmt|;
block|}
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
block|{
name|rp
operator|->
name|rp_imask
operator|&=
literal|0x7F
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CLOCAL
condition|)
block|{
name|rp
operator|->
name|rp_intmask
operator|&=
operator|~
name|DELTA_CD
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rp_intmask
operator||=
name|DELTA_CD
expr_stmt|;
block|}
comment|/* Put flow control stuff here */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|sEnCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sDisCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|rp
operator|->
name|rp_rts_iflow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rp_rts_iflow
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|sEnRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sDisRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CLOCAL
operator|)
operator|||
operator|(
name|sGetChanStatusLo
argument_list|(
name|cp
argument_list|)
operator|&
name|CD_ACT
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*	tp->t_state |= TS_CAN_BYPASS_L_RINT; 	flags = rp->rp_channel.TxControl[3]; 	if(flags& SET_DTR) 	else 	if(flags& SET_RTS) 	else */
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rp_disc_optim
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpstart
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|clist
modifier|*
name|qp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|char
name|flags
decl_stmt|;
name|int
name|spl
decl_stmt|,
name|xmit_fifo_room
decl_stmt|;
name|int
name|count
decl_stmt|,
name|wcount
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|spl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rp
operator|->
name|rp_xmit_stopped
condition|)
block|{
name|sEnTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_xmit_stopped
operator|=
literal|0
expr_stmt|;
block|}
name|count
operator|=
name|sGetTxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return;
block|}
name|xmit_fifo_room
operator|=
name|TXFIFO_SIZE
operator|-
name|sGetTxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
if|if
condition|(
name|xmit_fifo_room
operator|>
literal|0
operator|&&
name|qp
operator|->
name|c_cc
operator|>
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|count
operator|=
name|q_to_b
argument_list|(
name|qp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|rp
operator|->
name|TxBuf
argument_list|,
name|xmit_fifo_room
argument_list|)
expr_stmt|;
name|wcount
operator|=
name|count
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|wcount
condition|)
block|{
name|rp_writemultich2
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|,
operator|(
name|u_int16_t
operator|*
operator|)
name|rp
operator|->
name|TxBuf
argument_list|,
name|wcount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|1
condition|)
block|{
name|rp_writech1
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|,
name|rp
operator|->
name|TxBuf
index|[
operator|(
name|count
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|rp_restart
operator|=
operator|(
name|qp
operator|->
name|c_cc
operator|>
literal|0
operator|)
condition|?
name|rp
operator|->
name|rp_fifo_lw
else|:
literal|0
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpstop
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|int
name|spl
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|spl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|sFlushTxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|rp_xmit_stopped
operator|==
literal|0
condition|)
block|{
name|sDisTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_xmit_stopped
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|rpstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

