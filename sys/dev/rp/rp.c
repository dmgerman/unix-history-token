begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) Comtrol Corporation<support@comtrol.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted prodived that the follwoing conditions  * are met.  * 1. Redistributions of source code must retain the above copyright   *    notive, this list of conditions and the following disclainer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials prodided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *       This product includes software developed by Comtrol Corporation.  * 4. The name of Comtrol Corporation may not be used to endorse or   *    promote products derived from this software without specific   *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY COMTROL CORPORATION ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL COMTROL CORPORATION BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * rp.c - for RocketPort FreeBSD  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_define
define|#
directive|define
name|ROCKET_C
end_define

begin_include
include|#
directive|include
file|<dev/rp/rpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/rp/rpvar.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|RocketPortVersion
index|[]
init|=
literal|"3.02"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Byte_t
name|RData
index|[
name|RDATASIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|,
literal|0xf6
block|,
literal|0x82
block|,
literal|0x02
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0xfb
block|,
literal|0x04
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x01
block|,
literal|0x0a
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x13
block|,
literal|0x0a
block|,
literal|0x09
block|,
literal|0xc5
block|,
literal|0x11
block|,
literal|0x0c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x85
block|,
literal|0x0e
block|,
literal|0x09
block|,
literal|0x20
block|,
literal|0x0a
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x21
block|,
literal|0x0a
block|,
literal|0x12
block|,
literal|0x09
block|,
literal|0x41
block|,
literal|0xff
block|,
literal|0x14
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x00
block|,
literal|0x16
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7b
block|,
literal|0x18
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x7d
block|,
literal|0x1a
block|,
literal|0x09
block|,
literal|0x88
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x7a
block|,
literal|0x1e
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x81
block|,
literal|0x20
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7c
block|,
literal|0x22
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Byte_t
name|RRegData
index|[
name|RREGDATASIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|,
literal|0xf6
block|,
literal|0x82
block|,
comment|/* 00: Stop Rx processor */
literal|0x08
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x13
block|,
comment|/* 04: Tx software flow control */
literal|0x0a
block|,
literal|0x09
block|,
literal|0xc5
block|,
literal|0x11
block|,
comment|/* 08: XON char */
literal|0x0c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x85
block|,
comment|/* 0c: XANY */
literal|0x12
block|,
literal|0x09
block|,
literal|0x41
block|,
literal|0xff
block|,
comment|/* 10: Rx mask char */
literal|0x14
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x00
block|,
comment|/* 14: Compare/Ignore #0 */
literal|0x16
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7b
block|,
comment|/* 18: Compare #1 */
literal|0x18
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x7d
block|,
comment|/* 1c: Compare #2 */
literal|0x1a
block|,
literal|0x09
block|,
literal|0x88
block|,
literal|0x81
block|,
comment|/* 20: Interrupt #1 */
literal|0x1c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x7a
block|,
comment|/* 24: Ignore/Replace #1 */
literal|0x1e
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x81
block|,
comment|/* 28: Interrupt #2 */
literal|0x20
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7c
block|,
comment|/* 2c: Ignore/Replace #2 */
literal|0x22
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
comment|/* 30: Rx FIFO Enable */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* IRQ number to MUDBAC register 2 mapping */
end_comment

begin_endif
unit|Byte_t sIRQMap[16] = {    0,0,0,0x10,0x20,0x30,0,0,0,0x40,0x50,0x60,0x70,0,0,0x80 };
endif|#
directive|endif
end_endif

begin_decl_stmt
name|Byte_t
name|rp_sBitMapClrTbl
index|[
literal|8
index|]
init|=
block|{
literal|0xfe
block|,
literal|0xfd
block|,
literal|0xfb
block|,
literal|0xf7
block|,
literal|0xef
block|,
literal|0xdf
block|,
literal|0xbf
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Byte_t
name|rp_sBitMapSetTbl
index|[
literal|8
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rpfree
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************************** Function: sReadAiopID Purpose:  Read the AIOP idenfication number directly from an AIOP. Call:	  sReadAiopID(CtlP, aiop) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int aiop: AIOP index Return:   int: Flag AIOPID_XXXX if a valid AIOP is found, where X 		 is replace by an identifying number. 	  Flag AIOPID_NULL if no valid AIOP is found Warnings: No context switches are allowed while executing this function.  */
end_comment

begin_function
name|int
name|sReadAiopID
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|int
name|aiop
parameter_list|)
block|{
name|Byte_t
name|AiopID
decl_stmt|;
comment|/* ID byte from AIOP */
name|rp_writeaiop1
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_CMD_REG
argument_list|,
name|RESET_ALL
argument_list|)
expr_stmt|;
comment|/* reset AIOP */
name|rp_writeaiop1
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_CMD_REG
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|AiopID
operator|=
name|rp_readaiop1
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_CHN_STAT0
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|AiopID
operator|==
literal|0x06
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
comment|/* AIOP does not exist */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sReadAiopNumChan Purpose:  Read the number of channels available in an AIOP directly from 	  an AIOP. Call:	  sReadAiopNumChan(CtlP, aiop) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int aiop: AIOP index Return:   int: The number of channels available Comments: The number of channels is determined by write/reads from identical 	  offsets within the SRAM address spaces for channels 0 and 4. 	  If the channel 4 space is mirrored to channel 0 it is a 4 channel 	  AIOP, otherwise it is an 8 channel. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sReadAiopNumChan
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|int
name|aiop
parameter_list|)
block|{
name|Word_t
name|x
decl_stmt|,
name|y
decl_stmt|;
name|rp_writeaiop4
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_ADDR
argument_list|,
literal|0x12340000L
argument_list|)
expr_stmt|;
comment|/* write to chan 0 SRAM */
name|rp_writeaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read from SRAM, chan 0 */
name|x
operator|=
name|rp_readaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_DATA
argument_list|)
expr_stmt|;
name|rp_writeaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_ADDR
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
comment|/* read from SRAM, chan 4 */
name|y
operator|=
name|rp_readaiop2
argument_list|(
name|CtlP
argument_list|,
name|aiop
argument_list|,
name|_INDX_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|y
condition|)
comment|/* if different must be 8 chan */
return|return
operator|(
literal|8
operator|)
return|;
else|else
return|return
operator|(
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sInitChan Purpose:  Initialization of a channel and channel structure Call:	  sInitChan(CtlP,ChP,AiopNum,ChanNum) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  CHANNEL_T *ChP; Ptr to channel structure 	  int AiopNum; AIOP number within controller 	  int ChanNum; Channel number within AIOP Return:   int: TRUE if initialization succeeded, FALSE if it fails because channel 	       number exceeds number of channels available in AIOP. Comments: This function must be called before a channel can be used. Warnings: No range checking on any of the parameters is done.  	  No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sInitChan
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|int
name|AiopNum
parameter_list|,
name|int
name|ChanNum
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ChOff
decl_stmt|;
name|Byte_t
modifier|*
name|ChR
decl_stmt|;
specifier|static
name|Byte_t
name|R
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|ChanNum
operator|>=
name|CtlP
operator|->
name|AiopNumChan
index|[
name|AiopNum
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* exceeds num chans in AIOP */
comment|/* Channel, AIOP, and controller identifiers */
name|ChP
operator|->
name|CtlP
operator|=
name|CtlP
expr_stmt|;
name|ChP
operator|->
name|ChanID
operator|=
name|CtlP
operator|->
name|AiopID
index|[
name|AiopNum
index|]
expr_stmt|;
name|ChP
operator|->
name|AiopNum
operator|=
name|AiopNum
expr_stmt|;
name|ChP
operator|->
name|ChanNum
operator|=
name|ChanNum
expr_stmt|;
comment|/* Initialize the channel from the RData array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RDATASIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|R
index|[
literal|0
index|]
operator|=
name|RData
index|[
name|i
index|]
expr_stmt|;
name|R
index|[
literal|1
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|0x10
operator|*
name|ChanNum
expr_stmt|;
name|R
index|[
literal|2
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|R
index|[
literal|3
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|R
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ChR
operator|=
name|ChP
operator|->
name|R
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RREGDATASIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ChR
index|[
name|i
index|]
operator|=
name|RRegData
index|[
name|i
index|]
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|0x10
operator|*
name|ChanNum
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
comment|/* Indexed registers */
name|ChOff
operator|=
operator|(
name|Word_t
operator|)
name|ChanNum
operator|*
literal|0x1000
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_BAUD
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_BAUD
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|2
index|]
operator|=
operator|(
name|Byte_t
operator|)
name|BRD9600
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|3
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|BRD9600
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|BaudDiv
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TX_CTRL
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TX_CTRL
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxControl
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_RX_CTRL
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_RX_CTRL
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|RxControl
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TX_ENBLS
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TX_ENBLS
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxEnables
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXCMP1
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXCMP1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxCompare
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXREP1B1
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXREP1B1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxReplace1
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXREP2
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXREP2
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxReplace2
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxFIFOPtrs
operator|=
name|ChOff
operator|+
name|_TXF_OUTP
expr_stmt|;
name|ChP
operator|->
name|TxFIFO
operator|=
name|ChOff
operator|+
name|_TX_FIFO
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
operator||
name|RESTXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Tx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
argument_list|)
expr_stmt|;
comment|/* remove reset Tx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Tx in/out ptrs */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxFIFOPtrs
operator|=
name|ChOff
operator|+
name|_RXF_OUTP
expr_stmt|;
name|ChP
operator|->
name|RxFIFO
operator|=
name|ChOff
operator|+
name|_RX_FIFO
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
operator||
name|RESRXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Rx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
argument_list|)
expr_stmt|;
comment|/* remove reset Rx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Rx out ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* clear Rx in ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioCnt
operator|=
name|ChOff
operator|+
name|_TXP_CNT
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioPtr
operator|=
name|ChOff
operator|+
name|_TXP_PNTR
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxPrioPtr
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioBuf
operator|=
name|ChOff
operator|+
name|_TXP_BUF
expr_stmt|;
name|sEnRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* start the Rx processor */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sStopRxProcessor Purpose:  Stop the receive processor from processing a channel. Call:	  sStopRxProcessor(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure  Comments: The receive processor can be started again with sStartRxProcessor(). 	  This function causes the receive processor to skip over the 	  stopped channel.  It does not stop it from processing other channels.  Warnings: No context switches are allowed while executing this function.  	  Do not leave the receive processor stopped for more than one 	  character time.  	  After calling this function a delay of 4 uS is required to ensure 	  that the receive processor is no longer processing this channel. */
end_comment

begin_function
name|void
name|sStopRxProcessor
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|Byte_t
name|R
index|[
literal|4
index|]
decl_stmt|;
name|R
index|[
literal|0
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|0
index|]
expr_stmt|;
name|R
index|[
literal|1
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|1
index|]
expr_stmt|;
name|R
index|[
literal|2
index|]
operator|=
literal|0x0a
expr_stmt|;
name|R
index|[
literal|3
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|3
index|]
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|R
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sFlushRxFIFO Purpose:  Flush the Rx FIFO Call:	  sFlushRxFIFO(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure Return:   void Comments: To prevent data from being enqueued or dequeued in the Tx FIFO 	  while it is being flushed the receive processor is stopped 	  and the transmitter is disabled.  After these operations a 	  4 uS delay is done before clearing the pointers to allow 	  the receive processor to stop.  These items are handled inside 	  this function. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|void
name|sFlushRxFIFO
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Byte_t
name|Ch
decl_stmt|;
comment|/* channel number within AIOP */
name|int
name|RxFIFOEnabled
decl_stmt|;
comment|/* TRUE if Rx FIFO enabled */
if|if
condition|(
name|sGetRxCnt
argument_list|(
name|ChP
argument_list|)
operator|==
literal|0
condition|)
comment|/* Rx FIFO empty */
return|return;
comment|/* don't need to flush */
name|RxFIFOEnabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ChP
operator|->
name|R
index|[
literal|0x32
index|]
operator|==
literal|0x08
condition|)
comment|/* Rx FIFO is enabled */
block|{
name|RxFIFOEnabled
operator|=
name|TRUE
expr_stmt|;
name|sDisRxFIFO
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* disable it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2000
operator|/
literal|200
condition|;
name|i
operator|++
control|)
comment|/* delay 2 uS to allow proc to disable FIFO*/
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_CHAN
argument_list|)
expr_stmt|;
comment|/* depends on bus i/o timing */
block|}
name|sGetChanStatus
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* clear any pending Rx errors in chan stat */
name|Ch
operator|=
operator|(
name|Byte_t
operator|)
name|sGetChanNum
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
operator||
name|RESRXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Rx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
argument_list|)
expr_stmt|;
comment|/* remove reset Rx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Rx out ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* clear Rx in ptr */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RxFIFOEnabled
condition|)
name|sEnRxFIFO
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* enable Rx FIFO */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sFlushTxFIFO Purpose:  Flush the Tx FIFO Call:	  sFlushTxFIFO(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure Return:   void Comments: To prevent data from being enqueued or dequeued in the Tx FIFO 	  while it is being flushed the receive processor is stopped 	  and the transmitter is disabled.  After these operations a 	  4 uS delay is done before clearing the pointers to allow 	  the receive processor to stop.  These items are handled inside 	  this function. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|void
name|sFlushTxFIFO
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Byte_t
name|Ch
decl_stmt|;
comment|/* channel number within AIOP */
name|int
name|TxEnabled
decl_stmt|;
comment|/* TRUE if transmitter enabled */
if|if
condition|(
name|sGetTxCnt
argument_list|(
name|ChP
argument_list|)
operator|==
literal|0
condition|)
comment|/* Tx FIFO empty */
return|return;
comment|/* don't need to flush */
name|TxEnabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ChP
operator|->
name|TxControl
index|[
literal|3
index|]
operator|&
name|TX_ENABLE
condition|)
block|{
name|TxEnabled
operator|=
name|TRUE
expr_stmt|;
name|sDisTransmit
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* disable transmitter */
block|}
name|sStopRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* stop Rx processor */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4000
operator|/
literal|200
condition|;
name|i
operator|++
control|)
comment|/* delay 4 uS to allow proc to stop */
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_CHAN
argument_list|)
expr_stmt|;
comment|/* depends on bus i/o timing */
name|Ch
operator|=
operator|(
name|Byte_t
operator|)
name|sGetChanNum
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
operator||
name|RESTXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Tx FIFO count */
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_CMD_REG
argument_list|,
name|Ch
argument_list|)
expr_stmt|;
comment|/* remove reset Tx FIFO count */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Tx in/out ptrs */
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TxEnabled
condition|)
name|sEnTransmit
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* enable transmitter */
name|sStartRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* restart Rx processor */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sWriteTxPrioByte Purpose:  Write a byte of priority transmit data to a channel Call:	  sWriteTxPrioByte(ChP,Data) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Byte_t Data; The transmit data byte  Return:   int: 1 if the bytes is successfully written, otherwise 0.  Comments: The priority byte is transmitted before any data in the Tx FIFO.  Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sWriteTxPrioByte
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Byte_t
name|Data
parameter_list|)
block|{
name|Byte_t
name|DWBuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* buffer for double word writes */
if|if
condition|(
name|sGetTxCnt
argument_list|(
name|ChP
argument_list|)
operator|>
literal|1
condition|)
comment|/* write it to Tx priority buffer */
block|{
name|rp_writech2
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
comment|/* get priority buffer status */
if|if
condition|(
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INDX_DATA
argument_list|)
operator|&
name|PRI_PEND
condition|)
comment|/* priority buffer busy */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing sent */
name|le16enc
argument_list|(
name|DWBuf
argument_list|,
name|ChP
operator|->
name|TxPrioBuf
argument_list|)
expr_stmt|;
comment|/* data byte address */
name|DWBuf
index|[
literal|2
index|]
operator|=
name|Data
expr_stmt|;
comment|/* data byte value */
name|DWBuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* priority buffer pointer */
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|DWBuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write it out */
name|le16enc
argument_list|(
name|DWBuf
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
comment|/* Tx priority count address */
name|DWBuf
index|[
literal|2
index|]
operator|=
name|PRI_PEND
operator|+
literal|1
expr_stmt|;
comment|/* indicate 1 byte pending */
name|DWBuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* priority buffer pointer */
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|DWBuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write it out */
block|}
else|else
comment|/* write it to Tx FIFO */
block|{
name|sWriteTxByte
argument_list|(
name|ChP
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|ChP
argument_list|)
argument_list|,
name|Data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 1 byte sent */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sEnInterrupts Purpose:  Enable one or more interrupts for a channel Call:	  sEnInterrupts(ChP,Flags) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Word_t Flags: Interrupt enable flags, can be any combination 	     of the following flags: 		TXINT_EN:   Interrupt on Tx FIFO empty 		RXINT_EN:   Interrupt on Rx FIFO at trigger level (see 			    sSetRxTrigger()) 		SRCINT_EN:  Interrupt on SRC (Special Rx Condition) 		MCINT_EN:   Interrupt on modem input change 		CHANINT_EN: Allow channel interrupt signal to the AIOP's 			    Interrupt Channel Register. Return:   void Comments: If an interrupt enable flag is set in Flags, that interrupt will be 	  enabled.  If an interrupt enable flag is not set in Flags, that 	  interrupt will not be changed.  Interrupts can be disabled with 	  function sDisInterrupts().  	  This function sets the appropriate bit for the channel in the AIOP's 	  Interrupt Mask Register if the CHANINT_EN flag is set.  This allows 	  this channel's bit to be set in the AIOP's Interrupt Channel Register.  	  Interrupts must also be globally enabled before channel interrupts 	  will be passed on to the host.  This is done with function 	  sEnGlobalInt().  	  In some cases it may be desirable to disable interrupts globally but 	  enable channel interrupts.  This would allow the global interrupt 	  status register to be used to determine which AIOPs need service. */
end_comment

begin_function
name|void
name|sEnInterrupts
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Word_t
name|Flags
parameter_list|)
block|{
name|Byte_t
name|Mask
decl_stmt|;
comment|/* Interrupt Mask Register */
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
operator|(
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|MCINT_EN
operator|)
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|RxControl
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
name|TXINT_EN
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxControl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|CHANINT_EN
condition|)
block|{
name|Mask
operator|=
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|)
operator||
name|rp_sBitMapSetTbl
index|[
name|ChP
operator|->
name|ChanNum
index|]
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sDisInterrupts Purpose:  Disable one or more interrupts for a channel Call:	  sDisInterrupts(ChP,Flags) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Word_t Flags: Interrupt flags, can be any combination 	     of the following flags: 		TXINT_EN:   Interrupt on Tx FIFO empty 		RXINT_EN:   Interrupt on Rx FIFO at trigger level (see 			    sSetRxTrigger()) 		SRCINT_EN:  Interrupt on SRC (Special Rx Condition) 		MCINT_EN:   Interrupt on modem input change 		CHANINT_EN: Disable channel interrupt signal to the 			    AIOP's Interrupt Channel Register. Return:   void Comments: If an interrupt flag is set in Flags, that interrupt will be 	  disabled.  If an interrupt flag is not set in Flags, that 	  interrupt will not be changed.  Interrupts can be enabled with 	  function sEnInterrupts().  	  This function clears the appropriate bit for the channel in the AIOP's 	  Interrupt Mask Register if the CHANINT_EN flag is set.  This blocks 	  this channel's bit from being set in the AIOP's Interrupt Channel 	  Register. */
end_comment

begin_function
name|void
name|sDisInterrupts
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Word_t
name|Flags
parameter_list|)
block|{
name|Byte_t
name|Mask
decl_stmt|;
comment|/* Interrupt Mask Register */
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
operator|(
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|MCINT_EN
operator|)
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|RxControl
argument_list|)
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
name|TXINT_EN
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
name|ChP
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|ChP
operator|->
name|TxControl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|CHANINT_EN
condition|)
block|{
name|Mask
operator|=
name|rp_readch1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|)
operator|&
name|rp_sBitMapClrTbl
index|[
name|ChP
operator|->
name|ChanNum
index|]
expr_stmt|;
name|rp_writech1
argument_list|(
name|ChP
argument_list|,
name|_INT_MASK
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************   Begin FreeBsd-specific driver code **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|POLL_INTERVAL
value|(hz / 100)
end_define

begin_define
define|#
directive|define
name|RP_ISMULTIPORT
parameter_list|(
name|dev
parameter_list|)
value|((dev)->id_flags& 0x1)
end_define

begin_define
define|#
directive|define
name|RP_MPMASTER
parameter_list|(
name|dev
parameter_list|)
value|(((dev)->id_flags>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|RP_NOTAST4
parameter_list|(
name|dev
parameter_list|)
value|((dev)->id_flags& 0x04)
end_define

begin_comment
comment|/*  * The top-level routines begin here  */
end_comment

begin_function_decl
specifier|static
name|void
name|rpclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rphardclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpmodem
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpstart
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpioctl
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpopen
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rp_do_receive
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|CHANNEL_t
modifier|*
name|cp
parameter_list|,
name|unsigned
name|int
name|ChanStatus
parameter_list|)
block|{
name|unsigned
name|int
name|CharNStat
decl_stmt|;
name|int
name|ToRecv
decl_stmt|,
name|ch
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|ToRecv
operator|=
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ToRecv
operator|==
literal|0
condition|)
return|return;
comment|/*	If status indicates there are errored characters in the 	FIFO, then enter status mode (a word in FIFO holds 	characters and status) */
if|if
condition|(
name|ChanStatus
operator|&
operator|(
name|RXFOVERFL
operator||
name|RXBREAK
operator||
name|RXFRAME
operator||
name|RXPARITY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ChanStatus
operator|&
name|STATMODE
operator|)
condition|)
block|{
name|ChanStatus
operator||=
name|STATMODE
expr_stmt|;
name|sEnRxStatusMode
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	if we previously entered status mode then read down the 	FIFO one word at a time, pulling apart the character and 	the status. Update error counters depending on status. */
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ChanStatus
operator|&
name|STATMODE
condition|)
block|{
while|while
condition|(
name|ToRecv
condition|)
block|{
name|CharNStat
operator|=
name|rp_readch2
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
name|CharNStat
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|CharNStat
operator|&
name|STMBREAK
operator|)
operator|||
operator|(
name|CharNStat
operator|&
name|STMFRAMEH
operator|)
condition|)
name|err
operator||=
name|TRE_FRAMING
expr_stmt|;
elseif|else
if|if
condition|(
name|CharNStat
operator|&
name|STMPARITYH
condition|)
name|err
operator||=
name|TRE_PARITY
expr_stmt|;
elseif|else
if|if
condition|(
name|CharNStat
operator|&
name|STMRCVROVRH
condition|)
block|{
name|rp
operator|->
name|rp_overflows
operator|++
expr_stmt|;
name|err
operator||=
name|TRE_OVERRUN
expr_stmt|;
block|}
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
name|ch
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ToRecv
operator|--
expr_stmt|;
block|}
comment|/* 	After emtying FIFO in status mode, turn off status mode */
if|if
condition|(
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sDisRxStatusMode
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ToRecv
operator|=
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ToRecv
condition|)
block|{
name|ch
operator|=
name|rp_readch1
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ToRecv
operator|--
expr_stmt|;
block|}
block|}
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rp_handle_port
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|)
block|{
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|IntMask
decl_stmt|,
name|ChanStatus
decl_stmt|;
if|if
condition|(
operator|!
name|rp
condition|)
return|return;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|IntMask
operator|=
name|sGetChanIntID
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|IntMask
operator|=
name|IntMask
operator|&
name|rp
operator|->
name|rp_intmask
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IntMask
operator|&
name|RXF_TRIG
condition|)
name|rp_do_receive
argument_list|(
name|rp
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
name|ChanStatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|IntMask
operator|&
name|DELTA_CD
condition|)
block|{
if|if
condition|(
name|ChanStatus
operator|&
name|CD_ACT
condition|)
block|{
operator|(
name|void
operator|)
name|ttydisc_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ttydisc_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*	oldcts = rp->rp_cts; 	rp->rp_cts = ((ChanStatus& CTS_ACT) != 0); 	if(oldcts != rp->rp_cts) { 		printf("CTS change (now %s)... on port %d\n", rp->rp_cts ? "on" : "off", rp->rp_port); 	} */
block|}
end_function

begin_function
specifier|static
name|void
name|rp_do_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|CONTROLLER_t
modifier|*
name|ctl
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|CtlMask
decl_stmt|,
name|AiopMask
decl_stmt|;
name|rp
operator|=
name|arg
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|rp
operator|->
name|rp_ctlp
expr_stmt|;
name|CtlMask
operator|=
name|ctl
operator|->
name|ctlmask
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|CtlMask
operator|&
operator|(
literal|1
operator|<<
name|rp
operator|->
name|rp_aiop
operator|)
condition|)
block|{
name|AiopMask
operator|=
name|sGetAiopIntStatus
argument_list|(
name|ctl
argument_list|,
name|rp
operator|->
name|rp_aiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|AiopMask
operator|&
operator|(
literal|1
operator|<<
name|rp
operator|->
name|rp_chan
operator|)
condition|)
block|{
name|rp_handle_port
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
name|count
operator|=
name|sGetTxCnt
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|0
operator|&&
operator|(
name|count
operator|<=
name|rp
operator|->
name|rp_restart
operator|)
condition|)
block|{
name|rpstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|callout_schedule
argument_list|(
operator|&
name|rp
operator|->
name|rp_timer
argument_list|,
name|POLL_INTERVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ttydevsw
name|rp_tty_class
init|=
block|{
operator|.
name|tsw_flags
operator|=
name|TF_INITLOCK
operator||
name|TF_CALLOUT
block|,
operator|.
name|tsw_open
operator|=
name|rpopen
block|,
operator|.
name|tsw_close
operator|=
name|rpclose
block|,
operator|.
name|tsw_outwakeup
operator|=
name|rpstart
block|,
operator|.
name|tsw_ioctl
operator|=
name|rpioctl
block|,
operator|.
name|tsw_param
operator|=
name|rpparam
block|,
operator|.
name|tsw_modem
operator|=
name|rpmodem
block|,
operator|.
name|tsw_free
operator|=
name|rpfree
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rpfree
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
init|=
name|softc
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|ctlp
init|=
name|rp
operator|->
name|rp_ctlp
decl_stmt|;
name|atomic_subtract_32
argument_list|(
operator|&
name|ctlp
operator|->
name|free
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rp_attachcommon
parameter_list|(
name|CONTROLLER_T
modifier|*
name|ctlp
parameter_list|,
name|int
name|num_aiops
parameter_list|,
name|int
name|num_ports
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|num_chan
decl_stmt|;
name|int
name|aiop
decl_stmt|,
name|chan
decl_stmt|,
name|port
decl_stmt|;
name|int
name|ChanStatus
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RocketPort%d (Version %s) %d ports.\n"
argument_list|,
name|unit
argument_list|,
name|RocketPortVersion
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
name|ctlp
operator|->
name|rp
operator|=
name|rp
operator|=
operator|(
expr|struct
name|rp_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
literal|"rp_attachcommon: Could not malloc rp_ports structures.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|num_chan
operator|=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|num_chan
condition|;
name|chan
operator|++
operator|,
name|port
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|rp
operator|->
name|rp_tty
operator|=
name|tp
operator|=
name|tty_alloc
argument_list|(
operator|&
name|rp_tty_class
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|rp
operator|->
name|rp_timer
argument_list|,
name|tty_getlock
argument_list|(
name|tp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_port
operator|=
name|port
expr_stmt|;
name|rp
operator|->
name|rp_ctlp
operator|=
name|ctlp
expr_stmt|;
name|rp
operator|->
name|rp_unit
operator|=
name|unit
expr_stmt|;
name|rp
operator|->
name|rp_chan
operator|=
name|chan
expr_stmt|;
name|rp
operator|->
name|rp_aiop
operator|=
name|aiop
expr_stmt|;
name|rp
operator|->
name|rp_intmask
operator|=
name|RXF_TRIG
operator||
name|TXFIFO_MT
operator||
name|SRC_INT
operator||
name|DELTA_CD
operator||
name|DELTA_CTS
operator||
name|DELTA_DSR
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
name|sInitChan
argument_list|(
name|ctlp
argument_list|,
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
literal|"RocketPort sInitChan(%d, %d, %d) failed.\n"
argument_list|,
name|unit
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_cts
operator|=
operator|(
name|ChanStatus
operator|&
name|CTS_ACT
operator|)
operator|!=
literal|0
expr_stmt|;
name|tty_makedev
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|,
literal|"R%r%r"
argument_list|,
name|unit
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_init
argument_list|(
operator|&
name|ctlp
operator|->
name|hwmtx
argument_list|,
literal|"rp_hwmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|hwmtx_init
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
name|rp_releaseresource
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rp_releaseresource
parameter_list|(
name|CONTROLLER_t
modifier|*
name|ctlp
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ctlp
operator|->
name|rp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlp
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|rp
operator|=
name|ctlp
operator|->
name|rp
operator|+
name|i
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|ctlp
operator|->
name|free
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|rp
operator|->
name|rp_tty
argument_list|)
expr_stmt|;
name|tty_rel_gone
argument_list|(
name|rp
operator|->
name|rp_tty
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ctlp
operator|->
name|rp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|rp
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|ctlp
operator|->
name|free
operator|!=
literal|0
condition|)
block|{
name|pause
argument_list|(
literal|"rpwt"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|->
name|hwmtx_init
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|ctlp
operator|->
name|hwmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rpopen
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|IntMask
decl_stmt|,
name|ChanStatus
decl_stmt|;
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|SET_RTS
expr_stmt|;
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&
operator|~
operator|(
name|SET_RTS
operator||
name|SET_DTR
operator|)
operator|)
operator||
name|flags
operator|)
expr_stmt|;
name|rp_writech4
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
argument_list|)
argument_list|)
expr_stmt|;
name|sSetRxTrigger
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|TRIG_1
argument_list|)
expr_stmt|;
name|sDisRxStatusMode
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sFlushRxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sFlushTxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnInterrupts
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
operator|(
name|TXINT_EN
operator||
name|MCINT_EN
operator||
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|CHANINT_EN
operator|)
argument_list|)
expr_stmt|;
name|sSetRxTrigger
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|TRIG_1
argument_list|)
expr_stmt|;
name|sDisRxStatusMode
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sClrTxXOFF
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
comment|/*	sDisRTSFlowCtl(&rp->rp_channel); 	sDisCTSFlowCtl(&rp->rp_channel); */
name|sDisTxSoftFlowCtl
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sStartRxProcessor
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnRxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnTransmit
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
comment|/*	sSetDTR(&rp->rp_channel); 	sSetRTS(&rp->rp_channel); */
name|IntMask
operator|=
name|sGetChanIntID
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|IntMask
operator|=
name|IntMask
operator|&
name|rp
operator|->
name|rp_intmask
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|rp
operator|->
name|rp_timer
argument_list|,
name|POLL_INTERVAL
argument_list|,
name|rp_do_poll
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|device_busy
argument_list|(
name|rp
operator|->
name|rp_ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|rp
operator|->
name|rp_timer
argument_list|)
expr_stmt|;
name|rphardclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|device_unbusy
argument_list|(
name|rp
operator|->
name|rp_ctlp
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rphardclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|sFlushRxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sFlushTxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisInterrupts
argument_list|(
name|cp
argument_list|,
name|TXINT_EN
operator||
name|MCINT_EN
operator||
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|CHANINT_EN
argument_list|)
expr_stmt|;
name|sDisRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisTxSoftFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sClrTxXOFF
argument_list|(
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DJA
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|!
name|tp
operator|->
name|t_actout
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCALLOUT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_actout
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_actout
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DJA */
block|}
end_function

begin_function
specifier|static
name|int
name|rpioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|sSendBreak
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCCBRK
case|:
name|sClrBreak
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
name|ENOIOCTL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rpmodem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sigon
parameter_list|,
name|int
name|sigoff
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigon
operator|!=
literal|0
operator|||
name|sigoff
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sigon
operator|&
name|SER_DTR
condition|)
name|i
operator|=
name|SET_DTR
expr_stmt|;
if|if
condition|(
name|sigoff
operator|&
name|SER_DTR
condition|)
name|j
operator|=
name|SET_DTR
expr_stmt|;
if|if
condition|(
name|sigon
operator|&
name|SER_RTS
condition|)
name|i
operator|=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|sigoff
operator|&
name|SER_RTS
condition|)
name|j
operator|=
name|SET_RTS
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&=
operator|~
name|i
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator||=
name|j
expr_stmt|;
name|rp_writech4
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|_INDX_ADDR
argument_list|,
name|le32dec
argument_list|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|sGetChanStatusLo
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|j
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|SET_DTR
condition|)
name|k
operator||=
name|SER_DTR
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|SET_RTS
condition|)
name|k
operator||=
name|SER_RTS
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|CD_ACT
condition|)
name|k
operator||=
name|SER_DCD
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|DSR_ACT
condition|)
name|k
operator||=
name|SER_DSR
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|CTS_ACT
condition|)
name|k
operator||=
name|SER_CTS
expr_stmt|;
return|return
operator|(
name|k
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|baud
decl_stmt|;
name|int
name|conversion
decl_stmt|;
block|}
name|baud_table
index|[]
init|=
block|{
block|{
name|B0
block|,
literal|0
block|}
block|,
block|{
name|B50
block|,
name|BRD50
block|}
block|,
block|{
name|B75
block|,
name|BRD75
block|}
block|,
block|{
name|B110
block|,
name|BRD110
block|}
block|,
block|{
name|B134
block|,
name|BRD134
block|}
block|,
block|{
name|B150
block|,
name|BRD150
block|}
block|,
block|{
name|B200
block|,
name|BRD200
block|}
block|,
block|{
name|B300
block|,
name|BRD300
block|}
block|,
block|{
name|B600
block|,
name|BRD600
block|}
block|,
block|{
name|B1200
block|,
name|BRD1200
block|}
block|,
block|{
name|B1800
block|,
name|BRD1800
block|}
block|,
block|{
name|B2400
block|,
name|BRD2400
block|}
block|,
block|{
name|B4800
block|,
name|BRD4800
block|}
block|,
block|{
name|B9600
block|,
name|BRD9600
block|}
block|,
block|{
name|B19200
block|,
name|BRD19200
block|}
block|,
block|{
name|B38400
block|,
name|BRD38400
block|}
block|,
block|{
name|B7200
block|,
name|BRD7200
block|}
block|,
block|{
name|B14400
block|,
name|BRD14400
block|}
block|,
block|{
name|B57600
block|,
name|BRD57600
block|}
block|,
block|{
name|B76800
block|,
name|BRD76800
block|}
block|,
block|{
name|B115200
block|,
name|BRD115200
block|}
block|,
block|{
name|B230400
block|,
name|BRD230400
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|rp_convert_baud
parameter_list|(
name|int
name|baud
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|baud_table
index|[
name|i
index|]
operator|.
name|baud
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baud_table
index|[
name|i
index|]
operator|.
name|baud
operator|==
name|baud
condition|)
break|break;
block|}
return|return
name|baud_table
index|[
name|i
index|]
operator|.
name|conversion
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rpparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|int
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|lflag
decl_stmt|;
name|int
name|ospeed
decl_stmt|;
ifdef|#
directive|ifdef
name|RPCLOCAL
name|int
name|devshift
decl_stmt|;
endif|#
directive|endif
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
ifdef|#
directive|ifdef
name|RPCLOCAL
name|devshift
operator|=
name|umynor
operator|/
literal|32
expr_stmt|;
name|devshift
operator|=
literal|1
operator|<<
name|devshift
expr_stmt|;
if|if
condition|(
name|devshift
operator|&
name|RPCLOCAL
condition|)
block|{
name|cflag
operator||=
name|CLOCAL
expr_stmt|;
block|}
endif|#
directive|endif
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|ospeed
operator|=
name|rp_convert_baud
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rp
operator|->
name|rp_fifo_lw
operator|=
operator|(
operator|(
name|t
operator|->
name|c_ospeed
operator|*
literal|2
operator|)
operator|/
literal|1000
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Set baud rate ----- we only pay attention to ispeed */
name|sSetDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sSetRTS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sSetBaud
argument_list|(
name|cp
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
block|{
name|sSetStop2
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sSetStop1
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
name|sEnParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
block|{
name|sSetOddParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sSetEvenParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sDisParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS8
condition|)
block|{
name|sSetData8
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_imask
operator|=
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|sSetData7
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_imask
operator|=
literal|0x7F
expr_stmt|;
block|}
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
block|{
name|rp
operator|->
name|rp_imask
operator|&=
literal|0x7F
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CLOCAL
condition|)
block|{
name|rp
operator|->
name|rp_intmask
operator|&=
operator|~
name|DELTA_CD
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rp_intmask
operator||=
name|DELTA_CD
expr_stmt|;
block|}
comment|/* Put flow control stuff here */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|sEnCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sDisCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|rp
operator|->
name|rp_rts_iflow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rp_rts_iflow
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|sEnRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sDisRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|char
name|flags
decl_stmt|;
name|int
name|xmit_fifo_room
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|wcount
decl_stmt|;
name|rp
operator|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rp_xmit_stopped
condition|)
block|{
name|sEnTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_xmit_stopped
operator|=
literal|0
expr_stmt|;
block|}
name|xmit_fifo_room
operator|=
name|TXFIFO_SIZE
operator|-
name|sGetTxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|count
operator|=
name|ttydisc_getc
argument_list|(
name|tp
argument_list|,
operator|&
name|rp
operator|->
name|TxBuf
argument_list|,
name|xmit_fifo_room
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmit_fifo_room
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|wcount
operator|=
name|count
operator|>>
literal|1
init|;
name|wcount
operator|>
literal|0
condition|;
name|i
operator|+=
literal|2
operator|,
name|wcount
operator|--
control|)
block|{
name|rp_writech2
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|,
name|le16dec
argument_list|(
operator|&
name|rp
operator|->
name|TxBuf
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|&
literal|1
condition|)
block|{
name|rp_writech1
argument_list|(
name|cp
argument_list|,
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|,
name|rp
operator|->
name|TxBuf
index|[
operator|(
name|count
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

