begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) Comtrol Corporation<support@comtrol.com>  * All rights reserved.  *  * ISA-specific part separated from:  * sys/i386/isa/rp.c,v 1.33 1999/09/28 11:45:27 phk Exp  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted prodived that the follwoing conditions  * are met.  * 1. Redistributions of source code must retain the above copyright   *    notive, this list of conditions and the following disclainer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials prodided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *       This product includes software developed by Comtrol Corporation.  * 4. The name of Comtrol Corporation may not be used to endorse or   *    promote products derived from this software without specific   *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY COMTROL CORPORATION ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL COMTROL CORPORATION BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_define
define|#
directive|define
name|ROCKET_C
end_define

begin_include
include|#
directive|include
file|<dev/rp/rpreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/rp/rpvar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_comment
comment|/* ISA-specific part of CONTROLLER_t */
end_comment

begin_struct
struct|struct
name|ISACONTROLLER_T
block|{
name|int
name|MBaseIO
decl_stmt|;
comment|/* rid of the Mudbac controller for this controller */
name|int
name|MReg0IO
decl_stmt|;
comment|/* offset0 of the Mudbac controller for this controller */
name|int
name|MReg1IO
decl_stmt|;
comment|/* offset1 of the Mudbac controller for this controller */
name|int
name|MReg2IO
decl_stmt|;
comment|/* offset2 of the Mudbac controller for this controller */
name|int
name|MReg3IO
decl_stmt|;
comment|/* offset3 of the Mudbac controller for this controller */
name|Byte_t
name|MReg2
decl_stmt|;
name|Byte_t
name|MReg3
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ISACONTROLLER_T
name|ISACONTROLLER_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ISACTL
parameter_list|(
name|ctlp
parameter_list|)
value|((ISACONTROLLER_t *)((ctlp)->bus_ctlp))
end_define

begin_comment
comment|/*************************************************************************** Function: sControllerEOI Purpose:  Strobe the MUDBAC's End Of Interrupt bit. Call:	  sControllerEOI(MudbacCtlP,CtlP) 	  CONTROLLER_T *MudbacCtlP; Ptr to Mudbac controller structure 	  CONTROLLER_T *CtlP; Ptr to controller structure */
end_comment

begin_define
define|#
directive|define
name|sControllerEOI
parameter_list|(
name|MudbacCtlP
parameter_list|,
name|CtlP
parameter_list|)
define|\
value|rp_writeio1(MudbacCtlP,ISACTL(CtlP)->MBaseIO,ISACTL(CtlP)->MReg2IO,ISACTL(CtlP)->MReg2 | INT_STROB)
end_define

begin_comment
comment|/*************************************************************************** Function: sDisAiop Purpose:  Disable I/O access to an AIOP Call:	  sDisAiop(MudbacCtlP,CtlP) 	  CONTROLLER_T *MudbacCtlP; Ptr to Mudbac controller structure 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int AiopNum; Number of AIOP on controller */
end_comment

begin_define
define|#
directive|define
name|sDisAiop
parameter_list|(
name|MudbacCtlP
parameter_list|,
name|CtlP
parameter_list|,
name|AIOPNUM
parameter_list|)
define|\
value|{ \    ISACTL(CtlP)->MReg3&= rp_sBitMapClrTbl[AIOPNUM]; \    rp_writeio1(MudbacCtlP,ISACTL(CtlP)->MBaseIO,ISACTL(CtlP)->MReg3IO,ISACTL(CtlP)->MReg3); \ }
end_define

begin_comment
comment|/*************************************************************************** Function: sEnAiop Purpose:  Enable I/O access to an AIOP Call:	  sEnAiop(MudbacCtlP,CtlP) 	  CONTROLLER_T *MudbacCtlP; Ptr to Mudbac controller structure 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int AiopNum; Number of AIOP on controller */
end_comment

begin_define
define|#
directive|define
name|sEnAiop
parameter_list|(
name|MudbacCtlP
parameter_list|,
name|CtlP
parameter_list|,
name|AIOPNUM
parameter_list|)
define|\
value|{ \    ISACTL(CtlP)->MReg3 |= rp_sBitMapSetTbl[AIOPNUM]; \    rp_writeio1(MudbacCtlP,ISACTL(CtlP)->MBaseIO,ISACTL(CtlP)->MReg3IO,ISACTL(CtlP)->MReg3); \ }
end_define

begin_comment
comment|/*************************************************************************** Function: sGetControllerIntStatus Purpose:  Get the controller interrupt status Call:	  sGetControllerIntStatus(MudbacCtlP,CtlP) 	  CONTROLLER_T *MudbacCtlP; Ptr to Mudbac controller structure 	  CONTROLLER_T *CtlP; Ptr to controller structure Return:   Byte_t: The controller interrupt status in the lower 4 			 bits.	Bits 0 through 3 represent AIOP's 0 			 through 3 respectively.  If a bit is set that 			 AIOP is interrupting.	Bits 4 through 7 will 			 always be cleared. */
end_comment

begin_define
define|#
directive|define
name|sGetControllerIntStatus
parameter_list|(
name|MudbacCtlP
parameter_list|,
name|CtlP
parameter_list|)
define|\
value|(rp_readio1(MudbacCtlP,ISACTL(CtlP)->MBaseIO,ISACTL(CtlP)->MReg1IO)& 0x0f)
end_define

begin_decl_stmt
specifier|static
name|devclass_t
name|rp_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CONTROLLER_t
modifier|*
name|rp_controller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rp_nisadevs
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|rp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rp_isareleaseresource
parameter_list|(
name|CONTROLLER_t
modifier|*
name|ctlp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sInitController
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|CONTROLLER_T
modifier|*
name|MudbacCtlP
parameter_list|,
name|int
name|AiopNum
parameter_list|,
name|int
name|IRQNum
parameter_list|,
name|Byte_t
name|Frequency
parameter_list|,
name|int
name|PeriodicOnly
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|rp_aiop2rid_t
name|rp_isa_aiop2rid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rp_aiop2off_t
name|rp_isa_aiop2off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rp_ctlmask_t
name|rp_isa_ctlmask
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|controller
decl_stmt|;
name|int
name|num_aiops
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|ctlp
decl_stmt|;
name|int
name|retval
decl_stmt|;
comment|/* 	 * We have no PnP RocketPort cards. 	 * (At least according to LINT) 	 */
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* We need IO port resource to configure an ISA device. */
if|if
condition|(
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rpprobe: unit number %d invalid.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"probing for RocketPort(ISA) unit %d.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ctlp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ctlp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctlp
argument_list|)
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ctlp
operator|->
name|aiop2rid
operator|=
name|rp_isa_aiop2rid
expr_stmt|;
name|ctlp
operator|->
name|aiop2off
operator|=
name|rp_isa_aiop2off
expr_stmt|;
name|ctlp
operator|->
name|ctlmask
operator|=
name|rp_isa_ctlmask
expr_stmt|;
comment|/* The IO ports of AIOPs for an ISA controller are discrete. */
name|ctlp
operator|->
name|io_num
operator|=
literal|1
expr_stmt|;
name|ctlp
operator|->
name|io_rid
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ctlp
operator|->
name|io_rid
operator|)
argument_list|)
operator|*
name|MAX_AIOPS_PER_BOARD
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|io
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ctlp
operator|->
name|io
operator|)
argument_list|)
operator|*
name|MAX_AIOPS_PER_BOARD
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlp
operator|->
name|io_rid
operator|==
name|NULL
operator|||
name|ctlp
operator|->
name|io
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rp_attach: Out of memory.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|bzero
argument_list|(
name|ctlp
operator|->
name|io_rid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ctlp
operator|->
name|io_rid
operator|)
argument_list|)
operator|*
name|MAX_AIOPS_PER_BOARD
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ctlp
operator|->
name|io
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|ctlp
operator|->
name|io
operator|)
argument_list|)
operator|*
name|MAX_AIOPS_PER_BOARD
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|bus_ctlp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ISACONTROLLER_t
argument_list|)
operator|*
literal|1
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlp
operator|->
name|bus_ctlp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rp_attach: Out of memory.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|bzero
argument_list|(
name|ctlp
operator|->
name|bus_ctlp
argument_list|,
sizeof|sizeof
argument_list|(
name|ISACONTROLLER_t
argument_list|)
operator|*
literal|1
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|io_rid
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rp_controller
operator|!=
name|NULL
condition|)
block|{
name|controller
operator|=
name|rp_controller
expr_stmt|;
name|ctlp
operator|->
name|io
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|ctlp
operator|->
name|io_rid
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0x40
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|controller
operator|=
name|rp_controller
operator|=
name|ctlp
expr_stmt|;
name|ctlp
operator|->
name|io
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|ctlp
operator|->
name|io_rid
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0x44
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|->
name|io
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"rp_attach: Resource not available.\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
name|num_aiops
operator|=
name|sInitController
argument_list|(
name|ctlp
argument_list|,
name|controller
argument_list|,
name|MAX_AIOPS_PER_BOARD
argument_list|,
literal|0
argument_list|,
name|FREQ_DIS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_aiops
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"board%d init failed.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|retval
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
if|if
condition|(
name|rp_controller
operator|==
name|NULL
condition|)
name|rp_controller
operator|=
name|controller
expr_stmt|;
name|rp_nisadevs
operator|++
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"RocketPort ISA"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
name|rp_isareleaseresource
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|num_ports
decl_stmt|,
name|num_aiops
decl_stmt|;
name|int
name|aiop
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|ctlp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ctlp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|#
directive|if
name|notdef
name|num_aiops
operator|=
name|sInitController
argument_list|(
name|ctlp
argument_list|,
name|rp_controller
argument_list|,
name|MAX_AIOPS_PER_BOARD
argument_list|,
literal|0
argument_list|,
name|FREQ_DIS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|num_aiops
operator|=
name|ctlp
operator|->
name|NumAiop
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
name|num_ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|sResetAiopByNum
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|sEnAiop
argument_list|(
name|rp_controller
argument_list|,
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|num_ports
operator|+=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|rp_attachcommon
argument_list|(
name|ctlp
argument_list|,
name|num_aiops
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
goto|goto
name|nogo
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|nogo
label|:
name|rp_isareleaseresource
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rp_isareleaseresource
parameter_list|(
name|CONTROLLER_t
modifier|*
name|ctlp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rp_releaseresource
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlp
operator|==
name|rp_controller
condition|)
name|rp_controller
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctlp
operator|->
name|io
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_AIOPS_PER_BOARD
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ctlp
operator|->
name|io
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|ctlp
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ctlp
operator|->
name|io_rid
index|[
name|i
index|]
argument_list|,
name|ctlp
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctlp
operator|->
name|io
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|->
name|io_rid
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctlp
operator|->
name|io_rid
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_controller
operator|!=
name|NULL
operator|&&
name|rp_controller
operator|->
name|io
index|[
name|ISACTL
argument_list|(
name|ctlp
argument_list|)
operator|->
name|MBaseIO
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|rp_controller
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rp_controller
operator|->
name|io_rid
index|[
name|ISACTL
argument_list|(
name|ctlp
argument_list|)
operator|->
name|MBaseIO
index|]
argument_list|,
name|rp_controller
operator|->
name|io
index|[
name|ISACTL
argument_list|(
name|ctlp
argument_list|)
operator|->
name|MBaseIO
index|]
argument_list|)
expr_stmt|;
name|rp_controller
operator|->
name|io
index|[
name|ISACTL
argument_list|(
name|ctlp
argument_list|)
operator|->
name|MBaseIO
index|]
operator|=
name|NULL
expr_stmt|;
name|rp_controller
operator|->
name|io_rid
index|[
name|ISACTL
argument_list|(
name|ctlp
argument_list|)
operator|->
name|MBaseIO
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ctlp
operator|->
name|bus_ctlp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctlp
operator|->
name|bus_ctlp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sInitController Purpose:  Initialization of controller global registers and controller 	  structure. Call:	  sInitController(CtlP,MudbacCtlP,AiopNum, 			  IRQNum,Frequency,PeriodicOnly) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  CONTROLLER_T *MudbacCtlP; Ptr to Mudbac controller structure 	  int AiopNum; Number of Aiops 	  int IRQNum; Interrupt Request number.  Can be any of the following: 			 0: Disable global interrupts 			 3: IRQ 3 			 4: IRQ 4 			 5: IRQ 5 			 9: IRQ 9 			 10: IRQ 10 			 11: IRQ 11 			 12: IRQ 12 			 15: IRQ 15 	  Byte_t Frequency: A flag identifying the frequency 		   of the periodic interrupt, can be any one of the following: 		      FREQ_DIS - periodic interrupt disabled 		      FREQ_137HZ - 137 Hertz 		      FREQ_69HZ - 69 Hertz 		      FREQ_34HZ - 34 Hertz 		      FREQ_17HZ - 17 Hertz 		      FREQ_9HZ - 9 Hertz 		      FREQ_4HZ - 4 Hertz 		   If IRQNum is set to 0 the Frequency parameter is 		   overidden, it is forced to a value of FREQ_DIS. 	  int PeriodicOnly: TRUE if all interrupts except the periodic 			       interrupt are to be blocked. 			    FALSE is both the periodic interrupt and 			       other channel interrupts are allowed. 			    If IRQNum is set to 0 the PeriodicOnly parameter is 			       overidden, it is forced to a value of FALSE. Return:   int: Number of AIOPs on the controller, or CTLID_NULL if controller 	       initialization failed.  Comments: 	  If periodic interrupts are to be disabled but AIOP interrupts 	  are allowed, set Frequency to FREQ_DIS and PeriodicOnly to FALSE.  	  If interrupts are to be completely disabled set IRQNum to 0.  	  Setting Frequency to FREQ_DIS and PeriodicOnly to TRUE is an 	  invalid combination.  	  This function performs initialization of global interrupt modes, 	  but it does not actually enable global interrupts.  To enable 	  and disable global interrupts use functions sEnGlobalInt() and 	  sDisGlobalInt().  Enabling of global interrupts is normally not 	  done until all other initializations are complete.  	  Even if interrupts are globally enabled, they must also be 	  individually enabled for each channel that is to generate 	  interrupts.  Warnings: No range checking on any of the parameters is done.  	  No context switches are allowed while executing this function.  	  After this function all AIOPs on the controller are disabled, 	  they can be enabled with sEnAiop(). */
end_comment

begin_function
specifier|static
name|int
name|sInitController
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|CONTROLLER_T
modifier|*
name|MudbacCtlP
parameter_list|,
name|int
name|AiopNum
parameter_list|,
name|int
name|IRQNum
parameter_list|,
name|Byte_t
name|Frequency
parameter_list|,
name|int
name|PeriodicOnly
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ctl_base
decl_stmt|,
name|aiop_base
decl_stmt|,
name|aiop_size
decl_stmt|;
name|CtlP
operator|->
name|CtlID
operator|=
name|CTLID_0001
expr_stmt|;
comment|/* controller release 1 */
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
operator|=
name|rp_nisadevs
expr_stmt|;
if|if
condition|(
name|MudbacCtlP
operator|->
name|io
index|[
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
index|]
operator|!=
name|NULL
condition|)
block|{
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg0IO
operator|=
literal|0x40
operator|+
literal|0
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg1IO
operator|=
literal|0x40
operator|+
literal|1
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2IO
operator|=
literal|0x40
operator|+
literal|2
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3IO
operator|=
literal|0x40
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
name|MudbacCtlP
operator|->
name|io_rid
index|[
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
index|]
operator|=
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
expr_stmt|;
name|ctl_base
operator|=
name|rman_get_start
argument_list|(
name|MudbacCtlP
operator|->
name|io
index|[
literal|0
index|]
argument_list|)
operator|+
literal|0x40
operator|+
literal|0x400
operator|*
name|rp_nisadevs
expr_stmt|;
name|MudbacCtlP
operator|->
name|io
index|[
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|MudbacCtlP
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|CtlP
operator|->
name|io_rid
index|[
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
index|]
argument_list|,
name|ctl_base
argument_list|,
name|ctl_base
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg0IO
operator|=
literal|0
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg1IO
operator|=
literal|1
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2IO
operator|=
literal|2
expr_stmt|;
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3IO
operator|=
literal|3
expr_stmt|;
block|}
if|#
directive|if
literal|1
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2
operator|=
literal|0
expr_stmt|;
comment|/* interrupt disable */
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3
operator|=
literal|0
expr_stmt|;
comment|/* no periodic interrupts */
else|#
directive|else
if|if
condition|(
name|sIRQMap
index|[
name|IRQNum
index|]
operator|==
literal|0
condition|)
comment|/* interrupts globally disabled */
block|{
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2
operator|=
literal|0
expr_stmt|;
comment|/* interrupt disable */
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3
operator|=
literal|0
expr_stmt|;
comment|/* no periodic interrupts */
block|}
else|else
block|{
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2
operator|=
name|sIRQMap
index|[
name|IRQNum
index|]
expr_stmt|;
comment|/* set IRQ number */
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3
operator|=
name|Frequency
expr_stmt|;
comment|/* set frequency */
if|if
condition|(
name|PeriodicOnly
condition|)
comment|/* periodic interrupt only */
block|{
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3
operator||=
name|PERIODIC_ONLY
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|rp_writeio1
argument_list|(
name|MudbacCtlP
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2IO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2
argument_list|)
expr_stmt|;
name|rp_writeio1
argument_list|(
name|MudbacCtlP
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3IO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg3
argument_list|)
expr_stmt|;
name|sControllerEOI
argument_list|(
name|MudbacCtlP
argument_list|,
name|CtlP
argument_list|)
expr_stmt|;
comment|/* clear EOI if warm init */
comment|/* Init AIOPs */
name|CtlP
operator|->
name|NumAiop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AiopNum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CtlP
operator|->
name|io
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|CtlP
operator|->
name|io_rid
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|aiop_base
operator|=
name|rman_get_start
argument_list|(
name|CtlP
operator|->
name|io
index|[
literal|0
index|]
argument_list|)
operator|+
literal|0x400
operator|*
name|i
expr_stmt|;
if|if
condition|(
name|rp_nisadevs
operator|==
literal|0
condition|)
name|aiop_size
operator|=
literal|0x44
expr_stmt|;
else|else
name|aiop_size
operator|=
literal|0x40
expr_stmt|;
name|CtlP
operator|->
name|io
index|[
name|i
index|]
operator|=
name|bus_alloc_resource
argument_list|(
name|CtlP
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|CtlP
operator|->
name|io_rid
index|[
name|i
index|]
argument_list|,
name|aiop_base
argument_list|,
name|aiop_base
operator|+
name|aiop_size
operator|-
literal|1
argument_list|,
name|aiop_size
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
name|aiop_base
operator|=
name|rman_get_start
argument_list|(
name|CtlP
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rp_writeio1
argument_list|(
name|MudbacCtlP
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2IO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg2
operator||
operator|(
name|i
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
comment|/* AIOP index */
name|rp_writeio1
argument_list|(
name|MudbacCtlP
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MBaseIO
argument_list|,
name|ISACTL
argument_list|(
name|CtlP
argument_list|)
operator|->
name|MReg0IO
argument_list|,
call|(
name|Byte_t
call|)
argument_list|(
name|aiop_base
operator|>>
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up AIOP I/O in MUDBAC */
name|sEnAiop
argument_list|(
name|MudbacCtlP
argument_list|,
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* enable the AIOP */
name|CtlP
operator|->
name|AiopID
index|[
name|i
index|]
operator|=
name|sReadAiopID
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* read AIOP ID */
if|if
condition|(
name|CtlP
operator|->
name|AiopID
index|[
name|i
index|]
operator|==
name|AIOPID_NULL
condition|)
comment|/* if AIOP does not exist */
block|{
name|sDisAiop
argument_list|(
name|MudbacCtlP
argument_list|,
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* disable AIOP */
name|bus_release_resource
argument_list|(
name|CtlP
operator|->
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|CtlP
operator|->
name|io_rid
index|[
name|i
index|]
argument_list|,
name|CtlP
operator|->
name|io
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CtlP
operator|->
name|io
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
comment|/* done looking for AIOPs */
block|}
name|CtlP
operator|->
name|AiopNumChan
index|[
name|i
index|]
operator|=
name|sReadAiopNumChan
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* num channels in AIOP */
name|rp_writeaiop2
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|,
name|_INDX_ADDR
argument_list|,
name|_CLK_PRE
argument_list|)
expr_stmt|;
comment|/* clock prescaler */
name|rp_writeaiop1
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|,
name|_INDX_DATA
argument_list|,
name|CLOCK_PRESC
argument_list|)
expr_stmt|;
name|CtlP
operator|->
name|NumAiop
operator|++
expr_stmt|;
comment|/* bump count of AIOPs */
name|sDisAiop
argument_list|(
name|MudbacCtlP
argument_list|,
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* disable AIOP */
block|}
if|if
condition|(
name|CtlP
operator|->
name|NumAiop
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|CtlP
operator|->
name|NumAiop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ARGSUSED  * Maps (aiop, offset) to rid.  */
end_comment

begin_function
specifier|static
name|int
name|rp_isa_aiop2rid
parameter_list|(
name|int
name|aiop
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|/* rid equals to aiop for an ISA controller. */
return|return
name|aiop
return|;
block|}
end_function

begin_comment
comment|/*  * ARGSUSED  * Maps (aiop, offset) to the offset of resource.  */
end_comment

begin_function
specifier|static
name|int
name|rp_isa_aiop2off
parameter_list|(
name|int
name|aiop
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|/* Each aiop has its own resource. */
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Read the int status for an ISA controller. */
end_comment

begin_function
name|unsigned
name|char
name|rp_isa_ctlmask
parameter_list|(
name|CONTROLLER_t
modifier|*
name|ctlp
parameter_list|)
block|{
return|return
name|sGetControllerIntStatus
argument_list|(
name|rp_controller
argument_list|,
name|ctlp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|rp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|rp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|rp_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|rp_driver
init|=
block|{
literal|"rp"
block|,
name|rp_methods
block|,
sizeof|sizeof
argument_list|(
name|CONTROLLER_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * rp can be attached to an isa bus.  */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|rp
argument_list|,
name|isa
argument_list|,
name|rp_driver
argument_list|,
name|rp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

