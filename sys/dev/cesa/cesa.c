begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2009-2011 Semihalf.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * CESA SRAM Memory Map:  *  * +------------------------+<= sc->sc_sram_base_va + CESA_SRAM_SIZE  * |                        |  * |          DATA          |  * |                        |  * +------------------------+<= sc->sc_sram_base_va + CESA_DATA(0)  * |  struct cesa_sa_data   |  * +------------------------+  * |  struct cesa_sa_hdesc  |  * +------------------------+<= sc->sc_sram_base_va  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/fdt.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha1.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha2/sha256.h>
end_include

begin_include
include|#
directive|include
file|<crypto/rijndael/rijndael.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|"cryptodev_if.h"
end_include

begin_include
include|#
directive|include
file|<arm/mv/mvreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/mv/mvvar.h>
end_include

begin_include
include|#
directive|include
file|"cesa.h"
end_include

begin_function_decl
specifier|static
name|int
name|cesa_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cesa_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cesa_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cesa_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cesa_newsession
parameter_list|(
name|device_t
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|,
name|struct
name|cryptoini
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cesa_freesession
parameter_list|(
name|device_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cesa_process
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|cryptop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|cesa_res_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|cesa_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cesa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cesa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cesa_detach
argument_list|)
block|,
comment|/* Crypto device methods */
name|DEVMETHOD
argument_list|(
name|cryptodev_newsession
argument_list|,
name|cesa_newsession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_freesession
argument_list|,
name|cesa_freesession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_process
argument_list|,
name|cesa_process
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cesa_driver
init|=
block|{
literal|"cesa"
block|,
name|cesa_methods
block|,
expr|sizeof
operator|(
expr|struct
name|cesa_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|cesa_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cesa
argument_list|,
name|simplebus
argument_list|,
name|cesa_driver
argument_list|,
name|cesa_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cesa
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cesa_dump_cshd
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_sa_hdesc
modifier|*
name|cshd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|sc_dev
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CESA SA Hardware Descriptor:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tconfig: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_config
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\te_src:  0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_enc_src
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\te_dst:  0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_enc_dst
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\te_dlen: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_enc_dlen
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\te_key:  0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_enc_key
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\te_iv_1: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_enc_iv
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\te_iv_2: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_enc_iv_buf
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tm_src:  0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_mac_src
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tm_dst:  0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_mac_dst
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tm_dlen: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_mac_dlen
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tm_tlen: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_mac_total_dlen
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tm_iv_i: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_mac_iv_in
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"\t\tm_iv_o: 0x%08X\n"
argument_list|,
name|cshd
operator|->
name|cshd_mac_iv_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_alloc_dma_mem_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|cesa_dma_mem
modifier|*
name|cdm
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"Got wrong number of DMA segments, should be 1."
operator|)
argument_list|)
expr_stmt|;
name|cdm
operator|=
name|arg
expr_stmt|;
name|cdm
operator|->
name|cdm_paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_alloc_dma_mem
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_dma_mem
modifier|*
name|cdm
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|cdm
operator|->
name|cdm_vaddr
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s(): DMA memory descriptor in use."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
comment|/* parent */
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|size
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegments */
name|size
argument_list|,
literal|0
argument_list|,
comment|/* maxsegsz, flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|cdm
operator|->
name|cdm_tag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate busdma tag, error"
literal|" %i!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|,
operator|&
name|cdm
operator|->
name|cdm_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|cdm
operator|->
name|cdm_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"failed to allocate DMA safe"
literal|" memory, error %i!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|,
name|cdm
operator|->
name|cdm_map
argument_list|,
name|cdm
operator|->
name|cdm_vaddr
argument_list|,
name|size
argument_list|,
name|cesa_alloc_dma_mem_cb
argument_list|,
name|cdm
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot get address of the DMA"
literal|" memory, error %i\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err3
label|:
name|bus_dmamem_free
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|,
name|cdm
operator|->
name|cdm_vaddr
argument_list|,
name|cdm
operator|->
name|cdm_map
argument_list|)
expr_stmt|;
name|err2
label|:
name|bus_dma_tag_destroy
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|)
expr_stmt|;
name|err1
label|:
name|cdm
operator|->
name|cdm_vaddr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_free_dma_mem
parameter_list|(
name|struct
name|cesa_dma_mem
modifier|*
name|cdm
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|,
name|cdm
operator|->
name|cdm_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|,
name|cdm
operator|->
name|cdm_vaddr
argument_list|,
name|cdm
operator|->
name|cdm_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|cdm_vaddr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_sync_dma_mem
parameter_list|(
name|struct
name|cesa_dma_mem
modifier|*
name|cdm
parameter_list|,
name|bus_dmasync_op_t
name|op
parameter_list|)
block|{
comment|/* Sync only if dma memory is valid */
if|if
condition|(
name|cdm
operator|->
name|cdm_vaddr
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|cdm
operator|->
name|cdm_tag
argument_list|,
name|cdm
operator|->
name|cdm_map
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_sync_desc
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|bus_dmasync_op_t
name|op
parameter_list|)
block|{
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_cdm
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_sdesc_cdm
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_cdm
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_session
modifier|*
name|cesa_alloc_session
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cesa_session
modifier|*
name|cs
decl_stmt|;
name|CESA_GENERIC_ALLOC_LOCKED
argument_list|(
name|sc
argument_list|,
name|cs
argument_list|,
name|sessions
argument_list|)
expr_stmt|;
return|return
operator|(
name|cs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_session
modifier|*
name|cesa_get_session
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|sid
parameter_list|)
block|{
if|if
condition|(
name|sid
operator|>=
name|CESA_SESSIONS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sid
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_free_session
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_session
modifier|*
name|cs
parameter_list|)
block|{
name|CESA_GENERIC_FREE_LOCKED
argument_list|(
name|sc
argument_list|,
name|cs
argument_list|,
name|sessions
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_request
modifier|*
name|cesa_alloc_request
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cesa_request
modifier|*
name|cr
decl_stmt|;
name|CESA_GENERIC_ALLOC_LOCKED
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|requests
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cr
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cr
operator|->
name|cr_sdesc
argument_list|)
expr_stmt|;
return|return
operator|(
name|cr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_free_request
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|)
block|{
comment|/* Free TDMA descriptors assigned to this request */
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|tdesc
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_tdesc
argument_list|,
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|)
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|tdesc
argument_list|)
expr_stmt|;
comment|/* Free SA descriptors assigned to this request */
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|sdesc
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_sdesc
argument_list|,
operator|&
name|cr
operator|->
name|cr_sdesc
argument_list|)
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|sdesc
argument_list|)
expr_stmt|;
comment|/* Unload DMA memory associated with request */
if|if
condition|(
name|cr
operator|->
name|cr_dmap_loaded
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|cr
operator|->
name|cr_dmap
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_dmap_loaded
operator|=
literal|0
expr_stmt|;
block|}
name|CESA_GENERIC_FREE_LOCKED
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
name|requests
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_enqueue_request
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|)
block|{
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_ready_requests
argument_list|,
name|cr
argument_list|,
name|cr_stq
argument_list|)
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_tdma_desc
modifier|*
name|cesa_alloc_tdesc
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd
decl_stmt|;
name|CESA_GENERIC_ALLOC_LOCKED
argument_list|(
name|sc
argument_list|,
name|ctd
argument_list|,
name|tdesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TDMA descriptors pool exhaused. "
literal|"Consider increasing CESA_TDMA_DESCRIPTORS.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ctd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_sa_desc
modifier|*
name|cesa_alloc_sdesc
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|cesa_sa_desc
modifier|*
name|csd
decl_stmt|;
name|CESA_GENERIC_ALLOC_LOCKED
argument_list|(
name|sc
argument_list|,
name|csd
argument_list|,
name|sdesc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csd
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SA descriptors pool exhaused. "
literal|"Consider increasing CESA_SA_DESCRIPTORS.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cr
operator|->
name|cr_sdesc
argument_list|,
name|csd
argument_list|,
name|csd_stq
argument_list|)
expr_stmt|;
comment|/* Fill-in SA descriptor with default values */
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_key
operator|=
name|CESA_SA_DATA
argument_list|(
name|csd_key
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_iv
operator|=
name|CESA_SA_DATA
argument_list|(
name|csd_iv
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_iv_buf
operator|=
name|CESA_SA_DATA
argument_list|(
name|csd_iv
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_src
operator|=
literal|0
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_dst
operator|=
literal|0
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_dlen
operator|=
literal|0
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_dst
operator|=
name|CESA_SA_DATA
argument_list|(
name|csd_hash
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_iv_in
operator|=
name|CESA_SA_DATA
argument_list|(
name|csd_hiv_in
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_iv_out
operator|=
name|CESA_SA_DATA
argument_list|(
name|csd_hiv_out
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_src
operator|=
literal|0
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_dlen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|csd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_tdma_desc
modifier|*
name|cesa_tdma_copy
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|bus_addr_t
name|dst
parameter_list|,
name|bus_addr_t
name|src
parameter_list|,
name|bus_size_t
name|size
parameter_list|)
block|{
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd
decl_stmt|;
name|ctd
operator|=
name|cesa_alloc_tdesc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_dst
operator|=
name|dst
expr_stmt|;
name|ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_src
operator|=
name|src
expr_stmt|;
name|ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_byte_count
operator|=
name|size
expr_stmt|;
comment|/* Handle special control packet */
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
name|ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_flags
operator|=
name|CESA_CTHD_OWNED
expr_stmt|;
else|else
name|ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ctd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_tdma_desc
modifier|*
name|cesa_tdma_copyin_sa_data
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|)
block|{
return|return
operator|(
name|cesa_tdma_copy
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_sram_base_pa
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_hdesc
argument_list|)
argument_list|,
name|cr
operator|->
name|cr_csd_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_data
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_tdma_desc
modifier|*
name|cesa_tdma_copyout_sa_data
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|)
block|{
return|return
operator|(
name|cesa_tdma_copy
argument_list|(
name|sc
argument_list|,
name|cr
operator|->
name|cr_csd_paddr
argument_list|,
name|sc
operator|->
name|sc_sram_base_pa
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_hdesc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_data
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cesa_tdma_desc
modifier|*
name|cesa_tdma_copy_sdesc
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_sa_desc
modifier|*
name|csd
parameter_list|)
block|{
return|return
operator|(
name|cesa_tdma_copy
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_sram_base_pa
argument_list|,
name|csd
operator|->
name|csd_cshd_paddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_hdesc
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_append_tdesc
parameter_list|(
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|,
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd
parameter_list|)
block|{
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd_prev
decl_stmt|;
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|)
condition|)
block|{
name|ctd_prev
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|,
name|cesa_tdma_desc
argument_list|,
name|ctd_stq
argument_list|)
expr_stmt|;
name|ctd_prev
operator|->
name|ctd_cthd
operator|->
name|cthd_next
operator|=
name|ctd
operator|->
name|ctd_cthd_paddr
expr_stmt|;
block|}
name|ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_next
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|,
name|ctd
argument_list|,
name|ctd_stq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_append_packet
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|,
name|struct
name|cesa_packet
modifier|*
name|cp
parameter_list|,
name|struct
name|cesa_sa_desc
modifier|*
name|csd
parameter_list|)
block|{
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Copy SA descriptor for this packet */
name|ctd
operator|=
name|cesa_tdma_copy_sdesc
argument_list|(
name|sc
argument_list|,
name|csd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cesa_append_tdesc
argument_list|(
name|cr
argument_list|,
name|ctd
argument_list|)
expr_stmt|;
comment|/* Copy data to be processed */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|ctd
argument_list|,
argument|&cp->cp_copyin
argument_list|,
argument|ctd_stq
argument_list|,
argument|tmp
argument_list|)
name|cesa_append_tdesc
argument_list|(
name|cr
argument_list|,
name|ctd
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cp
operator|->
name|cp_copyin
argument_list|)
expr_stmt|;
comment|/* Insert control descriptor */
name|ctd
operator|=
name|cesa_tdma_copy
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cesa_append_tdesc
argument_list|(
name|cr
argument_list|,
name|ctd
argument_list|)
expr_stmt|;
comment|/* Copy back results */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|ctd
argument_list|,
argument|&cp->cp_copyout
argument_list|,
argument|ctd_stq
argument_list|,
argument|tmp
argument_list|)
name|cesa_append_tdesc
argument_list|(
name|cr
argument_list|,
name|ctd
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cp
operator|->
name|cp_copyout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_set_mkey
parameter_list|(
name|struct
name|cesa_session
modifier|*
name|cs
parameter_list|,
name|int
name|alg
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|mkey
parameter_list|,
name|int
name|mklen
parameter_list|)
block|{
name|uint8_t
name|ipad
index|[
name|CESA_MAX_HMAC_BLOCK_LEN
index|]
decl_stmt|;
name|uint8_t
name|opad
index|[
name|CESA_MAX_HMAC_BLOCK_LEN
index|]
decl_stmt|;
name|SHA1_CTX
name|sha1ctx
decl_stmt|;
name|SHA256_CTX
name|sha256ctx
decl_stmt|;
name|MD5_CTX
name|md5ctx
decl_stmt|;
name|uint32_t
modifier|*
name|hout
decl_stmt|;
name|uint32_t
modifier|*
name|hin
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|ipad
argument_list|,
name|HMAC_IPAD_VAL
argument_list|,
name|CESA_MAX_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|opad
argument_list|,
name|HMAC_OPAD_VAL
argument_list|,
name|CESA_MAX_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mklen
condition|;
name|i
operator|++
control|)
block|{
name|ipad
index|[
name|i
index|]
operator|^=
name|mkey
index|[
name|i
index|]
expr_stmt|;
name|opad
index|[
name|i
index|]
operator|^=
name|mkey
index|[
name|i
index|]
expr_stmt|;
block|}
name|hin
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cs
operator|->
name|cs_hiv_in
expr_stmt|;
name|hout
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cs
operator|->
name|cs_hiv_out
expr_stmt|;
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|CRYPTO_MD5_HMAC
case|:
name|MD5Init
argument_list|(
operator|&
name|md5ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|ipad
argument_list|,
name|MD5_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hin
argument_list|,
name|md5ctx
operator|.
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|md5ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|opad
argument_list|,
name|MD5_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hout
argument_list|,
name|md5ctx
operator|.
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA1_HMAC
case|:
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|ipad
argument_list|,
name|SHA1_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hin
argument_list|,
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|opad
argument_list|,
name|SHA1_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hout
argument_list|,
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
name|SHA256_Init
argument_list|(
operator|&
name|sha256ctx
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|sha256ctx
argument_list|,
name|ipad
argument_list|,
name|SHA2_256_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hin
argument_list|,
name|sha256ctx
operator|.
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|sha256ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Init
argument_list|(
operator|&
name|sha256ctx
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|sha256ctx
argument_list|,
name|opad
argument_list|,
name|SHA2_256_HMAC_BLOCK_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|hout
argument_list|,
name|sha256ctx
operator|.
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|sha256ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_MAX_HASH_LEN
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hin
index|[
name|i
index|]
operator|=
name|htobe32
argument_list|(
name|hin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|hout
index|[
name|i
index|]
operator|=
name|htobe32
argument_list|(
name|hout
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_prep_aes_key
parameter_list|(
name|struct
name|cesa_session
modifier|*
name|cs
parameter_list|)
block|{
name|uint32_t
name|ek
index|[
literal|4
operator|*
operator|(
name|RIJNDAEL_MAXNR
operator|+
literal|1
operator|)
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|dkey
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rijndaelKeySetupEnc
argument_list|(
name|ek
argument_list|,
name|cs
operator|->
name|cs_key
argument_list|,
name|cs
operator|->
name|cs_klen
operator|*
literal|8
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_config
operator|&=
operator|~
name|CESA_CSH_AES_KLEN_MASK
expr_stmt|;
name|dkey
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cs
operator|->
name|cs_aes_dkey
expr_stmt|;
switch|switch
condition|(
name|cs
operator|->
name|cs_klen
condition|)
block|{
case|case
literal|16
case|:
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSH_AES_KLEN_128
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|dkey
operator|++
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|10
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSH_AES_KLEN_192
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|dkey
operator|++
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|12
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
operator|*
name|dkey
operator|++
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|11
operator|+
literal|2
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSH_AES_KLEN_256
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|dkey
operator|++
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|14
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|dkey
operator|++
operator|=
name|htobe32
argument_list|(
name|ek
index|[
literal|4
operator|*
literal|13
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_is_hash
parameter_list|(
name|int
name|alg
parameter_list|)
block|{
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|CRYPTO_MD5
case|:
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_start_packet
parameter_list|(
name|struct
name|cesa_packet
modifier|*
name|cp
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|cp
operator|->
name|cp_size
operator|=
name|size
expr_stmt|;
name|cp
operator|->
name|cp_offset
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cp
operator|->
name|cp_copyin
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|cp
operator|->
name|cp_copyout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_fill_packet
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_packet
modifier|*
name|cp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|)
block|{
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd
decl_stmt|;
name|unsigned
name|int
name|bsize
decl_stmt|;
comment|/* Calculate size of block copy */
name|bsize
operator|=
name|MIN
argument_list|(
name|seg
operator|->
name|ds_len
argument_list|,
name|cp
operator|->
name|cp_size
operator|-
name|cp
operator|->
name|cp_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsize
operator|>
literal|0
condition|)
block|{
name|ctd
operator|=
name|cesa_tdma_copy
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_sram_base_pa
operator|+
name|CESA_DATA
argument_list|(
name|cp
operator|->
name|cp_offset
argument_list|)
argument_list|,
name|seg
operator|->
name|ds_addr
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cp
operator|->
name|cp_copyin
argument_list|,
name|ctd
argument_list|,
name|ctd_stq
argument_list|)
expr_stmt|;
name|ctd
operator|=
name|cesa_tdma_copy
argument_list|(
name|sc
argument_list|,
name|seg
operator|->
name|ds_addr
argument_list|,
name|sc
operator|->
name|sc_sram_base_pa
operator|+
name|CESA_DATA
argument_list|(
name|cp
operator|->
name|cp_offset
argument_list|)
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cp
operator|->
name|cp_copyout
argument_list|,
name|ctd
argument_list|,
name|ctd_stq
argument_list|)
expr_stmt|;
name|seg
operator|->
name|ds_len
operator|-=
name|bsize
expr_stmt|;
name|seg
operator|->
name|ds_addr
operator|+=
name|bsize
expr_stmt|;
name|cp
operator|->
name|cp_offset
operator|+=
name|bsize
expr_stmt|;
block|}
return|return
operator|(
name|bsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_create_chain_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|unsigned
name|int
name|mpsize
decl_stmt|,
name|fragmented
decl_stmt|;
name|unsigned
name|int
name|mlen
decl_stmt|,
name|mskip
decl_stmt|,
name|tmlen
decl_stmt|;
name|struct
name|cesa_chain_info
modifier|*
name|cci
decl_stmt|;
name|unsigned
name|int
name|elen
decl_stmt|,
name|eskip
decl_stmt|;
name|unsigned
name|int
name|skip
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cesa_sa_desc
modifier|*
name|csd
decl_stmt|;
name|struct
name|cesa_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cesa_packet
name|cp
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|uint32_t
name|config
decl_stmt|;
name|int
name|size
decl_stmt|;
name|cci
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|cci
operator|->
name|cci_sc
expr_stmt|;
name|cr
operator|=
name|cci
operator|->
name|cci_cr
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cci
operator|->
name|cci_error
operator|=
name|error
expr_stmt|;
return|return;
block|}
name|elen
operator|=
name|cci
operator|->
name|cci_enc
condition|?
name|cci
operator|->
name|cci_enc
operator|->
name|crd_len
else|:
literal|0
expr_stmt|;
name|eskip
operator|=
name|cci
operator|->
name|cci_enc
condition|?
name|cci
operator|->
name|cci_enc
operator|->
name|crd_skip
else|:
literal|0
expr_stmt|;
name|mlen
operator|=
name|cci
operator|->
name|cci_mac
condition|?
name|cci
operator|->
name|cci_mac
operator|->
name|crd_len
else|:
literal|0
expr_stmt|;
name|mskip
operator|=
name|cci
operator|->
name|cci_mac
condition|?
name|cci
operator|->
name|cci_mac
operator|->
name|crd_skip
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|elen
operator|&&
name|mlen
operator|&&
operator|(
operator|(
name|eskip
operator|>
name|mskip
operator|&&
operator|(
operator|(
name|eskip
operator|-
name|mskip
operator|)
operator|&
operator|(
name|cr
operator|->
name|cr_cs
operator|->
name|cs_ivlen
operator|-
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|mskip
operator|>
name|eskip
operator|&&
operator|(
operator|(
name|mskip
operator|-
name|eskip
operator|)
operator|&
operator|(
name|cr
operator|->
name|cr_cs
operator|->
name|cs_mblen
operator|-
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|eskip
operator|>
operator|(
name|mskip
operator|+
name|mlen
operator|)
operator|)
operator|||
operator|(
name|mskip
operator|>
operator|(
name|eskip
operator|+
name|elen
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Data alignment in the request does not meet CESA requiremnts 		 * for combined encryption/decryption and hashing. We have to 		 * split the request to separate operations and process them 		 * one by one. 		 */
name|config
operator|=
name|cci
operator|->
name|cci_config
expr_stmt|;
if|if
condition|(
operator|(
name|config
operator|&
name|CESA_CSHD_OP_MASK
operator|)
operator|==
name|CESA_CSHD_MAC_AND_ENC
condition|)
block|{
name|config
operator|&=
operator|~
name|CESA_CSHD_OP_MASK
expr_stmt|;
name|cci
operator|->
name|cci_config
operator|=
name|config
operator||
name|CESA_CSHD_MAC
expr_stmt|;
name|cci
operator|->
name|cci_enc
operator|=
name|NULL
expr_stmt|;
name|cci
operator|->
name|cci_mac
operator|=
name|cr
operator|->
name|cr_mac
expr_stmt|;
name|cesa_create_chain_cb
argument_list|(
name|cci
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|cci
operator|->
name|cci_error
argument_list|)
expr_stmt|;
name|cci
operator|->
name|cci_config
operator|=
name|config
operator||
name|CESA_CSHD_ENC
expr_stmt|;
name|cci
operator|->
name|cci_enc
operator|=
name|cr
operator|->
name|cr_enc
expr_stmt|;
name|cci
operator|->
name|cci_mac
operator|=
name|NULL
expr_stmt|;
name|cesa_create_chain_cb
argument_list|(
name|cci
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|cci
operator|->
name|cci_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|config
operator|&=
operator|~
name|CESA_CSHD_OP_MASK
expr_stmt|;
name|cci
operator|->
name|cci_config
operator|=
name|config
operator||
name|CESA_CSHD_ENC
expr_stmt|;
name|cci
operator|->
name|cci_enc
operator|=
name|cr
operator|->
name|cr_enc
expr_stmt|;
name|cci
operator|->
name|cci_mac
operator|=
name|NULL
expr_stmt|;
name|cesa_create_chain_cb
argument_list|(
name|cci
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|cci
operator|->
name|cci_error
argument_list|)
expr_stmt|;
name|cci
operator|->
name|cci_config
operator|=
name|config
operator||
name|CESA_CSHD_MAC
expr_stmt|;
name|cci
operator|->
name|cci_enc
operator|=
name|NULL
expr_stmt|;
name|cci
operator|->
name|cci_mac
operator|=
name|cr
operator|->
name|cr_mac
expr_stmt|;
name|cesa_create_chain_cb
argument_list|(
name|cci
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|cci
operator|->
name|cci_error
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|tmlen
operator|=
name|mlen
expr_stmt|;
name|fragmented
operator|=
literal|0
expr_stmt|;
name|mpsize
operator|=
name|CESA_MAX_PACKET_SIZE
expr_stmt|;
name|mpsize
operator|&=
operator|~
operator|(
operator|(
name|cr
operator|->
name|cr_cs
operator|->
name|cs_ivlen
operator|-
literal|1
operator|)
operator||
operator|(
name|cr
operator|->
name|cr_cs
operator|->
name|cs_mblen
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|elen
operator|&&
name|mlen
condition|)
block|{
name|skip
operator|=
name|MIN
argument_list|(
name|eskip
argument_list|,
name|mskip
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAX
argument_list|(
name|elen
operator|+
name|eskip
argument_list|,
name|mlen
operator|+
name|mskip
argument_list|)
operator|-
name|skip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elen
condition|)
block|{
name|skip
operator|=
name|eskip
expr_stmt|;
name|len
operator|=
name|elen
expr_stmt|;
block|}
else|else
block|{
name|skip
operator|=
name|mskip
expr_stmt|;
name|len
operator|=
name|mlen
expr_stmt|;
block|}
comment|/* Start first packet in chain */
name|cesa_start_packet
argument_list|(
operator|&
name|cp
argument_list|,
name|MIN
argument_list|(
name|mpsize
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nseg
operator|--
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
name|seg
operator|=
operator|*
operator|(
name|segs
operator|++
operator|)
expr_stmt|;
comment|/* 		 * Skip data in buffer on which neither ENC nor MAC operation 		 * is requested. 		 */
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|skip
argument_list|,
name|seg
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|skip
operator|-=
name|size
expr_stmt|;
name|seg
operator|.
name|ds_addr
operator|+=
name|size
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|eskip
operator|>
literal|0
condition|)
name|eskip
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|mskip
operator|>
literal|0
condition|)
name|mskip
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|seg
operator|.
name|ds_len
operator|==
literal|0
condition|)
continue|continue;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 			 * Fill in current packet with data. Break if there is 			 * no more data in current DMA segment or an error 			 * occurred. 			 */
name|size
operator|=
name|cesa_fill_packet
argument_list|(
name|sc
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
operator|-
name|size
expr_stmt|;
break|break;
block|}
name|len
operator|-=
name|size
expr_stmt|;
comment|/* If packet is full, append it to the chain */
if|if
condition|(
name|cp
operator|.
name|cp_size
operator|==
name|cp
operator|.
name|cp_offset
condition|)
block|{
name|csd
operator|=
name|cesa_alloc_sdesc
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csd
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* Create SA descriptor for this packet */
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_config
operator|=
name|cci
operator|->
name|cci_config
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_total_dlen
operator|=
name|tmlen
expr_stmt|;
comment|/* 				 * Enable fragmentation if request will not fit 				 * into one packet. 				 */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fragmented
condition|)
block|{
name|fragmented
operator|=
literal|1
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_config
operator||=
name|CESA_CSHD_FRAG_FIRST
expr_stmt|;
block|}
else|else
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_config
operator||=
name|CESA_CSHD_FRAG_MIDDLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragmented
condition|)
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_config
operator||=
name|CESA_CSHD_FRAG_LAST
expr_stmt|;
if|if
condition|(
name|eskip
operator|<
name|cp
operator|.
name|cp_size
operator|&&
name|elen
operator|>
literal|0
condition|)
block|{
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_src
operator|=
name|CESA_DATA
argument_list|(
name|eskip
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_dst
operator|=
name|CESA_DATA
argument_list|(
name|eskip
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_dlen
operator|=
name|MIN
argument_list|(
name|elen
argument_list|,
name|cp
operator|.
name|cp_size
operator|-
name|eskip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mskip
operator|<
name|cp
operator|.
name|cp_size
operator|&&
name|mlen
operator|>
literal|0
condition|)
block|{
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_src
operator|=
name|CESA_DATA
argument_list|(
name|mskip
argument_list|)
expr_stmt|;
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_dlen
operator|=
name|MIN
argument_list|(
name|mlen
argument_list|,
name|cp
operator|.
name|cp_size
operator|-
name|mskip
argument_list|)
expr_stmt|;
block|}
name|elen
operator|-=
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_enc_dlen
expr_stmt|;
name|eskip
operator|-=
name|MIN
argument_list|(
name|eskip
argument_list|,
name|cp
operator|.
name|cp_size
argument_list|)
expr_stmt|;
name|mlen
operator|-=
name|csd
operator|->
name|csd_cshd
operator|->
name|cshd_mac_dlen
expr_stmt|;
name|mskip
operator|-=
name|MIN
argument_list|(
name|mskip
argument_list|,
name|cp
operator|.
name|cp_size
argument_list|)
expr_stmt|;
name|cesa_dump_cshd
argument_list|(
name|sc
argument_list|,
name|csd
operator|->
name|csd_cshd
argument_list|)
expr_stmt|;
comment|/* Append packet to the request */
name|error
operator|=
name|cesa_append_packet
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|,
operator|&
name|cp
argument_list|,
name|csd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* Start a new packet, as current is full */
name|cesa_start_packet
argument_list|(
operator|&
name|cp
argument_list|,
name|MIN
argument_list|(
name|mpsize
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Move all allocated resources to the request. They will be 		 * freed later. 		 */
name|STAILQ_CONCAT
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|,
operator|&
name|cp
operator|.
name|cp_copyin
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|,
operator|&
name|cp
operator|.
name|cp_copyout
argument_list|)
expr_stmt|;
name|cci
operator|->
name|cci_error
operator|=
name|error
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_create_chain_cb2
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|cesa_create_chain_cb
argument_list|(
name|arg
argument_list|,
name|segs
argument_list|,
name|nseg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_create_chain
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|cesa_request
modifier|*
name|cr
parameter_list|)
block|{
name|struct
name|cesa_chain_info
name|cci
decl_stmt|;
name|struct
name|cesa_tdma_desc
modifier|*
name|ctd
decl_stmt|;
name|uint32_t
name|config
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|CESA_LOCK_ASSERT
argument_list|(
name|sc
argument_list|,
name|sessions
argument_list|)
expr_stmt|;
comment|/* Create request metadata */
if|if
condition|(
name|cr
operator|->
name|cr_enc
condition|)
block|{
if|if
condition|(
name|cr
operator|->
name|cr_enc
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|&&
operator|(
name|cr
operator|->
name|cr_enc
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_key
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_aes_dkey
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_klen
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_key
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_key
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_klen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cr
operator|->
name|cr_mac
condition|)
block|{
name|memcpy
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_hiv_in
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_hiv_in
argument_list|,
name|CESA_MAX_HASH_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_hiv_out
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_hiv_out
argument_list|,
name|CESA_MAX_HASH_LEN
argument_list|)
expr_stmt|;
block|}
name|ctd
operator|=
name|cesa_tdma_copyin_sa_data
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cesa_append_tdesc
argument_list|(
name|cr
argument_list|,
name|ctd
argument_list|)
expr_stmt|;
comment|/* Prepare SA configuration */
name|config
operator|=
name|cr
operator|->
name|cr_cs
operator|->
name|cs_config
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_enc
operator|&&
operator|(
name|cr
operator|->
name|cr_enc
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
operator|==
literal|0
condition|)
name|config
operator||=
name|CESA_CSHD_DECRYPT
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_enc
operator|&&
operator|!
name|cr
operator|->
name|cr_mac
condition|)
name|config
operator||=
name|CESA_CSHD_ENC
expr_stmt|;
if|if
condition|(
operator|!
name|cr
operator|->
name|cr_enc
operator|&&
name|cr
operator|->
name|cr_mac
condition|)
name|config
operator||=
name|CESA_CSHD_MAC
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_enc
operator|&&
name|cr
operator|->
name|cr_mac
condition|)
name|config
operator||=
operator|(
name|config
operator|&
name|CESA_CSHD_DECRYPT
operator|)
condition|?
name|CESA_CSHD_MAC_AND_ENC
else|:
name|CESA_CSHD_ENC_AND_MAC
expr_stmt|;
comment|/* Create data packets */
name|cci
operator|.
name|cci_sc
operator|=
name|sc
expr_stmt|;
name|cci
operator|.
name|cci_cr
operator|=
name|cr
expr_stmt|;
name|cci
operator|.
name|cci_enc
operator|=
name|cr
operator|->
name|cr_enc
expr_stmt|;
name|cci
operator|.
name|cci_mac
operator|=
name|cr
operator|->
name|cr_mac
expr_stmt|;
name|cci
operator|.
name|cci_config
operator|=
name|config
expr_stmt|;
name|cci
operator|.
name|cci_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
name|error
operator|=
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|cr
operator|->
name|cr_dmap
argument_list|,
operator|(
expr|struct
name|uio
operator|*
operator|)
name|cr
operator|->
name|cr_crp
operator|->
name|crp_buf
argument_list|,
name|cesa_create_chain_cb2
argument_list|,
operator|&
name|cci
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cr
operator|->
name|cr_crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|cr
operator|->
name|cr_dmap
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|cr
operator|->
name|cr_crp
operator|->
name|crp_buf
argument_list|,
name|cesa_create_chain_cb2
argument_list|,
operator|&
name|cci
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|cr
operator|->
name|cr_dmap
argument_list|,
name|cr
operator|->
name|cr_crp
operator|->
name|crp_buf
argument_list|,
name|cr
operator|->
name|cr_crp
operator|->
name|crp_ilen
argument_list|,
name|cesa_create_chain_cb
argument_list|,
operator|&
name|cci
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cr
operator|->
name|cr_dmap_loaded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cci
operator|.
name|cci_error
condition|)
name|error
operator|=
name|cci
operator|.
name|cci_error
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read back request metadata */
name|ctd
operator|=
name|cesa_tdma_copyout_sa_data
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctd
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cesa_append_tdesc
argument_list|(
name|cr
argument_list|,
name|ctd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_execute
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cesa_tdma_desc
modifier|*
name|prev_ctd
decl_stmt|,
modifier|*
name|ctd
decl_stmt|;
name|struct
name|cesa_request
modifier|*
name|prev_cr
decl_stmt|,
modifier|*
name|cr
decl_stmt|;
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
comment|/* 	 * If ready list is empty, there is nothing to execute. If queued list 	 * is not empty, the hardware is busy and we cannot start another 	 * execution. 	 */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ready_requests
argument_list|)
operator|||
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|)
condition|)
block|{
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Move all ready requests to queued list */
name|STAILQ_CONCAT
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|,
operator|&
name|sc
operator|->
name|sc_ready_requests
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_ready_requests
argument_list|)
expr_stmt|;
comment|/* Create one execution chain from all requests on the list */
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|)
operator|!=
name|STAILQ_LAST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|,
name|cesa_request
argument_list|,
name|cr_stq
argument_list|)
condition|)
block|{
name|prev_cr
operator|=
name|NULL
expr_stmt|;
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_cdm
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|cr
argument_list|,
argument|&sc->sc_queued_requests
argument_list|,
argument|cr_stq
argument_list|)
block|{
if|if
condition|(
name|prev_cr
condition|)
block|{
name|ctd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|)
expr_stmt|;
name|prev_ctd
operator|=
name|STAILQ_LAST
argument_list|(
operator|&
name|prev_cr
operator|->
name|cr_tdesc
argument_list|,
name|cesa_tdma_desc
argument_list|,
name|ctd_stq
argument_list|)
expr_stmt|;
name|prev_ctd
operator|->
name|ctd_cthd
operator|->
name|cthd_next
operator|=
name|ctd
operator|->
name|ctd_cthd_paddr
expr_stmt|;
block|}
name|prev_cr
operator|=
name|cr
expr_stmt|;
block|}
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_cdm
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* Start chain execution in hardware */
name|cr
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|)
expr_stmt|;
name|ctd
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|cr
operator|->
name|cr_tdesc
argument_list|)
expr_stmt|;
name|CESA_TDMA_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_ND
argument_list|,
name|ctd
operator|->
name|ctd_cthd_paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6828
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6820
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6810
condition|)
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_SA_CMD
argument_list|,
name|CESA_SA_CMD_ACTVATE
operator||
name|CESA_SA_CMD_SHA2
argument_list|)
expr_stmt|;
else|else
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_SA_CMD
argument_list|,
name|CESA_SA_CMD_ACTVATE
argument_list|)
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_setup_sram
parameter_list|(
name|struct
name|cesa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|phandle_t
name|sram_node
decl_stmt|;
name|ihandle_t
name|sram_ihandle
decl_stmt|;
name|pcell_t
name|sram_handle
decl_stmt|,
name|sram_reg
index|[
literal|2
index|]
decl_stmt|;
name|void
modifier|*
name|sram_va
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|ofw_bus_get_node
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
literal|"sram-handle"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sram_handle
argument_list|,
sizeof|sizeof
argument_list|(
name|sram_handle
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|sram_ihandle
operator|=
operator|(
name|ihandle_t
operator|)
name|sram_handle
expr_stmt|;
name|sram_node
operator|=
name|OF_instance_to_package
argument_list|(
name|sram_ihandle
argument_list|)
expr_stmt|;
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|sram_node
argument_list|,
literal|"reg"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sram_reg
argument_list|,
sizeof|sizeof
argument_list|(
name|sram_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|sc
operator|->
name|sc_sram_base_pa
operator|=
name|sram_reg
index|[
literal|0
index|]
expr_stmt|;
comment|/* Store SRAM size to be able to unmap in detach() */
name|sc
operator|->
name|sc_sram_size
operator|=
name|sram_reg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_soc_id
operator|!=
name|MV_DEV_88F6828
operator|&&
name|sc
operator|->
name|sc_soc_id
operator|!=
name|MV_DEV_88F6820
operator|&&
name|sc
operator|->
name|sc_soc_id
operator|!=
name|MV_DEV_88F6810
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* SRAM memory was not mapped in platform_sram_devmap(), map it now */
name|sram_va
operator|=
name|pmap_mapdev
argument_list|(
name|sc
operator|->
name|sc_sram_base_pa
argument_list|,
name|sc
operator|->
name|sc_sram_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sram_va
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|sc_sram_base_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|sram_va
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"mrvl,cesa"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Marvell Cryptographic Engine and Security "
literal|"Accelerator"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|d
decl_stmt|,
name|r
decl_stmt|,
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blocked
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|soc_id
argument_list|(
operator|&
name|d
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
condition|)
block|{
case|case
name|MV_DEV_88F6281
case|:
case|case
name|MV_DEV_88F6282
case|:
comment|/* Check if CESA peripheral device has power turned on */
if|if
condition|(
name|soc_power_ctrl_get
argument_list|(
name|CPU_PM_CTRL_CRYPTO
argument_list|)
operator|==
name|CPU_PM_CTRL_CRYPTO
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not powered on\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_tperr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MV_DEV_88F6828
case|:
case|case
name|MV_DEV_88F6820
case|:
case|case
name|MV_DEV_88F6810
case|:
name|sc
operator|->
name|sc_tperr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MV_DEV_MV78100
case|:
case|case
name|MV_DEV_MV78100_Z0
case|:
comment|/* Check if CESA peripheral device has power turned on */
if|if
condition|(
name|soc_power_ctrl_get
argument_list|(
name|CPU_PM_CTRL_CRYPTO
argument_list|)
operator|!=
name|CPU_PM_CTRL_CRYPTO
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not powered on\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_tperr
operator|=
name|CESA_ICR_TPERR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_soc_id
operator|=
name|d
expr_stmt|;
comment|/* Initialize mutexes */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_sc_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"CESA Shared Data"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"CESA TDMA Descriptors Pool"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_sdesc_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"CESA SA Descriptors Pool"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"CESA Requests Pool"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"CESA Sessions Pool"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Allocate I/O and IRQ resources */
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|cesa_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
comment|/* Acquire SRAM base address */
name|error
operator|=
name|cesa_setup_sram
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup SRAM\n"
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Setup interrupt handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
name|RES_CESA_IRQ
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|cesa_intr
argument_list|,
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|sc_icookie
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup engine completion irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
comment|/* Create DMA tag for processed data */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filtfunc, filtfuncarg */
name|CESA_MAX_REQUEST_SIZE
argument_list|,
comment|/* maxsize */
name|CESA_MAX_FRAGMENTS
argument_list|,
comment|/* nsegments */
name|CESA_MAX_REQUEST_SIZE
argument_list|,
literal|0
argument_list|,
comment|/* maxsegsz, flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|sc_data_dtag
argument_list|)
expr_stmt|;
comment|/* dmat */
if|if
condition|(
name|error
condition|)
goto|goto
name|err3
goto|;
comment|/* Initialize data structures: TDMA Descriptors Pool */
name|error
operator|=
name|cesa_alloc_dma_mem
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdesc_cdm
argument_list|,
name|CESA_TDMA_DESCRIPTORS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_tdma_hdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err4
goto|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_tdesc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_TDMA_DESCRIPTORS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_tdesc
index|[
name|i
index|]
operator|.
name|ctd_cthd
operator|=
operator|(
expr|struct
name|cesa_tdma_hdesc
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_tdesc_cdm
operator|.
name|cdm_vaddr
operator|)
operator|+
name|i
expr_stmt|;
name|sc
operator|->
name|sc_tdesc
index|[
name|i
index|]
operator|.
name|ctd_cthd_paddr
operator|=
name|sc
operator|->
name|sc_tdesc_cdm
operator|.
name|cdm_paddr
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_tdma_hdesc
argument_list|)
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_tdesc
argument_list|,
operator|&
name|sc
operator|->
name|sc_tdesc
index|[
name|i
index|]
argument_list|,
name|ctd_stq
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize data structures: SA Descriptors Pool */
name|error
operator|=
name|cesa_alloc_dma_mem
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_sdesc_cdm
argument_list|,
name|CESA_SA_DESCRIPTORS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_hdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err5
goto|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_sdesc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_SA_DESCRIPTORS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_sdesc
index|[
name|i
index|]
operator|.
name|csd_cshd
operator|=
operator|(
expr|struct
name|cesa_sa_hdesc
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_sdesc_cdm
operator|.
name|cdm_vaddr
operator|)
operator|+
name|i
expr_stmt|;
name|sc
operator|->
name|sc_sdesc
index|[
name|i
index|]
operator|.
name|csd_cshd_paddr
operator|=
name|sc
operator|->
name|sc_sdesc_cdm
operator|.
name|cdm_paddr
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_hdesc
argument_list|)
operator|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_sdesc
argument_list|,
operator|&
name|sc
operator|->
name|sc_sdesc
index|[
name|i
index|]
argument_list|,
name|csd_stq
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize data structures: Requests Pool */
name|error
operator|=
name|cesa_alloc_dma_mem
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_requests_cdm
argument_list|,
name|CESA_REQUESTS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|err6
goto|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_requests
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_ready_requests
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_REQUESTS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
operator|.
name|cr_csd
operator|=
operator|(
expr|struct
name|cesa_sa_data
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_requests_cdm
operator|.
name|cdm_vaddr
operator|)
operator|+
name|i
expr_stmt|;
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
operator|.
name|cr_csd_paddr
operator|=
name|sc
operator|->
name|sc_requests_cdm
operator|.
name|cdm_paddr
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cesa_sa_data
argument_list|)
operator|)
expr_stmt|;
comment|/* Preallocate DMA maps */
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
operator|.
name|cr_dmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
do|do
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
operator|.
name|cr_dmap
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|--
condition|)
do|;
goto|goto
name|err7
goto|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_requests
argument_list|,
operator|&
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
argument_list|,
name|cr_stq
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize data structures: Sessions Pool */
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_sessions
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_SESSIONS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_sessions
index|[
name|i
index|]
operator|.
name|cs_sid
operator|=
name|i
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_free_sessions
argument_list|,
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|i
index|]
argument_list|,
name|cs_stq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize TDMA: 	 * - Burst limit: 128 bytes, 	 * - Outstanding reads enabled, 	 * - No byte-swap. 	 */
name|val
operator|=
name|CESA_TDMA_CR_DBL128
operator||
name|CESA_TDMA_CR_SBL128
operator||
name|CESA_TDMA_CR_ORDEN
operator||
name|CESA_TDMA_CR_NBS
operator||
name|CESA_TDMA_CR_ENABLE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6828
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6820
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6810
condition|)
name|val
operator||=
name|CESA_TDMA_NUM_OUTSTAND
expr_stmt|;
name|CESA_TDMA_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_CR
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize SA: 	 * - SA descriptor is present at beginning of CESA SRAM, 	 * - Multi-packet chain mode, 	 * - Cooperation with TDMA enabled. 	 */
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_SA_DPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_SA_CR
argument_list|,
name|CESA_SA_CR_ACTIVATE_TDMA
operator||
name|CESA_SA_CR_WAIT_FOR_TDMA
operator||
name|CESA_SA_CR_MULTI_MODE
argument_list|)
expr_stmt|;
comment|/* Unmask interrupts */
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_ICM
argument_list|,
name|CESA_ICM_ACCTDMA
operator||
name|sc
operator|->
name|sc_tperr
argument_list|)
expr_stmt|;
name|CESA_TDMA_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_ECR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CESA_TDMA_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_EMR
argument_list|,
name|CESA_TDMA_EMR_MISS
operator||
name|CESA_TDMA_EMR_DOUBLE_HIT
operator||
name|CESA_TDMA_EMR_BOTH_HIT
operator||
name|CESA_TDMA_EMR_DATA_ERROR
argument_list|)
expr_stmt|;
comment|/* Register in OCF */
name|sc
operator|->
name|sc_cid
operator|=
name|crypto_get_driverid
argument_list|(
name|dev
argument_list|,
name|CRYPTOCAP_F_HARDWARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cid
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get crypto driver id\n"
argument_list|)
expr_stmt|;
goto|goto
name|err8
goto|;
block|}
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_AES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_3DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6828
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6820
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6810
condition|)
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA2_256_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err8
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_REQUESTS
condition|;
name|i
operator|++
control|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
operator|.
name|cr_dmap
argument_list|)
expr_stmt|;
name|err7
label|:
name|cesa_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_cdm
argument_list|)
expr_stmt|;
name|err6
label|:
name|cesa_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_sdesc_cdm
argument_list|)
expr_stmt|;
name|err5
label|:
name|cesa_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_cdm
argument_list|)
expr_stmt|;
name|err4
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|)
expr_stmt|;
name|err3
label|:
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
name|RES_CESA_IRQ
index|]
argument_list|,
name|sc
operator|->
name|sc_icookie
argument_list|)
expr_stmt|;
name|err2
label|:
if|if
condition|(
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6828
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6820
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6810
condition|)
name|pmap_unmapdev
argument_list|(
name|sc
operator|->
name|sc_sram_base_va
argument_list|,
name|sc
operator|->
name|sc_sram_size
argument_list|)
expr_stmt|;
name|err1
label|:
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|cesa_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|err0
label|:
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sdesc_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* TODO: Wait for queued requests completion before shutdown. */
comment|/* Mask interrupts */
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_ICM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CESA_TDMA_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_EMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unregister from OCF */
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
comment|/* Free DMA Maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CESA_REQUESTS
condition|;
name|i
operator|++
control|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|sc
operator|->
name|sc_requests
index|[
name|i
index|]
operator|.
name|cr_dmap
argument_list|)
expr_stmt|;
comment|/* Free DMA Memory */
name|cesa_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_cdm
argument_list|)
expr_stmt|;
name|cesa_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_sdesc_cdm
argument_list|)
expr_stmt|;
name|cesa_free_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_cdm
argument_list|)
expr_stmt|;
comment|/* Free DMA Tag */
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|)
expr_stmt|;
comment|/* Stop interrupt */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_res
index|[
name|RES_CESA_IRQ
index|]
argument_list|,
name|sc
operator|->
name|sc_icookie
argument_list|)
expr_stmt|;
comment|/* Relase I/O and IRQ resources */
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|cesa_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
comment|/* Unmap SRAM memory */
if|if
condition|(
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6828
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6820
operator|||
name|sc
operator|->
name|sc_soc_id
operator|==
name|MV_DEV_88F6810
condition|)
name|pmap_unmapdev
argument_list|(
name|sc
operator|->
name|sc_sram_base_va
argument_list|,
name|sc
operator|->
name|sc_sram_size
argument_list|)
expr_stmt|;
comment|/* Destroy mutexes */
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sdesc_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_tdesc_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cesa_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|cesa_request
argument_list|)
name|requests
expr_stmt|;
name|struct
name|cesa_request
modifier|*
name|cr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|ecr
decl_stmt|,
name|icr
decl_stmt|;
name|int
name|blocked
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* Ack interrupt */
name|ecr
operator|=
name|CESA_TDMA_READ
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_ECR
argument_list|)
expr_stmt|;
name|CESA_TDMA_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_TDMA_ECR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|icr
operator|=
name|CESA_REG_READ
argument_list|(
name|sc
argument_list|,
name|CESA_ICR
argument_list|)
expr_stmt|;
name|CESA_REG_WRITE
argument_list|(
name|sc
argument_list|,
name|CESA_ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for TDMA errors */
if|if
condition|(
name|ecr
operator|&
name|CESA_TDMA_ECR_MISS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TDMA Miss error detected!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
name|ecr
operator|&
name|CESA_TDMA_ECR_DOUBLE_HIT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TDMA Double Hit error detected!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
name|ecr
operator|&
name|CESA_TDMA_ECR_BOTH_HIT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TDMA Both Hit error detected!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
name|ecr
operator|&
name|CESA_TDMA_ECR_DATA_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"TDMA Data error detected!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* Check for CESA errors */
if|if
condition|(
name|icr
operator|&
name|sc
operator|->
name|sc_tperr
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"CESA SRAM Parity error detected!\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* If there is nothing more to do, return */
if|if
condition|(
operator|(
name|icr
operator|&
name|CESA_ICR_ACCTDMA
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Get all finished requests */
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|requests
argument_list|)
expr_stmt|;
name|STAILQ_CONCAT
argument_list|(
operator|&
name|requests
argument_list|,
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_queued_requests
argument_list|)
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|requests
argument_list|)
expr_stmt|;
comment|/* Execute all ready requests */
name|cesa_execute
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Process completed requests */
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_cdm
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|cr
argument_list|,
argument|&requests
argument_list|,
argument|cr_stq
argument_list|,
argument|tmp
argument_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|cr
operator|->
name|cr_dmap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_crp
operator|->
name|crp_etype
operator|=
name|sc
operator|->
name|sc_error
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|cr_mac
condition|)
name|crypto_copyback
argument_list|(
name|cr
operator|->
name|cr_crp
operator|->
name|crp_flags
argument_list|,
name|cr
operator|->
name|cr_crp
operator|->
name|crp_buf
argument_list|,
name|cr
operator|->
name|cr_mac
operator|->
name|crd_inject
argument_list|,
name|cr
operator|->
name|cr_cs
operator|->
name|cs_hlen
argument_list|,
name|cr
operator|->
name|cr_csd
operator|->
name|csd_hash
argument_list|)
expr_stmt|;
name|crypto_done
argument_list|(
name|cr
operator|->
name|cr_crp
argument_list|)
expr_stmt|;
name|cesa_free_request
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
name|cesa_sync_dma_mem
argument_list|(
operator|&
name|sc
operator|->
name|sc_requests_cdm
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_error
operator|=
literal|0
expr_stmt|;
comment|/* Unblock driver if it ran out of resources */
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|blocked
operator|=
name|sc
operator|->
name|sc_blocked
expr_stmt|;
name|sc
operator|->
name|sc_blocked
operator|=
literal|0
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked
condition|)
name|crypto_unblock
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|blocked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_newsession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|sidp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
name|struct
name|cesa_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cryptoini
modifier|*
name|enc
decl_stmt|;
name|struct
name|cryptoini
modifier|*
name|mac
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|enc
operator|=
name|NULL
expr_stmt|;
name|mac
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Check and parse input */
if|if
condition|(
name|cesa_is_hash
argument_list|(
name|cri
operator|->
name|cri_alg
argument_list|)
condition|)
name|mac
operator|=
name|cri
expr_stmt|;
else|else
name|enc
operator|=
name|cri
expr_stmt|;
name|cri
operator|=
name|cri
operator|->
name|cri_next
expr_stmt|;
if|if
condition|(
name|cri
condition|)
block|{
if|if
condition|(
operator|!
name|enc
operator|&&
operator|!
name|cesa_is_hash
argument_list|(
name|cri
operator|->
name|cri_alg
argument_list|)
condition|)
name|enc
operator|=
name|cri
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|&&
name|cesa_is_hash
argument_list|(
name|cri
operator|->
name|cri_alg
argument_list|)
condition|)
name|mac
operator|=
name|cri
expr_stmt|;
if|if
condition|(
name|cri
operator|->
name|cri_next
operator|||
operator|!
operator|(
name|enc
operator|&&
name|mac
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|enc
operator|&&
operator|(
name|enc
operator|->
name|cri_klen
operator|/
literal|8
operator|)
operator|>
name|CESA_MAX_KEY_LEN
operator|)
operator|||
operator|(
name|mac
operator|&&
operator|(
name|mac
operator|->
name|cri_klen
operator|/
literal|8
operator|)
operator|>
name|CESA_MAX_MKEY_LEN
operator|)
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
comment|/* Allocate session */
name|cs
operator|=
name|cesa_alloc_session
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cs
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Prepare CESA configuration */
name|cs
operator|->
name|cs_config
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_ivlen
operator|=
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_mblen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|enc
condition|)
block|{
switch|switch
condition|(
name|enc
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_AES_CBC
case|:
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_AES
operator||
name|CESA_CSHD_CBC
expr_stmt|;
name|cs
operator|->
name|cs_ivlen
operator|=
name|AES_BLOCK_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_DES_CBC
case|:
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_DES
operator||
name|CESA_CSHD_CBC
expr_stmt|;
name|cs
operator|->
name|cs_ivlen
operator|=
name|DES_BLOCK_LEN
expr_stmt|;
break|break;
case|case
name|CRYPTO_3DES_CBC
case|:
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_3DES
operator||
name|CESA_CSHD_3DES_EDE
operator||
name|CESA_CSHD_CBC
expr_stmt|;
name|cs
operator|->
name|cs_ivlen
operator|=
name|DES3_BLOCK_LEN
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|mac
condition|)
block|{
switch|switch
condition|(
name|mac
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_MD5
case|:
name|cs
operator|->
name|cs_mblen
operator|=
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
operator|(
name|mac
operator|->
name|cri_mlen
operator|==
literal|0
operator|)
condition|?
name|MD5_HASH_LEN
else|:
name|mac
operator|->
name|cri_mlen
expr_stmt|;
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_MD5
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_HMAC
case|:
name|cs
operator|->
name|cs_mblen
operator|=
name|MD5_HMAC_BLOCK_LEN
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
operator|(
name|mac
operator|->
name|cri_mlen
operator|==
literal|0
operator|)
condition|?
name|MD5_HASH_LEN
else|:
name|mac
operator|->
name|cri_mlen
expr_stmt|;
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_MD5_HMAC
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_hlen
operator|==
name|CESA_HMAC_TRUNC_LEN
condition|)
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_96_BIT_HMAC
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA1
case|:
name|cs
operator|->
name|cs_mblen
operator|=
literal|1
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
operator|(
name|mac
operator|->
name|cri_mlen
operator|==
literal|0
operator|)
condition|?
name|SHA1_HASH_LEN
else|:
name|mac
operator|->
name|cri_mlen
expr_stmt|;
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_SHA1
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA1_HMAC
case|:
name|cs
operator|->
name|cs_mblen
operator|=
name|SHA1_HMAC_BLOCK_LEN
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
operator|(
name|mac
operator|->
name|cri_mlen
operator|==
literal|0
operator|)
condition|?
name|SHA1_HASH_LEN
else|:
name|mac
operator|->
name|cri_mlen
expr_stmt|;
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_SHA1_HMAC
expr_stmt|;
if|if
condition|(
name|cs
operator|->
name|cs_hlen
operator|==
name|CESA_HMAC_TRUNC_LEN
condition|)
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_96_BIT_HMAC
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA2_256_HMAC
case|:
name|cs
operator|->
name|cs_mblen
operator|=
name|SHA2_256_HMAC_BLOCK_LEN
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
operator|(
name|mac
operator|->
name|cri_mlen
operator|==
literal|0
operator|)
condition|?
name|SHA2_256_HASH_LEN
else|:
name|mac
operator|->
name|cri_mlen
expr_stmt|;
name|cs
operator|->
name|cs_config
operator||=
name|CESA_CSHD_SHA2_256_HMAC
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
comment|/* Save cipher key */
if|if
condition|(
operator|!
name|error
operator|&&
name|enc
operator|&&
name|enc
operator|->
name|cri_key
condition|)
block|{
name|cs
operator|->
name|cs_klen
operator|=
name|enc
operator|->
name|cri_klen
operator|/
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|cs
operator|->
name|cs_key
argument_list|,
name|enc
operator|->
name|cri_key
argument_list|,
name|cs
operator|->
name|cs_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|cri_alg
operator|==
name|CRYPTO_AES_CBC
condition|)
name|error
operator|=
name|cesa_prep_aes_key
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
comment|/* Save digest key */
if|if
condition|(
operator|!
name|error
operator|&&
name|mac
operator|&&
name|mac
operator|->
name|cri_key
condition|)
name|error
operator|=
name|cesa_set_mkey
argument_list|(
name|cs
argument_list|,
name|mac
operator|->
name|cri_alg
argument_list|,
name|mac
operator|->
name|cri_key
argument_list|,
name|mac
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cesa_free_session
argument_list|(
name|sc
argument_list|,
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|sidp
operator|=
name|cs
operator|->
name|cs_sid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint64_t
name|tid
parameter_list|)
block|{
name|struct
name|cesa_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cs
operator|=
name|cesa_get_session
argument_list|(
name|sc
argument_list|,
name|CRYPTO_SESID2LID
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Free session */
name|cesa_free_session
argument_list|(
name|sc
argument_list|,
name|cs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cesa_process
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|cesa_request
modifier|*
name|cr
decl_stmt|;
name|struct
name|cesa_session
modifier|*
name|cs
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|enc
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|mac
decl_stmt|;
name|struct
name|cesa_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|enc
operator|=
name|NULL
expr_stmt|;
name|mac
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Check session ID */
name|cs
operator|=
name|cesa_get_session
argument_list|(
name|sc
argument_list|,
name|CRYPTO_SESID2LID
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cs
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|EINVAL
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check and parse input */
if|if
condition|(
name|crp
operator|->
name|crp_ilen
operator|>
name|CESA_MAX_REQUEST_SIZE
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|E2BIG
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cesa_is_hash
argument_list|(
name|crd
operator|->
name|crd_alg
argument_list|)
condition|)
name|mac
operator|=
name|crd
expr_stmt|;
else|else
name|enc
operator|=
name|crd
expr_stmt|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
expr_stmt|;
if|if
condition|(
name|crd
condition|)
block|{
if|if
condition|(
operator|!
name|enc
operator|&&
operator|!
name|cesa_is_hash
argument_list|(
name|crd
operator|->
name|crd_alg
argument_list|)
condition|)
name|enc
operator|=
name|crd
expr_stmt|;
if|if
condition|(
operator|!
name|mac
operator|&&
name|cesa_is_hash
argument_list|(
name|crd
operator|->
name|crd_alg
argument_list|)
condition|)
name|mac
operator|=
name|crd
expr_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_next
operator|||
operator|!
operator|(
name|enc
operator|&&
name|mac
operator|)
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|EINVAL
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Get request descriptor. Block driver if there is no free 	 * descriptors in pool. 	 */
name|cr
operator|=
name|cesa_alloc_request
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cr
condition|)
block|{
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_blocked
operator|=
name|CRYPTO_SYMQ
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
comment|/* Prepare request */
name|cr
operator|->
name|cr_crp
operator|=
name|crp
expr_stmt|;
name|cr
operator|->
name|cr_enc
operator|=
name|enc
expr_stmt|;
name|cr
operator|->
name|cr_mac
operator|=
name|mac
expr_stmt|;
name|cr
operator|->
name|cr_cs
operator|=
name|cs
expr_stmt|;
name|CESA_LOCK
argument_list|(
name|sc
argument_list|,
name|sessions
argument_list|)
expr_stmt|;
name|cesa_sync_desc
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|&&
name|enc
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
if|if
condition|(
name|enc
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_iv
argument_list|,
name|enc
operator|->
name|crd_iv
argument_list|,
name|cs
operator|->
name|cs_ivlen
argument_list|)
expr_stmt|;
else|else
name|arc4rand
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_iv
argument_list|,
name|cs
operator|->
name|cs_ivlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enc
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|enc
operator|->
name|crd_inject
argument_list|,
name|cs
operator|->
name|cs_ivlen
argument_list|,
name|cr
operator|->
name|cr_csd
operator|->
name|csd_iv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enc
condition|)
block|{
if|if
condition|(
name|enc
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|memcpy
argument_list|(
name|cr
operator|->
name|cr_csd
operator|->
name|csd_iv
argument_list|,
name|enc
operator|->
name|crd_iv
argument_list|,
name|cs
operator|->
name|cs_ivlen
argument_list|)
expr_stmt|;
else|else
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|enc
operator|->
name|crd_inject
argument_list|,
name|cs
operator|->
name|cs_ivlen
argument_list|,
name|cr
operator|->
name|cr_csd
operator|->
name|csd_iv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enc
operator|&&
name|enc
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
if|if
condition|(
operator|(
name|enc
operator|->
name|crd_klen
operator|/
literal|8
operator|)
operator|<=
name|CESA_MAX_KEY_LEN
condition|)
block|{
name|cs
operator|->
name|cs_klen
operator|=
name|enc
operator|->
name|crd_klen
operator|/
literal|8
expr_stmt|;
name|memcpy
argument_list|(
name|cs
operator|->
name|cs_key
argument_list|,
name|enc
operator|->
name|crd_key
argument_list|,
name|cs
operator|->
name|cs_klen
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
condition|)
name|error
operator|=
name|cesa_prep_aes_key
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|E2BIG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|mac
operator|&&
name|mac
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
block|{
if|if
condition|(
operator|(
name|mac
operator|->
name|crd_klen
operator|/
literal|8
operator|)
operator|<=
name|CESA_MAX_MKEY_LEN
condition|)
name|error
operator|=
name|cesa_set_mkey
argument_list|(
name|cs
argument_list|,
name|mac
operator|->
name|crd_alg
argument_list|,
name|mac
operator|->
name|crd_key
argument_list|,
name|mac
operator|->
name|crd_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|E2BIG
expr_stmt|;
block|}
comment|/* Convert request to chain of TDMA and SA descriptors */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|cesa_create_chain
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|cesa_sync_desc
argument_list|(
name|sc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|CESA_UNLOCK
argument_list|(
name|sc
argument_list|,
name|sessions
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cesa_free_request
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|error
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_data_dtag
argument_list|,
name|cr
operator|->
name|cr_dmap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Enqueue request to execution */
name|cesa_enqueue_request
argument_list|(
name|sc
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* Start execution, if we have no more requests in queue */
if|if
condition|(
operator|(
name|hint
operator|&
name|CRYPTO_HINT_MORE
operator|)
operator|==
literal|0
condition|)
name|cesa_execute
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

