begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996-2000 Distributed Processing Technology Corporation  * Copyright (c) 2000-2001 Adaptec Corporation  * All rights reserved.  *  * TERMS AND CONDITIONS OF USE  *  * Redistribution and use in source form, with or without modification, are  * permitted provided that redistributions of source code must retain the  * above copyright notice, this list of conditions and the following disclaimer.  *  * This software is provided `as is' by Adaptec and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose, are disclaimed. In no  * event shall Adaptec be liable for any direct, indirect, incidental, special,  * exemplary or consequential damages (including, but not limited to,  * procurement of substitute goods or services; loss of use, data, or profits;  * or business interruptions) however caused and on any theory of liability,  * whether in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this driver software, even  * if advised of the possibility of such damage.  *  * SCSI I2O host adapter driver  *  *	V1.10 2004/05/05 scottl@freebsd.org  *		- Massive cleanup of the driver to remove dead code and  *		  non-conformant style.  *		- Removed most i386-specific code to make it more portable.  *		- Converted to the bus_space API.  *	V1.08 2001/08/21 Mark_Salyzyn@adaptec.com  *		- The 2000S and 2005S do not initialize on some machines,  *		  increased timeout to 255ms from 50ms for the StatusGet  *		  command.  *	V1.07 2001/05/22 Mark_Salyzyn@adaptec.com  *		- I knew this one was too good to be true. The error return  *		  on ioctl commands needs to be compared to CAM_REQ_CMP, not  *		  to the bit masked status.  *	V1.06 2001/05/08 Mark_Salyzyn@adaptec.com  *		- The 2005S that was supported is affectionately called the  *		  Conjoined BAR Firmware. In order to support RAID-5 in a  *		  16MB low-cost configuration, Firmware was forced to go  *		  to a Split BAR Firmware. This requires a separate IOP and  *		  Messaging base address.  *	V1.05 2001/04/25 Mark_Salyzyn@adaptec.com  *		- Handle support for 2005S Zero Channel RAID solution.  *		- System locked up if the Adapter locked up. Do not try  *		  to send other commands if the resetIOP command fails. The  *		  fail outstanding command discovery loop was flawed as the  *		  removal of the command from the list prevented discovering  *		  all the commands.  *		- Comment changes to clarify driver.  *		- SysInfo searched for an EATA SmartROM, not an I2O SmartROM.  *		- We do not use the AC_FOUND_DEV event because of I2O.  *		  Removed asr_async.  *	V1.04 2000/09/22 Mark_Salyzyn@adaptec.com, msmith@freebsd.org,  *			 lampa@fee.vutbr.cz and Scott_Long@adaptec.com.  *		- Removed support for PM1554, PM2554 and PM2654 in Mode-0  *		  mode as this is confused with competitor adapters in run  *		  mode.  *		- critical locking needed in ASR_ccbAdd and ASR_ccbRemove  *		  to prevent operating system panic.  *		- moved default major number to 154 from 97.  *	V1.03 2000/07/12 Mark_Salyzyn@adaptec.com  *		- The controller is not actually an ASR (Adaptec SCSI RAID)  *		  series that is visible, it's more of an internal code name.  *		  remove any visible references within reason for now.  *		- bus_ptr->LUN was not correctly zeroed when initially  *		  allocated causing a possible panic of the operating system  *		  during boot.  *	V1.02 2000/06/26 Mark_Salyzyn@adaptec.com  *		- Code always fails for ASR_getTid affecting performance.  *		- initiated a set of changes that resulted from a formal  *		  code inspection by Mark_Salyzyn@adaptec.com,  *		  George_Dake@adaptec.com, Jeff_Zeak@adaptec.com,  *		  Martin_Wilson@adaptec.com and Vincent_Trandoan@adaptec.com.  *		  Their findings were focussed on the LCT& TID handler, and  *		  all resulting changes were to improve code readability,  *		  consistency or have a positive effect on performance.  *	V1.01 2000/06/14 Mark_Salyzyn@adaptec.com  *		- Passthrough returned an incorrect error.  *		- Passthrough did not migrate the intrinsic scsi layer wakeup  *		  on command completion.  *		- generate control device nodes using make_dev and delete_dev.  *		- Performance affected by TID caching reallocing.  *		- Made suggested changes by Justin_Gibbs@adaptec.com  *			- use splcam instead of splbio.  *			- use cam_imask instead of bio_imask.  *			- use u_int8_t instead of u_char.  *			- use u_int16_t instead of u_short.  *			- use u_int32_t instead of u_long where appropriate.  *			- use 64 bit context handler instead of 32 bit.  *			- create_ccb should only allocate the worst case  *			  requirements for the driver since CAM may evolve  *			  making union ccb much larger than needed here.  *			  renamed create_ccb to asr_alloc_ccb.  *			- go nutz justifying all debug prints as macros  *			  defined at the top and remove unsightly ifdefs.  *			- INLINE STATIC viewed as confusing. Historically  *			  utilized to affect code performance and debug  *			  issues in OS, Compiler or OEM specific situations.  *	V1.00 2000/05/31 Mark_Salyzyn@adaptec.com  *		- Ported from FreeBSD 2.2.X DPT I2O driver.  *			changed struct scsi_xfer to union ccb/struct ccb_hdr  *			changed variable name xs to ccb  *			changed struct scsi_link to struct cam_path  *			changed struct scsibus_data to struct cam_sim  *			stopped using fordriver for holding on to the TID  *			use proprietary packet creation instead of scsi_inquire  *			CAM layer sends synchronize commands.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* TRUE=1 and FALSE=0 defined here */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_asr.h"
end_include

begin_include
include|#
directive|include
file|<i386/include/cputypes.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BURN_BRIDGES
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ASR_COMPAT
argument_list|)
end_if

begin_define
define|#
directive|define
name|ASR_IOCTL_COMPAT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASR_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BURN_BRIDGES */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|osdSwap4
parameter_list|(
name|x
parameter_list|)
value|((u_long)ntohl((u_long)(x)))
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_include
include|#
directive|include
file|<dev/asr/dptalign.h>
end_include

begin_include
include|#
directive|include
file|<dev/asr/i2oexec.h>
end_include

begin_include
include|#
directive|include
file|<dev/asr/i2obscsi.h>
end_include

begin_include
include|#
directive|include
file|<dev/asr/i2odpt.h>
end_include

begin_include
include|#
directive|include
file|<dev/asr/i2oadptr.h>
end_include

begin_include
include|#
directive|include
file|<dev/asr/sys_info.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ASR_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|ASR_REVISION
value|'1'
end_define

begin_define
define|#
directive|define
name|ASR_SUBREVISION
value|'0'
end_define

begin_define
define|#
directive|define
name|ASR_MONTH
value|5
end_define

begin_define
define|#
directive|define
name|ASR_DAY
value|5
end_define

begin_define
define|#
directive|define
name|ASR_YEAR
value|(2004 - 1980)
end_define

begin_comment
comment|/*  *	Debug macros to reduce the unsightly ifdefs  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_ASR_USR_CMD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_ASR_CMD
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|__inline
name|void
name|debug_asr_message
parameter_list|(
name|PI2O_MESSAGE_FRAME
name|message
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|pointer
init|=
operator|(
name|u_int32_t
operator|*
operator|)
name|message
decl_stmt|;
name|u_int32_t
name|length
init|=
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|message
argument_list|)
decl_stmt|;
name|u_int32_t
name|counter
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
block|{
name|printf
argument_list|(
literal|"%08lx%c"
argument_list|,
operator|(
name|u_long
operator|)
operator|*
operator|(
name|pointer
operator|++
operator|)
argument_list|,
operator|(
operator|(
operator|(
operator|++
name|counter
operator|&
literal|7
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|length
operator|==
literal|0
operator|)
operator|)
condition|?
literal|'\n'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR || DEBUG_ASR_USR_CMD || DEBUG_ASR_CMD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ASR
end_ifdef

begin_comment
comment|/* Breaks on none STDC based compilers :-( */
end_comment

begin_define
define|#
directive|define
name|debug_asr_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt, ##args)
end_define

begin_define
define|#
directive|define
name|debug_asr_dump_message
parameter_list|(
name|message
parameter_list|)
value|debug_asr_message(message)
end_define

begin_define
define|#
directive|define
name|debug_asr_print_path
parameter_list|(
name|ccb
parameter_list|)
value|xpt_print_path(ccb->ccb_h.path);
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ASR */
end_comment

begin_define
define|#
directive|define
name|debug_asr_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_print_path
parameter_list|(
name|ccb
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR */
end_comment

begin_comment
comment|/*  *	If DEBUG_ASR_CMD is defined:  *		0 - Display incoming SCSI commands  *		1 - add in a quick character before queueing.  *		2 - add in outgoing message frames.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR_CMD
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt,##args)
end_define

begin_function
specifier|static
name|__inline
name|void
name|debug_asr_dump_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|cp
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|)
decl_stmt|;
name|int
name|len
init|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|debug_asr_cmd_printf
argument_list|(
literal|" %02x"
argument_list|,
operator|*
operator|(
name|cp
operator|++
operator|)
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|DEBUG_ASR_CMD
operator|>
literal|0
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_cmd1_printf
value|debug_asr_cmd_printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug_asr_cmd1_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|DEBUG_ASR_CMD
operator|>
literal|1
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_cmd2_printf
value|debug_asr_cmd_printf
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_dump_message
parameter_list|(
name|message
parameter_list|)
value|debug_asr_message(message)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug_asr_cmd2_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ASR_CMD */
end_comment

begin_define
define|#
directive|define
name|debug_asr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_dump_ccb
parameter_list|(
name|ccb
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd1_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR_CMD */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR_USR_CMD
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|debug_usr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt,##args)
end_define

begin_define
define|#
directive|define
name|debug_usr_cmd_dump_message
parameter_list|(
name|message
parameter_list|)
value|debug_usr_message(message)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ASR_USR_CMD */
end_comment

begin_define
define|#
directive|define
name|debug_usr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_usr_cmd_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR_USR_CMD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
end_ifdef

begin_define
define|#
directive|define
name|dsDescription_size
value|46
end_define

begin_comment
comment|/* Snug as a bug in a rug */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASR_IOCTL_COMPAT */
end_comment

begin_include
include|#
directive|include
file|"dev/asr/dptsig.h"
end_include

begin_decl_stmt
specifier|static
name|dpt_sig_S
name|ASR_sig
init|=
block|{
block|{
literal|'d'
block|,
literal|'P'
block|,
literal|'t'
block|,
literal|'S'
block|,
literal|'i'
block|,
literal|'G'
block|}
block|,
name|SIG_VERSION
block|,
name|PROC_INTEL
block|,
name|PROC_386
operator||
name|PROC_486
operator||
name|PROC_PENTIUM
operator||
name|PROC_SEXIUM
block|,
name|FT_HBADRVR
block|,
literal|0
block|,
name|OEM_DPT
block|,
name|OS_FREE_BSD
block|,
name|CAP_ABOVE16MB
block|,
name|DEV_ALL
block|,
name|ADF_ALL_SC5
block|,
literal|0
block|,
literal|0
block|,
name|ASR_VERSION
block|,
name|ASR_REVISION
block|,
name|ASR_SUBREVISION
block|,
name|ASR_MONTH
block|,
name|ASR_DAY
block|,
name|ASR_YEAR
block|,
comment|/*	 01234567890123456789012345678901234567890123456789< 50 chars */
literal|"Adaptec FreeBSD 4.0.0 Unix SCSI I2O HBA Driver"
comment|/*		 ^^^^^ asr_attach alters these to match OS */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration Definitions */
end_comment

begin_define
define|#
directive|define
name|SG_SIZE
value|58
end_define

begin_comment
comment|/* Scatter Gather list Size		 */
end_comment

begin_define
define|#
directive|define
name|MAX_TARGET_ID
value|126
end_define

begin_comment
comment|/* Maximum Target ID supported		 */
end_comment

begin_define
define|#
directive|define
name|MAX_LUN
value|255
end_define

begin_comment
comment|/* Maximum LUN Supported		 */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANNEL
value|7
end_define

begin_comment
comment|/* Maximum Channel # Supported by driver */
end_comment

begin_define
define|#
directive|define
name|MAX_INBOUND
value|2000
end_define

begin_comment
comment|/* Max CCBs, Also Max Queue Size	 */
end_comment

begin_define
define|#
directive|define
name|MAX_OUTBOUND
value|256
end_define

begin_comment
comment|/* Maximum outbound frames/adapter	 */
end_comment

begin_define
define|#
directive|define
name|MAX_INBOUND_SIZE
value|512
end_define

begin_comment
comment|/* Maximum inbound frame size		 */
end_comment

begin_define
define|#
directive|define
name|MAX_MAP
value|4194304L
end_define

begin_comment
comment|/* Maximum mapping size of IOP	 */
end_comment

begin_comment
comment|/* Also serves as the minimum map for	 */
end_comment

begin_comment
comment|/* the 2005S zero channel RAID product	 */
end_comment

begin_comment
comment|/* I2O register set */
end_comment

begin_define
define|#
directive|define
name|I2O_REG_STATUS
value|0x30
end_define

begin_define
define|#
directive|define
name|I2O_REG_MASK
value|0x34
end_define

begin_define
define|#
directive|define
name|I2O_REG_TOFIFO
value|0x40
end_define

begin_define
define|#
directive|define
name|I2O_REG_FROMFIFO
value|0x44
end_define

begin_define
define|#
directive|define
name|Mask_InterruptsDisabled
value|0x08
end_define

begin_comment
comment|/*  * A MIX of performance and space considerations for TID lookups  */
end_comment

begin_typedef
typedef|typedef
name|u_int16_t
name|tid_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/* up to MAX_LUN    */
name|tid_t
name|TID
index|[
literal|1
index|]
decl_stmt|;
block|}
name|lun2tid_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/* up to MAX_TARGET */
name|lun2tid_t
modifier|*
name|LUN
index|[
literal|1
index|]
decl_stmt|;
block|}
name|target2lun_t
typedef|;
end_typedef

begin_comment
comment|/*  *	To ensure that we only allocate and use the worst case ccb here, lets  *	make our own local ccb union. If asr_alloc_ccb is utilized for another  *	ccb type, ensure that you add the additional structures into our local  *	ccb union. To ensure strict type checking, we will utilize the local  *	ccb definition wherever possible.  */
end_comment

begin_union
union|union
name|asr_ccb
block|{
name|struct
name|ccb_hdr
name|ccb_h
decl_stmt|;
comment|/* For convenience */
name|struct
name|ccb_scsiio
name|csio
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|Asr_status_mem
block|{
name|I2O_EXEC_STATUS_GET_REPLY
name|status
decl_stmt|;
name|U32
name|rstatus
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/************************************************************************** ** ASR Host Adapter structure - One Structure For Each Host Adapter That ** **  Is Configured Into The System.  The Structure Supplies Configuration ** **  Information, Status Info, Queue Info And An Active CCB List Pointer. ** ***************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|Asr_softc
block|{
name|device_t
name|ha_dev
decl_stmt|;
name|u_int16_t
name|ha_irq
decl_stmt|;
name|u_long
name|ha_Base
decl_stmt|;
comment|/* base port for each board */
name|bus_size_t
name|ha_blinkLED
decl_stmt|;
name|bus_space_handle_t
name|ha_i2o_bhandle
decl_stmt|;
name|bus_space_tag_t
name|ha_i2o_btag
decl_stmt|;
name|bus_space_handle_t
name|ha_frame_bhandle
decl_stmt|;
name|bus_space_tag_t
name|ha_frame_btag
decl_stmt|;
name|I2O_IOP_ENTRY
name|ha_SystemTable
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|ha_ccb
expr_stmt|;
comment|/* ccbs in use		   */
name|bus_dma_tag_t
name|ha_parent_dmat
decl_stmt|;
name|bus_dma_tag_t
name|ha_statusmem_dmat
decl_stmt|;
name|bus_dmamap_t
name|ha_statusmem_dmamap
decl_stmt|;
name|struct
name|Asr_status_mem
modifier|*
name|ha_statusmem
decl_stmt|;
name|u_int32_t
name|ha_rstatus_phys
decl_stmt|;
name|u_int32_t
name|ha_status_phys
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|ha_path
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|ha_sim
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|resource
modifier|*
name|ha_mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ha_mes_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ha_irq_res
decl_stmt|;
name|void
modifier|*
name|ha_intr
decl_stmt|;
name|PI2O_LCT
name|ha_LCT
decl_stmt|;
comment|/* Complete list of devices */
define|#
directive|define
name|le_type
value|IdentityTag[0]
define|#
directive|define
name|I2O_BSA
value|0x20
define|#
directive|define
name|I2O_FCA
value|0x40
define|#
directive|define
name|I2O_SCSI
value|0x00
define|#
directive|define
name|I2O_PORT
value|0x80
define|#
directive|define
name|I2O_UNKNOWN
value|0x7F
define|#
directive|define
name|le_bus
value|IdentityTag[1]
define|#
directive|define
name|le_target
value|IdentityTag[2]
define|#
directive|define
name|le_lun
value|IdentityTag[3]
name|target2lun_t
modifier|*
name|ha_targets
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|ha_Msgs
decl_stmt|;
name|u_long
name|ha_Msgs_Phys
decl_stmt|;
name|u_int8_t
name|ha_in_reset
decl_stmt|;
define|#
directive|define
name|HA_OPERATIONAL
value|0
define|#
directive|define
name|HA_IN_RESET
value|1
define|#
directive|define
name|HA_OFF_LINE
value|2
define|#
directive|define
name|HA_OFF_LINE_RECOVERY
value|3
comment|/* Configuration information */
comment|/* The target id maximums we take */
name|u_int8_t
name|ha_MaxBus
decl_stmt|;
comment|/* Maximum bus */
name|u_int8_t
name|ha_MaxId
decl_stmt|;
comment|/* Maximum target ID */
name|u_int8_t
name|ha_MaxLun
decl_stmt|;
comment|/* Maximum target LUN */
name|u_int8_t
name|ha_SgSize
decl_stmt|;
comment|/* Max SG elements */
name|u_int8_t
name|ha_pciBusNum
decl_stmt|;
name|u_int8_t
name|ha_pciDeviceNum
decl_stmt|;
name|u_int8_t
name|ha_adapter_target
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|u_int16_t
name|ha_QueueSize
decl_stmt|;
comment|/* Max outstanding commands */
name|u_int16_t
name|ha_Msgs_Count
decl_stmt|;
comment|/* Links into other parents and HBAs */
name|struct
name|Asr_softc
modifier|*
name|ha_next
decl_stmt|;
comment|/* HBA list */
name|struct
name|cdev
modifier|*
name|ha_devt
decl_stmt|;
block|}
name|Asr_softc_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|Asr_softc_t
modifier|*
name|Asr_softc_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Prototypes of the routines we have in this object.  */
end_comment

begin_comment
comment|/* I2O HDM interface */
end_comment

begin_function_decl
specifier|static
name|int
name|asr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asr_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asr_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|ifmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asr_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ifmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|asr_intr
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asr_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ASR_init
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ASR_acquireLct
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ASR_acquireHrt
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|asr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ASR_queue
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *	Here is the auto-probe structure used to nest our tests appropriately  *	during the startup phase of the operating system.  */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|asr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|asr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|asr_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|asr_driver
init|=
block|{
literal|"asr"
block|,
name|asr_methods
block|,
expr|sizeof
operator|(
name|Asr_softc_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|asr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|asr
argument_list|,
name|pci
argument_list|,
name|asr_driver
argument_list|,
name|asr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|asr
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|asr
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * devsw for asr hba driver  *  * only ioctl is used. the sd driver provides all other access.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|asr_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|asr_open
block|,
operator|.
name|d_close
operator|=
name|asr_close
block|,
operator|.
name|d_ioctl
operator|=
name|asr_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"asr"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I2O support routines */
end_comment

begin_function
specifier|static
name|__inline
name|u_int32_t
name|asr_get_FromFIFO
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_FROMFIFO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|asr_get_ToFIFO
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_TOFIFO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|asr_get_intr
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_MASK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|asr_get_status
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_STATUS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|asr_set_FromFIFO
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_FROMFIFO
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|asr_set_ToFIFO
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_TOFIFO
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|asr_set_intr
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|ha_i2o_btag
argument_list|,
name|sc
operator|->
name|ha_i2o_bhandle
argument_list|,
name|I2O_REG_MASK
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|asr_set_frame
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|frame
parameter_list|,
name|u_int32_t
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|bus_space_write_region_4
argument_list|(
name|sc
operator|->
name|ha_frame_btag
argument_list|,
name|sc
operator|->
name|ha_frame_bhandle
argument_list|,
name|offset
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|frame
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Fill message with default.  */
end_comment

begin_function
specifier|static
name|PI2O_MESSAGE_FRAME
name|ASR_fillMessage
parameter_list|(
name|void
modifier|*
name|Message
parameter_list|,
name|u_int16_t
name|size
parameter_list|)
block|{
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|I2O_MESSAGE_FRAME
operator|*
operator|)
name|Message
expr_stmt|;
name|bzero
argument_list|(
name|Message_Ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|Message_Ptr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Message_Ptr == NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Message_Ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_fillMessage */
end_comment

begin_define
define|#
directive|define
name|EMPTY_QUEUE
value|(0xffffffff)
end_define

begin_function
specifier|static
name|__inline
name|U32
name|ASR_getMessage
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|U32
name|MessageOffset
decl_stmt|;
name|MessageOffset
operator|=
name|asr_get_ToFIFO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|MessageOffset
operator|==
name|EMPTY_QUEUE
condition|)
name|MessageOffset
operator|=
name|asr_get_ToFIFO
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|MessageOffset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getMessage */
end_comment

begin_comment
comment|/* Issue a polled command */
end_comment

begin_function
specifier|static
name|U32
name|ASR_initiateCp
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|U32
name|Mask
init|=
literal|0xffffffff
decl_stmt|;
name|U32
name|MessageOffset
decl_stmt|;
name|u_int
name|Delay
init|=
literal|1500
decl_stmt|;
comment|/* 	 * ASR_initiateCp is only used for synchronous commands and will 	 * be made more resiliant to adapter delays since commands like 	 * resetIOP can cause the adapter to be deaf for a little time. 	 */
while|while
condition|(
operator|(
operator|(
name|MessageOffset
operator|=
name|ASR_getMessage
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|EMPTY_QUEUE
operator|)
operator|&&
operator|(
operator|--
name|Delay
operator|!=
literal|0
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MessageOffset
operator|!=
name|EMPTY_QUEUE
condition|)
block|{
name|asr_set_frame
argument_list|(
name|sc
argument_list|,
name|Message
argument_list|,
name|MessageOffset
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 *	Disable the Interrupts 		 */
name|Mask
operator|=
name|asr_get_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|asr_set_intr
argument_list|(
name|sc
argument_list|,
name|Mask
operator||
name|Mask_InterruptsDisabled
argument_list|)
expr_stmt|;
name|asr_set_ToFIFO
argument_list|(
name|sc
argument_list|,
name|MessageOffset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_initiateCp */
end_comment

begin_comment
comment|/*  *	Reset the adapter.  */
end_comment

begin_function
specifier|static
name|U32
name|ASR_resetIOP
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|I2O_EXEC_IOP_RESET_MESSAGE
name|Message
decl_stmt|;
name|PI2O_EXEC_IOP_RESET_MESSAGE
name|Message_Ptr
decl_stmt|;
name|U32
modifier|*
name|Reply_Ptr
decl_stmt|;
name|U32
name|Old
decl_stmt|;
comment|/* 	 *  Build up our copy of the Message. 	 */
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_IOP_RESET_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_IOP_RESET_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_EXEC_IOP_RESET_MESSAGE_setFunction
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_EXEC_IOP_RESET
argument_list|)
expr_stmt|;
comment|/* 	 *  Reset the Reply Status 	 */
name|Reply_Ptr
operator|=
operator|&
name|sc
operator|->
name|ha_statusmem
operator|->
name|rstatus
expr_stmt|;
operator|*
name|Reply_Ptr
operator|=
literal|0
expr_stmt|;
name|I2O_EXEC_IOP_RESET_MESSAGE_setStatusWordLowAddress
argument_list|(
name|Message_Ptr
argument_list|,
name|sc
operator|->
name|ha_rstatus_phys
argument_list|)
expr_stmt|;
comment|/* 	 *	Send the Message out 	 */
if|if
condition|(
operator|(
name|Old
operator|=
name|ASR_initiateCp
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
comment|/* 		 * Wait for a response (Poll), timeouts are dangerous if 		 * the card is truly responsive. We assume response in 2s. 		 */
name|u_int8_t
name|Delay
init|=
literal|200
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|Reply_Ptr
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|--
name|Delay
operator|!=
literal|0
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Re-enable the interrupts. 		 */
name|asr_set_intr
argument_list|(
name|sc
argument_list|,
name|Old
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|Reply_Ptr
operator|!=
literal|0
argument_list|,
operator|(
literal|"*Reply_Ptr == 0"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|Reply_Ptr
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|Old
operator|!=
literal|0xffffffff
argument_list|,
operator|(
literal|"Old == -1"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_resetIOP */
end_comment

begin_comment
comment|/*  *	Get the curent state of the adapter  */
end_comment

begin_function
specifier|static
name|PI2O_EXEC_STATUS_GET_REPLY
name|ASR_getStatus
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|I2O_EXEC_STATUS_GET_MESSAGE
name|Message
decl_stmt|;
name|PI2O_EXEC_STATUS_GET_MESSAGE
name|Message_Ptr
decl_stmt|;
name|PI2O_EXEC_STATUS_GET_REPLY
name|buffer
decl_stmt|;
name|U32
name|Old
decl_stmt|;
comment|/* 	 *  Build up our copy of the Message. 	 */
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_STATUS_GET_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_EXEC_STATUS_GET_MESSAGE_setFunction
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_EXEC_STATUS_GET
argument_list|)
expr_stmt|;
name|I2O_EXEC_STATUS_GET_MESSAGE_setReplyBufferAddressLow
argument_list|(
name|Message_Ptr
argument_list|,
name|sc
operator|->
name|ha_status_phys
argument_list|)
expr_stmt|;
comment|/* This one is a Byte Count */
name|I2O_EXEC_STATUS_GET_MESSAGE_setReplyBufferLength
argument_list|(
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_REPLY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Reset the Reply Status 	 */
name|buffer
operator|=
operator|&
name|sc
operator|->
name|ha_statusmem
operator|->
name|status
expr_stmt|;
name|bzero
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_REPLY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *	Send the Message out 	 */
if|if
condition|(
operator|(
name|Old
operator|=
name|ASR_initiateCp
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
comment|/* 		 *	Wait for a response (Poll), timeouts are dangerous if 		 * the card is truly responsive. We assume response in 50ms. 		 */
name|u_int8_t
name|Delay
init|=
literal|255
decl_stmt|;
while|while
condition|(
operator|*
operator|(
operator|(
name|U8
operator|*
specifier|volatile
operator|)
operator|&
operator|(
name|buffer
operator|->
name|SyncByte
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|Delay
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Re-enable the interrupts. 		 */
name|asr_set_intr
argument_list|(
name|sc
argument_list|,
name|Old
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getStatus */
end_comment

begin_comment
comment|/*  *	Check if the device is a SCSI I2O HBA, and add it to the list.  */
end_comment

begin_comment
comment|/*  * Probe for ASR controller.  If we find it, we will use it.  * virtual adapters.  */
end_comment

begin_function
specifier|static
name|int
name|asr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int32_t
name|id
decl_stmt|;
name|id
operator|=
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|==
literal|0xA5011044
operator|)
operator|||
operator|(
name|id
operator|==
literal|0xA5111044
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Adaptec Caching SCSI RAID"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_probe */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|union
name|asr_ccb
operator|*
name|asr_alloc_ccb
argument_list|(
argument|Asr_softc_t *sc
argument_list|)
block|{
expr|union
name|asr_ccb
operator|*
name|new_ccb
block|;
if|if
condition|(
operator|(
name|new_ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|new_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|=
name|sc
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|new_ccb
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* asr_alloc_ccb */
end_comment

begin_function
unit|static
name|__inline
name|void
name|asr_free_ccb
parameter_list|(
name|union
name|asr_ccb
modifier|*
name|free_ccb
parameter_list|)
block|{
name|free
argument_list|(
name|free_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_free_ccb */
end_comment

begin_comment
comment|/*  *	Print inquiry data `carefully'  */
end_comment

begin_function
specifier|static
name|void
name|ASR_prstring
parameter_list|(
name|u_int8_t
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|--
name|len
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|s
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
operator|(
name|s
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ASR_prstring */
end_comment

begin_comment
comment|/*  *	Send a message synchronously and without Interrupt to a ccb.  */
end_comment

begin_function
specifier|static
name|int
name|ASR_queue_s
parameter_list|(
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|U32
name|Mask
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
operator|(
name|Asr_softc_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|)
decl_stmt|;
comment|/* 	 * We do not need any (optional byteswapping) method access to 	 * the Initiator context field. 	 */
name|I2O_MESSAGE_FRAME_setInitiatorContext64
argument_list|(
name|Message
argument_list|,
operator|(
name|long
operator|)
name|ccb
argument_list|)
expr_stmt|;
comment|/* Prevent interrupt service */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|Mask
operator|=
name|asr_get_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|asr_set_intr
argument_list|(
name|sc
argument_list|,
name|Mask
operator||
name|Mask_InterruptsDisabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_queue
argument_list|(
name|sc
argument_list|,
name|Message
argument_list|)
operator|==
name|EMPTY_QUEUE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
comment|/* 	 * Wait for this board to report a finished instruction. 	 */
while|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
operator|(
name|void
operator|)
name|asr_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable Interrupts */
name|asr_set_intr
argument_list|(
name|sc
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue_s */
end_comment

begin_comment
comment|/*  *	Send a message synchronously to an Asr_softc_t.  */
end_comment

begin_function
specifier|static
name|int
name|ASR_queue_c
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|asr_alloc_ccb
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|CAM_REQUEUE_REQ
operator|)
return|;
block|}
name|status
operator|=
name|ASR_queue_s
argument_list|(
name|ccb
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue_c */
end_comment

begin_comment
comment|/*  *	Add the specified ccb to the active queue  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ASR_ccbAdd
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|,
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|==
name|CAM_TIME_DEFAULT
condition|)
block|{
comment|/* 			 * RAID systems can take considerable time to 			 * complete some commands given the large cache 			 * flashes switching from write back to write thru. 			 */
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|6
operator|*
literal|60
operator|*
literal|1000
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASR_ccbAdd */
end_comment

begin_comment
comment|/*  *	Remove the specified ccb from the active queue.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ASR_ccbRemove
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|untimeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASR_ccbRemove */
end_comment

begin_comment
comment|/*  *	Fail all the active commands, so they get re-issued by the operating  *	system.  */
end_comment

begin_function
specifier|static
name|void
name|ASR_failActiveCommands
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 *	We do not need to inform the CAM layer that we had a bus 	 * reset since we manage it on our own, this also prevents the 	 * SCSI_DELAY settling that would be required on other systems. 	 * The `SCSI_DELAY' has already been handled by the card via the 	 * acquisition of the LCT table while we are at CAM priority level. 	 *  for (int bus = 0; bus<= sc->ha_MaxBus; ++bus) { 	 *	xpt_async (AC_BUS_RESET, sc->ha_path[bus], NULL); 	 *  } 	 */
while|while
condition|(
operator|(
name|ccb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ASR_ccbRemove
argument_list|(
name|sc
argument_list|,
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
comment|/* Nothing Transfered */
operator|(
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccb
operator|)
operator|->
name|resid
operator|=
operator|(
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccb
operator|)
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|path
condition|)
block|{
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wakeup
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASR_failActiveCommands */
end_comment

begin_comment
comment|/*  *	The following command causes the HBA to reset the specific bus  */
end_comment

begin_function
specifier|static
name|void
name|ASR_resetBus
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|)
block|{
name|I2O_HBA_BUS_RESET_MESSAGE
name|Message
decl_stmt|;
name|I2O_HBA_BUS_RESET_MESSAGE
modifier|*
name|Message_Ptr
decl_stmt|;
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|I2O_HBA_BUS_RESET_MESSAGE
operator|*
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_HBA_BUS_RESET_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
name|Message_Ptr
operator|->
name|StdMessageFrame
argument_list|,
name|I2O_HBA_BUS_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|Device
operator|->
name|le_type
operator|&
name|I2O_PORT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|==
name|bus
operator|)
condition|)
block|{
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
operator|&
name|Message_Ptr
operator|->
name|StdMessageFrame
argument_list|,
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Asynchronous command, with no expectations */
operator|(
name|void
operator|)
name|ASR_queue
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ASR_resetBus */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ASR_getBlinkLedCode
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|U8
name|blink
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|blink
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|ha_frame_btag
argument_list|,
name|sc
operator|->
name|ha_frame_bhandle
argument_list|,
name|sc
operator|->
name|ha_blinkLED
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|blink
operator|!=
literal|0xBC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|blink
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|ha_frame_btag
argument_list|,
name|sc
operator|->
name|ha_frame_bhandle
argument_list|,
name|sc
operator|->
name|ha_blinkLED
argument_list|)
expr_stmt|;
return|return
operator|(
name|blink
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getBlinkCode */
end_comment

begin_comment
comment|/*  *	Determine the address of an TID lookup. Must be done at high priority  *	since the address can be changed by other threads of execution.  *  *	Returns NULL pointer if not indexible (but will attempt to generate  *	an index if `new_entry' flag is set to TRUE).  *  *	All addressible entries are to be guaranteed zero if never initialized.  */
end_comment

begin_function
specifier|static
name|tid_t
modifier|*
name|ASR_getTidAddress
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|new_entry
parameter_list|)
block|{
name|target2lun_t
modifier|*
name|bus_ptr
decl_stmt|;
name|lun2tid_t
modifier|*
name|target_ptr
decl_stmt|;
name|unsigned
name|new_size
decl_stmt|;
comment|/* 	 *	Validity checking of incoming parameters. More of a bound 	 * expansion limit than an issue with the code dealing with the 	 * values. 	 * 	 *	sc must be valid before it gets here, so that check could be 	 * dropped if speed a critical issue. 	 */
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|bus
operator|>
name|MAX_CHANNEL
operator|)
operator|||
operator|(
name|target
operator|>
name|sc
operator|->
name|ha_MaxId
operator|)
operator|||
operator|(
name|lun
operator|>
name|sc
operator|->
name|ha_MaxLun
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"(%lx,%d,%d,%d) target out of range\n"
argument_list|,
operator|(
name|u_long
operator|)
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 *	See if there is an associated bus list. 	 * 	 *	for performance, allocate in size of BUS_CHUNK chunks. 	 *	BUS_CHUNK must be a power of two. This is to reduce 	 *	fragmentation effects on the allocations. 	 */
define|#
directive|define
name|BUS_CHUNK
value|8
name|new_size
operator|=
operator|(
operator|(
name|target
operator|+
name|BUS_CHUNK
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|BUS_CHUNK
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bus_ptr
operator|=
name|sc
operator|->
name|ha_targets
index|[
name|bus
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 *	Allocate a new structure? 		 *		Since one element in structure, the +1 		 *		needed for size has been abstracted. 		 */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|sc
operator|->
name|ha_targets
index|[
name|bus
index|]
operator|=
name|bus_ptr
operator|=
operator|(
name|target2lun_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bus_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bus_ptr
operator|->
name|LUN
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to allocate bus list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bus_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bus_ptr
operator|->
name|size
operator|<=
name|new_size
condition|)
block|{
name|target2lun_t
modifier|*
name|new_bus_ptr
decl_stmt|;
comment|/* 		 *	Reallocate a new structure? 		 *		Since one element in structure, the +1 		 *		needed for size has been abstracted. 		 */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|new_bus_ptr
operator|=
operator|(
name|target2lun_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bus_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bus_ptr
operator|->
name|LUN
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to reallocate bus list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 *	Copy the whole thing, safer, simpler coding 		 * and not really performance critical at this point. 		 */
name|bcopy
argument_list|(
name|bus_ptr
argument_list|,
name|new_bus_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bus_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bus_ptr
operator|->
name|LUN
argument_list|)
operator|*
operator|(
name|bus_ptr
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_targets
index|[
name|bus
index|]
operator|=
name|new_bus_ptr
expr_stmt|;
name|free
argument_list|(
name|bus_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|bus_ptr
operator|=
name|new_bus_ptr
expr_stmt|;
name|bus_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 *	We now have the bus list, lets get to the target list. 	 *	Since most systems have only *one* lun, we do not allocate 	 *	in chunks as above, here we allow one, then in chunk sizes. 	 *	TARGET_CHUNK must be a power of two. This is to reduce 	 *	fragmentation effects on the allocations. 	 */
define|#
directive|define
name|TARGET_CHUNK
value|8
if|if
condition|(
operator|(
name|new_size
operator|=
name|lun
operator|)
operator|!=
literal|0
condition|)
block|{
name|new_size
operator|=
operator|(
operator|(
name|lun
operator|+
name|TARGET_CHUNK
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|TARGET_CHUNK
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|target_ptr
operator|=
name|bus_ptr
operator|->
name|LUN
index|[
name|target
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 *	Allocate a new structure? 		 *		Since one element in structure, the +1 		 *		needed for size has been abstracted. 		 */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|bus_ptr
operator|->
name|LUN
index|[
name|target
index|]
operator|=
name|target_ptr
operator|=
operator|(
name|lun2tid_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|target_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|target_ptr
operator|->
name|TID
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to allocate target list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|target_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_ptr
operator|->
name|size
operator|<=
name|new_size
condition|)
block|{
name|lun2tid_t
modifier|*
name|new_target_ptr
decl_stmt|;
comment|/* 		 *	Reallocate a new structure? 		 *		Since one element in structure, the +1 		 *		needed for size has been abstracted. 		 */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|new_target_ptr
operator|=
operator|(
name|lun2tid_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|target_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|target_ptr
operator|->
name|TID
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to reallocate target list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 *	Copy the whole thing, safer, simpler coding 		 * and not really performance critical at this point. 		 */
name|bcopy
argument_list|(
name|target_ptr
argument_list|,
name|new_target_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|target_ptr
operator|->
name|TID
argument_list|)
operator|*
operator|(
name|target_ptr
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|bus_ptr
operator|->
name|LUN
index|[
name|target
index|]
operator|=
name|new_target_ptr
expr_stmt|;
name|free
argument_list|(
name|target_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|target_ptr
operator|=
name|new_target_ptr
expr_stmt|;
name|target_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 	 *	Now, acquire the TID address from the LUN indexed list. 	 */
return|return
operator|(
operator|&
operator|(
name|target_ptr
operator|->
name|TID
index|[
name|lun
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getTidAddress */
end_comment

begin_comment
comment|/*  *	Get a pre-existing TID relationship.  *  *	If the TID was never set, return (tid_t)-1.  *  *	should use mutex rather than spl.  */
end_comment

begin_function
specifier|static
name|__inline
name|tid_t
name|ASR_getTid
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|tid_t
modifier|*
name|tid_ptr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tid_t
name|retval
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tid_ptr
operator|=
name|ASR_getTidAddress
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
operator|)
comment|/* (tid_t)0 or (tid_t)-1 indicate no TID */
operator|||
operator|(
operator|*
name|tid_ptr
operator|==
operator|(
name|tid_t
operator|)
literal|0
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|retval
operator|=
operator|*
name|tid_ptr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getTid */
end_comment

begin_comment
comment|/*  *	Set a TID relationship.  *  *	If the TID was not set, return (tid_t)-1.  *  *	should use mutex rather than spl.  */
end_comment

begin_function
specifier|static
name|__inline
name|tid_t
name|ASR_setTid
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|tid_t
name|TID
parameter_list|)
block|{
name|tid_t
modifier|*
name|tid_ptr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|TID
operator|!=
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TID
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tid_ptr
operator|=
name|ASR_getTidAddress
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|tid_ptr
operator|=
name|TID
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TID
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_setTid */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*		      Function ASR_rescan				   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The Parameters Passed To This Function Are :				   */
end_comment

begin_comment
comment|/*     Asr_softc_t *	 : HBA miniport driver's adapter data storage.	   */
end_comment

begin_comment
comment|/*									   */
end_comment

begin_comment
comment|/* This Function Will rescan the adapter and resynchronize any data	   */
end_comment

begin_comment
comment|/*									   */
end_comment

begin_comment
comment|/* Return : 0 For OK, Error Code Otherwise				   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ASR_rescan
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|bus
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Re-acquire the LCT table and synchronize us to the adapter. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ASR_acquireLct
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ASR_acquireHrt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|bus
operator|=
name|sc
operator|->
name|ha_MaxBus
expr_stmt|;
comment|/* Reset all existing cached TID lookups */
do|do
block|{
name|int
name|target
decl_stmt|,
name|event
init|=
literal|0
decl_stmt|;
comment|/* 		 *	Scan for all targets on this bus to see if they 		 * got affected by the rescan. 		 */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|sc
operator|->
name|ha_MaxId
condition|;
operator|++
name|target
control|)
block|{
name|int
name|lun
decl_stmt|;
comment|/* Stay away from the controller ID */
if|if
condition|(
name|target
operator|==
name|sc
operator|->
name|ha_adapter_target
index|[
name|bus
index|]
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<=
name|sc
operator|->
name|ha_MaxLun
condition|;
operator|++
name|lun
control|)
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|tid_t
name|TID
init|=
operator|(
name|tid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|tid_t
name|LastTID
decl_stmt|;
comment|/* 				 * See if the cached TID changed. Search for 				 * the device in our new LCT. 				 */
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
operator|(
name|Device
operator|->
name|le_type
operator|!=
name|I2O_UNKNOWN
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_target
operator|==
name|target
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_lun
operator|==
name|lun
operator|)
operator|&&
operator|(
name|I2O_LCT_ENTRY_getUserTID
argument_list|(
name|Device
argument_list|)
operator|==
literal|0xFFF
operator|)
condition|)
block|{
name|TID
operator|=
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 				 * Indicate to the OS that the label needs 				 * to be recalculated, or that the specific 				 * open device is no longer valid (Merde) 				 * because the cached TID changed. 				 */
name|LastTID
operator|=
name|ASR_getTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|LastTID
operator|!=
name|TID
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|)
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|TID
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|event
operator||=
name|AC_LOST_DEVICE
expr_stmt|;
block|}
else|else
block|{
name|event
operator||=
name|AC_INQ_CHANGED
operator||
name|AC_GETDEV_CHANGED
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TID
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LastTID
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|struct
name|ccb_getdev
name|ccb
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
operator|(
name|ccb
operator|.
name|ccb_h
operator|)
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_FOUND_DEVICE
argument_list|,
name|path
argument_list|,
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_async
argument_list|(
name|AC_INQ_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_GETDEV_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 				 *	We have the option of clearing the 				 * cached TID for it to be rescanned, or to 				 * set it now even if the device never got 				 * accessed. We chose the later since we 				 * currently do not use the condition that 				 * the TID ever got cached. 				 */
name|ASR_setTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|TID
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 *	The xpt layer can not handle multiple events at the 		 * same call. 		 */
if|if
condition|(
name|event
operator|&
name|AC_LOST_DEVICE
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|&
name|AC_INQ_CHANGED
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_INQ_CHANGED
argument_list|,
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|&
name|AC_GETDEV_CHANGED
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_GETDEV_CHANGED
argument_list|,
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|bus
operator|>=
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_rescan */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*		      Function ASR_reset				   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The Parameters Passed To This Function Are :				   */
end_comment

begin_comment
comment|/*     Asr_softc_t *	  : HBA miniport driver's adapter data storage.	   */
end_comment

begin_comment
comment|/*									   */
end_comment

begin_comment
comment|/* This Function Will reset the adapter and resynchronize any data	   */
end_comment

begin_comment
comment|/*									   */
end_comment

begin_comment
comment|/* Return : None							   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ASR_reset
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|retVal
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_in_reset
operator|==
name|HA_IN_RESET
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_in_reset
operator|==
name|HA_OFF_LINE_RECOVERY
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 	 *	Promotes HA_OPERATIONAL to HA_IN_RESET, 	 * or HA_OFF_LINE to HA_OFF_LINE_RECOVERY. 	 */
operator|++
operator|(
name|sc
operator|->
name|ha_in_reset
operator|)
expr_stmt|;
if|if
condition|(
name|ASR_resetIOP
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"ASR_resetIOP failed\n"
argument_list|)
expr_stmt|;
comment|/* 		 *	We really need to take this card off-line, easier said 		 * than make sense. Better to keep retrying for now since if a 		 * UART cable is connected the blinkLEDs the adapter is now in 		 * a hard state requiring action from the monitor commands to 		 * the HBA to continue. For debugging waiting forever is a 		 * good thing. In a production system, however, one may wish 		 * to instead take the card off-line ... 		 */
comment|/* Wait Forever */
while|while
condition|(
name|ASR_resetIOP
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
name|retVal
operator|=
name|ASR_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|!=
literal|0
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"ASR_init failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_in_reset
operator|=
name|HA_OFF_LINE
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ASR_rescan
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"ASR_rescan failed\n"
argument_list|)
expr_stmt|;
block|}
name|ASR_failActiveCommands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_in_reset
operator|==
name|HA_OFF_LINE_RECOVERY
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d: Brining adapter back on-line\n"
argument_list|,
name|sc
operator|->
name|ha_path
index|[
literal|0
index|]
condition|?
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|sc
operator|->
name|ha_path
index|[
literal|0
index|]
argument_list|)
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ha_in_reset
operator|=
name|HA_OPERATIONAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_reset */
end_comment

begin_comment
comment|/*  *	Device timeout handler.  */
end_comment

begin_function
specifier|static
name|void
name|asr_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|arg
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
operator|(
name|Asr_softc_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|debug_asr_print_path
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|debug_asr_printf
argument_list|(
literal|"timed out"
argument_list|)
expr_stmt|;
comment|/* 	 *	Check if the adapter has locked up? 	 */
if|if
condition|(
operator|(
name|s
operator|=
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Reset Adapter */
name|printf
argument_list|(
literal|"asr%d: Blink LED 0x%x resetting adapter\n"
argument_list|,
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|==
name|ENXIO
condition|)
block|{
comment|/* Try again later */
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 *	Abort does not function on the ASR card!!! Walking away from 	 * the SCSI command is also *very* dangerous. A SCSI BUS reset is 	 * our best bet, followed by a complete adapter reset if that fails. 	 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* Check if we already timed out once to raise the issue */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_CMD_TIMEOUT
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|" AGAIN\nreinitializing adapter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|==
name|ENXIO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug_asr_printf
argument_list|(
literal|"\nresetting bus\n"
argument_list|)
expr_stmt|;
comment|/* If the BUS reset does not take, then an adapter reset is next! */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ASR_resetBus
argument_list|(
name|sc
argument_list|,
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_timeout */
end_comment

begin_comment
comment|/*  * send a message asynchronously  */
end_comment

begin_function
specifier|static
name|int
name|ASR_queue
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|U32
name|MessageOffset
decl_stmt|;
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|debug_asr_printf
argument_list|(
literal|"Host Command Dump:\n"
argument_list|)
expr_stmt|;
name|debug_asr_dump_message
argument_list|(
name|Message
argument_list|)
expr_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
operator|(
name|long
operator|)
name|I2O_MESSAGE_FRAME_getInitiatorContext64
argument_list|(
name|Message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MessageOffset
operator|=
name|ASR_getMessage
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|EMPTY_QUEUE
condition|)
block|{
name|asr_set_frame
argument_list|(
name|sc
argument_list|,
name|Message
argument_list|,
name|MessageOffset
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
name|ASR_ccbAdd
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* Post the command */
name|asr_set_ToFIFO
argument_list|(
name|sc
argument_list|,
name|MessageOffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* 			 *	Unlikely we can do anything if we can't grab a 			 * message frame :-(, but lets give it a try. 			 */
operator|(
name|void
operator|)
name|ASR_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|MessageOffset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue */
end_comment

begin_comment
comment|/* Simple Scatter Gather elements */
end_comment

begin_define
define|#
directive|define
name|SG
parameter_list|(
name|SGL
parameter_list|,
name|Index
parameter_list|,
name|Flags
parameter_list|,
name|Buffer
parameter_list|,
name|Size
parameter_list|)
define|\
value|I2O_FLAGS_COUNT_setCount(				   \&(((PI2O_SG_ELEMENT)(SGL))->u.Simple[Index].FlagsCount), \ 	  Size);						   \ 	I2O_FLAGS_COUNT_setFlags(				   \&(((PI2O_SG_ELEMENT)(SGL))->u.Simple[Index].FlagsCount), \ 	  I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT | (Flags));	   \ 	I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress(		   \&(((PI2O_SG_ELEMENT)(SGL))->u.Simple[Index]),		   \ 	  (Buffer == NULL) ? 0 : KVTOPHYS(Buffer))
end_define

begin_comment
comment|/*  *	Retrieve Parameter Group.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ASR_getParams
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|tid_t
name|TID
parameter_list|,
name|int
name|Group
parameter_list|,
name|void
modifier|*
name|Buffer
parameter_list|,
name|unsigned
name|BufferSize
parameter_list|)
block|{
struct|struct
name|paramGetMessage
block|{
name|I2O_UTIL_PARAMS_GET_MESSAGE
name|M
decl_stmt|;
name|char
name|F
index|[
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
index|]
decl_stmt|;
struct|struct
name|Operations
block|{
name|I2O_PARAM_OPERATIONS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE
name|Template
index|[
literal|1
index|]
decl_stmt|;
block|}
name|O
struct|;
block|}
name|Message
struct|;
name|struct
name|Operations
modifier|*
name|Operations_Ptr
decl_stmt|;
name|I2O_UTIL_PARAMS_GET_MESSAGE
modifier|*
name|Message_Ptr
decl_stmt|;
struct|struct
name|ParamBuffer
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|char
name|Info
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|Buffer_Ptr
struct|;
name|Message_Ptr
operator|=
operator|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
operator|*
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|Operations_Ptr
operator|=
operator|(
expr|struct
name|Operations
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
sizeof|sizeof
argument_list|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|Operations_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Operations
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATIONS_LIST_HEADER_setOperationCount
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Header
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE_setOperation
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Template
index|[
literal|0
index|]
operator|)
argument_list|,
name|I2O_PARAMS_OPERATION_FIELD_GET
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE_setFieldCount
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Template
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE_setGroupNumber
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Template
index|[
literal|0
index|]
operator|)
argument_list|,
name|Group
argument_list|)
expr_stmt|;
name|Buffer_Ptr
operator|=
operator|(
expr|struct
name|ParamBuffer
operator|*
operator|)
name|Buffer
expr_stmt|;
name|bzero
argument_list|(
name|Buffer_Ptr
argument_list|,
name|BufferSize
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_UTIL_PARAMS_GET
argument_list|)
expr_stmt|;
comment|/* 	 *  Set up the buffers as scatter gather elements. 	 */
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|Operations_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Operations
argument_list|)
argument_list|)
expr_stmt|;
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|1
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|Buffer_Ptr
argument_list|,
name|BufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|Buffer_Ptr
operator|->
name|Header
operator|.
name|ResultCount
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|Buffer_Ptr
operator|->
name|Info
operator|)
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getParams */
end_comment

begin_comment
comment|/*  *	Acquire the LCT information.  */
end_comment

begin_function
specifier|static
name|int
name|ASR_acquireLct
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
name|Message_Ptr
decl_stmt|;
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
name|int
name|MessageSizeInBytes
decl_stmt|;
name|caddr_t
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
name|I2O_LCT
name|Table
decl_stmt|;
name|PI2O_LCT_ENTRY
name|Entry
decl_stmt|;
comment|/* 	 *	sc value assumed valid 	 */
name|MessageSizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|I2O_EXEC_LCT_NOTIFY_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ASR_fillMessage
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Message_Ptr
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
operator|(
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_LCT_NOTIFY_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_LCT_NOTIFY
argument_list|)
expr_stmt|;
name|I2O_EXEC_LCT_NOTIFY_MESSAGE_setClassIdentifier
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_CLASS_MATCH_ANYCLASS
argument_list|)
expr_stmt|;
comment|/* 	 *	Call the LCT table to determine the number of device entries 	 * to reserve space for. 	 */
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
operator|&
name|Table
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *	since this code is reused in several systems, code efficiency 	 * is greater by using a shift operation rather than a divide by 	 * sizeof(u_int32_t). 	 */
name|I2O_LCT_setTableSize
argument_list|(
operator|&
name|Table
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_LCT_ENTRY
argument_list|)
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
comment|/* 	 *	Determine the size of the LCT table. 	 */
if|if
condition|(
name|sc
operator|->
name|ha_LCT
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	malloc only generates contiguous memory when less than a 	 * page is expected. We must break the request up into an SG list ... 	 */
if|if
condition|(
operator|(
operator|(
name|len
operator|=
operator|(
name|I2O_LCT_getTableSize
argument_list|(
operator|&
name|Table
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|<=
operator|(
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_LCT_ENTRY
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|len
operator|>
operator|(
literal|128
operator|*
literal|1024
operator|)
operator|)
condition|)
block|{
comment|/* Arbitrary */
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_LCT
operator|=
operator|(
name|PI2O_LCT
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 *	since this code is reused in several systems, code efficiency 	 * is greater by using a shift operation rather than a divide by 	 * sizeof(u_int32_t). 	 */
name|I2O_LCT_setTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_LCT_ENTRY
argument_list|)
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 *	Convert the access to the LCT table into a SG list. 	 */
name|sg
operator|=
name|Message_Ptr
operator|->
name|SGL
operator|.
name|u
operator|.
name|Simple
expr_stmt|;
name|v
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|next
decl_stmt|,
name|base
decl_stmt|,
name|span
decl_stmt|;
name|span
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress
argument_list|(
name|sg
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* How far can we go contiguously */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|base
operator|==
name|next
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
name|next
operator|=
name|trunc_page
argument_list|(
name|base
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|next
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
name|size
operator|=
name|len
expr_stmt|;
block|}
name|span
operator|+=
name|size
expr_stmt|;
name|v
operator|+=
name|size
expr_stmt|;
name|len
operator|-=
name|size
expr_stmt|;
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the Flags */
name|I2O_FLAGS_COUNT_setCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
block|{
name|int
name|rw
init|=
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|rw
operator|=
operator|(
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
operator||
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
operator|)
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|rw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
comment|/* 		 * Incrementing requires resizing of the packet. 		 */
operator|++
name|sg
expr_stmt|;
name|MessageSizeInBytes
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|{
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
name|NewMessage_Ptr
decl_stmt|;
if|if
condition|(
operator|(
name|NewMessage_Ptr
operator|=
operator|(
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_LCT
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|span
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|sg
operator|)
operator|-
operator|(
name|caddr_t
operator|)
name|Message_Ptr
expr_stmt|;
name|bcopy
argument_list|(
name|Message_Ptr
argument_list|,
name|NewMessage_Ptr
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
operator|)
operator|+
name|span
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|=
name|NewMessage_Ptr
expr_stmt|;
block|}
block|}
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
comment|/* If the LCT table grew, lets truncate accesses */
if|if
condition|(
name|I2O_LCT_getTableSize
argument_list|(
operator|&
name|Table
argument_list|)
operator|<
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
condition|)
block|{
name|I2O_LCT_setTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
name|I2O_LCT_getTableSize
argument_list|(
operator|&
name|Table
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Entry
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Entry
control|)
block|{
name|Entry
operator|->
name|le_type
operator|=
name|I2O_UNKNOWN
expr_stmt|;
switch|switch
condition|(
name|I2O_CLASS_ID_getClass
argument_list|(
operator|&
operator|(
name|Entry
operator|->
name|ClassID
operator|)
argument_list|)
condition|)
block|{
case|case
name|I2O_CLASS_RANDOM_BLOCK_STORAGE
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_BSA
expr_stmt|;
break|break;
case|case
name|I2O_CLASS_SCSI_PERIPHERAL
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_SCSI
expr_stmt|;
break|break;
case|case
name|I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_FCA
expr_stmt|;
break|break;
case|case
name|I2O_CLASS_BUS_ADAPTER_PORT
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_PORT
operator||
name|I2O_SCSI
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|I2O_CLASS_FIBRE_CHANNEL_PORT
case|:
if|if
condition|(
name|I2O_CLASS_ID_getClass
argument_list|(
operator|&
operator|(
name|Entry
operator|->
name|ClassID
operator|)
argument_list|)
operator|==
name|I2O_CLASS_FIBRE_CHANNEL_PORT
condition|)
block|{
name|Entry
operator|->
name|le_type
operator|=
name|I2O_PORT
operator||
name|I2O_FCA
expr_stmt|;
block|}
block|{
struct|struct
name|ControllerInfo
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
name|Info
decl_stmt|;
block|}
name|Buffer
struct|;
name|PI2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
name|Info
decl_stmt|;
name|Entry
operator|->
name|le_bus
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_target
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|Info
operator|=
operator|(
name|PI2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
operator|)
name|ASR_getParams
argument_list|(
name|sc
argument_list|,
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Entry
argument_list|)
argument_list|,
name|I2O_HBA_SCSI_CONTROLLER_INFO_GROUP_NO
argument_list|,
operator|&
name|Buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ControllerInfo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|Entry
operator|->
name|le_target
operator|=
name|I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR_getInitiatorID
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
literal|0
expr_stmt|;
block|}
comment|/* FALLTHRU */
default|default:
continue|continue;
block|}
block|{
struct|struct
name|DeviceInfo
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|I2O_DPT_DEVICE_INFO_SCALAR
name|Info
decl_stmt|;
block|}
name|Buffer
struct|;
name|PI2O_DPT_DEVICE_INFO_SCALAR
name|Info
decl_stmt|;
name|Entry
operator|->
name|le_bus
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_target
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|Info
operator|=
operator|(
name|PI2O_DPT_DEVICE_INFO_SCALAR
operator|)
name|ASR_getParams
argument_list|(
name|sc
argument_list|,
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Entry
argument_list|)
argument_list|,
name|I2O_DPT_DEVICE_INFO_GROUP_NO
argument_list|,
operator|&
name|Buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|DeviceInfo
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|Entry
operator|->
name|le_type
operator||=
name|I2O_DPT_DEVICE_INFO_SCALAR_getDeviceType
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|Entry
operator|->
name|le_bus
operator|=
name|I2O_DPT_DEVICE_INFO_SCALAR_getBus
argument_list|(
name|Info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Entry
operator|->
name|le_bus
operator|>
name|sc
operator|->
name|ha_MaxBus
operator|)
operator|&&
operator|(
name|Entry
operator|->
name|le_bus
operator|<=
name|MAX_CHANNEL
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_MaxBus
operator|=
name|Entry
operator|->
name|le_bus
expr_stmt|;
block|}
name|Entry
operator|->
name|le_target
operator|=
name|I2O_DPT_DEVICE_INFO_SCALAR_getIdentifier
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
name|I2O_DPT_DEVICE_INFO_SCALAR_getLunInfo
argument_list|(
name|Info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 *	A zero return value indicates success. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_acquireLct */
end_comment

begin_comment
comment|/*  * Initialize a message frame.  * We assume that the CDB has already been set up, so all we do here is  * generate the Scatter Gather list.  */
end_comment

begin_function
specifier|static
name|PI2O_MESSAGE_FRAME
name|ASR_init_message
parameter_list|(
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
operator|(
name|Asr_softc_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|)
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|len
decl_stmt|;
name|caddr_t
name|v
decl_stmt|;
name|U32
name|MessageSize
decl_stmt|;
name|int
name|next
decl_stmt|,
name|span
decl_stmt|,
name|base
decl_stmt|,
name|rw
decl_stmt|;
name|int
name|target
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|int
name|lun
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
decl_stmt|;
name|int
name|bus
init|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
decl_stmt|;
name|tid_t
name|TID
decl_stmt|;
comment|/* We only need to zero out the PRIVATE_SCSI_SCB_EXECUTE_MESSAGE */
name|Message_Ptr
operator|=
operator|(
name|I2O_MESSAGE_FRAME
operator|*
operator|)
name|Message
expr_stmt|;
name|bzero
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TID
operator|=
name|ASR_getTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|TID
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
operator|(
name|Device
operator|->
name|le_type
operator|!=
name|I2O_UNKNOWN
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_target
operator|==
name|target
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_lun
operator|==
name|lun
operator|)
operator|&&
operator|(
name|I2O_LCT_ENTRY_getUserTID
argument_list|(
name|Device
argument_list|)
operator|==
literal|0xFFF
operator|)
condition|)
block|{
name|TID
operator|=
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
expr_stmt|;
name|ASR_setTid
argument_list|(
name|sc
argument_list|,
name|Device
operator|->
name|le_bus
argument_list|,
name|Device
operator|->
name|le_target
argument_list|,
name|Device
operator|->
name|le_lun
argument_list|,
name|TID
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|TID
operator|==
operator|(
name|tid_t
operator|)
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setTID
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
operator||
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_PRIVATE_MESSAGE
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setXFunctionCode
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCSI_SCB_EXEC
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
argument_list|)
expr_stmt|;
comment|/* 	 * We do not need any (optional byteswapping) method access to 	 * the Initiator& Transaction context field. 	 */
name|I2O_MESSAGE_FRAME_setInitiatorContext64
argument_list|(
name|Message
argument_list|,
operator|(
name|long
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setOrganizationID
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|DPT_ORGANIZATION_ID
argument_list|)
expr_stmt|;
comment|/* 	 * copy the cdb over 	 */
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setCDBLength
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|)
argument_list|,
operator|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
operator|)
operator|->
name|CDB
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
comment|/* 	 * Given a buffer describing a transfer, set up a scatter/gather map 	 * in a ccb to map that SCSI transfer. 	 */
name|rw
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
literal|0
else|:
name|I2O_SGL_FLAGS_DIR
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
operator|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|)
condition|?
operator|(
operator|(
name|rw
operator|)
condition|?
operator|(
name|I2O_SCB_FLAG_XFER_TO_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
else|:
operator|(
name|I2O_SCB_FLAG_XFER_FROM_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
operator|)
else|:
operator|(
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Given a transfer described by a `data', fill in the SG list. 	 */
name|sg
operator|=
operator|&
operator|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
operator|)
operator|->
name|SGL
operator|.
name|u
operator|.
name|Simple
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|v
operator|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|KASSERT
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>=
literal|0
argument_list|,
operator|(
literal|"csio.dxfer_len< 0"
operator|)
argument_list|)
expr_stmt|;
name|MessageSize
operator|=
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setByteCount
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sg
operator|<
operator|&
operator|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
operator|)
operator|->
name|SGL
operator|.
name|u
operator|.
name|Simple
index|[
name|SG_SIZE
index|]
operator|)
condition|)
block|{
name|span
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress
argument_list|(
name|sg
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* How far can we go contiguously */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|base
operator|==
name|next
operator|)
condition|)
block|{
name|next
operator|=
name|trunc_page
argument_list|(
name|base
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|next
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
name|size
operator|=
name|len
expr_stmt|;
block|}
name|span
operator|+=
name|size
expr_stmt|;
name|v
operator|+=
name|size
expr_stmt|;
name|len
operator|-=
name|size
expr_stmt|;
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|rw
operator||=
name|I2O_SGL_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
operator||
name|rw
argument_list|)
expr_stmt|;
operator|++
name|sg
expr_stmt|;
name|MessageSize
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
expr_stmt|;
block|}
comment|/* We always do the request sense ... */
if|if
condition|(
operator|(
name|span
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|)
operator|==
literal|0
condition|)
block|{
name|span
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
expr_stmt|;
block|}
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
name|MessageSize
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Message_Ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_init_message */
end_comment

begin_comment
comment|/*  *	Reset the adapter.  */
end_comment

begin_function
specifier|static
name|U32
name|ASR_initOutBound
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
struct|struct
name|initOutBoundMessage
block|{
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE
name|M
decl_stmt|;
name|U32
name|R
decl_stmt|;
block|}
name|Message
struct|;
name|PI2O_EXEC_OUTBOUND_INIT_MESSAGE
name|Message_Ptr
decl_stmt|;
name|U32
modifier|*
specifier|volatile
name|Reply_Ptr
decl_stmt|;
name|U32
name|Old
decl_stmt|;
comment|/* 	 *  Build up our copy of the Message. 	 */
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_OUTBOUND_INIT_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_OUTBOUND_INIT
argument_list|)
expr_stmt|;
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE_setHostPageFrameSize
argument_list|(
name|Message_Ptr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE_setOutboundMFrameSize
argument_list|(
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Reset the Reply Status 	 */
operator|*
operator|(
name|Reply_Ptr
operator|=
operator|(
name|U32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
sizeof|sizeof
argument_list|(
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE
argument_list|)
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
argument_list|,
name|Reply_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *	Send the Message out 	 */
if|if
condition|(
operator|(
name|Old
operator|=
name|ASR_initiateCp
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
name|u_long
name|size
decl_stmt|,
name|addr
decl_stmt|;
comment|/* 		 *	Wait for a response (Poll). 		 */
while|while
condition|(
operator|*
name|Reply_Ptr
operator|<
name|I2O_EXEC_OUTBOUND_INIT_REJECTED
condition|)
empty_stmt|;
comment|/* 		 *	Re-enable the interrupts. 		 */
name|asr_set_intr
argument_list|(
name|sc
argument_list|,
name|Old
argument_list|)
expr_stmt|;
comment|/* 		 *	Populate the outbound table. 		 */
if|if
condition|(
name|sc
operator|->
name|ha_Msgs
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate the reply frames */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|*
name|sc
operator|->
name|ha_Msgs_Count
expr_stmt|;
comment|/* 			 *	contigmalloc only works reliably at 			 * initialization time. 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_Msgs
operator|=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|contigmalloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0ul
argument_list|,
literal|0xFFFFFFFFul
argument_list|,
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|,
literal|0ul
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|sc
operator|->
name|ha_Msgs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_Msgs_Phys
operator|=
name|KVTOPHYS
argument_list|(
name|sc
operator|->
name|ha_Msgs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize the outbound FIFO */
if|if
condition|(
name|sc
operator|->
name|ha_Msgs
operator|!=
name|NULL
condition|)
for|for
control|(
name|size
operator|=
name|sc
operator|->
name|ha_Msgs_Count
operator|,
name|addr
operator|=
name|sc
operator|->
name|ha_Msgs_Phys
init|;
name|size
condition|;
operator|--
name|size
control|)
block|{
name|asr_set_FromFIFO
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|Reply_Ptr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_initOutBound */
end_comment

begin_comment
comment|/*  *	Set the system table  */
end_comment

begin_function
specifier|static
name|int
name|ASR_setSysTab
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|PI2O_EXEC_SYS_TAB_SET_MESSAGE
name|Message_Ptr
decl_stmt|;
name|PI2O_SET_SYSTAB_HEADER
name|SystemTable
decl_stmt|;
name|Asr_softc_t
modifier|*
name|ha
decl_stmt|;
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
name|int
name|retVal
decl_stmt|;
if|if
condition|(
operator|(
name|SystemTable
operator|=
operator|(
name|PI2O_SET_SYSTAB_HEADER
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_SET_SYSTAB_HEADER
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|ha
operator|=
name|Asr_softc_list
init|;
name|ha
condition|;
name|ha
operator|=
name|ha
operator|->
name|ha_next
control|)
block|{
operator|++
name|SystemTable
operator|->
name|NumberEntries
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_SYS_TAB_SET_MESSAGE
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_TAB_SET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|+
name|SystemTable
operator|->
name|NumberEntries
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|SystemTable
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ASR_fillMessage
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_TAB_SET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|+
name|SystemTable
operator|->
name|NumberEntries
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
operator|(
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_TAB_SET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_SYS_TAB_SET
argument_list|)
expr_stmt|;
comment|/* 	 *	Call the LCT table to determine the number of device entries 	 * to reserve space for. 	 *	since this code is reused in several systems, code efficiency 	 * is greater by using a shift operation rather than a divide by 	 * sizeof(u_int32_t). 	 */
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_DIR
argument_list|,
name|SystemTable
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_SET_SYSTAB_HEADER
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|sg
expr_stmt|;
for|for
control|(
name|ha
operator|=
name|Asr_softc_list
init|;
name|ha
condition|;
name|ha
operator|=
name|ha
operator|->
name|ha_next
control|)
block|{
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|ha
operator|->
name|ha_next
operator|)
condition|?
operator|(
name|I2O_SGL_FLAGS_DIR
operator|)
else|:
operator|(
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
operator|)
operator|)
argument_list|,
operator|&
operator|(
name|ha
operator|->
name|ha_SystemTable
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|ha_SystemTable
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|sg
expr_stmt|;
block|}
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SG
argument_list|(
name|sg
argument_list|,
literal|1
argument_list|,
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|SystemTable
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|retVal
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_setSysTab */
end_comment

begin_function
specifier|static
name|int
name|ASR_acquireHrt
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|I2O_EXEC_HRT_GET_MESSAGE
name|Message
decl_stmt|;
name|I2O_EXEC_HRT_GET_MESSAGE
modifier|*
name|Message_Ptr
decl_stmt|;
struct|struct
block|{
name|I2O_HRT
name|Header
decl_stmt|;
name|I2O_HRT_ENTRY
name|Entry
index|[
name|MAX_CHANNEL
index|]
decl_stmt|;
block|}
name|Hrt
struct|;
name|u_int8_t
name|NumberOfEntries
decl_stmt|;
name|PI2O_HRT_ENTRY
name|Entry
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|Hrt
argument_list|,
sizeof|sizeof
argument_list|(
name|Hrt
argument_list|)
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|=
operator|(
name|I2O_EXEC_HRT_GET_MESSAGE
operator|*
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_HRT_GET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
operator|(
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_HRT_GET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_HRT_GET
argument_list|)
expr_stmt|;
comment|/* 	 *  Set up the buffers as scatter gather elements. 	 */
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
operator|&
name|Hrt
argument_list|,
sizeof|sizeof
argument_list|(
name|Hrt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|NumberOfEntries
operator|=
name|I2O_HRT_getNumberEntries
argument_list|(
operator|&
name|Hrt
operator|.
name|Header
argument_list|)
operator|)
operator|>
operator|(
name|MAX_CHANNEL
operator|+
literal|1
operator|)
condition|)
block|{
name|NumberOfEntries
operator|=
name|MAX_CHANNEL
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|Entry
operator|=
name|Hrt
operator|.
name|Header
operator|.
name|HRTEntry
init|;
name|NumberOfEntries
operator|!=
literal|0
condition|;
operator|++
name|Entry
operator|,
operator|--
name|NumberOfEntries
control|)
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
operator|==
operator|(
name|I2O_HRT_ENTRY_getAdapterID
argument_list|(
name|Entry
argument_list|)
operator|&
literal|0xFFF
operator|)
condition|)
block|{
name|Device
operator|->
name|le_bus
operator|=
name|I2O_HRT_ENTRY_getAdapterID
argument_list|(
name|Entry
argument_list|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|Device
operator|->
name|le_bus
operator|>
name|sc
operator|->
name|ha_MaxBus
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|<=
name|MAX_CHANNEL
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_MaxBus
operator|=
name|Device
operator|->
name|le_bus
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_acquireHrt */
end_comment

begin_comment
comment|/*  *	Enable the adapter.  */
end_comment

begin_function
specifier|static
name|int
name|ASR_enableSys
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|I2O_EXEC_SYS_ENABLE_MESSAGE
name|Message
decl_stmt|;
name|PI2O_EXEC_SYS_ENABLE_MESSAGE
name|Message_Ptr
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_SYS_ENABLE_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_ENABLE_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_SYS_ENABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_enableSys */
end_comment

begin_comment
comment|/*  *	Perform the stages necessary to initialize the adapter  */
end_comment

begin_function
specifier|static
name|int
name|ASR_init
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ASR_initOutBound
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ASR_setSysTab
argument_list|(
name|sc
argument_list|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
name|ASR_enableSys
argument_list|(
name|sc
argument_list|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_init */
end_comment

begin_comment
comment|/*  *	Send a Synchronize Cache command to the target device.  */
end_comment

begin_function
specifier|static
name|void
name|ASR_sync
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|tid_t
name|TID
decl_stmt|;
comment|/* 	 * We will not synchronize the device when there are outstanding 	 * commands issued by the OS (this is due to a locked up device, 	 * as the OS normally would flush all outstanding commands before 	 * issuing a shutdown or an adapter reset). 	 */
if|if
condition|(
operator|(
name|sc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|TID
operator|=
name|ASR_getTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
operator|!=
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|TID
operator|!=
operator|(
name|tid_t
operator|)
literal|0
operator|)
condition|)
block|{
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
name|Message
decl_stmt|;
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
name|Message_Ptr
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|*
operator|)
operator|&
name|Message
expr_stmt|;
name|bzero
argument_list|(
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
operator||
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_PRIVATE_MESSAGE
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setXFunctionCode
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCSI_SCB_EXEC
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setTID
argument_list|(
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setOrganizationID
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|DPT_ORGANIZATION_ID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setCDBLength
argument_list|(
name|Message_Ptr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|0
index|]
operator|=
name|SYNCHRONIZE_CACHE
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|1
index|]
operator|=
operator|(
name|lun
operator|<<
literal|5
operator|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
name|I2O_SCB_FLAG_XFER_FROM_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ASR_synchronize
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<=
name|sc
operator|->
name|ha_MaxBus
condition|;
operator|++
name|bus
control|)
block|{
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|sc
operator|->
name|ha_MaxId
condition|;
operator|++
name|target
control|)
block|{
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<=
name|sc
operator|->
name|ha_MaxLun
condition|;
operator|++
name|lun
control|)
block|{
name|ASR_sync
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	Reset the HBA, targets and BUS.  *		Currently this resets *all* the SCSI busses.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|asr_hbareset
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ASR_synchronize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_hbareset */
end_comment

begin_comment
comment|/*  *	A reduced copy of the real pci_map_mem, incorporating the MAX_MAP  * limit and a reduction in error checking (in the pre 4.0 case).  */
end_comment

begin_function
specifier|static
name|int
name|asr_pci_map_mem
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|u_int32_t
name|p
decl_stmt|,
name|l
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * I2O specification says we must find first *memory* mapped BAR 	 */
for|for
control|(
name|rid
operator|=
literal|0
init|;
name|rid
operator|<
literal|4
condition|;
name|rid
operator|++
control|)
block|{
name|p
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_BAR
argument_list|(
name|rid
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
comment|/* 	 *	Give up? 	 */
if|if
condition|(
name|rid
operator|>=
literal|4
condition|)
block|{
name|rid
operator|=
literal|0
expr_stmt|;
block|}
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|rid
argument_list|)
expr_stmt|;
name|p
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
operator|-
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
operator|&
operator|~
literal|15
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|MAX_MAP
condition|)
block|{
name|l
operator|=
name|MAX_MAP
expr_stmt|;
block|}
comment|/* 	 * The 2005S Zero Channel RAID solution is not a perfect PCI 	 * citizen. It asks for 4MB on BAR0, and 0MB on BAR1, once 	 * enabled it rewrites the size of BAR0 to 2MB, sets BAR1 to 	 * BAR0+2MB and sets it's size to 2MB. The IOP registers are 	 * accessible via BAR0, the messaging registers are accessible 	 * via BAR1. If the subdevice code is 50 to 59 decimal. 	 */
name|s
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0xA5111044
condition|)
block|{
name|s
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|ADPTDOMINATOR_SUB_ID_START
operator|^
name|s
operator|)
operator|&
literal|0xF000FFFF
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ADPTDOMINATOR_SUB_ID_START
operator|<=
name|s
operator|)
operator|&&
operator|(
name|s
operator|<=
name|ADPTDOMINATOR_SUB_ID_END
operator|)
condition|)
block|{
name|l
operator|=
name|MAX_MAP
expr_stmt|;
comment|/* Conjoined BAR Raptor Daptor */
block|}
block|}
name|p
operator|&=
operator|~
literal|15
expr_stmt|;
name|sc
operator|->
name|ha_mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|l
argument_list|,
name|l
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_mem_res
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_Base
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ha_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_i2o_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ha_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_i2o_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ha_mem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0xA5111044
condition|)
block|{
comment|/* Split BAR Raptor Daptor */
if|if
condition|(
operator|(
name|rid
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|>=
name|PCIR_BAR
argument_list|(
literal|4
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
operator|-
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
operator|&
operator|~
literal|15
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|MAX_MAP
condition|)
block|{
name|l
operator|=
name|MAX_MAP
expr_stmt|;
block|}
name|p
operator|&=
operator|~
literal|15
expr_stmt|;
name|sc
operator|->
name|ha_mes_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|l
argument_list|,
name|l
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_mes_res
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_frame_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|ha_mes_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_frame_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|ha_mes_res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ha_frame_bhandle
operator|=
name|sc
operator|->
name|ha_i2o_bhandle
expr_stmt|;
name|sc
operator|->
name|ha_frame_btag
operator|=
name|sc
operator|->
name|ha_i2o_btag
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_pci_map_mem */
end_comment

begin_comment
comment|/*  *	A simplified copy of the real pci_map_int with additional  * registration requirements.  */
end_comment

begin_function
specifier|static
name|int
name|asr_pci_map_int
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|ha_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_irq_res
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|ha_irq_res
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|asr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|ha_intr
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_irq
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_INTLINE
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_pci_map_int */
end_comment

begin_function
specifier|static
name|void
name|asr_status_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|Asr_softc_t
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|sc
operator|=
operator|(
name|Asr_softc_t
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* XXX 	 * The status word can be at a 64-bit address, but the existing 	 * accessor macros simply cannot manipulate 64-bit addresses. 	 */
name|sc
operator|->
name|ha_status_phys
operator|=
operator|(
name|u_int32_t
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|Asr_status_mem
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_rstatus_phys
operator|=
operator|(
name|u_int32_t
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|Asr_status_mem
argument_list|,
name|rstatus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|asr_alloc_dma
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|ha_dev
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|ha_parent_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate parent DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|ha_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ha_statusmem
argument_list|)
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ha_statusmem
argument_list|)
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate status DMA tag\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ha_parent_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ha_statusmem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|ha_statusmem_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate status memory\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ha_parent_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|,
name|sc
operator|->
name|ha_statusmem_dmamap
argument_list|,
name|sc
operator|->
name|ha_statusmem
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ha_statusmem
argument_list|)
argument_list|,
name|asr_status_cb
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|asr_release_dma
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|ha_rstatus_phys
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|,
name|sc
operator|->
name|ha_statusmem_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_statusmem
operator|!=
name|NULL
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|,
name|sc
operator|->
name|ha_statusmem
argument_list|,
name|sc
operator|->
name|ha_statusmem_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_statusmem_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ha_statusmem_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_parent_dmat
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ha_parent_dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Attach the devices, and virtual devices to the driver list.  */
end_comment

begin_function
specifier|static
name|int
name|asr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PI2O_EXEC_STATUS_GET_REPLY
name|status
decl_stmt|;
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
decl_stmt|,
modifier|*
modifier|*
name|ha
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|iq
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|size
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|Asr_softc_list
operator|==
name|NULL
condition|)
block|{
comment|/* 		 *	Fixup the OS revision as saved in the dptsig for the 		 *	engine (dptioctl.h) to pick up. 		 */
name|bcopy
argument_list|(
name|osrelease
argument_list|,
operator|&
name|ASR_sig
operator|.
name|dsDescription
index|[
literal|16
index|]
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Initialize the software structure 	 */
name|LIST_INIT
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|)
expr_stmt|;
comment|/* Link us into the HA list */
for|for
control|(
name|ha
operator|=
operator|&
name|Asr_softc_list
init|;
operator|*
name|ha
condition|;
name|ha
operator|=
operator|&
operator|(
operator|(
operator|*
name|ha
operator|)
operator|->
name|ha_next
operator|)
control|)
empty_stmt|;
operator|*
operator|(
name|ha
operator|)
operator|=
name|sc
expr_stmt|;
comment|/* 	 *	This is the real McCoy! 	 */
if|if
condition|(
operator|!
name|asr_pci_map_mem
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Enable if not formerly enabled */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_pciBusNum
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_pciDeviceNum
operator|=
operator|(
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|<<
literal|3
operator|)
operator||
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|asr_alloc_dma
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check if the device is there? */
if|if
condition|(
name|ASR_resetIOP
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot reset adapter\n"
argument_list|)
expr_stmt|;
name|asr_release_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|status
operator|=
operator|&
name|sc
operator|->
name|ha_statusmem
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|ASR_getStatus
argument_list|(
name|sc
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not initialize hardware\n"
argument_list|)
expr_stmt|;
name|asr_release_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|sc
operator|->
name|ha_SystemTable
operator|.
name|OrganizationID
operator|=
name|status
operator|->
name|OrganizationID
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|IOP_ID
operator|=
name|status
operator|->
name|IOP_ID
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|I2oVersion
operator|=
name|status
operator|->
name|I2oVersion
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|IopState
operator|=
name|status
operator|->
name|IopState
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|MessengerType
operator|=
name|status
operator|->
name|MessengerType
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|InboundMessageFrameSize
operator|=
name|status
operator|->
name|InboundMFrameSize
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|MessengerInfo
operator|.
name|InboundMessagePortAddressLow
operator|=
call|(
name|U32
call|)
argument_list|(
name|sc
operator|->
name|ha_Base
operator|+
name|I2O_REG_TOFIFO
argument_list|)
expr_stmt|;
comment|/* XXX 64-bit */
if|if
condition|(
operator|!
name|asr_pci_map_int
argument_list|(
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
name|asr_release_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Adjust the maximim inbound count */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|ha_QueueSize
operator|=
name|I2O_EXEC_STATUS_GET_REPLY_getMaxInboundMFrames
argument_list|(
name|status
argument_list|)
operator|)
operator|>
name|MAX_INBOUND
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_QueueSize
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_QueueSize
operator|=
name|MAX_INBOUND
expr_stmt|;
block|}
comment|/* Adjust the maximum outbound count */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|ha_Msgs_Count
operator|=
name|I2O_EXEC_STATUS_GET_REPLY_getMaxOutboundMFrames
argument_list|(
name|status
argument_list|)
operator|)
operator|>
name|MAX_OUTBOUND
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_Msgs_Count
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_Msgs_Count
operator|=
name|MAX_OUTBOUND
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ha_Msgs_Count
operator|>
name|sc
operator|->
name|ha_QueueSize
condition|)
block|{
name|sc
operator|->
name|ha_Msgs_Count
operator|=
name|sc
operator|->
name|ha_QueueSize
expr_stmt|;
block|}
comment|/* Adjust the maximum SG size to adapter */
if|if
condition|(
operator|(
name|size
operator|=
operator|(
name|I2O_EXEC_STATUS_GET_REPLY_getInboundMFrameSize
argument_list|(
name|status
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|>
name|MAX_INBOUND_SIZE
condition|)
block|{
name|size
operator|=
name|MAX_INBOUND_SIZE
expr_stmt|;
block|}
name|sc
operator|->
name|ha_SgSize
operator|=
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
expr_stmt|;
comment|/* 	 *	Only do a bus/HBA reset on the first time through. On this 	 * first time through, we do not send a flush to the devices. 	 */
if|if
condition|(
name|ASR_init
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
struct|struct
name|BufferInfo
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|I2O_DPT_EXEC_IOP_BUFFERS_SCALAR
name|Info
decl_stmt|;
block|}
name|Buffer
struct|;
name|PI2O_DPT_EXEC_IOP_BUFFERS_SCALAR
name|Info
decl_stmt|;
define|#
directive|define
name|FW_DEBUG_BLED_OFFSET
value|8
if|if
condition|(
operator|(
name|Info
operator|=
operator|(
name|PI2O_DPT_EXEC_IOP_BUFFERS_SCALAR
operator|)
name|ASR_getParams
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO
argument_list|,
operator|&
name|Buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BufferInfo
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|ha_blinkLED
operator|=
name|FW_DEBUG_BLED_OFFSET
operator|+
name|I2O_DPT_EXEC_IOP_BUFFERS_SCALAR_getSerialOutputOffset
argument_list|(
name|Info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ASR_acquireLct
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ASR_acquireHrt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to initialize\n"
argument_list|)
expr_stmt|;
name|asr_release_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 *	Add in additional probe responses for more channels. We 	 * are reusing the variable `target' for a channel loop counter. 	 * Done here because of we need both the acquireLct and 	 * acquireHrt data. 	 */
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
name|Device
operator|->
name|le_type
operator|==
name|I2O_UNKNOWN
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|I2O_LCT_ENTRY_getUserTID
argument_list|(
name|Device
argument_list|)
operator|==
literal|0xFFF
condition|)
block|{
if|if
condition|(
name|Device
operator|->
name|le_target
operator|>
name|sc
operator|->
name|ha_MaxId
condition|)
block|{
name|sc
operator|->
name|ha_MaxId
operator|=
name|Device
operator|->
name|le_target
expr_stmt|;
block|}
if|if
condition|(
name|Device
operator|->
name|le_lun
operator|>
name|sc
operator|->
name|ha_MaxLun
condition|)
block|{
name|sc
operator|->
name|ha_MaxLun
operator|=
name|Device
operator|->
name|le_lun
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|Device
operator|->
name|le_type
operator|&
name|I2O_PORT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|<=
name|MAX_CHANNEL
operator|)
condition|)
block|{
comment|/* Do not increase MaxId for efficiency */
name|sc
operator|->
name|ha_adapter_target
index|[
name|Device
operator|->
name|le_bus
index|]
operator|=
name|Device
operator|->
name|le_target
expr_stmt|;
block|}
block|}
comment|/* 	 *	Print the HBA model number as inquired from the card. 	 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
name|Message
decl_stmt|;
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
name|Message_Ptr
decl_stmt|;
name|int
name|posted
init|=
literal|0
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|*
operator|)
operator|&
name|Message
expr_stmt|;
name|bzero
argument_list|(
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
operator||
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_PRIVATE_MESSAGE
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setXFunctionCode
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCSI_SCB_EXEC
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setInterpret
argument_list|(
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setOrganizationID
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|DPT_ORGANIZATION_ID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setCDBLength
argument_list|(
name|Message_Ptr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|0
index|]
operator|=
name|INQUIRY
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|4
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|Message_Ptr
operator|->
name|CDB
index|[
literal|4
index|]
operator|==
literal|0
condition|)
block|{
name|Message_Ptr
operator|->
name|CDB
index|[
literal|4
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
name|I2O_SCB_FLAG_XFER_FROM_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setByteCount
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|iq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|vendor
index|[
literal|0
index|]
operator|&&
operator|(
name|iq
operator|->
name|vendor
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|ASR_prstring
argument_list|(
name|iq
operator|->
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|++
name|posted
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|product
index|[
literal|0
index|]
operator|&&
operator|(
name|iq
operator|->
name|product
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|ASR_prstring
argument_list|(
name|iq
operator|->
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|++
name|posted
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|revision
index|[
literal|0
index|]
operator|&&
operator|(
name|iq
operator|->
name|revision
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" FW Rev. "
argument_list|)
expr_stmt|;
name|ASR_prstring
argument_list|(
name|iq
operator|->
name|revision
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|++
name|posted
expr_stmt|;
block|}
name|free
argument_list|(
name|iq
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|posted
condition|)
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|" %d channel, %d CCBs, Protocol I2O\n"
argument_list|,
name|sc
operator|->
name|ha_MaxBus
operator|+
literal|1
argument_list|,
operator|(
name|sc
operator|->
name|ha_QueueSize
operator|>
name|MAX_INBOUND
operator|)
condition|?
name|MAX_INBOUND
else|:
name|sc
operator|->
name|ha_QueueSize
argument_list|)
expr_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<=
name|sc
operator|->
name|ha_MaxBus
condition|;
operator|++
name|bus
control|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|QueueSize
init|=
name|sc
operator|->
name|ha_QueueSize
decl_stmt|;
if|if
condition|(
name|QueueSize
operator|>
name|MAX_INBOUND
condition|)
block|{
name|QueueSize
operator|=
name|MAX_INBOUND
expr_stmt|;
block|}
comment|/* 		 *	Create the device queue for our SIM(s). 		 */
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|QueueSize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* 		 *	Construct our first channel SIM entry 		 */
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|=
name|cam_sim_alloc
argument_list|(
name|asr_action
argument_list|,
name|asr_poll
argument_list|,
literal|"asr"
argument_list|,
name|sc
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|QueueSize
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|,
name|bus
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
operator|)
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	 *	Generate the device node information 	 */
name|sc
operator|->
name|ha_devt
operator|=
name|make_dev
argument_list|(
operator|&
name|asr_cdevsw
argument_list|,
name|unit
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"asr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_devt
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|make_dev_alias
argument_list|(
name|sc
operator|->
name|ha_devt
argument_list|,
literal|"rdpti%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_devt
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_attach */
end_comment

begin_function
specifier|static
name|void
name|asr_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|asr_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_poll */
end_comment

begin_function
specifier|static
name|void
name|asr_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|Asr_softc
modifier|*
name|sc
decl_stmt|;
name|debug_asr_printf
argument_list|(
literal|"asr_action(%lx,%lx{%x})\n"
argument_list|,
operator|(
name|u_long
operator|)
name|sim
argument_list|,
operator|(
name|u_long
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"asr_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|=
name|sc
operator|=
operator|(
expr|struct
name|Asr_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
struct|struct
name|Message
block|{
name|char
name|M
index|[
name|MAX_INBOUND_SIZE
index|]
decl_stmt|;
block|}
name|Message
struct|;
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
comment|/* Reject incoming commands while we are resetting the card */
if|if
condition|(
name|sc
operator|->
name|ha_in_reset
operator|!=
name|HA_OPERATIONAL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_in_reset
operator|>=
name|HA_OFF_LINE
condition|)
block|{
comment|/* HBA is now off-line */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNREC_HBA_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|/* HBA currently resetting, try again later. */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
name|debug_asr_cmd_printf
argument_list|(
literal|" e\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|debug_asr_cmd_printf
argument_list|(
literal|" q\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d WARNING: scsi_cmd(%x) already done on b%dt%du%d\n"
argument_list|,
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
block|}
name|debug_asr_cmd_printf
argument_list|(
literal|"(%d,%d,%d,%d)"
argument_list|,
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|debug_asr_dump_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
name|ASR_init_message
argument_list|(
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|ccb
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
operator|&
name|Message
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|debug_asr_cmd2_printf
argument_list|(
literal|"TID=%x:\n"
argument_list|,
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_getTID
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|)
argument_list|)
expr_stmt|;
name|debug_asr_cmd2_dump_message
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
name|debug_asr_cmd1_printf
argument_list|(
literal|" q"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_queue
argument_list|(
name|sc
argument_list|,
name|Message_Ptr
argument_list|)
operator|==
name|EMPTY_QUEUE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|debug_asr_cmd_printf
argument_list|(
literal|" E\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|debug_asr_cmd_printf
argument_list|(
literal|" Q\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 *	We will get here if there is no valid TID for the device 		 * referenced in the scsi command packet. 		 */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|debug_asr_cmd_printf
argument_list|(
literal|" B\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
comment|/* Rese HBA device ... */
name|asr_hbareset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|REPORT_LUNS
argument_list|)
operator|)
case|case
name|REPORT_LUNS
case|:
endif|#
directive|endif
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
operator|(
name|ccb
operator|->
name|cts
operator|)
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|scsi
operator|->
name|flags
operator|=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|spi
operator|->
name|sync_period
operator|=
literal|6
expr_stmt|;
comment|/* 40MHz */
name|spi
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
operator|(
name|ccb
operator|->
name|ccg
operator|)
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|4096
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size_mb
operator|>
literal|2048
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|128
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|65
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
name|ASR_resetBus
argument_list|(
name|sc
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
operator|(
name|ccb
operator|->
name|cpi
operator|)
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
comment|/* Not necessary to reset bus, done by HDM initialization */
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|sc
operator|->
name|ha_MaxId
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|sc
operator|->
name|ha_MaxLun
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|sc
operator|->
name|ha_adapter_target
index|[
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
index|]
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* asr_action */
end_comment

begin_comment
comment|/*  * Handle processing of current CCB as pointed to by the Status.  */
end_comment

begin_function
specifier|static
name|int
name|asr_intr
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|processed
decl_stmt|;
for|for
control|(
name|processed
operator|=
literal|0
init|;
name|asr_get_status
argument_list|(
name|sc
argument_list|)
operator|&
name|Mask_InterruptsDisabled
condition|;
name|processed
operator|=
literal|1
control|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|u_int
name|dsc
decl_stmt|;
name|U32
name|ReplyOffset
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|Reply
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ReplyOffset
operator|=
name|asr_get_FromFIFO
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|EMPTY_QUEUE
operator|)
operator|&&
operator|(
operator|(
name|ReplyOffset
operator|=
name|asr_get_FromFIFO
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|EMPTY_QUEUE
operator|)
condition|)
block|{
break|break;
block|}
name|Reply
operator|=
call|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
call|)
argument_list|(
name|ReplyOffset
operator|-
name|sc
operator|->
name|ha_Msgs_Phys
operator|+
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|ha_Msgs
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * We do not need any (optional byteswapping) method access to 		 * the Initiator context field. 		 */
name|ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
operator|(
name|long
operator|)
name|I2O_MESSAGE_FRAME_getInitiatorContext64
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|I2O_MESSAGE_FRAME_getMsgFlags
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
operator|&
name|I2O_MESSAGE_FLAGS_FAIL
condition|)
block|{
name|I2O_UTIL_NOP_MESSAGE
name|Message
decl_stmt|;
name|PI2O_UTIL_NOP_MESSAGE
name|Message_Ptr
decl_stmt|;
name|U32
name|MessageOffset
decl_stmt|;
name|MessageOffset
operator|=
operator|(
name|u_long
operator|)
name|I2O_FAILURE_REPLY_MESSAGE_FRAME_getPreservedMFA
argument_list|(
operator|(
name|PI2O_FAILURE_REPLY_MESSAGE_FRAME
operator|)
name|Reply
argument_list|)
expr_stmt|;
comment|/* 			 *  Get the Original Message Frame's address, and get 			 * it's Transaction Context into our space. (Currently 			 * unused at original authorship, but better to be 			 * safe than sorry). Straight copy means that we 			 * need not concern ourselves with the (optional 			 * byteswapping) method access. 			 */
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|TransactionContext
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|ha_frame_btag
argument_list|,
name|sc
operator|->
name|ha_frame_bhandle
argument_list|,
name|MessageOffset
operator|+
name|offsetof
argument_list|(
name|I2O_SINGLE_REPLY_MESSAGE_FRAME
argument_list|,
name|TransactionContext
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 *	For 64 bit machines, we need to reconstruct the 			 * 64 bit context. 			 */
name|ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
operator|(
name|long
operator|)
name|I2O_MESSAGE_FRAME_getInitiatorContext64
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Unique error code for command failure. 			 */
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_setDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|)
argument_list|,
operator|(
name|u_int16_t
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* 			 *  Modify the message frame to contain a NOP and 			 * re-issue it to the controller. 			 */
name|Message_Ptr
operator|=
operator|(
name|PI2O_UTIL_NOP_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
operator|&
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_UTIL_NOP_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|I2O_UTIL_NOP
operator|!=
literal|0
operator|)
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_UTIL_NOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 *  Copy the packet out to the Original Message 			 */
name|asr_set_frame
argument_list|(
name|sc
argument_list|,
name|Message_Ptr
argument_list|,
name|MessageOffset
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_UTIL_NOP_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 *  Issue the NOP 			 */
name|asr_set_ToFIFO
argument_list|(
name|sc
argument_list|,
name|MessageOffset
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *	Asynchronous command with no return requirements, 		 * and a generic handler for immunity against odd error 		 * returns from the adapter. 		 */
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Return Reply so that it can be used for the 			 * next command 			 */
name|asr_set_FromFIFO
argument_list|(
name|sc
argument_list|,
name|ReplyOffset
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Welease Wadjah! (and stop timeouts) */
name|ASR_ccbRemove
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|dsc
operator|=
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_getDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|dsc
operator|&
name|I2O_SCSI_DEVICE_DSC_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|dsc
condition|)
block|{
case|case
name|I2O_SCSI_DSC_SUCCESS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_DSC_CHECK_CONDITION
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_DSC_BUSY
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_ADAPTER_BUSY
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_SCSI_BUS_RESET
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_BUS_BUSY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUSY
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_HBA_DSC_SELECTION_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_HBA_DSC_COMMAND_TIMEOUT
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_DEVICE_NOT_PRESENT
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_LUN_INVALID
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_SCSI_TID_INVALID
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_HBA_DSC_DATA_OVERRUN
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_REQUEST_LENGTH_ERROR
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|-=
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_getTransferCount
argument_list|(
name|Reply
argument_list|)
expr_stmt|;
block|}
comment|/* Sense data in reply packet */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
condition|)
block|{
name|u_int16_t
name|size
init|=
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_getAutoSenseTransferCount
argument_list|(
name|Reply
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|I2O_SCSI_SENSE_DATA_SZ
condition|)
block|{
name|size
operator|=
name|I2O_SCSI_SENSE_DATA_SZ
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|)
operator|&&
operator|(
name|size
operator|>
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|)
condition|)
block|{
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|Reply
operator|->
name|SenseData
argument_list|,
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Return Reply so that it can be used for the next command 		 * since we have no more need for it now 		 */
name|asr_set_FromFIFO
argument_list|(
name|sc
argument_list|,
name|ReplyOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
condition|)
block|{
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wakeup
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|processed
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_intr */
end_comment

begin_undef
undef|#
directive|undef
name|QueueSize
end_undef

begin_comment
comment|/* Grrrr */
end_comment

begin_undef
undef|#
directive|undef
name|SG_Size
end_undef

begin_comment
comment|/* Grrrr */
end_comment

begin_comment
comment|/*  *	Meant to be included at the bottom of asr.c !!!  */
end_comment

begin_comment
comment|/*  *	Included here as hard coded. Done because other necessary include  *	files utilize C++ comment structures which make them a nuisance to  *	included here just to pick up these three typedefs.  */
end_comment

begin_typedef
typedef|typedef
name|U32
name|DPT_TAG_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|U32
name|DPT_MSG_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|U32
name|DPT_RTN_T
typedef|;
end_typedef

begin_undef
undef|#
directive|undef
name|SCSI_RESET
end_undef

begin_comment
comment|/* Conflicts with "scsi/scsiconf.h" defintion */
end_comment

begin_include
include|#
directive|include
file|"dev/asr/osd_unix.h"
end_include

begin_define
define|#
directive|define
name|asr_unit
parameter_list|(
name|dev
parameter_list|)
value|minor(dev)
end_define

begin_decl_stmt
specifier|static
name|u_int8_t
name|ASR_ctlr_held
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|asr_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|ifmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|si_drv1
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|ASR_ctlr_held
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|ASR_ctlr_held
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_open */
end_comment

begin_function
specifier|static
name|int
name|asr_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ifmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ASR_ctlr_held
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_close */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*		      Function ASR_queue_i				   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The Parameters Passed To This Function Are :				   */
end_comment

begin_comment
comment|/*     Asr_softc_t *	  : HBA miniport driver's adapter data storage.	   */
end_comment

begin_comment
comment|/*     PI2O_MESSAGE_FRAME : Msg Structure Pointer For This Command	   */
end_comment

begin_comment
comment|/*	I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME following the Msg Structure	   */
end_comment

begin_comment
comment|/*									   */
end_comment

begin_comment
comment|/* This Function Will Take The User Request Packet And Convert It To An	   */
end_comment

begin_comment
comment|/* I2O MSG And Send It Off To The Adapter.				   */
end_comment

begin_comment
comment|/*									   */
end_comment

begin_comment
comment|/* Return : 0 For OK, Error Code Otherwise				   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|ASR_queue_i
parameter_list|(
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|PI2O_MESSAGE_FRAME
name|Packet
parameter_list|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|Reply
decl_stmt|;
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|Reply_Ptr
decl_stmt|;
name|int
name|MessageSizeInBytes
decl_stmt|;
name|int
name|ReplySizeInBytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Scatter Gather buffer list */
struct|struct
name|ioctlSgList_S
block|{
name|SLIST_ENTRY
argument_list|(
argument|ioctlSgList_S
argument_list|)
name|link
expr_stmt|;
name|caddr_t
name|UserSpace
decl_stmt|;
name|I2O_FLAGS_COUNT
name|FlagsCount
decl_stmt|;
name|char
name|KernelSpace
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|elm
struct|;
comment|/* Generates a `first' entry */
name|SLIST_HEAD
argument_list|(
argument|ioctlSgListHead_S
argument_list|,
argument|ioctlSgList_S
argument_list|)
name|sgList
expr_stmt|;
if|if
condition|(
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Adapter currently in BlinkLed %x\n"
argument_list|,
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Copy in the message into a local allocation */
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire I2O_MESSAGE_FRAME memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|Packet
argument_list|,
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Can't copy in packet errno=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Acquire information to determine type of packet */
name|MessageSizeInBytes
operator|=
operator|(
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message_Ptr
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* The offset of the reply information within the user packet */
name|Reply
operator|=
call|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Packet
operator|+
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
comment|/* Check if the message is a synchronous initialization command */
name|s
operator|=
name|I2O_MESSAGE_FRAME_getFunction
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|I2O_EXEC_IOP_RESET
case|:
block|{
name|U32
name|status
decl_stmt|;
name|status
operator|=
name|ASR_resetIOP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ReplySizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"resetIOP done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|status
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
operator|)
return|;
block|}
case|case
name|I2O_EXEC_STATUS_GET
case|:
block|{
name|PI2O_EXEC_STATUS_GET_REPLY
name|status
decl_stmt|;
name|status
operator|=
operator|&
name|sc
operator|->
name|ha_statusmem
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|ASR_getStatus
argument_list|(
name|sc
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"getStatus failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ReplySizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"getStatus done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|status
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
operator|)
return|;
block|}
case|case
name|I2O_EXEC_OUTBOUND_INIT
case|:
block|{
name|U32
name|status
decl_stmt|;
name|status
operator|=
name|ASR_initOutBound
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ReplySizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"intOutBound done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|status
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* Determine if the message size is valid */
if|if
condition|(
operator|(
name|MessageSizeInBytes
operator|<
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
operator|)
operator|||
operator|(
name|MAX_INBOUND_SIZE
operator|<
name|MessageSizeInBytes
operator|)
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Packet size %d incorrect\n"
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire frame[%d] memory\n"
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|Packet
argument_list|,
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
name|MessageSizeInBytes
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Can't copy in packet[%d] errno=%d\n"
argument_list|,
name|MessageSizeInBytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check the size of the reply frame, and start constructing */
if|if
condition|(
operator|(
name|Reply_Ptr
operator|=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire I2O_MESSAGE_FRAME memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to copy in reply frame, errno=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ReplySizeInBytes
operator|=
operator|(
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReplySizeInBytes
operator|<
sizeof|sizeof
argument_list|(
name|I2O_SINGLE_REPLY_MESSAGE_FRAME
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to copy in reply frame[%d], errno=%d\n"
argument_list|,
name|ReplySizeInBytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|Reply_Ptr
operator|=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
operator|(
operator|(
name|ReplySizeInBytes
operator|>
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|)
condition|?
name|ReplySizeInBytes
else|:
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire frame[%d] memory\n"
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ASR_fillMessage
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Reply_Ptr
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|.
name|InitiatorContext
operator|=
name|Message_Ptr
operator|->
name|InitiatorContext
expr_stmt|;
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|TransactionContext
operator|=
operator|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
operator|)
operator|->
name|TransactionContext
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMsgFlags
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_MESSAGE_FRAME_getMsgFlags
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
operator||
name|I2O_MESSAGE_FLAGS_REPLY
argument_list|)
expr_stmt|;
comment|/* Check if the message is a special case command */
switch|switch
condition|(
name|I2O_MESSAGE_FRAME_getFunction
argument_list|(
name|Message_Ptr
argument_list|)
condition|)
block|{
case|case
name|I2O_EXEC_SYS_TAB_SET
case|:
comment|/* Special Case of empty Scatter Gather */
if|if
condition|(
name|MessageSizeInBytes
operator|==
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_setDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|)
argument_list|,
operator|(
name|ASR_setSysTab
argument_list|(
name|sc
argument_list|)
operator|!=
name|CAM_REQ_CMP
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_SINGLE_REPLY_MESSAGE_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Deal in the general case */
comment|/* First allocate and optionally copy in each scatter gather element */
name|SLIST_INIT
argument_list|(
operator|&
name|sgList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|!=
literal|0
condition|)
block|{
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
comment|/* 		 *	since this code is reused in several systems, code 		 * efficiency is greater by using a shift operation rather 		 * than a divide by sizeof(u_int32_t). 		 */
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sg
operator|<
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
operator|)
operator|+
name|MessageSizeInBytes
argument_list|)
condition|)
block|{
name|caddr_t
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|)
operator|&
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|I2O_FLAGS_COUNT_getCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"SG[%d] = %x[%d]\n"
argument_list|,
name|sg
operator|-
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
argument_list|,
name|I2O_SGE_SIMPLE_ELEMENT_getPhysicalAddress
argument_list|(
name|sg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elm
operator|=
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|elm
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|elm
operator|->
name|KernelSpace
argument_list|)
operator|+
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to allocate SG[%d]\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|elm
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|elm
operator|->
name|FlagsCount
operator|=
name|sg
operator|->
name|FlagsCount
expr_stmt|;
name|elm
operator|->
name|UserSpace
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT_getPhysicalAddress
argument_list|(
name|sg
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|elm
operator|->
name|KernelSpace
expr_stmt|;
comment|/* Copy in outgoing data (DIR bit could be invalid) */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|elm
operator|->
name|UserSpace
argument_list|,
operator|(
name|caddr_t
operator|)
name|v
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
comment|/* 			 *	If the buffer is not contiguous, lets 			 * break up the scatter/gather entries. 			 */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sg
operator|<
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
operator|)
operator|+
name|MAX_INBOUND_SIZE
argument_list|)
operator|)
condition|)
block|{
name|int
name|next
decl_stmt|,
name|base
decl_stmt|,
name|span
decl_stmt|;
name|span
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress
argument_list|(
name|sg
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* How far can we go physically contiguously */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|base
operator|==
name|next
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
name|next
operator|=
name|trunc_page
argument_list|(
name|base
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|next
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
name|size
operator|=
name|len
expr_stmt|;
block|}
name|span
operator|+=
name|size
expr_stmt|;
name|v
operator|+=
name|size
expr_stmt|;
name|len
operator|-=
name|size
expr_stmt|;
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the Flags */
name|I2O_FLAGS_COUNT_setCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
block|{
name|int
name|flags
init|=
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|elm
operator|->
name|FlagsCount
operator|)
argument_list|)
decl_stmt|;
comment|/* Any remaining length? */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|I2O_SGL_FLAGS_END_OF_BUFFER
operator||
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator|)
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|debug_usr_cmd_printf
argument_list|(
literal|"sg[%d] = %x[%d]\n"
argument_list|,
name|sg
operator|-
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
argument_list|,
name|I2O_SGE_SIMPLE_ELEMENT_getPhysicalAddress
argument_list|(
name|sg
argument_list|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
comment|/* 				 * Incrementing requires resizing of the 				 * packet, and moving up the existing SG 				 * elements. 				 */
operator|++
name|sg
expr_stmt|;
name|MessageSizeInBytes
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message_Ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|{
name|PI2O_MESSAGE_FRAME
name|NewMessage_Ptr
decl_stmt|;
if|if
condition|(
operator|(
name|NewMessage_Ptr
operator|=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire frame[%d] memory\n"
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|span
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|sg
operator|)
operator|-
operator|(
name|caddr_t
operator|)
name|Message_Ptr
expr_stmt|;
name|bcopy
argument_list|(
name|Message_Ptr
argument_list|,
name|NewMessage_Ptr
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|sg
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
operator|)
operator|+
name|span
argument_list|,
name|MessageSizeInBytes
operator|-
name|span
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
operator|)
operator|+
name|span
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|=
name|NewMessage_Ptr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
operator|(
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|)
operator|&
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
break|break;
block|}
operator|++
name|sg
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|debug_usr_cmd_printf
argument_list|(
literal|"Inbound: "
argument_list|)
expr_stmt|;
name|debug_usr_cmd_dump_message
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
comment|/* Send the command */
if|if
condition|(
operator|(
name|ccb
operator|=
name|asr_alloc_ccb
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Free up in-kernel buffers */
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * We do not need any (optional byteswapping) method access to 	 * the Initiator context field. 	 */
name|I2O_MESSAGE_FRAME_setInitiatorContext64
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
operator|(
name|long
operator|)
name|ccb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the board to report a finished instruction. 	 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Reset Adapter */
name|printf
argument_list|(
literal|"asr%d: Blink LED 0x%x resetting adapter\n"
argument_list|,
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|,
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|==
name|ENXIO
condition|)
block|{
comment|/* Command Cleanup */
name|ASR_ccbRemove
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Free up in-kernel buffers */
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check every second for BlinkLed */
comment|/* There is no PRICAM, but outwardly PRIBIO is functional */
name|tsleep
argument_list|(
name|ccb
argument_list|,
name|PRIBIO
argument_list|,
literal|"asr"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Outbound: "
argument_list|)
expr_stmt|;
name|debug_usr_cmd_dump_message
argument_list|(
name|Reply_Ptr
argument_list|)
expr_stmt|;
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_setDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|)
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReplySizeInBytes
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|-
name|I2O_SCSI_SENSE_DATA_SZ
operator|-
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
condition|)
block|{
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_setTransferCount
argument_list|(
name|Reply_Ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|&&
operator|(
name|ReplySizeInBytes
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|-
name|I2O_SCSI_SENSE_DATA_SZ
operator|)
operator|)
condition|)
block|{
name|int
name|size
init|=
name|ReplySizeInBytes
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|-
name|I2O_SCSI_SENSE_DATA_SZ
decl_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
argument_list|,
name|Reply_Ptr
operator|->
name|SenseData
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_setAutoSenseTransferCount
argument_list|(
name|Reply_Ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Free up in-kernel buffers */
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy out as necessary */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
comment|/* DIR bit considered `valid', error due to ignorance works */
operator|&&
operator|(
operator|(
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|elm
operator|->
name|FlagsCount
operator|)
argument_list|)
operator|&
name|I2O_SGL_FLAGS_DIR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|elm
operator|->
name|KernelSpace
argument_list|)
argument_list|,
name|elm
operator|->
name|UserSpace
argument_list|,
name|I2O_FLAGS_COUNT_getCount
argument_list|(
operator|&
operator|(
name|elm
operator|->
name|FlagsCount
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Copy reply frame to user space */
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue_i */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*			    Function asr_ioctl			       */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The parameters passed to this function are :				*/
end_comment

begin_comment
comment|/*     dev  : Device number.						*/
end_comment

begin_comment
comment|/*     cmd  : Ioctl Command						*/
end_comment

begin_comment
comment|/*     data : User Argument Passed In.					*/
end_comment

begin_comment
comment|/*     flag : Mode Parameter						*/
end_comment

begin_comment
comment|/*     proc : Process Parameter						*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/* This function is the user interface into this adapter driver		*/
end_comment

begin_comment
comment|/*									*/
end_comment

begin_comment
comment|/* Return : zero if OK, error code if not				*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|asr_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|Asr_softc_t
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
name|int
name|j
decl_stmt|;
endif|#
directive|endif
comment|/* ASR_IOCTL_COMPAT */
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DPT_SIGNATURE
case|:
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
if|#
directive|if
operator|(
name|dsDescription_size
operator|!=
literal|50
operator|)
case|case
name|DPT_SIGNATURE
operator|+
operator|(
operator|(
literal|50
operator|-
name|dsDescription_size
operator|)
operator|<<
literal|16
operator|)
case|:
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|&
literal|0xFFFF0000
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|ASR_sig
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig_S
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Traditional version of the ioctl interface */
case|case
name|DPT_SIGNATURE
operator|&
literal|0x0000FFFF
case|:
endif|#
directive|endif
return|return
operator|(
name|copyout
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|ASR_sig
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig_S
argument_list|)
argument_list|)
operator|)
return|;
comment|/* Traditional version of the ioctl interface */
case|case
name|DPT_CTRLINFO
operator|&
literal|0x0000FFFF
case|:
case|case
name|DPT_CTRLINFO
case|:
block|{
struct|struct
block|{
name|u_int16_t
name|length
decl_stmt|;
name|u_int16_t
name|drvrHBAnum
decl_stmt|;
name|u_int32_t
name|baseAddr
decl_stmt|;
name|u_int16_t
name|blinkState
decl_stmt|;
name|u_int8_t
name|pciBusNum
decl_stmt|;
name|u_int8_t
name|pciDeviceNum
decl_stmt|;
name|u_int16_t
name|hbaFlags
decl_stmt|;
name|u_int16_t
name|Interrupt
decl_stmt|;
name|u_int32_t
name|reserved1
decl_stmt|;
name|u_int32_t
name|reserved2
decl_stmt|;
name|u_int32_t
name|reserved3
decl_stmt|;
block|}
name|CtlrInfo
struct|;
name|bzero
argument_list|(
operator|&
name|CtlrInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
argument_list|)
expr_stmt|;
name|CtlrInfo
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|CtlrInfo
operator|.
name|drvrHBAnum
operator|=
name|asr_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CtlrInfo
operator|.
name|baseAddr
operator|=
name|sc
operator|->
name|ha_Base
expr_stmt|;
name|i
operator|=
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|CtlrInfo
operator|.
name|blinkState
operator|=
name|i
expr_stmt|;
name|CtlrInfo
operator|.
name|pciBusNum
operator|=
name|sc
operator|->
name|ha_pciBusNum
expr_stmt|;
name|CtlrInfo
operator|.
name|pciDeviceNum
operator|=
name|sc
operator|->
name|ha_pciDeviceNum
expr_stmt|;
define|#
directive|define
name|FLG_OSD_PCI_VALID
value|0x0001
define|#
directive|define
name|FLG_OSD_DMA
value|0x0002
define|#
directive|define
name|FLG_OSD_I2O
value|0x0004
name|CtlrInfo
operator|.
name|hbaFlags
operator|=
name|FLG_OSD_PCI_VALID
operator||
name|FLG_OSD_DMA
operator||
name|FLG_OSD_I2O
expr_stmt|;
name|CtlrInfo
operator|.
name|Interrupt
operator|=
name|sc
operator|->
name|ha_irq
expr_stmt|;
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
if|if
condition|(
name|cmd
operator|&
literal|0xffff0000
condition|)
name|bcopy
argument_list|(
operator|&
name|CtlrInfo
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* ASR_IOCTL_COMPAT */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|CtlrInfo
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
comment|/* Traditional version of the ioctl interface */
case|case
name|DPT_SYSINFO
operator|&
literal|0x0000FFFF
case|:
case|case
name|DPT_SYSINFO
case|:
block|{
name|sysInfo_S
name|Info
decl_stmt|;
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Kernel Specific ptok `hack' */
define|#
directive|define
name|ptok
parameter_list|(
name|a
parameter_list|)
value|((char *)(uintptr_t)(a) + KERNBASE)
name|bzero
argument_list|(
operator|&
name|Info
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Appears I am the only person in the Kernel doing this */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|i
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|Info
operator|.
name|drive0CMOS
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|i
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|Info
operator|.
name|drive1CMOS
operator|=
name|j
expr_stmt|;
name|Info
operator|.
name|numDrives
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|ptok
argument_list|(
literal|0x475
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASR_IOCTL_COMPAT */
name|bzero
argument_list|(
operator|&
name|Info
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
name|Info
operator|.
name|processorFamily
operator|=
name|ASR_sig
operator|.
name|dsProcessorFamily
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
switch|switch
condition|(
name|cpu
condition|)
block|{
case|case
name|CPU_386SX
case|:
case|case
name|CPU_386
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_386
expr_stmt|;
break|break;
case|case
name|CPU_486SX
case|:
case|case
name|CPU_486
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_486
expr_stmt|;
break|break;
case|case
name|CPU_586
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_PENTIUM
expr_stmt|;
break|break;
case|case
name|CPU_686
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_SEXIUM
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|Info
operator|.
name|osType
operator|=
name|OS_BSDI_UNIX
expr_stmt|;
name|Info
operator|.
name|osMajorVersion
operator|=
name|osrelease
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|Info
operator|.
name|osMinorVersion
operator|=
name|osrelease
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* Info.osRevision = 0; */
comment|/* Info.osSubRevision = 0; */
name|Info
operator|.
name|busType
operator|=
name|SI_PCI_BUS
expr_stmt|;
name|Info
operator|.
name|flags
operator|=
name|SI_OSversionValid
operator||
name|SI_BusTypeValid
operator||
name|SI_NO_SmartROM
expr_stmt|;
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
name|Info
operator|.
name|flags
operator||=
name|SI_CMOS_Valid
operator||
name|SI_NumDrivesValid
expr_stmt|;
comment|/* Go Out And Look For I2O SmartROM */
for|for
control|(
name|j
operator|=
literal|0xC8000
init|;
name|j
operator|<
literal|0xE0000
condition|;
name|j
operator|+=
literal|2048
control|)
block|{
name|int
name|k
decl_stmt|;
name|cp
operator|=
name|ptok
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|cp
operator|)
operator|!=
literal|0xAA55
condition|)
block|{
continue|continue;
block|}
name|j
operator|+=
operator|(
name|cp
index|[
literal|2
index|]
operator|*
literal|512
operator|)
operator|-
literal|2048
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
name|cp
operator|+
literal|6
operator|)
operator|)
operator|!=
operator|(
literal|'S'
operator|+
operator|(
literal|' '
operator|*
literal|256
operator|)
operator|+
operator|(
literal|' '
operator|*
literal|65536L
operator|)
operator|)
operator|)
operator|||
operator|(
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
name|cp
operator|+
literal|10
operator|)
operator|)
operator|!=
operator|(
literal|'I'
operator|+
operator|(
literal|'2'
operator|*
literal|256
operator|)
operator|+
operator|(
literal|'0'
operator|*
literal|65536L
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|cp
operator|+=
literal|0x24
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|64
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|cp
operator|)
operator|==
operator|(
literal|' '
operator|+
operator|(
literal|'v'
operator|*
literal|256
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|k
operator|<
literal|64
condition|)
block|{
name|Info
operator|.
name|smartROMMajorVersion
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|cp
operator|+=
literal|4
operator|)
operator|)
operator|-
literal|'0'
expr_stmt|;
name|Info
operator|.
name|smartROMMinorVersion
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|cp
operator|+=
literal|2
operator|)
operator|)
expr_stmt|;
name|Info
operator|.
name|smartROMRevision
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|++
name|cp
operator|)
operator|)
expr_stmt|;
name|Info
operator|.
name|flags
operator||=
name|SI_SmartROMverValid
expr_stmt|;
name|Info
operator|.
name|flags
operator|&=
operator|~
name|SI_NO_SmartROM
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get The Conventional Memory Size From CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x15
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|Info
operator|.
name|conventionalMemSize
operator|=
name|j
expr_stmt|;
comment|/* Get The Extended Memory Found At Power On From CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|Info
operator|.
name|extendedMemSize
operator|=
name|j
expr_stmt|;
name|Info
operator|.
name|flags
operator||=
name|SI_MemorySizeValid
expr_stmt|;
comment|/* Copy Out The Info Structure To The User */
if|if
condition|(
name|cmd
operator|&
literal|0xFFFF0000
condition|)
name|bcopy
argument_list|(
operator|&
name|Info
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* ASR_IOCTL_COMPAT */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|Info
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get The BlinkLED State */
case|case
name|DPT_BLINKLED
case|:
name|i
operator|=
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ASR_IOCTL_COMPAT
if|if
condition|(
name|cmd
operator|&
literal|0xffff0000
condition|)
name|bcopy
argument_list|(
operator|&
name|i
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* ASR_IOCTL_COMPAT */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Send an I2O command */
case|case
name|I2OUSRCMD
case|:
return|return
operator|(
name|ASR_queue_i
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|*
operator|)
name|data
operator|)
argument_list|)
operator|)
return|;
comment|/* Reset and re-initialize the adapter */
case|case
name|I2ORESETCMD
case|:
return|return
operator|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|)
return|;
comment|/* Rescan the LCT table and resynchronize the information */
case|case
name|I2ORESCANCMD
case|:
return|return
operator|(
name|ASR_rescan
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_ioctl */
end_comment

end_unit

