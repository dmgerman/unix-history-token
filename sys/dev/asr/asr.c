begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996-2000 Distributed Processing Technology Corporation  * Copyright (c) 2000-2001 Adaptec Corporation  * All rights reserved.  *  * TERMS AND CONDITIONS OF USE  *  * Redistribution and use in source form, with or without modification, are  * permitted provided that redistributions of source code must retain the  * above copyright notice, this list of conditions and the following disclaimer.  *  * This software is provided `as is' by Adaptec and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose, are disclaimed. In no  * event shall Adaptec be liable for any direct, indirect, incidental, special,  * exemplary or consequential damages (including, but not limited to,  * procurement of substitute goods or services; loss of use, data, or profits;  * or business interruptions) however caused and on any theory of liability,  * whether in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this driver software, even  * if advised of the possibility of such damage.  *  * SCSI I2O host adapter driver  *  *      V1.08 2001/08/21 Mark_Salyzyn@adaptec.com  *              - The 2000S and 2005S do not initialize on some machines,  *		  increased timeout to 255ms from 50ms for the StatusGet  *		  command.  *      V1.07 2001/05/22 Mark_Salyzyn@adaptec.com  *              - I knew this one was too good to be true. The error return  *                on ioctl commands needs to be compared to CAM_REQ_CMP, not  *                to the bit masked status.  *      V1.06 2001/05/08 Mark_Salyzyn@adaptec.com  *              - The 2005S that was supported is affectionately called the  *                Conjoined BAR Firmware. In order to support RAID-5 in a  *                16MB low-cost configuration, Firmware was forced to go  *                to a Split BAR Firmware. This requires a separate IOP and  *                Messaging base address.  *      V1.05 2001/04/25 Mark_Salyzyn@adaptec.com  *              - Handle support for 2005S Zero Channel RAID solution.  *              - System locked up if the Adapter locked up. Do not try  *                to send other commands if the resetIOP command fails. The  *                fail outstanding command discovery loop was flawed as the  *                removal of the command from the list prevented discovering  *                all the commands.  *              - Comment changes to clarify driver.  *              - SysInfo searched for an EATA SmartROM, not an I2O SmartROM.  *              - We do not use the AC_FOUND_DEV event because of I2O.  *                Removed asr_async.  *      V1.04 2000/09/22 Mark_Salyzyn@adaptec.com, msmith@freebsd.org,  *                       lampa@fee.vutbr.cz and Scott_Long@adaptec.com.  *              - Removed support for PM1554, PM2554 and PM2654 in Mode-0  *                mode as this is confused with competitor adapters in run  *                mode.  *              - critical locking needed in ASR_ccbAdd and ASR_ccbRemove  *                to prevent operating system panic.  *              - moved default major number to 154 from 97.  *      V1.03 2000/07/12 Mark_Salyzyn@adaptec.com  *              - The controller is not actually an ASR (Adaptec SCSI RAID)  *                series that is visible, it's more of an internal code name.  *                remove any visible references within reason for now.  *              - bus_ptr->LUN was not correctly zeroed when initially  *                allocated causing a possible panic of the operating system  *                during boot.  *      V1.02 2000/06/26 Mark_Salyzyn@adaptec.com  *              - Code always fails for ASR_getTid affecting performance.  *              - initiated a set of changes that resulted from a formal  *                code inspection by Mark_Salyzyn@adaptec.com,  *                George_Dake@adaptec.com, Jeff_Zeak@adaptec.com,  *                Martin_Wilson@adaptec.com and Vincent_Trandoan@adaptec.com.  *                Their findings were focussed on the LCT& TID handler, and  *                all resulting changes were to improve code readability,  *                consistency or have a positive effect on performance.  *      V1.01 2000/06/14 Mark_Salyzyn@adaptec.com  *              - Passthrough returned an incorrect error.  *              - Passthrough did not migrate the intrinsic scsi layer wakeup  *                on command completion.  *              - generate control device nodes using make_dev and delete_dev.  *              - Performance affected by TID caching reallocing.  *              - Made suggested changes by Justin_Gibbs@adaptec.com  *                      - use splcam instead of splbio.  *                      - use cam_imask instead of bio_imask.  *                      - use u_int8_t instead of u_char.  *                      - use u_int16_t instead of u_short.  *                      - use u_int32_t instead of u_long where appropriate.  *                      - use 64 bit context handler instead of 32 bit.  *                      - create_ccb should only allocate the worst case  *                        requirements for the driver since CAM may evolve  *                        making union ccb much larger than needed here.  *                        renamed create_ccb to asr_alloc_ccb.  *                      - go nutz justifying all debug prints as macros  *                        defined at the top and remove unsightly ifdefs.  *                      - INLINE STATIC viewed as confusing. Historically  *                        utilized to affect code performance and debug  *                        issues in OS, Compiler or OEM specific situations.  *      V1.00 2000/05/31 Mark_Salyzyn@adaptec.com  *              - Ported from FreeBSD 2.2.X DPT I2O driver.  *                      changed struct scsi_xfer to union ccb/struct ccb_hdr  *                      changed variable name xs to ccb  *                      changed struct scsi_link to struct cam_path  *                      changed struct scsibus_data to struct cam_sim  *                      stopped using fordriver for holding on to the TID  *                      use proprietary packet creation instead of scsi_inquire  *                      CAM layer sends synchronize commands.  *  * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|ASR_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|ASR_REVISION
value|'0'
end_define

begin_define
define|#
directive|define
name|ASR_SUBREVISION
value|'8'
end_define

begin_define
define|#
directive|define
name|ASR_MONTH
value|8
end_define

begin_define
define|#
directive|define
name|ASR_DAY
value|21
end_define

begin_define
define|#
directive|define
name|ASR_YEAR
value|2001 - 1980
end_define

begin_comment
comment|/*  *      Debug macros to reduce the unsightly ifdefs  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_ASR_USR_CMD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUG_ASR_CMD
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_message
parameter_list|(
name|message
parameter_list|)
define|\
value|{                                                                      \                 u_int32_t * pointer = (u_int32_t *)message;                    \                 u_int32_t   length = I2O_MESSAGE_FRAME_getMessageSize(message);\                 u_int32_t   counter = 0;                                       \                                                                                \                 while (length--) {                                             \                         printf ("%08lx%c", (u_long)*(pointer++),               \                           (((++counter& 7) == 0) || (length == 0))            \                             ? '\n'                                             \                             : ' ');                                            \                 }                                                              \         }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR || DEBUG_ASR_USR_CMD || DEBUG_ASR_CMD */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR
argument_list|)
operator|)
end_if

begin_comment
comment|/* Breaks on none STDC based compilers :-( */
end_comment

begin_define
define|#
directive|define
name|debug_asr_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt, ##args)
end_define

begin_define
define|#
directive|define
name|debug_asr_dump_message
parameter_list|(
name|message
parameter_list|)
value|debug_asr_message(message)
end_define

begin_define
define|#
directive|define
name|debug_asr_print_path
parameter_list|(
name|ccb
parameter_list|)
value|xpt_print_path(ccb->ccb_h.path);
end_define

begin_comment
comment|/* None fatal version of the ASSERT macro */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|phrase
parameter_list|)
value|if(!(phrase))printf(#phrase " at line %d file %s\n",__LINE__,__FILE__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|phrase
parameter_list|)
value|if(!(phrase))printf("phrase" " at line %d file %s\n",__LINE__,__FILE__)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ASR */
end_comment

begin_define
define|#
directive|define
name|debug_asr_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_print_path
parameter_list|(
name|ccb
parameter_list|)
end_define

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR */
end_comment

begin_comment
comment|/*  *      If DEBUG_ASR_CMD is defined:  *              0 - Display incoming SCSI commands  *              1 - add in a quick character before queueing.  *              2 - add in outgoing message frames.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR_CMD
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt,##args)
end_define

begin_define
define|#
directive|define
name|debug_asr_dump_ccb
parameter_list|(
name|ccb
parameter_list|)
define|\
value|{                                                             \                 u_int8_t * cp = (unsigned char *)&(ccb->csio.cdb_io); \                 int        len = ccb->csio.cdb_len;                   \                                                                       \                 while (len) {                                         \                         debug_asr_cmd_printf (" %02x", *(cp++));      \                         --len;                                        \                 }                                                     \         }
end_define

begin_if
if|#
directive|if
operator|(
name|DEBUG_ASR_CMD
operator|>
literal|0
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_cmd1_printf
value|debug_asr_cmd_printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug_asr_cmd1_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|DEBUG_ASR_CMD
operator|>
literal|1
operator|)
end_if

begin_define
define|#
directive|define
name|debug_asr_cmd2_printf
value|debug_asr_cmd_printf
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_dump_message
parameter_list|(
name|message
parameter_list|)
value|debug_asr_message(message)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debug_asr_cmd2_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ASR_CMD */
end_comment

begin_define
define|#
directive|define
name|debug_asr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd_dump_ccb
parameter_list|(
name|ccb
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd1_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_asr_cmd2_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR_CMD */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR_USR_CMD
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|debug_usr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt,##args)
end_define

begin_define
define|#
directive|define
name|debug_usr_cmd_dump_message
parameter_list|(
name|message
parameter_list|)
value|debug_usr_message(message)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ASR_USR_CMD */
end_comment

begin_define
define|#
directive|define
name|debug_usr_cmd_printf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|debug_usr_cmd_dump_message
parameter_list|(
name|message
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ASR_USR_CMD */
end_comment

begin_define
define|#
directive|define
name|dsDescription_size
value|46
end_define

begin_comment
comment|/* Snug as a bug in a rug */
end_comment

begin_include
include|#
directive|include
file|"dev/asr/dptsig.h"
end_include

begin_decl_stmt
specifier|static
name|dpt_sig_S
name|ASR_sig
init|=
block|{
block|{
literal|'d'
block|,
literal|'P'
block|,
literal|'t'
block|,
literal|'S'
block|,
literal|'i'
block|,
literal|'G'
block|}
block|,
name|SIG_VERSION
block|,
name|PROC_INTEL
block|,
name|PROC_386
operator||
name|PROC_486
operator||
name|PROC_PENTIUM
operator||
name|PROC_SEXIUM
block|,
name|FT_HBADRVR
block|,
literal|0
block|,
name|OEM_DPT
block|,
name|OS_FREE_BSD
block|,
name|CAP_ABOVE16MB
block|,
name|DEV_ALL
block|,
name|ADF_ALL_SC5
block|,
literal|0
block|,
literal|0
block|,
name|ASR_VERSION
block|,
name|ASR_REVISION
block|,
name|ASR_SUBREVISION
block|,
name|ASR_MONTH
block|,
name|ASR_DAY
block|,
name|ASR_YEAR
block|,
comment|/*       01234567890123456789012345678901234567890123456789< 50 chars */
literal|"Adaptec FreeBSD 4.0.0 Unix SCSI I2O HBA Driver"
comment|/*               ^^^^^ asr_attach alters these to match OS */
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* TRUE=1 and FALSE=0 defined here */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/include/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/vmparam.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<alpha/include/pmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_define
define|#
directive|define
name|INLINE
end_define

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG_ASR
argument_list|)
operator|&&
operator|(
name|DEBUG_ASR
operator|>
literal|0
operator|)
operator|)
end_if

begin_undef
undef|#
directive|undef
name|STATIC
end_undef

begin_define
define|#
directive|define
name|STATIC
end_define

begin_undef
undef|#
directive|undef
name|INLINE
end_undef

begin_define
define|#
directive|define
name|INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IN
end_define

begin_define
define|#
directive|define
name|OUT
end_define

begin_define
define|#
directive|define
name|INOUT
end_define

begin_define
define|#
directive|define
name|osdSwap4
parameter_list|(
name|x
parameter_list|)
value|((u_long)ntohl((u_long)(x)))
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_include
include|#
directive|include
file|"dev/asr/dptalign.h"
end_include

begin_include
include|#
directive|include
file|"dev/asr/i2oexec.h"
end_include

begin_include
include|#
directive|include
file|"dev/asr/i2obscsi.h"
end_include

begin_include
include|#
directive|include
file|"dev/asr/i2odpt.h"
end_include

begin_include
include|#
directive|include
file|"dev/asr/i2oadptr.h"
end_include

begin_include
include|#
directive|include
file|"opt_asr.h"
end_include

begin_include
include|#
directive|include
file|"dev/asr/sys_info.h"
end_include

begin_comment
comment|/* Configuration Definitions */
end_comment

begin_define
define|#
directive|define
name|SG_SIZE
value|58
end_define

begin_comment
comment|/* Scatter Gather list Size              */
end_comment

begin_define
define|#
directive|define
name|MAX_TARGET_ID
value|126
end_define

begin_comment
comment|/* Maximum Target ID supported           */
end_comment

begin_define
define|#
directive|define
name|MAX_LUN
value|255
end_define

begin_comment
comment|/* Maximum LUN Supported                 */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANNEL
value|7
end_define

begin_comment
comment|/* Maximum Channel # Supported by driver */
end_comment

begin_define
define|#
directive|define
name|MAX_INBOUND
value|2000
end_define

begin_comment
comment|/* Max CCBs, Also Max Queue Size         */
end_comment

begin_define
define|#
directive|define
name|MAX_OUTBOUND
value|256
end_define

begin_comment
comment|/* Maximum outbound frames/adapter       */
end_comment

begin_define
define|#
directive|define
name|MAX_INBOUND_SIZE
value|512
end_define

begin_comment
comment|/* Maximum inbound frame size            */
end_comment

begin_define
define|#
directive|define
name|MAX_MAP
value|4194304L
end_define

begin_comment
comment|/* Maximum mapping size of IOP         */
end_comment

begin_comment
comment|/* Also serves as the minimum map for    */
end_comment

begin_comment
comment|/* the 2005S zero channel RAID product   */
end_comment

begin_comment
comment|/************************************************************************** ** ASR Host Adapter structure - One Structure For Each Host Adapter That ** **  Is Configured Into The System.  The Structure Supplies Configuration ** **  Information, Status Info, Queue Info And An Active CCB List Pointer. ** ***************************************************************************/
end_comment

begin_comment
comment|/* I2O register set */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|U8
name|Address
index|[
literal|0x30
index|]
decl_stmt|;
specifier|volatile
name|U32
name|Status
decl_stmt|;
specifier|volatile
name|U32
name|Mask
decl_stmt|;
define|#
directive|define
name|Mask_InterruptsDisabled
value|0x08
name|U32
name|x
index|[
literal|2
index|]
decl_stmt|;
specifier|volatile
name|U32
name|ToFIFO
decl_stmt|;
comment|/* In Bound FIFO  */
specifier|volatile
name|U32
name|FromFIFO
decl_stmt|;
comment|/* Out Bound FIFO */
block|}
name|i2oRegs_t
typedef|;
end_typedef

begin_comment
comment|/*  * A MIX of performance and space considerations for TID lookups  */
end_comment

begin_typedef
typedef|typedef
name|u_int16_t
name|tid_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/* up to MAX_LUN    */
name|tid_t
name|TID
index|[
literal|1
index|]
decl_stmt|;
block|}
name|lun2tid_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/* up to MAX_TARGET */
name|lun2tid_t
modifier|*
name|LUN
index|[
literal|1
index|]
decl_stmt|;
block|}
name|target2lun_t
typedef|;
end_typedef

begin_comment
comment|/*  *      To ensure that we only allocate and use the worst case ccb here, lets  *      make our own local ccb union. If asr_alloc_ccb is utilized for another  *      ccb type, ensure that you add the additional structures into our local  *      ccb union. To ensure strict type checking, we will utilize the local  *      ccb definition wherever possible.  */
end_comment

begin_union
union|union
name|asr_ccb
block|{
name|struct
name|ccb_hdr
name|ccb_h
decl_stmt|;
comment|/* For convenience */
name|struct
name|ccb_scsiio
name|csio
decl_stmt|;
name|struct
name|ccb_setasync
name|csa
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
struct|struct
name|Asr_softc
block|{
name|u_int16_t
name|ha_irq
decl_stmt|;
name|void
modifier|*
name|ha_Base
decl_stmt|;
comment|/* base port for each board */
name|u_int8_t
modifier|*
specifier|volatile
name|ha_blinkLED
decl_stmt|;
name|i2oRegs_t
modifier|*
name|ha_Virt
decl_stmt|;
comment|/* Base address of IOP      */
name|U8
modifier|*
name|ha_Fvirt
decl_stmt|;
comment|/* Base address of Frames   */
name|I2O_IOP_ENTRY
name|ha_SystemTable
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|ha_ccb
expr_stmt|;
comment|/* ccbs in use              */
name|struct
name|cam_path
modifier|*
name|ha_path
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|ha_sim
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|struct
name|resource
modifier|*
name|ha_mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ha_mes_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ha_irq_res
decl_stmt|;
name|void
modifier|*
name|ha_intr
decl_stmt|;
endif|#
directive|endif
name|PI2O_LCT
name|ha_LCT
decl_stmt|;
comment|/* Complete list of devices */
define|#
directive|define
name|le_type
value|IdentityTag[0]
define|#
directive|define
name|I2O_BSA
value|0x20
define|#
directive|define
name|I2O_FCA
value|0x40
define|#
directive|define
name|I2O_SCSI
value|0x00
define|#
directive|define
name|I2O_PORT
value|0x80
define|#
directive|define
name|I2O_UNKNOWN
value|0x7F
define|#
directive|define
name|le_bus
value|IdentityTag[1]
define|#
directive|define
name|le_target
value|IdentityTag[2]
define|#
directive|define
name|le_lun
value|IdentityTag[3]
name|target2lun_t
modifier|*
name|ha_targets
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|ha_Msgs
decl_stmt|;
name|u_long
name|ha_Msgs_Phys
decl_stmt|;
name|u_int8_t
name|ha_in_reset
decl_stmt|;
define|#
directive|define
name|HA_OPERATIONAL
value|0
define|#
directive|define
name|HA_IN_RESET
value|1
define|#
directive|define
name|HA_OFF_LINE
value|2
define|#
directive|define
name|HA_OFF_LINE_RECOVERY
value|3
comment|/* Configuration information */
comment|/* The target id maximums we take */
name|u_int8_t
name|ha_MaxBus
decl_stmt|;
comment|/* Maximum bus */
name|u_int8_t
name|ha_MaxId
decl_stmt|;
comment|/* Maximum target ID */
name|u_int8_t
name|ha_MaxLun
decl_stmt|;
comment|/* Maximum target LUN */
name|u_int8_t
name|ha_SgSize
decl_stmt|;
comment|/* Max SG elements */
name|u_int8_t
name|ha_pciBusNum
decl_stmt|;
name|u_int8_t
name|ha_pciDeviceNum
decl_stmt|;
name|u_int8_t
name|ha_adapter_target
index|[
name|MAX_CHANNEL
operator|+
literal|1
index|]
decl_stmt|;
name|u_int16_t
name|ha_QueueSize
decl_stmt|;
comment|/* Max outstanding commands */
name|u_int16_t
name|ha_Msgs_Count
decl_stmt|;
comment|/* Links into other parents and HBAs */
name|struct
name|Asr_softc
modifier|*
name|ha_next
decl_stmt|;
comment|/* HBA list */
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
define|#
directive|define
name|MAX_TIMEQ_SIZE
value|256
comment|/* assumes MAX 256 scsi commands sent */
name|asr_perf_t
name|ha_performance
decl_stmt|;
name|u_int32_t
name|ha_submitted_ccbs_count
decl_stmt|;
comment|/* Queueing macros for a circular queue */
define|#
directive|define
name|TIMEQ_FREE_LIST_EMPTY
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
value|(-1 == (head)&& -1 == (tail))
define|#
directive|define
name|TIMEQ_FREE_LIST_FULL
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
value|((((tail) + 1) % MAX_TIMEQ_SIZE) == (head))
define|#
directive|define
name|ENQ_TIMEQ_FREE_LIST
parameter_list|(
name|item
parameter_list|,
name|Q
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|)
define|\
value|if (!TIMEQ_FREE_LIST_FULL((head), (tail))) { \                 if TIMEQ_FREE_LIST_EMPTY((head),(tail)) { \                         (head) = (tail) = 0; \                 } \                 else (tail) = ((tail) + 1) % MAX_TIMEQ_SIZE; \                 Q[(tail)] = (item); \         } \         else { \                 debug_asr_printf("asr: Enqueueing when TimeQ Free List is full... This should not happen!\n"); \         }
define|#
directive|define
name|DEQ_TIMEQ_FREE_LIST
parameter_list|(
name|item
parameter_list|,
name|Q
parameter_list|,
name|head
parameter_list|,
name|tail
parameter_list|)
define|\
value|if (!TIMEQ_FREE_LIST_EMPTY((head), (tail))) { \                 item  = Q[(head)]; \                 if ((head) == (tail)) { (head) = (tail) = -1; } \                 else (head) = ((head) + 1) % MAX_TIMEQ_SIZE; \         } \         else { \                 (item) = -1; \                 debug_asr_printf("asr: Dequeueing when TimeQ Free List is empty... This should not happen!\n"); \         }
comment|/* Circular queue of time stamps */
name|struct
name|timeval
name|ha_timeQ
index|[
name|MAX_TIMEQ_SIZE
index|]
decl_stmt|;
name|u_int32_t
name|ha_timeQFreeList
index|[
name|MAX_TIMEQ_SIZE
index|]
decl_stmt|;
name|int
name|ha_timeQFreeHead
decl_stmt|;
name|int
name|ha_timeQFreeTail
decl_stmt|;
endif|#
directive|endif
block|}
name|Asr_softc_t
typedef|;
end_typedef

begin_decl_stmt
name|STATIC
name|Asr_softc_t
modifier|*
name|Asr_softc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *      Prototypes of the routines we have in this object.  */
end_comment

begin_comment
comment|/* Externally callable routines */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_define
define|#
directive|define
name|PROBE_ARGS
value|IN device_t tag
end_define

begin_define
define|#
directive|define
name|PROBE_RET
value|int
end_define

begin_define
define|#
directive|define
name|PROBE_SET
parameter_list|()
value|u_int32_t id = (pci_get_device(tag)<<16)|pci_get_vendor(tag)
end_define

begin_define
define|#
directive|define
name|PROBE_RETURN
parameter_list|(
name|retval
parameter_list|)
value|if(retval){device_set_desc(tag,retval);return(0);}else{return(ENXIO);}
end_define

begin_define
define|#
directive|define
name|ATTACH_ARGS
value|IN device_t tag
end_define

begin_define
define|#
directive|define
name|ATTACH_RET
value|int
end_define

begin_define
define|#
directive|define
name|ATTACH_SET
parameter_list|()
value|int unit = device_get_unit(tag)
end_define

begin_define
define|#
directive|define
name|ATTACH_RETURN
parameter_list|(
name|retval
parameter_list|)
value|return(retval)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROBE_ARGS
value|IN pcici_t tag, IN pcidi_t id
end_define

begin_define
define|#
directive|define
name|PROBE_RET
value|const char *
end_define

begin_define
define|#
directive|define
name|PROBE_SET
parameter_list|()
end_define

begin_define
define|#
directive|define
name|PROBE_RETURN
parameter_list|(
name|retval
parameter_list|)
value|return(retval)
end_define

begin_define
define|#
directive|define
name|ATTACH_ARGS
value|IN pcici_t tag, IN int unit
end_define

begin_define
define|#
directive|define
name|ATTACH_RET
value|void
end_define

begin_define
define|#
directive|define
name|ATTACH_SET
parameter_list|()
end_define

begin_define
define|#
directive|define
name|ATTACH_RETURN
parameter_list|(
name|retval
parameter_list|)
value|return
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I2O HDM interface */
end_comment

begin_function_decl
name|STATIC
name|PROBE_RET
name|asr_probe
parameter_list|(
name|PROBE_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|ATTACH_RET
name|asr_attach
parameter_list|(
name|ATTACH_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* DOMINO placeholder */
end_comment

begin_function_decl
name|STATIC
name|PROBE_RET
name|domino_probe
parameter_list|(
name|PROBE_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|ATTACH_RET
name|domino_attach
parameter_list|(
name|ATTACH_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* MODE0 adapter placeholder */
end_comment

begin_function_decl
name|STATIC
name|PROBE_RET
name|mode0_probe
parameter_list|(
name|PROBE_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|ATTACH_RET
name|mode0_attach
parameter_list|(
name|ATTACH_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|Asr_softc_t
modifier|*
name|ASR_get_sc
parameter_list|(
name|IN
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|asr_ioctl
parameter_list|(
name|IN
name|dev_t
name|dev
parameter_list|,
name|IN
name|u_long
name|cmd
parameter_list|,
name|INOUT
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|asr_open
parameter_list|(
name|IN
name|dev_t
name|dev
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|ifmt
parameter_list|,
name|IN
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|asr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ifmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|asr_intr
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|asr_timeout
parameter_list|(
name|INOUT
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|ASR_init
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|INLINE
name|int
name|ASR_acquireLct
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|INLINE
name|int
name|ASR_acquireHrt
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|asr_action
parameter_list|(
name|IN
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|IN
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|asr_poll
parameter_list|(
name|IN
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *      Here is the auto-probe structure used to nest our tests appropriately  *      during the startup phase of the operating system.  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_decl_stmt
name|STATIC
name|device_method_t
name|asr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|asr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|asr_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|driver_t
name|asr_driver
init|=
block|{
literal|"asr"
block|,
name|asr_methods
block|,
expr|sizeof
operator|(
name|Asr_softc_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|devclass_t
name|asr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|asr
argument_list|,
name|pci
argument_list|,
name|asr_driver
argument_list|,
name|asr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|device_method_t
name|domino_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|domino_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|domino_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|driver_t
name|domino_driver
init|=
block|{
literal|"domino"
block|,
name|domino_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|devclass_t
name|domino_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|domino
argument_list|,
name|pci
argument_list|,
name|domino_driver
argument_list|,
name|domino_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|device_method_t
name|mode0_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mode0_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mode0_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|driver_t
name|mode0_driver
init|=
block|{
literal|"mode0"
block|,
name|mode0_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|devclass_t
name|mode0_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mode0
argument_list|,
name|pci
argument_list|,
name|mode0_driver
argument_list|,
name|mode0_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|STATIC
name|u_long
name|asr_pcicount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|pci_device
name|asr_pcidev
init|=
block|{
literal|"asr"
block|,
name|asr_probe
block|,
name|asr_attach
block|,
operator|&
name|asr_pcicount
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|asr_pciset
argument_list|,
name|asr_pcidev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|u_long
name|domino_pcicount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|pci_device
name|domino_pcidev
init|=
block|{
literal|"domino"
block|,
name|domino_probe
block|,
name|domino_attach
block|,
operator|&
name|domino_pcicount
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|domino_pciset
argument_list|,
name|domino_pcidev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|STATIC
name|u_long
name|mode0_pcicount
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|struct
name|pci_device
name|mode0_pcidev
init|=
block|{
literal|"mode0"
block|,
name|mode0_probe
block|,
name|mode0_attach
block|,
operator|&
name|mode0_pcicount
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|mode0_pciset
argument_list|,
name|mode0_pcidev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * devsw for asr hba driver  *  * only ioctl is used. the sd driver provides all other access.  */
end_comment

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|154
end_define

begin_comment
comment|/* preferred default character major */
end_comment

begin_decl_stmt
name|STATIC
name|struct
name|cdevsw
name|asr_cdevsw
init|=
block|{
name|asr_open
block|,
comment|/* open     */
name|asr_close
block|,
comment|/* close    */
name|noread
block|,
comment|/* read     */
name|nowrite
block|,
comment|/* write    */
name|asr_ioctl
block|,
comment|/* ioctl    */
name|nopoll
block|,
comment|/* poll     */
name|nommap
block|,
comment|/* mmap     */
name|nostrategy
block|,
comment|/* strategy */
literal|"asr"
block|,
comment|/* name     */
name|CDEV_MAJOR
block|,
comment|/* maj      */
name|nodump
block|,
comment|/* dump     */
name|nopsize
block|,
comment|/* psize    */
literal|0
block|,
comment|/* flags    */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
end_ifdef

begin_function_decl
name|STATIC
name|u_int32_t
name|asr_time_delta
parameter_list|(
name|IN
name|struct
name|timeval
name|start
parameter_list|,
name|IN
name|struct
name|timeval
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ASR_VERY_BROKEN
end_ifdef

begin_comment
comment|/*  * Initialize the dynamic cdevsw hooks.  */
end_comment

begin_function
name|STATIC
name|void
name|asr_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|static
name|int
name|asr_devsw_installed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asr_devsw_installed
condition|)
block|{
return|return;
block|}
name|asr_devsw_installed
operator|++
expr_stmt|;
comment|/*          * Find a free spot (the report during driver load used by          * osd layer in engine to generate the controlling nodes).          */
while|while
condition|(
operator|(
name|asr_cdevsw
operator|.
name|d_maj
operator|<
name|NUMCDEVSW
operator|)
operator|&&
operator|(
name|devsw
argument_list|(
name|makedev
argument_list|(
name|asr_cdevsw
operator|.
name|d_maj
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
operator|(
expr|struct
name|cdevsw
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
operator|++
name|asr_cdevsw
operator|.
name|d_maj
expr_stmt|;
block|}
if|if
condition|(
name|asr_cdevsw
operator|.
name|d_maj
operator|>=
name|NUMCDEVSW
condition|)
for|for
control|(
name|asr_cdevsw
operator|.
name|d_maj
operator|=
literal|0
init|;
operator|(
name|asr_cdevsw
operator|.
name|d_maj
operator|<
name|CDEV_MAJOR
operator|)
operator|&&
operator|(
name|devsw
argument_list|(
name|makedev
argument_list|(
name|asr_cdevsw
operator|.
name|d_maj
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
operator|(
expr|struct
name|cdevsw
operator|*
operator|)
name|NULL
operator|)
condition|;
operator|++
name|asr_cdevsw
operator|.
name|d_maj
control|)
empty_stmt|;
comment|/*          *      Come to papa          */
name|cdevsw_add
argument_list|(
operator|&
name|asr_cdevsw
argument_list|)
expr_stmt|;
comment|/*          *      delete any nodes that would attach to the primary adapter,          * let the adapter scans add them.          */
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|asr_cdevsw
operator|.
name|d_maj
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_drvinit */
end_comment

begin_comment
comment|/* Must initialize before CAM layer picks up our HBA driver */
end_comment

begin_macro
name|SYSINIT
argument_list|(
argument|asrdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|asr_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I2O support routines */
end_comment

begin_define
define|#
directive|define
name|defAlignLong
parameter_list|(
name|STRUCT
parameter_list|,
name|NAME
parameter_list|)
value|char NAME[sizeof(STRUCT)]
end_define

begin_define
define|#
directive|define
name|getAlignLong
parameter_list|(
name|STRUCT
parameter_list|,
name|NAME
parameter_list|)
value|((STRUCT *)(NAME))
end_define

begin_comment
comment|/*  *      Fill message with default.  */
end_comment

begin_function
name|STATIC
name|PI2O_MESSAGE_FRAME
name|ASR_fillMessage
parameter_list|(
name|IN
name|char
modifier|*
name|Message
parameter_list|,
name|IN
name|u_int16_t
name|size
parameter_list|)
block|{
name|OUT
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
name|Message_Ptr
operator|=
name|getAlignLong
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Message_Ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|-
literal|1
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|Message_Ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_fillMessage */
end_comment

begin_define
define|#
directive|define
name|EMPTY_QUEUE
value|((U32)-1L)
end_define

begin_function
name|STATIC
name|INLINE
name|U32
name|ASR_getMessage
parameter_list|(
name|IN
name|i2oRegs_t
modifier|*
name|virt
parameter_list|)
block|{
name|OUT
name|U32
name|MessageOffset
decl_stmt|;
if|if
condition|(
operator|(
name|MessageOffset
operator|=
name|virt
operator|->
name|ToFIFO
operator|)
operator|==
name|EMPTY_QUEUE
condition|)
block|{
name|MessageOffset
operator|=
name|virt
operator|->
name|ToFIFO
expr_stmt|;
block|}
return|return
operator|(
name|MessageOffset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getMessage */
end_comment

begin_comment
comment|/* Issue a polled command */
end_comment

begin_function
name|STATIC
name|U32
name|ASR_initiateCp
parameter_list|(
name|INOUT
name|i2oRegs_t
modifier|*
name|virt
parameter_list|,
name|INOUT
name|U8
modifier|*
name|fvirt
parameter_list|,
name|IN
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|OUT
name|U32
name|Mask
init|=
operator|-
literal|1L
decl_stmt|;
name|U32
name|MessageOffset
decl_stmt|;
name|u_int
name|Delay
init|=
literal|1500
decl_stmt|;
comment|/*          * ASR_initiateCp is only used for synchronous commands and will          * be made more resiliant to adapter delays since commands like          * resetIOP can cause the adapter to be deaf for a little time.          */
while|while
condition|(
operator|(
operator|(
name|MessageOffset
operator|=
name|ASR_getMessage
argument_list|(
name|virt
argument_list|)
operator|)
operator|==
name|EMPTY_QUEUE
operator|)
operator|&&
operator|(
operator|--
name|Delay
operator|!=
literal|0
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|MessageOffset
operator|!=
name|EMPTY_QUEUE
condition|)
block|{
name|bcopy
argument_list|(
name|Message
argument_list|,
name|fvirt
operator|+
name|MessageOffset
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message
argument_list|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/*                  *      Disable the Interrupts                  */
name|virt
operator|->
name|Mask
operator|=
operator|(
name|Mask
operator|=
name|virt
operator|->
name|Mask
operator|)
operator||
name|Mask_InterruptsDisabled
expr_stmt|;
name|virt
operator|->
name|ToFIFO
operator|=
name|MessageOffset
expr_stmt|;
block|}
return|return
operator|(
name|Mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_initiateCp */
end_comment

begin_comment
comment|/*  *      Reset the adapter.  */
end_comment

begin_function
name|STATIC
name|U32
name|ASR_resetIOP
parameter_list|(
name|INOUT
name|i2oRegs_t
modifier|*
name|virt
parameter_list|,
name|INOUT
name|U8
modifier|*
name|fvirt
parameter_list|)
block|{
struct|struct
name|resetMessage
block|{
name|I2O_EXEC_IOP_RESET_MESSAGE
name|M
decl_stmt|;
name|U32
name|R
decl_stmt|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|resetMessage
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PI2O_EXEC_IOP_RESET_MESSAGE
name|Message_Ptr
decl_stmt|;
name|OUT
name|U32
modifier|*
specifier|volatile
name|Reply_Ptr
decl_stmt|;
name|U32
name|Old
decl_stmt|;
comment|/*          *  Build up our copy of the Message.          */
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_IOP_RESET_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_IOP_RESET_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_EXEC_IOP_RESET_MESSAGE_setFunction
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_EXEC_IOP_RESET
argument_list|)
expr_stmt|;
comment|/*          *  Reset the Reply Status          */
operator|*
operator|(
name|Reply_Ptr
operator|=
operator|(
name|U32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
sizeof|sizeof
argument_list|(
name|I2O_EXEC_IOP_RESET_MESSAGE
argument_list|)
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|I2O_EXEC_IOP_RESET_MESSAGE_setStatusWordLowAddress
argument_list|(
name|Message_Ptr
argument_list|,
name|KVTOPHYS
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Reply_Ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          *      Send the Message out          */
if|if
condition|(
operator|(
name|Old
operator|=
name|ASR_initiateCp
argument_list|(
name|virt
argument_list|,
name|fvirt
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|)
operator|!=
operator|(
name|U32
operator|)
operator|-
literal|1L
condition|)
block|{
comment|/*                  *      Wait for a response (Poll), timeouts are dangerous if                  * the card is truly responsive. We assume response in 2s.                  */
name|u_int8_t
name|Delay
init|=
literal|200
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|Reply_Ptr
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|--
name|Delay
operator|!=
literal|0
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/*                  *      Re-enable the interrupts.                  */
name|virt
operator|->
name|Mask
operator|=
name|Old
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|Reply_Ptr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|Reply_Ptr
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|Old
operator|!=
operator|(
name|U32
operator|)
operator|-
literal|1L
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_resetIOP */
end_comment

begin_comment
comment|/*  *      Get the curent state of the adapter  */
end_comment

begin_function
name|STATIC
name|INLINE
name|PI2O_EXEC_STATUS_GET_REPLY
name|ASR_getStatus
parameter_list|(
name|INOUT
name|i2oRegs_t
modifier|*
name|virt
parameter_list|,
name|INOUT
name|U8
modifier|*
name|fvirt
parameter_list|,
name|OUT
name|PI2O_EXEC_STATUS_GET_REPLY
name|buffer
parameter_list|)
block|{
name|defAlignLong
argument_list|(
name|I2O_EXEC_STATUS_GET_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PI2O_EXEC_STATUS_GET_MESSAGE
name|Message_Ptr
decl_stmt|;
name|U32
name|Old
decl_stmt|;
comment|/*          *  Build up our copy of the Message.          */
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_STATUS_GET_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_EXEC_STATUS_GET_MESSAGE_setFunction
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_EXEC_STATUS_GET
argument_list|)
expr_stmt|;
name|I2O_EXEC_STATUS_GET_MESSAGE_setReplyBufferAddressLow
argument_list|(
name|Message_Ptr
argument_list|,
name|KVTOPHYS
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This one is a Byte Count */
name|I2O_EXEC_STATUS_GET_MESSAGE_setReplyBufferLength
argument_list|(
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_REPLY
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          *  Reset the Reply Status          */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_REPLY
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          *      Send the Message out          */
if|if
condition|(
operator|(
name|Old
operator|=
name|ASR_initiateCp
argument_list|(
name|virt
argument_list|,
name|fvirt
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|)
operator|!=
operator|(
name|U32
operator|)
operator|-
literal|1L
condition|)
block|{
comment|/*                  *      Wait for a response (Poll), timeouts are dangerous if                  * the card is truly responsive. We assume response in 50ms.                  */
name|u_int8_t
name|Delay
init|=
literal|255
decl_stmt|;
while|while
condition|(
operator|*
operator|(
operator|(
name|U8
operator|*
specifier|volatile
operator|)
operator|&
operator|(
name|buffer
operator|->
name|SyncByte
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|Delay
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
operator|(
name|PI2O_EXEC_STATUS_GET_REPLY
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/*                  *      Re-enable the interrupts.                  */
name|virt
operator|->
name|Mask
operator|=
name|Old
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|PI2O_EXEC_STATUS_GET_REPLY
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getStatus */
end_comment

begin_comment
comment|/*  *      Check if the device is a SCSI I2O HBA, and add it to the list.  */
end_comment

begin_comment
comment|/*  * Probe for ASR controller.  If we find it, we will use it.  * virtual adapters.  */
end_comment

begin_function
name|STATIC
name|PROBE_RET
name|asr_probe
parameter_list|(
name|PROBE_ARGS
parameter_list|)
block|{
name|PROBE_SET
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|==
literal|0xA5011044
operator|)
operator|||
operator|(
name|id
operator|==
literal|0xA5111044
operator|)
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Caching SCSI RAID"
argument_list|)
expr_stmt|;
block|}
name|PROBE_RETURN
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_probe */
end_comment

begin_comment
comment|/*  * Probe/Attach for DOMINO chipset.  */
end_comment

begin_function
name|STATIC
name|PROBE_RET
name|domino_probe
parameter_list|(
name|PROBE_ARGS
parameter_list|)
block|{
name|PROBE_SET
argument_list|()
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0x10121044
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Caching Memory Controller"
argument_list|)
expr_stmt|;
block|}
name|PROBE_RETURN
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* domino_probe */
end_comment

begin_function
name|STATIC
name|ATTACH_RET
name|domino_attach
parameter_list|(
name|ATTACH_ARGS
parameter_list|)
block|{
name|ATTACH_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* domino_attach */
end_comment

begin_comment
comment|/*  * Probe/Attach for MODE0 adapters.  */
end_comment

begin_function
name|STATIC
name|PROBE_RET
name|mode0_probe
parameter_list|(
name|PROBE_ARGS
parameter_list|)
block|{
name|PROBE_SET
argument_list|()
expr_stmt|;
comment|/*          *      If/When we can get a business case to commit to a          * Mode0 driver here, we can make all these tests more          * specific and robust. Mode0 adapters have their processors          * turned off, this the chips are in a raw state.          */
comment|/* This is a PLX9054 */
if|if
condition|(
name|id
operator|==
literal|0x905410B5
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Mode0 PM3757"
argument_list|)
expr_stmt|;
block|}
comment|/* This is a PLX9080 */
if|if
condition|(
name|id
operator|==
literal|0x908010B5
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Mode0 PM3754/PM3755"
argument_list|)
expr_stmt|;
block|}
comment|/* This is a ZION 80303 */
if|if
condition|(
name|id
operator|==
literal|0x53098086
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Mode0 3010S"
argument_list|)
expr_stmt|;
block|}
comment|/* This is an i960RS */
if|if
condition|(
name|id
operator|==
literal|0x39628086
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Mode0 2100S"
argument_list|)
expr_stmt|;
block|}
comment|/* This is an i960RN */
if|if
condition|(
name|id
operator|==
literal|0x19648086
condition|)
block|{
name|PROBE_RETURN
argument_list|(
literal|"Adaptec Mode0 PM2865/2400A/3200S/3400S"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* this would match any generic i960 -- mjs */
comment|/* This is an i960RP (typically also on Motherboards) */
block|if (id == 0x19608086) {                 PROBE_RETURN ("Adaptec Mode0 PM2554/PM1554/PM2654");         }
endif|#
directive|endif
name|PROBE_RETURN
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mode0_probe */
end_comment

begin_function
name|STATIC
name|ATTACH_RET
name|mode0_attach
parameter_list|(
name|ATTACH_ARGS
parameter_list|)
block|{
name|ATTACH_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mode0_attach */
end_comment

begin_expr_stmt
name|STATIC
name|INLINE
expr|union
name|asr_ccb
operator|*
name|asr_alloc_ccb
argument_list|(
argument|IN Asr_softc_t    * sc
argument_list|)
block|{
name|OUT
expr|union
name|asr_ccb
operator|*
name|new_ccb
block|;
if|if
condition|(
operator|(
name|new_ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_ccb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|!=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|NULL
condition|)
block|{
name|new_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|priority
operator|=
literal|1
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|pinfo
operator|.
name|index
operator|=
name|CAM_UNQUEUED_INDEX
expr_stmt|;
name|new_ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|=
name|sc
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|new_ccb
operator|)
return|;
end_return

begin_comment
unit|}
comment|/* asr_alloc_ccb */
end_comment

begin_function
unit|STATIC
name|INLINE
name|void
name|asr_free_ccb
parameter_list|(
name|IN
name|union
name|asr_ccb
modifier|*
name|free_ccb
parameter_list|)
block|{
name|free
argument_list|(
name|free_ccb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_free_ccb */
end_comment

begin_comment
comment|/*  *      Print inquiry data `carefully'  */
end_comment

begin_function
name|STATIC
name|void
name|ASR_prstring
parameter_list|(
name|u_int8_t
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|(
operator|--
name|len
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|s
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|s
operator|!=
literal|'-'
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
operator|(
name|s
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ASR_prstring */
end_comment

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_function_decl
name|STATIC
name|INLINE
name|int
name|ASR_queue
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *      Send a message synchronously and without Interrupt to a ccb.  */
end_comment

begin_function
name|STATIC
name|int
name|ASR_queue_s
parameter_list|(
name|INOUT
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|,
name|IN
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|U32
name|Mask
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
operator|(
name|Asr_softc_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|)
decl_stmt|;
comment|/*          * We do not need any (optional byteswapping) method access to          * the Initiator context field.          */
name|I2O_MESSAGE_FRAME_setInitiatorContext64
argument_list|(
name|Message
argument_list|,
operator|(
name|long
operator|)
name|ccb
argument_list|)
expr_stmt|;
comment|/* Prevent interrupt service */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|sc
operator|->
name|ha_Virt
operator|->
name|Mask
operator|=
operator|(
name|Mask
operator|=
name|sc
operator|->
name|ha_Virt
operator|->
name|Mask
operator|)
operator||
name|Mask_InterruptsDisabled
expr_stmt|;
if|if
condition|(
name|ASR_queue
argument_list|(
name|sc
argument_list|,
name|Message
argument_list|)
operator|==
name|EMPTY_QUEUE
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
comment|/*          * Wait for this board to report a finished instruction.          */
while|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
operator|(
name|void
operator|)
name|asr_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable Interrupts */
name|sc
operator|->
name|ha_Virt
operator|->
name|Mask
operator|=
name|Mask
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue_s */
end_comment

begin_comment
comment|/*  *      Send a message synchronously to a Asr_softc_t  */
end_comment

begin_function
name|STATIC
name|int
name|ASR_queue_c
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|OUT
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|asr_alloc_ccb
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|CAM_REQUEUE_REQ
operator|)
return|;
block|}
name|status
operator|=
name|ASR_queue_s
argument_list|(
name|ccb
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue_c */
end_comment

begin_comment
comment|/*  *      Add the specified ccb to the active queue  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|ASR_ccbAdd
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|INOUT
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|,
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|!=
name|CAM_TIME_INFINITY
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|==
name|CAM_TIME_DEFAULT
condition|)
block|{
comment|/*                          * RAID systems can take considerable time to                          * complete some commands given the large cache                          * flashes switching from write back to write thru.                          */
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|6
operator|*
literal|60
operator|*
literal|1000
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASR_ccbAdd */
end_comment

begin_comment
comment|/*  *      Remove the specified ccb from the active queue.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|ASR_ccbRemove
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|INOUT
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|untimeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|ccb_h
operator|)
argument_list|,
name|sim_links
operator|.
name|le
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASR_ccbRemove */
end_comment

begin_comment
comment|/*  *      Fail all the active commands, so they get re-issued by the operating  *      system.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|ASR_failActiveCommands
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Currently handled by callers, unnecessary paranoia currently */
comment|/* Left in for historical perspective. */
block|defAlignLong(I2O_EXEC_LCT_NOTIFY_MESSAGE,Message);         PI2O_EXEC_LCT_NOTIFY_MESSAGE             Message_Ptr;
comment|/* Send a blind LCT command to wait for the enableSys to complete */
block|Message_Ptr = (PI2O_EXEC_LCT_NOTIFY_MESSAGE)ASR_fillMessage(Message,           sizeof(I2O_EXEC_LCT_NOTIFY_MESSAGE) - sizeof(I2O_SG_ELEMENT));         I2O_MESSAGE_FRAME_setFunction(&(Message_Ptr->StdMessageFrame),           I2O_EXEC_LCT_NOTIFY);         I2O_EXEC_LCT_NOTIFY_MESSAGE_setClassIdentifier(Message_Ptr,           I2O_CLASS_MATCH_ANYCLASS);         (void)ASR_queue_c(sc, (PI2O_MESSAGE_FRAME)Message_Ptr);
endif|#
directive|endif
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/*          *      We do not need to inform the CAM layer that we had a bus          * reset since we manage it on our own, this also prevents the          * SCSI_DELAY settling that would be required on other systems.          * The `SCSI_DELAY' has already been handled by the card via the          * acquisition of the LCT table while we are at CAM priority level.          *  for (int bus = 0; bus<= sc->ha_MaxBus; ++bus) {          *      xpt_async (AC_BUS_RESET, sc->ha_path[bus], NULL);          *  }          */
while|while
condition|(
operator|(
name|ccb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ccb_hdr
operator|*
operator|)
name|NULL
condition|)
block|{
name|ASR_ccbRemove
argument_list|(
name|sc
argument_list|,
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
comment|/* Nothing Transfered */
operator|(
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccb
operator|)
operator|->
name|resid
operator|=
operator|(
operator|(
expr|struct
name|ccb_scsiio
operator|*
operator|)
name|ccb
operator|)
operator|->
name|dxfer_len
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|path
condition|)
block|{
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ASR_failActiveCommands */
end_comment

begin_comment
comment|/*  *      The following command causes the HBA to reset the specific bus  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|ASR_resetBus
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|int
name|bus
parameter_list|)
block|{
name|defAlignLong
argument_list|(
name|I2O_HBA_BUS_RESET_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|I2O_HBA_BUS_RESET_MESSAGE
modifier|*
name|Message_Ptr
decl_stmt|;
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|I2O_HBA_BUS_RESET_MESSAGE
operator|*
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_HBA_BUS_RESET_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
name|Message_Ptr
operator|->
name|StdMessageFrame
argument_list|,
name|I2O_HBA_BUS_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|Device
operator|->
name|le_type
operator|&
name|I2O_PORT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|==
name|bus
operator|)
condition|)
block|{
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
operator|&
name|Message_Ptr
operator|->
name|StdMessageFrame
argument_list|,
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Asynchronous command, with no expectations */
operator|(
name|void
operator|)
name|ASR_queue
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ASR_resetBus */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_getBlinkLedCode
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|!=
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ha_blinkLED
operator|!=
operator|(
name|u_int8_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ha_blinkLED
index|[
literal|1
index|]
operator|==
literal|0xBC
operator|)
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|ha_blinkLED
index|[
literal|0
index|]
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getBlinkCode */
end_comment

begin_comment
comment|/*  *      Determine the address of an TID lookup. Must be done at high priority  *      since the address can be changed by other threads of execution.  *  *      Returns NULL pointer if not indexible (but will attempt to generate  *      an index if `new_entry' flag is set to TRUE).  *  *      All addressible entries are to be guaranteed zero if never initialized.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|tid_t
modifier|*
name|ASR_getTidAddress
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|int
name|bus
parameter_list|,
name|IN
name|int
name|target
parameter_list|,
name|IN
name|int
name|lun
parameter_list|,
name|IN
name|int
name|new_entry
parameter_list|)
block|{
name|target2lun_t
modifier|*
name|bus_ptr
decl_stmt|;
name|lun2tid_t
modifier|*
name|target_ptr
decl_stmt|;
name|unsigned
name|new_size
decl_stmt|;
comment|/*          *      Validity checking of incoming parameters. More of a bound          * expansion limit than an issue with the code dealing with the          * values.          *          *      sc must be valid before it gets here, so that check could be          * dropped if speed a critical issue.          */
if|if
condition|(
operator|(
name|sc
operator|==
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|bus
operator|>
name|MAX_CHANNEL
operator|)
operator|||
operator|(
name|target
operator|>
name|sc
operator|->
name|ha_MaxId
operator|)
operator|||
operator|(
name|lun
operator|>
name|sc
operator|->
name|ha_MaxLun
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"(%lx,%d,%d,%d) target out of range\n"
argument_list|,
operator|(
name|u_long
operator|)
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*          *      See if there is an associated bus list.          *          *      for performance, allocate in size of BUS_CHUNK chunks.          *      BUS_CHUNK must be a power of two. This is to reduce          *      fragmentation effects on the allocations.          */
define|#
directive|define
name|BUS_CHUNK
value|8
name|new_size
operator|=
operator|(
operator|(
name|target
operator|+
name|BUS_CHUNK
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|BUS_CHUNK
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bus_ptr
operator|=
name|sc
operator|->
name|ha_targets
index|[
name|bus
index|]
operator|)
operator|==
operator|(
name|target2lun_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*                  *      Allocate a new structure?                  *              Since one element in structure, the +1                  *              needed for size has been abstracted.                  */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|sc
operator|->
name|ha_targets
index|[
name|bus
index|]
operator|=
name|bus_ptr
operator|=
operator|(
name|target2lun_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bus_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bus_ptr
operator|->
name|LUN
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
operator|(
name|target2lun_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to allocate bus list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|bus_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bus_ptr
operator|->
name|size
operator|<=
name|new_size
condition|)
block|{
name|target2lun_t
modifier|*
name|new_bus_ptr
decl_stmt|;
comment|/*                  *      Reallocate a new structure?                  *              Since one element in structure, the +1                  *              needed for size has been abstracted.                  */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|new_bus_ptr
operator|=
operator|(
name|target2lun_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bus_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bus_ptr
operator|->
name|LUN
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
operator|(
name|target2lun_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to reallocate bus list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*                  *      Copy the whole thing, safer, simpler coding                  * and not really performance critical at this point.                  */
name|bcopy
argument_list|(
name|bus_ptr
argument_list|,
name|new_bus_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bus_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bus_ptr
operator|->
name|LUN
argument_list|)
operator|*
operator|(
name|bus_ptr
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_targets
index|[
name|bus
index|]
operator|=
name|new_bus_ptr
expr_stmt|;
name|free
argument_list|(
name|bus_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|bus_ptr
operator|=
name|new_bus_ptr
expr_stmt|;
name|bus_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
comment|/*          *      We now have the bus list, lets get to the target list.          *      Since most systems have only *one* lun, we do not allocate          *      in chunks as above, here we allow one, then in chunk sizes.          *      TARGET_CHUNK must be a power of two. This is to reduce          *      fragmentation effects on the allocations.          */
define|#
directive|define
name|TARGET_CHUNK
value|8
if|if
condition|(
operator|(
name|new_size
operator|=
name|lun
operator|)
operator|!=
literal|0
condition|)
block|{
name|new_size
operator|=
operator|(
operator|(
name|lun
operator|+
name|TARGET_CHUNK
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|TARGET_CHUNK
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|target_ptr
operator|=
name|bus_ptr
operator|->
name|LUN
index|[
name|target
index|]
operator|)
operator|==
operator|(
name|lun2tid_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*                  *      Allocate a new structure?                  *              Since one element in structure, the +1                  *              needed for size has been abstracted.                  */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|bus_ptr
operator|->
name|LUN
index|[
name|target
index|]
operator|=
name|target_ptr
operator|=
operator|(
name|lun2tid_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|target_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|target_ptr
operator|->
name|TID
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
operator|(
name|lun2tid_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to allocate target list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|target_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_ptr
operator|->
name|size
operator|<=
name|new_size
condition|)
block|{
name|lun2tid_t
modifier|*
name|new_target_ptr
decl_stmt|;
comment|/*                  *      Reallocate a new structure?                  *              Since one element in structure, the +1                  *              needed for size has been abstracted.                  */
if|if
condition|(
operator|(
name|new_entry
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|new_target_ptr
operator|=
operator|(
name|lun2tid_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|target_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|target_ptr
operator|->
name|TID
argument_list|)
operator|*
name|new_size
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
operator|(
name|lun2tid_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"failed to reallocate target list\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/*                  *      Copy the whole thing, safer, simpler coding                  * and not really performance critical at this point.                  */
name|bcopy
argument_list|(
name|target_ptr
argument_list|,
name|new_target_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target_ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|target_ptr
operator|->
name|TID
argument_list|)
operator|*
operator|(
name|target_ptr
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|bus_ptr
operator|->
name|LUN
index|[
name|target
index|]
operator|=
name|new_target_ptr
expr_stmt|;
name|free
argument_list|(
name|target_ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|target_ptr
operator|=
name|new_target_ptr
expr_stmt|;
name|target_ptr
operator|->
name|size
operator|=
name|new_size
operator|+
literal|1
expr_stmt|;
block|}
comment|/*          *      Now, acquire the TID address from the LUN indexed list.          */
return|return
operator|(
operator|&
operator|(
name|target_ptr
operator|->
name|TID
index|[
name|lun
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getTidAddress */
end_comment

begin_comment
comment|/*  *      Get a pre-existing TID relationship.  *  *      If the TID was never set, return (tid_t)-1.  *  *      should use mutex rather than spl.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|tid_t
name|ASR_getTid
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|int
name|bus
parameter_list|,
name|IN
name|int
name|target
parameter_list|,
name|IN
name|int
name|lun
parameter_list|)
block|{
name|tid_t
modifier|*
name|tid_ptr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|OUT
name|tid_t
name|retval
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tid_ptr
operator|=
name|ASR_getTidAddress
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
operator|(
name|tid_t
operator|*
operator|)
name|NULL
operator|)
comment|/* (tid_t)0 or (tid_t)-1 indicate no TID */
operator|||
operator|(
operator|*
name|tid_ptr
operator|==
operator|(
name|tid_t
operator|)
literal|0
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|retval
operator|=
operator|*
name|tid_ptr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getTid */
end_comment

begin_comment
comment|/*  *      Set a TID relationship.  *  *      If the TID was not set, return (tid_t)-1.  *  *      should use mutex rather than spl.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|tid_t
name|ASR_setTid
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|int
name|bus
parameter_list|,
name|IN
name|int
name|target
parameter_list|,
name|IN
name|int
name|lun
parameter_list|,
name|INOUT
name|tid_t
name|TID
parameter_list|)
block|{
name|tid_t
modifier|*
name|tid_ptr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|TID
operator|!=
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|TID
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tid_ptr
operator|=
name|ASR_getTidAddress
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|==
operator|(
name|tid_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|tid_ptr
operator|=
name|TID
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TID
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_setTid */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*                    Function ASR_rescan                                  */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The Parameters Passed To This Function Are :                            */
end_comment

begin_comment
comment|/*     Asr_softc_t *     : HBA miniport driver's adapter data storage.     */
end_comment

begin_comment
comment|/*                                                                         */
end_comment

begin_comment
comment|/* This Function Will rescan the adapter and resynchronize any data        */
end_comment

begin_comment
comment|/*                                                                         */
end_comment

begin_comment
comment|/* Return : 0 For OK, Error Code Otherwise                                 */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_rescan
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|bus
decl_stmt|;
name|OUT
name|int
name|error
decl_stmt|;
comment|/*          * Re-acquire the LCT table and synchronize us to the adapter.          */
if|if
condition|(
operator|(
name|error
operator|=
name|ASR_acquireLct
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ASR_acquireHrt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
name|error
return|;
block|}
name|bus
operator|=
name|sc
operator|->
name|ha_MaxBus
expr_stmt|;
comment|/* Reset all existing cached TID lookups */
do|do
block|{
name|int
name|target
decl_stmt|,
name|event
init|=
literal|0
decl_stmt|;
comment|/*                  *      Scan for all targets on this bus to see if they                  * got affected by the rescan.                  */
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|sc
operator|->
name|ha_MaxId
condition|;
operator|++
name|target
control|)
block|{
name|int
name|lun
decl_stmt|;
comment|/* Stay away from the controller ID */
if|if
condition|(
name|target
operator|==
name|sc
operator|->
name|ha_adapter_target
index|[
name|bus
index|]
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<=
name|sc
operator|->
name|ha_MaxLun
condition|;
operator|++
name|lun
control|)
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|tid_t
name|TID
init|=
operator|(
name|tid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|tid_t
name|LastTID
decl_stmt|;
comment|/*                                  * See if the cached TID changed. Search for                                  * the device in our new LCT.                                  */
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
operator|(
name|Device
operator|->
name|le_type
operator|!=
name|I2O_UNKNOWN
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_target
operator|==
name|target
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_lun
operator|==
name|lun
operator|)
operator|&&
operator|(
name|I2O_LCT_ENTRY_getUserTID
argument_list|(
name|Device
argument_list|)
operator|==
literal|0xFFF
operator|)
condition|)
block|{
name|TID
operator|=
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*                                  * Indicate to the OS that the label needs                                  * to be recalculated, or that the specific                                  * open device is no longer valid (Merde)                                  * because the cached TID changed.                                  */
name|LastTID
operator|=
name|ASR_getTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|LastTID
operator|!=
name|TID
condition|)
block|{
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|)
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
if|if
condition|(
name|TID
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|event
operator||=
name|AC_LOST_DEVICE
expr_stmt|;
block|}
else|else
block|{
name|event
operator||=
name|AC_INQ_CHANGED
operator||
name|AC_GETDEV_CHANGED
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TID
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LastTID
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|struct
name|ccb_getdev
name|ccb
decl_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
operator|(
name|ccb
operator|.
name|ccb_h
operator|)
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_FOUND_DEVICE
argument_list|,
name|path
argument_list|,
operator|&
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xpt_async
argument_list|(
name|AC_INQ_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_GETDEV_CHANGED
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*                                  *      We have the option of clearing the                                  * cached TID for it to be rescanned, or to                                  * set it now even if the device never got                                  * accessed. We chose the later since we                                  * currently do not use the condition that                                  * the TID ever got cached.                                  */
name|ASR_setTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|TID
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*                  *      The xpt layer can not handle multiple events at the                  * same call.                  */
if|if
condition|(
name|event
operator|&
name|AC_LOST_DEVICE
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|&
name|AC_INQ_CHANGED
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_INQ_CHANGED
argument_list|,
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|&
name|AC_GETDEV_CHANGED
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_GETDEV_CHANGED
argument_list|,
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|bus
operator|>=
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_rescan */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*                    Function ASR_reset                                   */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The Parameters Passed To This Function Are :                            */
end_comment

begin_comment
comment|/*     Asr_softc_t *      : HBA miniport driver's adapter data storage.    */
end_comment

begin_comment
comment|/*                                                                         */
end_comment

begin_comment
comment|/* This Function Will reset the adapter and resynchronize any data         */
end_comment

begin_comment
comment|/*                                                                         */
end_comment

begin_comment
comment|/* Return : None                                                           */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_reset
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|retVal
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_in_reset
operator|==
name|HA_IN_RESET
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_in_reset
operator|==
name|HA_OFF_LINE_RECOVERY
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/*          *      Promotes HA_OPERATIONAL to HA_IN_RESET,          * or HA_OFF_LINE to HA_OFF_LINE_RECOVERY.          */
operator|++
operator|(
name|sc
operator|->
name|ha_in_reset
operator|)
expr_stmt|;
if|if
condition|(
name|ASR_resetIOP
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"ASR_resetIOP failed\n"
argument_list|)
expr_stmt|;
comment|/*                  *      We really need to take this card off-line, easier said                  * than make sense. Better to keep retrying for now since if a                  * UART cable is connected the blinkLEDs the adapter is now in                  * a hard state requiring action from the monitor commands to                  * the HBA to continue. For debugging waiting forever is a                  * good thing. In a production system, however, one may wish                  * to instead take the card off-line ...                  */
if|#
directive|if
literal|0
operator|&&
operator|(
name|defined
argument_list|(
name|HA_OFF_LINE
argument_list|)
operator|)
comment|/*                          * Take adapter off-line.                          */
block|printf ("asr%d: Taking adapter off-line\n",                           sc->ha_path[0]                             ? cam_sim_unit(xpt_path_sim(sc->ha_path[0]))                             : 0);                         sc->ha_in_reset = HA_OFF_LINE;                         splx (s);                         return (ENXIO);
else|#
directive|else
comment|/* Wait Forever */
while|while
condition|(
name|ASR_resetIOP
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
endif|#
directive|endif
block|}
name|retVal
operator|=
name|ASR_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|retVal
operator|!=
literal|0
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"ASR_init failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_in_reset
operator|=
name|HA_OFF_LINE
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ASR_rescan
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"ASR_rescan failed\n"
argument_list|)
expr_stmt|;
block|}
name|ASR_failActiveCommands
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_in_reset
operator|==
name|HA_OFF_LINE_RECOVERY
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d: Brining adapter back on-line\n"
argument_list|,
name|sc
operator|->
name|ha_path
index|[
literal|0
index|]
condition|?
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|sc
operator|->
name|ha_path
index|[
literal|0
index|]
argument_list|)
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|ha_in_reset
operator|=
name|HA_OPERATIONAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_reset */
end_comment

begin_comment
comment|/*  *      Device timeout handler.  */
end_comment

begin_function
name|STATIC
name|void
name|asr_timeout
parameter_list|(
name|INOUT
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|arg
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
operator|(
name|Asr_softc_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|debug_asr_print_path
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|debug_asr_printf
argument_list|(
literal|"timed out"
argument_list|)
expr_stmt|;
comment|/*          *      Check if the adapter has locked up?          */
if|if
condition|(
operator|(
name|s
operator|=
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Reset Adapter */
name|printf
argument_list|(
literal|"asr%d: Blink LED 0x%x resetting adapter\n"
argument_list|,
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|==
name|ENXIO
condition|)
block|{
comment|/* Try again later */
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*          *      Abort does not function on the ASR card!!! Walking away from          * the SCSI command is also *very* dangerous. A SCSI BUS reset is          * our best bet, followed by a complete adapter reset if that fails.          */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* Check if we already timed out once to raise the issue */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_CMD_TIMEOUT
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|" AGAIN\nreinitializing adapter\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|==
name|ENXIO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|debug_asr_printf
argument_list|(
literal|"\nresetting bus\n"
argument_list|)
expr_stmt|;
comment|/* If the BUS reset does not take, then an adapter reset is next! */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|asr_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ASR_resetBus
argument_list|(
name|sc
argument_list|,
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_timeout */
end_comment

begin_comment
comment|/*  * send a message asynchronously  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_queue
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|OUT
name|U32
name|MessageOffset
decl_stmt|;
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|debug_asr_printf
argument_list|(
literal|"Host Command Dump:\n"
argument_list|)
expr_stmt|;
name|debug_asr_dump_message
argument_list|(
name|Message
argument_list|)
expr_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
operator|(
name|long
operator|)
name|I2O_MESSAGE_FRAME_getInitiatorContext64
argument_list|(
name|Message
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|MessageOffset
operator|=
name|ASR_getMessage
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|)
operator|)
operator|!=
name|EMPTY_QUEUE
condition|)
block|{
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
name|int
name|startTimeIndex
decl_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
operator|++
name|sc
operator|->
name|ha_performance
operator|.
name|command_count
index|[
operator|(
name|int
operator|)
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
index|]
expr_stmt|;
name|DEQ_TIMEQ_FREE_LIST
argument_list|(
name|startTimeIndex
argument_list|,
name|sc
operator|->
name|ha_timeQFreeList
argument_list|,
name|sc
operator|->
name|ha_timeQFreeHead
argument_list|,
name|sc
operator|->
name|ha_timeQFreeTail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|startTimeIndex
condition|)
block|{
name|microtime
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_timeQ
index|[
name|startTimeIndex
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Time stamp the command before we send it out */
operator|(
operator|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|*
operator|)
name|Message
operator|)
operator|->
name|PrivateMessageFrame
operator|.
name|TransactionContext
operator|=
operator|(
name|I2O_TRANSACTION_CONTEXT
operator|)
name|startTimeIndex
expr_stmt|;
operator|++
name|sc
operator|->
name|ha_submitted_ccbs_count
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_performance
operator|.
name|max_submit_count
operator|<
name|sc
operator|->
name|ha_submitted_ccbs_count
condition|)
block|{
name|sc
operator|->
name|ha_performance
operator|.
name|max_submit_count
operator|=
name|sc
operator|->
name|ha_submitted_ccbs_count
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|bcopy
argument_list|(
name|Message
argument_list|,
name|sc
operator|->
name|ha_Fvirt
operator|+
name|MessageOffset
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message
argument_list|)
operator|<<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
name|ASR_ccbAdd
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* Post the command */
name|sc
operator|->
name|ha_Virt
operator|->
name|ToFIFO
operator|=
name|MessageOffset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*                          *      Unlikely we can do anything if we can't grab a                          * message frame :-(, but lets give it a try.                          */
operator|(
name|void
operator|)
name|ASR_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|MessageOffset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue */
end_comment

begin_comment
comment|/* Simple Scatter Gather elements */
end_comment

begin_define
define|#
directive|define
name|SG
parameter_list|(
name|SGL
parameter_list|,
name|Index
parameter_list|,
name|Flags
parameter_list|,
name|Buffer
parameter_list|,
name|Size
parameter_list|)
define|\
value|I2O_FLAGS_COUNT_setCount(                                  \&(((PI2O_SG_ELEMENT)(SGL))->u.Simple[Index].FlagsCount), \           Size);                                                   \         I2O_FLAGS_COUNT_setFlags(                                  \&(((PI2O_SG_ELEMENT)(SGL))->u.Simple[Index].FlagsCount), \           I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT | (Flags));         \         I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress(                 \&(((PI2O_SG_ELEMENT)(SGL))->u.Simple[Index]),            \           (Buffer == NULL) ? NULL : KVTOPHYS(Buffer))
end_define

begin_comment
comment|/*  *      Retrieve Parameter Group.  *              Buffer must be allocated using defAlignLong macro.  */
end_comment

begin_function
name|STATIC
name|void
modifier|*
name|ASR_getParams
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|tid_t
name|TID
parameter_list|,
name|IN
name|int
name|Group
parameter_list|,
name|OUT
name|void
modifier|*
name|Buffer
parameter_list|,
name|IN
name|unsigned
name|BufferSize
parameter_list|)
block|{
struct|struct
name|paramGetMessage
block|{
name|I2O_UTIL_PARAMS_GET_MESSAGE
name|M
decl_stmt|;
name|char
name|F
index|[
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
index|]
decl_stmt|;
struct|struct
name|Operations
block|{
name|I2O_PARAM_OPERATIONS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE
name|Template
index|[
literal|1
index|]
decl_stmt|;
block|}
name|O
struct|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|paramGetMessage
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|struct
name|Operations
modifier|*
name|Operations_Ptr
decl_stmt|;
name|I2O_UTIL_PARAMS_GET_MESSAGE
modifier|*
name|Message_Ptr
decl_stmt|;
struct|struct
name|ParamBuffer
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|char
name|Info
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|Buffer_Ptr
struct|;
name|Message_Ptr
operator|=
operator|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
operator|*
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|Operations_Ptr
operator|=
operator|(
expr|struct
name|Operations
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
sizeof|sizeof
argument_list|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|*
literal|2
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|Operations_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Operations
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATIONS_LIST_HEADER_setOperationCount
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Header
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE_setOperation
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Template
index|[
literal|0
index|]
operator|)
argument_list|,
name|I2O_PARAMS_OPERATION_FIELD_GET
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE_setFieldCount
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Template
index|[
literal|0
index|]
operator|)
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|I2O_PARAM_OPERATION_ALL_TEMPLATE_setGroupNumber
argument_list|(
operator|&
operator|(
name|Operations_Ptr
operator|->
name|Template
index|[
literal|0
index|]
operator|)
argument_list|,
name|Group
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|Buffer_Ptr
operator|=
name|getAlignLong
argument_list|(
expr|struct
name|ParamBuffer
argument_list|,
name|Buffer
argument_list|)
operator|)
argument_list|,
name|BufferSize
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_UTIL_PARAMS_GET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_UTIL_PARAMS_GET
argument_list|)
expr_stmt|;
comment|/*          *  Set up the buffers as scatter gather elements.          */
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|Operations_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Operations
argument_list|)
argument_list|)
expr_stmt|;
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|1
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|Buffer_Ptr
argument_list|,
name|BufferSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|==
name|CAM_REQ_CMP
operator|)
operator|&&
operator|(
name|Buffer_Ptr
operator|->
name|Header
operator|.
name|ResultCount
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|Buffer_Ptr
operator|->
name|Info
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_getParams */
end_comment

begin_comment
comment|/*  *      Acquire the LCT information.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_acquireLct
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
name|Message_Ptr
decl_stmt|;
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
name|int
name|MessageSizeInBytes
decl_stmt|;
name|caddr_t
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
name|I2O_LCT
name|Table
decl_stmt|;
name|PI2O_LCT_ENTRY
name|Entry
decl_stmt|;
comment|/*          *      sc value assumed valid          */
name|MessageSizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|I2O_EXEC_LCT_NOTIFY_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ASR_fillMessage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
operator|(
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_LCT_NOTIFY_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_LCT_NOTIFY
argument_list|)
expr_stmt|;
name|I2O_EXEC_LCT_NOTIFY_MESSAGE_setClassIdentifier
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_CLASS_MATCH_ANYCLASS
argument_list|)
expr_stmt|;
comment|/*          *      Call the LCT table to determine the number of device entries          * to reserve space for.          */
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
operator|&
name|Table
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          *      since this code is reused in several systems, code efficiency          * is greater by using a shift operation rather than a divide by          * sizeof(u_int32_t).          */
name|I2O_LCT_setTableSize
argument_list|(
operator|&
name|Table
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_LCT_ENTRY
argument_list|)
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
comment|/*          *      Determine the size of the LCT table.          */
if|if
condition|(
name|sc
operator|->
name|ha_LCT
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/*          *      malloc only generates contiguous memory when less than a          * page is expected. We must break the request up into an SG list ...          */
if|if
condition|(
operator|(
operator|(
name|len
operator|=
operator|(
name|I2O_LCT_getTableSize
argument_list|(
operator|&
name|Table
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|<=
operator|(
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_LCT_ENTRY
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|len
operator|>
operator|(
literal|128
operator|*
literal|1024
operator|)
operator|)
condition|)
block|{
comment|/* Arbitrary */
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_LCT
operator|=
operator|(
name|PI2O_LCT
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_LCT
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*          *      since this code is reused in several systems, code efficiency          * is greater by using a shift operation rather than a divide by          * sizeof(u_int32_t).          */
name|I2O_LCT_setTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|I2O_LCT
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_LCT_ENTRY
argument_list|)
operator|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/*          *      Convert the access to the LCT table into a SG list.          */
name|sg
operator|=
name|Message_Ptr
operator|->
name|SGL
operator|.
name|u
operator|.
name|Simple
expr_stmt|;
name|v
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|next
decl_stmt|,
name|base
decl_stmt|,
name|span
decl_stmt|;
name|span
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress
argument_list|(
name|sg
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* How far can we go contiguously */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|base
operator|==
name|next
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
name|next
operator|=
name|trunc_page
argument_list|(
name|base
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|next
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
name|size
operator|=
name|len
expr_stmt|;
block|}
name|span
operator|+=
name|size
expr_stmt|;
name|v
operator|+=
name|size
expr_stmt|;
name|len
operator|-=
name|size
expr_stmt|;
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the Flags */
name|I2O_FLAGS_COUNT_setCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
block|{
name|int
name|rw
init|=
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|rw
operator|=
operator|(
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
operator||
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
operator|)
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|rw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
comment|/*                  * Incrementing requires resizing of the packet.                  */
operator|++
name|sg
expr_stmt|;
name|MessageSizeInBytes
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|{
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
name|NewMessage_Ptr
decl_stmt|;
if|if
condition|(
operator|(
name|NewMessage_Ptr
operator|=
operator|(
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_EXEC_LCT_NOTIFY_MESSAGE
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_LCT
operator|=
operator|(
name|PI2O_LCT
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|span
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|sg
operator|)
operator|-
operator|(
name|caddr_t
operator|)
name|Message_Ptr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
operator|)
operator|+
name|span
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|=
name|NewMessage_Ptr
expr_stmt|;
block|}
block|}
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
comment|/* If the LCT table grew, lets truncate accesses */
if|if
condition|(
name|I2O_LCT_getTableSize
argument_list|(
operator|&
name|Table
argument_list|)
operator|<
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
condition|)
block|{
name|I2O_LCT_setTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|,
name|I2O_LCT_getTableSize
argument_list|(
operator|&
name|Table
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|Entry
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Entry
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Entry
control|)
block|{
name|Entry
operator|->
name|le_type
operator|=
name|I2O_UNKNOWN
expr_stmt|;
switch|switch
condition|(
name|I2O_CLASS_ID_getClass
argument_list|(
operator|&
operator|(
name|Entry
operator|->
name|ClassID
operator|)
argument_list|)
condition|)
block|{
case|case
name|I2O_CLASS_RANDOM_BLOCK_STORAGE
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_BSA
expr_stmt|;
break|break;
case|case
name|I2O_CLASS_SCSI_PERIPHERAL
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_SCSI
expr_stmt|;
break|break;
case|case
name|I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_FCA
expr_stmt|;
break|break;
case|case
name|I2O_CLASS_BUS_ADAPTER_PORT
case|:
name|Entry
operator|->
name|le_type
operator|=
name|I2O_PORT
operator||
name|I2O_SCSI
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|I2O_CLASS_FIBRE_CHANNEL_PORT
case|:
if|if
condition|(
name|I2O_CLASS_ID_getClass
argument_list|(
operator|&
operator|(
name|Entry
operator|->
name|ClassID
operator|)
argument_list|)
operator|==
name|I2O_CLASS_FIBRE_CHANNEL_PORT
condition|)
block|{
name|Entry
operator|->
name|le_type
operator|=
name|I2O_PORT
operator||
name|I2O_FCA
expr_stmt|;
block|}
block|{
struct|struct
name|ControllerInfo
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
name|Info
decl_stmt|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|ControllerInfo
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|PI2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
name|Info
decl_stmt|;
name|Entry
operator|->
name|le_bus
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_target
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|Info
operator|=
operator|(
name|PI2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
operator|)
name|ASR_getParams
argument_list|(
name|sc
argument_list|,
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Entry
argument_list|)
argument_list|,
name|I2O_HBA_SCSI_CONTROLLER_INFO_GROUP_NO
argument_list|,
name|Buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ControllerInfo
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_HBA_SCSI_CONTROLLER_INFO_SCALAR
operator|)
name|NULL
condition|)
block|{
continue|continue;
block|}
name|Entry
operator|->
name|le_target
operator|=
name|I2O_HBA_SCSI_CONTROLLER_INFO_SCALAR_getInitiatorID
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
literal|0
expr_stmt|;
block|}
comment|/* FALLTHRU */
default|default:
continue|continue;
block|}
block|{
struct|struct
name|DeviceInfo
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|I2O_DPT_DEVICE_INFO_SCALAR
name|Info
decl_stmt|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|DeviceInfo
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|PI2O_DPT_DEVICE_INFO_SCALAR
name|Info
decl_stmt|;
name|Entry
operator|->
name|le_bus
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_target
operator|=
literal|0xff
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|Info
operator|=
operator|(
name|PI2O_DPT_DEVICE_INFO_SCALAR
operator|)
name|ASR_getParams
argument_list|(
name|sc
argument_list|,
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Entry
argument_list|)
argument_list|,
name|I2O_DPT_DEVICE_INFO_GROUP_NO
argument_list|,
name|Buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|DeviceInfo
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_DPT_DEVICE_INFO_SCALAR
operator|)
name|NULL
condition|)
block|{
continue|continue;
block|}
name|Entry
operator|->
name|le_type
operator||=
name|I2O_DPT_DEVICE_INFO_SCALAR_getDeviceType
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|Entry
operator|->
name|le_bus
operator|=
name|I2O_DPT_DEVICE_INFO_SCALAR_getBus
argument_list|(
name|Info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Entry
operator|->
name|le_bus
operator|>
name|sc
operator|->
name|ha_MaxBus
operator|)
operator|&&
operator|(
name|Entry
operator|->
name|le_bus
operator|<=
name|MAX_CHANNEL
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_MaxBus
operator|=
name|Entry
operator|->
name|le_bus
expr_stmt|;
block|}
name|Entry
operator|->
name|le_target
operator|=
name|I2O_DPT_DEVICE_INFO_SCALAR_getIdentifier
argument_list|(
name|Info
argument_list|)
expr_stmt|;
name|Entry
operator|->
name|le_lun
operator|=
name|I2O_DPT_DEVICE_INFO_SCALAR_getLunInfo
argument_list|(
name|Info
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          *      A zero return value indicates success.          */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_acquireLct */
end_comment

begin_comment
comment|/*  * Initialize a message frame.  * We assume that the CDB has already been set up, so all we do here is  * generate the Scatter Gather list.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|PI2O_MESSAGE_FRAME
name|ASR_init_message
parameter_list|(
name|IN
name|union
name|asr_ccb
modifier|*
name|ccb
parameter_list|,
name|OUT
name|PI2O_MESSAGE_FRAME
name|Message
parameter_list|)
block|{
name|int
name|next
decl_stmt|,
name|span
decl_stmt|,
name|base
decl_stmt|,
name|rw
decl_stmt|;
name|OUT
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
operator|(
name|Asr_softc_t
operator|*
operator|)
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|)
decl_stmt|;
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
name|caddr_t
name|v
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|,
name|len
decl_stmt|;
name|U32
name|MessageSize
decl_stmt|;
comment|/* We only need to zero out the PRIVATE_SCSI_SCB_EXECUTE_MESSAGE */
name|bzero
argument_list|(
name|Message_Ptr
operator|=
name|getAlignLong
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|,
name|Message
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|{
name|int
name|target
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
name|int
name|lun
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
decl_stmt|;
name|int
name|bus
init|=
name|cam_sim_bus
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
decl_stmt|;
name|tid_t
name|TID
decl_stmt|;
if|if
condition|(
operator|(
name|TID
operator|=
name|ASR_getTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
operator|==
operator|(
name|tid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
name|TID
operator|=
operator|(
name|tid_t
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
operator|(
name|Device
operator|->
name|le_type
operator|!=
name|I2O_UNKNOWN
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|==
name|bus
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_target
operator|==
name|target
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_lun
operator|==
name|lun
operator|)
operator|&&
operator|(
name|I2O_LCT_ENTRY_getUserTID
argument_list|(
name|Device
argument_list|)
operator|==
literal|0xFFF
operator|)
condition|)
block|{
name|TID
operator|=
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
expr_stmt|;
name|ASR_setTid
argument_list|(
name|sc
argument_list|,
name|Device
operator|->
name|le_bus
argument_list|,
name|Device
operator|->
name|le_target
argument_list|,
name|Device
operator|->
name|le_lun
argument_list|,
name|TID
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|TID
operator|==
operator|(
name|tid_t
operator|)
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|NULL
operator|)
return|;
block|}
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setTID
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
block|}
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
operator||
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_PRIVATE_MESSAGE
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setXFunctionCode
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCSI_SCB_EXEC
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
argument_list|)
expr_stmt|;
comment|/*          * We do not need any (optional byteswapping) method access to          * the Initiator& Transaction context field.          */
name|I2O_MESSAGE_FRAME_setInitiatorContext64
argument_list|(
name|Message
argument_list|,
operator|(
name|long
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setOrganizationID
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|DPT_ORGANIZATION_ID
argument_list|)
expr_stmt|;
comment|/*          * copy the cdb over          */
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setCDBLength
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|)
argument_list|,
operator|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
operator|)
operator|->
name|CDB
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
comment|/*          * Given a buffer describing a transfer, set up a scatter/gather map          * in a ccb to map that SCSI transfer.          */
name|rw
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
literal|0
else|:
name|I2O_SGL_FLAGS_DIR
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
operator|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|)
condition|?
operator|(
operator|(
name|rw
operator|)
condition|?
operator|(
name|I2O_SCB_FLAG_XFER_TO_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
else|:
operator|(
name|I2O_SCB_FLAG_XFER_FROM_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
operator|)
else|:
operator|(
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
argument_list|)
expr_stmt|;
comment|/*          * Given a transfer described by a `data', fill in the SG list.          */
name|sg
operator|=
operator|&
operator|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
operator|)
operator|->
name|SGL
operator|.
name|u
operator|.
name|Simple
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|v
operator|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|ASSERT
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|MessageSize
operator|=
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setByteCount
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sg
operator|<
operator|&
operator|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
operator|)
operator|->
name|SGL
operator|.
name|u
operator|.
name|Simple
index|[
name|SG_SIZE
index|]
operator|)
condition|)
block|{
name|span
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress
argument_list|(
name|sg
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* How far can we go contiguously */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|base
operator|==
name|next
operator|)
condition|)
block|{
name|next
operator|=
name|trunc_page
argument_list|(
name|base
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|next
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
name|size
operator|=
name|len
expr_stmt|;
block|}
name|span
operator|+=
name|size
expr_stmt|;
name|v
operator|+=
name|size
expr_stmt|;
name|len
operator|-=
name|size
expr_stmt|;
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|rw
operator||=
name|I2O_SGL_FLAGS_LAST_ELEMENT
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
operator||
name|rw
argument_list|)
expr_stmt|;
operator|++
name|sg
expr_stmt|;
name|MessageSize
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
expr_stmt|;
block|}
comment|/* We always do the request sense ... */
if|if
condition|(
operator|(
name|span
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|)
operator|==
literal|0
condition|)
block|{
name|span
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
expr_stmt|;
block|}
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
name|MessageSize
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Message_Ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_init_message */
end_comment

begin_comment
comment|/*  *      Reset the adapter.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|U32
name|ASR_initOutBound
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
struct|struct
name|initOutBoundMessage
block|{
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE
name|M
decl_stmt|;
name|U32
name|R
decl_stmt|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|initOutBoundMessage
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PI2O_EXEC_OUTBOUND_INIT_MESSAGE
name|Message_Ptr
decl_stmt|;
name|OUT
name|U32
modifier|*
specifier|volatile
name|Reply_Ptr
decl_stmt|;
name|U32
name|Old
decl_stmt|;
comment|/*          *  Build up our copy of the Message.          */
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_OUTBOUND_INIT_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_OUTBOUND_INIT
argument_list|)
expr_stmt|;
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE_setHostPageFrameSize
argument_list|(
name|Message_Ptr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE_setOutboundMFrameSize
argument_list|(
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          *  Reset the Reply Status          */
operator|*
operator|(
name|Reply_Ptr
operator|=
operator|(
name|U32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
sizeof|sizeof
argument_list|(
name|I2O_EXEC_OUTBOUND_INIT_MESSAGE
argument_list|)
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
argument_list|,
name|Reply_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
comment|/*          *      Send the Message out          */
if|if
condition|(
operator|(
name|Old
operator|=
name|ASR_initiateCp
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|)
operator|!=
operator|(
name|U32
operator|)
operator|-
literal|1L
condition|)
block|{
name|u_long
name|size
decl_stmt|,
name|addr
decl_stmt|;
comment|/*                  *      Wait for a response (Poll).                  */
while|while
condition|(
operator|*
name|Reply_Ptr
operator|<
name|I2O_EXEC_OUTBOUND_INIT_REJECTED
condition|)
empty_stmt|;
comment|/*                  *      Re-enable the interrupts.                  */
name|sc
operator|->
name|ha_Virt
operator|->
name|Mask
operator|=
name|Old
expr_stmt|;
comment|/*                  *      Populate the outbound table.                  */
if|if
condition|(
name|sc
operator|->
name|ha_Msgs
operator|==
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
comment|/* Allocate the reply frames */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|*
name|sc
operator|->
name|ha_Msgs_Count
expr_stmt|;
comment|/*                          *      contigmalloc only works reliably at                          * initialization time.                          */
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_Msgs
operator|=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|contigmalloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
literal|0ul
argument_list|,
literal|0xFFFFFFFFul
argument_list|,
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|,
literal|0ul
argument_list|)
operator|)
operator|!=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|ha_Msgs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_Msgs_Phys
operator|=
name|KVTOPHYS
argument_list|(
name|sc
operator|->
name|ha_Msgs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Initialize the outbound FIFO */
if|if
condition|(
name|sc
operator|->
name|ha_Msgs
operator|!=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|NULL
condition|)
for|for
control|(
name|size
operator|=
name|sc
operator|->
name|ha_Msgs_Count
operator|,
name|addr
operator|=
name|sc
operator|->
name|ha_Msgs_Phys
init|;
name|size
condition|;
operator|--
name|size
control|)
block|{
name|sc
operator|->
name|ha_Virt
operator|->
name|FromFIFO
operator|=
name|addr
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|Reply_Ptr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_initOutBound */
end_comment

begin_comment
comment|/*  *      Set the system table  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_setSysTab
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|PI2O_EXEC_SYS_TAB_SET_MESSAGE
name|Message_Ptr
decl_stmt|;
name|PI2O_SET_SYSTAB_HEADER
name|SystemTable
decl_stmt|;
name|Asr_softc_t
modifier|*
name|ha
decl_stmt|;
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
name|int
name|retVal
decl_stmt|;
if|if
condition|(
operator|(
name|SystemTable
operator|=
operator|(
name|PI2O_SET_SYSTAB_HEADER
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_SET_SYSTAB_HEADER
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_SET_SYSTAB_HEADER
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|ha
operator|=
name|Asr_softc
init|;
name|ha
condition|;
name|ha
operator|=
name|ha
operator|->
name|ha_next
control|)
block|{
operator|++
name|SystemTable
operator|->
name|NumberEntries
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_SYS_TAB_SET_MESSAGE
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_TAB_SET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|+
name|SystemTable
operator|->
name|NumberEntries
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_EXEC_SYS_TAB_SET_MESSAGE
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|SystemTable
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ASR_fillMessage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_TAB_SET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
operator|(
operator|(
literal|3
operator|+
name|SystemTable
operator|->
name|NumberEntries
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
operator|(
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_TAB_SET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_SYS_TAB_SET
argument_list|)
expr_stmt|;
comment|/*          *      Call the LCT table to determine the number of device entries          * to reserve space for.          *      since this code is reused in several systems, code efficiency          * is greater by using a shift operation rather than a divide by          * sizeof(u_int32_t).          */
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_DIR
argument_list|,
name|SystemTable
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_SET_SYSTAB_HEADER
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|sg
expr_stmt|;
for|for
control|(
name|ha
operator|=
name|Asr_softc
init|;
name|ha
condition|;
name|ha
operator|=
name|ha
operator|->
name|ha_next
control|)
block|{
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|ha
operator|->
name|ha_next
operator|)
condition|?
operator|(
name|I2O_SGL_FLAGS_DIR
operator|)
else|:
operator|(
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
operator|)
operator|)
argument_list|,
operator|&
operator|(
name|ha
operator|->
name|ha_SystemTable
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|ha_SystemTable
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|sg
expr_stmt|;
block|}
name|SG
argument_list|(
name|sg
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SG
argument_list|(
name|sg
argument_list|,
literal|1
argument_list|,
name|I2O_SGL_FLAGS_DIR
operator||
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retVal
operator|=
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|SystemTable
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|retVal
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_setSysTab */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_acquireHrt
parameter_list|(
name|INOUT
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|defAlignLong
argument_list|(
name|I2O_EXEC_HRT_GET_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|I2O_EXEC_HRT_GET_MESSAGE
modifier|*
name|Message_Ptr
decl_stmt|;
struct|struct
block|{
name|I2O_HRT
name|Header
decl_stmt|;
name|I2O_HRT_ENTRY
name|Entry
index|[
name|MAX_CHANNEL
index|]
decl_stmt|;
block|}
name|Hrt
struct|;
name|u_int8_t
name|NumberOfEntries
decl_stmt|;
name|PI2O_HRT_ENTRY
name|Entry
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|Hrt
argument_list|,
sizeof|sizeof
argument_list|(
name|Hrt
argument_list|)
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|=
operator|(
name|I2O_EXEC_HRT_GET_MESSAGE
operator|*
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_HRT_GET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
operator|(
name|I2O_VERSION_11
operator|+
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_HRT_GET_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_HRT_GET
argument_list|)
expr_stmt|;
comment|/*          *  Set up the buffers as scatter gather elements.          */
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
operator|&
name|Hrt
argument_list|,
sizeof|sizeof
argument_list|(
name|Hrt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|NumberOfEntries
operator|=
name|I2O_HRT_getNumberEntries
argument_list|(
operator|&
name|Hrt
operator|.
name|Header
argument_list|)
operator|)
operator|>
operator|(
name|MAX_CHANNEL
operator|+
literal|1
operator|)
condition|)
block|{
name|NumberOfEntries
operator|=
name|MAX_CHANNEL
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|Entry
operator|=
name|Hrt
operator|.
name|Header
operator|.
name|HRTEntry
init|;
name|NumberOfEntries
operator|!=
literal|0
condition|;
operator|++
name|Entry
operator|,
operator|--
name|NumberOfEntries
control|)
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
name|I2O_LCT_ENTRY_getLocalTID
argument_list|(
name|Device
argument_list|)
operator|==
operator|(
name|I2O_HRT_ENTRY_getAdapterID
argument_list|(
name|Entry
argument_list|)
operator|&
literal|0xFFF
operator|)
condition|)
block|{
name|Device
operator|->
name|le_bus
operator|=
name|I2O_HRT_ENTRY_getAdapterID
argument_list|(
name|Entry
argument_list|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|Device
operator|->
name|le_bus
operator|>
name|sc
operator|->
name|ha_MaxBus
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|<=
name|MAX_CHANNEL
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_MaxBus
operator|=
name|Device
operator|->
name|le_bus
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_acquireHrt */
end_comment

begin_comment
comment|/*  *      Enable the adapter.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_enableSys
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|defAlignLong
argument_list|(
name|I2O_EXEC_SYS_ENABLE_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PI2O_EXEC_SYS_ENABLE_MESSAGE
name|Message_Ptr
decl_stmt|;
name|Message_Ptr
operator|=
operator|(
name|PI2O_EXEC_SYS_ENABLE_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_EXEC_SYS_ENABLE_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_EXEC_SYS_ENABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_enableSys */
end_comment

begin_comment
comment|/*  *      Perform the stages necessary to initialize the adapter  */
end_comment

begin_function
name|STATIC
name|int
name|ASR_init
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ASR_initOutBound
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ASR_setSysTab
argument_list|(
name|sc
argument_list|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
name|ASR_enableSys
argument_list|(
name|sc
argument_list|)
operator|!=
name|CAM_REQ_CMP
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_init */
end_comment

begin_comment
comment|/*  *      Send a Synchronize Cache command to the target device.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|ASR_sync
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|int
name|bus
parameter_list|,
name|IN
name|int
name|target
parameter_list|,
name|IN
name|int
name|lun
parameter_list|)
block|{
name|tid_t
name|TID
decl_stmt|;
comment|/*          * We will not synchronize the device when there are outstanding          * commands issued by the OS (this is due to a locked up device,          * as the OS normally would flush all outstanding commands before          * issuing a shutdown or an adapter reset).          */
if|if
condition|(
operator|(
name|sc
operator|!=
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|)
operator|!=
operator|(
expr|struct
name|ccb_hdr
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|TID
operator|=
name|ASR_getTid
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
operator|)
operator|!=
operator|(
name|tid_t
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|TID
operator|!=
operator|(
name|tid_t
operator|)
literal|0
operator|)
condition|)
block|{
name|defAlignLong
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
name|Message_Ptr
decl_stmt|;
name|bzero
argument_list|(
name|Message_Ptr
operator|=
name|getAlignLong
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|,
name|Message
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
operator||
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_PRIVATE_MESSAGE
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setTargetAddress
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setXFunctionCode
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCSI_SCB_EXEC
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setTID
argument_list|(
name|Message_Ptr
argument_list|,
name|TID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setOrganizationID
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|DPT_ORGANIZATION_ID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setCDBLength
argument_list|(
name|Message_Ptr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|0
index|]
operator|=
name|SYNCHRONIZE_CACHE
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|1
index|]
operator|=
operator|(
name|lun
operator|<<
literal|5
operator|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
name|I2O_SCB_FLAG_XFER_FROM_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|STATIC
name|INLINE
name|void
name|ASR_synchronize
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|bus
decl_stmt|,
name|target
decl_stmt|,
name|lun
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<=
name|sc
operator|->
name|ha_MaxBus
condition|;
operator|++
name|bus
control|)
block|{
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<=
name|sc
operator|->
name|ha_MaxId
condition|;
operator|++
name|target
control|)
block|{
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<=
name|sc
operator|->
name|ha_MaxLun
condition|;
operator|++
name|lun
control|)
block|{
name|ASR_sync
argument_list|(
name|sc
argument_list|,
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *      Reset the HBA, targets and BUS.  *              Currently this resets *all* the SCSI busses.  */
end_comment

begin_function
name|STATIC
name|INLINE
name|void
name|asr_hbareset
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|ASR_synchronize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_hbareset */
end_comment

begin_comment
comment|/*  *      A reduced copy of the real pci_map_mem, incorporating the MAX_MAP  * limit and a reduction in error checking (in the pre 4.0 case).  */
end_comment

begin_function
name|STATIC
name|int
name|asr_pci_map_mem
parameter_list|(
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|IN
name|device_t
name|tag
parameter_list|,
else|#
directive|else
name|IN
name|pcici_t
name|tag
parameter_list|,
endif|#
directive|endif
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|u_int32_t
name|p
decl_stmt|,
name|l
decl_stmt|,
name|s
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
comment|/*          * I2O specification says we must find first *memory* mapped BAR          */
for|for
control|(
name|rid
operator|=
name|PCIR_MAPS
init|;
name|rid
operator|<
operator|(
name|PCIR_MAPS
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|;
name|rid
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
control|)
block|{
name|p
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
comment|/*          *      Give up?          */
if|if
condition|(
name|rid
operator|>=
operator|(
name|PCIR_MAPS
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|)
block|{
name|rid
operator|=
name|PCIR_MAPS
expr_stmt|;
block|}
name|p
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
operator|-
operator|(
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
operator|&
operator|~
literal|15
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|MAX_MAP
condition|)
block|{
name|l
operator|=
name|MAX_MAP
expr_stmt|;
block|}
comment|/*          * The 2005S Zero Channel RAID solution is not a perfect PCI          * citizen. It asks for 4MB on BAR0, and 0MB on BAR1, once          * enabled it rewrites the size of BAR0 to 2MB, sets BAR1 to          * BAR0+2MB and sets it's size to 2MB. The IOP registers are          * accessible via BAR0, the messaging registers are accessible          * via BAR1. If the subdevice code is 50 to 59 decimal.          */
name|s
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0xA5111044
condition|)
block|{
name|s
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|ADPTDOMINATOR_SUB_ID_START
operator|^
name|s
operator|)
operator|&
literal|0xF000FFFF
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ADPTDOMINATOR_SUB_ID_START
operator|<=
name|s
operator|)
operator|&&
operator|(
name|s
operator|<=
name|ADPTDOMINATOR_SUB_ID_END
operator|)
condition|)
block|{
name|l
operator|=
name|MAX_MAP
expr_stmt|;
comment|/* Conjoined BAR Raptor Daptor */
block|}
block|}
name|p
operator|&=
operator|~
literal|15
expr_stmt|;
name|sc
operator|->
name|ha_mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|tag
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|l
argument_list|,
name|l
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_mem_res
operator|==
operator|(
expr|struct
name|resource
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_Base
operator|=
operator|(
name|void
operator|*
operator|)
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ha_mem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_Base
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_Virt
operator|=
operator|(
name|i2oRegs_t
operator|*
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|ha_mem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0xA5111044
condition|)
block|{
comment|/* Split BAR Raptor Daptor */
if|if
condition|(
operator|(
name|rid
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|>=
operator|(
name|PCIR_MAPS
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|p
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
literal|0
operator|-
operator|(
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
operator|&
operator|~
literal|15
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|MAX_MAP
condition|)
block|{
name|l
operator|=
name|MAX_MAP
expr_stmt|;
block|}
name|p
operator|&=
operator|~
literal|15
expr_stmt|;
name|sc
operator|->
name|ha_mes_res
operator|=
name|bus_alloc_resource
argument_list|(
name|tag
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|l
argument_list|,
name|l
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_mes_res
operator|==
operator|(
expr|struct
name|resource
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ha_mes_res
argument_list|)
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_Fvirt
operator|=
operator|(
name|U8
operator|*
operator|)
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|ha_mes_res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ha_Fvirt
operator|=
operator|(
name|U8
operator|*
operator|)
operator|(
name|sc
operator|->
name|ha_Virt
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|vm_size_t
name|psize
decl_stmt|,
name|poffs
decl_stmt|;
comment|/*          * I2O specification says we must find first *memory* mapped BAR          */
for|for
control|(
name|rid
operator|=
name|PCI_MAP_REG_START
init|;
name|rid
operator|<
operator|(
name|PCI_MAP_REG_START
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|;
name|rid
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
control|)
block|{
name|p
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|rid
operator|>=
operator|(
name|PCI_MAP_REG_START
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|)
block|{
name|rid
operator|=
name|PCI_MAP_REG_START
expr_stmt|;
block|}
comment|/*         **      save old mapping, get size and type of memory         **         **      type is in the lowest four bits.         **      If device requires 2^n bytes, the next         **      n-4 bits are read as 0.         */
name|sc
operator|->
name|ha_Base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|p
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|)
operator|)
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|l
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/*         **      check the type         */
if|if
condition|(
operator|!
operator|(
operator|(
name|l
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|==
name|PCI_MAP_MEMORY_TYPE_32BIT_1M
operator|&&
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Base
operator|&
operator|~
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|l
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|!=
name|PCI_MAP_MEMORY_TYPE_32BIT
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"asr_pci_map_mem failed: bad memory type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/*         **      get the size.         */
name|psize
operator|=
operator|-
operator|(
name|l
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|psize
operator|>
name|MAX_MAP
condition|)
block|{
name|psize
operator|=
name|MAX_MAP
expr_stmt|;
block|}
comment|/*          * The 2005S Zero Channel RAID solution is not a perfect PCI          * citizen. It asks for 4MB on BAR0, and 0MB on BAR1, once          * enabled it rewrites the size of BAR0 to 2MB, sets BAR1 to          * BAR0+2MB and sets it's size to 2MB. The IOP registers are          * accessible via BAR0, the messaging registers are accessible          * via BAR1. If the subdevice code is 50 to 59 decimal.          */
name|s
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0xA5111044
condition|)
block|{
name|s
operator|=
name|pci_conf_read
argument_list|(
argument|tag
argument_list|,
argument|PCIR_SUBVEND_0
argument_list|)
if|if
condition|(
operator|(
operator|(
operator|(
name|ADPTDOMINATOR_SUB_ID_START
operator|^
name|s
operator|)
operator|&
literal|0xF000FFFF
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ADPTDOMINATOR_SUB_ID_START
operator|<=
name|s
operator|)
operator|&&
operator|(
name|s
operator|<=
name|ADPTDOMINATOR_SUB_ID_END
operator|)
condition|)
block|{
name|psize
operator|=
name|MAX_MAP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_Base
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_Base
operator|==
operator|(
name|void
operator|*
operator|)
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"asr_pci_map_mem: not configured by bios.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/*         **      Truncate sc->ha_Base to page boundary.         **      (Or does pmap_mapdev the job?)         */
name|poffs
operator|=
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Base
operator|-
name|trunc_page
argument_list|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Base
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_Virt
operator|=
operator|(
name|i2oRegs_t
operator|*
operator|)
name|pmap_mapdev
argument_list|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Base
operator|-
name|poffs
argument_list|,
name|psize
operator|+
name|poffs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_Virt
operator|==
operator|(
name|i2oRegs_t
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_Virt
operator|=
operator|(
name|i2oRegs_t
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Virt
operator|+
name|poffs
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0xA5111044
condition|)
block|{
if|if
condition|(
operator|(
name|rid
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|>=
operator|(
name|PCI_MAP_REG_START
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*                 **      save old mapping, get size and type of memory                 **                 **      type is in the lowest four bits.                 **      If device requires 2^n bytes, the next                 **      n-4 bits are read as 0.                 */
if|if
condition|(
operator|(
operator|(
operator|(
name|p
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|)
operator|)
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
operator|==
literal|0L
operator|)
operator|||
operator|(
operator|(
name|p
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
operator|==
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"asr_pci_map_mem: not configured by bios.\n"
argument_list|)
expr_stmt|;
block|}
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|l
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|rid
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|&=
name|PCI_MAP_MEMORY_TYPE_MASK
expr_stmt|;
comment|/*                 **      check the type                 */
if|if
condition|(
operator|!
operator|(
operator|(
name|l
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|==
name|PCI_MAP_MEMORY_TYPE_32BIT_1M
operator|&&
operator|(
name|p
operator|&
operator|~
literal|0xfffff
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|l
operator|&
name|PCI_MAP_MEMORY_TYPE_MASK
operator|)
operator|!=
name|PCI_MAP_MEMORY_TYPE_32BIT
operator|)
condition|)
block|{
name|debug_asr_printf
argument_list|(
literal|"asr_pci_map_mem failed: bad memory type=0x%x\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
empty_stmt|;
comment|/*                 **      get the size.                 */
name|psize
operator|=
operator|-
operator|(
name|l
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|psize
operator|>
name|MAX_MAP
condition|)
block|{
name|psize
operator|=
name|MAX_MAP
expr_stmt|;
block|}
comment|/*                 **      Truncate p to page boundary.                 **      (Or does pmap_mapdev the job?)                 */
name|poffs
operator|=
name|p
operator|-
name|trunc_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_Fvirt
operator|=
operator|(
name|U8
operator|*
operator|)
name|pmap_mapdev
argument_list|(
name|p
operator|-
name|poffs
argument_list|,
name|psize
operator|+
name|poffs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_Fvirt
operator|==
operator|(
name|U8
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_Fvirt
operator|=
operator|(
name|U8
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Fvirt
operator|+
name|poffs
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ha_Fvirt
operator|=
operator|(
name|U8
operator|*
operator|)
operator|(
name|sc
operator|->
name|ha_Virt
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_pci_map_mem */
end_comment

begin_comment
comment|/*  *      A simplified copy of the real pci_map_int with additional  * registration requirements.  */
end_comment

begin_function
name|STATIC
name|int
name|asr_pci_map_int
parameter_list|(
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|IN
name|device_t
name|tag
parameter_list|,
else|#
directive|else
name|IN
name|pcici_t
name|tag
parameter_list|,
endif|#
directive|endif
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|ha_irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|tag
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_irq_res
operator|==
operator|(
expr|struct
name|resource
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|tag
argument_list|,
name|sc
operator|->
name|ha_irq_res
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_ENTROPY
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|asr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|ha_intr
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_irq
operator|=
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|PCIR_INTLINE
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|tag
argument_list|,
operator|(
name|pci_inthand_t
operator|*
operator|)
name|asr_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|cam_imask
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|ha_irq
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCIR_INTLINE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_pci_map_int */
end_comment

begin_comment
comment|/*  *      Attach the devices, and virtual devices to the driver list.  */
end_comment

begin_function
name|STATIC
name|ATTACH_RET
name|asr_attach
parameter_list|(
name|ATTACH_ARGS
parameter_list|)
block|{
name|Asr_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|iq
decl_stmt|;
name|ATTACH_SET
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|ATTACH_RETURN
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Asr_softc
operator|==
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*                  *      Fixup the OS revision as saved in the dptsig for the                  *      engine (dptioctl.h) to pick up.                  */
name|bcopy
argument_list|(
name|osrelease
argument_list|,
operator|&
name|ASR_sig
operator|.
name|dsDescription
index|[
literal|16
index|]
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"asr%d: major=%d\n"
argument_list|,
name|unit
argument_list|,
name|asr_cdevsw
operator|.
name|d_maj
argument_list|)
expr_stmt|;
block|}
comment|/*          *      Initialize the software structure          */
name|LIST_INIT
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_ccb
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
block|{
name|u_int32_t
name|i
decl_stmt|;
comment|/* initialize free list for timeQ */
name|sc
operator|->
name|ha_timeQFreeHead
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|ha_timeQFreeTail
operator|=
name|MAX_TIMEQ_SIZE
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_TIMEQ_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ha_timeQFreeList
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Link us into the HA list */
block|{
name|Asr_softc_t
modifier|*
modifier|*
name|ha
decl_stmt|;
for|for
control|(
name|ha
operator|=
operator|&
name|Asr_softc
init|;
operator|*
name|ha
condition|;
name|ha
operator|=
operator|&
operator|(
operator|(
operator|*
name|ha
operator|)
operator|->
name|ha_next
operator|)
control|)
empty_stmt|;
operator|*
operator|(
name|ha
operator|)
operator|=
name|sc
expr_stmt|;
block|}
block|{
name|PI2O_EXEC_STATUS_GET_REPLY
name|status
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/*                  *      This is the real McCoy!                  */
if|if
condition|(
operator|!
name|asr_pci_map_mem
argument_list|(
name|tag
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d: could not map memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ATTACH_RETURN
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* Enable if not formerly enabled */
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
name|pci_write_config
argument_list|(
name|tag
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_read_config
argument_list|(
name|tag
argument_list|,
name|PCIR_COMMAND
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Knowledge is power, responsibility is direct */
block|{
struct|struct
name|pci_devinfo
block|{
name|STAILQ_ENTRY
argument_list|(
argument|pci_devinfo
argument_list|)
name|pci_links
expr_stmt|;
name|struct
name|resource_list
name|resources
decl_stmt|;
name|pcicfgregs
name|cfg
decl_stmt|;
block|}
modifier|*
name|dinfo
init|=
name|device_get_ivars
argument_list|(
name|tag
argument_list|)
struct|;
name|sc
operator|->
name|ha_pciBusNum
operator|=
name|dinfo
operator|->
name|cfg
operator|.
name|bus
expr_stmt|;
name|sc
operator|->
name|ha_pciDeviceNum
operator|=
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|slot
operator|<<
literal|3
operator|)
operator||
name|dinfo
operator|->
name|cfg
operator|.
name|func
expr_stmt|;
block|}
else|#
directive|else
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCIR_COMMAND
argument_list|)
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
argument_list|)
expr_stmt|;
comment|/* Knowledge is power, responsibility is direct */
switch|switch
condition|(
name|pci_mechanism
condition|)
block|{
case|case
literal|1
case|:
name|sc
operator|->
name|ha_pciBusNum
operator|=
name|tag
operator|.
name|cfg1
operator|>>
literal|16
expr_stmt|;
name|sc
operator|->
name|ha_pciDeviceNum
operator|=
name|tag
operator|.
name|cfg1
operator|>>
literal|8
expr_stmt|;
case|case
literal|2
case|:
name|sc
operator|->
name|ha_pciBusNum
operator|=
name|tag
operator|.
name|cfg2
operator|.
name|forward
expr_stmt|;
name|sc
operator|->
name|ha_pciDeviceNum
operator|=
operator|(
operator|(
name|tag
operator|.
name|cfg2
operator|.
name|enable
operator|>>
literal|1
operator|)
operator|&
literal|7
operator|)
operator||
operator|(
name|tag
operator|.
name|cfg2
operator|.
name|port
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check if the device is there? */
if|if
condition|(
operator|(
name|ASR_resetIOP
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|status
operator|=
operator|(
name|PI2O_EXEC_STATUS_GET_REPLY
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_EXEC_STATUS_GET_REPLY
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_EXEC_STATUS_GET_REPLY
operator|)
name|NULL
operator|)
operator|||
operator|(
name|ASR_getStatus
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|,
name|status
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d: could not initialize hardware\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ATTACH_RETURN
argument_list|(
name|ENODEV
argument_list|)
expr_stmt|;
comment|/* Get next, maybe better luck */
block|}
name|sc
operator|->
name|ha_SystemTable
operator|.
name|OrganizationID
operator|=
name|status
operator|->
name|OrganizationID
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|IOP_ID
operator|=
name|status
operator|->
name|IOP_ID
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|I2oVersion
operator|=
name|status
operator|->
name|I2oVersion
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|IopState
operator|=
name|status
operator|->
name|IopState
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|MessengerType
operator|=
name|status
operator|->
name|MessengerType
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|InboundMessageFrameSize
operator|=
name|status
operator|->
name|InboundMFrameSize
expr_stmt|;
name|sc
operator|->
name|ha_SystemTable
operator|.
name|MessengerInfo
operator|.
name|InboundMessagePortAddressLow
operator|=
call|(
name|U32
call|)
argument_list|(
name|sc
operator|->
name|ha_Base
argument_list|)
operator|+
call|(
name|U32
call|)
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|i2oRegs_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|ToFIFO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|asr_pci_map_int
argument_list|(
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d: could not map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ATTACH_RETURN
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust the maximim inbound count */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|ha_QueueSize
operator|=
name|I2O_EXEC_STATUS_GET_REPLY_getMaxInboundMFrames
argument_list|(
name|status
argument_list|)
operator|)
operator|>
name|MAX_INBOUND
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_QueueSize
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_QueueSize
operator|=
name|MAX_INBOUND
expr_stmt|;
block|}
comment|/* Adjust the maximum outbound count */
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|ha_Msgs_Count
operator|=
name|I2O_EXEC_STATUS_GET_REPLY_getMaxOutboundMFrames
argument_list|(
name|status
argument_list|)
operator|)
operator|>
name|MAX_OUTBOUND
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_Msgs_Count
operator|==
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_Msgs_Count
operator|=
name|MAX_OUTBOUND
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ha_Msgs_Count
operator|>
name|sc
operator|->
name|ha_QueueSize
condition|)
block|{
name|sc
operator|->
name|ha_Msgs_Count
operator|=
name|sc
operator|->
name|ha_QueueSize
expr_stmt|;
block|}
comment|/* Adjust the maximum SG size to adapter */
if|if
condition|(
operator|(
name|size
operator|=
operator|(
name|I2O_EXEC_STATUS_GET_REPLY_getInboundMFrameSize
argument_list|(
name|status
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|>
name|MAX_INBOUND_SIZE
condition|)
block|{
name|size
operator|=
name|MAX_INBOUND_SIZE
expr_stmt|;
block|}
name|free
argument_list|(
name|status
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_SgSize
operator|=
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
expr_stmt|;
block|}
comment|/*          *      Only do a bus/HBA reset on the first time through. On this          * first time through, we do not send a flush to the devices.          */
if|if
condition|(
name|ASR_init
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
struct|struct
name|BufferInfo
block|{
name|I2O_PARAM_RESULTS_LIST_HEADER
name|Header
decl_stmt|;
name|I2O_PARAM_READ_OPERATION_RESULT
name|Read
decl_stmt|;
name|I2O_DPT_EXEC_IOP_BUFFERS_SCALAR
name|Info
decl_stmt|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|BufferInfo
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|PI2O_DPT_EXEC_IOP_BUFFERS_SCALAR
name|Info
decl_stmt|;
define|#
directive|define
name|FW_DEBUG_BLED_OFFSET
value|8
if|if
condition|(
operator|(
name|Info
operator|=
operator|(
name|PI2O_DPT_EXEC_IOP_BUFFERS_SCALAR
operator|)
name|ASR_getParams
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO
argument_list|,
name|Buffer
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|BufferInfo
argument_list|)
argument_list|)
operator|)
operator|!=
operator|(
name|PI2O_DPT_EXEC_IOP_BUFFERS_SCALAR
operator|)
name|NULL
condition|)
block|{
name|sc
operator|->
name|ha_blinkLED
operator|=
name|sc
operator|->
name|ha_Fvirt
operator|+
name|I2O_DPT_EXEC_IOP_BUFFERS_SCALAR_getSerialOutputOffset
argument_list|(
name|Info
argument_list|)
operator|+
name|FW_DEBUG_BLED_OFFSET
expr_stmt|;
block|}
if|if
condition|(
name|ASR_acquireLct
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ASR_acquireHrt
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"asr%d: failed to initialize\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ATTACH_RETURN
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
comment|/*          *      Add in additional probe responses for more channels. We          * are reusing the variable `target' for a channel loop counter.          * Done here because of we need both the acquireLct and          * acquireHrt data.          */
block|{
name|PI2O_LCT_ENTRY
name|Device
decl_stmt|;
for|for
control|(
name|Device
operator|=
name|sc
operator|->
name|ha_LCT
operator|->
name|LCTEntry
init|;
name|Device
operator|<
call|(
name|PI2O_LCT_ENTRY
call|)
argument_list|(
operator|(
operator|(
name|U32
operator|*
operator|)
name|sc
operator|->
name|ha_LCT
operator|)
operator|+
name|I2O_LCT_getTableSize
argument_list|(
name|sc
operator|->
name|ha_LCT
argument_list|)
argument_list|)
condition|;
operator|++
name|Device
control|)
block|{
if|if
condition|(
name|Device
operator|->
name|le_type
operator|==
name|I2O_UNKNOWN
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|I2O_LCT_ENTRY_getUserTID
argument_list|(
name|Device
argument_list|)
operator|==
literal|0xFFF
condition|)
block|{
if|if
condition|(
name|Device
operator|->
name|le_target
operator|>
name|sc
operator|->
name|ha_MaxId
condition|)
block|{
name|sc
operator|->
name|ha_MaxId
operator|=
name|Device
operator|->
name|le_target
expr_stmt|;
block|}
if|if
condition|(
name|Device
operator|->
name|le_lun
operator|>
name|sc
operator|->
name|ha_MaxLun
condition|)
block|{
name|sc
operator|->
name|ha_MaxLun
operator|=
name|Device
operator|->
name|le_lun
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|Device
operator|->
name|le_type
operator|&
name|I2O_PORT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|Device
operator|->
name|le_bus
operator|<=
name|MAX_CHANNEL
operator|)
condition|)
block|{
comment|/* Do not increase MaxId for efficiency */
name|sc
operator|->
name|ha_adapter_target
index|[
name|Device
operator|->
name|le_bus
index|]
operator|=
name|Device
operator|->
name|le_target
expr_stmt|;
block|}
block|}
block|}
comment|/*          *      Print the HBA model number as inquired from the card.          */
name|printf
argument_list|(
literal|"asr%d:"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iq
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|NULL
condition|)
block|{
name|defAlignLong
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
name|Message_Ptr
decl_stmt|;
name|int
name|posted
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|Message_Ptr
operator|=
name|getAlignLong
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|,
name|Message
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setVersionOffset
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_VERSION_11
operator||
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SG_ELEMENT
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setInitiatorAddress
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_PRIVATE_MESSAGE
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setXFunctionCode
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|I2O_SCSI_SCB_EXEC
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setInterpret
argument_list|(
name|Message_Ptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|I2O_PRIVATE_MESSAGE_FRAME_setOrganizationID
argument_list|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
name|DPT_ORGANIZATION_ID
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setCDBLength
argument_list|(
name|Message_Ptr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|0
index|]
operator|=
name|INQUIRY
expr_stmt|;
name|Message_Ptr
operator|->
name|CDB
index|[
literal|4
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|Message_Ptr
operator|->
name|CDB
index|[
literal|4
index|]
operator|==
literal|0
condition|)
block|{
name|Message_Ptr
operator|->
name|CDB
index|[
literal|4
index|]
operator|=
literal|255
expr_stmt|;
block|}
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setSCBFlags
argument_list|(
name|Message_Ptr
argument_list|,
operator|(
name|I2O_SCB_FLAG_XFER_FROM_DEVICE
operator||
name|I2O_SCB_FLAG_ENABLE_DISCONNECT
operator||
name|I2O_SCB_FLAG_SIMPLE_QUEUE_TAG
operator||
name|I2O_SCB_FLAG_SENSE_DATA_IN_BUFFER
operator|)
argument_list|)
expr_stmt|;
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_setByteCount
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
name|SG
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|SGL
operator|)
argument_list|,
literal|0
argument_list|,
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator||
name|I2O_SGL_FLAGS_END_OF_BUFFER
argument_list|,
name|iq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue_c
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|iq
operator|->
name|vendor
index|[
literal|0
index|]
operator|&&
operator|(
name|iq
operator|->
name|vendor
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|ASR_prstring
argument_list|(
name|iq
operator|->
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|++
name|posted
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|product
index|[
literal|0
index|]
operator|&&
operator|(
name|iq
operator|->
name|product
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|ASR_prstring
argument_list|(
name|iq
operator|->
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|++
name|posted
expr_stmt|;
block|}
if|if
condition|(
name|iq
operator|->
name|revision
index|[
literal|0
index|]
operator|&&
operator|(
name|iq
operator|->
name|revision
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" FW Rev. "
argument_list|)
expr_stmt|;
name|ASR_prstring
argument_list|(
name|iq
operator|->
name|revision
argument_list|,
literal|4
argument_list|)
expr_stmt|;
operator|++
name|posted
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|iq
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|posted
condition|)
block|{
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|" %d channel, %d CCBs, Protocol I2O\n"
argument_list|,
name|sc
operator|->
name|ha_MaxBus
operator|+
literal|1
argument_list|,
operator|(
name|sc
operator|->
name|ha_QueueSize
operator|>
name|MAX_INBOUND
operator|)
condition|?
name|MAX_INBOUND
else|:
name|sc
operator|->
name|ha_QueueSize
argument_list|)
expr_stmt|;
comment|/*          * fill in the prototype cam_path.          */
block|{
name|int
name|bus
decl_stmt|;
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|asr_alloc_ccb
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d: CAM could not be notified of asynchronous callback parameters\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ATTACH_RETURN
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<=
name|sc
operator|->
name|ha_MaxBus
condition|;
operator|++
name|bus
control|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|QueueSize
init|=
name|sc
operator|->
name|ha_QueueSize
decl_stmt|;
if|if
condition|(
name|QueueSize
operator|>
name|MAX_INBOUND
condition|)
block|{
name|QueueSize
operator|=
name|MAX_INBOUND
expr_stmt|;
block|}
comment|/*                          *      Create the device queue for our SIM(s).                          */
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|QueueSize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/*                          *      Construct our first channel SIM entry                          */
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|=
name|cam_sim_alloc
argument_list|(
name|asr_action
argument_list|,
name|asr_poll
argument_list|,
literal|"asr"
argument_list|,
name|sc
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|QueueSize
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|,
name|bus
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_path
index|[
name|bus
index|]
operator|)
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_sim
index|[
name|bus
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/*          *      Generate the device node information          */
operator|(
name|void
operator|)
name|make_dev
argument_list|(
operator|&
name|asr_cdevsw
argument_list|,
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|S_IRWXU
argument_list|,
literal|"rasr%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ATTACH_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_attach */
end_comment

begin_function
name|STATIC
name|void
name|asr_poll
parameter_list|(
name|IN
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|asr_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* asr_poll */
end_comment

begin_function
name|STATIC
name|void
name|asr_action
parameter_list|(
name|IN
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|IN
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|Asr_softc
modifier|*
name|sc
decl_stmt|;
name|debug_asr_printf
argument_list|(
literal|"asr_action(%lx,%lx{%x})\n"
argument_list|,
operator|(
name|u_long
operator|)
name|sim
argument_list|,
operator|(
name|u_long
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
argument_list|)
expr_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"asr_action\n"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|spriv_ptr0
operator|=
name|sc
operator|=
operator|(
expr|struct
name|Asr_softc
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_SCSI_IO
case|:
comment|/* Execute the requested I/O operation */
block|{
struct|struct
name|Message
block|{
name|char
name|M
index|[
name|MAX_INBOUND_SIZE
index|]
decl_stmt|;
block|}
struct|;
name|defAlignLong
argument_list|(
expr|struct
name|Message
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
comment|/* Reject incoming commands while we are resetting the card */
if|if
condition|(
name|sc
operator|->
name|ha_in_reset
operator|!=
name|HA_OPERATIONAL
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ha_in_reset
operator|>=
name|HA_OFF_LINE
condition|)
block|{
comment|/* HBA is now off-line */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNREC_HBA_ERROR
expr_stmt|;
block|}
else|else
block|{
comment|/* HBA currently resetting, try again later. */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
name|debug_asr_cmd_printf
argument_list|(
literal|" e\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|debug_asr_cmd_printf
argument_list|(
literal|" q\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|printf
argument_list|(
literal|"asr%d WARNING: scsi_cmd(%x) already done on b%dt%du%d\n"
argument_list|,
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
block|}
name|debug_asr_cmd_printf
argument_list|(
literal|"(%d,%d,%d,%d)"
argument_list|,
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
argument_list|)
expr_stmt|;
name|debug_asr_cmd_dump_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
name|ASR_init_message
argument_list|(
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|ccb
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message
argument_list|)
operator|)
operator|!=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
name|debug_asr_cmd2_printf
argument_list|(
literal|"TID=%x:\n"
argument_list|,
name|PRIVATE_SCSI_SCB_EXECUTE_MESSAGE_getTID
argument_list|(
operator|(
name|PPRIVATE_SCSI_SCB_EXECUTE_MESSAGE
operator|)
name|Message_Ptr
argument_list|)
argument_list|)
expr_stmt|;
name|debug_asr_cmd2_dump_message
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
name|debug_asr_cmd1_printf
argument_list|(
literal|" q"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_queue
argument_list|(
name|sc
argument_list|,
name|Message_Ptr
argument_list|)
operator|==
name|EMPTY_QUEUE
condition|)
block|{
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
operator|++
name|sc
operator|->
name|ha_performance
operator|.
name|command_too_busy
expr_stmt|;
endif|#
directive|endif
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
name|debug_asr_cmd_printf
argument_list|(
literal|" E\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
name|debug_asr_cmd_printf
argument_list|(
literal|" Q\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*                  *      We will get here if there is no valid TID for the device                  * referenced in the scsi command packet.                  */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|debug_asr_cmd_printf
argument_list|(
literal|" B\n"
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
comment|/* Rese HBA device ... */
name|asr_hbareset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|REPORT_LUNS
argument_list|)
operator|)
case|case
name|REPORT_LUNS
case|:
endif|#
directive|endif
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|u_int
name|target_mask
decl_stmt|;
name|cts
operator|=
operator|&
operator|(
name|ccb
operator|->
name|cts
operator|)
expr_stmt|;
name|target_mask
operator|=
literal|0x01
operator|<<
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|cts
operator|->
name|flags
operator|=
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|cts
operator|->
name|sync_period
operator|=
literal|6
expr_stmt|;
comment|/* 40MHz */
name|cts
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_DISC_VALID
operator||
name|CCB_TRANS_TQ_VALID
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u_int32_t
name|size_mb
decl_stmt|;
name|u_int32_t
name|secs_per_cylinder
decl_stmt|;
name|ccg
operator|=
operator|&
operator|(
name|ccb
operator|->
name|ccg
operator|)
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|4096
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size_mb
operator|>
literal|2048
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|128
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size_mb
operator|>
literal|1024
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|65
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
name|ASR_resetBus
argument_list|(
name|sc
argument_list|,
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
operator|(
name|ccb
operator|->
name|cpi
operator|)
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
comment|/* Not necessary to reset bus, done by HDM initialization */
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|sc
operator|->
name|ha_MaxId
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|sc
operator|->
name|ha_MaxLun
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|sc
operator|->
name|ha_adapter_target
index|[
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
index|]
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Adaptec"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* asr_action */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
end_ifdef

begin_define
define|#
directive|define
name|WRITE_OP
value|1
end_define

begin_define
define|#
directive|define
name|READ_OP
value|2
end_define

begin_define
define|#
directive|define
name|min_submitR
value|sc->ha_performance.read_by_size_min_time[index]
end_define

begin_define
define|#
directive|define
name|max_submitR
value|sc->ha_performance.read_by_size_max_time[index]
end_define

begin_define
define|#
directive|define
name|min_submitW
value|sc->ha_performance.write_by_size_min_time[index]
end_define

begin_define
define|#
directive|define
name|max_submitW
value|sc->ha_performance.write_by_size_max_time[index]
end_define

begin_function
name|STATIC
name|INLINE
name|void
name|asr_IObySize
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|IN
name|u_int32_t
name|submitted_time
parameter_list|,
name|IN
name|int
name|op
parameter_list|,
name|IN
name|int
name|index
parameter_list|)
block|{
name|struct
name|timeval
name|submitted_timeval
decl_stmt|;
name|submitted_timeval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|submitted_timeval
operator|.
name|tv_usec
operator|=
name|submitted_time
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|READ_OP
condition|)
block|{
operator|++
name|sc
operator|->
name|ha_performance
operator|.
name|read_by_size_count
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|submitted_time
operator|!=
literal|0xffffffff
condition|)
block|{
name|timevaladd
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_performance
operator|.
name|read_by_size_total_time
index|[
name|index
index|]
operator|)
argument_list|,
operator|&
name|submitted_timeval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|min_submitR
operator|==
literal|0
operator|)
operator|||
operator|(
name|submitted_time
operator|<
name|min_submitR
operator|)
condition|)
block|{
name|min_submitR
operator|=
name|submitted_time
expr_stmt|;
block|}
if|if
condition|(
name|submitted_time
operator|>
name|max_submitR
condition|)
block|{
name|max_submitR
operator|=
name|submitted_time
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
operator|++
name|sc
operator|->
name|ha_performance
operator|.
name|write_by_size_count
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|submitted_time
operator|!=
literal|0xffffffff
condition|)
block|{
name|timevaladd
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ha_performance
operator|.
name|write_by_size_total_time
index|[
name|index
index|]
operator|)
argument_list|,
operator|&
name|submitted_timeval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|submitted_time
operator|<
name|min_submitW
operator|)
operator|||
operator|(
name|min_submitW
operator|==
literal|0
operator|)
condition|)
block|{
name|min_submitW
operator|=
name|submitted_time
expr_stmt|;
block|}
if|if
condition|(
name|submitted_time
operator|>
name|max_submitW
condition|)
block|{
name|max_submitW
operator|=
name|submitted_time
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* asr_IObySize */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle processing of current CCB as pointed to by the Status.  */
end_comment

begin_function
name|STATIC
name|int
name|asr_intr
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|OUT
name|int
name|processed
decl_stmt|;
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
name|struct
name|timeval
name|junk
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|junk
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ha_performance
operator|.
name|intr_started
operator|=
name|junk
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|processed
operator|=
literal|0
init|;
name|sc
operator|->
name|ha_Virt
operator|->
name|Status
operator|&
name|Mask_InterruptsDisabled
condition|;
name|processed
operator|=
literal|1
control|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|U32
name|ReplyOffset
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|Reply
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ReplyOffset
operator|=
name|sc
operator|->
name|ha_Virt
operator|->
name|FromFIFO
operator|)
operator|==
name|EMPTY_QUEUE
operator|)
operator|&&
operator|(
operator|(
name|ReplyOffset
operator|=
name|sc
operator|->
name|ha_Virt
operator|->
name|FromFIFO
operator|)
operator|==
name|EMPTY_QUEUE
operator|)
condition|)
block|{
break|break;
block|}
name|Reply
operator|=
call|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
call|)
argument_list|(
name|ReplyOffset
operator|-
name|sc
operator|->
name|ha_Msgs_Phys
operator|+
operator|(
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|ha_Msgs
operator|)
argument_list|)
expr_stmt|;
comment|/*                  * We do not need any (optional byteswapping) method access to                  * the Initiator context field.                  */
name|ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
operator|(
name|long
operator|)
name|I2O_MESSAGE_FRAME_getInitiatorContext64
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|I2O_MESSAGE_FRAME_getMsgFlags
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
operator|&
name|I2O_MESSAGE_FLAGS_FAIL
condition|)
block|{
name|defAlignLong
argument_list|(
name|I2O_UTIL_NOP_MESSAGE
argument_list|,
name|Message
argument_list|)
expr_stmt|;
name|PI2O_UTIL_NOP_MESSAGE
name|Message_Ptr
decl_stmt|;
name|U32
name|MessageOffset
decl_stmt|;
name|MessageOffset
operator|=
operator|(
name|u_long
operator|)
name|I2O_FAILURE_REPLY_MESSAGE_FRAME_getPreservedMFA
argument_list|(
operator|(
name|PI2O_FAILURE_REPLY_MESSAGE_FRAME
operator|)
name|Reply
argument_list|)
expr_stmt|;
comment|/*                          *  Get the Original Message Frame's address, and get                          * it's Transaction Context into our space. (Currently                          * unused at original authorship, but better to be                          * safe than sorry). Straight copy means that we                          * need not concern ourselves with the (optional                          * byteswapping) method access.                          */
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|TransactionContext
operator|=
operator|(
call|(
name|PI2O_SINGLE_REPLY_MESSAGE_FRAME
call|)
argument_list|(
name|sc
operator|->
name|ha_Fvirt
operator|+
name|MessageOffset
argument_list|)
operator|)
operator|->
name|TransactionContext
expr_stmt|;
comment|/*                          *      For 64 bit machines, we need to reconstruct the                          * 64 bit context.                          */
name|ccb
operator|=
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
operator|(
name|long
operator|)
name|I2O_MESSAGE_FRAME_getInitiatorContext64
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
expr_stmt|;
comment|/*                          * Unique error code for command failure.                          */
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_setDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|)
argument_list|,
operator|(
name|u_int16_t
operator|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/*                          *  Modify the message frame to contain a NOP and                          * re-issue it to the controller.                          */
name|Message_Ptr
operator|=
operator|(
name|PI2O_UTIL_NOP_MESSAGE
operator|)
name|ASR_fillMessage
argument_list|(
name|Message
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_UTIL_NOP_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|I2O_UTIL_NOP
operator|!=
literal|0
operator|)
name|I2O_MESSAGE_FRAME_setFunction
argument_list|(
operator|&
operator|(
name|Message_Ptr
operator|->
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_UTIL_NOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*                          *  Copy the packet out to the Original Message                          */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
name|sc
operator|->
name|ha_Fvirt
operator|+
name|MessageOffset
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_UTIL_NOP_MESSAGE
argument_list|)
argument_list|)
expr_stmt|;
comment|/*                          *  Issue the NOP                          */
name|sc
operator|->
name|ha_Virt
operator|->
name|ToFIFO
operator|=
name|MessageOffset
expr_stmt|;
block|}
comment|/*                  *      Asynchronous command with no return requirements,                  * and a generic handler for immunity against odd error                  * returns from the adapter.                  */
if|if
condition|(
name|ccb
operator|==
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/*                          * Return Reply so that it can be used for the                          * next command                          */
name|sc
operator|->
name|ha_Virt
operator|->
name|FromFIFO
operator|=
name|ReplyOffset
expr_stmt|;
continue|continue;
block|}
comment|/* Welease Wadjah! (and stop timeouts) */
name|ASR_ccbRemove
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_getDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply
operator|->
name|StdReplyFrame
operator|)
argument_list|)
condition|)
block|{
case|case
name|I2O_SCSI_DSC_SUCCESS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_DSC_CHECK_CONDITION
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_DSC_BUSY
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_ADAPTER_BUSY
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_SCSI_BUS_RESET
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_BUS_BUSY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_BUSY
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_HBA_DSC_SELECTION_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_HBA_DSC_COMMAND_TIMEOUT
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_DEVICE_NOT_PRESENT
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_LUN_INVALID
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_SCSI_TID_INVALID
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
case|case
name|I2O_SCSI_HBA_DSC_DATA_OVERRUN
case|:
comment|/* FALLTHRU */
case|case
name|I2O_SCSI_HBA_DSC_REQUEST_LENGTH_ERROR
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DATA_RUN_ERR
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|)
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|-=
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_getTransferCount
argument_list|(
name|Reply
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
block|{
name|struct
name|timeval
name|endTime
decl_stmt|;
name|u_int32_t
name|submitted_time
decl_stmt|;
name|u_int32_t
name|size
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|int
name|startTimeIndex
decl_stmt|;
operator|--
name|sc
operator|->
name|ha_submitted_ccbs_count
expr_stmt|;
name|startTimeIndex
operator|=
operator|(
name|int
operator|)
name|Reply
operator|->
name|StdReplyFrame
operator|.
name|TransactionContext
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|startTimeIndex
condition|)
block|{
comment|/* Compute the time spent in device/adapter */
name|microtime
argument_list|(
operator|&
name|endTime
argument_list|)
expr_stmt|;
name|submitted_time
operator|=
name|asr_time_delta
argument_list|(
name|sc
operator|->
name|ha_timeQ
index|[
name|startTimeIndex
index|]
argument_list|,
name|endTime
argument_list|)
expr_stmt|;
comment|/* put the startTimeIndex back on free list */
name|ENQ_TIMEQ_FREE_LIST
argument_list|(
name|startTimeIndex
argument_list|,
name|sc
operator|->
name|ha_timeQFreeList
argument_list|,
name|sc
operator|->
name|ha_timeQFreeHead
argument_list|,
name|sc
operator|->
name|ha_timeQFreeTail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|submitted_time
operator|=
literal|0xffffffff
expr_stmt|;
block|}
define|#
directive|define
name|maxctime
value|sc->ha_performance.max_command_time[ccb->csio.cdb_io.cdb_bytes[0]]
define|#
directive|define
name|minctime
value|sc->ha_performance.min_command_time[ccb->csio.cdb_io.cdb_bytes[0]]
if|if
condition|(
name|submitted_time
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|maxctime
operator|<
name|submitted_time
condition|)
block|{
name|maxctime
operator|=
name|submitted_time
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minctime
operator|==
literal|0
operator|)
operator|||
operator|(
name|minctime
operator|>
name|submitted_time
operator|)
condition|)
block|{
name|minctime
operator|=
name|submitted_time
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ha_performance
operator|.
name|max_submit_time
operator|<
name|submitted_time
condition|)
block|{
name|sc
operator|->
name|ha_performance
operator|.
name|max_submit_time
operator|=
name|submitted_time
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ha_performance
operator|.
name|min_submit_time
operator|==
literal|0
operator|||
name|sc
operator|->
name|ha_performance
operator|.
name|min_submit_time
operator|>
name|submitted_time
condition|)
block|{
name|sc
operator|->
name|ha_performance
operator|.
name|min_submit_time
operator|=
name|submitted_time
expr_stmt|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0xa8
case|:
comment|/* 12-byte READ */
comment|/* FALLTHRU */
case|case
literal|0x08
case|:
comment|/* 6-byte READ  */
comment|/* FALLTHRU */
case|case
literal|0x28
case|:
comment|/* 10-byte READ */
name|op_type
operator|=
name|READ_OP
expr_stmt|;
break|break;
case|case
literal|0x0a
case|:
comment|/* 6-byte WRITE */
comment|/* FALLTHRU */
case|case
literal|0xaa
case|:
comment|/* 12-byte WRITE */
comment|/* FALLTHRU */
case|case
literal|0x2a
case|:
comment|/* 10-byte WRITE */
name|op_type
operator|=
name|WRITE_OP
expr_stmt|;
break|break;
default|default:
name|op_type
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_type
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_rw_big
modifier|*
name|cmd
decl_stmt|;
name|cmd
operator|=
operator|(
expr|struct
name|scsi_rw_big
operator|*
operator|)
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|cmd
operator|->
name|length2
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int32_t
operator|)
name|cmd
operator|->
name|length1
operator|)
operator|)
operator|<<
literal|9
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|512
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_512
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1024
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_1K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2048
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_2K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4096
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_4K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8192
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_8K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_16K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_32K
argument_list|)
expr_stmt|;
break|break;
case|case
literal|65536
case|:
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_64K
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|size
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_BIGGER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asr_IObySize
argument_list|(
name|sc
argument_list|,
name|submitted_time
argument_list|,
name|op_type
argument_list|,
name|SIZE_OTHER
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Sense data in reply packet */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
condition|)
block|{
name|u_int16_t
name|size
init|=
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_getAutoSenseTransferCount
argument_list|(
name|Reply
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>
name|I2O_SCSI_SENSE_DATA_SZ
condition|)
block|{
name|size
operator|=
name|I2O_SCSI_SENSE_DATA_SZ
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|)
operator|&&
operator|(
name|size
operator|>
name|ccb
operator|->
name|csio
operator|.
name|sense_len
operator|)
condition|)
block|{
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply
operator|->
name|SenseData
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*                  * Return Reply so that it can be used for the next command                  * since we have no more need for it now                  */
name|sc
operator|->
name|ha_Virt
operator|->
name|FromFIFO
operator|=
name|ReplyOffset
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
condition|)
block|{
name|xpt_done
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
block|{
name|u_int32_t
name|result
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|junk
argument_list|)
expr_stmt|;
name|result
operator|=
name|asr_time_delta
argument_list|(
name|sc
operator|->
name|ha_performance
operator|.
name|intr_started
argument_list|,
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ha_performance
operator|.
name|max_intr_time
operator|<
name|result
condition|)
block|{
name|sc
operator|->
name|ha_performance
operator|.
name|max_intr_time
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|ha_performance
operator|.
name|min_intr_time
operator|==
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|ha_performance
operator|.
name|min_intr_time
operator|>
name|result
operator|)
condition|)
block|{
name|sc
operator|->
name|ha_performance
operator|.
name|min_intr_time
operator|=
name|result
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|processed
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_intr */
end_comment

begin_undef
undef|#
directive|undef
name|QueueSize
end_undef

begin_comment
comment|/* Grrrr */
end_comment

begin_undef
undef|#
directive|undef
name|SG_Size
end_undef

begin_comment
comment|/* Grrrr */
end_comment

begin_comment
comment|/*  *      Meant to be included at the bottom of asr.c !!!  */
end_comment

begin_comment
comment|/*  *      Included here as hard coded. Done because other necessary include  *      files utilize C++ comment structures which make them a nuisance to  *      included here just to pick up these three typedefs.  */
end_comment

begin_typedef
typedef|typedef
name|U32
name|DPT_TAG_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|U32
name|DPT_MSG_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|U32
name|DPT_RTN_T
typedef|;
end_typedef

begin_undef
undef|#
directive|undef
name|SCSI_RESET
end_undef

begin_comment
comment|/* Conflicts with "scsi/scsiconf.h" defintion */
end_comment

begin_include
include|#
directive|include
file|"dev/asr/osd_unix.h"
end_include

begin_define
define|#
directive|define
name|asr_unit
parameter_list|(
name|dev
parameter_list|)
value|minor(dev)
end_define

begin_function
name|STATIC
name|INLINE
name|Asr_softc_t
modifier|*
name|ASR_get_sc
parameter_list|(
name|IN
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|asr_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|OUT
name|Asr_softc_t
modifier|*
name|sc
init|=
name|Asr_softc
decl_stmt|;
while|while
condition|(
name|sc
operator|&&
name|sc
operator|->
name|ha_sim
index|[
literal|0
index|]
operator|&&
operator|(
name|cam_sim_unit
argument_list|(
name|sc
operator|->
name|ha_sim
index|[
literal|0
index|]
argument_list|)
operator|!=
name|unit
operator|)
condition|)
block|{
name|sc
operator|=
name|sc
operator|->
name|ha_next
expr_stmt|;
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_get_sc */
end_comment

begin_decl_stmt
name|STATIC
name|u_int8_t
name|ASR_ctlr_held
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|UNREFERENCED_PARAMETER
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|UNREFERENCED_PARAMETER
parameter_list|(
name|x
parameter_list|)
value|(void)(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|int
name|asr_open
parameter_list|(
name|IN
name|dev_t
name|dev
parameter_list|,
name|int32_t
name|flags
parameter_list|,
name|int32_t
name|ifmt
parameter_list|,
name|IN
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|OUT
name|int
name|error
decl_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|ifmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_get_sc
argument_list|(
name|dev
argument_list|)
operator|==
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|ASR_ctlr_held
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|++
name|ASR_ctlr_held
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_open */
end_comment

begin_function
name|STATIC
name|int
name|asr_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|ifmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|UNREFERENCED_PARAMETER
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|ifmt
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ASR_ctlr_held
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_close */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*                    Function ASR_queue_i                                 */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The Parameters Passed To This Function Are :                            */
end_comment

begin_comment
comment|/*     Asr_softc_t *      : HBA miniport driver's adapter data storage.    */
end_comment

begin_comment
comment|/*     PI2O_MESSAGE_FRAME : Msg Structure Pointer For This Command         */
end_comment

begin_comment
comment|/*      I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME following the Msg Structure     */
end_comment

begin_comment
comment|/*                                                                         */
end_comment

begin_comment
comment|/* This Function Will Take The User Request Packet And Convert It To An    */
end_comment

begin_comment
comment|/* I2O MSG And Send It Off To The Adapter.                                 */
end_comment

begin_comment
comment|/*                                                                         */
end_comment

begin_comment
comment|/* Return : 0 For OK, Error Code Otherwise                                 */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_function
name|STATIC
name|INLINE
name|int
name|ASR_queue_i
parameter_list|(
name|IN
name|Asr_softc_t
modifier|*
name|sc
parameter_list|,
name|INOUT
name|PI2O_MESSAGE_FRAME
name|Packet
parameter_list|)
block|{
name|union
name|asr_ccb
modifier|*
name|ccb
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|Reply
decl_stmt|;
name|PI2O_MESSAGE_FRAME
name|Message_Ptr
decl_stmt|;
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
name|Reply_Ptr
decl_stmt|;
name|int
name|MessageSizeInBytes
decl_stmt|;
name|int
name|ReplySizeInBytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Scatter Gather buffer list */
struct|struct
name|ioctlSgList_S
block|{
name|SLIST_ENTRY
argument_list|(
argument|ioctlSgList_S
argument_list|)
name|link
expr_stmt|;
name|caddr_t
name|UserSpace
decl_stmt|;
name|I2O_FLAGS_COUNT
name|FlagsCount
decl_stmt|;
name|char
name|KernelSpace
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|elm
struct|;
comment|/* Generates a `first' entry */
name|SLIST_HEAD
argument_list|(
argument|ioctlSgListHead_S
argument_list|,
argument|ioctlSgList_S
argument_list|)
name|sgList
expr_stmt|;
if|if
condition|(
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Adapter currently in BlinkLed %x\n"
argument_list|,
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Copy in the message into a local allocation */
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire I2O_MESSAGE_FRAME memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|Packet
argument_list|,
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Can't copy in packet errno=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Acquire information to determine type of packet */
name|MessageSizeInBytes
operator|=
operator|(
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message_Ptr
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* The offset of the reply information within the user packet */
name|Reply
operator|=
call|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Packet
operator|+
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
comment|/* Check if the message is a synchronous initialization command */
name|s
operator|=
name|I2O_MESSAGE_FRAME_getFunction
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|I2O_EXEC_IOP_RESET
case|:
block|{
name|U32
name|status
decl_stmt|;
name|status
operator|=
name|ASR_resetIOP
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|)
expr_stmt|;
name|ReplySizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"resetIOP done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|status
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
operator|)
return|;
block|}
case|case
name|I2O_EXEC_STATUS_GET
case|:
block|{
name|I2O_EXEC_STATUS_GET_REPLY
name|status
decl_stmt|;
if|if
condition|(
name|ASR_getStatus
argument_list|(
name|sc
operator|->
name|ha_Virt
argument_list|,
name|sc
operator|->
name|ha_Fvirt
argument_list|,
operator|&
name|status
argument_list|)
operator|==
operator|(
name|PI2O_EXEC_STATUS_GET_REPLY
operator|)
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"getStatus failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ReplySizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"getStatus done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|status
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
operator|)
return|;
block|}
case|case
name|I2O_EXEC_OUTBOUND_INIT
case|:
block|{
name|U32
name|status
decl_stmt|;
name|status
operator|=
name|ASR_initOutBound
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ReplySizeInBytes
operator|=
sizeof|sizeof
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"intOutBound done\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|status
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* Determine if the message size is valid */
if|if
condition|(
operator|(
name|MessageSizeInBytes
operator|<
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
operator|)
operator|||
operator|(
name|MAX_INBOUND_SIZE
operator|<
name|MessageSizeInBytes
operator|)
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Packet size %d incorrect\n"
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|Message_Ptr
operator|=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire frame[%d] memory\n"
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|Packet
argument_list|,
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
name|MessageSizeInBytes
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Can't copy in packet[%d] errno=%d\n"
argument_list|,
name|MessageSizeInBytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check the size of the reply frame, and start constructing */
if|if
condition|(
operator|(
name|Reply_Ptr
operator|=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire I2O_MESSAGE_FRAME memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_MESSAGE_FRAME
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to copy in reply frame, errno=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ReplySizeInBytes
operator|=
operator|(
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReplySizeInBytes
operator|<
sizeof|sizeof
argument_list|(
name|I2O_SINGLE_REPLY_MESSAGE_FRAME
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to copy in reply frame[%d], errno=%d\n"
argument_list|,
name|ReplySizeInBytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|Reply_Ptr
operator|=
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
operator|(
operator|(
name|ReplySizeInBytes
operator|>
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|)
condition|?
name|ReplySizeInBytes
else|:
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire frame[%d] memory\n"
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ASR_fillMessage
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Reply_Ptr
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|.
name|InitiatorContext
operator|=
name|Message_Ptr
operator|->
name|InitiatorContext
expr_stmt|;
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|TransactionContext
operator|=
operator|(
operator|(
name|PI2O_PRIVATE_MESSAGE_FRAME
operator|)
name|Message_Ptr
operator|)
operator|->
name|TransactionContext
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMsgFlags
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|,
name|I2O_MESSAGE_FRAME_getMsgFlags
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|)
operator||
name|I2O_MESSAGE_FLAGS_REPLY
argument_list|)
expr_stmt|;
comment|/* Check if the message is a special case command */
switch|switch
condition|(
name|I2O_MESSAGE_FRAME_getFunction
argument_list|(
name|Message_Ptr
argument_list|)
condition|)
block|{
case|case
name|I2O_EXEC_SYS_TAB_SET
case|:
comment|/* Special Case of empty Scatter Gather */
if|if
condition|(
name|MessageSizeInBytes
operator|==
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
condition|)
block|{
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_setDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|)
argument_list|,
operator|(
name|ASR_setSysTab
argument_list|(
name|sc
argument_list|)
operator|!=
name|CAM_REQ_CMP
operator|)
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|.
name|StdMessageFrame
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|I2O_SINGLE_REPLY_MESSAGE_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Deal in the general case */
comment|/* First allocate and optionally copy in each scatter gather element */
name|SLIST_INIT
argument_list|(
operator|&
name|sgList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|!=
literal|0
condition|)
block|{
name|PI2O_SGE_SIMPLE_ELEMENT
name|sg
decl_stmt|;
comment|/*                  *      since this code is reused in several systems, code                  * efficiency is greater by using a shift operation rather                  * than a divide by sizeof(u_int32_t).                  */
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|sg
operator|<
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
operator|)
operator|+
name|MessageSizeInBytes
argument_list|)
condition|)
block|{
name|caddr_t
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|)
operator|&
name|I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|I2O_FLAGS_COUNT_getCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"SG[%d] = %x[%d]\n"
argument_list|,
name|sg
operator|-
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
argument_list|,
name|I2O_SGE_SIMPLE_ELEMENT_getPhysicalAddress
argument_list|(
name|sg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|elm
operator|=
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|elm
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|elm
operator|->
name|KernelSpace
argument_list|)
operator|+
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to allocate SG[%d]\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|elm
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|elm
operator|->
name|FlagsCount
operator|=
name|sg
operator|->
name|FlagsCount
expr_stmt|;
name|elm
operator|->
name|UserSpace
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|I2O_SGE_SIMPLE_ELEMENT_getPhysicalAddress
argument_list|(
name|sg
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|elm
operator|->
name|KernelSpace
expr_stmt|;
comment|/* Copy in outgoing data (DIR bit could be invalid) */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|elm
operator|->
name|UserSpace
argument_list|,
operator|(
name|caddr_t
operator|)
name|v
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
comment|/*                          *      If the buffer is not contiguous, lets                          * break up the scatter/gather entries.                          */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sg
operator|<
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
operator|)
operator|+
name|MAX_INBOUND_SIZE
argument_list|)
operator|)
condition|)
block|{
name|int
name|next
decl_stmt|,
name|base
decl_stmt|,
name|span
decl_stmt|;
name|span
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|I2O_SGE_SIMPLE_ELEMENT_setPhysicalAddress
argument_list|(
name|sg
argument_list|,
name|base
argument_list|)
expr_stmt|;
comment|/* How far can we go physically contiguously */
while|while
condition|(
operator|(
name|len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|base
operator|==
name|next
operator|)
condition|)
block|{
name|int
name|size
decl_stmt|;
name|next
operator|=
name|trunc_page
argument_list|(
name|base
argument_list|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|size
operator|=
name|next
operator|-
name|base
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
block|{
name|size
operator|=
name|len
expr_stmt|;
block|}
name|span
operator|+=
name|size
expr_stmt|;
name|v
operator|+=
name|size
expr_stmt|;
name|len
operator|-=
name|size
expr_stmt|;
name|base
operator|=
name|KVTOPHYS
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* Construct the Flags */
name|I2O_FLAGS_COUNT_setCount
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
block|{
name|int
name|flags
init|=
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|elm
operator|->
name|FlagsCount
operator|)
argument_list|)
decl_stmt|;
comment|/* Any remaining length? */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|I2O_SGL_FLAGS_END_OF_BUFFER
operator||
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator|)
expr_stmt|;
block|}
name|I2O_FLAGS_COUNT_setFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|debug_usr_cmd_printf
argument_list|(
literal|"sg[%d] = %x[%d]\n"
argument_list|,
name|sg
operator|-
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Message_Ptr
operator|+
operator|(
operator|(
name|I2O_MESSAGE_FRAME_getVersionOffset
argument_list|(
name|Message_Ptr
argument_list|)
operator|&
literal|0xF0
operator|)
operator|>>
literal|2
operator|)
argument_list|)
argument_list|,
name|I2O_SGE_SIMPLE_ELEMENT_getPhysicalAddress
argument_list|(
name|sg
argument_list|)
argument_list|,
name|span
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
comment|/*                                  * Incrementing requires resizing of the                                  * packet, and moving up the existing SG                                  * elements.                                  */
operator|++
name|sg
expr_stmt|;
name|MessageSizeInBytes
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
expr_stmt|;
name|I2O_MESSAGE_FRAME_setMessageSize
argument_list|(
name|Message_Ptr
argument_list|,
name|I2O_MESSAGE_FRAME_getMessageSize
argument_list|(
name|Message_Ptr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|{
name|PI2O_MESSAGE_FRAME
name|NewMessage_Ptr
decl_stmt|;
if|if
condition|(
operator|(
name|NewMessage_Ptr
operator|=
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|malloc
argument_list|(
name|MessageSizeInBytes
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|NULL
condition|)
block|{
name|debug_usr_cmd_printf
argument_list|(
literal|"Failed to acquire frame[%d] memory\n"
argument_list|,
name|MessageSizeInBytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|span
operator|=
operator|(
operator|(
name|caddr_t
operator|)
name|sg
operator|)
operator|-
operator|(
name|caddr_t
operator|)
name|Message_Ptr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|Message_Ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
argument_list|,
name|span
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|sg
operator|-
literal|1
argument_list|)
argument_list|,
operator|(
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
operator|)
operator|+
name|span
argument_list|,
name|MessageSizeInBytes
operator|-
name|span
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sg
operator|=
call|(
name|PI2O_SGE_SIMPLE_ELEMENT
call|)
argument_list|(
operator|(
operator|(
name|caddr_t
operator|)
name|NewMessage_Ptr
operator|)
operator|+
name|span
argument_list|)
expr_stmt|;
name|Message_Ptr
operator|=
name|NewMessage_Ptr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|)
operator|||
operator|(
operator|(
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|sg
operator|->
name|FlagsCount
operator|)
argument_list|)
operator|&
name|I2O_SGL_FLAGS_LAST_ELEMENT
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
break|break;
block|}
operator|++
name|sg
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|debug_usr_cmd_printf
argument_list|(
literal|"Inbound: "
argument_list|)
expr_stmt|;
name|debug_usr_cmd_dump_message
argument_list|(
name|Message_Ptr
argument_list|)
expr_stmt|;
comment|/* Send the command */
if|if
condition|(
operator|(
name|ccb
operator|=
name|asr_alloc_ccb
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
operator|(
expr|union
name|asr_ccb
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Free up in-kernel buffers */
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*          * We do not need any (optional byteswapping) method access to          * the Initiator context field.          */
name|I2O_MESSAGE_FRAME_setInitiatorContext64
argument_list|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|,
operator|(
name|long
operator|)
name|ccb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ASR_queue
argument_list|(
name|sc
argument_list|,
operator|(
name|PI2O_MESSAGE_FRAME
operator|)
name|Message_Ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Message_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/*          * Wait for the board to report a finished instruction.          */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* Reset Adapter */
name|printf
argument_list|(
literal|"asr%d: Blink LED 0x%x resetting adapter\n"
argument_list|,
name|cam_sim_unit
argument_list|(
name|xpt_path_sim
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
argument_list|)
argument_list|,
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|==
name|ENXIO
condition|)
block|{
comment|/* Command Cleanup */
name|ASR_ccbRemove
argument_list|(
name|sc
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Free up in-kernel buffers */
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check every second for BlinkLed */
comment|/* There is no PRICAM, but outwardly PRIBIO is functional */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|PRIBIO
argument_list|,
literal|"asr"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|debug_usr_cmd_printf
argument_list|(
literal|"Outbound: "
argument_list|)
expr_stmt|;
name|debug_usr_cmd_dump_message
argument_list|(
name|Reply_Ptr
argument_list|)
expr_stmt|;
name|I2O_SINGLE_REPLY_MESSAGE_FRAME_setDetailedStatusCode
argument_list|(
operator|&
operator|(
name|Reply_Ptr
operator|->
name|StdReplyFrame
operator|)
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReplySizeInBytes
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|-
name|I2O_SCSI_SENSE_DATA_SZ
operator|-
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
operator|)
condition|)
block|{
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_setTransferCount
argument_list|(
name|Reply_Ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|->
name|csio
operator|.
name|resid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_AUTOSNS_VALID
operator|)
operator|&&
operator|(
name|ReplySizeInBytes
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|-
name|I2O_SCSI_SENSE_DATA_SZ
operator|)
operator|)
condition|)
block|{
name|int
name|size
init|=
name|ReplySizeInBytes
operator|-
sizeof|sizeof
argument_list|(
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME
argument_list|)
operator|-
name|I2O_SCSI_SENSE_DATA_SZ
decl_stmt|;
if|if
condition|(
name|size
operator|>
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|ccb
operator|->
name|csio
operator|.
name|sense_data
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
operator|->
name|SenseData
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|I2O_SCSI_ERROR_REPLY_MESSAGE_FRAME_setAutoSenseTransferCount
argument_list|(
name|Reply_Ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Free up in-kernel buffers */
while|while
condition|(
operator|(
name|elm
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sgList
argument_list|)
operator|)
operator|!=
operator|(
expr|struct
name|ioctlSgList_S
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Copy out as necessary */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
comment|/* DIR bit considered `valid', error due to ignorance works */
operator|&&
operator|(
operator|(
name|I2O_FLAGS_COUNT_getFlags
argument_list|(
operator|&
operator|(
name|elm
operator|->
name|FlagsCount
operator|)
argument_list|)
operator|&
name|I2O_SGL_FLAGS_DIR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|elm
operator|->
name|KernelSpace
argument_list|)
argument_list|,
name|elm
operator|->
name|UserSpace
argument_list|,
name|I2O_FLAGS_COUNT_getCount
argument_list|(
operator|&
operator|(
name|elm
operator|->
name|FlagsCount
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sgList
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Copy reply frame to user space */
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|Reply_Ptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|Reply
argument_list|,
name|ReplySizeInBytes
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|Reply_Ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|asr_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ASR_queue_i */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*                          Function asr_ioctl                         */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The parameters passed to this function are :                         */
end_comment

begin_comment
comment|/*     dev  : Device number.                                            */
end_comment

begin_comment
comment|/*     cmd  : Ioctl Command                                             */
end_comment

begin_comment
comment|/*     data : User Argument Passed In.                                  */
end_comment

begin_comment
comment|/*     flag : Mode Parameter                                            */
end_comment

begin_comment
comment|/*     proc : Process Parameter                                         */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/* This function is the user interface into this adapter driver         */
end_comment

begin_comment
comment|/*                                                                      */
end_comment

begin_comment
comment|/* Return : zero if OK, error code if not                               */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_function
name|STATIC
name|int
name|asr_ioctl
parameter_list|(
name|IN
name|dev_t
name|dev
parameter_list|,
name|IN
name|u_long
name|cmd
parameter_list|,
name|INOUT
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|OUT
name|int
name|error
init|=
literal|0
decl_stmt|;
name|Asr_softc_t
modifier|*
name|sc
init|=
name|ASR_get_sc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|flag
argument_list|)
expr_stmt|;
name|UNREFERENCED_PARAMETER
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
operator|(
name|Asr_softc_t
operator|*
operator|)
name|NULL
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DPT_SIGNATURE
case|:
if|#
directive|if
operator|(
name|dsDescription_size
operator|!=
literal|50
operator|)
case|case
name|DPT_SIGNATURE
operator|+
operator|(
operator|(
literal|50
operator|-
name|dsDescription_size
operator|)
operator|<<
literal|16
operator|)
case|:
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|&
literal|0xFFFF0000
condition|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|ASR_sig
argument_list|)
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig_S
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Traditional version of the ioctl interface */
case|case
name|DPT_SIGNATURE
operator|&
literal|0x0000FFFF
case|:
return|return
operator|(
name|copyout
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|ASR_sig
argument_list|)
argument_list|,
operator|*
operator|(
operator|(
name|caddr_t
operator|*
operator|)
name|data
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dpt_sig_S
argument_list|)
argument_list|)
operator|)
return|;
comment|/* Traditional version of the ioctl interface */
case|case
name|DPT_CTRLINFO
operator|&
literal|0x0000FFFF
case|:
case|case
name|DPT_CTRLINFO
case|:
block|{
struct|struct
block|{
name|u_int16_t
name|length
decl_stmt|;
name|u_int16_t
name|drvrHBAnum
decl_stmt|;
name|u_int32_t
name|baseAddr
decl_stmt|;
name|u_int16_t
name|blinkState
decl_stmt|;
name|u_int8_t
name|pciBusNum
decl_stmt|;
name|u_int8_t
name|pciDeviceNum
decl_stmt|;
name|u_int16_t
name|hbaFlags
decl_stmt|;
name|u_int16_t
name|Interrupt
decl_stmt|;
name|u_int32_t
name|reserved1
decl_stmt|;
name|u_int32_t
name|reserved2
decl_stmt|;
name|u_int32_t
name|reserved3
decl_stmt|;
block|}
name|CtlrInfo
struct|;
name|bzero
argument_list|(
operator|&
name|CtlrInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
argument_list|)
expr_stmt|;
name|CtlrInfo
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|CtlrInfo
operator|.
name|drvrHBAnum
operator|=
name|asr_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CtlrInfo
operator|.
name|baseAddr
operator|=
operator|(
name|u_long
operator|)
name|sc
operator|->
name|ha_Base
expr_stmt|;
name|i
operator|=
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|CtlrInfo
operator|.
name|blinkState
operator|=
name|i
expr_stmt|;
name|CtlrInfo
operator|.
name|pciBusNum
operator|=
name|sc
operator|->
name|ha_pciBusNum
expr_stmt|;
name|CtlrInfo
operator|.
name|pciDeviceNum
operator|=
name|sc
operator|->
name|ha_pciDeviceNum
expr_stmt|;
define|#
directive|define
name|FLG_OSD_PCI_VALID
value|0x0001
define|#
directive|define
name|FLG_OSD_DMA
value|0x0002
define|#
directive|define
name|FLG_OSD_I2O
value|0x0004
name|CtlrInfo
operator|.
name|hbaFlags
operator|=
name|FLG_OSD_PCI_VALID
operator||
name|FLG_OSD_DMA
operator||
name|FLG_OSD_I2O
expr_stmt|;
name|CtlrInfo
operator|.
name|Interrupt
operator|=
name|sc
operator|->
name|ha_irq
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0xFFFF0000
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|CtlrInfo
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|CtlrInfo
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|CtlrInfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
comment|/* Traditional version of the ioctl interface */
case|case
name|DPT_SYSINFO
operator|&
literal|0x0000FFFF
case|:
case|case
name|DPT_SYSINFO
case|:
block|{
name|sysInfo_S
name|Info
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Kernel Specific ptok `hack' */
define|#
directive|define
name|ptok
parameter_list|(
name|a
parameter_list|)
value|((char *)(a) + KERNBASE)
name|bzero
argument_list|(
operator|&
name|Info
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Appears I am the only person in the Kernel doing this */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|i
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|Info
operator|.
name|drive0CMOS
operator|=
name|j
expr_stmt|;
name|j
operator|=
name|i
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0x0f
condition|)
block|{
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
block|}
name|Info
operator|.
name|drive1CMOS
operator|=
name|j
expr_stmt|;
name|Info
operator|.
name|numDrives
operator|=
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|ptok
argument_list|(
literal|0x475
argument_list|)
operator|)
expr_stmt|;
name|Info
operator|.
name|processorFamily
operator|=
name|ASR_sig
operator|.
name|dsProcessorFamily
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
switch|switch
condition|(
name|cpu
condition|)
block|{
case|case
name|CPU_386SX
case|:
case|case
name|CPU_386
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_386
expr_stmt|;
break|break;
case|case
name|CPU_486SX
case|:
case|case
name|CPU_486
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_486
expr_stmt|;
break|break;
case|case
name|CPU_586
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_PENTIUM
expr_stmt|;
break|break;
case|case
name|CPU_686
case|:
name|Info
operator|.
name|processorType
operator|=
name|PROC_SEXIUM
expr_stmt|;
break|break;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__alpha__
argument_list|)
name|Info
operator|.
name|processorType
operator|=
name|PROC_ALPHA
expr_stmt|;
endif|#
directive|endif
name|Info
operator|.
name|osType
operator|=
name|OS_BSDI_UNIX
expr_stmt|;
name|Info
operator|.
name|osMajorVersion
operator|=
name|osrelease
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|Info
operator|.
name|osMinorVersion
operator|=
name|osrelease
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* Info.osRevision = 0; */
comment|/* Info.osSubRevision = 0; */
name|Info
operator|.
name|busType
operator|=
name|SI_PCI_BUS
expr_stmt|;
name|Info
operator|.
name|flags
operator|=
name|SI_CMOS_Valid
operator||
name|SI_NumDrivesValid
operator||
name|SI_OSversionValid
operator||
name|SI_BusTypeValid
operator||
name|SI_NO_SmartROM
expr_stmt|;
comment|/* Go Out And Look For I2O SmartROM */
for|for
control|(
name|j
operator|=
literal|0xC8000
init|;
name|j
operator|<
literal|0xE0000
condition|;
name|j
operator|+=
literal|2048
control|)
block|{
name|int
name|k
decl_stmt|;
name|cp
operator|=
name|ptok
argument_list|(
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|cp
operator|)
operator|!=
literal|0xAA55
condition|)
block|{
continue|continue;
block|}
name|j
operator|+=
operator|(
name|cp
index|[
literal|2
index|]
operator|*
literal|512
operator|)
operator|-
literal|2048
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
name|cp
operator|+
literal|6
operator|)
operator|)
operator|!=
operator|(
literal|'S'
operator|+
operator|(
literal|' '
operator|*
literal|256
operator|)
operator|+
operator|(
literal|' '
operator|*
literal|65536L
operator|)
operator|)
operator|)
operator|||
operator|(
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|(
name|cp
operator|+
literal|10
operator|)
operator|)
operator|!=
operator|(
literal|'I'
operator|+
operator|(
literal|'2'
operator|*
literal|256
operator|)
operator|+
operator|(
literal|'0'
operator|*
literal|65536L
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|cp
operator|+=
literal|0x24
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|64
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|cp
operator|)
operator|==
operator|(
literal|' '
operator|+
operator|(
literal|'v'
operator|*
literal|256
operator|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|k
operator|<
literal|64
condition|)
block|{
name|Info
operator|.
name|smartROMMajorVersion
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|cp
operator|+=
literal|4
operator|)
operator|)
operator|-
literal|'0'
expr_stmt|;
name|Info
operator|.
name|smartROMMinorVersion
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|cp
operator|+=
literal|2
operator|)
operator|)
expr_stmt|;
name|Info
operator|.
name|smartROMRevision
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|++
name|cp
operator|)
operator|)
expr_stmt|;
name|Info
operator|.
name|flags
operator||=
name|SI_SmartROMverValid
expr_stmt|;
name|Info
operator|.
name|flags
operator|&=
operator|~
name|SI_NO_SmartROM
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get The Conventional Memory Size From CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x15
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|Info
operator|.
name|conventionalMemSize
operator|=
name|j
expr_stmt|;
comment|/* Get The Extended Memory Found At Power On From CMOS */
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|8
expr_stmt|;
name|outb
argument_list|(
literal|0x70
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|j
operator||=
name|inb
argument_list|(
literal|0x71
argument_list|)
expr_stmt|;
name|Info
operator|.
name|extendedMemSize
operator|=
name|j
expr_stmt|;
name|Info
operator|.
name|flags
operator||=
name|SI_MemorySizeValid
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|THIS_IS_BROKEN
argument_list|)
operator|)
comment|/* If There Is 1 or 2 Drives Found, Set Up Drive Parameters */
if|if
condition|(
name|Info
operator|.
name|numDrives
operator|>
literal|0
condition|)
block|{
comment|/*                          *      Get The Pointer From Int 41 For The First                          *      Drive Parameters                          */
name|j
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|ptok
argument_list|(
literal|0x104
operator|+
literal|2
argument_list|)
operator|)
argument_list|)
operator|<<
literal|4
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|ptok
argument_list|(
literal|0x104
operator|+
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/*                          * It appears that SmartROM's Int41/Int46 pointers                          * use memory that gets stepped on by the kernel                          * loading. We no longer have access to this                          * geometry information but try anyways (!?)                          */
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|cylinders
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|cylinders
operator|+=
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
operator|)
operator|<<
literal|8
expr_stmt|;
operator|++
name|j
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|heads
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
name|j
operator|+=
literal|12
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|sectors
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
name|Info
operator|.
name|flags
operator||=
name|SI_DriveParamsValid
expr_stmt|;
if|if
condition|(
operator|(
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|cylinders
operator|==
literal|0
operator|)
operator|||
operator|(
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|heads
operator|==
literal|0
operator|)
operator|||
operator|(
name|Info
operator|.
name|drives
index|[
literal|0
index|]
operator|.
name|sectors
operator|==
literal|0
operator|)
condition|)
block|{
name|Info
operator|.
name|flags
operator|&=
operator|~
name|SI_DriveParamsValid
expr_stmt|;
block|}
if|if
condition|(
name|Info
operator|.
name|numDrives
operator|>
literal|1
condition|)
block|{
comment|/*                                  *      Get The Pointer From Int 46 For The                                  *      Second Drive Parameters                                  */
name|j
operator|=
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|ptok
argument_list|(
literal|0x118
operator|+
literal|2
argument_list|)
operator|)
argument_list|)
operator|<<
literal|4
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|ptok
argument_list|(
literal|0x118
operator|+
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|cylinders
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|cylinders
operator|+=
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
operator|)
operator|<<
literal|8
expr_stmt|;
operator|++
name|j
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|heads
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
name|j
operator|+=
literal|12
expr_stmt|;
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|sectors
operator|=
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ptok
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|cylinders
operator|==
literal|0
operator|)
operator|||
operator|(
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|heads
operator|==
literal|0
operator|)
operator|||
operator|(
name|Info
operator|.
name|drives
index|[
literal|1
index|]
operator|.
name|sectors
operator|==
literal|0
operator|)
condition|)
block|{
name|Info
operator|.
name|flags
operator|&=
operator|~
name|SI_DriveParamsValid
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Copy Out The Info Structure To The User */
if|if
condition|(
name|cmd
operator|&
literal|0xFFFF0000
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|Info
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|Info
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|Info
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get The BlinkLED State */
case|case
name|DPT_BLINKLED
case|:
name|i
operator|=
name|ASR_getBlinkLedCode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
literal|0xFFFF0000
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|i
argument_list|)
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|i
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Get performance metrics */
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
case|case
name|DPT_PERF_INFO
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|sc
operator|->
name|ha_performance
operator|)
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ha_performance
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* Send an I2O command */
case|case
name|I2OUSRCMD
case|:
return|return
operator|(
name|ASR_queue_i
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
operator|(
name|PI2O_MESSAGE_FRAME
operator|*
operator|)
name|data
operator|)
argument_list|)
operator|)
return|;
comment|/* Reset and re-initialize the adapter */
case|case
name|I2ORESETCMD
case|:
return|return
operator|(
name|ASR_reset
argument_list|(
name|sc
argument_list|)
operator|)
return|;
comment|/* Rescan the LCT table and resynchronize the information */
case|case
name|I2ORESCANCMD
case|:
return|return
operator|(
name|ASR_rescan
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_ioctl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASR_MEASURE_PERFORMANCE
end_ifdef

begin_comment
comment|/*  * This function subtracts one timeval structure from another,  * Returning the result in usec.  * It assumes that less than 4 billion usecs passed form start to end.  * If times are sensless, 0xffffffff is returned.  */
end_comment

begin_function
name|STATIC
name|u_int32_t
name|asr_time_delta
parameter_list|(
name|IN
name|struct
name|timeval
name|start
parameter_list|,
name|IN
name|struct
name|timeval
name|end
parameter_list|)
block|{
name|OUT
name|u_int32_t
name|result
decl_stmt|;
if|if
condition|(
name|start
operator|.
name|tv_sec
operator|>
name|end
operator|.
name|tv_sec
condition|)
block|{
name|result
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|start
operator|.
name|tv_sec
operator|==
name|end
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|start
operator|.
name|tv_usec
operator|>
name|end
operator|.
name|tv_usec
condition|)
block|{
name|result
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|end
operator|.
name|tv_usec
operator|-
name|start
operator|.
name|tv_usec
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|end
operator|.
name|tv_sec
operator|-
name|start
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|end
operator|.
name|tv_usec
operator|+
operator|(
literal|1000000
operator|-
name|start
operator|.
name|tv_usec
operator|)
return|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* asr_time_delta */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

