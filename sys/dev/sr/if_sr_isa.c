begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 - 2001 John Hay.  * Copyright (c) 1996 SDL Communications, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_comment
comment|/* cdevsw stuff */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* SYSINIT stuff */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* SYSINIT stuff */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* malloc region definitions */
end_comment

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|"isa_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/ic/hd64570.h>
end_include

begin_include
include|#
directive|include
file|<dev/sr/if_srregs.h>
end_include

begin_comment
comment|/*  * List of valid interrupt numbers for the N2 ISA card.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sr_irqtable
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
comment|/*  0 */
literal|0
block|,
comment|/*  1 */
literal|0
block|,
comment|/*  2 */
literal|1
block|,
comment|/*  3 */
literal|1
block|,
comment|/*  4 */
literal|1
block|,
comment|/*  5 */
literal|0
block|,
comment|/*  6 */
literal|1
block|,
comment|/*  7 */
literal|0
block|,
comment|/*  8 */
literal|0
block|,
comment|/*  9 */
literal|1
block|,
comment|/* 10 */
literal|1
block|,
comment|/* 11 */
literal|1
block|,
comment|/* 12 */
literal|0
block|,
comment|/* 13 */
literal|0
block|,
comment|/* 14 */
literal|1
comment|/* 15 */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sr_isa_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sr_isa_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|sr_ids
index|[]
init|=
block|{
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|sr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sr_isa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sr_isa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|sr_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|sr_isa_driver
init|=
block|{
literal|"sr"
block|,
name|sr_methods
block|,
expr|sizeof
operator|(
expr|struct
name|sr_hardc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sr
argument_list|,
name|isa
argument_list|,
name|sr_isa_driver
argument_list|,
name|sr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sr
argument_list|,
name|isa
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|u_int
name|src_get8_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|src_get16_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|src_put8_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|src_put16_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|src_dpram_size
parameter_list|(
name|device_t
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Probe for an ISA card. If it is there, size its memory. Then get the  * rest of its information and fill it in.  */
end_comment

begin_function
specifier|static
name|int
name|sr_isa_probe
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|struct
name|sr_hardc
modifier|*
name|hc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|tmp
decl_stmt|;
name|u_long
name|irq
decl_stmt|,
name|junk
decl_stmt|,
name|membase
decl_stmt|,
name|memsize
decl_stmt|;
name|sca_regs
modifier|*
name|sca
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|device
argument_list|)
argument_list|,
name|device
argument_list|,
name|sr_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENXIO
operator|||
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|hc
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sr_hardc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_allocate_ioport
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
name|SRC_IO_SIZ
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Now see if the card is realy there. 	 */
name|hc
operator|->
name|cardtype
operator|=
name|SR_CRD_N2
expr_stmt|;
name|hc
operator|->
name|cunit
operator|=
name|device_get_unit
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * We have to fill these in early because the SRC_PUT* and SRC_GET* 	 * macros use them. 	 */
name|hc
operator|->
name|src_get8
operator|=
name|src_get8_io
expr_stmt|;
name|hc
operator|->
name|src_get16
operator|=
name|src_get16_io
expr_stmt|;
name|hc
operator|->
name|src_put8
operator|=
name|src_put8_io
expr_stmt|;
name|hc
operator|->
name|src_put16
operator|=
name|src_put16_io
expr_stmt|;
name|hc
operator|->
name|sca
operator|=
literal|0
expr_stmt|;
name|hc
operator|->
name|numports
operator|=
name|NCHAN
expr_stmt|;
comment|/* assumed # of channels on the card */
name|flags
operator|=
name|device_get_flags
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SR_FLAGS_NCHAN_MSK
condition|)
name|hc
operator|->
name|numports
operator|=
name|flags
operator|&
name|SR_FLAGS_NCHAN_MSK
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* turn off the card */
comment|/* 	 * Next, we'll test the Base Address Register to retension of 	 * data... ... seeing if we're *really* talking to an N2. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
name|i
operator|++
control|)
block|{
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_BAR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_BAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"sr%d: probe failed BAR %x, %x.\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|i
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|errexit
goto|;
block|}
block|}
comment|/* 	 * Now see if we can see the SCA. 	 */
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
name|SR_PCR_SCARUN
operator||
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|)
argument_list|)
expr_stmt|;
name|SRC_PUT8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|wcrl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SRC_PUT8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|wcrm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SRC_PUT8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|wcrh
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SRC_PUT8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|pcr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SRC_PUT8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|msci
index|[
literal|0
index|]
operator|.
name|tmc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr_inb
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SRC_GET8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|msci
index|[
literal|0
index|]
operator|.
name|tmc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sr%d: Error reading SCA 0, %x\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|errexit
goto|;
block|}
name|SRC_PUT8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|msci
index|[
literal|0
index|]
operator|.
name|tmc
argument_list|,
literal|0x5A
argument_list|)
expr_stmt|;
name|sr_inb
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SRC_GET8
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|msci
index|[
literal|0
index|]
operator|.
name|tmc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0x5A
condition|)
block|{
name|printf
argument_list|(
literal|"sr%d: Error reading SCA 0x5A, %x\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|errexit
goto|;
block|}
name|SRC_PUT16
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|dmac
index|[
literal|0
index|]
operator|.
name|cda
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sr_inb
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SRC_GET16
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|dmac
index|[
literal|0
index|]
operator|.
name|cda
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sr%d: Error reading SCA 0, %x\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|errexit
goto|;
block|}
name|SRC_PUT16
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|dmac
index|[
literal|0
index|]
operator|.
name|cda
argument_list|,
literal|0x55AA
argument_list|)
expr_stmt|;
name|sr_inb
argument_list|(
name|hc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|SRC_GET16
argument_list|(
name|hc
argument_list|,
name|sca
operator|->
name|dmac
index|[
literal|0
index|]
operator|.
name|cda
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0x55AA
condition|)
block|{
name|printf
argument_list|(
literal|"sr%d: Error reading SCA 0x55AA, %x\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
goto|goto
name|errexit
goto|;
block|}
name|membase
operator|=
name|bus_get_resource_start
argument_list|(
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memsize
operator|=
name|SRC_WIN_SIZ
expr_stmt|;
if|if
condition|(
name|bus_set_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|membase
argument_list|,
name|memsize
argument_list|)
condition|)
goto|goto
name|errexit
goto|;
if|if
condition|(
name|sr_allocate_memory
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
name|SRC_WIN_SIZ
argument_list|)
condition|)
goto|goto
name|errexit
goto|;
if|if
condition|(
name|src_dpram_size
argument_list|(
name|device
argument_list|)
operator|<
literal|4
condition|)
goto|goto
name|errexit
goto|;
if|if
condition|(
name|sr_allocate_irq
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|errexit
goto|;
if|if
condition|(
name|bus_get_resource
argument_list|(
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|junk
argument_list|)
condition|)
block|{
goto|goto
name|errexit
goto|;
block|}
comment|/* 	 * Do a little sanity check. 	 */
if|if
condition|(
name|sr_irqtable
index|[
name|irq
index|]
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"sr%d: Warning: illegal interrupt %ld chosen.\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* 	 * Bogus card configuration 	 */
if|if
condition|(
operator|(
name|hc
operator|->
name|numports
operator|>
name|NCHAN
operator|)
comment|/* only 2 ports/card */
operator|||
operator|(
name|hc
operator|->
name|memsize
operator|>
operator|(
literal|512
operator|*
literal|1024
operator|)
operator|)
condition|)
comment|/* no more than 256K */
goto|goto
name|errexit
goto|;
name|sr_deallocate_resources
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errexit
label|:
name|sr_deallocate_resources
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * srattach_isa and srattach_pci allocate memory for hardc, softc and  * data buffers. It also does any initialization that is bus specific.  * At the end they call the common srattach() function.  */
end_comment

begin_function
specifier|static
name|int
name|sr_isa_attach
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|u_char
name|mar
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|struct
name|sr_hardc
modifier|*
name|hc
decl_stmt|;
name|hc
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sr_hardc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_allocate_ioport
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
name|SRC_IO_SIZ
argument_list|)
condition|)
goto|goto
name|errexit
goto|;
if|if
condition|(
name|sr_allocate_memory
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
name|SRC_WIN_SIZ
argument_list|)
condition|)
goto|goto
name|errexit
goto|;
if|if
condition|(
name|sr_allocate_irq
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|errexit
goto|;
comment|/* 	 * We have to fill these in early because the SRC_PUT* and SRC_GET* 	 * macros use them. 	 */
name|hc
operator|->
name|src_get8
operator|=
name|src_get8_io
expr_stmt|;
name|hc
operator|->
name|src_get16
operator|=
name|src_get16_io
expr_stmt|;
name|hc
operator|->
name|src_put8
operator|=
name|src_put8_io
expr_stmt|;
name|hc
operator|->
name|src_put16
operator|=
name|src_put16_io
expr_stmt|;
name|hc
operator|->
name|cardtype
operator|=
name|SR_CRD_N2
expr_stmt|;
name|hc
operator|->
name|cunit
operator|=
name|device_get_unit
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|hc
operator|->
name|sca
operator|=
literal|0
expr_stmt|;
name|hc
operator|->
name|numports
operator|=
name|NCHAN
expr_stmt|;
comment|/* assumed # of channels on the card */
name|flags
operator|=
name|device_get_flags
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SR_FLAGS_NCHAN_MSK
condition|)
name|hc
operator|->
name|numports
operator|=
name|flags
operator|&
name|SR_FLAGS_NCHAN_MSK
expr_stmt|;
name|hc
operator|->
name|mem_start
operator|=
operator|(
name|caddr_t
operator|)
name|rman_get_virtual
argument_list|(
name|hc
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|hc
operator|->
name|mem_end
operator|=
name|hc
operator|->
name|mem_start
operator|+
name|SRC_WIN_SIZ
expr_stmt|;
name|hc
operator|->
name|mem_pstart
operator|=
literal|0
expr_stmt|;
name|hc
operator|->
name|winmsk
operator|=
name|SRC_WIN_MSK
expr_stmt|;
name|hc
operator|->
name|mempages
operator|=
name|src_dpram_size
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|hc
operator|->
name|memsize
operator|=
name|hc
operator|->
name|mempages
operator|*
name|SRC_WIN_SIZ
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|)
operator||
name|SR_PCR_SCARUN
argument_list|)
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|,
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|)
operator||
name|SR_PSR_EN_SCA_DMA
argument_list|)
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_MCR
argument_list|,
name|SR_MCR_DTR0
operator||
name|SR_MCR_DTR1
operator||
name|SR_MCR_TE0
operator||
name|SR_MCR_TE1
argument_list|)
expr_stmt|;
name|SRC_SET_ON
argument_list|(
name|hc
argument_list|)
expr_stmt|;
comment|/* 	 * Configure the card. Mem address, irq, 	 */
name|mar
operator|=
operator|(
name|rman_get_start
argument_list|(
name|hc
operator|->
name|res_memory
argument_list|)
operator|>>
literal|16
operator|)
operator|&
name|SR_PCR_16M_SEL
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
name|mar
operator||
operator|(
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|)
operator|&
operator|~
name|SR_PCR_16M_SEL
operator|)
argument_list|)
expr_stmt|;
name|mar
operator|=
name|rman_get_start
argument_list|(
name|hc
operator|->
name|res_memory
argument_list|)
operator|>>
literal|12
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_BAR
argument_list|,
name|mar
argument_list|)
expr_stmt|;
return|return
name|sr_attach
argument_list|(
name|device
argument_list|)
return|;
name|errexit
label|:
name|sr_deallocate_resources
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * I/O for ISA N2 card(s)  */
end_comment

begin_define
define|#
directive|define
name|SRC_REG
parameter_list|(
name|y
parameter_list|)
value|((((y)& 0xf) + (((y)& 0xf0)<< 6)) | 0x8000)
end_define

begin_function
specifier|static
name|u_int
name|src_get8_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_1
argument_list|(
name|hc
operator|->
name|bt_ioport
argument_list|,
name|hc
operator|->
name|bh_ioport
argument_list|,
name|SRC_REG
argument_list|(
name|off
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|src_get16_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|)
block|{
return|return
name|bus_space_read_2
argument_list|(
name|hc
operator|->
name|bt_ioport
argument_list|,
name|hc
operator|->
name|bh_ioport
argument_list|,
name|SRC_REG
argument_list|(
name|off
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|src_put8_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|hc
operator|->
name|bt_ioport
argument_list|,
name|hc
operator|->
name|bh_ioport
argument_list|,
name|SRC_REG
argument_list|(
name|off
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|src_put16_io
parameter_list|(
name|struct
name|sr_hardc
modifier|*
name|hc
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|bus_space_write_2
argument_list|(
name|hc
operator|->
name|bt_ioport
argument_list|,
name|hc
operator|->
name|bh_ioport
argument_list|,
name|SRC_REG
argument_list|(
name|off
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|src_dpram_size
parameter_list|(
name|device_t
name|device
parameter_list|)
block|{
name|u_int
name|pgs
decl_stmt|,
name|i
decl_stmt|;
name|u_short
modifier|*
name|smem
decl_stmt|;
name|u_char
name|mar
decl_stmt|;
name|u_long
name|membase
decl_stmt|;
name|struct
name|sr_hardc
modifier|*
name|hc
decl_stmt|;
name|hc
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * OK, the board's interface registers seem to work. Now we'll see 	 * if the Dual-Ported RAM is fully accessible... 	 */
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
name|SR_PCR_EN_VPM
operator||
name|SR_PCR_ISA16
argument_list|)
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|,
name|SR_PSR_WIN_16K
argument_list|)
expr_stmt|;
comment|/* 	 * Take the kernel "virtual" address supplied to us and convert 	 * it to a "real" address. Then program the card to use that. 	 */
name|membase
operator|=
name|rman_get_start
argument_list|(
name|hc
operator|->
name|res_memory
argument_list|)
expr_stmt|;
name|mar
operator|=
operator|(
name|membase
operator|>>
literal|16
operator|)
operator|&
name|SR_PCR_16M_SEL
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
name|mar
operator||
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|)
argument_list|)
expr_stmt|;
name|mar
operator|=
name|membase
operator|>>
literal|12
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_BAR
argument_list|,
name|mar
argument_list|)
expr_stmt|;
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|,
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PCR
argument_list|)
operator||
name|SR_PCR_MEM_WIN
argument_list|)
expr_stmt|;
name|smem
operator|=
operator|(
name|u_short
operator|*
operator|)
name|rman_get_virtual
argument_list|(
name|hc
operator|->
name|res_memory
argument_list|)
expr_stmt|;
comment|/* DP RAM Address */
comment|/* 	 * Here we will perform the memory scan to size the device. 	 * 	 * This is done by marking each potential page with a magic number. 	 * We then loop through the pages looking for that magic number. As 	 * soon as we no longer see that magic number, we'll quit the scan, 	 * knowing that no more memory is present. This provides the number 	 * of pages present on the card. 	 * 	 * Note: We're sizing 16K memory granules. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SR_PSR_PG_SEL
condition|;
name|i
operator|++
control|)
block|{
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|,
operator|(
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|)
operator|&
operator|~
name|SR_PSR_PG_SEL
operator|)
operator||
name|i
argument_list|)
expr_stmt|;
operator|*
name|smem
operator|=
literal|0xAA55
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SR_PSR_PG_SEL
condition|;
name|i
operator|++
control|)
block|{
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|,
operator|(
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|)
operator|&
operator|~
name|SR_PSR_PG_SEL
operator|)
operator||
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|smem
operator|!=
literal|0xAA55
condition|)
block|{
comment|/* 			 * If we have less than 64k of memory, give up. That 			 * is 4 x 16k pages. 			 */
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"sr%d: Bad mem page %d, mem %x, %x.\n"
argument_list|,
name|hc
operator|->
name|cunit
argument_list|,
name|i
argument_list|,
literal|0xAA55
argument_list|,
operator|*
name|smem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
operator|*
name|smem
operator|=
name|i
expr_stmt|;
block|}
name|hc
operator|->
name|mempages
operator|=
name|i
expr_stmt|;
name|hc
operator|->
name|memsize
operator|=
name|i
operator|*
name|SRC_WIN_SIZ
expr_stmt|;
name|hc
operator|->
name|winmsk
operator|=
name|SRC_WIN_MSK
expr_stmt|;
name|pgs
operator|=
name|i
expr_stmt|;
comment|/* final count of 16K pages */
comment|/* 	 * This next loop erases the contents of that page in DPRAM 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|pgs
condition|;
name|i
operator|++
control|)
block|{
name|sr_outb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|,
operator|(
name|sr_inb
argument_list|(
name|hc
argument_list|,
name|SR_PSR
argument_list|)
operator|&
operator|~
name|SR_PSR_PG_SEL
operator|)
operator||
name|i
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|smem
argument_list|,
name|SRC_WIN_SIZ
argument_list|)
expr_stmt|;
block|}
name|SRC_SET_OFF
argument_list|(
name|hc
argument_list|)
expr_stmt|;
return|return
operator|(
name|pgs
operator|)
return|;
block|}
end_function

end_unit

