begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Device driver optimized for the Symbios/LSI 53C896/53C895A/53C1010   *  PCI-SCSI controllers.  *  *  Copyright (C) 1999-2000  Gerard Roudier<groudier@club-internet.fr>  *  *  This driver also supports the following Symbios/LSI PCI-SCSI chips:  *	53C810A, 53C825A, 53C860, 53C875, 53C876, 53C885, 53C895,  *	53C810,  53C815,  53C825 and the 53C1510D is 53C8XX mode.  *  *    *  This driver for FreeBSD-CAM is derived from the Linux sym53c8xx driver.  *  Copyright (C) 1998-1999  Gerard Roudier  *  *  The sym53c8xx driver is derived from the ncr53c8xx driver that had been   *  a port of the FreeBSD ncr driver to Linux-1.2.13.  *  *  The original ncr driver has been written for 386bsd and FreeBSD by  *          Wolfgang Stanglmeier<wolf@cologne.de>  *          Stefan Esser<se@mi.Uni-Koeln.de>  *  Copyright (C) 1994  Wolfgang Stanglmeier  *  *  The initialisation code, and part of the code that addresses   *  FreeBSD-CAM services is based on the aic7xxx driver for FreeBSD-CAM   *  written by Justin T. Gibbs.  *  *  Other major contributions:  *  *  NVRAM detection and reading.  *  Copyright (C) 1997 Richard Waltham<dormouse@farsrobt.demon.co.uk>  *  *-----------------------------------------------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  *  Scripts for SYMBIOS-Processor  *  *  We have to know the offsets of all labels before we reach   *  them (for forward jumps). Therefore we declare a struct   *  here. If you make changes inside the script,  *  *  DONT FORGET TO CHANGE THE LENGTHS HERE!  */
end_comment

begin_comment
comment|/*  *  Script fragments which are loaded into the on-chip RAM   *  of 825A, 875, 876, 895, 895A, 896 and 1010 chips.  *  Must not exceed 4K bytes.  */
end_comment

begin_struct
struct|struct
name|SYM_FWA_SCR
block|{
name|u32
name|start
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|getjob_begin
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|getjob_end
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|select
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|wf_sel_done
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|send_ident
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
name|u32
name|select2
index|[
literal|8
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|select2
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|command
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|dispatch
index|[
literal|28
index|]
decl_stmt|;
name|u32
name|sel_no_cmd
index|[
literal|10
index|]
decl_stmt|;
name|u32
name|init
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|clrack
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|disp_status
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|datai_done
index|[
literal|26
index|]
decl_stmt|;
name|u32
name|datao_done
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|datai_phase
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|datao_phase
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|msg_in
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|msg_in2
index|[
literal|10
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
name|u32
name|status
index|[
literal|14
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|status
index|[
literal|10
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|complete
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|complete2
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|complete_error
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|done
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|done_end
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|save_dp
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|restore_dp
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|disconnect
index|[
literal|20
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
name|u32
name|idle
index|[
literal|4
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|idle
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
name|u32
name|ungetjob
index|[
literal|6
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|ungetjob
index|[
literal|4
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|reselect
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|reselected
index|[
literal|22
index|]
decl_stmt|;
name|u32
name|resel_scntl4
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|resel_lun0
index|[
literal|6
index|]
decl_stmt|;
if|#
directive|if
name|SYM_CONF_MAX_TASK
operator|*
literal|4
operator|>
literal|512
name|u32
name|resel_tag
index|[
literal|26
index|]
decl_stmt|;
elif|#
directive|elif
name|SYM_CONF_MAX_TASK
operator|*
literal|4
operator|>
literal|256
name|u32
name|resel_tag
index|[
literal|20
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|resel_tag
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|resel_dsa
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|resel_dsa1
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|resel_no_tag
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|data_in
index|[
name|SYM_CONF_MAX_SG
operator|*
literal|2
index|]
decl_stmt|;
name|u32
name|data_in2
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|data_out
index|[
name|SYM_CONF_MAX_SG
operator|*
literal|2
index|]
decl_stmt|;
name|u32
name|data_out2
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pm0_data
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|pm0_data_out
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|pm0_data_end
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|pm1_data
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|pm1_data_out
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|pm1_data_end
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Script fragments which stay in main memory for all chips   *  except for chips that support 8K on-chip RAM.  */
end_comment

begin_struct
struct|struct
name|SYM_FWB_SCR
block|{
name|u32
name|start64
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|no_data
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|sel_for_abort
index|[
literal|18
index|]
decl_stmt|;
name|u32
name|sel_for_abort_1
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|msg_in_etc
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|msg_received
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_weird_seen
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_extended
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|msg_bad
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|msg_weird
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_weird1
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|wdtr_resp
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|send_wdtr
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|sdtr_resp
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|send_sdtr
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|ppr_resp
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|send_ppr
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|nego_bad_phase
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_out
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_out_done
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|data_ovrun
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|data_ovrun1
index|[
literal|22
index|]
decl_stmt|;
name|u32
name|data_ovrun2
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|abort_resel
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|resend_ident
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|ident_break
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|ident_break_atn
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|sdata_in
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|resel_bad_lun
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|bad_i_t_l
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|bad_i_t_l_q
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|bad_status
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|pm_handle
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|pm_handle1
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pm_save
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pm0_save
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|pm1_save
index|[
literal|14
index|]
decl_stmt|;
comment|/* WSR handling */
name|u32
name|pm_wsr_handle
index|[
literal|42
index|]
decl_stmt|;
name|u32
name|wsr_ma_helper
index|[
literal|4
index|]
decl_stmt|;
comment|/* Data area */
name|u32
name|zero
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|scratch
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|pm0_data_addr
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|pm1_data_addr
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|saved_dsa
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|saved_drs
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|done_pos
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|startpos
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|targtbl
index|[
literal|1
index|]
decl_stmt|;
comment|/* End of data area */
name|u32
name|snooptest
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|snoopend
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|SYM_FWA_SCR
name|SYM_FWA_SCR
init|=
block|{
comment|/*--------------------------< START>----------------------------*/
block|{
comment|/* 	 *  Switch the LED on. 	 *  Will be patched with a NO_OP if LED 	 *  not needed or not desired. 	 */
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfe
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *      Clear SIGP. 	 */
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Stop here if the C code wants to perform  	 *  some error recovery procedure manually. 	 *  (Indicate this by setting SEM in ISTAT) 	 */
name|SCR_FROM_REG
argument_list|(
name|istat
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Report to the C code the next position in  	 *  the start queue the SCRIPTS will schedule. 	 *  The C code must not change SCRATCHA. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|SEM
argument_list|,
name|SEM
argument_list|)
argument_list|)
block|,
name|SIR_SCRIPT_STOPPED
block|,
comment|/* 	 *  Start the next job. 	 * 	 *  @DSA     = start point for this job. 	 *  SCRATCHA = address of this job in the start queue. 	 * 	 *  We will restore startpos with SCRATCHA if we fails the  	 *  arbitration or if it is the idle job. 	 * 	 *  The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS  	 *  is a critical path. If it is partially executed, it then  	 *  may happen that the job address is not yet in the DSA  	 *  and the the next queue position points to the next JOB. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
literal|4
block|, }
comment|/*-------------------------< GETJOB_BEGIN>---------------------*/
block|,
block|{
name|SCR_STORE_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< GETJOB_END>-----------------------*/
block|,
block|{
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< SELECT>---------------------------*/
block|,
block|{
comment|/* 	 *  DSA	contains the address of a scheduled 	 *  	data structure. 	 * 	 *  SCRATCHA contains the address of the start queue   	 *  	entry which points to the next job. 	 * 	 *  Set Initiator mode. 	 * 	 *  (Target mode is left as an exercise for the reader) 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *      And try to select this target. 	 */
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|ungetjob
argument_list|)
block|,
comment|/* 	 *  Now there are 4 possibilities: 	 * 	 *  (1) The chip looses arbitration. 	 *  This is ok, because it will try again, 	 *  when the bus becomes idle. 	 *  (But beware of the timeout function!) 	 * 	 *  (2) The chip is reselected. 	 *  Then the script processor takes the jump 	 *  to the RESELECT label. 	 * 	 *  (3) The chip wins arbitration. 	 *  Then it will execute SCRIPTS instruction until  	 *  the next instruction that checks SCSI phase. 	 *  Then will stop and wait for selection to be  	 *  complete or selection time-out to occur. 	 * 	 *  After having won arbitration, the SCRIPTS   	 *  processor is able to execute instructions while  	 *  the SCSI core is performing SCSI selection. 	 */
comment|/* 	 *      load the savep (saved data pointer) into 	 *      the actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|savep
argument_list|)
block|,
comment|/* 	 *      Initialize the status registers 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|status
argument_list|)
block|, }
comment|/*-------------------------< WF_SEL_DONE>----------------------*/
block|,
block|{
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|SIR_SEL_ATN_NO_MSG_OUT
block|, }
comment|/*-------------------------< SEND_IDENT>-----------------------*/
block|,
block|{
comment|/* 	 *  Selection complete. 	 *  Send the IDENTIFY and possibly the TAG message  	 *  and negotiation message if present. 	 */
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|smsg
argument_list|)
block|, }
comment|/*-------------------------< SELECT2>--------------------------*/
block|,
block|{
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *  Set IMMEDIATE ARBITRATION if we have been given  	 *  a hint to do so. (Some job to do after this one). 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_HINT_IARB
argument_list|,
name|HF_HINT_IARB
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|scntl1
argument_list|,
name|SCR_OR
argument_list|,
name|IARB
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  Anticipate the COMMAND phase. 	 *  This is the PHASE we expect at this point. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_COMMAND
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|sel_no_cmd
argument_list|)
block|, }
comment|/*-------------------------< COMMAND>--------------------------*/
block|,
block|{
comment|/* 	 *  ... and send the command 	 */
name|SCR_MOVE_TBL
operator|^
name|SCR_COMMAND
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|cmd
argument_list|)
block|, }
comment|/*-------------------------< DISPATCH>-------------------------*/
block|,
block|{
comment|/* 	 *  MSG_IN is the only phase that shall be  	 *  entered at least once for each (re)selection. 	 *  So we test it first. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|datao_phase
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|datai_phase
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_STATUS
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|status
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_COMMAND
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|command
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_out
argument_list|)
block|,
comment|/* 	 *  Discard as many illegal phases as  	 *  required and tell the C code about. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_ILG_OUT
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_OUT
block|,
name|HADDR_1
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_ILG_OUT
argument_list|)
argument_list|)
block|,
operator|-
literal|16
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_ILG_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_IN
block|,
name|HADDR_1
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_ILG_IN
argument_list|)
argument_list|)
block|,
operator|-
literal|16
block|,
name|SCR_INT
block|,
name|SIR_BAD_PHASE
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< SEL_NO_CMD>-----------------------*/
block|,
block|{
comment|/* 	 *  The target does not switch to command  	 *  phase after IDENTIFY has been sent. 	 * 	 *  If it stays in MSG OUT phase send it  	 *  the IDENTIFY again. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|resend_ident
argument_list|)
block|,
comment|/* 	 *  If target does not switch to MSG IN phase  	 *  and we sent a negotiation, assert the  	 *  failure immediately. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_FAILED
block|,
comment|/* 	 *  Jump to dispatcher. 	 */
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< INIT>-----------------------------*/
block|,
block|{
comment|/* 	 *  Wait for the SCSI RESET signal to be  	 *  inactive before restarting operations,  	 *  since the chip may hang on SEL_ATN  	 *  if SCSI RESET is active. 	 */
name|SCR_FROM_REG
argument_list|(
name|sstat0
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|IRST
argument_list|,
name|IRST
argument_list|)
argument_list|)
block|,
operator|-
literal|16
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< CLRACK>---------------------------*/
block|,
block|{
comment|/* 	 *  Terminate possible pending message phase. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DISP_STATUS>----------------------*/
block|,
block|{
comment|/* 	 *  Anticipate STATUS phase. 	 * 	 *  Does spare 3 SCRIPTS instructions when we have  	 *  completed the INPUT of the data. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_STATUS
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|status
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DATAI_DONE>-----------------------*/
block|,
block|{
comment|/* 	 *  If the device still wants to send us data, 	 *  we must count the extra bytes. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|,
comment|/* 	 *  If the SWIDE is not full, jump to dispatcher. 	 *  We anticipate a STATUS phase. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|disp_status
argument_list|)
block|,
comment|/* 	 *  The SWIDE is full. 	 *  Clear this condition. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSR
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  We are expecting an IGNORE RESIDUE message  	 *  from the device, otherwise we are in data  	 *  overrun condition. Check against MSG_IN phase. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|SIR_SWIDE_OVERRUN
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|disp_status
argument_list|)
block|,
comment|/* 	 *  We are in MSG_IN phase, 	 *  Read the first byte of the message. 	 *  If it is not an IGNORE RESIDUE message, 	 *  signal overrun and jump to message  	 *  processing. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
index|[
literal|0
index|]
argument_list|)
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|M_IGN_RESIDUE
argument_list|)
argument_list|)
block|,
name|SIR_SWIDE_OVERRUN
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|M_IGN_RESIDUE
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|msg_in2
argument_list|)
block|,
comment|/* 	 *  We got the message we expected. 	 *  Read the 2nd byte, and jump to dispatcher. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|disp_status
argument_list|)
block|, }
comment|/*-------------------------< DATAO_DONE>-----------------------*/
block|,
block|{
comment|/* 	 *  If the device wants us to send more data, 	 *  we must count the extra bytes. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|,
comment|/* 	 *  If the SODL is not full jump to dispatcher. 	 *  We anticipate a STATUS phase. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSS
argument_list|,
name|WSS
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|disp_status
argument_list|)
block|,
comment|/* 	 *  The SODL is full, clear this condition. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSS
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  And signal a DATA UNDERRUN condition  	 *  to the C code. 	 */
name|SCR_INT
block|,
name|SIR_SODL_UNDERRUN
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DATAI_PHASE>----------------------*/
block|,
block|{
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< DATAO_PHASE>----------------------*/
block|,
block|{
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< MSG_IN>---------------------------*/
block|,
block|{
comment|/* 	 *  Get the first byte of the message. 	 * 	 *  The script processor doesn't negate the 	 *  ACK signal after this transfer. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
index|[
literal|0
index|]
argument_list|)
block|, }
comment|/*-------------------------< MSG_IN2>--------------------------*/
block|,
block|{
comment|/* 	 *  Check first against 1 byte messages  	 *  that we handle from SCRIPTS. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_COMPLETE
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|complete
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_DISCONNECT
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|disconnect
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_SAVE_DP
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|save_dp
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_RESTORE_DP
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|restore_dp
argument_list|)
block|,
comment|/* 	 *  We handle all other messages from the  	 *  C code, so no need to waste on-chip RAM  	 *  for those ones. 	 */
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|msg_in_etc
argument_list|)
block|, }
comment|/*-------------------------< STATUS>---------------------------*/
block|,
block|{
comment|/* 	 *  get the status 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_STATUS
block|,
name|HADDR_1
argument_list|(
name|scratch
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *  If STATUS is not GOOD, clear IMMEDIATE ARBITRATION,  	 *  since we may have to tamper the start queue from  	 *  the C code. 	 */
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|S_GOOD
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|scntl1
argument_list|,
name|SCR_AND
argument_list|,
operator|~
name|IARB
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  save status to scsi_status. 	 *  mark as complete. 	 */
name|SCR_TO_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_COMPLETE
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Anticipate the MESSAGE PHASE for  	 *  the TASK COMPLETE message. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< COMPLETE>-------------------------*/
block|,
block|{
comment|/* 	 *  Complete message. 	 * 	 *  Copy the data pointer to LASTP. 	 */
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|lastp
argument_list|)
block|,
comment|/* 	 *  When we terminate the cycle by clearing ACK, 	 *  the target may disconnect immediately. 	 * 	 *  We don't want to be told of an "unexpected disconnect", 	 *  so we disable this feature. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Terminate cycle ... 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  ... and wait for the disconnect. 	 */
name|SCR_WAIT_DISC
block|,
literal|0
block|, }
comment|/*-------------------------< COMPLETE2>------------------------*/
block|,
block|{
comment|/* 	 *  Save host status. 	 */
name|SCR_STORE_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  Some bridges may reorder DMA writes to memory. 	 *  We donnot want the CPU to deal with completions   	 *  without all the posted write having been flushed  	 *  to memory. This DUMMY READ should flush posted  	 *  buffers prior to the CPU having to deal with  	 *  completions. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
comment|/* DUMMY READ */
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  If command resulted in not GOOD status, 	 *  call the C code if needed. 	 */
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_CALL
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|S_GOOD
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|bad_status
argument_list|)
block|,
comment|/* 	 *  If we performed an auto-sense, call  	 *  the C code to synchronyze task aborts  	 *  with UNIT ATTENTION conditions. 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
operator|(
name|HF_SENSE
operator||
name|HF_EXT_ERR
operator|)
argument_list|)
argument_list|)
block|,
literal|16
block|, }
comment|/*-------------------------< COMPLETE_ERROR>-------------------*/
block|,
block|{
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_INT
block|,
name|SIR_COMPLETE_ERROR
block|, }
comment|/*-------------------------< DONE>-----------------------------*/
block|,
block|{
comment|/* 	 *  Copy the DSA to the DONE QUEUE and  	 *  signal completion to the host. 	 *  If we are interrupted between DONE  	 *  and DONE_END, we must reset, otherwise  	 *  the completed CCB may be lost. 	 */
name|SCR_STORE_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|saved_dsa
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|done_pos
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|saved_dsa
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  The instruction below reads the DONE QUEUE next  	 *  free position from memory. 	 *  In addition it ensures that all PCI posted writes   	 *  are flushed and so the DSA value of the done  	 *  CCB is visible by the CPU before INTFLY is raised. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
literal|4
block|,
name|SCR_INT_FLY
block|,
literal|0
block|,
name|SCR_STORE_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|done_pos
argument_list|)
block|, }
comment|/*-------------------------< DONE_END>-------------------------*/
block|,
block|{
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< SAVE_DP>--------------------------*/
block|,
block|{
comment|/* 	 *  Clear ACK immediately. 	 *  No need to delay it. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Keep track we received a SAVE DP, so  	 *  we will switch to the other PM context  	 *  on the next PM since the DP may point  	 *  to the current PM context. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_DP_SAVED
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  SAVE_DP message: 	 *  Copy the data pointer to SAVEP. 	 */
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< RESTORE_DP>-----------------------*/
block|,
block|{
comment|/* 	 *  RESTORE_DP message: 	 *  Copy SAVEP to actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< DISCONNECT>-----------------------*/
block|,
block|{
comment|/* 	 *  DISCONNECTing  ... 	 * 	 *  disable the "unexpected disconnect" feature, 	 *  and remove the ACK signal. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Wait for the disconnect. 	 */
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	 *  Status is: DISCONNECTED. 	 */
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_DISCONNECT
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Save host status. 	 */
name|SCR_STORE_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  If QUIRK_AUTOSAVE is set, 	 *  do an "save pointer" operation. 	 */
name|SCR_FROM_REG
argument_list|(
name|QU_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|SYM_QUIRK_AUTOSAVE
argument_list|,
name|SYM_QUIRK_AUTOSAVE
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|,
comment|/* 	 *  like SAVE_DP message: 	 *  Remember we saved the data pointer. 	 *  Copy data pointer to SAVEP. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_DP_SAVED
argument_list|)
block|,
literal|0
block|,
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< IDLE>-----------------------------*/
block|,
block|{
comment|/* 	 *  Nothing to do? 	 *  Switch the LED off and wait for reselect. 	 *  Will be patched with a NO_OP if LED 	 *  not needed or not desired. 	 */
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_OR
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
name|SCR_JUMPR
block|,
literal|8
block|,
endif|#
directive|endif
block|}
comment|/*-------------------------< UNGETJOB>-------------------------*/
block|,
block|{
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *  Set IMMEDIATE ARBITRATION, for the next time. 	 *  This will give us better chance to win arbitration  	 *  for the job we just wanted to do. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl1
argument_list|,
name|SCR_OR
argument_list|,
name|IARB
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  We are not able to restart the SCRIPTS if we are  	 *  interrupted and these instruction haven't been  	 *  all executed. BTW, this is very unlikely to  	 *  happen, but we check that from the C code. 	 */
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
name|SCR_STORE_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|startpos
argument_list|)
block|, }
comment|/*-------------------------< RESELECT>-------------------------*/
block|,
block|{
comment|/* 	 *  Make sure we are in initiator mode. 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Sleep waiting for a reselection. 	 */
name|SCR_WAIT_RESEL
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< RESELECTED>-----------------------*/
block|,
block|{
comment|/* 	 *  Switch the LED on. 	 *  Will be patched with a NO_OP if LED 	 *  not needed or not desired. 	 */
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfe
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  load the target id into the sdid 	 */
name|SCR_REG_SFBR
argument_list|(
name|ssid
argument_list|,
name|SCR_AND
argument_list|,
literal|0x8F
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|sdid
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Load the target control block address 	 */
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|targtbl
argument_list|)
block|,
name|SCR_SFBR_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_AND
argument_list|,
literal|0x3c
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  We expect MESSAGE IN phase. 	 *  If not, get help from the C code. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|SIR_RESEL_NO_MSG_IN
block|,
comment|/* 	 *  Load the legacy synchronous transfer registers. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scntl3
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|wval
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|sxfer
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|sval
argument_list|)
block|, }
comment|/*-------------------------< RESEL_SCNTL4>---------------------*/
block|,
block|{
comment|/* 	 *  The C1010 uses a new synchronous timing scheme. 	 *  Will be patched with a NO_OP if not a C1010. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scntl4
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|uval
argument_list|)
block|,
comment|/* 	 *  Get the IDENTIFY message. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
argument_list|)
block|,
comment|/* 	 *  If IDENTIFY LUN #0, use a faster path  	 *  to find the LCB structure. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0x80
argument_list|,
literal|0xbf
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|resel_lun0
argument_list|)
block|,
comment|/* 	 *  If message isn't an IDENTIFY,  	 *  tell the C code about. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0x80
argument_list|,
literal|0x80
argument_list|)
argument_list|)
block|,
name|SIR_RESEL_NO_IDENTIFY
block|,
comment|/* 	 *  It is an IDENTIFY message, 	 *  Load the LUN control block address. 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|luntbl_sa
argument_list|)
block|,
name|SCR_SFBR_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfc
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
block|,
literal|8
block|, }
comment|/*-------------------------< RESEL_LUN0>-----------------------*/
block|,
block|{
comment|/* 	 *  LUN 0 special case (but usual one :)) 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|lun0_sa
argument_list|)
block|,
comment|/* 	 *  Jump indirectly to the reselect action for this LUN. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_lcb
argument_list|,
name|head
operator|.
name|resel_sa
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* In normal situations, we jump to RESEL_TAG or RESEL_NO_TAG */
block|}
comment|/*-------------------------< RESEL_TAG>------------------------*/
block|,
block|{
comment|/* 	 *  ACK the IDENTIFY or TAG previously received. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  It shall be a tagged command. 	 *  Read SIMPLE+TAG. 	 *  The C code will deal with errors. 	 *  Agressive optimization, is'nt it? :) 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|2
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
argument_list|)
block|,
comment|/* 	 *  Load the pointer to the tagged task  	 *  table for this LUN. 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_lcb
argument_list|,
name|head
operator|.
name|itlq_tbl_sa
argument_list|)
block|,
comment|/* 	 *  The SIDL still contains the TAG value. 	 *  Agressive optimization, isn't it? :):) 	 */
name|SCR_REG_SFBR
argument_list|(
name|sidl
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
if|#
directive|if
name|SYM_CONF_MAX_TASK
operator|*
literal|4
operator|>
literal|512
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|dsa1
argument_list|,
name|SCR_OR
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|dsa1
argument_list|,
name|SCR_OR
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
elif|#
directive|elif
name|SYM_CONF_MAX_TASK
operator|*
literal|4
operator|>
literal|256
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|dsa1
argument_list|,
name|SCR_OR
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  Retrieve the DSA of this task. 	 *  JUMP indirectly to the restart point of the CCB. 	 */
name|SCR_SFBR_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfc
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|restart
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* In normal situations we branch to RESEL_DSA */
block|}
comment|/*-------------------------< RESEL_DSA>------------------------*/
block|,
block|{
comment|/* 	 *  ACK the IDENTIFY or TAG previously received. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< RESEL_DSA1>-----------------------*/
block|,
block|{
comment|/* 	 *      load the savep (saved pointer) into 	 *      the actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|savep
argument_list|)
block|,
comment|/* 	 *      Initialize the status registers 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  Jump to dispatcher. 	 */
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< RESEL_NO_TAG>---------------------*/
block|,
block|{
comment|/* 	 *  Load the DSA with the unique ITL task. 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_lcb
argument_list|,
name|head
operator|.
name|itl_task_sa
argument_list|)
block|,
comment|/* 	 *  JUMP indirectly to the restart point of the CCB. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|restart
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* In normal situations we branch to RESEL_DSA */
block|}
comment|/*-------------------------< DATA_IN>--------------------------*/
block|,
block|{
comment|/*  *  Because the size depends on the  *  #define SYM_CONF_MAX_SG parameter,  *  it is filled in at runtime.  *  *  ##===========< i=0; i<SYM_CONF_MAX_SG>=========  *  ||	SCR_CHMOV_TBL ^ SCR_DATA_IN,  *  ||		offsetof (struct sym_dsb, data[ i]),  *  ##==========================================  */
literal|0
block|}
comment|/*-------------------------< DATA_IN2>-------------------------*/
block|,
block|{
name|SCR_CALL
block|,
name|PADDR_A
argument_list|(
name|datai_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|, }
comment|/*-------------------------< DATA_OUT>-------------------------*/
block|,
block|{
comment|/*  *  Because the size depends on the  *  #define SYM_CONF_MAX_SG parameter,  *  it is filled in at runtime.  *  *  ##===========< i=0; i<SYM_CONF_MAX_SG>=========  *  ||	SCR_CHMOV_TBL ^ SCR_DATA_OUT,  *  ||		offsetof (struct sym_dsb, data[ i]),  *  ##==========================================  */
literal|0
block|}
comment|/*-------------------------< DATA_OUT2>------------------------*/
block|,
block|{
name|SCR_CALL
block|,
name|PADDR_A
argument_list|(
name|datao_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|, }
comment|/*-------------------------< PM0_DATA>-------------------------*/
block|,
block|{
comment|/* 	 *  Read our host flags to SFBR, so we will be able  	 *  to check against the data direction we expect. 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Check against actual DATA PHASE. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|pm0_data_out
argument_list|)
block|,
comment|/* 	 *  Actual phase is DATA IN. 	 *  Check against expected direction. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_DATA_IN
argument_list|,
name|HF_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|,
comment|/* 	 *  Keep track we are moving data from the  	 *  PM0 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_IN_PM0
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Move the data to memory. 	 */
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|pm0_data_end
argument_list|)
block|, }
comment|/*-------------------------< PM0_DATA_OUT>---------------------*/
block|,
block|{
comment|/* 	 *  Actual phase is DATA OUT. 	 *  Check against expected direction. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|HF_DATA_IN
argument_list|,
name|HF_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|,
comment|/* 	 *  Keep track we are moving data from the  	 *  PM0 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_IN_PM0
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Move the data from memory. 	 */
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|, }
comment|/*-------------------------< PM0_DATA_END>---------------------*/
block|,
block|{
comment|/* 	 *  Clear the flag that told we were moving   	 *  data from the PM0 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_AND
argument_list|,
operator|(
operator|~
name|HF_IN_PM0
operator|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Return to the previous DATA script which  	 *  is guaranteed by design (if no bug) to be  	 *  the main DATA script for this transfer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< PM1_DATA>-------------------------*/
block|,
block|{
comment|/* 	 *  Read our host flags to SFBR, so we will be able  	 *  to check against the data direction we expect. 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Check against actual DATA PHASE. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|pm1_data_out
argument_list|)
block|,
comment|/* 	 *  Actual phase is DATA IN. 	 *  Check against expected direction. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_DATA_IN
argument_list|,
name|HF_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|,
comment|/* 	 *  Keep track we are moving data from the  	 *  PM1 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_IN_PM1
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Move the data to memory. 	 */
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|pm1_data_end
argument_list|)
block|, }
comment|/*-------------------------< PM1_DATA_OUT>---------------------*/
block|,
block|{
comment|/* 	 *  Actual phase is DATA OUT. 	 *  Check against expected direction. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|HF_DATA_IN
argument_list|,
name|HF_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|,
comment|/* 	 *  Keep track we are moving data from the  	 *  PM1 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_IN_PM1
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Move the data from memory. 	 */
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|, }
comment|/*-------------------------< PM1_DATA_END>---------------------*/
block|,
block|{
comment|/* 	 *  Clear the flag that told we were moving   	 *  data from the PM1 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_AND
argument_list|,
operator|(
operator|~
name|HF_IN_PM1
operator|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Return to the previous DATA script which  	 *  is guaranteed by design (if no bug) to be  	 *  the main DATA script for this transfer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------<>-----------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|SYM_FWB_SCR
name|SYM_FWB_SCR
init|=
block|{
comment|/*--------------------------< START64>--------------------------*/
block|{
comment|/* 	 *  SCRIPT entry point for the 895A, 896 and 1010. 	 *  For now, there is no specific stuff for those  	 *  chips at this point, but this may come. 	 */
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|init
argument_list|)
block|, }
comment|/*-------------------------< NO_DATA>--------------------------*/
block|,
block|{
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|, }
comment|/*-------------------------< SEL_FOR_ABORT>--------------------*/
block|,
block|{
comment|/* 	 *  We are jumped here by the C code, if we have  	 *  some target to reset or some disconnected  	 *  job to abort. Since error recovery is a serious  	 *  busyness, we will really reset the SCSI BUS, if  	 *  case of a SCSI interrupt occuring in this path. 	 */
comment|/* 	 *  Set initiator mode. 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *      And try to select this target. 	 */
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|abrt_sel
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|reselect
argument_list|)
block|,
comment|/* 	 *  Wait for the selection to complete or  	 *  the selection to time out. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
operator|-
literal|8
block|,
comment|/* 	 *  Call the C code. 	 */
name|SCR_INT
block|,
name|SIR_TARGET_SELECTED
block|,
comment|/* 	 *  The C code should let us continue here.  	 *  Send the 'kiss of death' message. 	 *  We expect an immediate disconnect once  	 *  the target has eaten the message. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|abrt_tbl
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	 *  Tell the C code that we are done. 	 */
name|SCR_INT
block|,
name|SIR_ABORT_SENT
block|, }
comment|/*-------------------------< SEL_FOR_ABORT_1>------------------*/
block|,
block|{
comment|/* 	 *  Jump at scheduler. 	 */
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< MSG_IN_ETC>-----------------------*/
block|,
block|{
comment|/* 	 *  If it is an EXTENDED (variable size message) 	 *  Handle it. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_EXTENDED
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_extended
argument_list|)
block|,
comment|/* 	 *  Let the C code handle any other  	 *  1 byte message. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_received
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0x10
argument_list|,
literal|0xf0
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_received
argument_list|)
block|,
comment|/* 	 *  We donnot handle 2 bytes messages from SCRIPTS. 	 *  So, let the C code deal with these ones too. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0x20
argument_list|,
literal|0xf0
argument_list|)
argument_list|)
block|,
name|SIR_MSG_WEIRD
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|, }
comment|/*-------------------------< MSG_RECEIVED>---------------------*/
block|,
block|{
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
comment|/* DUMMY READ */
literal|0
block|,
name|SCR_INT
block|,
name|SIR_MSG_RECEIVED
block|, }
comment|/*-------------------------< MSG_WEIRD_SEEN>-------------------*/
block|,
block|{
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
comment|/* DUMMY READ */
literal|0
block|,
name|SCR_INT
block|,
name|SIR_MSG_WEIRD
block|, }
comment|/*-------------------------< MSG_EXTENDED>---------------------*/
block|,
block|{
comment|/* 	 *  Clear ACK and get the next byte  	 *  assumed to be the message length. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* 	 *  Try to catch some unlikely situations as 0 length  	 *  or too large the length. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_weird_seen
argument_list|)
block|,
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_ADD
argument_list|,
operator|(
literal|256
operator|-
literal|8
operator|)
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|CARRYSET
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_weird_seen
argument_list|)
block|,
comment|/* 	 *  We donnot handle extended messages from SCRIPTS. 	 *  Read the amount of data correponding to the  	 *  message length and call the C code. 	 */
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|smsg_ext
operator|.
name|size
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|smsg_ext
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|msg_received
argument_list|)
block|, }
comment|/*-------------------------< MSG_BAD>--------------------------*/
block|,
block|{
comment|/* 	 *  unimplemented message - reject it. 	 */
name|SCR_INT
block|,
name|SIR_REJECT_TO_SEND
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< MSG_WEIRD>------------------------*/
block|,
block|{
comment|/* 	 *  weird message received 	 *  ignore all MSG IN phases and reject it. 	 */
name|SCR_INT
block|,
name|SIR_REJECT_TO_SEND
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< MSG_WEIRD1>-----------------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|HADDR_1
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|msg_weird1
argument_list|)
block|, }
comment|/*-------------------------< WDTR_RESP>------------------------*/
block|,
block|{
comment|/* 	 *  let the target fetch our answer. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|nego_bad_phase
argument_list|)
block|, }
comment|/*-------------------------< SEND_WDTR>------------------------*/
block|,
block|{
comment|/* 	 *  Send the M_X_WIDE_REQ 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|4
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|HADDR_1
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|msg_out_done
argument_list|)
block|, }
comment|/*-------------------------< SDTR_RESP>------------------------*/
block|,
block|{
comment|/* 	 *  let the target fetch our answer. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|nego_bad_phase
argument_list|)
block|, }
comment|/*-------------------------< SEND_SDTR>------------------------*/
block|,
block|{
comment|/* 	 *  Send the M_X_SYNC_REQ 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|5
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|HADDR_1
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|msg_out_done
argument_list|)
block|, }
comment|/*-------------------------< PPR_RESP>-------------------------*/
block|,
block|{
comment|/* 	 *  let the target fetch our answer. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|nego_bad_phase
argument_list|)
block|, }
comment|/*-------------------------< SEND_PPR>-------------------------*/
block|,
block|{
comment|/* 	 *  Send the M_X_PPR_REQ 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|8
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|HADDR_1
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|msg_out_done
argument_list|)
block|, }
comment|/*-------------------------< NEGO_BAD_PHASE>-------------------*/
block|,
block|{
name|SCR_INT
block|,
name|SIR_NEGO_PROTO
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT>--------------------------*/
block|,
block|{
comment|/* 	 *  The target requests a message. 	 *  We donnot send messages that may  	 *  require the device to go to bus free. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|HADDR_1
argument_list|(
name|msgout
argument_list|)
block|,
comment|/* 	 *  ... wait for the next phase 	 *  if it's a message out, send it again, ... 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|msg_out
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT_DONE>---------------------*/
block|,
block|{
comment|/* 	 *  Let the C code be aware of the  	 *  sent message and clear the message. 	 */
name|SCR_INT
block|,
name|SIR_MSG_OUT_DONE
block|,
comment|/* 	 *  ... and process the next phase 	 */
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DATA_OVRUN>-----------------------*/
block|,
block|{
comment|/* 	 *  Use scratcha to count the extra bytes. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|zero
argument_list|)
block|, }
comment|/*-------------------------< DATA_OVRUN1>----------------------*/
block|,
block|{
comment|/* 	 *  The target may want to transfer too much data. 	 * 	 *  If phase is DATA OUT write 1 byte and count it. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_OUT
block|,
name|HADDR_1
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun2
argument_list|)
block|,
comment|/* 	 *  If WSR is set, clear this condition, and  	 *  count this byte. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSR
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun2
argument_list|)
block|,
comment|/* 	 *  Finally check against DATA IN phase. 	 *  Signal data overrun to the C code  	 *  and jump to dispatcher if not so. 	 *  Read 1 byte otherwise and count it. 	 */
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_INT
block|,
name|SIR_DATA_OVERRUN
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_CHMOV_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_IN
block|,
name|HADDR_1
argument_list|(
name|scratch
argument_list|)
block|, }
comment|/*-------------------------< DATA_OVRUN2>----------------------*/
block|,
block|{
comment|/* 	 *  Count this byte. 	 *  This will allow to return a negative  	 *  residual to user. 	 */
name|SCR_REG_REG
argument_list|(
name|scratcha
argument_list|,
name|SCR_ADD
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha2
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  .. and repeat as required. 	 */
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun1
argument_list|)
block|, }
comment|/*-------------------------< ABORT_RESEL>----------------------*/
block|,
block|{
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  send the abort/abortag/reset message 	 *  we expect an immediate disconnect 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|HADDR_1
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
name|SCR_INT
block|,
name|SIR_RESEL_ABORTED
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< RESEND_IDENT>---------------------*/
block|,
block|{
comment|/* 	 *  The target stays in MSG OUT phase after having acked  	 *  Identify [+ Tag [+ Extended message ]]. Targets shall 	 *  behave this way on parity error. 	 *  We must send it again all the messages. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
comment|/* Shall be asserted 2 deskew delays before the  */
literal|0
block|,
comment|/* 1rst ACK = 90 ns. Hope the chip isn't too fast */
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|send_ident
argument_list|)
block|, }
comment|/*-------------------------< IDENT_BREAK>----------------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|select2
argument_list|)
block|, }
comment|/*-------------------------< IDENT_BREAK_ATN>------------------*/
block|,
block|{
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|select2
argument_list|)
block|, }
comment|/*-------------------------< SDATA_IN>-------------------------*/
block|,
block|{
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|sense
argument_list|)
block|,
name|SCR_CALL
block|,
name|PADDR_A
argument_list|(
name|datai_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|data_ovrun
argument_list|)
block|, }
comment|/*-------------------------< RESEL_BAD_LUN>--------------------*/
block|,
block|{
comment|/* 	 *  Message is an IDENTIFY, but lun is unknown. 	 *  Signal problem to C code for logging the event. 	 *  Send a M_ABORT to clear all pending tasks. 	 */
name|SCR_INT
block|,
name|SIR_RESEL_BAD_LUN
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|abort_resel
argument_list|)
block|, }
comment|/*-------------------------< BAD_I_T_L>------------------------*/
block|,
block|{
comment|/* 	 *  We donnot have a task for that I_T_L. 	 *  Signal problem to C code for logging the event. 	 *  Send a M_ABORT message. 	 */
name|SCR_INT
block|,
name|SIR_RESEL_BAD_I_T_L
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|abort_resel
argument_list|)
block|, }
comment|/*-------------------------< BAD_I_T_L_Q>----------------------*/
block|,
block|{
comment|/* 	 *  We donnot have a task that matches the tag. 	 *  Signal problem to C code for logging the event. 	 *  Send a M_ABORTTAG message. 	 */
name|SCR_INT
block|,
name|SIR_RESEL_BAD_I_T_L_Q
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|abort_resel
argument_list|)
block|, }
comment|/*-------------------------< BAD_STATUS>-----------------------*/
block|,
block|{
comment|/* 	 *  Anything different from INTERMEDIATE  	 *  CONDITION MET should be a bad SCSI status,  	 *  given that GOOD status has already been tested. 	 *  Call the C code. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|S_COND_MET
argument_list|)
argument_list|)
block|,
name|SIR_BAD_SCSI_STATUS
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< PM_HANDLE>------------------------*/
block|,
block|{
comment|/* 	 *  Phase mismatch handling. 	 * 	 *  Since we have to deal with 2 SCSI data pointers   	 *  (current and saved), we need at least 2 contexts. 	 *  Each context (pm0 and pm1) has a saved area, a  	 *  SAVE mini-script and a DATA phase mini-script. 	 */
comment|/* 	 *  Get the PM handling flags. 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  If no flags (1rst PM for example), avoid  	 *  all the below heavy flags testing. 	 *  This makes the normal case a bit faster. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm_handle1
argument_list|)
block|,
comment|/* 	 *  If we received a SAVE DP, switch to the  	 *  other PM context since the savep may point  	 *  to the current PM context. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_DP_SAVED
argument_list|,
name|HF_DP_SAVED
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_XOR
argument_list|,
name|HF_ACT_PM
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  If we have been interrupt in a PM DATA mini-script, 	 *  we take the return address from the corresponding  	 *  saved area. 	 *  This ensure the return address always points to the  	 *  main DATA script for this transfer. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator|)
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm_handle1
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_IN_PM0
argument_list|,
name|HF_IN_PM0
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_LOAD_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|pm_save
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_B
argument_list|(
name|pm_save
argument_list|)
block|, }
comment|/*-------------------------< PM_HANDLE1>-----------------------*/
block|,
block|{
comment|/* 	 *  Normal case. 	 *  Update the return address so that it  	 *  will point after the interrupted MOVE. 	 */
name|SCR_REG_REG
argument_list|(
name|ia
argument_list|,
name|SCR_ADD
argument_list|,
literal|8
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ia1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< PM_SAVE>--------------------------*/
block|,
block|{
comment|/* 	 *  Clear all the flags that told us if we were  	 *  interrupted in a PM DATA mini-script and/or  	 *  we received a SAVE DP. 	 */
name|SCR_SFBR_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_AND
argument_list|,
operator|(
operator|~
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
operator|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Choose the current PM context. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|HF_ACT_PM
argument_list|,
name|HF_ACT_PM
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm1_save
argument_list|)
block|, }
comment|/*-------------------------< PM0_SAVE>-------------------------*/
block|,
block|{
name|SCR_STORE_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
block|,
comment|/* 	 *  If WSR bit is set, either UA and RBC may  	 *  have to be changed whether the device wants  	 *  to ignore this residue or not. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_CALL
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm_wsr_handle
argument_list|)
block|,
comment|/* 	 *  Save the remaining byte count, the updated  	 *  address and the return address. 	 */
name|SCR_STORE_REL
argument_list|(
name|rbc
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
operator|.
name|size
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
operator|.
name|addr
argument_list|)
block|,
comment|/* 	 *  Set the current pointer at the PM0 DATA mini-script. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm0_data_addr
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< PM1_SAVE>-------------------------*/
block|,
block|{
name|SCR_STORE_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
block|,
comment|/* 	 *  If WSR bit is set, either UA and RBC may  	 *  have to be changed whether the device wants  	 *  to ignore this residue or not. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_CALL
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm_wsr_handle
argument_list|)
block|,
comment|/* 	 *  Save the remaining byte count, the updated  	 *  address and the return address. 	 */
name|SCR_STORE_REL
argument_list|(
name|rbc
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
operator|.
name|size
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
operator|.
name|addr
argument_list|)
block|,
comment|/* 	 *  Set the current pointer at the PM1 DATA mini-script. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|pm1_data_addr
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< PM_WSR_HANDLE>--------------------*/
block|,
block|{
comment|/* 	 *  Phase mismatch handling from SCRIPT with WSR set. 	 *  Such a condition can occur if the chip wants to  	 *  execute a CHMOV(size> 1) when the WSR bit is  	 *  set and the target changes PHASE. 	 * 	 *  We must move the residual byte to memory. 	 * 	 *  UA contains bit 0..31 of the address to  	 *  move the residual byte. 	 *  Move it to the table indirect. 	 */
name|SCR_STORE_REL
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|wresid
operator|.
name|addr
argument_list|)
block|,
comment|/* 	 *  Increment UA (move address to next position). 	 */
name|SCR_REG_REG
argument_list|(
name|ua
argument_list|,
name|SCR_ADD
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua2
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua3
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Compute SCRATCHA as: 	 *  - size to transfer = 1 byte. 	 *  - bit 24..31 = high address bit [32...39]. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|zero
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha
argument_list|,
name|SCR_OR
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|rbc3
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|scratcha3
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Move this value to the table indirect. 	 */
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|wresid
operator|.
name|size
argument_list|)
block|,
comment|/* 	 *  Wait for a valid phase. 	 *  While testing with bogus QUANTUM drives, the C1010  	 *  sometimes raised a spurious phase mismatch with  	 *  WSR and the CHMOV(1) triggered another PM. 	 *  Waiting explicitely for the PHASE seemed to avoid  	 *  the nested phase mismatch. Btw, this didn't happen  	 *  using my IBM drives. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Perform the move of the residual byte. 	 */
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|wresid
argument_list|)
block|,
comment|/* 	 *  We can now handle the phase mismatch with UA fixed. 	 *  RBC[0..23]=0 is a special case that does not require  	 *  a PM context. The C code also checks against this. 	 */
name|SCR_FROM_REG
argument_list|(
name|rbc
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|rbc1
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|rbc2
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  RBC[0..23]=0. 	 *  Not only we donnot need a PM context, but this would  	 *  lead to a bogus CHMOV(0). This condition means that  	 *  the residual was the last byte to move from this CHMOV. 	 *  So, we just have to move the current data script pointer  	 *  (i.e. TEMP) to the SCRIPTS address following the  	 *  interrupted CHMOV and jump to dispatcher. 	 */
name|SCR_STORE_ABS
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDR_B
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< WSR_MA_HELPER>--------------------*/
block|,
block|{
comment|/* 	 *  Helper for the C code when WSR bit is set. 	 *  Perform the move of the residual byte. 	 */
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|wresid
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR_A
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< ZERO>-----------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SCRATCH>--------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< PM0_DATA_ADDR>--------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< PM1_DATA_ADDR>--------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SAVED_DSA>------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SAVED_DRS>------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< DONE_POS>-------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< STARTPOS>-------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< TARGTBL>--------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|,  }
comment|/*-------------------------< SNOOPTEST>------------------------*/
block|,
block|{
comment|/* 	 *  Read the variable from memory. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|cache
argument_list|)
block|,
comment|/* 	 *  Write the variable to memory. 	 */
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|cache
argument_list|)
block|,
comment|/* 	 *  Read back the variable from memory. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|cache
argument_list|)
block|, }
comment|/*-------------------------< SNOOPEND>-------------------------*/
block|,
block|{
comment|/* 	 *  And stop. 	 */
name|SCR_INT
block|,
literal|99
block|, }
comment|/*-------------------------<>-----------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

end_unit

