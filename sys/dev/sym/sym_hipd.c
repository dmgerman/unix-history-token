begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Device driver optimized for the Symbios/LSI 53C896/53C895A/53C1010   *  PCI-SCSI controllers.  *  *  Copyright (C) 1999  Gerard Roudier<groudier@club-internet.fr>  *  *  This driver also supports the following Symbios/LSI PCI-SCSI chips:  *	53C810A, 53C825A, 53C860, 53C875, 53C876, 53C885, 53C895.  *  *  but does not support earlier chips as the following ones:  *	53C810, 53C815, 53C825.  *    *  This driver for FreeBSD-CAM is derived from the Linux sym53c8xx driver.  *  Copyright (C) 1998-1999  Gerard Roudier  *  *  The sym53c8xx driver is derived from the ncr53c8xx driver that had been   *  a port of the FreeBSD ncr driver to Linux-1.2.13.  *  *  The original ncr driver has been written for 386bsd and FreeBSD by  *          Wolfgang Stanglmeier<wolf@cologne.de>  *          Stefan Esser<se@mi.Uni-Koeln.de>  *  Copyright (C) 1994  Wolfgang Stanglmeier  *  *  The initialisation code, and part of the code that addresses   *  FreeBSD-CAM services is based on the aic7xxx driver for FreeBSD-CAM   *  written by Justin T. Gibbs.  *  *  Other major contributions:  *  *  NVRAM detection and reading.  *  Copyright (C) 1997 Richard Waltham<dormouse@farsrobt.demon.co.uk>  *  *-----------------------------------------------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_define
define|#
directive|define
name|SYM_DRIVER_NAME
value|"sym-0.10.0-19991111"
end_define

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For offsetof */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/*  *  Only use the BUS stuff for PCI under FreeBSD 4 and later versions.  *  Note that the old BUS stuff also works for FreeBSD 4 and spares   *  about 1.5KB for the driver objet file.  */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|400000
end_if

begin_define
define|#
directive|define
name|FreeBSD_4_Bus
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
end_ifdef

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
end_ifdef

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Short and quite clear integer types */
end_comment

begin_typedef
typedef|typedef
name|int8_t
name|s8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int16_t
name|s16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|s32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int8_t
name|u8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int16_t
name|u16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int32_t
name|u32
typedef|;
end_typedef

begin_comment
comment|/* Driver configuration and definitions */
end_comment

begin_include
include|#
directive|include
file|<pci/sym_conf.h>
end_include

begin_include
include|#
directive|include
file|<pci/sym_defs.h>
end_include

begin_comment
comment|/*  *  On x86 architecture, write buffers management does not   *  reorder writes to memory. So, preventing compiler from    *  optimizing the code is enough to guarantee some ordering   *  when the CPU is writing data accessed by the PCI chip.  *  On Alpha architecture, explicit barriers are to be used.  *  By the way, the *BSD semantic associates the barrier   *  with some window on the BUS and the corresponding verbs   *  are for now unused. What a strangeness. The driver must   *  ensure that accesses from the CPU to the start and done   *  queues are not reordered by either the compiler or the   *  CPU and uses 'volatile' for this purpose.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|MEMORY_BARRIER
parameter_list|()
value|alpha_mb()
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__i386__*/
end_comment

begin_define
define|#
directive|define
name|MEMORY_BARRIER
parameter_list|()
value|do { ; } while(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  A la VMS/CAM-3 queue management.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|sym_quehead
block|{
name|struct
name|sym_quehead
modifier|*
name|flink
decl_stmt|;
comment|/* Forward  pointer */
name|struct
name|sym_quehead
modifier|*
name|blink
decl_stmt|;
comment|/* Backward pointer */
block|}
name|SYM_QUEHEAD
typedef|;
end_typedef

begin_define
define|#
directive|define
name|sym_que_init
parameter_list|(
name|ptr
parameter_list|)
value|do { \ 	(ptr)->flink = (ptr); (ptr)->blink = (ptr); \ } while (0)
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sym_quehead
operator|*
name|sym_que_first
argument_list|(
argument|struct sym_quehead *head
argument_list|)
block|{
return|return
operator|(
name|head
operator|->
name|flink
operator|==
name|head
operator|)
operator|?
literal|0
operator|:
name|head
operator|->
name|flink
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sym_quehead
operator|*
name|sym_que_last
argument_list|(
argument|struct sym_quehead *head
argument_list|)
block|{
return|return
operator|(
name|head
operator|->
name|blink
operator|==
name|head
operator|)
operator|?
literal|0
operator|:
name|head
operator|->
name|blink
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|__sym_que_add
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|new
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|blink
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|flink
parameter_list|)
block|{
name|flink
operator|->
name|blink
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|flink
operator|=
name|flink
expr_stmt|;
name|new
operator|->
name|blink
operator|=
name|blink
expr_stmt|;
name|blink
operator|->
name|flink
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__sym_que_del
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|blink
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|flink
parameter_list|)
block|{
name|flink
operator|->
name|blink
operator|=
name|blink
expr_stmt|;
name|blink
operator|->
name|flink
operator|=
name|flink
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|sym_que_empty
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|head
parameter_list|)
block|{
return|return
name|head
operator|->
name|flink
operator|==
name|head
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sym_que_splice
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|list
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|sym_quehead
modifier|*
name|first
init|=
name|list
operator|->
name|flink
decl_stmt|;
if|if
condition|(
name|first
operator|!=
name|list
condition|)
block|{
name|struct
name|sym_quehead
modifier|*
name|last
init|=
name|list
operator|->
name|blink
decl_stmt|;
name|struct
name|sym_quehead
modifier|*
name|at
init|=
name|head
operator|->
name|flink
decl_stmt|;
name|first
operator|->
name|blink
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|flink
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|flink
operator|=
name|at
expr_stmt|;
name|at
operator|->
name|blink
operator|=
name|last
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|sym_que_entry
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((type *)((char *)(ptr)-(unsigned long)(&((type *)0)->member)))
end_define

begin_define
define|#
directive|define
name|sym_insque
parameter_list|(
name|new
parameter_list|,
name|pos
parameter_list|)
value|__sym_que_add(new, pos, (pos)->flink)
end_define

begin_define
define|#
directive|define
name|sym_remque
parameter_list|(
name|el
parameter_list|)
value|__sym_que_del((el)->blink, (el)->flink)
end_define

begin_define
define|#
directive|define
name|sym_insque_head
parameter_list|(
name|new
parameter_list|,
name|head
parameter_list|)
value|__sym_que_add(new, head, (head)->flink)
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sym_quehead
operator|*
name|sym_remque_head
argument_list|(
argument|struct sym_quehead *head
argument_list|)
block|{ 	struct
name|sym_quehead
operator|*
name|elem
operator|=
name|head
operator|->
name|flink
block|;
if|if
condition|(
name|elem
operator|!=
name|head
condition|)
name|__sym_que_del
argument_list|(
name|head
argument_list|,
name|elem
operator|->
name|flink
argument_list|)
expr_stmt|;
else|else
name|elem
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|elem
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|sym_insque_tail
parameter_list|(
name|new
parameter_list|,
name|head
parameter_list|)
value|__sym_que_add(new, (head)->blink, head)
end_define

begin_function
unit|static
name|__inline
name|struct
name|sym_quehead
modifier|*
name|sym_remque_tail
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|sym_quehead
modifier|*
name|elem
init|=
name|head
operator|->
name|blink
decl_stmt|;
if|if
condition|(
name|elem
operator|!=
name|head
condition|)
name|__sym_que_del
argument_list|(
name|elem
operator|->
name|blink
argument_list|,
name|head
argument_list|)
expr_stmt|;
else|else
name|elem
operator|=
literal|0
expr_stmt|;
return|return
name|elem
return|;
block|}
end_function

begin_comment
comment|/*  *  This one may be usefull.  */
end_comment

begin_define
define|#
directive|define
name|FOR_EACH_QUEUED_ELEMENT
parameter_list|(
name|head
parameter_list|,
name|qp
parameter_list|)
define|\
value|for (qp = (head)->flink; qp != (head); qp = qp->flink)
end_define

begin_comment
comment|/*  *  FreeBSD does not offer our kind of queue in the CAM CCB.  *  So, we have to cast.  */
end_comment

begin_define
define|#
directive|define
name|sym_qptr
parameter_list|(
name|p
parameter_list|)
value|((struct sym_quehead *) (p))
end_define

begin_comment
comment|/*  *  Simple bitmap operations.  */
end_comment

begin_define
define|#
directive|define
name|sym_set_bit
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(((u32 *)(p))[(n)>>5] |=  (1<<((n)&0x1f)))
end_define

begin_define
define|#
directive|define
name|sym_clr_bit
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(((u32 *)(p))[(n)>>5]&= ~(1<<((n)&0x1f)))
end_define

begin_define
define|#
directive|define
name|sym_is_bit
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(((u32 *)(p))[(n)>>5]&   (1<<((n)&0x1f)))
end_define

begin_comment
comment|/*  *  Number of tasks per device we want to handle.  */
end_comment

begin_if
if|#
directive|if
name|SYMCONF_MAX_TAG_ORDER
operator|>
literal|8
end_if

begin_error
error|#
directive|error
literal|"more than 256 tags per logical unit not allowed."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYMCONF_MAX_TASK
value|(1<<SYMCONF_MAX_TAG_ORDER)
end_define

begin_comment
comment|/*  *  Donnot use more tasks that we can handle.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYMCONF_MAX_TAG
end_ifndef

begin_define
define|#
directive|define
name|SYMCONF_MAX_TAG
value|SYMCONF_MAX_TASK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SYMCONF_MAX_TAG
operator|>
name|SYMCONF_MAX_TASK
end_if

begin_undef
undef|#
directive|undef
name|SYMCONF_MAX_TAG
end_undef

begin_define
define|#
directive|define
name|SYMCONF_MAX_TAG
value|SYMCONF_MAX_TASK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *    This one means 'NO TAG for this job'  */
end_comment

begin_define
define|#
directive|define
name|NO_TAG
value|(256)
end_define

begin_comment
comment|/*  *  Number of SCSI targets.  */
end_comment

begin_if
if|#
directive|if
name|SYMCONF_MAX_TARGET
operator|>
literal|16
end_if

begin_error
error|#
directive|error
literal|"more than 16 targets not allowed."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Number of logical units per target.  */
end_comment

begin_if
if|#
directive|if
name|SYMCONF_MAX_LUN
operator|>
literal|64
end_if

begin_error
error|#
directive|error
literal|"more than 64 logical units per target not allowed."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *    Asynchronous pre-scaler (ns). Shall be 40 for   *    the SCSI timings to be compliant.  */
end_comment

begin_define
define|#
directive|define
name|SYMCONF_MIN_ASYNC
value|(40)
end_define

begin_comment
comment|/*  *  Number of entries in the START and DONE queues.  *  *  We limit to 1 PAGE in order to succeed allocation of   *  these queues. Each entry is 8 bytes long (2 DWORDS).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMCONF_MAX_START
end_ifdef

begin_define
define|#
directive|define
name|SYMCONF_MAX_QUEUE
value|(SYMCONF_MAX_START+2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SYMCONF_MAX_QUEUE
value|(7*SYMCONF_MAX_TASK+2)
end_define

begin_define
define|#
directive|define
name|SYMCONF_MAX_START
value|(SYMCONF_MAX_QUEUE-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SYMCONF_MAX_QUEUE
operator|>
name|PAGE_SIZE
operator|/
literal|8
end_if

begin_undef
undef|#
directive|undef
name|SYMCONF_MAX_QUEUE
end_undef

begin_define
define|#
directive|define
name|SYMCONF_MAX_QUEUE
value|PAGE_SIZE/8
end_define

begin_undef
undef|#
directive|undef
name|SYMCONF_MAX_START
end_undef

begin_define
define|#
directive|define
name|SYMCONF_MAX_START
value|(SYMCONF_MAX_QUEUE-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  For this one, we want a short name :-)  */
end_comment

begin_define
define|#
directive|define
name|MAX_QUEUE
value|SYMCONF_MAX_QUEUE
end_define

begin_comment
comment|/*  *  This one should have been already defined.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|t
parameter_list|,
name|m
parameter_list|)
value|((size_t) (&((t *)0)->m))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Active debugging tags and verbosity.  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_ALLOC
value|(0x0001)
end_define

begin_define
define|#
directive|define
name|DEBUG_PHASE
value|(0x0002)
end_define

begin_define
define|#
directive|define
name|DEBUG_POLL
value|(0x0004)
end_define

begin_define
define|#
directive|define
name|DEBUG_QUEUE
value|(0x0008)
end_define

begin_define
define|#
directive|define
name|DEBUG_RESULT
value|(0x0010)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCATTER
value|(0x0020)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCRIPT
value|(0x0040)
end_define

begin_define
define|#
directive|define
name|DEBUG_TINY
value|(0x0080)
end_define

begin_define
define|#
directive|define
name|DEBUG_TIMING
value|(0x0100)
end_define

begin_define
define|#
directive|define
name|DEBUG_NEGO
value|(0x0200)
end_define

begin_define
define|#
directive|define
name|DEBUG_TAGS
value|(0x0400)
end_define

begin_define
define|#
directive|define
name|DEBUG_POINTER
value|(0x0800)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|static int sym_debug = 0;
define|#
directive|define
name|DEBUG_FLAGS
value|sym_debug
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*	#define DEBUG_FLAGS (0x0631) */
end_comment

begin_define
define|#
directive|define
name|DEBUG_FLAGS
value|(0x0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sym_verbose
value|(np->verbose)
end_define

begin_comment
comment|/*  *  Virtual to bus address translation.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|vtobus
parameter_list|(
name|p
parameter_list|)
value|alpha_XXX_dmamap((vm_offset_t)(p))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__i386__*/
end_comment

begin_define
define|#
directive|define
name|vtobus
parameter_list|(
name|p
parameter_list|)
value|vtophys(p)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Copy from main memory to PCI memory space.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|memcpy_to_pci
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|memcpy_toio((u32)(d), (void *)(s), (n))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__i386__*/
end_comment

begin_define
define|#
directive|define
name|memcpy_to_pci
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|bcopy((s), (void *)(d), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Insert a delay in micro-seconds and milli-seconds.  */
end_comment

begin_function
specifier|static
name|void
name|UDELAY
parameter_list|(
name|long
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|MDELAY
parameter_list|(
name|long
name|ms
parameter_list|)
block|{
while|while
condition|(
name|ms
operator|--
condition|)
name|UDELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Memory allocation/allocator.  *  We assume allocations are naturally aligned and if it is   *  not guaranteed, we may use our internal allocator.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMCONF_USE_INTERNAL_ALLOCATOR
end_ifdef

begin_comment
comment|/*  *  Simple power of two buddy-like allocator.  *  *  This simple code is not intended to be fast, but to   *  provide power of 2 aligned memory allocations.  *  Since the SCRIPTS processor only supplies 8 bit arithmetic,   *  this allocator allows simple and fast address calculations    *  from the SCRIPTS code. In addition, cache line alignment   *  is guaranteed for power of 2 cache line size.  *  *  This allocator has been developped for the Linux sym53c8xx    *  driver, since this O/S does not provide naturally aligned   *  allocations.  *  It has the vertue to allow the driver to use private pages   *  of memory that will be useful if we ever need to deal with   *  IO MMU for PCI.  */
end_comment

begin_define
define|#
directive|define
name|MEMO_SHIFT
value|4
end_define

begin_comment
comment|/* 16 bytes minimum memory chunk */
end_comment

begin_define
define|#
directive|define
name|MEMO_PAGE_ORDER
value|0
end_define

begin_comment
comment|/* 1 PAGE maximum (for now (ever?) */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|long
name|addr
typedef|;
end_typedef

begin_comment
comment|/* Enough bits to bit-hack addresses */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|MEMO_FREE_UNUSED
end_define

begin_comment
comment|/* Free unused pages immediately */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|m_link
block|{
name|struct
name|m_link
modifier|*
name|next
decl_stmt|;
comment|/* Simple links are enough */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|M_DMA_32BIT
end_ifndef

begin_define
define|#
directive|define
name|M_DMA_32BIT
value|0
end_define

begin_comment
comment|/* Will this flag ever exist */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|get_pages
parameter_list|()
define|\
value|malloc(PAGE_SIZE<<MEMO_PAGE_ORDER, M_DEVBUF, M_NOWAIT)
end_define

begin_define
define|#
directive|define
name|free_pages
parameter_list|(
name|p
parameter_list|)
define|\
value|free((p), M_DEVBUF)
end_define

begin_comment
comment|/*  *  Lists of available memory chunks.  *  Starts with 16 bytes chunks until 1 PAGE chunks.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|m_link
name|h
index|[
name|PAGE_SHIFT
operator|-
name|MEMO_SHIFT
operator|+
name|MEMO_PAGE_ORDER
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Allocate a memory area aligned on the lowest power of 2   *  greater than the requested size.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|__sym_malloc
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
operator|(
literal|1
operator|<<
name|MEMO_SHIFT
operator|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|addr
name|a
decl_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
name|PAGE_SIZE
operator|<<
name|MEMO_PAGE_ORDER
operator|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|size
operator|>
name|s
condition|)
block|{
name|s
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
operator|!
name|h
index|[
name|j
index|]
operator|.
name|next
condition|)
block|{
if|if
condition|(
name|s
operator|==
operator|(
name|PAGE_SIZE
operator|<<
name|MEMO_PAGE_ORDER
operator|)
condition|)
block|{
name|h
index|[
name|j
index|]
operator|.
name|next
operator|=
operator|(
expr|struct
name|m_link
operator|*
operator|)
name|get_pages
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
index|[
name|j
index|]
operator|.
name|next
condition|)
name|h
index|[
name|j
index|]
operator|.
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|++
name|j
expr_stmt|;
name|s
operator|<<=
literal|1
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|addr
operator|)
name|h
index|[
name|j
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|h
index|[
name|j
index|]
operator|.
name|next
operator|=
name|h
index|[
name|j
index|]
operator|.
name|next
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|j
operator|>
name|i
condition|)
block|{
name|j
operator|-=
literal|1
expr_stmt|;
name|s
operator|>>=
literal|1
expr_stmt|;
name|h
index|[
name|j
index|]
operator|.
name|next
operator|=
operator|(
expr|struct
name|m_link
operator|*
operator|)
operator|(
name|a
operator|+
name|s
operator|)
expr_stmt|;
name|h
index|[
name|j
index|]
operator|.
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"__sym_malloc(%d) = %p\n"
argument_list|,
name|size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|void
operator|*
operator|)
name|a
return|;
block|}
end_function

begin_comment
comment|/*  *  Free a memory area allocated using sym_malloc().  *  Coalesce buddies.  *  Free pages that become unused if MEMO_FREE_UNUSED is   *  defined.  */
end_comment

begin_function
specifier|static
name|void
name|__sym_mfree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
operator|(
literal|1
operator|<<
name|MEMO_SHIFT
operator|)
decl_stmt|;
name|struct
name|m_link
modifier|*
name|q
decl_stmt|;
name|addr
name|a
decl_stmt|,
name|b
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"sym_mfree(%p, %d)\n"
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
operator|(
name|PAGE_SIZE
operator|<<
name|MEMO_PAGE_ORDER
operator|)
condition|)
return|return;
while|while
condition|(
name|size
operator|>
name|s
condition|)
block|{
name|s
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|addr
operator|)
name|ptr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
if|if
condition|(
name|s
operator|==
operator|(
name|PAGE_SIZE
operator|<<
name|MEMO_PAGE_ORDER
operator|)
condition|)
block|{
name|free_pages
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|b
operator|=
name|a
operator|^
name|s
expr_stmt|;
name|q
operator|=
operator|&
name|h
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|next
operator|&&
name|q
operator|->
name|next
operator|!=
operator|(
expr|struct
name|m_link
operator|*
operator|)
name|b
condition|)
block|{
name|q
operator|=
name|q
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q
operator|->
name|next
condition|)
block|{
operator|(
operator|(
expr|struct
name|m_link
operator|*
operator|)
name|a
operator|)
operator|->
name|next
operator|=
name|h
index|[
name|i
index|]
operator|.
name|next
expr_stmt|;
name|h
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|(
expr|struct
name|m_link
operator|*
operator|)
name|a
expr_stmt|;
break|break;
block|}
name|q
operator|->
name|next
operator|=
name|q
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|a
operator|=
name|a
operator|&
name|b
expr_stmt|;
name|s
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !defined SYSCONF_USE_INTERNAL_ALLOCATOR */
end_comment

begin_comment
comment|/*  *  Using directly the system memory allocator.  */
end_comment

begin_define
define|#
directive|define
name|__sym_mfree
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|free((ptr), M_DEVBUF)
end_define

begin_define
define|#
directive|define
name|__sym_malloc
parameter_list|(
name|size
parameter_list|)
value|malloc((size), M_DEVBUF, M_NOWAIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMCONF_USE_INTERNAL_ALLOCATOR */
end_comment

begin_define
define|#
directive|define
name|MEMO_WARN
value|1
end_define

begin_function
specifier|static
name|void
modifier|*
name|sym_calloc2
parameter_list|(
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|uflags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|__sym_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_ALLOC
condition|)
name|printf
argument_list|(
literal|"new %-10s[%4d] @%p.\n"
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|bzero
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uflags
operator|&
name|MEMO_WARN
condition|)
name|printf
argument_list|(
literal|"sym_calloc: failed to allocate %s[%d]\n"
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_define
define|#
directive|define
name|sym_calloc
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|sym_calloc2(s, n, MEMO_WARN)
end_define

begin_function
specifier|static
name|void
name|sym_mfree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_ALLOC
condition|)
name|printf
argument_list|(
literal|"freeing %-10s[%4d] @%p.\n"
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|__sym_mfree
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Print a buffer in hexadecimal format.  */
end_comment

begin_function
specifier|static
name|void
name|sym_printb_hex
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Same with a label at beginning and .\n at end.  */
end_comment

begin_function
specifier|static
name|void
name|sym_printl_hex
parameter_list|(
name|char
modifier|*
name|label
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|sym_printb_hex
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Some poor sync table that refers to Tekram NVRAM layout.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|u_char
name|Tekram_sync
index|[
literal|16
index|]
init|=
block|{
literal|25
block|,
literal|31
block|,
literal|37
block|,
literal|43
block|,
literal|50
block|,
literal|62
block|,
literal|75
block|,
literal|125
block|,
literal|12
block|,
literal|15
block|,
literal|18
block|,
literal|21
block|,
literal|6
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Union of supported NVRAM formats.  */
end_comment

begin_struct
struct|struct
name|sym_nvram
block|{
name|int
name|type
decl_stmt|;
define|#
directive|define
name|SYM_SYMBIOS_NVRAM
value|(1)
define|#
directive|define
name|SYM_TEKRAM_NVRAM
value|(2)
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
union|union
block|{
name|Symbios_nvram
name|Symbios
decl_stmt|;
name|Tekram_nvram
name|Tekram
decl_stmt|;
block|}
name|data
union|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  *  This one is hopefully useless, but actually useful. :-)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|assert
end_ifndef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expression
parameter_list|)
value|{ \ 	if (!(expression)) { \ 		(void)panic( \ 			"assertion \"%s\" failed: file \"%s\", line %d\n", \ 			#expression, \ 			__FILE__, __LINE__); \ 	} \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Some provision for a possible big endian support.  *  By the way some Symbios chips also may support some kind   *  of big endian byte ordering.  *  For now, this stuff does not deserve any comments. :)  */
end_comment

begin_define
define|#
directive|define
name|sym_offb
parameter_list|(
name|o
parameter_list|)
value|(o)
end_define

begin_define
define|#
directive|define
name|sym_offw
parameter_list|(
name|o
parameter_list|)
value|(o)
end_define

begin_define
define|#
directive|define
name|cpu_to_scr
parameter_list|(
name|dw
parameter_list|)
value|(dw)
end_define

begin_define
define|#
directive|define
name|scr_to_cpu
parameter_list|(
name|dw
parameter_list|)
value|(dw)
end_define

begin_comment
comment|/*  *  Access to the controller chip.  *  *  If SYMCONF_IOMAPPED is defined, the driver will use   *  normal IOs instead of the MEMORY MAPPED IO method    *  recommended by PCI specifications.  */
end_comment

begin_comment
comment|/*  *  Define some understable verbs so we will not suffer of   *  having to deal with the stupid PC tokens for IO.  */
end_comment

begin_define
define|#
directive|define
name|io_read8
parameter_list|(
name|p
parameter_list|)
value|scr_to_cpu(inb((p)))
end_define

begin_define
define|#
directive|define
name|io_read16
parameter_list|(
name|p
parameter_list|)
value|scr_to_cpu(inw((p)))
end_define

begin_define
define|#
directive|define
name|io_read32
parameter_list|(
name|p
parameter_list|)
value|scr_to_cpu(inl((p)))
end_define

begin_define
define|#
directive|define
name|io_write8
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|outb((p), cpu_to_scr(v))
end_define

begin_define
define|#
directive|define
name|io_write16
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|outw((p), cpu_to_scr(v))
end_define

begin_define
define|#
directive|define
name|io_write32
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|outl((p), cpu_to_scr(v))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|mmio_read8
parameter_list|(
name|a
parameter_list|)
value|readb(a)
end_define

begin_define
define|#
directive|define
name|mmio_read16
parameter_list|(
name|a
parameter_list|)
value|readw(a)
end_define

begin_define
define|#
directive|define
name|mmio_read32
parameter_list|(
name|a
parameter_list|)
value|readl(a)
end_define

begin_define
define|#
directive|define
name|mmio_write8
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|writeb(a, b)
end_define

begin_define
define|#
directive|define
name|mmio_write16
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|writew(a, b)
end_define

begin_define
define|#
directive|define
name|mmio_write32
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|writel(a, b)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*__i386__*/
end_comment

begin_define
define|#
directive|define
name|mmio_read8
parameter_list|(
name|a
parameter_list|)
value|scr_to_cpu((*(volatile unsigned char *) (a)))
end_define

begin_define
define|#
directive|define
name|mmio_read16
parameter_list|(
name|a
parameter_list|)
value|scr_to_cpu((*(volatile unsigned short *) (a)))
end_define

begin_define
define|#
directive|define
name|mmio_read32
parameter_list|(
name|a
parameter_list|)
value|scr_to_cpu((*(volatile unsigned int *) (a)))
end_define

begin_define
define|#
directive|define
name|mmio_write8
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(volatile unsigned char *) (a)) = cpu_to_scr(b)
end_define

begin_define
define|#
directive|define
name|mmio_write16
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(volatile unsigned short *) (a)) = cpu_to_scr(b)
end_define

begin_define
define|#
directive|define
name|mmio_write32
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(*(volatile unsigned int *) (a)) = cpu_to_scr(b)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Normal IO  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYMCONF_IOMAPPED
argument_list|)
end_if

begin_define
define|#
directive|define
name|INB_OFF
parameter_list|(
name|o
parameter_list|)
value|io_read8(np->io_port + sym_offb(o))
end_define

begin_define
define|#
directive|define
name|OUTB_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|io_write8(np->io_port + sym_offb(o), (v))
end_define

begin_define
define|#
directive|define
name|INW_OFF
parameter_list|(
name|o
parameter_list|)
value|io_read16(np->io_port + sym_offw(o))
end_define

begin_define
define|#
directive|define
name|OUTW_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|io_write16(np->io_port + sym_offw(o), (v))
end_define

begin_define
define|#
directive|define
name|INL_OFF
parameter_list|(
name|o
parameter_list|)
value|io_read32(np->io_port + (o))
end_define

begin_define
define|#
directive|define
name|OUTL_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|io_write32(np->io_port + (o), (v))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Memory mapped IO */
end_comment

begin_define
define|#
directive|define
name|INB_OFF
parameter_list|(
name|o
parameter_list|)
value|mmio_read8(np->mmio_va + sym_offb(o))
end_define

begin_define
define|#
directive|define
name|OUTB_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|mmio_write8(np->mmio_va + sym_offb(o), (v))
end_define

begin_define
define|#
directive|define
name|INW_OFF
parameter_list|(
name|o
parameter_list|)
value|mmio_read16(np->mmio_va + sym_offw(o))
end_define

begin_define
define|#
directive|define
name|OUTW_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|mmio_write16(np->mmio_va + sym_offw(o), (v))
end_define

begin_define
define|#
directive|define
name|INL_OFF
parameter_list|(
name|o
parameter_list|)
value|mmio_read32(np->mmio_va + (o))
end_define

begin_define
define|#
directive|define
name|OUTL_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|mmio_write32(np->mmio_va + (o), (v))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Common to both normal IO and MMIO.  */
end_comment

begin_define
define|#
directive|define
name|INB
parameter_list|(
name|r
parameter_list|)
value|INB_OFF(offsetof(struct sym_reg,r))
end_define

begin_define
define|#
directive|define
name|INW
parameter_list|(
name|r
parameter_list|)
value|INW_OFF(offsetof(struct sym_reg,r))
end_define

begin_define
define|#
directive|define
name|INL
parameter_list|(
name|r
parameter_list|)
value|INL_OFF(offsetof(struct sym_reg,r))
end_define

begin_define
define|#
directive|define
name|OUTB
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|OUTB_OFF(offsetof(struct sym_reg,r), (v))
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|OUTW_OFF(offsetof(struct sym_reg,r), (v))
end_define

begin_define
define|#
directive|define
name|OUTL
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|OUTL_OFF(offsetof(struct sym_reg,r), (v))
end_define

begin_define
define|#
directive|define
name|OUTONB
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTB(r, INB(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFB
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTB(r, INB(r)& ~(m))
end_define

begin_define
define|#
directive|define
name|OUTONW
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTW(r, INW(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFW
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTW(r, INW(r)& ~(m))
end_define

begin_define
define|#
directive|define
name|OUTONL
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTL(r, INL(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFL
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTL(r, INL(r)& ~(m))
end_define

begin_comment
comment|/*  *  Command control block states.  */
end_comment

begin_define
define|#
directive|define
name|HS_IDLE
value|(0)
end_define

begin_define
define|#
directive|define
name|HS_BUSY
value|(1)
end_define

begin_define
define|#
directive|define
name|HS_NEGOTIATE
value|(2)
end_define

begin_comment
comment|/* sync/wide data transfer*/
end_comment

begin_define
define|#
directive|define
name|HS_DISCONNECT
value|(3)
end_define

begin_comment
comment|/* Disconnected by target */
end_comment

begin_define
define|#
directive|define
name|HS_DONEMASK
value|(0x80)
end_define

begin_define
define|#
directive|define
name|HS_COMPLETE
value|(4|HS_DONEMASK)
end_define

begin_define
define|#
directive|define
name|HS_SEL_TIMEOUT
value|(5|HS_DONEMASK)
end_define

begin_comment
comment|/* Selection timeout      */
end_comment

begin_define
define|#
directive|define
name|HS_UNEXPECTED
value|(6|HS_DONEMASK)
end_define

begin_comment
comment|/* Unexpected disconnect  */
end_comment

begin_define
define|#
directive|define
name|HS_COMP_ERR
value|(7|HS_DONEMASK)
end_define

begin_comment
comment|/* Completed with error	  */
end_comment

begin_comment
comment|/*  *  Software Interrupt Codes  */
end_comment

begin_define
define|#
directive|define
name|SIR_BAD_SCSI_STATUS
value|(1)
end_define

begin_define
define|#
directive|define
name|SIR_SEL_ATN_NO_MSG_OUT
value|(2)
end_define

begin_define
define|#
directive|define
name|SIR_MSG_RECEIVED
value|(3)
end_define

begin_define
define|#
directive|define
name|SIR_MSG_WEIRD
value|(4)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_FAILED
value|(5)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_PROTO
value|(6)
end_define

begin_define
define|#
directive|define
name|SIR_SCRIPT_STOPPED
value|(7)
end_define

begin_define
define|#
directive|define
name|SIR_REJECT_TO_SEND
value|(8)
end_define

begin_define
define|#
directive|define
name|SIR_SWIDE_OVERRUN
value|(9)
end_define

begin_define
define|#
directive|define
name|SIR_SODL_UNDERRUN
value|(10)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_NO_MSG_IN
value|(11)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_NO_IDENTIFY
value|(12)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_BAD_LUN
value|(13)
end_define

begin_define
define|#
directive|define
name|SIR_TARGET_SELECTED
value|(14)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_BAD_I_T_L
value|(15)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_BAD_I_T_L_Q
value|(16)
end_define

begin_define
define|#
directive|define
name|SIR_ABORT_SENT
value|(17)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_ABORTED
value|(18)
end_define

begin_define
define|#
directive|define
name|SIR_MSG_OUT_DONE
value|(19)
end_define

begin_define
define|#
directive|define
name|SIR_COMPLETE_ERROR
value|(20)
end_define

begin_define
define|#
directive|define
name|SIR_MAX
value|(20)
end_define

begin_comment
comment|/*  *  Extended error bit codes.  *  xerr_status field of struct sym_ccb.  */
end_comment

begin_define
define|#
directive|define
name|XE_EXTRA_DATA
value|(1)
end_define

begin_comment
comment|/* unexpected data phase	 */
end_comment

begin_define
define|#
directive|define
name|XE_BAD_PHASE
value|(1<<1)
end_define

begin_comment
comment|/* illegal phase (4/5)		 */
end_comment

begin_define
define|#
directive|define
name|XE_PARITY_ERR
value|(1<<2)
end_define

begin_comment
comment|/* unrecovered SCSI parity error */
end_comment

begin_define
define|#
directive|define
name|XE_SODL_UNRUN
value|(1<<3)
end_define

begin_comment
comment|/* ODD transfer in DATA OUT phase */
end_comment

begin_define
define|#
directive|define
name|XE_SWIDE_OVRUN
value|(1<<4)
end_define

begin_comment
comment|/* ODD transfer in DATA IN phase */
end_comment

begin_comment
comment|/*  *  Negotiation status.  *  nego_status field of struct sym_ccb.  */
end_comment

begin_define
define|#
directive|define
name|NS_SYNC
value|(1)
end_define

begin_define
define|#
directive|define
name|NS_WIDE
value|(2)
end_define

begin_define
define|#
directive|define
name|NS_PPR
value|(3)
end_define

begin_comment
comment|/*  *  A CCB hashed table is used to retrieve CCB address   *  from DSA value.  */
end_comment

begin_define
define|#
directive|define
name|CCB_HASH_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|CCB_HASH_SIZE
value|(1UL<< CCB_HASH_SHIFT)
end_define

begin_define
define|#
directive|define
name|CCB_HASH_MASK
value|(CCB_HASH_SIZE-1)
end_define

begin_define
define|#
directive|define
name|CCB_HASH_CODE
parameter_list|(
name|dsa
parameter_list|)
value|(((dsa)>> 9)& CCB_HASH_MASK)
end_define

begin_comment
comment|/*  *  Device flags.  */
end_comment

begin_define
define|#
directive|define
name|SYM_DISC_ENABLED
value|(1)
end_define

begin_define
define|#
directive|define
name|SYM_TAGS_ENABLED
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|SYM_SCAN_BOOT_DISABLED
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|SYM_SCAN_LUNS_DISABLED
value|(1<<3)
end_define

begin_comment
comment|/*  *  Device quirks.  *  Some devices, for example the CHEETAH 2 LVD, disconnects without   *  saving the DATA POINTER then reconnect and terminates the IO.  *  On reselection, the automatic RESTORE DATA POINTER makes the   *  CURRENT DATA POINTER not point at the end of the IO.  *  This behaviour just breaks our calculation of the residual.  *  For now, we just force an AUTO SAVE on disconnection and will   *  fix that in a further driver version.  */
end_comment

begin_define
define|#
directive|define
name|SYM_QUIRK_AUTOSAVE
value|1
end_define

begin_comment
comment|/*  *  Misc.  */
end_comment

begin_define
define|#
directive|define
name|SYM_SNOOP_TIMEOUT
value|(10000000)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_IO
value|PCIR_MAPS
end_define

begin_define
define|#
directive|define
name|SYM_PCI_MMIO
value|(PCIR_MAPS + 4)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_RAM
value|(PCIR_MAPS + 8)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_RAM64
value|(PCIR_MAPS + 12)
end_define

begin_comment
comment|/*  *  Back-pointer from the CAM CCB to our data structures.  */
end_comment

begin_define
define|#
directive|define
name|sym_hcb_ptr
value|spriv_ptr0
end_define

begin_comment
comment|/* #define sym_ccb_ptr	spriv_ptr1 */
end_comment

begin_comment
comment|/*  *  We mostly have to deal with pointers.  *  Thus these typedef's.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|sym_tcb
modifier|*
name|tcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_lcb
modifier|*
name|lcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_ccb
modifier|*
name|ccb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_hcb
modifier|*
name|hcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_scr
modifier|*
name|script_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_scrh
modifier|*
name|scripth_p
typedef|;
end_typedef

begin_comment
comment|/*  *  Gather negotiable parameters value  */
end_comment

begin_struct
struct|struct
name|sym_trans
block|{
name|u8
name|period
decl_stmt|;
name|u8
name|offset
decl_stmt|;
name|u8
name|width
decl_stmt|;
name|u8
name|options
decl_stmt|;
comment|/* PPR options */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sym_tinfo
block|{
name|struct
name|sym_trans
name|current
decl_stmt|;
name|struct
name|sym_trans
name|goal
decl_stmt|;
name|struct
name|sym_trans
name|user
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BUS_8_BIT
value|MSG_EXT_WDTR_BUS_8_BIT
end_define

begin_define
define|#
directive|define
name|BUS_16_BIT
value|MSG_EXT_WDTR_BUS_16_BIT
end_define

begin_comment
comment|/*  *  Target Control Block  */
end_comment

begin_struct
struct|struct
name|sym_tcb
block|{
comment|/* 	 *  LUN table used by the SCRIPTS processor. 	 *  An array of bus addresses is used on reselection. 	 *  LUN #0 is a special case, since multi-lun devices are rare,  	 *  and we we want to speed-up the general case and not waste  	 *  resources. 	 */
name|u32
modifier|*
name|luntbl
decl_stmt|;
comment|/* LCBs bus address table	*/
name|u32
name|luntbl_sa
decl_stmt|;
comment|/* bus address of this table	*/
name|u32
name|lun0_sa
decl_stmt|;
comment|/* bus address of LCB #0	*/
comment|/* 	 *  LUN table used by the C code. 	 */
name|lcb_p
name|lun0p
decl_stmt|;
comment|/* LCB of LUN #0 (usual case)	*/
if|#
directive|if
name|SYMCONF_MAX_LUN
operator|>
literal|1
name|lcb_p
modifier|*
name|lunmp
decl_stmt|;
comment|/* Other LCBs [1..MAX_LUN]	*/
endif|#
directive|endif
comment|/* 	 *  Bitmap that tells about LUNs that succeeded at least  	 *  1 IO and therefore assumed to be a real device. 	 *  Avoid useless allocation of the LCB structure. 	 */
name|u32
name|lun_map
index|[
operator|(
name|SYMCONF_MAX_LUN
operator|+
literal|31
operator|)
operator|/
literal|32
index|]
decl_stmt|;
comment|/* 	 *  Bitmap that tells about LUNs that haven't yet an LCB  	 *  allocated (not discovered or LCB allocation failed). 	 */
name|u32
name|busy0_map
index|[
operator|(
name|SYMCONF_MAX_LUN
operator|+
literal|31
operator|)
operator|/
literal|32
index|]
decl_stmt|;
comment|/* 	 *  Actual SYNC/WIDE IO registers value for this target. 	 *  'sval', 'wval' and 'uval' are read from SCRIPTS and  	 *  so have alignment constraints. 	 */
comment|/*0*/
name|u_char
name|uval
decl_stmt|;
comment|/* -> SCNTL4 register		*/
comment|/*1*/
name|u_char
name|sval
decl_stmt|;
comment|/* -> SXFER  io register	*/
comment|/*2*/
name|u_char
name|filler1
decl_stmt|;
comment|/*3*/
name|u_char
name|wval
decl_stmt|;
comment|/* -> SCNTL3 io register	*/
comment|/* 	 *  Transfer capabilities (SIP) 	 */
name|struct
name|sym_tinfo
name|tinfo
decl_stmt|;
comment|/* 	 * Keep track of the CCB used for the negotiation in order 	 * to ensure that only 1 negotiation is queued at a time. 	 */
name|ccb_p
name|nego_cp
decl_stmt|;
comment|/* CCB used for the nego		*/
comment|/* 	 *  Set when we want to reset the device. 	 */
name|u_char
name|to_reset
decl_stmt|;
comment|/* 	 *  Other user settable limits and options. 	 *  These limits are read from the NVRAM if present. 	 */
name|u_char
name|usrflags
decl_stmt|;
name|u_short
name|usrtags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Logical Unit Control Block  */
end_comment

begin_struct
struct|struct
name|sym_lcb
block|{
comment|/* 	 *  SCRIPTS address jumped by SCRIPTS on reselection. 	 *  For not probed logical units, this address points to  	 *  SCRIPTS that deal with bad LU handling (must be at  	 *  offset zero for that reason). 	 */
comment|/*0*/
name|u32
name|resel_sa
decl_stmt|;
comment|/* 	 *  Task (bus address of a CCB) read from SCRIPTS that points  	 *  to the unique ITL nexus allowed to be disconnected. 	 */
name|u32
name|itl_task_sa
decl_stmt|;
comment|/* 	 *  Task table read from SCRIPTS that contains pointers to  	 *  ITLQ nexuses (bus addresses read from SCRIPTS). 	 */
name|u32
modifier|*
name|itlq_tbl
decl_stmt|;
comment|/* Kernel virtual address	*/
name|u32
name|itlq_tbl_sa
decl_stmt|;
comment|/* Bus address used by SCRIPTS	*/
comment|/* 	 *  Busy CCBs management. 	 */
name|u_short
name|busy_itlq
decl_stmt|;
comment|/* Number of busy tagged CCBs	*/
name|u_short
name|busy_itl
decl_stmt|;
comment|/* Number of busy untagged CCBs	*/
comment|/* 	 *  Circular tag allocation buffer. 	 */
name|u_short
name|ia_tag
decl_stmt|;
comment|/* Tag allocation index		*/
name|u_short
name|if_tag
decl_stmt|;
comment|/* Tag release index		*/
name|u_char
modifier|*
name|cb_tags
decl_stmt|;
comment|/* Circular tags buffer		*/
comment|/* 	 *  Set when we want to clear all tasks. 	 */
name|u_char
name|to_clear
decl_stmt|;
comment|/* 	 *  Capabilities. 	 */
name|u_char
name|user_flags
decl_stmt|;
name|u_char
name|current_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Action from SCRIPTS on a task.  *  Is part of the CCB, but is also used separately to plug   *  error handling action to perform from SCRIPTS.  */
end_comment

begin_struct
struct|struct
name|sym_actscr
block|{
name|u32
name|start
decl_stmt|;
comment|/* Jumped by SCRIPTS after selection	*/
name|u32
name|restart
decl_stmt|;
comment|/* Jumped by SCRIPTS on relection	*/
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Phase mismatch context.  *  *  It is part of the CCB and is used as parameters for the   *  DATA pointer. We need two contexts to handle correctly the   *  SAVED DATA POINTER.  */
end_comment

begin_struct
struct|struct
name|sym_pmc
block|{
name|struct
name|sym_tblmove
name|sg
decl_stmt|;
comment|/* Updated interrupted SG block	*/
name|u32
name|ret
decl_stmt|;
comment|/* SCRIPT return address	*/
block|}
struct|;
end_struct

begin_comment
comment|/*  *  LUN control block lookup.  *  We use a direct pointer for LUN #0, and a table of   *  pointers which is only allocated for devices that support   *  LUN(s)> 0.  */
end_comment

begin_if
if|#
directive|if
name|SYMCONF_MAX_LUN
operator|<=
literal|1
end_if

begin_define
define|#
directive|define
name|sym_lp
parameter_list|(
name|np
parameter_list|,
name|tp
parameter_list|,
name|lun
parameter_list|)
value|(!lun) ? (tp)->lun0p : 0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sym_lp
parameter_list|(
name|np
parameter_list|,
name|tp
parameter_list|,
name|lun
parameter_list|)
define|\
value|(!lun) ? (tp)->lun0p : (tp)->lunmp ? (tp)->lunmp[(lun)] : 0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Status are used by the host and the script processor.  *  *  The last four bytes (status[4]) are copied to the   *  scratchb register (declared as scr0..scr3) just after the   *  select/reselect, and copied back just after disconnecting.  *  Inside the script the XX_REG are used.  *  *  The first four bytes (scr_st[4]) are used inside the   *  script by "LOAD/STORE" commands.  *  Because source and destination must have the same alignment  *  in a DWORD, the fields HAVE to be at the choosen offsets.  *  	xerr_st		0	(0x34)	scratcha  *  	nego_st		2  */
end_comment

begin_comment
comment|/*  *  Last four bytes (script)  */
end_comment

begin_define
define|#
directive|define
name|QU_REG
value|scr0
end_define

begin_define
define|#
directive|define
name|HS_REG
value|scr1
end_define

begin_define
define|#
directive|define
name|HS_PRT
value|nc_scr1
end_define

begin_define
define|#
directive|define
name|SS_REG
value|scr2
end_define

begin_define
define|#
directive|define
name|SS_PRT
value|nc_scr2
end_define

begin_define
define|#
directive|define
name|HF_REG
value|scr3
end_define

begin_define
define|#
directive|define
name|HF_PRT
value|nc_scr3
end_define

begin_comment
comment|/*  *  Last four bytes (host)  */
end_comment

begin_define
define|#
directive|define
name|actualquirks
value|phys.status[0]
end_define

begin_define
define|#
directive|define
name|host_status
value|phys.status[1]
end_define

begin_define
define|#
directive|define
name|ssss_status
value|phys.status[2]
end_define

begin_define
define|#
directive|define
name|host_flags
value|phys.status[3]
end_define

begin_comment
comment|/*  *  Host flags  */
end_comment

begin_define
define|#
directive|define
name|HF_IN_PM0
value|1u
end_define

begin_define
define|#
directive|define
name|HF_IN_PM1
value|(1u<<1)
end_define

begin_define
define|#
directive|define
name|HF_ACT_PM
value|(1u<<2)
end_define

begin_define
define|#
directive|define
name|HF_DP_SAVED
value|(1u<<3)
end_define

begin_define
define|#
directive|define
name|HF_SENSE
value|(1u<<4)
end_define

begin_define
define|#
directive|define
name|HF_EXT_ERR
value|(1u<<5)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
end_ifdef

begin_define
define|#
directive|define
name|HF_HINT_IARB
value|(1u<<7)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  First four bytes (script)  */
end_comment

begin_define
define|#
directive|define
name|xerr_st
value|scr_st[0]
end_define

begin_define
define|#
directive|define
name|nego_st
value|scr_st[2]
end_define

begin_comment
comment|/*  *  First four bytes (host)  */
end_comment

begin_define
define|#
directive|define
name|xerr_status
value|phys.xerr_st
end_define

begin_define
define|#
directive|define
name|nego_status
value|phys.nego_st
end_define

begin_comment
comment|/*  *  Data Structure Block  *  *  During execution of a ccb by the script processor, the   *  DSA (data structure address) register points to this   *  substructure of the ccb.  */
end_comment

begin_struct
struct|struct
name|dsb
block|{
comment|/* 	 *  Start and restart SCRIPTS addresses (must be at 0). 	 */
comment|/*0*/
name|struct
name|sym_actscr
name|go
decl_stmt|;
comment|/* 	 *  SCRIPTS jump address that deal with data pointers. 	 *  'savep' points to the position in the script responsible  	 *  for the	actual transfer of data. 	 *  It's written on reception of a SAVE_DATA_POINTER message. 	 */
name|u32
name|savep
decl_stmt|;
comment|/* Jump address to saved data pointer	*/
name|u32
name|lastp
decl_stmt|;
comment|/* SCRIPTS address at end of data	*/
name|u32
name|goalp
decl_stmt|;
comment|/* Not used for now			*/
comment|/* 	 *  Status fields. 	 */
name|u8
name|scr_st
index|[
literal|4
index|]
decl_stmt|;
comment|/* script status		*/
name|u8
name|status
index|[
literal|4
index|]
decl_stmt|;
comment|/* host status			*/
comment|/* 	 *  Table data for Script 	 */
name|struct
name|sym_tblsel
name|select
decl_stmt|;
name|struct
name|sym_tblmove
name|smsg
decl_stmt|;
name|struct
name|sym_tblmove
name|smsg_ext
decl_stmt|;
name|struct
name|sym_tblmove
name|cmd
decl_stmt|;
name|struct
name|sym_tblmove
name|sense
decl_stmt|;
name|struct
name|sym_tblmove
name|data
index|[
name|SYMCONF_MAX_SG
index|]
decl_stmt|;
comment|/* 	 *  Phase mismatch contexts. 	 *  We need two to handle correctly the SAVED DATA POINTER. 	 */
name|struct
name|sym_pmc
name|pm0
decl_stmt|;
name|struct
name|sym_pmc
name|pm1
decl_stmt|;
comment|/* 	 *  Extra bytes count transferred in case of data overrun. 	 */
name|u32
name|extra_bytes
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Our Command Control Block  */
end_comment

begin_struct
struct|struct
name|sym_ccb
block|{
comment|/* 	 *  This is the data structure which is pointed by the DSA  	 *  register when it is executed by the script processor. 	 *  It must be the first entry. 	 */
name|struct
name|dsb
name|phys
decl_stmt|;
comment|/* 	 *  Pointer to CAM ccb and related stuff. 	 */
name|union
name|ccb
modifier|*
name|cam_ccb
decl_stmt|;
comment|/* CAM scsiio ccb		*/
name|int
name|data_len
decl_stmt|;
comment|/* Total data length		*/
name|int
name|segments
decl_stmt|;
comment|/* Number of SG segments	*/
comment|/* 	 *  Message areas. 	 *  We prepare a message to be sent after selection. 	 *  We may use a second one if the command is rescheduled  	 *  due to CHECK_CONDITION or COMMAND TERMINATED. 	 *  Contents are IDENTIFY and SIMPLE_TAG. 	 *  While negotiating sync or wide transfer, 	 *  a SDTR or WDTR message is appended. 	 */
name|u_char
name|scsi_smsg
index|[
literal|12
index|]
decl_stmt|;
name|u_char
name|scsi_smsg2
index|[
literal|12
index|]
decl_stmt|;
comment|/* 	 *  Auto request sense related fields. 	 */
name|u_char
name|sensecmd
index|[
literal|6
index|]
decl_stmt|;
comment|/* Request Sense command	*/
name|u_char
name|sv_scsi_status
decl_stmt|;
comment|/* Saved SCSI status 		*/
name|u_char
name|sv_xerr_status
decl_stmt|;
comment|/* Saved extended status	*/
name|int
name|sv_resid
decl_stmt|;
comment|/* Saved residual		*/
comment|/* 	 *  Other fields. 	 */
name|u_long
name|ccb_ba
decl_stmt|;
comment|/* BUS address of this CCB	*/
name|u_short
name|tag
decl_stmt|;
comment|/* Tag for this transfer	*/
comment|/*  NO_TAG means no tag		*/
name|u_char
name|target
decl_stmt|;
name|u_char
name|lun
decl_stmt|;
name|ccb_p
name|link_ccb
decl_stmt|;
comment|/* Host adapter CCB chain	*/
name|ccb_p
name|link_ccbh
decl_stmt|;
comment|/* Host adapter CCB hash chain	*/
name|SYM_QUEHEAD
name|link_ccbq
decl_stmt|;
comment|/* Link to free/busy CCB queue	*/
name|u32
name|startp
decl_stmt|;
comment|/* Initial data pointer		*/
name|int
name|ext_sg
decl_stmt|;
comment|/* Extreme data pointer, used	*/
name|int
name|ext_ofs
decl_stmt|;
comment|/*  to calculate the residual.	*/
name|u_char
name|to_abort
decl_stmt|;
comment|/* Want this IO to be aborted	*/
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CCB_PHYS
parameter_list|(
name|cp
parameter_list|,
name|lbl
parameter_list|)
value|(cp->ccb_ba + offsetof(struct sym_ccb, lbl))
end_define

begin_comment
comment|/*  *  Host Control Block  */
end_comment

begin_struct
struct|struct
name|sym_hcb
block|{
comment|/* 	 *  Idle task and invalid task actions and  	 *  their bus addresses. 	 */
name|struct
name|sym_actscr
name|idletask
decl_stmt|,
name|notask
decl_stmt|,
name|bad_itl
decl_stmt|,
name|bad_itlq
decl_stmt|;
name|vm_offset_t
name|idletask_ba
decl_stmt|,
name|notask_ba
decl_stmt|,
name|bad_itl_ba
decl_stmt|,
name|bad_itlq_ba
decl_stmt|;
comment|/* 	 *  Dummy lun table to protect us against target  	 *  returning bad lun number on reselection. 	 */
name|u32
modifier|*
name|badluntbl
decl_stmt|;
comment|/* Table physical address	*/
name|u32
name|badlun_sa
decl_stmt|;
comment|/* SCRIPT handler BUS address	*/
comment|/* 	 *  Bit 32-63 of the on-chip RAM bus address in LE format. 	 *  The START_RAM64 script loads the MMRS and MMWS from this  	 *  field. 	 */
name|u32
name|scr_ram_seg
decl_stmt|;
comment|/* 	 *  Chip and controller indentification. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|device_t
name|device
decl_stmt|;
else|#
directive|else
name|pcici_t
name|pci_tag
decl_stmt|;
endif|#
directive|endif
name|int
name|unit
decl_stmt|;
name|char
name|inst_name
index|[
literal|8
index|]
decl_stmt|;
comment|/* 	 *  Initial value of some IO register bits. 	 *  These values are assumed to have been set by BIOS, and may  	 *  be used to probe adapter implementation differences. 	 */
name|u_char
name|sv_scntl0
decl_stmt|,
name|sv_scntl3
decl_stmt|,
name|sv_dmode
decl_stmt|,
name|sv_dcntl
decl_stmt|,
name|sv_ctest3
decl_stmt|,
name|sv_ctest4
decl_stmt|,
name|sv_ctest5
decl_stmt|,
name|sv_gpcntl
decl_stmt|,
name|sv_stest2
decl_stmt|,
name|sv_stest4
decl_stmt|,
name|sv_scntl4
decl_stmt|;
comment|/* 	 *  Actual initial value of IO register bits used by the  	 *  driver. They are loaded at initialisation according to   	 *  features that are to be enabled/disabled. 	 */
name|u_char
name|rv_scntl0
decl_stmt|,
name|rv_scntl3
decl_stmt|,
name|rv_dmode
decl_stmt|,
name|rv_dcntl
decl_stmt|,
name|rv_ctest3
decl_stmt|,
name|rv_ctest4
decl_stmt|,
name|rv_ctest5
decl_stmt|,
name|rv_stest2
decl_stmt|,
name|rv_ccntl0
decl_stmt|,
name|rv_ccntl1
decl_stmt|,
name|rv_scntl4
decl_stmt|;
comment|/* 	 *  Target data used by the CPU. 	 */
name|struct
name|sym_tcb
name|target
index|[
name|SYMCONF_MAX_TARGET
index|]
decl_stmt|;
comment|/* 	 *  Target control block bus address array used by the SCRIPT  	 *  on reselection. 	 */
name|u32
modifier|*
name|targtbl
decl_stmt|;
comment|/* 	 *  CAM SIM information for this instance. 	 */
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 *  Allocated hardware resources. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|io_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|mmio_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ram_res
decl_stmt|;
name|int
name|ram_id
decl_stmt|;
name|void
modifier|*
name|intr
decl_stmt|;
endif|#
directive|endif
comment|/* 	 *  Bus stuff. 	 * 	 *  My understanding of PCI is that all agents must share the  	 *  same addressing range and model. 	 *  But some hardware architecture guys provide complex and   	 *  brain-deaded stuff that makes shit. 	 *  This driver only support PCI compliant implementations and  	 *  deals with part of the BUS stuff complexity only to fit O/S  	 *  requirements. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|bus_space_handle_t
name|io_bsh
decl_stmt|;
name|bus_space_tag_t
name|io_tag
decl_stmt|;
name|bus_space_handle_t
name|mmio_bsh
decl_stmt|;
name|bus_space_tag_t
name|mmio_tag
decl_stmt|;
name|bus_space_handle_t
name|ram_bsh
decl_stmt|;
name|bus_space_tag_t
name|ram_tag
decl_stmt|;
endif|#
directive|endif
comment|/* 	 *  Virtual and physical bus addresses of the chip. 	 */
name|vm_offset_t
name|mmio_va
decl_stmt|;
comment|/* MMIO kernel virtual address	*/
name|vm_offset_t
name|mmio_pa
decl_stmt|;
comment|/* MMIO CPU physical address	*/
name|vm_offset_t
name|mmio_ba
decl_stmt|;
comment|/* MMIO BUS address		*/
name|int
name|mmio_ws
decl_stmt|;
comment|/* MMIO Window size		*/
name|vm_offset_t
name|ram_va
decl_stmt|;
comment|/* RAM kernel virtual address	*/
name|vm_offset_t
name|ram_pa
decl_stmt|;
comment|/* RAM CPU physical address	*/
name|vm_offset_t
name|ram_ba
decl_stmt|;
comment|/* RAM BUS address		*/
name|int
name|ram_ws
decl_stmt|;
comment|/* RAM window size		*/
name|u32
name|io_port
decl_stmt|;
comment|/* IO port address		*/
comment|/* 	 *  SCRIPTS virtual and physical bus addresses. 	 *  'script'  is loaded in the on-chip RAM if present. 	 *  'scripth' stays in main memory for all chips except the  	 *  53C895A, 53C896 and 53C1010 that provide 8K on-chip RAM. 	 */
name|struct
name|sym_scr
modifier|*
name|script0
decl_stmt|;
comment|/* Copies of script and scripth	*/
name|struct
name|sym_scrh
modifier|*
name|scripth0
decl_stmt|;
comment|/*  relocated for this host.	*/
name|vm_offset_t
name|script_ba
decl_stmt|;
comment|/* Actual script and scripth	*/
name|vm_offset_t
name|scripth_ba
decl_stmt|;
comment|/*  bus addresses.		*/
name|vm_offset_t
name|scripth0_ba
decl_stmt|;
comment|/* 	 *  General controller parameters and configuration. 	 */
name|u_short
name|device_id
decl_stmt|;
comment|/* PCI device id		*/
name|u_char
name|revision_id
decl_stmt|;
comment|/* PCI device revision id	*/
name|u_int
name|features
decl_stmt|;
comment|/* Chip features map		*/
name|u_char
name|myaddr
decl_stmt|;
comment|/* SCSI id of the adapter	*/
name|u_char
name|maxburst
decl_stmt|;
comment|/* log base 2 of dwords burst	*/
name|u_char
name|maxwide
decl_stmt|;
comment|/* Maximum transfer width	*/
name|u_char
name|minsync
decl_stmt|;
comment|/* Min sync period factor (ST)	*/
name|u_char
name|maxsync
decl_stmt|;
comment|/* Max sync period factor (ST)	*/
name|u_char
name|minsync_dt
decl_stmt|;
comment|/* Min sync period factor (DT)	*/
name|u_char
name|maxsync_dt
decl_stmt|;
comment|/* Max sync period factor (DT)	*/
name|u_char
name|maxoffs
decl_stmt|;
comment|/* Max scsi offset		*/
name|u_char
name|multiplier
decl_stmt|;
comment|/* Clock multiplier (1,2,4)	*/
name|u_char
name|clock_divn
decl_stmt|;
comment|/* Number of clock divisors	*/
name|u_long
name|clock_khz
decl_stmt|;
comment|/* SCSI clock frequency in KHz	*/
comment|/* 	 *  Start queue management. 	 *  It is filled up by the host processor and accessed by the  	 *  SCRIPTS processor in order to start SCSI commands. 	 */
specifier|volatile
comment|/* Prevent code optimizations	*/
name|u32
modifier|*
name|squeue
decl_stmt|;
comment|/* Start queue			*/
name|u_short
name|squeueput
decl_stmt|;
comment|/* Next free slot of the queue	*/
name|u_short
name|actccbs
decl_stmt|;
comment|/* Number of allocated CCBs	*/
comment|/* 	 *  Command completion queue. 	 *  It is the same size as the start queue to avoid overflow. 	 */
name|u_short
name|dqueueget
decl_stmt|;
comment|/* Next position to scan	*/
specifier|volatile
comment|/* Prevent code optimizations	*/
name|u32
modifier|*
name|dqueue
decl_stmt|;
comment|/* Completion (done) queue	*/
comment|/* 	 *  Miscellaneous buffers accessed by the scripts-processor. 	 *  They shall be DWORD aligned, because they may be read or  	 *  written with a script command. 	 */
name|u_char
name|msgout
index|[
literal|8
index|]
decl_stmt|;
comment|/* Buffer for MESSAGE OUT 	*/
name|u_char
name|msgin
index|[
literal|8
index|]
decl_stmt|;
comment|/* Buffer for MESSAGE IN	*/
name|u32
name|lastmsg
decl_stmt|;
comment|/* Last SCSI message sent	*/
name|u_char
name|scratch
decl_stmt|;
comment|/* Scratch for SCSI receive	*/
comment|/* 	 *  Miscellaneous configuration and status parameters. 	 */
name|u_char
name|scsi_mode
decl_stmt|;
comment|/* Current SCSI BUS mode	*/
name|u_char
name|verbose
decl_stmt|;
comment|/* Verbosity for this controller*/
name|u32
name|cache
decl_stmt|;
comment|/* Used for cache test at init.	*/
comment|/* 	 *  CCB lists and queue. 	 */
name|ccb_p
name|ccbh
index|[
name|CCB_HASH_SIZE
index|]
decl_stmt|;
comment|/* CCB hashed by DSA value	*/
name|ccb_p
name|ccbc
decl_stmt|;
comment|/* CCB chain			*/
name|SYM_QUEHEAD
name|free_ccbq
decl_stmt|;
comment|/* Queue of available CCBs	*/
name|SYM_QUEHEAD
name|busy_ccbq
decl_stmt|;
comment|/* Queue of busy CCBs		*/
comment|/* 	 *  During error handling and/or recovery, 	 *  active CCBs that are to be completed with  	 *  error or requeued are moved from the busy_ccbq 	 *  to the comp_ccbq prior to completion. 	 */
name|SYM_QUEHEAD
name|comp_ccbq
decl_stmt|;
comment|/* 	 *  CAM CCB pending queue. 	 */
name|SYM_QUEHEAD
name|cam_ccbq
decl_stmt|;
comment|/* 	 *  IMMEDIATE ARBITRATION (IARB) control. 	 * 	 *  We keep track in 'last_cp' of the last CCB that has been  	 *  queued to the SCRIPTS processor and clear 'last_cp' when  	 *  this CCB completes. If last_cp is not zero at the moment  	 *  we queue a new CCB, we set a flag in 'last_cp' that is  	 *  used by the SCRIPTS as a hint for setting IARB. 	 *  We donnot set more than 'iarb_max' consecutive hints for  	 *  IARB in order to leave devices a chance to reselect. 	 *  By the way, any non zero value of 'iarb_max' is unfair. :) 	 */
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
name|u_short
name|iarb_max
decl_stmt|;
comment|/* Max. # consecutive IARB hints*/
name|u_short
name|iarb_count
decl_stmt|;
comment|/* Actual # of these hints	*/
name|ccb_p
name|last_cp
decl_stmt|;
endif|#
directive|endif
comment|/* 	 *  Command abort handling. 	 *  We need to synchronize tightly with the SCRIPTS  	 *  processor in order to handle things correctly. 	 */
name|u_char
name|abrt_msg
index|[
literal|4
index|]
decl_stmt|;
comment|/* Message to send buffer	*/
name|struct
name|sym_tblmove
name|abrt_tbl
decl_stmt|;
comment|/* Table for the MOV of it 	*/
name|struct
name|sym_tblsel
name|abrt_sel
decl_stmt|;
comment|/* Sync params for selection	*/
name|u_char
name|istat_sem
decl_stmt|;
comment|/* Tells the chip to stop (SEM)	*/
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SCRIPT_BA
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->script_ba   + offsetof(struct sym_scr, lbl))
end_define

begin_define
define|#
directive|define
name|SCRIPTH_BA
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->scripth_ba  + offsetof(struct sym_scrh,lbl))
end_define

begin_define
define|#
directive|define
name|SCRIPTH0_BA
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->scripth0_ba + offsetof(struct sym_scrh,lbl))
end_define

begin_comment
comment|/*  *  Scripts for SYMBIOS-Processor  *  *  Use sym_fill_scripts() to create the variable parts.  *  Use sym_bind_script()  to make a copy and bind to   *  physical bus addresses.  *  We have to know the offsets of all labels before we reach   *  them (for forward jumps). Therefore we declare a struct   *  here. If you make changes inside the script,  *  *  DONT FORGET TO CHANGE THE LENGTHS HERE!  */
end_comment

begin_comment
comment|/*  *  Script fragments which are loaded into the on-chip RAM   *  of 825A, 875, 876, 895, 895A, 896 and 1010 chips.  *  Must not exceed 4K bytes.  */
end_comment

begin_struct
struct|struct
name|sym_scr
block|{
name|u32
name|start
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|getjob_begin
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|getjob_end
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|select
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|wf_sel_done
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|send_ident
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
name|u32
name|select2
index|[
literal|8
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|select2
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|command
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|u32
name|dispatch
index|[
literal|18
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|dispatch
index|[
literal|30
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|sel_no_cmd
index|[
literal|10
index|]
decl_stmt|;
name|u32
name|init
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|clrack
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|disp_msg_in
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|disp_status
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|datai_done
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|datao_done
index|[
literal|10
index|]
decl_stmt|;
name|u32
name|ign_i_w_r_msg
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|dataphase
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|msg_in
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|msg_in2
index|[
literal|10
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
name|u32
name|status
index|[
literal|14
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|status
index|[
literal|10
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|complete
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|complete2
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|complete_error
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|done
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|done_end
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|save_dp
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|restore_dp
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|disconnect
index|[
literal|20
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
name|u32
name|idle
index|[
literal|4
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|idle
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
name|u32
name|ungetjob
index|[
literal|6
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|ungetjob
index|[
literal|4
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|reselect
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|reselected
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|resel_scntl4
index|[
literal|28
index|]
decl_stmt|;
if|#
directive|if
name|SYMCONF_MAX_TASK
operator|*
literal|4
operator|>
literal|512
name|u32
name|resel_tag
index|[
literal|24
index|]
decl_stmt|;
elif|#
directive|elif
name|SYMCONF_MAX_TASK
operator|*
literal|4
operator|>
literal|256
name|u32
name|resel_tag
index|[
literal|18
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|resel_tag
index|[
literal|14
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|resel_dsa
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|resel_dsa1
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|resel_no_tag
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|data_in
index|[
name|SYMCONF_MAX_SG
operator|*
literal|2
index|]
decl_stmt|;
name|u32
name|data_in2
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|data_out
index|[
name|SYMCONF_MAX_SG
operator|*
literal|2
index|]
decl_stmt|;
name|u32
name|data_out2
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|u32
name|pm0_data
index|[
literal|28
index|]
decl_stmt|;
name|u32
name|pm1_data
index|[
literal|28
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|pm0_data
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|pm1_data
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Script fragments which stay in main memory for all chips   *  except for chips that support 8K on-chip RAM.  */
end_comment

begin_struct
struct|struct
name|sym_scrh
block|{
name|u32
name|start64
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|sel_for_abort
index|[
literal|18
index|]
decl_stmt|;
name|u32
name|sel_for_abort_1
index|[
literal|2
index|]
decl_stmt|;
name|u32
name|select_no_atn
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|wf_sel_done_no_atn
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_in_etc
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|msg_received
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_weird_seen
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_extended
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|msg_bad
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|msg_weird
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_weird1
index|[
literal|8
index|]
decl_stmt|;
name|u32
name|wdtr_resp
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|send_wdtr
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|sdtr_resp
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|send_sdtr
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|ppr_resp
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|send_ppr
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|nego_bad_phase
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_out
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|msg_out_done
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|u32
name|no_data
index|[
literal|36
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|no_data
index|[
literal|28
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|abort_resel
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|resend_ident
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|ident_break
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|ident_break_atn
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|u32
name|sdata_in
index|[
literal|12
index|]
decl_stmt|;
else|#
directive|else
name|u32
name|sdata_in
index|[
literal|6
index|]
decl_stmt|;
endif|#
directive|endif
name|u32
name|resel_bad_lun
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|bad_i_t_l
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|bad_i_t_l_q
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|bad_status
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|pm_handle
index|[
literal|20
index|]
decl_stmt|;
name|u32
name|pm_handle1
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pm_save
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|pm0_save
index|[
literal|14
index|]
decl_stmt|;
name|u32
name|pm1_save
index|[
literal|14
index|]
decl_stmt|;
comment|/* SWIDE handling */
name|u32
name|swide_ma_32
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|swide_ma_64
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|swide_scr_64
index|[
literal|26
index|]
decl_stmt|;
name|u32
name|swide_scr_64_1
index|[
literal|12
index|]
decl_stmt|;
name|u32
name|swide_com_64
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|swide_common
index|[
literal|10
index|]
decl_stmt|;
name|u32
name|swide_fin_32
index|[
literal|24
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|u32
name|dt_data_in
index|[
name|SYMCONF_MAX_SG
operator|*
literal|2
index|]
decl_stmt|;
name|u32
name|dt_data_in2
index|[
literal|4
index|]
decl_stmt|;
name|u32
name|dt_data_out
index|[
name|SYMCONF_MAX_SG
operator|*
literal|2
index|]
decl_stmt|;
name|u32
name|dt_data_out2
index|[
literal|4
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* Data area */
name|u32
name|zero
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|scratch
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|scratch1
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|pm0_data_addr
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|pm1_data_addr
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|saved_dsa
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|saved_drs
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|done_pos
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|startpos
index|[
literal|1
index|]
decl_stmt|;
name|u32
name|targtbl
index|[
literal|1
index|]
decl_stmt|;
comment|/* End of data area */
name|u32
name|snooptest
index|[
literal|6
index|]
decl_stmt|;
name|u32
name|snoopend
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sym_fill_scripts
parameter_list|(
name|script_p
name|scr
parameter_list|,
name|scripth_p
name|scrh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_bind_script
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u32
modifier|*
name|src
parameter_list|,
name|u32
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_prepare_setting
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_prepare_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|nego
parameter_list|,
name|u_char
modifier|*
name|msgptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_put_start_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_soft_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_start_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_reset_scsi_bus
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|enab_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_wakeup_done
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_flush_busy_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_flush_comp_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_init
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|reset
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_getsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|sfac
parameter_list|,
name|u_char
modifier|*
name|divp
parameter_list|,
name|u_char
modifier|*
name|fakp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setwide
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setpprot
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_settrans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_log_hard_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|,
name|u_char
name|dstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_recover_scsi_int
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|hsts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_sto
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_udc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_sbmc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_par
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_ma
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_dequeue_from_squeue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_sir_bad_scsi_status
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_clear_tasks
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|targ
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_sir_task_recovery
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_evaluate_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u32
name|scr
parameter_list|,
name|int
modifier|*
name|ofs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_modify_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|ofs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_compute_residual
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_print_msg
parameter_list|(
name|ccb_p
name|cp
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_sync_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_ppr_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_wide_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nego_default
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nego_rejected
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_sir
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_free_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|sym_get_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|,
name|u_char
name|tag_order
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|sym_alloc_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|sym_ccb_from_dsa
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_long
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lcb_p
name|sym_alloc_lcb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_alloc_lcb_tags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_snooptest
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_selectclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|scntl3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_getclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|mult
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_getpciclock
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_complete_ok
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_complete_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_abort_scsiio
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|timed_out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_reset_dev
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_action1
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_setup_cdb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_setup_data
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_scatter_virtual
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_scatter_physical
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_action2
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_update_trans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|struct
name|sym_trans
modifier|*
name|tip
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_update_dflags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|flags
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
end_ifdef

begin_function_decl
specifier|static
name|struct
name|sym_pci_chip
modifier|*
name|sym_find_pci_chip
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|struct
name|sym_pci_chip
modifier|*
name|sym_find_pci_chip
parameter_list|(
name|pcici_t
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|sym_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_pci_attach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_pci_attach2
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sym_pci_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_cam_attach
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_cam_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nvram_setup_host
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nvram_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|targ
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_read_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Return the name of the controller.  */
end_comment

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|sym_name
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
return|return
name|np
operator|->
name|inst_name
return|;
block|}
end_function

begin_comment
comment|/*  *  Scripts for SYMBIOS-Processor  *  *  Use sym_bind_script for binding to physical addresses.  *  *  NADDR generates a reference to a field of the controller data.  *  PADDR generates a reference to another part of the script.  *  RADDR generates a reference to a script processor register.  *  FADDR generates a reference to a script processor register  *        with offset.  *  */
end_comment

begin_define
define|#
directive|define
name|RELOC_SOFTC
value|0x40000000
end_define

begin_define
define|#
directive|define
name|RELOC_LABEL
value|0x50000000
end_define

begin_define
define|#
directive|define
name|RELOC_REGISTER
value|0x60000000
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|RELOC_KVAR
value|0x70000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RELOC_LABELH
value|0x80000000
end_define

begin_define
define|#
directive|define
name|RELOC_MASK
value|0xf0000000
end_define

begin_define
define|#
directive|define
name|NADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_SOFTC  | offsetof(struct sym_hcb, label))
end_define

begin_define
define|#
directive|define
name|PADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_LABEL  | offsetof(struct sym_scr, label))
end_define

begin_define
define|#
directive|define
name|PADDRH
parameter_list|(
name|label
parameter_list|)
value|(RELOC_LABELH | offsetof(struct sym_scrh, label))
end_define

begin_define
define|#
directive|define
name|RADDR
parameter_list|(
name|label
parameter_list|)
value|(RELOC_REGISTER | REG(label))
end_define

begin_define
define|#
directive|define
name|FADDR
parameter_list|(
name|label
parameter_list|,
name|ofs
parameter_list|)
value|(RELOC_REGISTER | ((REG(label))+(ofs)))
end_define

begin_define
define|#
directive|define
name|KVAR
parameter_list|(
name|which
parameter_list|)
value|(RELOC_KVAR | (which))
end_define

begin_define
define|#
directive|define
name|SCR_DATA_ZERO
value|0xf00ff00f
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|RELOC_KVAR
end_ifdef

begin_define
define|#
directive|define
name|SCRIPT_KVAR_JIFFIES
value|(0)
end_define

begin_define
define|#
directive|define
name|SCRIPT_KVAR_FIRST
value|SCRIPT_KVAR_XXXXXXX
end_define

begin_define
define|#
directive|define
name|SCRIPT_KVAR_LAST
value|SCRIPT_KVAR_XXXXXXX
end_define

begin_comment
comment|/*  * Kernel variables referenced in the scripts.  * THESE MUST ALL BE ALIGNED TO A 4-BYTE BOUNDARY.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|script_kvars
index|[]
init|=
block|{
operator|(
name|void
operator|*
operator|)
operator|&
name|xxxxxxx
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|sym_scr
name|script0
init|=
block|{
comment|/*--------------------------< START>-----------------------*/
block|{
comment|/* 	 *  This NOP will be patched with LED ON 	 *  SCR_REG_REG (gpreg, SCR_AND, 0xfe) 	 */
name|SCR_NO_OP
block|,
literal|0
block|,
comment|/* 	 *      Clear SIGP. 	 */
name|SCR_FROM_REG
argument_list|(
name|ctest2
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Stop here if the C code wants to perform  	 *  some error recovery procedure manually. 	 *  (Indicate this by setting SEM in ISTAT) 	 */
name|SCR_FROM_REG
argument_list|(
name|istat
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Report to the C code the next position in  	 *  the start queue the SCRIPTS will schedule. 	 *  The C code must not change SCRATCHA. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|SEM
argument_list|,
name|SEM
argument_list|)
argument_list|)
block|,
name|SIR_SCRIPT_STOPPED
block|,
comment|/* 	 *  Start the next job. 	 * 	 *  @DSA	 = start point for this job. 	 *  SCRATCHA = address of this job in the start queue. 	 * 	 *  We will restore startpos with SCRATCHA if we fails the  	 *  arbitration or if it is the idle job. 	 * 	 *  The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS  	 *  is a critical path. If it is partially executed, it then  	 *  may happen that the job address is not yet in the DSA  	 *  and the the next queue position points to the next JOB. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
literal|4
block|, }
comment|/*-------------------------< GETJOB_BEGIN>------------------*/
block|,
block|{
name|SCR_STORE_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< GETJOB_END>--------------------*/
block|,
block|{
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< SELECT>----------------------*/
block|,
block|{
comment|/* 	 *  DSA	contains the address of a scheduled 	 *  	data structure. 	 * 	 *  SCRATCHA contains the address of the start queue   	 *  	entry which points to the next job. 	 * 	 *  Set Initiator mode. 	 * 	 *  (Target mode is left as an exercise for the reader) 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *      And try to select this target. 	 */
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|ungetjob
argument_list|)
block|,
comment|/* 	 *  Now there are 4 possibilities: 	 * 	 *  (1) The chip looses arbitration. 	 *  This is ok, because it will try again, 	 *  when the bus becomes idle. 	 *  (But beware of the timeout function!) 	 * 	 *  (2) The chip is reselected. 	 *  Then the script processor takes the jump 	 *  to the RESELECT label. 	 * 	 *  (3) The chip wins arbitration. 	 *  Then it will execute SCRIPTS instruction until  	 *  the next instruction that checks SCSI phase. 	 *  Then will stop and wait for selection to be  	 *  complete or selection time-out to occur. 	 * 	 *  After having won arbitration, the SCRIPTS   	 *  processor is able to execute instructions while  	 *  the SCSI core is performing SCSI selection. 	 */
comment|/* 	 *      load the savep (saved data pointer) into 	 *      the actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|savep
argument_list|)
block|,
comment|/* 	 *      Initialize the status registers 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|status
argument_list|)
block|, }
comment|/*-------------------------< WF_SEL_DONE>----------------------*/
block|,
block|{
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|SIR_SEL_ATN_NO_MSG_OUT
block|, }
comment|/*-------------------------< SEND_IDENT>----------------------*/
block|,
block|{
comment|/* 	 *  Selection complete. 	 *  Send the IDENTIFY and possibly the TAG message  	 *  and negotiation message if present. 	 */
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg
argument_list|)
block|, }
comment|/*-------------------------< SELECT2>----------------------*/
block|,
block|{
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 	 *  Set IMMEDIATE ARBITRATION if we have been given  	 *  a hint to do so. (Some job to do after this one). 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_HINT_IARB
argument_list|,
name|HF_HINT_IARB
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|scntl1
argument_list|,
name|SCR_OR
argument_list|,
name|IARB
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  Anticipate the COMMAND phase. 	 *  This is the PHASE we expect at this point. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_COMMAND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|sel_no_cmd
argument_list|)
block|, }
comment|/*-------------------------< COMMAND>--------------------*/
block|,
block|{
comment|/* 	 *  ... and send the command 	 */
name|SCR_MOVE_TBL
operator|^
name|SCR_COMMAND
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|cmd
argument_list|)
block|, }
comment|/*-----------------------< DISPATCH>----------------------*/
block|,
block|{
comment|/* 	 *  MSG_IN is the only phase that shall be  	 *  entered at least once for each (re)selection. 	 *  So we test it first. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dataphase
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dataphase
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_STATUS
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|status
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_COMMAND
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|command
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_out
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DT_DATA_OUT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dataphase
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|IF
argument_list|(
name|SCR_DT_DATA_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dataphase
argument_list|)
block|,
else|#
directive|else
comment|/* 	 *  Set the extended error flag. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_EXT_ERR
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Discard one illegal phase byte, if required. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|xerr_status
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha
argument_list|,
name|SCR_OR
argument_list|,
name|XE_BAD_PHASE
argument_list|)
block|,
literal|0
block|,
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|xerr_status
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_ILG_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_ILG_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_ILG_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
endif|#
directive|endif
comment|/* SYMCONF_BROKEN_U3EN_SUPPORT */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*---------------------< SEL_NO_CMD>----------------------*/
block|,
block|{
comment|/* 	 *  The target does not switch to command  	 *  phase after IDENTIFY has been sent. 	 * 	 *  If it stays in MSG OUT phase send it  	 *  the IDENTIFY again. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|resend_ident
argument_list|)
block|,
comment|/* 	 *  If target does not switch to MSG IN phase  	 *  and we sent a negotiation, assert the  	 *  failure immediately. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|HS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|HS_NEGOTIATE
argument_list|)
argument_list|)
block|,
name|SIR_NEGO_FAILED
block|,
comment|/* 	 *  Jump to dispatcher. 	 */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< INIT>------------------------*/
block|,
block|{
comment|/* 	 *  Wait for the SCSI RESET signal to be  	 *  inactive before restarting operations,  	 *  since the chip may hang on SEL_ATN  	 *  if SCSI RESET is active. 	 */
name|SCR_FROM_REG
argument_list|(
name|sstat0
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|IRST
argument_list|,
name|IRST
argument_list|)
argument_list|)
block|,
operator|-
literal|16
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< CLRACK>----------------------*/
block|,
block|{
comment|/* 	 *  Terminate possible pending message phase. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DISP_MSG_IN>----------------------*/
block|,
block|{
comment|/* 	 *  Anticipate MSG_IN phase then STATUS phase. 	 * 	 *  May spare 2 SCRIPTS instructions when we have  	 *  completed the OUTPUT of the data and the device  	 *  goes directly to STATUS phase. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|, }
comment|/*-------------------------< DISP_STATUS>----------------------*/
block|,
block|{
comment|/* 	 *  Anticipate STATUS phase. 	 * 	 *  Does spare 3 SCRIPTS instructions when we have  	 *  completed the INPUT of the data. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_STATUS
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|status
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DATAI_DONE>-------------------*/
block|,
block|{
comment|/* 	 *  If the SWIDE is not full, jump to dispatcher. 	 *  We anticipate a STATUS phase. 	 *  If we get later an IGNORE WIDE RESIDUE, we  	 *  will alias it as a MODIFY DP (-1). 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|disp_status
argument_list|)
block|,
comment|/* 	 *  The SWIDE is full. 	 *  Clear this condition. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSR
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Since the device is required to send any  	 *  IGNORE WIDE RESIDUE message prior to any 	 *  other information, we just snoop the SCSI  	 *  BUS to check for such a message. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_IGN_RESIDUE
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|disp_msg_in
argument_list|)
block|,
comment|/* 	 *  We have been ODD at the end of the transfer,  	 *  but the device hasn't be so. 	 *  Signal a DATA OVERRUN condition to the C code. 	 */
name|SCR_INT
block|,
name|SIR_SWIDE_OVERRUN
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< DATAO_DONE>-------------------*/
block|,
block|{
comment|/* 	 *  If the SODL is not full jump to dispatcher. 	 *  We anticipate a MSG IN phase or a STATUS phase. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|WSS
argument_list|,
name|WSS
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|disp_status
argument_list|)
block|,
comment|/* 	 *  The SODL is full, clear this condition. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSS
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  And signal a DATA UNDERRUN condition  	 *  to the C code. 	 */
name|SCR_INT
block|,
name|SIR_SODL_UNDERRUN
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< IGN_I_W_R_MSG>--------------*/
block|,
block|{
comment|/* 	 *  We jump here from the phase mismatch interrupt,  	 *  When we have a SWIDE and the device has presented  	 *  a IGNORE WIDE RESIDUE message on the BUS. 	 *  We just have to throw away this message and then  	 *  to jump to dispatcher. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|2
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
comment|/* 	 *  Clear ACK and jump to dispatcher. 	 */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< DATAPHASE>------------------*/
block|,
block|{
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< MSG_IN>--------------------*/
block|,
block|{
comment|/* 	 *  Get the first byte of the message. 	 * 	 *  The script processor doesn't negate the 	 *  ACK signal after this transfer. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|0
index|]
argument_list|)
block|, }
comment|/*-------------------------< MSG_IN2>--------------------*/
block|,
block|{
comment|/* 	 *  Check first against 1 byte messages  	 *  that we handle from SCRIPTS. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_COMPLETE
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|complete
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_DISCONNECT
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|disconnect
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_SAVE_DP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|save_dp
argument_list|)
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_RESTORE_DP
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|restore_dp
argument_list|)
block|,
comment|/* 	 *  We handle all other messages from the  	 *  C code, so no need to waste on-chip RAM  	 *  for those ones. 	 */
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|msg_in_etc
argument_list|)
block|, }
comment|/*-------------------------< STATUS>--------------------*/
block|,
block|{
comment|/* 	 *  get the status 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_STATUS
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 	 *  If STATUS is not GOOD, clear IMMEDIATE ARBITRATION,  	 *  since we may have to tamper the start queue from  	 *  the C code. 	 */
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|S_GOOD
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|scntl1
argument_list|,
name|SCR_AND
argument_list|,
operator|~
name|IARB
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  save status to scsi_status. 	 *  mark as complete. 	 */
name|SCR_TO_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_COMPLETE
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Anticipate the MESSAGE PHASE for  	 *  the TASK COMPLETE message. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|msg_in
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< COMPLETE>-----------------*/
block|,
block|{
comment|/* 	 *  Complete message. 	 * 	 *  Copy the data pointer to LASTP. 	 */
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|lastp
argument_list|)
block|,
comment|/* 	 *  When we terminate the cycle by clearing ACK, 	 *  the target may disconnect immediately. 	 * 	 *  We don't want to be told of an "unexpected disconnect", 	 *  so we disable this feature. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Terminate cycle ... 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  ... and wait for the disconnect. 	 */
name|SCR_WAIT_DISC
block|,
literal|0
block|, }
comment|/*-------------------------< COMPLETE2>-----------------*/
block|,
block|{
comment|/* 	 *  Save host status. 	 */
name|SCR_STORE_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  Some bridges may reorder DMA writes to memory. 	 *  We donnot want the CPU to deal with completions   	 *  without all the posted write having been flushed  	 *  to memory. This DUMMY READ should flush posted  	 *  buffers prior to the CPU having to deal with  	 *  completions. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
comment|/* DUMMY READ */
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  If command resulted in not GOOD status, 	 *  call the C code if needed. 	 */
name|SCR_FROM_REG
argument_list|(
name|SS_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_CALL
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|S_GOOD
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|bad_status
argument_list|)
block|,
comment|/* 	 *  If we performed an auto-sense, call  	 *  the C code to synchronyze task aborts  	 *  with UNIT ATTENTION conditions. 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
operator|(
name|HF_SENSE
operator||
name|HF_EXT_ERR
operator|)
argument_list|)
argument_list|)
block|,
literal|16
block|, }
comment|/*-------------------------< COMPLETE_ERROR>-----------------*/
block|,
block|{
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_INT
block|,
name|SIR_COMPLETE_ERROR
block|, }
comment|/*------------------------< DONE>-----------------*/
block|,
block|{
comment|/* 	 *  Copy the DSA to the DONE QUEUE and  	 *  signal completion to the host. 	 *  If we are interrupted between DONE  	 *  and DONE_END, we must reset, otherwise  	 *  the completed CCB may be lost. 	 */
name|SCR_STORE_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|saved_dsa
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|done_pos
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|saved_dsa
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  The instruction below reads the DONE QUEUE next  	 *  free position from memory. 	 *  In addition it ensures that all PCI posted writes   	 *  are flushed and so the DSA value of the done  	 *  CCB is visible by the CPU before INTFLY is raised. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
literal|4
block|,
name|SCR_INT_FLY
block|,
literal|0
block|,
name|SCR_STORE_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|done_pos
argument_list|)
block|, }
comment|/*------------------------< DONE_END>-----------------*/
block|,
block|{
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< SAVE_DP>------------------*/
block|,
block|{
comment|/* 	 *  Clear ACK immediately. 	 *  No need to delay it. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Keep track we received a SAVE DP, so  	 *  we will switch to the other PM context  	 *  on the next PM since the DP may point  	 *  to the current PM context. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_DP_SAVED
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  SAVE_DP message: 	 *  Copy the data pointer to SAVEP. 	 */
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< RESTORE_DP>---------------*/
block|,
block|{
comment|/* 	 *  RESTORE_DP message: 	 *  Copy SAVEP to actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< DISCONNECT>---------------*/
block|,
block|{
comment|/* 	 *  DISCONNECTing  ... 	 * 	 *  disable the "unexpected disconnect" feature, 	 *  and remove the ACK signal. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Wait for the disconnect. 	 */
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	 *  Status is: DISCONNECTED. 	 */
name|SCR_LOAD_REG
argument_list|(
name|HS_REG
argument_list|,
name|HS_DISCONNECT
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Save host status. 	 */
name|SCR_STORE_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  If QUIRK_AUTOSAVE is set, 	 *  do an "save pointer" operation. 	 */
name|SCR_FROM_REG
argument_list|(
name|QU_REG
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|SYM_QUIRK_AUTOSAVE
argument_list|,
name|SYM_QUIRK_AUTOSAVE
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|,
comment|/* 	 *  like SAVE_DP message: 	 *  Remember we saved the data pointer. 	 *  Copy data pointer to SAVEP. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_DP_SAVED
argument_list|)
block|,
literal|0
block|,
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|savep
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< IDLE>------------------------*/
block|,
block|{
comment|/* 	 *  Nothing to do? 	 *  Wait for reselect. 	 *  This NOP will be patched with LED OFF 	 *  SCR_REG_REG (gpreg, SCR_OR, 0x01) 	 */
name|SCR_NO_OP
block|,
literal|0
block|,
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
name|SCR_JUMPR
block|,
literal|8
block|,
endif|#
directive|endif
block|}
comment|/*-------------------------< UNGETJOB>-----------------*/
block|,
block|{
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 	 *  Set IMMEDIATE ARBITRATION, for the next time. 	 *  This will give us better chance to win arbitration  	 *  for the job we just wanted to do. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl1
argument_list|,
name|SCR_OR
argument_list|,
name|IARB
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  We are not able to restart the SCRIPTS if we are  	 *  interrupted and these instruction haven't been  	 *  all executed. BTW, this is very unlikely to  	 *  happen, but we check that from the C code. 	 */
name|SCR_LOAD_REG
argument_list|(
name|dsa
argument_list|,
literal|0xff
argument_list|)
block|,
literal|0
block|,
name|SCR_STORE_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|startpos
argument_list|)
block|, }
comment|/*-------------------------< RESELECT>--------------------*/
block|,
block|{
comment|/* 	 *  Make sure we are in initiator mode. 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Sleep waiting for a reselection. 	 */
name|SCR_WAIT_RESEL
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< RESELECTED>------------------*/
block|,
block|{
comment|/* 	 *  This NOP will be patched with LED ON 	 *  SCR_REG_REG (gpreg, SCR_AND, 0xfe) 	 */
name|SCR_NO_OP
block|,
literal|0
block|,
comment|/* 	 *  load the target id into the sdid 	 */
name|SCR_REG_SFBR
argument_list|(
name|ssid
argument_list|,
name|SCR_AND
argument_list|,
literal|0x8F
argument_list|)
block|,
literal|0
block|,
name|SCR_TO_REG
argument_list|(
name|sdid
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Load the target control block address 	 */
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|targtbl
argument_list|)
block|,
name|SCR_SFBR_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_AND
argument_list|,
literal|0x3c
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Load the legacy synchronous transfer registers. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scntl3
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|wval
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|sxfer
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|sval
argument_list|)
block|, }
comment|/*-------------------------< RESEL_SCNTL4>------------------*/
block|,
block|{
comment|/* 	 *  If C1010, patched with the load of SCNTL4 that 	 *  allows a new synchronous timing scheme. 	 * 	 *	SCR_LOAD_REL (scntl4, 1), 	 * 		offsetof(struct tcb, uval), 	 */
name|SCR_NO_OP
block|,
literal|0
block|,
comment|/* 	 *  If MESSAGE IN phase as expected, 	 *  Read the data directly from the BUS DATA lines. 	 *  This helps to support very old SCSI devices that  	 *  may reselect without sending an IDENTIFY. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|SIR_RESEL_NO_MSG_IN
block|,
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  If message phase but not an IDENTIFY, 	 *  get some help from the C code. 	 *  Old SCSI device may behave so. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0x80
argument_list|,
literal|0x80
argument_list|)
argument_list|)
block|,
name|SIR_RESEL_NO_IDENTIFY
block|,
comment|/* 	 *  It is an IDENTIFY message, 	 *  Load the LUN control block address. 	 *  If LUN 0, avoid a PCI BUS ownership by loading  	 *  directly 'lun0_sa' from the TCB. 	 */
name|SCR_JUMPR
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0x0
argument_list|,
literal|0x3f
argument_list|)
argument_list|)
block|,
literal|48
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|luntbl_sa
argument_list|)
block|,
name|SCR_SFBR_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfc
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
block|,
literal|8
block|,
comment|/* 	 *  LUN 0 special case (but usual one :)) 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|lun0_sa
argument_list|)
block|,
comment|/* 	 *  Jump indirectly to the reselect action for this LUN. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_lcb
argument_list|,
name|resel_sa
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* In normal situations, we jump to RESEL_TAG or RESEL_NO_TAG */
block|}
comment|/*-------------------------< RESEL_TAG>-------------------*/
block|,
block|{
comment|/* 	 *  It shall be a tagged command. 	 *  Read IDENTIFY+SIMPLE+TAG. 	 *  The C code will deal with errors. 	 *  Agressive optimization, is'nt it? :) 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|3
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
comment|/* 	 *  Load the pointer to the tagged task  	 *  table for this LUN. 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_lcb
argument_list|,
name|itlq_tbl_sa
argument_list|)
block|,
comment|/* 	 *  The SIDL still contains the TAG value. 	 *  Agressive optimization, isn't it? :):) 	 */
name|SCR_REG_SFBR
argument_list|(
name|sidl
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
if|#
directive|if
name|SYMCONF_MAX_TASK
operator|*
literal|4
operator|>
literal|512
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|dsa1
argument_list|,
name|SCR_OR
argument_list|,
literal|2
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_SHL
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|dsa1
argument_list|,
name|SCR_OR
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
elif|#
directive|elif
name|SYMCONF_MAX_TASK
operator|*
literal|4
operator|>
literal|256
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|CARRYSET
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|dsa1
argument_list|,
name|SCR_OR
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
endif|#
directive|endif
comment|/* 	 *  Retrieve the DSA of this task. 	 *  JUMP indirectly to the restart point of the CCB. 	 */
name|SCR_SFBR_REG
argument_list|(
name|dsa
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfc
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|go
operator|.
name|restart
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* In normal situations we branch to RESEL_DSA */
block|}
comment|/*-------------------------< RESEL_DSA>-------------------*/
block|,
block|{
comment|/* 	 *  ACK the IDENTIFY or TAG previously received. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< RESEL_DSA1>------------------*/
block|,
block|{
comment|/* 	 *      load the savep (saved pointer) into 	 *      the actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|savep
argument_list|)
block|,
comment|/* 	 *      Initialize the status registers 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|status
argument_list|)
block|,
comment|/* 	 *  Jump to dispatcher. 	 */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< RESEL_NO_TAG>-------------------*/
block|,
block|{
comment|/* 	 *  Throw away the IDENTIFY. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
argument_list|)
block|,
comment|/* 	 *  Load the DSA with the unique ITL task. 	 */
name|SCR_LOAD_REL
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_lcb
argument_list|,
name|itl_task_sa
argument_list|)
block|,
comment|/* 	 *  JUMP indirectly to the restart point of the CCB. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|go
operator|.
name|restart
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|,
comment|/* In normal situations we branch to RESEL_DSA */
block|}
comment|/*-------------------------< DATA_IN>--------------------*/
block|,
block|{
comment|/*  *  Because the size depends on the  *  #define SYMCONF_MAX_SG parameter,  *  it is filled in at runtime.  *  *  ##===========< i=0; i<SYMCONF_MAX_SG>=========  *  ||	SCR_CHMOV_TBL ^ SCR_DATA_IN,  *  ||		offsetof (struct dsb, data[ i]),  *  ##==========================================  */
literal|0
block|}
comment|/*-------------------------< DATA_IN2>-------------------*/
block|,
block|{
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|datai_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|no_data
argument_list|)
block|, }
comment|/*-------------------------< DATA_OUT>--------------------*/
block|,
block|{
comment|/*  *  Because the size depends on the  *  #define SYMCONF_MAX_SG parameter,  *  it is filled in at runtime.  *  *  ##===========< i=0; i<SYMCONF_MAX_SG>=========  *  ||	SCR_CHMOV_TBL ^ SCR_DATA_OUT,  *  ||		offsetof (struct dsb, data[ i]),  *  ##==========================================  */
literal|0
block|}
comment|/*-------------------------< DATA_OUT2>-------------------*/
block|,
block|{
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|datao_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|no_data
argument_list|)
block|, }
comment|/*-------------------------< PM0_DATA>--------------------*/
block|,
block|{
comment|/* 	 *  Keep track we are executing the PM0 DATA  	 *  mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_IN_PM0
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  MOVE the data according to the actual  	 *  DATA direction. 	 */
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|56
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|32
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DT_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DT_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|8
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DT_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
else|#
directive|else
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|8
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
argument_list|)
block|,
endif|#
directive|endif
comment|/* 	 *  Clear the flag that told we were in  	 *  the PM0 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_AND
argument_list|,
operator|(
operator|~
name|HF_IN_PM0
operator|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Return to the previous DATA script which  	 *  is guaranteed by design (if no bug) to be  	 *  the main DATA script for this transfer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*-------------------------< PM1_DATA>--------------------*/
block|,
block|{
comment|/* 	 *  Keep track we are executing the PM1 DATA  	 *  mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_IN_PM1
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  MOVE the data according to the actual  	 *  DATA direction. 	 */
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|56
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|32
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DT_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DT_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|8
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DT_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
else|#
directive|else
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|8
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
argument_list|)
block|,
endif|#
directive|endif
comment|/* 	 *  Clear the flag that told we were in  	 *  the PM1 DATA mini-script. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_AND
argument_list|,
operator|(
operator|~
name|HF_IN_PM1
operator|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Return to the previous DATA script which  	 *  is guaranteed by design (if no bug) to be  	 *  the main DATA script for this transfer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*---------------------------------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sym_scrh
name|scripth0
init|=
block|{
comment|/*------------------------< START64>-----------------------*/
block|{
comment|/* 	 *  SCRIPT entry point for the 895A, 896 and 1010. 	 *  For now, there is no specific stuff for those  	 *  chips at this point, but this may come. 	 */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|init
argument_list|)
block|, }
comment|/*-----------------------< SEL_FOR_ABORT>------------------*/
block|,
block|{
comment|/* 	 *  We are jumped here by the C code, if we have  	 *  some target to reset or some disconnected  	 *  job to abort. Since error recovery is a serious  	 *  busyness, we will really reset the SCSI BUS, if  	 *  case of a SCSI interrupt occuring in this path. 	 */
comment|/* 	 *  Set initiator mode. 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *      And try to select this target. 	 */
name|SCR_SEL_TBL_ATN
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|abrt_sel
argument_list|)
block|,
name|PADDR
argument_list|(
name|reselect
argument_list|)
block|,
comment|/* 	 *  Wait for the selection to complete or  	 *  the selection to time out. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
operator|-
literal|8
block|,
comment|/* 	 *  Call the C code. 	 */
name|SCR_INT
block|,
name|SIR_TARGET_SELECTED
block|,
comment|/* 	 *  The C code should let us continue here.  	 *  Send the 'kiss of death' message. 	 *  We expect an immediate disconnect once  	 *  the target has eaten the message. 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_OUT
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|abrt_tbl
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
comment|/* 	 *  Tell the C code that we are done. 	 */
name|SCR_INT
block|,
name|SIR_ABORT_SENT
block|, }
comment|/*-----------------------< SEL_FOR_ABORT_1>--------------*/
block|,
block|{
comment|/* 	 *  Jump at scheduler. 	 */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|,  }
comment|/*------------------------< SELECT_NO_ATN>-----------------*/
block|,
block|{
comment|/* 	 *  Set Initiator mode. 	 *  And try to select this target without ATN. 	 */
name|SCR_CLR
argument_list|(
name|SCR_TRG
argument_list|)
block|,
literal|0
block|,
name|SCR_SEL_TBL
operator|^
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|select
argument_list|)
block|,
name|PADDR
argument_list|(
name|ungetjob
argument_list|)
block|,
comment|/* 	 *  load the savep (saved pointer) into 	 *  the actual data pointer. 	 */
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|savep
argument_list|)
block|,
comment|/* 	 *  Initialize the status registers 	 */
name|SCR_LOAD_REL
argument_list|(
name|scr0
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|status
argument_list|)
block|, }
comment|/*------------------------< WF_SEL_DONE_NO_ATN>-----------------*/
block|,
block|{
comment|/* 	 *  Wait immediately for the next phase or  	 *  the selection to complete or time-out. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|select2
argument_list|)
block|, }
comment|/*-------------------------< MSG_IN_ETC>--------------------*/
block|,
block|{
comment|/* 	 *  If it is an EXTENDED (variable size message) 	 *  Handle it. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
name|M_EXTENDED
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_extended
argument_list|)
block|,
comment|/* 	 *  Let the C code handle any other  	 *  1 byte message. 	 */
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0x00
argument_list|,
literal|0xf0
argument_list|)
argument_list|)
block|,
name|SIR_MSG_RECEIVED
block|,
name|SCR_INT
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0x10
argument_list|,
literal|0xf0
argument_list|)
argument_list|)
block|,
name|SIR_MSG_RECEIVED
block|,
comment|/* 	 *  We donnot handle 2 bytes messages from SCRIPTS. 	 *  So, let the C code deal with these ones too. 	 */
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
literal|0x20
argument_list|,
literal|0xf0
argument_list|)
argument_list|)
block|,
name|SIR_MSG_WEIRD
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
name|SCR_INT
block|,
name|SIR_MSG_RECEIVED
block|,  }
comment|/*-------------------------< MSG_RECEIVED>--------------------*/
block|,
block|{
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
comment|/* DUMMY READ */
literal|0
block|,
name|SCR_INT
block|,
name|SIR_MSG_RECEIVED
block|,  }
comment|/*-------------------------< MSG_WEIRD_SEEN>------------------*/
block|,
block|{
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
comment|/* DUMMY READ */
literal|0
block|,
name|SCR_INT
block|,
name|SIR_MSG_WEIRD
block|,  }
comment|/*-------------------------< MSG_EXTENDED>--------------------*/
block|,
block|{
comment|/* 	 *  Clear ACK and get the next byte  	 *  assumed to be the message length. 	 */
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|msgin
index|[
literal|1
index|]
argument_list|)
block|,
comment|/* 	 *  Try to catch some unlikely situations as 0 length  	 *  or too large the length. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_weird_seen
argument_list|)
block|,
name|SCR_TO_REG
argument_list|(
name|scratcha
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_ADD
argument_list|,
operator|(
literal|256
operator|-
literal|8
operator|)
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|CARRYSET
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_weird_seen
argument_list|)
block|,
comment|/* 	 *  We donnot handle extended messages from SCRIPTS. 	 *  Read the amount of data correponding to the  	 *  message length and call the C code. 	 */
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg_ext
operator|.
name|size
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_TBL
operator|^
name|SCR_MSG_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|smsg_ext
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|msg_received
argument_list|)
block|,  }
comment|/*-------------------------< MSG_BAD>------------------*/
block|,
block|{
comment|/* 	 *  unimplemented message - reject it. 	 */
name|SCR_INT
block|,
name|SIR_REJECT_TO_SEND
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|clrack
argument_list|)
block|, }
comment|/*-------------------------< MSG_WEIRD>--------------------*/
block|,
block|{
comment|/* 	 *  weird message received 	 *  ignore all MSG IN phases and reject it. 	 */
name|SCR_INT
block|,
name|SIR_REJECT_TO_SEND
block|,
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< MSG_WEIRD1>--------------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|msg_weird1
argument_list|)
block|, }
comment|/*-------------------------< WDTR_RESP>----------------*/
block|,
block|{
comment|/* 	 *  let the target fetch our answer. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|nego_bad_phase
argument_list|)
block|, }
comment|/*-------------------------< SEND_WDTR>----------------*/
block|,
block|{
comment|/* 	 *  Send the M_X_WIDE_REQ 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|4
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|msg_out_done
argument_list|)
block|, }
comment|/*-------------------------< SDTR_RESP>-------------*/
block|,
block|{
comment|/* 	 *  let the target fetch our answer. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|nego_bad_phase
argument_list|)
block|, }
comment|/*-------------------------< SEND_SDTR>-------------*/
block|,
block|{
comment|/* 	 *  Send the M_X_SYNC_REQ 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|5
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|msg_out_done
argument_list|)
block|, }
comment|/*-------------------------< PPR_RESP>-------------*/
block|,
block|{
comment|/* 	 *  let the target fetch our answer. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|nego_bad_phase
argument_list|)
block|, }
comment|/*-------------------------< SEND_PPR>-------------*/
block|,
block|{
comment|/* 	 *  Send the M_X_PPR_REQ 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|8
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|msg_out_done
argument_list|)
block|, }
comment|/*-------------------------< NEGO_BAD_PHASE>------------*/
block|,
block|{
name|SCR_INT
block|,
name|SIR_NEGO_PROTO
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT>-------------------*/
block|,
block|{
comment|/* 	 *  The target requests a message. 	 *  We donnot send messages that may  	 *  require the device to go to bus free. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
comment|/* 	 *  ... wait for the next phase 	 *  if it's a message out, send it again, ... 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_OUT
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|msg_out
argument_list|)
block|, }
comment|/*-------------------------< MSG_OUT_DONE>--------------*/
block|,
block|{
comment|/* 	 *  Let the C code be aware of the  	 *  sent message and clear the message. 	 */
name|SCR_INT
block|,
name|SIR_MSG_OUT_DONE
block|,
comment|/* 	 *  ... and process the next phase 	 */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,  }
comment|/*-------------------------< NO_DATA>--------------------*/
block|,
block|{
comment|/* 	 *  The target wants to tranfer too much data 	 *  or in the wrong direction. 	 *  Discard one data byte, if required. 	 *  Count all discarded bytes. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DATA_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_DT_DATA_OUT
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DT_DATA_OUT
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|IF
argument_list|(
name|SCR_DT_DATA_IN
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_DT_DATA_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
endif|#
directive|endif
comment|/* 	 *  Set the extended error flag. 	 */
name|SCR_REG_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_OR
argument_list|,
name|HF_EXT_ERR
argument_list|)
block|,
literal|0
block|,
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|1
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|xerr_status
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha
argument_list|,
name|SCR_OR
argument_list|,
name|XE_EXTRA_DATA
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Count this byte. 	 *  This will allow to return a positive  	 *  residual to user. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|extra_bytes
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha
argument_list|,
name|SCR_ADD
argument_list|,
literal|0x01
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|scratcha2
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_STORE_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|extra_bytes
argument_list|)
block|,
comment|/* 	 *  .. and repeat as required. 	 */
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|no_data
argument_list|)
block|,  }
comment|/*-------------------------< ABORT_RESEL>----------------*/
block|,
block|{
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  send the abort/abortag/reset message 	 *  we expect an immediate disconnect 	 */
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_AND
argument_list|,
literal|0x7f
argument_list|)
block|,
literal|0
block|,
name|SCR_MOVE_ABS
argument_list|(
literal|1
argument_list|)
operator|^
name|SCR_MSG_OUT
block|,
name|NADDR
argument_list|(
name|msgout
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
operator||
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_WAIT_DISC
block|,
literal|0
block|,
name|SCR_INT
block|,
name|SIR_RESEL_ABORTED
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|start
argument_list|)
block|, }
comment|/*-------------------------< RESEND_IDENT>-------------------*/
block|,
block|{
comment|/* 	 *  The target stays in MSG OUT phase after having acked  	 *  Identify [+ Tag [+ Extended message ]]. Targets shall 	 *  behave this way on parity error. 	 *  We must send it again all the messages. 	 */
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
comment|/* Shall be asserted 2 deskew delays before the  */
literal|0
block|,
comment|/* 1rst ACK = 90 ns. Hope the chip isn't too fast */
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|send_ident
argument_list|)
block|, }
comment|/*-------------------------< IDENT_BREAK>-------------------*/
block|,
block|{
name|SCR_CLR
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|select2
argument_list|)
block|, }
comment|/*-------------------------< IDENT_BREAK_ATN>----------------*/
block|,
block|{
name|SCR_SET
argument_list|(
name|SCR_ATN
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|select2
argument_list|)
block|, }
comment|/*-------------------------< SDATA_IN>-------------------*/
block|,
block|{
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_DATA_IN
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|sense
argument_list|)
block|,
name|SCR_JUMPR
block|,
literal|8
block|,
name|SCR_CHMOV_TBL
operator|^
name|SCR_DT_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|sense
argument_list|)
block|,
else|#
directive|else
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
block|,
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|sense
argument_list|)
block|,
endif|#
directive|endif
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|no_data
argument_list|)
block|,  }
comment|/*-------------------------< RESEL_BAD_LUN>---------------*/
block|,
block|{
comment|/* 	 *  Message is an IDENTIFY, but lun is unknown. 	 *  Signal problem to C code for logging the event. 	 *  Send a M_ABORT to clear all pending tasks. 	 */
name|SCR_INT
block|,
name|SIR_RESEL_BAD_LUN
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|abort_resel
argument_list|)
block|, }
comment|/*-------------------------< BAD_I_T_L>------------------*/
block|,
block|{
comment|/* 	 *  We donnot have a task for that I_T_L. 	 *  Signal problem to C code for logging the event. 	 *  Send a M_ABORT message. 	 */
name|SCR_INT
block|,
name|SIR_RESEL_BAD_I_T_L
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|abort_resel
argument_list|)
block|, }
comment|/*-------------------------< BAD_I_T_L_Q>----------------*/
block|,
block|{
comment|/* 	 *  We donnot have a task that matches the tag. 	 *  Signal problem to C code for logging the event. 	 *  Send a M_ABORTTAG message. 	 */
name|SCR_INT
block|,
name|SIR_RESEL_BAD_I_T_L_Q
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|abort_resel
argument_list|)
block|, }
comment|/*-------------------------< BAD_STATUS>-----------------*/
block|,
block|{
comment|/* 	 *  Anything different from INTERMEDIATE  	 *  CONDITION MET should be a bad SCSI status,  	 *  given that GOOD status has already been tested. 	 *  Call the C code. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|startpos
argument_list|)
block|,
name|SCR_INT
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|S_COND_MET
argument_list|)
argument_list|)
block|,
name|SIR_BAD_SCSI_STATUS
block|,
name|SCR_RETURN
block|,
literal|0
block|,  }
comment|/*-------------------------< PM_HANDLE>------------------*/
block|,
block|{
comment|/* 	 *  Phase mismatch handling. 	 * 	 *  Since we have to deal with 2 SCSI data pointers   	 *  (current and saved), we need at least 2 contexts. 	 *  Each context (pm0 and pm1) has a saved area, a  	 *  SAVE mini-script and a DATA phase mini-script. 	 */
comment|/* 	 *  Get the PM handling flags. 	 */
name|SCR_FROM_REG
argument_list|(
name|HF_REG
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  If no flags (1rst PM for example), avoid  	 *  all the below heavy flags testing. 	 *  This makes the normal case a bit faster. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|pm_handle1
argument_list|)
block|,
comment|/* 	 *  If we received a SAVE DP, switch to the  	 *  other PM context since the savep may point  	 *  to the current PM context. 	 */
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_DP_SAVED
argument_list|,
name|HF_DP_SAVED
argument_list|)
argument_list|)
block|,
literal|8
block|,
name|SCR_REG_REG
argument_list|(
name|sfbr
argument_list|,
name|SCR_XOR
argument_list|,
name|HF_ACT_PM
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  If we have been interrupt in a PM DATA mini-script, 	 *  we take the return address from the corresponding  	 *  saved area. 	 *  This ensure the return address always points to the  	 *  main DATA script for this transfer. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
literal|0
argument_list|,
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator|)
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|pm_handle1
argument_list|)
block|,
name|SCR_JUMPR
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|HF_IN_PM0
argument_list|,
name|HF_IN_PM0
argument_list|)
argument_list|)
block|,
literal|16
block|,
name|SCR_LOAD_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|pm_save
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|pm_save
argument_list|)
block|, }
comment|/*-------------------------< PM_HANDLE1>-----------------*/
block|,
block|{
comment|/* 	 *  Normal case. 	 *  Update the return address so that it  	 *  will point after the interrupted MOVE. 	 */
name|SCR_REG_REG
argument_list|(
name|ia
argument_list|,
name|SCR_ADD
argument_list|,
literal|8
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ia1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|, }
comment|/*-------------------------< PM_SAVE>--------------------*/
block|,
block|{
comment|/* 	 *  Clear all the flags that told us if we were  	 *  interrupted in a PM DATA mini-script and/or  	 *  we received a SAVE DP. 	 */
name|SCR_SFBR_REG
argument_list|(
name|HF_REG
argument_list|,
name|SCR_AND
argument_list|,
operator|(
operator|~
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
operator|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Choose the current PM context. 	 */
name|SCR_JUMP
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|HF_ACT_PM
argument_list|,
name|HF_ACT_PM
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|pm1_save
argument_list|)
block|, }
comment|/*-------------------------< PM0_SAVE>-------------------*/
block|,
block|{
name|SCR_STORE_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
block|,
comment|/* 	 *  If WSR bit is set, either UA and RBC may  	 *  have to be changed whether the device wants  	 *  to ignore this residue ot not. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_CALL
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|swide_scr_64
argument_list|)
block|,
comment|/* 	 *  Save the remaining byte count, the updated  	 *  address and the return address. 	 */
name|SCR_STORE_REL
argument_list|(
name|rbc
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
operator|.
name|size
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm0
operator|.
name|sg
operator|.
name|addr
argument_list|)
block|,
comment|/* 	 *  Set the current pointer at the PM0 DATA mini-script. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|pm0_data_addr
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*-------------------------< PM1_SAVE>-------------------*/
block|,
block|{
name|SCR_STORE_REL
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
block|,
comment|/* 	 *  If WSR bit is set, either UA and RBC may  	 *  have been changed whether the device wants  	 *  to ignore this residue or not. 	 */
name|SCR_FROM_REG
argument_list|(
name|scntl2
argument_list|)
block|,
literal|0
block|,
name|SCR_CALL
operator|^
name|IFTRUE
argument_list|(
name|MASK
argument_list|(
name|WSR
argument_list|,
name|WSR
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|swide_scr_64
argument_list|)
block|,
comment|/* 	 *  Save the remaining byte count, the updated  	 *  address and the return address. 	 */
name|SCR_STORE_REL
argument_list|(
name|rbc
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
operator|.
name|size
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_ccb
argument_list|,
name|phys
operator|.
name|pm1
operator|.
name|sg
operator|.
name|addr
argument_list|)
block|,
comment|/* 	 *  Set the current pointer at the PM1 DATA mini-script. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|pm1_data_addr
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|, }
comment|/*--------------------------< SWIDE_MA_32>-----------------------*/
block|,
block|{
comment|/* 	 *  Handling of the SWIDE for 32 bit chips. 	 * 	 *  We jump here from the C code with SCRATCHA  	 *  containing the address to write the SWIDE. 	 *  - Save 32 bit address in<scratch>. 	 */
name|SCR_STORE_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|swide_common
argument_list|)
block|, }
comment|/*--------------------------< SWIDE_MA_64>-----------------------*/
block|,
block|{
comment|/* 	 *  Handling of the SWIDE for 64 bit chips when the  	 *  hardware handling of phase mismatch is disabled. 	 * 	 *  We jump here from the C code with SCRATCHA  	 *  containing the address to write the SWIDE and  	 *  SBR containing bit 32..39 of this address. 	 *  - Save 32 bit address in<scratch>. 	 *  - Move address bit 32..39 to SFBR. 	 */
name|SCR_STORE_ABS
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|sbr
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|swide_com_64
argument_list|)
block|, }
comment|/*--------------------------< SWIDE_SCR_64>-----------------------*/
block|,
block|{
comment|/* 	 *  Handling of the SWIDE for 64 bit chips when  	 *  hardware phase mismatch is enabled. 	 *  We are entered with a SCR_CALL from PMO_SAVE  	 *  and PM1_SAVE sub-scripts. 	 * 	 *  Snoop the SCSI BUS in case of the device  	 *  willing to ignore this residue. 	 *  If it does, we must only increment the RBC,  	 *  since this register does reflect all bytes  	 *  received from the SCSI BUS including the SWIDE. 	 */
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|WHEN
argument_list|(
name|SCR_MSG_IN
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|swide_scr_64_1
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|sbdl
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
name|M_IGN_RESIDUE
argument_list|)
argument_list|)
block|,
name|PADDRH
argument_list|(
name|swide_scr_64_1
argument_list|)
block|,
name|SCR_REG_REG
argument_list|(
name|rbc
argument_list|,
name|SCR_ADD
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|rbc1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|rbc2
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Save UA and RBC, since the PM0/1_SAVE  	 *  sub-scripts haven't moved them to the  	 *  context yet and the below MOV may just  	 *  change their value. 	 */
name|SCR_STORE_ABS
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_STORE_ABS
argument_list|(
name|rbc
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch1
argument_list|)
block|,
comment|/* 	 *  Throw away the IGNORE WIDE RESIDUE message. 	 *  since we just did take care of it. 	 */
name|SCR_MOVE_ABS
argument_list|(
literal|2
argument_list|)
operator|^
name|SCR_MSG_IN
block|,
name|NADDR
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_CLR
argument_list|(
name|SCR_ACK
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Restore UA and RBC registers and return. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|rbc
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch1
argument_list|)
block|,
name|SCR_RETURN
block|,
literal|0
block|, }
comment|/*--------------------------< SWIDE_SCR_64_1>---------------------*/
block|,
block|{
comment|/* 	 *  We must grab the SWIDE and move it to  	 *  memory. 	 * 	 *  - Save UA (32 bit address) in<scratch>. 	 *  - Move address bit 32..39 to SFBR. 	 *  - Increment UA (updated address). 	 */
name|SCR_STORE_ABS
argument_list|(
name|ua
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_FROM_REG
argument_list|(
name|rbc3
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua
argument_list|,
name|SCR_ADD
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua1
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua2
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|ua3
argument_list|,
name|SCR_ADDC
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|, }
comment|/*--------------------------< SWIDE_COM_64>-----------------------*/
block|,
block|{
comment|/* 	 *  - Save DRS. 	 *  - Load DRS with address bit 32..39 of the 	 *    location to write the SWIDE. 	 *    SFBR has been loaded with these bits. 	 *    (Look above). 	 */
name|SCR_STORE_ABS
argument_list|(
name|drs
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|saved_drs
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|drs
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|zero
argument_list|)
block|,
name|SCR_TO_REG
argument_list|(
name|drs
argument_list|)
block|,
literal|0
block|, }
comment|/*--------------------------< SWIDE_COMMON>-----------------------*/
block|,
block|{
comment|/* 	 *  - Save current DSA 	 *  - Load DSA with bit 0..31 of the memory  	 *    location to write the SWIDE. 	 */
name|SCR_STORE_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|saved_dsa
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
comment|/* 	 *  Move the SWIDE to memory. 	 *  Clear the WSR bit. 	 */
name|SCR_STORE_REL
argument_list|(
name|swide
argument_list|,
literal|1
argument_list|)
block|,
literal|0
block|,
name|SCR_REG_REG
argument_list|(
name|scntl2
argument_list|,
name|SCR_OR
argument_list|,
name|WSR
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  Restore the original DSA. 	 */
name|SCR_LOAD_ABS
argument_list|(
name|dsa
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|saved_dsa
argument_list|)
block|, }
comment|/*--------------------------< SWIDE_FIN_32>-----------------------*/
block|,
block|{
comment|/* 	 *  For 32 bit chip, the following SCRIPTS  	 *  instruction is patched with a JUMP to dispatcher. 	 *  (Look into the C code). 	 */
name|SCR_LOAD_ABS
argument_list|(
name|drs
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|saved_drs
argument_list|)
block|,
comment|/* 	 *  64 bit chip only. 	 *  If PM handling from SCRIPTS, we are just  	 *  a helper for the C code, so jump to  	 *  dispatcher now. 	 */
name|SCR_FROM_REG
argument_list|(
name|ccntl0
argument_list|)
block|,
literal|0
block|,
name|SCR_JUMP
operator|^
name|IFFALSE
argument_list|(
name|MASK
argument_list|(
name|ENPMJ
argument_list|,
name|ENPMJ
argument_list|)
argument_list|)
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
comment|/* 	 *  64 bit chip with hardware PM handling enabled. 	 * 	 *  Since we are paranoid:), we donnot want  	 *  a SWIDE followed by a CHMOV(1) to lead to  	 *  a CHMOV(0) in our PM context. 	 *  We check against such a condition. 	 *  Also does the C code. 	 */
name|SCR_FROM_REG
argument_list|(
name|rbc
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|rbc1
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
literal|0
block|,
name|SCR_FROM_REG
argument_list|(
name|rbc2
argument_list|)
block|,
literal|0
block|,
name|SCR_RETURN
operator|^
name|IFFALSE
argument_list|(
name|DATA
argument_list|(
literal|0
argument_list|)
argument_list|)
block|,
literal|0
block|,
comment|/* 	 *  If we are there, RBC(0..23) is zero,  	 *  and we just have to load the current  	 *  DATA SCRIPTS address (register TEMP)  	 *  with the IA and go to dispatch. 	 *  No PM context is needed. 	 */
name|SCR_STORE_ABS
argument_list|(
name|ia
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_LOAD_ABS
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|PADDRH
argument_list|(
name|scratch
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDR
argument_list|(
name|dispatch
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
block|}
comment|/*-------------------------< DT_DATA_IN>--------------------*/
block|,
block|{
comment|/*  *  Because the size depends on the  *  #define SYMCONF_MAX_SG parameter,  *  it is filled in at runtime.  *  *  ##===========< i=0; i<SYMCONF_MAX_SG>=========  *  ||	SCR_CHMOV_TBL ^ SCR_DT_DATA_IN,  *  ||		offsetof (struct dsb, data[ i]),  *  ##==========================================  */
literal|0
block|}
comment|/*-------------------------< DT_DATA_IN2>-------------------*/
block|,
block|{
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|datai_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|no_data
argument_list|)
block|, }
comment|/*-------------------------< DT_DATA_OUT>--------------------*/
block|,
block|{
comment|/*  *  Because the size depends on the  *  #define SYMCONF_MAX_SG parameter,  *  it is filled in at runtime.  *  *  ##===========< i=0; i<SYMCONF_MAX_SG>=========  *  ||	SCR_CHMOV_TBL ^ SCR_DT_DATA_OUT,  *  ||		offsetof (struct dsb, data[ i]),  *  ##==========================================  */
literal|0
block|}
comment|/*-------------------------< DT_DATA_OUT2>-------------------*/
block|,
block|{
name|SCR_CALL
block|,
name|PADDR
argument_list|(
name|datao_done
argument_list|)
block|,
name|SCR_JUMP
block|,
name|PADDRH
argument_list|(
name|no_data
argument_list|)
block|,
endif|#
directive|endif
comment|/* SYMCONF_BROKEN_U3EN_SUPPORT */
block|}
comment|/*-------------------------< ZERO>------------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SCRATCH>---------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SCRATCH1>--------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< PM0_DATA_ADDR>---------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< PM1_DATA_ADDR>---------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SAVED_DSA>-------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< SAVED_DRS>-------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< DONE_POS>--------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< STARTPOS>--------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|, }
comment|/*-------------------------< TARGTBL>---------------------*/
block|,
block|{
name|SCR_DATA_ZERO
block|,  }
comment|/*-------------------------< SNOOPTEST>-------------------*/
block|,
block|{
comment|/* 	 *  Read the variable. 	 */
name|SCR_LOAD_REL
argument_list|(
name|scratcha
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|cache
argument_list|)
block|,
name|SCR_STORE_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|cache
argument_list|)
block|,
name|SCR_LOAD_REL
argument_list|(
name|temp
argument_list|,
literal|4
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sym_hcb
argument_list|,
name|cache
argument_list|)
block|, }
comment|/*-------------------------< SNOOPEND>-------------------*/
block|,
block|{
comment|/* 	 *  And stop. 	 */
name|SCR_INT
block|,
literal|99
block|, }
comment|/*--------------------------------------------------------*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Fill in #define dependent parts of the scripts  */
end_comment

begin_function
specifier|static
name|void
name|sym_fill_scripts
parameter_list|(
name|script_p
name|scr
parameter_list|,
name|scripth_p
name|scrh
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|scr
operator|->
name|data_in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_SG
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scr
operator|->
name|data_in
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|data_in
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|scr
operator|->
name|data_out
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_SG
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scr
operator|->
name|data_out
operator|+
sizeof|sizeof
argument_list|(
name|scr
operator|->
name|data_out
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|p
operator|=
name|scrh
operator|->
name|dt_data_in
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_SG
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CHMOV_TBL
operator|^
name|SCR_DT_DATA_IN
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scrh
operator|->
name|dt_data_in
operator|+
sizeof|sizeof
argument_list|(
name|scrh
operator|->
name|dt_data_in
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|scrh
operator|->
name|dt_data_out
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_SG
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|assert
argument_list|(
operator|(
name|u_long
operator|)
name|p
operator|==
operator|(
name|u_long
operator|)
operator|&
name|scrh
operator|->
name|dt_data_out
operator|+
sizeof|sizeof
argument_list|(
name|scrh
operator|->
name|dt_data_out
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *  Copy and bind a script.  */
end_comment

begin_function
specifier|static
name|void
name|sym_bind_script
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u32
modifier|*
name|src
parameter_list|,
name|u32
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u32
name|opcode
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|u32
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|relocs
decl_stmt|;
name|int
name|opchanged
init|=
literal|0
decl_stmt|;
name|start
operator|=
name|src
expr_stmt|;
name|end
operator|=
name|src
operator|+
name|len
operator|/
literal|4
expr_stmt|;
while|while
condition|(
name|src
operator|<
name|end
condition|)
block|{
name|opcode
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|cpu_to_scr
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
comment|/* 		 *  If we forget to change the length 		 *  in scripts, a field will be 		 *  padded with 0. This is an illegal 		 *  command. 		 */
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR0 IN SCRIPT at %d.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|src
operator|-
name|start
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|MDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
comment|/* 		 *  We use the bogus value 0xf00ff00f ;-) 		 *  to reserve data area in SCRIPTS. 		 */
if|if
condition|(
name|opcode
operator|==
name|SCR_DATA_ZERO
condition|)
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCRIPT
condition|)
name|printf
argument_list|(
literal|"%p:<%x>\n"
argument_list|,
operator|(
name|src
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|unsigned
operator|)
name|opcode
argument_list|)
expr_stmt|;
comment|/* 		 *  We don't have to decode ALL commands 		 */
switch|switch
condition|(
name|opcode
operator|>>
literal|28
condition|)
block|{
case|case
literal|0xf
case|:
comment|/* 			 *  LOAD / STORE DSA relative, don't relocate. 			 */
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/* 			 *  LOAD / STORE absolute. 			 */
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/* 			 *  COPY has TWO arguments. 			 */
name|relocs
operator|=
literal|2
expr_stmt|;
name|tmp1
operator|=
name|src
index|[
literal|0
index|]
expr_stmt|;
name|tmp2
operator|=
name|src
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|RELOC_KVAR
if|if
condition|(
operator|(
name|tmp1
operator|&
name|RELOC_MASK
operator|)
operator|==
name|RELOC_KVAR
condition|)
name|tmp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp2
operator|&
name|RELOC_MASK
operator|)
operator|==
name|RELOC_KVAR
condition|)
name|tmp2
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|tmp1
operator|^
name|tmp2
operator|)
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR1 IN SCRIPT at %d.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|src
operator|-
name|start
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|MDELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *  If PREFETCH feature not enabled, remove  			 *  the NO FLUSH bit if present. 			 */
if|if
condition|(
operator|(
name|opcode
operator|&
name|SCR_NO_FLUSH
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
condition|)
block|{
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|opcode
operator|&
operator|~
name|SCR_NO_FLUSH
argument_list|)
expr_stmt|;
operator|++
name|opchanged
expr_stmt|;
block|}
break|break;
case|case
literal|0x0
case|:
comment|/* 			 *  MOVE/CHMOV (absolute address) 			 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|)
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|opcode
operator||
name|OPC_MOVE
argument_list|)
expr_stmt|;
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/* 			 *  MOVE/CHMOV (table indirect) 			 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|)
name|dst
index|[
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|opcode
operator||
name|OPC_MOVE
argument_list|)
expr_stmt|;
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
comment|/* 			 *  JUMP / CALL 			 *  dont't relocate if relative :-) 			 */
if|if
condition|(
name|opcode
operator|&
literal|0x00800000
condition|)
name|relocs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|&
literal|0xf8400000
operator|)
operator|==
literal|0x80400000
condition|)
comment|/*JUMP64*/
name|relocs
operator|=
literal|2
expr_stmt|;
else|else
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|relocs
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|cpu_to_scr
argument_list|(
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|relocs
operator|--
condition|)
block|{
name|old
operator|=
operator|*
name|src
operator|++
expr_stmt|;
switch|switch
condition|(
name|old
operator|&
name|RELOC_MASK
condition|)
block|{
case|case
name|RELOC_REGISTER
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|mmio_ba
expr_stmt|;
break|break;
case|case
name|RELOC_LABEL
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|script_ba
expr_stmt|;
break|break;
case|case
name|RELOC_LABELH
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|scripth_ba
expr_stmt|;
break|break;
case|case
name|RELOC_SOFTC
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|vtobus
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RELOC_KVAR
case|case
name|RELOC_KVAR
case|:
if|if
condition|(
operator|(
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|<
name|SCRIPT_KVAR_FIRST
operator|)
operator|||
operator|(
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|>
name|SCRIPT_KVAR_LAST
operator|)
condition|)
name|panic
argument_list|(
literal|"KVAR out of range"
argument_list|)
expr_stmt|;
name|new
operator|=
name|vtobus
argument_list|(
name|script_kvars
index|[
name|old
operator|&
operator|~
name|RELOC_MASK
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0
case|:
comment|/* Don't relocate a 0 address. */
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|old
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|new
operator|=
literal|0
expr_stmt|;
comment|/* For 'cc' not to complain */
name|panic
argument_list|(
literal|"sym_bind_script: "
literal|"weird relocation %x\n"
argument_list|,
name|old
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|dst
operator|++
operator|=
name|cpu_to_scr
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Print something which allows to retrieve the controler type,   *  unit, target, lun concerned by a kernel message.  */
end_comment

begin_function
specifier|static
name|void
name|PRINT_TARGET
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%d:"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PRINT_LUN
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%d:%d:"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PRINT_ADDR
parameter_list|(
name|ccb_p
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|&&
name|cp
operator|->
name|cam_ccb
condition|)
name|xpt_print_path
argument_list|(
name|cp
operator|->
name|cam_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Take into account this ccb in the freeze count.  *  The flag that tells user about avoids doing that   *  more than once for a ccb.  */
end_comment

begin_function
specifier|static
name|void
name|sym_freeze_cam_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFRZDIS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Set the status field of a CAM CCB.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sym_set_cam_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_status
name|status
parameter_list|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Get the status field of a CAM CCB.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|sym_get_cam_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
return|return
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
return|;
block|}
end_function

begin_comment
comment|/*  *  Enqueue a CAM CCB.  */
end_comment

begin_function
specifier|static
name|void
name|sym_enqueue_cam_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|sym_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|sym_hcb_ptr
operator|=
name|np
expr_stmt|;
name|sym_insque_tail
argument_list|(
name|sym_qptr
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|sim_links
argument_list|)
argument_list|,
operator|&
name|np
operator|->
name|cam_ccbq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Complete a pending CAM CCB.  */
end_comment

begin_function
specifier|static
name|void
name|sym_xpt_done
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
condition|)
block|{
name|untimeout
argument_list|(
name|sym_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
name|sym_remque
argument_list|(
name|sym_qptr
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|sim_links
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|sym_hcb_ptr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
condition|)
name|sym_freeze_cam_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_xpt_done2
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|cam_status
parameter_list|)
block|{
name|sym_set_cam_status
argument_list|(
name|ccb
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  SYMBIOS chip clock divisor table.  *  *  Divisors are multiplied by 10,000,000 in order to make   *  calculations more simple.  */
end_comment

begin_define
define|#
directive|define
name|_5M
value|5000000
end_define

begin_decl_stmt
specifier|static
name|u_long
name|div_10M
index|[]
init|=
block|{
literal|2
operator|*
name|_5M
block|,
literal|3
operator|*
name|_5M
block|,
literal|4
operator|*
name|_5M
block|,
literal|6
operator|*
name|_5M
block|,
literal|8
operator|*
name|_5M
block|,
literal|12
operator|*
name|_5M
block|,
literal|16
operator|*
name|_5M
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  SYMBIOS chips allow burst lengths of 2, 4, 8, 16, 32, 64,  *  128 transfers. All chips support at least 16 transfers   *  bursts. The 825A, 875 and 895 chips support bursts of up   *  to 128 transfers and the 895A and 896 support bursts of up  *  to 64 transfers. All other chips support up to 16   *  transfers bursts.  *  *  For PCI 32 bit data transfers each transfer is a DWORD.  *  It is a QUADWORD (8 bytes) for PCI 64 bit data transfers.  *  Only the 896 is able to perform 64 bit data transfers.  *  *  We use log base 2 (burst length) as internal code, with   *  value 0 meaning "burst disabled".  */
end_comment

begin_comment
comment|/*  *  Burst length from burst code.  */
end_comment

begin_define
define|#
directive|define
name|burst_length
parameter_list|(
name|bc
parameter_list|)
value|(!(bc))? 0 : 1<< (bc)
end_define

begin_comment
comment|/*  *  Burst code from io register bits.  */
end_comment

begin_define
define|#
directive|define
name|burst_code
parameter_list|(
name|dmode
parameter_list|,
name|ctest4
parameter_list|,
name|ctest5
parameter_list|)
define|\
value|(ctest4)& 0x80? 0 : (((dmode)& 0xc0)>> 6) + ((ctest5)& 0x04) + 1
end_define

begin_comment
comment|/*  *  Set initial io register bits from burst code.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sym_init_burst
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|bc
parameter_list|)
block|{
name|np
operator|->
name|rv_ctest4
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator|&=
operator|~
operator|(
literal|0x3
operator|<<
literal|6
operator|)
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator|&=
operator|~
literal|0x4
expr_stmt|;
if|if
condition|(
operator|!
name|bc
condition|)
block|{
name|np
operator|->
name|rv_ctest4
operator||=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
operator|--
name|bc
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator||=
operator|(
operator|(
name|bc
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator||=
operator|(
name|bc
operator|&
literal|0x4
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the list of targets that have some flag disabled by user.  */
end_comment

begin_function
specifier|static
name|void
name|sym_print_targets_flag
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|mask
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|np
operator|->
name|myaddr
condition|)
continue|continue;
if|if
condition|(
name|np
operator|->
name|target
index|[
name|i
index|]
operator|.
name|usrflags
operator|&
name|mask
condition|)
block|{
if|if
condition|(
operator|!
name|cnt
operator|++
condition|)
name|printf
argument_list|(
literal|"%s: %s disabled for targets"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Prepare io register values used by sym_init() according   *  to selected and supported features.  */
end_comment

begin_function
specifier|static
name|int
name|sym_prepare_setting
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|u_char
name|burst_max
decl_stmt|;
name|u_long
name|period
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  Save assumed BIOS setting 	 */
name|np
operator|->
name|sv_scntl0
operator|=
name|INB
argument_list|(
name|nc_scntl0
argument_list|)
operator|&
literal|0x0a
expr_stmt|;
name|np
operator|->
name|sv_scntl3
operator|=
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
operator|&
literal|0x07
expr_stmt|;
name|np
operator|->
name|sv_dmode
operator|=
name|INB
argument_list|(
name|nc_dmode
argument_list|)
operator|&
literal|0xce
expr_stmt|;
name|np
operator|->
name|sv_dcntl
operator|=
name|INB
argument_list|(
name|nc_dcntl
argument_list|)
operator|&
literal|0xa8
expr_stmt|;
name|np
operator|->
name|sv_ctest3
operator|=
name|INB
argument_list|(
name|nc_ctest3
argument_list|)
operator|&
literal|0x01
expr_stmt|;
name|np
operator|->
name|sv_ctest4
operator|=
name|INB
argument_list|(
name|nc_ctest4
argument_list|)
operator|&
literal|0x80
expr_stmt|;
name|np
operator|->
name|sv_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
name|np
operator|->
name|sv_stest2
operator|=
name|INB
argument_list|(
name|nc_stest2
argument_list|)
operator|&
literal|0x20
expr_stmt|;
name|np
operator|->
name|sv_stest4
operator|=
name|INB
argument_list|(
name|nc_stest4
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
comment|/* Always large DMA fifo + ultra3 */
name|np
operator|->
name|sv_scntl4
operator|=
name|INB
argument_list|(
name|nc_scntl4
argument_list|)
expr_stmt|;
name|np
operator|->
name|sv_ctest5
operator|=
name|INB
argument_list|(
name|nc_ctest5
argument_list|)
operator|&
literal|0x04
expr_stmt|;
block|}
else|else
name|np
operator|->
name|sv_ctest5
operator|=
name|INB
argument_list|(
name|nc_ctest5
argument_list|)
operator|&
literal|0x24
expr_stmt|;
comment|/* 	 *  Wide ? 	 */
name|np
operator|->
name|maxwide
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 *  Get the frequency of the chip's clock. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_QUAD
condition|)
name|np
operator|->
name|multiplier
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DBLR
condition|)
name|np
operator|->
name|multiplier
operator|=
literal|2
expr_stmt|;
else|else
name|np
operator|->
name|multiplier
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_CLK80
operator|)
condition|?
literal|80000
else|:
literal|40000
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|*=
name|np
operator|->
name|multiplier
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|clock_khz
operator|!=
literal|40000
condition|)
name|sym_getclock
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|multiplier
argument_list|)
expr_stmt|;
comment|/* 	 * Divisor to be used for async (timer pre-scaler). 	 */
name|i
operator|=
name|np
operator|->
name|clock_divn
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
literal|10ul
operator|*
name|SYMCONF_MIN_ASYNC
operator|*
name|np
operator|->
name|clock_khz
operator|>
name|div_10M
index|[
name|i
index|]
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
name|np
operator|->
name|rv_scntl3
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 * The C1010 uses hardwired divisors for async. 	 * So, we just throw away, the async. divisor.:-) 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
name|np
operator|->
name|rv_scntl3
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Minimum synchronous period factor supported by the chip. 	 * Btw, 'period' is in tenths of nanoseconds. 	 */
name|period
operator|=
operator|(
literal|4
operator|*
name|div_10M
index|[
literal|0
index|]
operator|+
name|np
operator|->
name|clock_khz
operator|-
literal|1
operator|)
operator|/
name|np
operator|->
name|clock_khz
expr_stmt|;
if|if
condition|(
name|period
operator|<=
literal|250
condition|)
name|np
operator|->
name|minsync
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
literal|303
condition|)
name|np
operator|->
name|minsync
operator|=
literal|11
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
literal|500
condition|)
name|np
operator|->
name|minsync
operator|=
literal|12
expr_stmt|;
else|else
name|np
operator|->
name|minsync
operator|=
operator|(
name|period
operator|+
literal|40
operator|-
literal|1
operator|)
operator|/
literal|40
expr_stmt|;
comment|/* 	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2). 	 */
if|if
condition|(
name|np
operator|->
name|minsync
operator|<
literal|25
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA
operator||
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
operator|)
condition|)
name|np
operator|->
name|minsync
operator|=
literal|25
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|minsync
operator|<
literal|12
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
operator|)
condition|)
name|np
operator|->
name|minsync
operator|=
literal|12
expr_stmt|;
comment|/* 	 * Maximum synchronous period factor supported by the chip. 	 */
name|period
operator|=
operator|(
literal|11
operator|*
name|div_10M
index|[
name|np
operator|->
name|clock_divn
operator|-
literal|1
index|]
operator|)
operator|/
operator|(
literal|4
operator|*
name|np
operator|->
name|clock_khz
operator|)
expr_stmt|;
name|np
operator|->
name|maxsync
operator|=
name|period
operator|>
literal|2540
condition|?
literal|254
else|:
name|period
operator|/
literal|10
expr_stmt|;
comment|/* 	 * If chip is a C1010, guess the sync limits in DT mode. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_ULTRA3
operator|)
operator|)
operator|==
operator|(
name|FE_C10
operator||
name|FE_ULTRA3
operator|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|clock_khz
operator|==
literal|160000
condition|)
block|{
name|np
operator|->
name|minsync_dt
operator|=
literal|9
expr_stmt|;
name|np
operator|->
name|maxsync_dt
operator|=
literal|50
expr_stmt|;
block|}
block|}
comment|/* 	 *  64 bit (53C895A or 53C896) ? 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
condition|)
if|#
directive|if
name|BITS_PER_LONG
operator|>
literal|32
name|np
operator|->
name|rv_ccntl1
operator||=
operator|(
name|XTIMOD
operator||
name|EXTIBMV
operator|)
expr_stmt|;
else|#
directive|else
name|np
operator|->
name|rv_ccntl1
operator||=
operator|(
name|DDAC
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Phase mismatch handled by SCRIPTS (895A/896/1010) ?   	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_NOPM
condition|)
name|np
operator|->
name|rv_ccntl0
operator||=
operator|(
name|ENPMJ
operator|)
expr_stmt|;
comment|/* 	 *  C1010 Errata. 	 *  In dual channel mode, contention occurs if internal cycles 	 *  are used. Disable internal cycles. 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010
operator|&&
name|np
operator|->
name|revision_id
operator|<
literal|0x45
condition|)
name|np
operator|->
name|rv_ccntl0
operator||=
name|DILS
expr_stmt|;
comment|/* 	 *  Prepare initial value of other IO registers 	 */
if|#
directive|if
name|defined
name|SYMCONF_TRUST_BIOS_SETTING
name|np
operator|->
name|rv_scntl0
operator|=
name|np
operator|->
name|sv_scntl0
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator|=
name|np
operator|->
name|sv_dmode
expr_stmt|;
name|np
operator|->
name|rv_dcntl
operator|=
name|np
operator|->
name|sv_dcntl
expr_stmt|;
name|np
operator|->
name|rv_ctest3
operator|=
name|np
operator|->
name|sv_ctest3
expr_stmt|;
name|np
operator|->
name|rv_ctest4
operator|=
name|np
operator|->
name|sv_ctest4
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator|=
name|np
operator|->
name|sv_ctest5
expr_stmt|;
name|burst_max
operator|=
name|burst_code
argument_list|(
name|np
operator|->
name|sv_dmode
argument_list|,
name|np
operator|->
name|sv_ctest4
argument_list|,
name|np
operator|->
name|sv_ctest5
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 *  Select burst length (dwords) 	 */
name|burst_max
operator|=
name|SYMSETUP_BURST_ORDER
expr_stmt|;
if|if
condition|(
name|burst_max
operator|==
literal|255
condition|)
name|burst_max
operator|=
name|burst_code
argument_list|(
name|np
operator|->
name|sv_dmode
argument_list|,
name|np
operator|->
name|sv_ctest4
argument_list|,
name|np
operator|->
name|sv_ctest5
argument_list|)
expr_stmt|;
if|if
condition|(
name|burst_max
operator|>
literal|7
condition|)
name|burst_max
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|burst_max
operator|>
name|np
operator|->
name|maxburst
condition|)
name|burst_max
operator|=
name|np
operator|->
name|maxburst
expr_stmt|;
comment|/* 	 *  DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2. 	 *  This chip and the 860 Rev 1 may wrongly use PCI cache line  	 *  based transactions on LOAD/STORE instructions. So we have  	 *  to prevent these chips from using such PCI transactions in  	 *  this driver. The generic ncr driver that does not use  	 *  LOAD/STORE instructions does not need this work-around. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C810
operator|&&
name|np
operator|->
name|revision_id
operator|>=
literal|0x10
operator|&&
name|np
operator|->
name|revision_id
operator|<=
literal|0x11
operator|)
operator|||
operator|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C860
operator|&&
name|np
operator|->
name|revision_id
operator|<=
literal|0x1
operator|)
condition|)
name|np
operator|->
name|features
operator|&=
operator|~
operator|(
name|FE_WRIE
operator||
name|FE_ERL
operator||
name|FE_ERMP
operator|)
expr_stmt|;
comment|/* 	 *  Select all supported special features. 	 *  If we are using on-board RAM for scripts, prefetch (PFEN)  	 *  does not help, but burst op fetch (BOF) does. 	 *  Disabling PFEN makes sure BOF will be used. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ERL
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|ERL
expr_stmt|;
comment|/* Enable Read Line */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_BOF
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|BOF
expr_stmt|;
comment|/* Burst Opcode Fetch */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ERMP
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|ERMP
expr_stmt|;
comment|/* Enable Read Multiple */
if|#
directive|if
literal|1
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
operator|&&
operator|!
name|np
operator|->
name|ram_ba
condition|)
else|#
directive|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
condition|)
endif|#
directive|endif
name|np
operator|->
name|rv_dcntl
operator||=
name|PFEN
expr_stmt|;
comment|/* Prefetch Enable */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_CLSE
condition|)
name|np
operator|->
name|rv_dcntl
operator||=
name|CLSE
expr_stmt|;
comment|/* Cache Line Size Enable */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_WRIE
condition|)
name|np
operator|->
name|rv_ctest3
operator||=
name|WRIE
expr_stmt|;
comment|/* Write and Invalidate */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DFS
condition|)
name|np
operator|->
name|rv_ctest5
operator||=
name|DFS
expr_stmt|;
comment|/* Dma Fifo Size */
comment|/* 	 *  Select some other 	 */
if|if
condition|(
name|SYMSETUP_PCI_PARITY
condition|)
name|np
operator|->
name|rv_ctest4
operator||=
name|MPEE
expr_stmt|;
comment|/* Master parity checking */
if|if
condition|(
name|SYMSETUP_SCSI_PARITY
condition|)
name|np
operator|->
name|rv_scntl0
operator||=
literal|0x0a
expr_stmt|;
comment|/*  full arb., ena parity, par->ATN  */
comment|/* 	 *  Get parity checking, host ID and verbose mode from NVRAM 	 */
name|np
operator|->
name|myaddr
operator|=
literal|255
expr_stmt|;
name|sym_nvram_setup_host
argument_list|(
name|np
argument_list|,
name|nvram
argument_list|)
expr_stmt|;
comment|/* 	 *  Get SCSI addr of host adapter (set by bios?). 	 */
if|if
condition|(
name|np
operator|->
name|myaddr
operator|==
literal|255
condition|)
block|{
name|np
operator|->
name|myaddr
operator|=
name|INB
argument_list|(
name|nc_scid
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|myaddr
condition|)
name|np
operator|->
name|myaddr
operator|=
name|SYMSETUP_HOST_ID
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYMCONF_TRUST_BIOS_SETTING */
comment|/* 	 *  Prepare initial io register bits for burst length 	 */
name|sym_init_burst
argument_list|(
name|np
argument_list|,
name|burst_max
argument_list|)
expr_stmt|;
comment|/* 	 *  Set SCSI BUS mode. 	 *  - LVD capable chips (895/895A/896/1010) report the  	 *    current BUS mode through the STEST4 IO register. 	 *  - For previous generation chips (825/825A/875),  	 *    user has to tell us how to check against HVD,  	 *    since a 100% safe algorithm is not possible. 	 */
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_SE
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
condition|)
name|np
operator|->
name|scsi_mode
operator|=
operator|(
name|np
operator|->
name|sv_stest4
operator|&
name|SMODE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DIFF
condition|)
block|{
if|if
condition|(
name|SYMSETUP_SCSI_DIFF
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|sv_scntl3
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|sv_stest2
operator|&
literal|0x20
condition|)
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_HVD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvram
operator|->
name|type
operator|==
name|SYM_SYMBIOS_NVRAM
condition|)
block|{
if|if
condition|(
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
operator|&
literal|0x08
condition|)
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_HVD
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SYMSETUP_SCSI_DIFF
operator|==
literal|2
condition|)
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_HVD
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|scsi_mode
operator|==
name|SMODE_HVD
condition|)
name|np
operator|->
name|rv_stest2
operator||=
literal|0x20
expr_stmt|;
comment|/* 	 *  Set LED support from SCRIPTS. 	 *  Ignore this feature for boards known to use a  	 *  specific GPIO wiring and for the 895A or 896  	 *  that drive the LED directly. 	 */
if|if
condition|(
operator|(
name|SYMSETUP_SCSI_LED
operator|||
name|nvram
operator|->
name|type
operator|==
name|SYM_SYMBIOS_NVRAM
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_LEDC
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|sv_gpcntl
operator|&
literal|0x01
operator|)
condition|)
name|np
operator|->
name|features
operator||=
name|FE_LED0
expr_stmt|;
comment|/* 	 *  Set irq mode. 	 */
switch|switch
condition|(
name|SYMSETUP_IRQ_MODE
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|np
operator|->
name|rv_dcntl
operator||=
name|IRQM
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|np
operator|->
name|rv_dcntl
operator||=
operator|(
name|np
operator|->
name|sv_dcntl
operator|&
name|IRQM
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 *  Configure targets according to driver setup. 	 *  If NVRAM present get targets setup from NVRAM. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|np
operator|->
name|maxwide
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|usrflags
operator||=
operator|(
name|SYM_DISC_ENABLED
operator||
name|SYM_TAGS_ENABLED
operator|)
expr_stmt|;
name|tp
operator|->
name|usrtags
operator|=
name|SYMSETUP_MAX_TAG
expr_stmt|;
name|sym_nvram_setup_target
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|nvram
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|usrtags
condition|)
name|tp
operator|->
name|usrflags
operator|&=
operator|~
name|SYM_TAGS_ENABLED
expr_stmt|;
block|}
comment|/* 	 *  Let user know about the settings. 	 */
name|i
operator|=
name|nvram
operator|->
name|type
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s NVRAM, ID %d, Fast-%d, %s%s\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
operator|==
name|SYM_SYMBIOS_NVRAM
condition|?
literal|"Symbios"
else|:
operator|(
name|i
operator|==
name|SYM_TEKRAM_NVRAM
condition|?
literal|"Tekram"
else|:
literal|"No"
operator|)
argument_list|,
name|np
operator|->
name|myaddr
argument_list|,
name|np
operator|->
name|minsync
operator|<
literal|10
condition|?
literal|80
else|:
operator|(
name|np
operator|->
name|minsync
operator|<
literal|12
condition|?
literal|40
else|:
operator|(
name|np
operator|->
name|minsync
operator|<
literal|25
condition|?
literal|20
else|:
literal|10
operator|)
operator|)
argument_list|,
operator|(
name|np
operator|->
name|rv_scntl0
operator|&
literal|0xa
operator|)
condition|?
literal|"parity checking"
else|:
literal|"NO parity"
argument_list|,
name|np
operator|->
name|scsi_mode
operator|==
name|SMODE_HVD
condition|?
literal|", HVD"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell him more on demand. 	 */
if|if
condition|(
name|sym_verbose
condition|)
name|printf
argument_list|(
literal|"%s: %s IRQ line driver%s\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|rv_dcntl
operator|&
name|IRQM
condition|?
literal|"totem pole"
else|:
literal|"open drain"
argument_list|,
name|np
operator|->
name|ram_ba
condition|?
literal|", using on-chip SRAM"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 *  And still more. 	 */
if|if
condition|(
name|sym_verbose
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "
literal|"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|sv_scntl3
argument_list|,
name|np
operator|->
name|sv_dmode
argument_list|,
name|np
operator|->
name|sv_dcntl
argument_list|,
name|np
operator|->
name|sv_ctest3
argument_list|,
name|np
operator|->
name|sv_ctest4
argument_list|,
name|np
operator|->
name|sv_ctest5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "
literal|"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|,
name|np
operator|->
name|rv_dcntl
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Let user be aware of targets that have some disable flags set. 	 */
name|sym_print_targets_flag
argument_list|(
name|np
argument_list|,
name|SYM_SCAN_BOOT_DISABLED
argument_list|,
literal|"SCAN AT BOOT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_verbose
condition|)
name|sym_print_targets_flag
argument_list|(
name|np
argument_list|,
name|SYM_SCAN_LUNS_DISABLED
argument_list|,
literal|"SCAN FOR LUNS"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Prepare the next negotiation message if needed.  *  *  Fill in the part of message buffer that contains the   *  negotiation and the nego_status field of the CCB.  *  Returns the size of the message in bytes.  */
end_comment

begin_function
specifier|static
name|int
name|sym_prepare_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|nego
parameter_list|,
name|u_char
modifier|*
name|msgptr
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|int
name|msglen
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|1
comment|/* 	 *  For now, only use PPR with DT option if period factor = 9. 	 */
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|==
literal|9
condition|)
block|{
name|nego
operator|=
name|NS_PPR
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
name|PPR_OPT_DT
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
operator|)
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  negotiate using PPR ? 	 */
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|&
name|PPR_OPT_MASK
condition|)
name|nego
operator|=
name|NS_PPR
expr_stmt|;
comment|/* 	 *  negotiate wide transfers ? 	 */
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
condition|)
name|nego
operator|=
name|NS_WIDE
expr_stmt|;
comment|/* 	 *  negotiate synchronous transfers? 	 */
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
condition|)
name|nego
operator|=
name|NS_SYNC
expr_stmt|;
switch|switch
condition|(
name|nego
condition|)
block|{
case|case
name|NS_SYNC
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|3
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|2
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_WIDE_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
expr_stmt|;
break|break;
case|case
name|NS_PPR
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|6
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_PPR_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|&
name|PPR_OPT_DT
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|nego
expr_stmt|;
if|if
condition|(
name|nego
condition|)
block|{
name|tp
operator|->
name|nego_cp
operator|=
name|cp
expr_stmt|;
comment|/* Keep track a nego will be performed */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"nego msgout:"
argument_list|,
name|msgptr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
name|msglen
return|;
block|}
end_function

begin_comment
comment|/*  *  Insert a job into the start queue.  */
end_comment

begin_function
specifier|static
name|void
name|sym_put_start_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_short
name|qidx
decl_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 	 *  If the previously queued CCB is not yet done,  	 *  set the IARB hint. The SCRIPTS will go with IARB  	 *  for this job when starting the previous one. 	 *  We leave devices a chance to win arbitration by  	 *  not using more than 'iarb_max' consecutive  	 *  immediate arbitrations. 	 */
if|if
condition|(
name|np
operator|->
name|last_cp
operator|&&
name|np
operator|->
name|iarb_count
operator|<
name|np
operator|->
name|iarb_max
condition|)
block|{
name|np
operator|->
name|last_cp
operator|->
name|host_flags
operator||=
name|HF_HINT_IARB
expr_stmt|;
operator|++
name|np
operator|->
name|iarb_count
expr_stmt|;
block|}
else|else
name|np
operator|->
name|iarb_count
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|last_cp
operator|=
name|cp
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Insert first the idle task and then our job. 	 *  The MB should ensure proper ordering. 	 */
name|qidx
operator|=
name|np
operator|->
name|squeueput
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|qidx
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|qidx
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|qidx
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|idletask_ba
argument_list|)
expr_stmt|;
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|np
operator|->
name|squeueput
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeueput
operator|=
name|qidx
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_QUEUE
condition|)
name|printf
argument_list|(
literal|"%s: queuepos=%d.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|squeueput
argument_list|)
expr_stmt|;
comment|/* 	 *  Script processor may be waiting for reselect. 	 *  Wake it up. 	 */
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
operator||
name|np
operator|->
name|istat_sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Soft reset the chip.  *  *  Some 896 and 876 chip revisions may hang-up if we set   *  the SRST (soft reset) bit at the wrong time when SCRIPTS   *  are running.  *  So, we need to abort the current operation prior to   *  soft resetting the chip.  */
end_comment

begin_function
specifier|static
name|void
name|sym_soft_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|istat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|CABRT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|&
name|SIP
condition|)
block|{
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|istat
operator|&
name|DIP
condition|)
block|{
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INB
argument_list|(
name|nc_dstat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|i
condition|)
name|printf
argument_list|(
literal|"%s: unable to abort current chip operation.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Start reset process.  *  *  The interrupt handler will reinitialize the chip.  */
end_comment

begin_function
specifier|static
name|void
name|sym_start_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sym_reset_scsi_bus
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_reset_scsi_bus
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|enab_int
parameter_list|)
block|{
name|u32
name|term
decl_stmt|;
name|int
name|retv
init|=
literal|0
decl_stmt|;
name|sym_soft_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Soft reset the chip */
name|UDELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* The 895/6 need time for the bus mode to settle */
if|if
condition|(
name|enab_int
condition|)
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
name|RST
argument_list|)
expr_stmt|;
comment|/* 	 *  Enable Tolerant, reset IRQD if present and  	 *  properly set IRQ mode, prior to resetting the bus. 	 */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|np
operator|->
name|rv_dcntl
operator|&
name|IRQM
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SYMSETUP_SCSI_BUS_CHECK
condition|)
goto|goto
name|out
goto|;
comment|/* 	 *  Check for no terminators or SCSI bus shorts to ground. 	 *  Read SCSI data bus, data parity bits and control signals. 	 *  We are expecting RESET to be TRUE and other signals to be  	 *  FALSE. 	 */
name|term
operator|=
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
expr_stmt|;
comment|/* rst, sdp0 */
name|term
operator|=
operator|(
operator|(
name|term
operator|&
literal|2
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|term
operator|&
literal|1
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|term
operator||=
operator|(
operator|(
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
operator|&
literal|0x01
operator|)
operator|<<
literal|25
operator|)
operator||
comment|/* sdp1 */
operator|(
name|INW
argument_list|(
name|nc_sbdl
argument_list|)
operator|<<
literal|9
operator|)
operator||
comment|/* d15-0 */
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
expr_stmt|;
comment|/* req, ack, bsy, sel, atn, msg, cd, io */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|)
name|term
operator|&=
literal|0x3ffff
expr_stmt|;
if|if
condition|(
name|term
operator|!=
operator|(
literal|2
operator|<<
literal|7
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: suspicious SCSI data while resetting the BUS.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = "
literal|"0x%lx, expecting 0x%lx\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|"dp1,d15-8,"
else|:
literal|""
argument_list|,
operator|(
name|u_long
operator|)
name|term
argument_list|,
call|(
name|u_long
call|)
argument_list|(
literal|2
operator|<<
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMSETUP_SCSI_BUS_CHECK
operator|==
literal|1
condition|)
name|retv
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MDELAY(100); */
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/*  *  The chip may have completed jobs. Look at the DONE QUEUE.  */
end_comment

begin_function
specifier|static
name|int
name|sym_wakeup_done
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|ccb_p
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_long
name|dsa
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|np
operator|->
name|dqueueget
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dsa
operator|=
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|dqueue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsa
condition|)
break|break;
name|np
operator|->
name|dqueue
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|i
operator|+
literal|2
operator|)
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|sym_complete_ok
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: bad DSA (%lx) in done queue.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|dqueueget
operator|=
name|i
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  *  Complete all active CCBs with error.  *  Used on CHIP/SCSI RESET.  */
end_comment

begin_function
specifier|static
name|void
name|sym_flush_busy_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
block|{
comment|/* 	 *  Move all active CCBs to the COMP queue  	 *  and flush this queue. 	 */
name|sym_que_splice
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Start chip.  */
end_comment

begin_function
specifier|static
name|void
name|sym_init
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|reset
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|phys
decl_stmt|;
comment|/* 	 *  Reset chip if asked, otherwise just clear fifos.  	 */
if|if
condition|(
name|reset
condition|)
name|sym_soft_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
else|else
block|{
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
name|OUTONB
argument_list|(
name|nc_ctest3
argument_list|,
name|CLF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Message. 	 */
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"%s: restart (%s).\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 *  Clear Start Queue 	 */
name|phys
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|squeue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_QUEUE
operator|*
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|np
operator|->
name|squeue
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|idletask_ba
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
operator|+
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|squeue
index|[
name|MAX_QUEUE
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Start at first entry. 	 */
name|np
operator|->
name|squeueput
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|scripth0
operator|->
name|startpos
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Clear Done Queue 	 */
name|phys
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|dqueue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_QUEUE
operator|*
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|np
operator|->
name|dqueue
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|dqueue
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
operator|+
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|dqueue
index|[
name|MAX_QUEUE
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Start at first entry. 	 */
name|np
operator|->
name|scripth0
operator|->
name|done_pos
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
argument_list|)
expr_stmt|;
name|np
operator|->
name|dqueueget
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Wakeup all pending jobs. 	 */
name|sym_flush_busy_queue
argument_list|(
name|np
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
comment|/* 	 *  Init chip. 	 */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  Remove Reset, abort */
name|UDELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* The 895 needs time for the bus mode to settle */
name|OUTB
argument_list|(
name|nc_scntl0
argument_list|,
name|np
operator|->
name|rv_scntl0
operator||
literal|0xc0
argument_list|)
expr_stmt|;
comment|/*  full arb., ena parity, par->ATN  */
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  odd parity, and remove CRST!! */
name|sym_selectclock
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|)
expr_stmt|;
comment|/* Select SCSI clock */
name|OUTB
argument_list|(
name|nc_scid
argument_list|,
name|RRE
operator||
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/* Adapter SCSI address */
name|OUTW
argument_list|(
name|nc_respid
argument_list|,
literal|1ul
operator|<<
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/* Id to respond to */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
comment|/*  Signal Process */
name|OUTB
argument_list|(
name|nc_dmode
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|)
expr_stmt|;
comment|/* Burst length, dma mode */
name|OUTB
argument_list|(
name|nc_ctest5
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
comment|/* Large fifo + large burst */
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|NOCOM
operator||
name|np
operator|->
name|rv_dcntl
argument_list|)
expr_stmt|;
comment|/* Protect SFBR */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|)
expr_stmt|;
comment|/* Write and invalidate */
name|OUTB
argument_list|(
name|nc_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|)
expr_stmt|;
comment|/* Master parity checking */
comment|/* Extended Sreq/Sack filtering not supported on the C10 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
name|np
operator|->
name|rv_stest2
argument_list|)
expr_stmt|;
else|else
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
name|EXT
operator||
name|np
operator|->
name|rv_stest2
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
argument_list|)
expr_stmt|;
comment|/* TolerANT enable */
name|OUTB
argument_list|(
name|nc_stime0
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* HTH disabled  STO 0.25 sec */
comment|/* 	 *  C10101 Errata. 	 *  Errant SGE's when in narrow. Write bits 4& 5 of 	 *  STEST1 register to disable SGE. We probably should do  	 *  that from SCRIPTS for each selection/reselection, but  	 *  I just don't want. :) 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010
operator|&&
name|np
operator|->
name|revision_id
operator|<
literal|0x45
condition|)
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|INB
argument_list|(
name|nc_stest1
argument_list|)
operator||
literal|0x30
argument_list|)
expr_stmt|;
comment|/* 	 *  DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2. 	 *  Disable overlapped arbitration for some dual function devices,  	 *  regardless revision id (kind of post-chip-design feature. ;-)) 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C875
condition|)
name|OUTB
argument_list|(
name|nc_ctest0
argument_list|,
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C896
condition|)
name|np
operator|->
name|rv_ccntl0
operator||=
name|DPR
expr_stmt|;
comment|/* 	 *  If 64 bit (895A/896/1010) write CCNTL1 to enable 40 bit  	 *  address table indirect addressing for MOVE. 	 *  Also write CCNTL0 if 64 bit chip, since this register seems  	 *  to only be used by 64 bit cores. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
condition|)
block|{
name|OUTB
argument_list|(
name|nc_ccntl0
argument_list|,
name|np
operator|->
name|rv_ccntl0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_ccntl1
argument_list|,
name|np
operator|->
name|rv_ccntl1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If phase mismatch handled by scripts (895A/896/1010), 	 *  set PM jump addresses. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_NOPM
condition|)
block|{
if|if
condition|(
name|sym_verbose
condition|)
name|printf
argument_list|(
literal|"%s: handling phase mismatch from SCRIPTS.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_pmjad1
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|pm_handle
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_pmjad2
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|pm_handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *    Enable GPIO0 pin for writing if LED support from SCRIPTS. 	 *    Also set GPIO5 and clear GPIO6 if hardware LED control. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
condition|)
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
operator|&
operator|~
literal|0x01
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LEDC
condition|)
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|(
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
operator|&
operator|~
literal|0x41
operator|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
comment|/* 	 *      enable ints 	 */
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
name|STO
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
name|MDPE
operator||
name|BF
operator||
name|SSI
operator||
name|SIR
operator||
name|IID
argument_list|)
expr_stmt|;
comment|/* 	 *  For 895/6 enable SBMC interrupt and save current SCSI bus mode. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
condition|)
block|{
name|OUTONW
argument_list|(
name|nc_sien
argument_list|,
name|SBMC
argument_list|)
expr_stmt|;
name|np
operator|->
name|scsi_mode
operator|=
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|SMODE
expr_stmt|;
block|}
comment|/* 	 *  Fill in target structure. 	 *  Reinitialize usrsync. 	 *  Reinitialize usrwide. 	 *  Prepare sync negotiation according to actual SCSI bus mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|uval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  Download SCSI SCRIPTS to on-chip RAM if present, 	 *  and start script processor. 	 */
if|if
condition|(
name|np
operator|->
name|ram_ba
condition|)
block|{
if|if
condition|(
name|sym_verbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading SCSI SCRIPTS.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ram_ws
operator|==
literal|8192
condition|)
block|{
name|memcpy_to_pci
argument_list|(
name|np
operator|->
name|ram_va
operator|+
literal|4096
argument_list|,
name|np
operator|->
name|scripth0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_mmws
argument_list|,
name|np
operator|->
name|scr_ram_seg
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_mmrs
argument_list|,
name|np
operator|->
name|scr_ram_seg
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_sfs
argument_list|,
name|np
operator|->
name|scr_ram_seg
argument_list|)
expr_stmt|;
name|phys
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|start64
argument_list|)
expr_stmt|;
block|}
else|else
name|phys
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|memcpy_to_pci
argument_list|(
name|np
operator|->
name|ram_va
argument_list|,
name|np
operator|->
name|script0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|phys
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|np
operator|->
name|istat_sem
operator|=
literal|0
expr_stmt|;
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|vtobus
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Notify the XPT of the event. 	 */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|np
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Get clock factor and sync divisor for a given   *  synchronous factor period.  */
end_comment

begin_function
specifier|static
name|int
name|sym_getsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|sfac
parameter_list|,
name|u_char
modifier|*
name|divp
parameter_list|,
name|u_char
modifier|*
name|fakp
parameter_list|)
block|{
name|u32
name|clk
init|=
name|np
operator|->
name|clock_khz
decl_stmt|;
comment|/* SCSI clock frequency in kHz	*/
name|int
name|div
init|=
name|np
operator|->
name|clock_divn
decl_stmt|;
comment|/* Number of divisors supported	*/
name|u32
name|fak
decl_stmt|;
comment|/* Sync factor in sxfer		*/
name|u32
name|per
decl_stmt|;
comment|/* Period in tenths of ns	*/
name|u32
name|kpc
decl_stmt|;
comment|/* (per * clk)			*/
name|int
name|ret
decl_stmt|;
comment|/* 	 *  Compute the synchronous period in tenths of nano-seconds 	 */
if|if
condition|(
name|dt
operator|&&
name|sfac
operator|<=
literal|9
condition|)
name|per
operator|=
literal|125
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|<=
literal|10
condition|)
name|per
operator|=
literal|250
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|==
literal|11
condition|)
name|per
operator|=
literal|303
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|==
literal|12
condition|)
name|per
operator|=
literal|500
expr_stmt|;
else|else
name|per
operator|=
literal|40
operator|*
name|sfac
expr_stmt|;
name|ret
operator|=
name|per
expr_stmt|;
name|kpc
operator|=
name|per
operator|*
name|clk
expr_stmt|;
if|if
condition|(
name|dt
condition|)
name|kpc
operator|<<=
literal|1
expr_stmt|;
comment|/* 	 *  For earliest C10, the extra clocks does not apply  	 *  to CRC cycles, so it may be safe not to use them. 	 *  Note that this limits the lowest sync data transfer  	 *  to 5 Mega-transfers per second and may result in 	 *  using higher clock divisors. 	 */
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_U3EN
operator|)
operator|)
operator|==
name|FE_C10
condition|)
block|{
comment|/* 		 *  Look for the lowest clock divisor that allows an  		 *  output speed not faster than the period. 		 */
while|while
condition|(
operator|--
name|div
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|kpc
operator|>
operator|(
name|div_10M
index|[
name|div
index|]
operator|<<
literal|2
operator|)
condition|)
block|{
operator|++
name|div
expr_stmt|;
break|break;
block|}
block|}
name|fak
operator|=
literal|0
expr_stmt|;
comment|/* No extra clocks */
if|if
condition|(
name|div
operator|==
name|np
operator|->
name|clock_divn
condition|)
block|{
comment|/* Are we too fast ? */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|divp
operator|=
name|div
expr_stmt|;
operator|*
name|fakp
operator|=
name|fak
expr_stmt|;
return|return
name|ret
return|;
block|}
endif|#
directive|endif
comment|/* 	 *  Look for the greatest clock divisor that allows an  	 *  input speed faster than the period. 	 */
while|while
condition|(
operator|--
name|div
operator|>=
literal|0
condition|)
if|if
condition|(
name|kpc
operator|>=
operator|(
name|div_10M
index|[
name|div
index|]
operator|<<
literal|2
operator|)
condition|)
break|break;
comment|/* 	 *  Calculate the lowest clock factor that allows an output  	 *  speed not faster than the period, and the max output speed. 	 *  If fak>= 1 we will set both XCLKH_ST and XCLKH_DT. 	 *  If fak>= 2 we will also set XCLKS_ST and XCLKS_DT. 	 */
if|if
condition|(
name|dt
condition|)
block|{
name|fak
operator|=
operator|(
name|kpc
operator|-
literal|1
operator|)
operator|/
operator|(
name|div_10M
index|[
name|div
index|]
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|-
literal|2
expr_stmt|;
comment|/* ret = ((2+fak)*div_10M[div])/np->clock_khz; */
block|}
else|else
block|{
name|fak
operator|=
operator|(
name|kpc
operator|-
literal|1
operator|)
operator|/
name|div_10M
index|[
name|div
index|]
operator|+
literal|1
operator|-
literal|4
expr_stmt|;
comment|/* ret = ((4+fak)*div_10M[div])/np->clock_khz; */
block|}
comment|/* 	 *  Check against our hardware limits, or bugs :). 	 */
if|if
condition|(
name|fak
operator|<
literal|0
condition|)
block|{
name|fak
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fak
operator|>
literal|2
condition|)
block|{
name|fak
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 *  Compute and return sync parameters. 	 */
operator|*
name|divp
operator|=
name|div
expr_stmt|;
operator|*
name|fakp
operator|=
name|fak
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  We received a WDTR.  *  Let everything be aware of the changes.  */
end_comment

begin_function
specifier|static
name|void
name|sym_setwide
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|cp
operator|->
name|cam_ccb
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|sym_settrans
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|wide
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCSI layer about the new transfer parameters. 	 */
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|neg
operator|.
name|bus_width
operator|=
name|wide
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
name|neg
operator|.
name|sync_period
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|sync_offset
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  We received a SDTR.  *  Let everything be aware of the changes.  */
end_comment

begin_function
specifier|static
name|void
name|sym_setsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|cp
operator|->
name|cam_ccb
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|u_char
name|wide
init|=
operator|(
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|&
name|EWS
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|sym_settrans
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCSI layer about the new transfer parameters. 	 */
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|per
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
name|neg
operator|.
name|sync_period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
expr_stmt|;
name|neg
operator|.
name|sync_offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  We received a PPR.  *  Let everything be aware of the changes.  */
end_comment

begin_function
specifier|static
name|void
name|sym_setpprot
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|cp
operator|->
name|cam_ccb
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|sym_settrans
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCSI layer about the new transfer parameters. 	 */
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|per
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|dt
condition|?
name|PPR_OPT_DT
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
name|neg
operator|.
name|sync_period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
expr_stmt|;
name|neg
operator|.
name|sync_offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
expr_stmt|;
name|neg
operator|.
name|bus_width
operator|=
name|wide
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
name|neg
operator|.
name|valid
operator|=
name|CCB_TRANS_BUS_WIDTH_VALID
operator||
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
end_ifdef

begin_comment
comment|/*  *  Patch a script address if it points to a data script to   *  the same position within another data script.  *  Accept up to endp + 8, due to the SCR_CALL   *  after end data script that moves to goalp.  */
end_comment

begin_function
specifier|static
name|u32
name|sym_chgp
parameter_list|(
name|u32
name|scrp
parameter_list|,
name|u32
name|old_endp
parameter_list|,
name|u32
name|new_endp
parameter_list|)
block|{
name|scrp
operator|=
name|scr_to_cpu
argument_list|(
name|scrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_endp
operator|!=
name|new_endp
operator|&&
name|old_endp
operator|+
literal|8
operator|-
name|scrp
operator|<=
name|SYMCONF_MAX_SG
operator|*
literal|8
operator|+
literal|8
condition|)
name|scrp
operator|=
name|new_endp
operator|+
literal|8
operator|-
operator|(
name|old_endp
operator|+
literal|8
operator|-
name|scrp
operator|)
expr_stmt|;
return|return
name|cpu_to_scr
argument_list|(
name|scrp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Called on negotiation, since the device may have   *  changed mind about DT versus ST data transfers.  *  Patches all data scripts address for a CCB, to fit   *  the new data script, if needed.  */
end_comment

begin_function
specifier|static
name|u32
name|sym_chg_ccb_scrp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u32
name|scrp
parameter_list|)
block|{
name|u32
name|old_endp
init|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|goalp
argument_list|)
operator|-
literal|8
decl_stmt|;
name|u32
name|new_endp
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Locate the data script we have to move to: 	 *  Given the end data script pointer value (old)  	 *  and the new type of transfert (DT/ST) deduce  	 *  the new end data script pointer(s). 	 */
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|old_endp
operator|==
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|data_in2
argument_list|)
condition|)
name|new_endp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|dt_data_in2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|old_endp
operator|==
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|data_out2
argument_list|)
condition|)
name|new_endp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|dt_data_out2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|old_endp
operator|==
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|dt_data_in2
argument_list|)
condition|)
name|new_endp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|data_in2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|old_endp
operator|==
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|dt_data_out2
argument_list|)
condition|)
name|new_endp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|data_out2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If the end data script pointer was not  	 *  inside a data script or if we must stay  	 *  in the same data script, we are done. 	 */
if|if
condition|(
operator|!
name|new_endp
operator|||
name|new_endp
operator|==
name|old_endp
condition|)
goto|goto
name|out
goto|;
comment|/* 	 *  Move to new data script all data script pointers  	 *  that point inside the previous data script. 	 */
name|cp
operator|->
name|phys
operator|.
name|savep
operator|=
name|sym_chgp
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|savep
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|lastp
operator|=
name|sym_chgp
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|lastp
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|goalp
operator|=
name|sym_chgp
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|goalp
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|pm0
operator|.
name|ret
operator|=
name|sym_chgp
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|pm1
operator|.
name|ret
operator|=
name|sym_chgp
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|startp
operator|=
name|sym_chgp
argument_list|(
name|cp
operator|->
name|startp
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
expr_stmt|;
comment|/* 	 *  Also move an additionnal script pointer  	 *  if passed by user. For the current CCB,  	 *  this is useful to know the new value for   	 *  TEMP register (current data script address). 	 */
if|if
condition|(
name|scrp
condition|)
name|scrp
operator|=
name|scr_to_cpu
argument_list|(
name|sym_chgp
argument_list|(
name|scrp
argument_list|,
name|old_endp
argument_list|,
name|new_endp
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|scrp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMCONF_BROKEN_U3EN_SUPPORT */
end_comment

begin_comment
comment|/*  *  Switch trans mode for current job and it's target.  */
end_comment

begin_function
specifier|static
name|void
name|sym_settrans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|u_char
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|u_char
name|sval
decl_stmt|,
name|wval
decl_stmt|,
name|uval
decl_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
name|assert
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ccb
condition|)
return|return;
name|assert
argument_list|(
name|target
operator|==
operator|(
name|cp
operator|->
name|target
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|sval
operator|=
name|tp
operator|->
name|sval
expr_stmt|;
name|wval
operator|=
name|tp
operator|->
name|wval
expr_stmt|;
name|uval
operator|=
name|tp
operator|->
name|uval
expr_stmt|;
if|#
directive|if
literal|0
block|printf("XXXXX sval=%x wval=%x uval=%x (%x)\n",  		sval, wval, uval, np->rv_scntl3);
endif|#
directive|endif
comment|/* 	 *  Set the offset. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
name|sval
operator|=
operator|(
name|sval
operator|&
operator|~
literal|0x1f
operator|)
operator||
name|ofs
expr_stmt|;
else|else
name|sval
operator|=
operator|(
name|sval
operator|&
operator|~
literal|0x3f
operator|)
operator||
name|ofs
expr_stmt|;
comment|/* 	 *  Set the sync divisor and extra clock factor. 	 */
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
block|{
name|wval
operator|=
operator|(
name|wval
operator|&
operator|~
literal|0x70
operator|)
operator||
operator|(
operator|(
name|div
operator|+
literal|1
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
name|sval
operator|=
operator|(
name|sval
operator|&
operator|~
literal|0xe0
operator|)
operator||
operator|(
name|fak
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
block|{
name|uval
operator|=
name|uval
operator|&
operator|~
operator|(
name|XCLKH_ST
operator||
name|XCLKH_DT
operator||
name|XCLKS_ST
operator||
name|XCLKS_DT
operator|)
expr_stmt|;
if|if
condition|(
name|fak
operator|>=
literal|1
condition|)
name|uval
operator||=
operator|(
name|XCLKH_ST
operator||
name|XCLKH_DT
operator|)
expr_stmt|;
if|if
condition|(
name|fak
operator|>=
literal|2
condition|)
name|uval
operator||=
operator|(
name|XCLKS_ST
operator||
name|XCLKS_DT
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 *  Set the bus width. 	 */
name|wval
operator|=
name|wval
operator|&
operator|~
name|EWS
expr_stmt|;
if|if
condition|(
name|wide
operator|!=
literal|0
condition|)
name|wval
operator||=
name|EWS
expr_stmt|;
comment|/* 	 *  Set misc. ultra enable bits. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|uval
operator|=
name|uval
operator|&
operator|~
name|U3EN
expr_stmt|;
if|if
condition|(
name|dt
condition|)
block|{
ifndef|#
directive|ifndef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|assert
argument_list|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
argument_list|)
expr_stmt|;
else|#
directive|else
name|uval
operator||=
name|U3EN
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|wval
operator|=
name|wval
operator|&
operator|~
name|ULTRA
expr_stmt|;
if|if
condition|(
name|per
operator|<=
literal|12
condition|)
name|wval
operator||=
name|ULTRA
expr_stmt|;
block|}
comment|/* 	 *   Stop there if sync parameters are unchanged. 	 */
if|if
condition|(
name|tp
operator|->
name|sval
operator|==
name|sval
operator|&&
name|tp
operator|->
name|wval
operator|==
name|wval
operator|&&
name|tp
operator|->
name|uval
operator|==
name|uval
condition|)
return|return;
name|tp
operator|->
name|sval
operator|=
name|sval
expr_stmt|;
name|tp
operator|->
name|wval
operator|=
name|wval
expr_stmt|;
name|tp
operator|->
name|uval
operator|=
name|uval
expr_stmt|;
comment|/* 	 *  Disable extended Sreq/Sack filtering if per< 50. 	 *  Not supported on the C1010. 	 */
if|if
condition|(
name|per
operator|<
literal|50
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
name|OUTOFFB
argument_list|(
name|nc_stest2
argument_list|,
name|EXT
argument_list|)
expr_stmt|;
comment|/* 	 *  set actual value and sync_status 	 */
name|OUTB
argument_list|(
name|nc_sxfer
argument_list|,
name|tp
operator|->
name|sval
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|tp
operator|->
name|wval
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
operator|)
condition|)
block|{
name|u32
name|temp
init|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
decl_stmt|;
name|temp
operator|=
name|sym_chg_ccb_scrp
argument_list|(
name|np
argument_list|,
name|dt
argument_list|,
name|cp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|OUTB
argument_list|(
name|nc_scntl4
argument_list|,
name|tp
operator|->
name|uval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  patch ALL ccbs of this target. 	 */
for|for
control|(
name|cp
operator|=
name|np
operator|->
name|ccbc
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_ccb
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_IDLE
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|target
operator|!=
name|target
condition|)
continue|continue;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|wval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|sval
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl4
operator|=
name|tp
operator|->
name|uval
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
operator|)
condition|)
operator|(
name|void
operator|)
name|sym_chg_ccb_scrp
argument_list|(
name|np
argument_list|,
name|dt
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  log message for real hard errors  *  *  sym0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).  *  	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.  *  *  exception register:  *  	ds:	dstat  *  	si:	sist  *  *  SCSI bus lines:  *  	so:	control lines as driven by chip.  *  	si:	control lines as seen by chip.  *  	sd:	scsi data lines as seen by chip.  *  *  wide/fastmode:  *  	sxfer:	(see the manual)  *  	scntl3:	(see the manual)  *  *  current script command:  *  	dsp:	script adress (relative to start of script).  *  	dbc:	first word of script command.  *  *  First 24 register of the chip:  *  	r0..rf  */
end_comment

begin_function
specifier|static
name|void
name|sym_log_hard_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|,
name|u_char
name|dstat
parameter_list|)
block|{
name|u32
name|dsp
decl_stmt|;
name|int
name|script_ofs
decl_stmt|;
name|int
name|script_size
decl_stmt|;
name|char
modifier|*
name|script_name
decl_stmt|;
name|u_char
modifier|*
name|script_base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|script_ba
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|script_ba
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
condition|)
block|{
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|script_ba
expr_stmt|;
name|script_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
expr_stmt|;
name|script_base
operator|=
operator|(
name|u_char
operator|*
operator|)
name|np
operator|->
name|script0
expr_stmt|;
name|script_name
operator|=
literal|"script"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|scripth_ba
operator|<
name|dsp
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|scripth_ba
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
condition|)
block|{
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|scripth_ba
expr_stmt|;
name|script_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
expr_stmt|;
name|script_base
operator|=
operator|(
name|u_char
operator|*
operator|)
name|np
operator|->
name|scripth0
expr_stmt|;
name|script_name
operator|=
literal|"scripth"
expr_stmt|;
block|}
else|else
block|{
name|script_ofs
operator|=
name|dsp
expr_stmt|;
name|script_size
operator|=
literal|0
expr_stmt|;
name|script_base
operator|=
literal|0
expr_stmt|;
name|script_name
operator|=
literal|"mem"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_socl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sbdl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sxfer
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
argument_list|,
name|script_name
argument_list|,
name|script_ofs
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|script_ofs
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|script_ofs
operator|<
name|script_size
condition|)
block|{
name|printf
argument_list|(
literal|"%s: script cmd = %08x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|scr_to_cpu
argument_list|(
operator|(
name|int
operator|)
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|script_base
operator|+
name|script_ofs
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: regdump:"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|INB_OFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
comment|/* 	 *  PCI BUS error, read the PCI ststus register. 	 */
if|if
condition|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator|)
condition|)
block|{
name|u_short
name|pci_sts
decl_stmt|;
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|pci_sts
operator|=
name|pci_read_config
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_sts
operator|=
name|pci_cfgread
argument_list|(
name|np
operator|->
name|pci_tag
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pci_sts
operator|&
literal|0xf900
condition|)
block|{
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|pci_write_config
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_sts
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_cfgwrite
argument_list|(
name|np
operator|->
name|pci_tag
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_sts
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s: PCI STATUS = 0x%04x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|pci_sts
operator|&
literal|0xf900
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  chip interrupt handler  *  *  In normal situations, interrupt conditions occur one at   *  a time. But when something bad happens on the SCSI BUS,   *  the chip may raise several interrupt flags before   *  stopping and interrupting the CPU. The additionnal   *  interrupt flags are stacked in some extra registers   *  after the SIP and/or DIP flag has been raised in the   *  ISTAT. After the CPU has read the interrupt condition   *  flag from SIST or DSTAT, the chip unstacks the other   *  interrupt flags and sets the corresponding bits in   *  SIST or DSTAT. Since the chip starts stacking once the   *  SIP or DIP flag is set, there is a small window of time   *  where the stacking does not occur.  *  *  Typically, multiple interrupt conditions may happen in   *  the following situations:  *  *  - SCSI parity error + Phase mismatch  (PAR|MA)  *    When an parity error is detected in input phase   *    and the device switches to msg-in phase inside a   *    block MOV.  *  - SCSI parity error + Unexpected disconnect (PAR|UDC)  *    When a stupid device does not want to handle the   *    recovery of an SCSI parity error.  *  - Some combinations of STO, PAR, UDC, ...  *    When using non compliant SCSI stuff, when user is   *    doing non compliant hot tampering on the BUS, when   *    something really bad happens to a device, etc ...  *  *  The heuristic suggested by SYMBIOS to handle   *  multiple interrupts is to try unstacking all   *  interrupts conditions and to handle them on some   *  priority based on error severity.  *  This will work when the unstacking has been   *  successful, but we cannot be 100 % sure of that,   *  since the CPU may have been faster to unstack than   *  the chip is able to stack. Hmmm ... But it seems that   *  such a situation is very unlikely to happen.  *  *  If this happen, for example STO caught by the CPU   *  then UDC happenning before the CPU have restarted   *  the SCRIPTS, the driver may wrongly complete the   *  same command on UDC, since the SCRIPTS didn't restart   *  and the DSA still points to the same command.  *  We avoid this situation by setting the DSA to an   *  invalid value when the CCB is completed and before   *  restarting the SCRIPTS.  *  *  Another issue is that we need some section of our   *  recovery procedures to be somehow uninterruptible but   *  the SCRIPTS processor does not provides such a   *  feature. For this reason, we handle recovery preferently   *  from the C code and check against some SCRIPTS critical   *  sections from the C code.  *  *  Hopefully, the interrupt handling of the driver is now   *  able to resist to weird BUS error conditions, but donnot   *  ask me for any guarantee that it will never fail. :-)  *  Use at your own decision and risk.  */
end_comment

begin_function
specifier|static
name|void
name|sym_intr1
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|istat
decl_stmt|,
name|istatc
decl_stmt|;
name|u_char
name|dstat
decl_stmt|;
name|u_short
name|sist
decl_stmt|;
comment|/* 	 *  interrupt on the fly ? 	 */
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|&
name|INTF
condition|)
block|{
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
operator|(
name|istat
operator|&
name|SIGP
operator|)
operator||
name|INTF
operator||
name|np
operator|->
name|istat_sem
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
comment|/* DUMMY READ */
endif|#
directive|endif
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"F "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sym_wakeup_done
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|istat
operator|&
operator|(
name|SIP
operator||
name|DIP
operator|)
operator|)
condition|)
return|return;
if|#
directive|if
literal|0
comment|/* We should never get this one */
block|if (istat& CABRT) 		OUTB (nc_istat, CABRT);
endif|#
directive|endif
comment|/* 	 *  PAR and MA interrupts may occur at the same time, 	 *  and we need to know of both in order to handle  	 *  this situation properly. We try to unstack SCSI  	 *  interrupts for that reason. BTW, I dislike a LOT  	 *  such a loop inside the interrupt routine. 	 *  Even if DMA interrupt stacking is very unlikely to  	 *  happen, we also try unstacking these ones, since  	 *  this has no performance impact. 	 */
name|sist
operator|=
literal|0
expr_stmt|;
name|dstat
operator|=
literal|0
expr_stmt|;
name|istatc
operator|=
name|istat
expr_stmt|;
do|do
block|{
if|if
condition|(
name|istatc
operator|&
name|SIP
condition|)
name|sist
operator||=
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
if|if
condition|(
name|istatc
operator|&
name|DIP
condition|)
name|dstat
operator||=
name|INB
argument_list|(
name|nc_dstat
argument_list|)
expr_stmt|;
name|istatc
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
name|istat
operator||=
name|istatc
expr_stmt|;
block|}
do|while
condition|(
name|istatc
operator|&
operator|(
name|SIP
operator||
name|DIP
operator|)
condition|)
do|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"<%d|%x:%x|%x:%x>"
argument_list|,
operator|(
name|int
operator|)
name|INB
argument_list|(
name|nc_scr0
argument_list|)
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  First, interrupts we want to service cleanly. 	 * 	 *  Phase mismatch (MA) is the most frequent interrupt  	 *  for chip earlier than the 896 and so we have to service  	 *  it as quickly as possible. 	 *  A SCSI parity error (PAR) may be combined with a phase  	 *  mismatch condition (MA). 	 *  Programmed interrupts (SIR) are used to call the C code  	 *  from SCRIPTS. 	 *  The single step interrupt (SSI) is not used in this  	 *  driver. 	 */
if|if
condition|(
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|SGE
operator||
name|UDC
operator||
name|SBMC
operator||
name|RST
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sist
operator|&
name|PAR
condition|)
name|sym_int_par
argument_list|(
name|np
argument_list|,
name|sist
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sist
operator|&
name|MA
condition|)
name|sym_int_ma
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dstat
operator|&
name|SIR
condition|)
name|sym_int_sir
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dstat
operator|&
name|SSI
condition|)
name|OUTONB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
else|else
goto|goto
name|unknown_int
goto|;
return|return;
block|}
empty_stmt|;
comment|/* 	 *  Now, interrupts that donnot happen in normal  	 *  situations and that we may need to recover from. 	 * 	 *  On SCSI RESET (RST), we reset everything. 	 *  On SCSI BUS MODE CHANGE (SBMC), we complete all  	 *  active CCBs with RESET status, prepare all devices  	 *  for negotiating again and restart the SCRIPTS. 	 *  On STO and UDC, we complete the CCB with the corres-  	 *  ponding status and restart the SCRIPTS. 	 */
if|if
condition|(
name|sist
operator|&
name|RST
condition|)
block|{
name|sym_init
argument_list|(
name|np
argument_list|,
literal|1
argument_list|,
name|sym_verbose
condition|?
literal|"scsi reset"
else|:
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
if|if
condition|(
operator|!
operator|(
name|sist
operator|&
operator|(
name|GEN
operator||
name|HTH
operator||
name|SGE
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sist
operator|&
name|SBMC
condition|)
name|sym_int_sbmc
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sist
operator|&
name|STO
condition|)
name|sym_int_sto
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sist
operator|&
name|UDC
condition|)
name|sym_int_udc
argument_list|(
name|np
argument_list|)
expr_stmt|;
else|else
goto|goto
name|unknown_int
goto|;
return|return;
block|}
empty_stmt|;
comment|/* 	 *  Now, interrupts we are not able to recover cleanly. 	 * 	 *  Log message for hard errors. 	 *  Reset everything. 	 */
name|sym_log_hard_error
argument_list|(
name|np
argument_list|,
name|sist
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sist
operator|&
operator|(
name|GEN
operator||
name|HTH
operator||
name|SGE
operator|)
operator|)
operator|||
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|unknown_int
label|:
comment|/* 	 *  We just miss the cause of the interrupt. :( 	 *  Print a message. The timeout will do the real work. 	 */
name|printf
argument_list|(
literal|"%s: unknown interrupt(s) ignored, "
literal|"ISTAT=0x%x DSTAT=0x%x SIST=0x%x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|istat
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|sym_intr1
argument_list|(
operator|(
name|hcb_p
operator|)
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|int
name|s
init|=
name|splcam
argument_list|()
decl_stmt|;
name|sym_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  generic recovery from scsi interrupt  *  *  The doc says that when the chip gets an SCSI interrupt,  *  it tries to stop in an orderly fashion, by completing   *  an instruction fetch that had started or by flushing   *  the DMA fifo for a write to memory that was executing.  *  Such a fashion is not enough to know if the instruction   *  that was just before the current DSP value has been   *  executed or not.  *  *  There are some small SCRIPTS sections that deal with   *  the start queue and the done queue that may break any   *  assomption from the C code if we are interrupted   *  inside, so we reset if this happens. Btw, since these   *  SCRIPTS sections are executed while the SCRIPTS hasn't   *  started SCSI operations, it is very unlikely to happen.  *  *  All the driver data structures are supposed to be   *  allocated from the same 4 GB memory window, so there   *  is a 1 to 1 relationship between DSA and driver data   *  structures. Since we are careful :) to invalidate the   *  DSA when we complete a command or when the SCRIPTS   *  pushes a DSA into a queue, we can trust it when it   *  points to a CCB.  */
end_comment

begin_function
specifier|static
name|void
name|sym_recover_scsi_int
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|hsts
parameter_list|)
block|{
name|u32
name|dsp
init|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
decl_stmt|;
name|u32
name|dsa
init|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
decl_stmt|;
name|ccb_p
name|cp
init|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
decl_stmt|;
comment|/* 	 *  If we haven't been interrupted inside the SCRIPTS  	 *  critical pathes, we can safely restart the SCRIPTS  	 *  and trust the DSA value if it matches a CCB. 	 */
if|if
condition|(
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|getjob_begin
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|getjob_end
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|ungetjob
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|reselect
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|sel_for_abort
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|sel_for_abort_1
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|done
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|done_end
argument_list|)
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
comment|/* 		 *  If we have a CCB, let the SCRIPTS call us back for  		 *  the handling of the error with SCRATCHA filled with  		 *  STARTPOS. This way, we will be able to freeze the  		 *  device queue and requeue awaiting IOs. 		 */
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|hsts
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|complete_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *  Otherwise just restart the SCRIPTS. 		 */
else|else
block|{
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
goto|goto
name|reset_all
goto|;
return|return;
name|reset_all
label|:
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for selection timeout  */
end_comment

begin_function
name|void
name|sym_int_sto
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u32
name|dsp
init|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"T"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|==
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|wf_sel_done
argument_list|)
operator|+
literal|8
condition|)
name|sym_recover_scsi_int
argument_list|(
name|np
argument_list|,
name|HS_SEL_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for unexpected disconnect  */
end_comment

begin_function
name|void
name|sym_int_udc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected disconnect\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|sym_recover_scsi_int
argument_list|(
name|np
argument_list|,
name|HS_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for SCSI bus mode change  *  *  spi2-r12 11.2.3 says a transceiver mode change must   *  generate a reset event and a device that detects a reset   *  event shall initiate a hard reset. It says also that a  *  device that detects a mode change shall set data transfer   *  mode to eight bit asynchronous, etc...  *  So, just reinitializing all except chip should be enough.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_sbmc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|scsi_mode
init|=
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|SMODE
decl_stmt|;
name|printf
argument_list|(
literal|"%s: SCSI bus mode change from %x to %x.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|scsi_mode
argument_list|,
name|scsi_mode
argument_list|)
expr_stmt|;
name|np
operator|->
name|scsi_mode
operator|=
name|scsi_mode
expr_stmt|;
comment|/* 	 *  Should suspend command processing for 1 second and  	 *  reinitialize all except the chip. 	 */
name|sym_init
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|sym_verbose
condition|?
literal|"scsi mode change"
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for SCSI parity error.  *  *  When the chip detects a SCSI parity error and is   *  currently executing a (CH)MOV instruction, it does   *  not interrupt immediately, but tries to finish the   *  transfer of the current scatter entry before   *  interrupting. The following situations may occur:  *  *  - The complete scatter entry has been transferred   *    without the device having changed phase.  *    The chip will then interrupt with the DSP pointing   *    to the instruction that follows the MOV.  *  *  - A phase mismatch occurs before the MOV finished   *    and phase errors are to be handled by the C code.  *    The chip will then interrupt with both PAR and MA   *    conditions set.  *  *  - A phase mismatch occurs before the MOV finished and   *    phase errors are to be handled by SCRIPTS.  *    The chip will load the DSP with the phase mismatch   *    JUMP address and interrupt the host processor.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_par
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|)
block|{
name|u_char
name|hsts
init|=
name|INB
argument_list|(
name|HS_PRT
argument_list|)
decl_stmt|;
name|u32
name|dsp
init|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
decl_stmt|;
name|u32
name|dbc
init|=
name|INL
argument_list|(
name|nc_dbc
argument_list|)
decl_stmt|;
name|u32
name|dsa
init|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
decl_stmt|;
name|u_char
name|sbcl
init|=
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
decl_stmt|;
name|u_char
name|cmd
init|=
name|dbc
operator|>>
literal|24
decl_stmt|;
name|int
name|phase
init|=
name|cmd
operator|&
literal|7
decl_stmt|;
name|ccb_p
name|cp
init|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|hsts
argument_list|,
name|dbc
argument_list|,
name|sbcl
argument_list|)
expr_stmt|;
comment|/* 	 *  Check that the chip is connected to the SCSI BUS. 	 */
if|if
condition|(
operator|!
operator|(
name|INB
argument_list|(
name|nc_scntl1
argument_list|)
operator|&
name|ISCON
operator|)
condition|)
block|{
name|sym_recover_scsi_int
argument_list|(
name|np
argument_list|,
name|HS_UNEXPECTED
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  If the nexus is not clearly identified, reset the bus. 	 *  We will try to do better later. 	 */
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|reset_all
goto|;
comment|/* 	 *  Check instruction was a MOV, direction was INPUT and  	 *  ATN is asserted. 	 */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xc0
operator|)
operator|||
operator|!
operator|(
name|phase
operator|&
literal|1
operator|)
operator|||
operator|!
operator|(
name|sbcl
operator|&
literal|0x8
operator|)
condition|)
goto|goto
name|reset_all
goto|;
comment|/* 	 *  Keep track of the parity error. 	 */
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_PARITY_ERR
expr_stmt|;
comment|/* 	 *  Prepare the message to send to the device. 	 */
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
operator|(
name|phase
operator|==
literal|7
operator|)
condition|?
name|M_PARITY
else|:
name|M_ID_ERROR
expr_stmt|;
comment|/* 	 *  If the old phase was DATA IN phase, we have to deal with 	 *  the 3 situations described above. 	 *  For other input phases (MSG IN and STATUS), the device  	 *  must resend the whole thing that failed parity checking  	 *  or signal error. So, jumping to dispatcher should be OK. 	 */
if|if
condition|(
name|phase
operator|==
literal|1
condition|)
block|{
comment|/* Phase mismatch handled by SCRIPTS */
if|if
condition|(
name|dsp
operator|==
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|pm_handle
argument_list|)
condition|)
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
comment|/* Phase mismatch handled by the C code */
elseif|else
if|if
condition|(
name|sist
operator|&
name|MA
condition|)
name|sym_int_ma
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* No phase mismatch occurred */
else|else
block|{
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reset_all
label|:
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for phase errors.  *  *  We have to construct a new transfer descriptor,  *  to transfer the rest of the current block.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_ma
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u32
name|dbc
decl_stmt|;
name|u32
name|rest
decl_stmt|;
name|u32
name|dsp
decl_stmt|;
name|u32
name|dsa
decl_stmt|;
name|u32
name|nxtdsp
decl_stmt|;
name|u32
modifier|*
name|vdsp
decl_stmt|;
name|u32
name|oadr
decl_stmt|,
name|olen
decl_stmt|;
name|u32
modifier|*
name|tblp
decl_stmt|;
name|u32
name|newcmd
decl_stmt|;
name|u_int
name|delta
decl_stmt|;
name|u_char
name|cmd
decl_stmt|;
name|u_char
name|hflags
decl_stmt|,
name|hflags0
decl_stmt|;
name|struct
name|sym_pmc
modifier|*
name|pm
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
name|dbc
operator|=
name|INL
argument_list|(
name|nc_dbc
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|dbc
operator|>>
literal|24
expr_stmt|;
name|rest
operator|=
name|dbc
operator|&
literal|0xffffff
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  locate matching cp if any. 	 */
name|cp
operator|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
comment|/* 	 *  Donnot take into account dma fifo and various buffers in  	 *  INPUT phase since the chip flushes everything before  	 *  raising the MA interrupt for interrupted INPUT phases. 	 *  For DATA IN phase, we will check for the SWIDE later. 	 */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|!=
literal|1
condition|)
block|{
name|u_char
name|ss0
decl_stmt|,
name|ss2
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DFBC
condition|)
name|delta
operator|=
name|INW
argument_list|(
name|nc_dfbc
argument_list|)
expr_stmt|;
else|else
block|{
name|u32
name|dfifo
decl_stmt|;
comment|/* 			 * Read DFIFO, CTEST[4-6] using 1 PCI bus ownership. 			 */
name|dfifo
operator|=
name|INL
argument_list|(
name|nc_dfifo
argument_list|)
expr_stmt|;
comment|/* 			 *  Calculate remaining bytes in DMA fifo. 			 *  (CTEST5 = dfifo>> 16) 			 */
if|if
condition|(
name|dfifo
operator|&
operator|(
name|DFS
operator|<<
literal|16
operator|)
condition|)
name|delta
operator|=
operator|(
operator|(
operator|(
operator|(
name|dfifo
operator|>>
literal|8
operator|)
operator|&
literal|0x300
operator|)
operator||
operator|(
name|dfifo
operator|&
literal|0xff
operator|)
operator|)
operator|-
name|rest
operator|)
operator|&
literal|0x3ff
expr_stmt|;
else|else
name|delta
operator|=
operator|(
operator|(
name|dfifo
operator|&
literal|0xff
operator|)
operator|-
name|rest
operator|)
operator|&
literal|0x7f
expr_stmt|;
block|}
comment|/* 		 *  The data in the dma fifo has not been transfered to 		 *  the target -> add the amount to the rest 		 *  and clear the data. 		 *  Check the sstat2 register in case of wide transfer. 		 */
name|rest
operator|+=
name|delta
expr_stmt|;
name|ss0
operator|=
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss0
operator|&
name|OLF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
if|if
condition|(
name|ss0
operator|&
name|ORF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|&
name|EWS
operator|)
condition|)
block|{
name|ss2
operator|=
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss2
operator|&
name|OLF1
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
if|if
condition|(
name|ss2
operator|&
name|ORF1
condition|)
name|rest
operator|++
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		 *  Clear fifos. 		 */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* scsi fifo */
block|}
comment|/* 	 *  log the information 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_TINY
operator||
name|DEBUG_PHASE
operator|)
condition|)
name|printf
argument_list|(
literal|"P%x%x RL=%d D=%d "
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
operator|&
literal|7
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|,
operator|(
name|unsigned
operator|)
name|delta
argument_list|)
expr_stmt|;
comment|/* 	 *  try to find the interrupted script command, 	 *  and the address at which to continue. 	 */
name|vdsp
operator|=
literal|0
expr_stmt|;
name|nxtdsp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|script_ba
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|script_ba
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
condition|)
block|{
name|vdsp
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|script0
operator|+
operator|(
name|dsp
operator|-
name|np
operator|->
name|script_ba
operator|-
literal|8
operator|)
operator|)
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|scripth_ba
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|scripth_ba
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
condition|)
block|{
name|vdsp
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|scripth0
operator|+
operator|(
name|dsp
operator|-
name|np
operator|->
name|scripth_ba
operator|-
literal|8
operator|)
operator|)
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
comment|/* 	 *  log the information 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"\nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x "
argument_list|,
name|cp
argument_list|,
operator|(
name|unsigned
operator|)
name|dsp
argument_list|,
operator|(
name|unsigned
operator|)
name|nxtdsp
argument_list|,
name|vdsp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|vdsp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: interrupted SCRIPT address not found.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reset_all
goto|;
block|}
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI phase error fixup: CCB already dequeued.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reset_all
goto|;
block|}
comment|/* 	 *  get old startaddress and old length. 	 */
name|oadr
operator|=
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x10
condition|)
block|{
comment|/* Table indirect */
name|tblp
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cp
operator|->
name|phys
operator|+
name|oadr
operator|)
expr_stmt|;
name|olen
operator|=
name|scr_to_cpu
argument_list|(
name|tblp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|oadr
operator|=
name|scr_to_cpu
argument_list|(
name|tblp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tblp
operator|=
operator|(
name|u32
operator|*
operator|)
literal|0
expr_stmt|;
name|olen
operator|=
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"OCMD=%x\nTBLP=%p OLEN=%x OADR=%x\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
argument_list|)
argument_list|,
name|tblp
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 *  check cmd against assumed interrupted script command. 	 */
if|if
condition|(
name|cmd
operator|!=
operator|(
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
operator|)
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"internal error: cmd=%02x != %02x=(vdsp[0]>> 24)\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cmd
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
goto|goto
name|reset_all
goto|;
block|}
empty_stmt|;
comment|/* 	 *  if old phase not dataphase, leave here. 	 */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|5
operator|)
operator|!=
operator|(
name|cmd
operator|&
literal|7
operator|)
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"phase change %x-%x %d@%08x resid=%d.\n"
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
operator|&
literal|7
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|)
expr_stmt|;
goto|goto
name|unexpected_phase
goto|;
block|}
empty_stmt|;
comment|/* 	 *  Choose the correct PM save area. 	 * 	 *  Look at the PM_SAVE SCRIPT if you want to understand  	 *  this stuff. The equivalent code is implemented in  	 *  SCRIPTS for the 895A and 896 that are able to handle  	 *  PM from the SCRIPTS processor. 	 */
name|hflags0
operator|=
name|INB
argument_list|(
name|HF_PRT
argument_list|)
expr_stmt|;
name|hflags
operator|=
name|hflags0
expr_stmt|;
if|if
condition|(
name|hflags
operator|&
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
condition|)
block|{
if|if
condition|(
name|hflags
operator|&
name|HF_IN_PM0
condition|)
name|nxtdsp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hflags
operator|&
name|HF_IN_PM1
condition|)
name|nxtdsp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|hflags
operator|&
name|HF_DP_SAVED
condition|)
name|hflags
operator|^=
name|HF_ACT_PM
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hflags
operator|&
name|HF_ACT_PM
operator|)
condition|)
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm0
expr_stmt|;
name|newcmd
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm1
expr_stmt|;
name|newcmd
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
expr_stmt|;
block|}
name|hflags
operator|&=
operator|~
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
expr_stmt|;
if|if
condition|(
name|hflags
operator|!=
name|hflags0
condition|)
name|OUTB
argument_list|(
name|HF_PRT
argument_list|,
name|hflags
argument_list|)
expr_stmt|;
comment|/* 	 *  fillin the phase mismatch context 	 */
name|pm
operator|->
name|sg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|oadr
operator|+
name|olen
operator|-
name|rest
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|pm
operator|->
name|ret
operator|=
name|cpu_to_scr
argument_list|(
name|nxtdsp
argument_list|)
expr_stmt|;
comment|/* 	 *  If we have a SWIDE, 	 *  - prepare the address to write the SWIDE from SCRIPTS, 	 *  - compute the SCRIPTS address to restart from, 	 *  - move current data pointer context by one byte. 	 */
name|nxtdsp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|==
literal|1
operator|&&
name|cp
operator|&&
operator|(
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|&
name|EWS
operator|)
operator|&&
operator|(
name|INB
argument_list|(
name|nc_scntl2
argument_list|)
operator|&
name|WSR
operator|)
condition|)
block|{
comment|/* 		 *  Hmmm... The device may want to also ignore  		 *  this residue but it must send immediately the 		 *  appropriate message. We snoop the SCSI BUS  		 *  and will just throw away this message from  		 *  SCRIPTS if the SWIDE is to be ignored. 		 */
if|if
condition|(
operator|(
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
operator|&
literal|7
operator|)
operator|==
literal|7
operator|&&
name|INB
argument_list|(
name|nc_sbdl
argument_list|)
operator|==
name|M_IGN_RESIDUE
condition|)
block|{
name|nxtdsp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|ign_i_w_r_msg
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *  We must grab the SWIDE. 		 *  We will use some complex SCRIPTS for that. 		 */
else|else
block|{
name|OUTL
argument_list|(
name|nc_scratcha
argument_list|,
name|pm
operator|->
name|sg
operator|.
name|addr
argument_list|)
expr_stmt|;
name|nxtdsp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|swide_ma_32
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
condition|)
block|{
name|OUTB
argument_list|(
name|nc_sbr
argument_list|,
operator|(
name|pm
operator|->
name|sg
operator|.
name|size
operator|>>
literal|24
operator|)
argument_list|)
expr_stmt|;
name|nxtdsp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|swide_ma_64
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *  Adjust our data pointer context. 			 */
operator|++
name|pm
operator|->
name|sg
operator|.
name|addr
expr_stmt|;
operator|--
name|pm
operator|->
name|sg
operator|.
name|size
expr_stmt|;
comment|/* 			 *  Hmmm... Could it be possible that a SWIDE that  			 *  is followed by a 1 byte CHMOV would lead to  			 *  a CHMOV(0). Anyway, we handle it by just  			 *  skipping context that would attempt a CHMOV(0). 			 */
if|if
condition|(
operator|!
name|pm
operator|->
name|sg
operator|.
name|size
condition|)
name|newcmd
operator|=
name|pm
operator|->
name|ret
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PM %x %x %x / %x %x %x.\n"
argument_list|,
name|hflags0
argument_list|,
name|hflags
argument_list|,
name|newcmd
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|addr
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|size
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Restart the SCRIPTS processor. 	 */
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|newcmd
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|nxtdsp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  Unexpected phase changes that occurs when the current phase  	 *  is not a DATA IN or DATA OUT phase are due to error conditions. 	 *  Such event may only happen when the SCRIPTS is using a  	 *  multibyte SCSI MOVE. 	 * 	 *  Phase change		Some possible cause 	 * 	 *  COMMAND  --> MSG IN	SCSI parity error detected by target. 	 *  COMMAND  --> STATUS	Bad command or refused by target. 	 *  MSG OUT  --> MSG IN     Message rejected by target. 	 *  MSG OUT  --> COMMAND    Bogus target that discards extended 	 *  			negotiation messages. 	 * 	 *  The code below does not care of the new phase and so  	 *  trusts the target. Why to annoy it ? 	 *  If the interrupted phase is COMMAND phase, we restart at 	 *  dispatcher. 	 *  If a target does not get all the messages after selection,  	 *  the code assumes blindly that the target discards extended  	 *  messages and clears the negotiation status. 	 *  If the target does not want all our response to negotiation, 	 *  we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids  	 *  bloat for such a should_not_happen situation). 	 *  In all other situation, we reset the BUS. 	 *  Are these assumptions reasonnable ? (Wait and see ...) 	 */
name|unexpected_phase
label|:
name|dsp
operator|-=
literal|8
expr_stmt|;
name|nxtdsp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|&
literal|7
condition|)
block|{
case|case
literal|2
case|:
comment|/* COMMAND phase */
name|nxtdsp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 3:
comment|/* STATUS  phase */
block|nxtdsp = SCRIPT_BA (np, dispatch); 		break;
endif|#
directive|endif
case|case
literal|6
case|:
comment|/* MSG OUT phase */
comment|/* 		 *  If the device may want to use untagged when we want  		 *  tagged, we prepare an IDENTIFY without disc. granted,  		 *  since we will not be able to handle reselect. 		 *  Otherwise, we just don't care. 		 */
if|if
condition|(
name|dsp
operator|==
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|send_ident
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
operator|&&
name|olen
operator|-
name|rest
operator|<=
literal|3
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|HS_BUSY
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
name|nxtdsp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|ident_break_atn
argument_list|)
expr_stmt|;
block|}
else|else
name|nxtdsp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|ident_break
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|==
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|send_wdtr
argument_list|)
operator|||
name|dsp
operator|==
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|send_sdtr
argument_list|)
operator|||
name|dsp
operator|==
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|send_ppr
argument_list|)
condition|)
block|{
name|nxtdsp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|nego_bad_phase
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case 7:
comment|/* MSG IN  phase */
block|nxtdsp = SCRIPT_BA (np, clrack); 		break;
endif|#
directive|endif
block|}
if|if
condition|(
name|nxtdsp
condition|)
block|{
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|nxtdsp
argument_list|)
expr_stmt|;
return|return;
block|}
name|reset_all
label|:
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Dequeue from the START queue all CCBs that match   *  a given target/lun/task condition (-1 means all),  *  and move them from the BUSY queue to the COMP queue   *  with CAM_REQUEUE_REQ status condition.  *  This function is used during error handling/recovery.  *  It is called with SCRIPTS not running.  */
end_comment

begin_function
specifier|static
name|int
name|sym_dequeue_from_squeue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
comment|/* 	 *  Make sure the starting index is within range. 	 */
name|assert
argument_list|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
literal|2
operator|*
name|MAX_QUEUE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Walk until end of START queue and dequeue every job  	 *  that matches the target/lun/task condition. 	 */
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|np
operator|->
name|squeueput
condition|)
block|{
name|cp
operator|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|squeue
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* Forget hints for IARB, they may be no longer relevant */
name|cp
operator|->
name|host_flags
operator|&=
operator|~
name|HF_HINT_IARB
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|target
operator|==
operator|-
literal|1
operator|||
name|cp
operator|->
name|target
operator|==
name|target
operator|)
operator|&&
operator|(
name|lun
operator|==
operator|-
literal|1
operator|||
name|cp
operator|->
name|lun
operator|==
name|lun
operator|)
operator|&&
operator|(
name|task
operator|==
operator|-
literal|1
operator|||
name|cp
operator|->
name|tag
operator|==
name|task
operator|)
condition|)
block|{
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|sym_remque
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|np
operator|->
name|squeue
index|[
name|j
index|]
operator|=
name|np
operator|->
name|squeue
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|+=
literal|2
operator|)
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+=
literal|2
operator|)
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|j
condition|)
comment|/* Copy back the idle task if needed */
name|np
operator|->
name|squeue
index|[
name|j
index|]
operator|=
name|np
operator|->
name|squeue
index|[
name|i
index|]
expr_stmt|;
name|np
operator|->
name|squeueput
operator|=
name|j
expr_stmt|;
comment|/* Update our current start queue pointer */
return|return
operator|(
name|i
operator|-
name|j
operator|)
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/*  *  Complete all CCBs queued to the COMP queue.  *  *  These CCBs are assumed:  *  - Not to be referenced either by devices or   *    SCRIPTS-related queues and datas.  *  - To have to be completed with an error condition   *    or requeued.  *  *  The device queue freeze count is incremented   *  for each CCB that does not prevent this.  *  This function is called when all CCBs involved   *  in error handling/recovery have been reaped.  */
end_comment

begin_function
specifier|static
name|void
name|sym_flush_comp_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
block|{
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
while|while
condition|(
operator|(
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
if|if
condition|(
name|cam_status
condition|)
name|sym_set_cam_status
argument_list|(
name|ccb
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_freeze_cam_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  chip handler for bad SCSI status condition  *  *  In case of bad SCSI status, we unqueue all the tasks   *  currently queued to the controller but not yet started   *  and then restart the SCRIPTS processor immediately.  *  *  QUEUE FULL and BUSY conditions are handled the same way.  *  Basically all the not yet started tasks are requeued in   *  device queue and the queue is frozen until a completion.  *  *  For CHECK CONDITION and COMMAND TERMINATED status, we use   *  the CCB of the failed command to prepare a REQUEST SENSE   *  SCSI command and queue it to the controller queue.  *  *  SCRATCHA is assumed to have been loaded with STARTPOS   *  before the SCRIPTS called the C code.  */
end_comment

begin_function
specifier|static
name|void
name|sym_sir_bad_scsi_status
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|u32
name|startp
decl_stmt|;
name|u_char
name|s_status
init|=
name|cp
operator|->
name|ssss_status
decl_stmt|;
name|u_char
name|h_flags
init|=
name|cp
operator|->
name|host_flags
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|int
name|nego
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  Compute the index of the next job to start from SCRIPTS. 	 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|vtobus
argument_list|(
name|np
operator|->
name|squeue
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* 	 *  The last CCB queued used for IARB hint may be  	 *  no longer relevant. Forget it. 	 */
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
if|if
condition|(
name|np
operator|->
name|last_cp
condition|)
name|np
operator|->
name|last_cp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Now deal with the SCSI status. 	 */
switch|switch
condition|(
name|s_status
condition|)
block|{
case|case
name|S_BUSY
case|:
case|case
name|S_QUEUE_FULL
case|:
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s_status
operator|==
name|S_BUSY
condition|?
literal|"BUSY"
else|:
literal|"QUEUE FULL\n"
argument_list|)
expr_stmt|;
block|}
default|default:
comment|/* S_INT, S_INT_COND_MET, S_CONFLICT */
name|sym_complete_error
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_TERMINATED
case|:
case|case
name|S_CHECK_COND
case|:
comment|/* 		 *  If we get an SCSI error when requesting sense, give up. 		 */
if|if
condition|(
name|h_flags
operator|&
name|HF_SENSE
condition|)
block|{
name|sym_complete_error
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Dequeue all queued CCBs for that device not yet started, 		 *  and restart the SCRIPTS processor immediately. 		 */
operator|(
name|void
operator|)
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 *  Save some info of the actual IO. 		 *  Compute the data residual. 		 */
name|cp
operator|->
name|sv_scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
name|cp
operator|->
name|sv_xerr_status
operator|=
name|cp
operator|->
name|xerr_status
expr_stmt|;
name|cp
operator|->
name|sv_resid
operator|=
name|sym_compute_residual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 		 *  Prepare all needed data structures for  		 *  requesting sense data. 		 */
comment|/* 		 *  identify message 		 */
name|cp
operator|->
name|scsi_smsg2
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
name|msglen
operator|=
literal|1
expr_stmt|;
comment|/* 		 *  If we are currently using anything different from  		 *  async. 8 bit data transfers with that target, 		 *  start a negotiation, since the device may want  		 *  to report us a UNIT ATTENTION condition due to  		 *  a cause we currently ignore, and we donnot want  		 *  to be stuck with WIDE and/or SYNC data transfer. 		 * 		 *  cp->nego_status is filled by sym_prepare_nego(). 		 */
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
name|nego
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|&
name|PPR_OPT_MASK
condition|)
name|nego
operator|=
name|NS_PPR
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|BUS_8_BIT
condition|)
name|nego
operator|=
name|NS_WIDE
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
literal|0
condition|)
name|nego
operator|=
name|NS_SYNC
expr_stmt|;
if|if
condition|(
name|nego
condition|)
name|msglen
operator|+=
name|sym_prepare_nego
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|nego
argument_list|,
operator|&
name|cp
operator|->
name|scsi_smsg2
index|[
name|msglen
index|]
argument_list|)
expr_stmt|;
comment|/* 		 *  Message table indirect structure. 		 */
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|scsi_smsg2
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
comment|/* 		 *  sense command 		 */
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|sensecmd
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* 		 *  patch requested size into sense command 		 */
name|cp
operator|->
name|sensecmd
index|[
literal|0
index|]
operator|=
literal|0x03
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|4
index|]
operator|=
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
name|cp
operator|->
name|data_len
operator|=
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
comment|/* 		 *  sense data 		 */
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
operator|.
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
operator|.
name|sense_len
argument_list|)
expr_stmt|;
comment|/* 		 *  requeue the command. 		 */
name|startp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|sdata_in
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|savep
operator|=
name|cpu_to_scr
argument_list|(
name|startp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
name|cp
operator|->
name|phys
operator|.
name|goalp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
operator|+
literal|40
argument_list|)
expr_stmt|;
else|#
directive|else
name|cp
operator|->
name|phys
operator|.
name|goalp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
operator|+
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|phys
operator|.
name|lastp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|startp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|actualquirks
operator|=
name|SYM_QUIRK_AUTOSAVE
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|cp
operator|->
name|nego_status
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|ssss_status
operator|=
name|S_ILLEGAL
expr_stmt|;
name|cp
operator|->
name|host_flags
operator|=
name|HF_SENSE
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|extra_bytes
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|go
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 *  Requeue the command. 		 */
name|sym_put_start_queue
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 		 *  Give back to upper layer everything we have dequeued. 		 */
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  After a device has accepted some management message   *  as BUS DEVICE RESET, ABORT TASK, etc ..., or when   *  a device signals a UNIT ATTENTION condition, some   *  tasks are thrown away by the device. We are required   *  to reflect that on our tasks list since the device   *  will never complete these tasks.  *  *  This function move from the BUSY queue to the COMP   *  queue all disconnected CCBs for a given target that   *  match the following criteria:  *  - lun=-1  means any logical UNIT otherwise a given one.  *  - task=-1 means any task, otherwise a given one.  */
end_comment

begin_function
specifier|static
name|int
name|sym_clear_tasks
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|SYM_QUEHEAD
name|qtmp
decl_stmt|,
modifier|*
name|qp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
comment|/* 	 *  Move the entire BUSY queue to our temporary queue. 	 */
name|sym_que_init
argument_list|(
operator|&
name|qtmp
argument_list|)
expr_stmt|;
name|sym_que_splice
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|,
operator|&
name|qtmp
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  Put all CCBs that matches our criteria into  	 *  the COMP queue and put back other ones into  	 *  the BUSY queue. 	 */
while|while
condition|(
operator|(
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|qtmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
operator|||
name|cp
operator|->
name|target
operator|!=
name|target
operator|||
operator|(
name|lun
operator|!=
operator|-
literal|1
operator|&&
name|cp
operator|->
name|lun
operator|!=
name|lun
operator|)
operator|||
operator|(
name|task
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
operator|&&
name|cp
operator|->
name|scsi_smsg
index|[
literal|2
index|]
operator|!=
name|task
operator|)
operator|)
condition|)
block|{
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
comment|/* Preserve the software timeout condition */
if|if
condition|(
name|sym_get_cam_status
argument_list|(
name|ccb
argument_list|)
operator|!=
name|CAM_CMD_TIMEOUT
condition|)
name|sym_set_cam_status
argument_list|(
name|ccb
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|#
directive|if
literal|0
block|printf("XXXXX TASK @%p CLEARED\n", cp);
endif|#
directive|endif
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for TASKS recovery  *  *  We cannot safely abort a command, while the SCRIPTS   *  processor is running, since we just would be in race   *  with it.  *  *  As long as we have tasks to abort, we keep the SEM   *  bit set in the ISTAT. When this bit is set, the   *  SCRIPTS processor interrupts (SIR_SCRIPT_STOPPED)   *  each time it enters the scheduler.  *  *  If we have to reset a target, clear tasks of a unit,  *  or to perform the abort of a disconnected job, we   *  restart the SCRIPTS for selecting the target. Once   *  selected, the SCRIPTS interrupts (SIR_TARGET_SELECTED).  *  If it loses arbitration, the SCRIPTS will interrupt again   *  the next time it will enter its scheduler, and so on ...  *  *  On SIR_TARGET_SELECTED, we scan for the more   *  appropriate thing to do:  *  *  - If nothing, we just sent a M_ABORT message to the   *    target to get rid of the useless SCSI bus ownership.  *    According to the specs, no tasks shall be affected.  *  - If the target is to be reset, we send it a M_RESET   *    message.  *  - If a logical UNIT is to be cleared , we send the   *    IDENTIFY(lun) + M_ABORT.  *  - If an untagged task is to be aborted, we send the   *    IDENTIFY(lun) + M_ABORT.  *  - If a tagged task is to be aborted, we send the   *    IDENTIFY(lun) + task attributes + M_ABORT_TAG.  *  *  Once our 'kiss of death' :) message has been accepted   *  by the target, the SCRIPTS interrupts again   *  (SIR_ABORT_SENT). On this interrupt, we complete   *  all the CCBs that should have been aborted by the   *  target according to our message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_sir_task_recovery
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|int
name|target
init|=
operator|-
literal|1
decl_stmt|,
name|lun
init|=
operator|-
literal|1
decl_stmt|,
name|task
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* 	 *  The SCRIPTS processor stopped before starting 	 *  the next command in order to allow us to perform  	 *  some task recovery. 	 */
case|case
name|SIR_SCRIPT_STOPPED
case|:
comment|/* 		 *  Do we have any target to reset or unit to clear ? 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|to_reset
operator|||
operator|(
name|tp
operator|->
name|lun0p
operator|&&
name|tp
operator|->
name|lun0p
operator|->
name|to_clear
operator|)
condition|)
block|{
name|target
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|lunmp
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|SYMCONF_MAX_LUN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|&&
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|->
name|to_clear
condition|)
block|{
name|target
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
comment|/* 		 *  If not, walk the busy queue for any  		 *  disconnected CCB to be aborted. 		 */
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|to_abort
condition|)
block|{
name|target
operator|=
name|cp
operator|->
name|target
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 *  If some target is to be selected,  		 *  prepare and start the selection. 		 */
if|if
condition|(
name|target
operator|!=
operator|-
literal|1
condition|)
block|{
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|np
operator|->
name|abrt_sel
operator|.
name|sel_id
operator|=
name|target
expr_stmt|;
name|np
operator|->
name|abrt_sel
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|wval
expr_stmt|;
name|np
operator|->
name|abrt_sel
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|sval
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|vtobus
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|sel_for_abort
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 *  Now look for a CCB to abort that haven't started yet. 		 *  Btw, the SCRIPTS processor is still stopped, so  		 *  we are not in race. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_BUSY
operator|&&
name|cp
operator|->
name|host_status
operator|!=
name|HS_NEGOTIATE
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cp
operator|->
name|to_abort
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 			 *    If we are using IMMEDIATE ARBITRATION, we donnot  			 *    want to cancel the last queued CCB, since the  			 *    SCRIPTS may have anticipated the selection. 			 */
if|if
condition|(
name|cp
operator|==
name|np
operator|->
name|last_cp
condition|)
block|{
name|cp
operator|->
name|to_abort
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|i
operator|=
literal|1
expr_stmt|;
comment|/* Means we have found some */
break|break;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* 			 *  We are done, so we donnot need  			 *  to synchronize with the SCRIPTS anylonger. 			 *  Remove the SEM flag from the ISTAT. 			 */
name|np
operator|->
name|istat_sem
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Compute index of next position in the start  		 *  queue the SCRIPTS intends to start and dequeue  		 *  all CCBs for that device that haven't been started. 		 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|vtobus
argument_list|(
name|np
operator|->
name|squeue
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
name|i
operator|=
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *  Make sure at least our IO to abort has been dequeued. 		 */
name|assert
argument_list|(
name|i
operator|&&
name|sym_get_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|)
operator|==
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
comment|/* 		 *  Keep track in cam status of the reason of the abort. 		 */
if|if
condition|(
name|cp
operator|->
name|to_abort
operator|==
literal|2
condition|)
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
comment|/* 		 *  Complete with error everything that we have dequeued. 	 	 */
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  The SCRIPTS processor has selected a target  	 *  we may have some manual recovery to perform for. 	 */
case|case
name|SIR_TARGET_SELECTED
case|:
name|target
operator|=
operator|(
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|addr
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|abrt_msg
argument_list|)
expr_stmt|;
comment|/* 		 *  If the target is to be reset, prepare a  		 *  M_RESET message and clear the to_reset flag  		 *  since we donnot expect this operation to fail. 		 */
if|if
condition|(
name|tp
operator|->
name|to_reset
condition|)
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_RESET
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Otherwise, look for some logical unit to be cleared. 		 */
if|if
condition|(
name|tp
operator|->
name|lun0p
operator|&&
name|tp
operator|->
name|lun0p
operator|->
name|to_clear
condition|)
name|lun
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|lunmp
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|SYMCONF_MAX_LUN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|&&
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|->
name|to_clear
condition|)
block|{
name|lun
operator|=
name|k
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 *  If a logical unit is to be cleared, prepare  		 *  an IDENTIFY(lun) + ABORT MESSAGE. 		 */
if|if
condition|(
name|lun
operator|!=
operator|-
literal|1
condition|)
block|{
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|lun
argument_list|)
decl_stmt|;
name|lp
operator|->
name|to_clear
operator|=
literal|0
expr_stmt|;
comment|/* We donnot expect to fail here */
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|lun
expr_stmt|;
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|=
name|M_ABORT
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Otherwise, look for some disconnected job to  		 *  abort for this target. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|target
operator|!=
name|target
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cp
operator|->
name|to_abort
condition|)
continue|continue;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* Means we have some */
break|break;
block|}
comment|/* 		 *  If we have none, probably since the device has  		 *  completed the command before we won abitration, 		 *  send a M_ABORT message without IDENTIFY. 		 *  According to the specs, the device must just  		 *  disconnect the BUS and not abort any task. 		 */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_ABORT
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 *  We have some task to abort. 		 *  Set the IDENTIFY(lun) 		 */
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
comment|/* 		 *  If we want to abort an untagged command, we  		 *  will send a IDENTIFY + M_ABORT. 		 *  Otherwise (tagged command), we will send  		 *  a IDENTITFY + task attributes + ABORT TAG. 		 */
if|if
condition|(
name|cp
operator|->
name|tag
operator|==
name|NO_TAG
condition|)
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|=
name|M_ABORT
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|scsi_smsg
index|[
literal|1
index|]
expr_stmt|;
name|np
operator|->
name|abrt_msg
index|[
literal|2
index|]
operator|=
name|cp
operator|->
name|scsi_smsg
index|[
literal|2
index|]
expr_stmt|;
name|np
operator|->
name|abrt_msg
index|[
literal|3
index|]
operator|=
name|M_ABORT_TAG
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|4
expr_stmt|;
block|}
comment|/* 		 *  Keep track of software timeout condition, since the  		 *  peripheral driver may not count retries on abort  		 *  conditions not due to timeout. 		 */
if|if
condition|(
name|cp
operator|->
name|to_abort
operator|==
literal|2
condition|)
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|cp
operator|->
name|to_abort
operator|=
literal|0
expr_stmt|;
comment|/* We donnot expect to fail here */
break|break;
comment|/* 	 *  The target has accepted our message and switched  	 *  to BUS FREE phase as we expected. 	 */
case|case
name|SIR_ABORT_SENT
case|:
name|target
operator|=
operator|(
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
comment|/* 		**  If we didn't abort anything, leave here. 		*/
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|==
name|M_ABORT
condition|)
break|break;
comment|/* 		 *  If we sent a M_RESET, then a hardware reset has  		 *  been performed by the target. 		 *  - Reset everything to async 8 bit 		 *  - Tell ourself to negotiate next time :-) 		 *  - Prepare to clear all disconnected CCBs for  		 *    this target from our task list (lun=task=-1) 		 */
name|lun
operator|=
operator|-
literal|1
expr_stmt|;
name|task
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|==
name|M_RESET
condition|)
block|{
name|tp
operator|->
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|uval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 *  Otherwise, check for the LUN and TASK(s)  		 *  concerned by the cancelation. 		 *  If it is not ABORT_TAG then it is CLEAR_QUEUE  		 *  or an ABORT message :-) 		 */
else|else
block|{
name|lun
operator|=
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|==
name|M_ABORT_TAG
condition|)
name|task
operator|=
name|np
operator|->
name|abrt_msg
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* 		 *  Complete all the CCBs the device should have  		 *  aborted due to our 'kiss of death' message. 		 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|vtobus
argument_list|(
name|np
operator|->
name|squeue
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sym_clear_tasks
argument_list|(
name|np
argument_list|,
name|CAM_REQ_ABORTED
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 *  If we sent a BDR, make uper layer aware of that. 		 */
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|==
name|M_RESET
condition|)
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|np
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 *  Print to the log the message we intend to send. 	 */
if|if
condition|(
name|num
operator|==
name|SIR_TARGET_SELECTED
condition|)
block|{
name|PRINT_TARGET
argument_list|(
name|np
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|sym_printl_hex
argument_list|(
literal|"control msgout:"
argument_list|,
name|np
operator|->
name|abrt_msg
argument_list|,
name|np
operator|->
name|abrt_tbl
operator|.
name|size
argument_list|)
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|abrt_tbl
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Let the SCRIPTS processor continue. 	 */
name|OUTONB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Gerard's alchemy:) that deals with with the data   *  pointer for both MDP and the residual calculation.  *  *  I didn't want to bloat the code by more than 200   *  lignes for the handling of both MDP and the residual.  *  This has been achieved by using a data pointer   *  representation consisting in an index in the data   *  array (dp_sg) and a negative offset (dp_ofs) that   *  have the following meaning:  *  *  - dp_sg = SYMCONF_MAX_SG  *    we are at the end of the data script.  *  - dp_sg< SYMCONF_MAX_SG  *    dp_sg points to the next entry of the scatter array   *    we want to transfer.  *  - dp_ofs< 0  *    dp_ofs represents the residual of bytes of the   *    previous entry scatter entry we will send first.  *  - dp_ofs = 0  *    no residual to send first.  *  *  The function sym_evaluate_dp() accepts an arbitray   *  offset (basically from the MDP message) and returns   *  the corresponding values of dp_sg and dp_ofs.  */
end_comment

begin_function
specifier|static
name|int
name|sym_evaluate_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u32
name|scr
parameter_list|,
name|int
modifier|*
name|ofs
parameter_list|)
block|{
name|u32
name|dp_scr
decl_stmt|;
name|int
name|dp_ofs
decl_stmt|,
name|dp_sg
decl_stmt|,
name|dp_sgmin
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|struct
name|sym_pmc
modifier|*
name|pm
decl_stmt|;
comment|/* 	 *  Compute the resulted data pointer in term of a script  	 *  address within some DATA script and a signed byte offset. 	 */
name|dp_scr
operator|=
name|scr
expr_stmt|;
name|dp_ofs
operator|=
operator|*
name|ofs
expr_stmt|;
if|if
condition|(
name|dp_scr
operator|==
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
condition|)
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm0
expr_stmt|;
elseif|else
if|if
condition|(
name|dp_scr
operator|==
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
condition|)
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm1
expr_stmt|;
else|else
name|pm
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pm
condition|)
block|{
name|dp_scr
operator|=
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|ret
argument_list|)
expr_stmt|;
name|dp_ofs
operator|-=
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If we are auto-sensing, then we are done. 	 */
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
block|{
operator|*
name|ofs
operator|=
name|dp_ofs
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 *  Deduce the index of the sg entry. 	 *  Keep track of the index of the first valid entry. 	 *  If result is dp_sg = SYMCONF_MAX_SG, then we are at the  	 *  end of the data. 	 */
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|goalp
argument_list|)
expr_stmt|;
name|dp_sg
operator|=
name|SYMCONF_MAX_SG
operator|-
operator|(
name|tmp
operator|-
literal|8
operator|-
operator|(
name|int
operator|)
name|dp_scr
operator|)
operator|/
operator|(
literal|2
operator|*
literal|4
operator|)
expr_stmt|;
name|dp_sgmin
operator|=
name|SYMCONF_MAX_SG
operator|-
name|cp
operator|->
name|segments
expr_stmt|;
comment|/* 	 *  Move to the sg entry the data pointer belongs to. 	 * 	 *  If we are inside the data area, we expect result to be: 	 * 	 *  Either, 	 *      dp_ofs = 0 and dp_sg is the index of the sg entry 	 *      the data pointer belongs to (or the end of the data) 	 *  Or, 	 *      dp_ofs< 0 and dp_sg is the index of the sg entry  	 *      the data pointer belongs to + 1. 	 */
if|if
condition|(
name|dp_ofs
operator|<
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
while|while
condition|(
name|dp_sg
operator|>
name|dp_sgmin
condition|)
block|{
operator|--
name|dp_sg
expr_stmt|;
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|n
operator|=
name|dp_ofs
operator|+
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|++
name|dp_sg
expr_stmt|;
break|break;
block|}
name|dp_ofs
operator|=
name|n
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dp_ofs
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|dp_sg
operator|<
name|SYMCONF_MAX_SG
condition|)
block|{
operator|++
name|dp_sg
expr_stmt|;
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|dp_ofs
operator|-=
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
expr_stmt|;
if|if
condition|(
name|dp_ofs
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 	 *  Make sure the data pointer is inside the data area. 	 *  If not, return some error. 	 */
if|if
condition|(
name|dp_sg
operator|<
name|dp_sgmin
operator|||
operator|(
name|dp_sg
operator|==
name|dp_sgmin
operator|&&
name|dp_ofs
operator|<
literal|0
operator|)
condition|)
goto|goto
name|out_err
goto|;
elseif|else
if|if
condition|(
name|dp_sg
operator|>
name|SYMCONF_MAX_SG
operator|||
operator|(
name|dp_sg
operator|==
name|SYMCONF_MAX_SG
operator|&&
name|dp_ofs
operator|>
literal|0
operator|)
condition|)
goto|goto
name|out_err
goto|;
comment|/* 	 *  Save the extreme pointer if needed. 	 */
if|if
condition|(
name|dp_sg
operator|>
name|cp
operator|->
name|ext_sg
operator|||
operator|(
name|dp_sg
operator|==
name|cp
operator|->
name|ext_sg
operator|&&
name|dp_ofs
operator|>
name|cp
operator|->
name|ext_ofs
operator|)
condition|)
block|{
name|cp
operator|->
name|ext_sg
operator|=
name|dp_sg
expr_stmt|;
name|cp
operator|->
name|ext_ofs
operator|=
name|dp_ofs
expr_stmt|;
block|}
comment|/* 	 *  Return data. 	 */
operator|*
name|ofs
operator|=
name|dp_ofs
expr_stmt|;
return|return
name|dp_sg
return|;
name|out_err
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for MODIFY DATA POINTER MESSAGE  *  *  We also call this function on IGNORE WIDE RESIDUE   *  messages that do not match a SWIDE full condition.  *  Btw, we assume in that situation that such a message   *  is equivalent to a MODIFY DATA POINTER (offset=-1).  */
end_comment

begin_function
specifier|static
name|void
name|sym_modify_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|ofs
parameter_list|)
block|{
name|int
name|dp_ofs
init|=
name|ofs
decl_stmt|;
name|u32
name|dp_scr
init|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
decl_stmt|;
name|u32
name|dp_ret
decl_stmt|;
name|u_char
name|hflags
decl_stmt|;
name|int
name|dp_sg
decl_stmt|;
name|struct
name|sym_pmc
modifier|*
name|pm
decl_stmt|;
comment|/* 	 *  Not supported for auto-sense. 	 */
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
goto|goto
name|out_reject
goto|;
comment|/* 	 *  Apply our alchemy:) (see comments in sym_evaluate_dp()),  	 *  to the resulted data pointer. 	 */
name|dp_sg
operator|=
name|sym_evaluate_dp
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dp_scr
argument_list|,
operator|&
name|dp_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp_sg
operator|<
literal|0
condition|)
goto|goto
name|out_reject
goto|;
comment|/* 	 *  And our alchemy:) allows to easily calculate the data  	 *  script address we want to return for the next data phase. 	 */
name|dp_ret
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|goalp
argument_list|)
expr_stmt|;
name|dp_ret
operator|=
name|dp_ret
operator|-
literal|8
operator|-
operator|(
name|SYMCONF_MAX_SG
operator|-
name|dp_sg
operator|)
operator|*
operator|(
literal|2
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* 	 *  If offset / scatter entry is zero we donnot need  	 *  a context for the new current data pointer. 	 */
if|if
condition|(
name|dp_ofs
operator|==
literal|0
condition|)
block|{
name|dp_scr
operator|=
name|dp_ret
expr_stmt|;
goto|goto
name|out_ok
goto|;
block|}
comment|/* 	 *  Get a context for the new current data pointer. 	 */
name|hflags
operator|=
name|INB
argument_list|(
name|HF_PRT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hflags
operator|&
name|HF_DP_SAVED
condition|)
name|hflags
operator|^=
name|HF_ACT_PM
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hflags
operator|&
name|HF_ACT_PM
operator|)
condition|)
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm0
expr_stmt|;
name|dp_scr
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm1
expr_stmt|;
name|dp_scr
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
expr_stmt|;
block|}
name|hflags
operator|&=
operator|~
operator|(
name|HF_DP_SAVED
operator|)
expr_stmt|;
name|OUTB
argument_list|(
name|HF_PRT
argument_list|,
name|hflags
argument_list|)
expr_stmt|;
comment|/* 	 *  Set up the new current data pointer. 	 *  ofs< 0 there, and for the next data phase, we  	 *  want to transfer part of the data of the sg entry  	 *  corresponding to index dp_sg-1 prior to returning  	 *  to the main data script. 	 */
name|pm
operator|->
name|ret
operator|=
name|cpu_to_scr
argument_list|(
name|dp_ret
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|addr
operator|=
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
operator|-
literal|1
index|]
operator|.
name|addr
operator|+
name|dp_ofs
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|size
operator|=
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
operator|-
literal|1
index|]
operator|.
name|size
operator|-
name|dp_ofs
expr_stmt|;
name|out_ok
label|:
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|dp_scr
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|out_reject
label|:
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip calculation of the data residual.  *  *  As I used to say, the requirement of data residual   *  in SCSI is broken, useless and cannot be achieved   *  without huge complexity.  *  But most OSes and even the official CAM require it.  *  When stupidity happens to be so widely spread inside   *  a community, it gets hard to convince.  *  *  Anyway, I don't care, since I am not going to use   *  any software that considers this data residual as   *  a relevant information. :)  */
end_comment

begin_function
specifier|static
name|int
name|sym_compute_residual
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|int
name|dp_sg
decl_stmt|,
name|dp_sgmin
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|dp_ofs
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Check for some data lost or just thrown away. 	 *  We are not required to be quite accurate in this  	 *  situation. Btw, if we are odd for output and the  	 *  device claims some more data, it may well happen  	 *  than our residual be zero. :-) 	 */
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
operator|(
name|XE_EXTRA_DATA
operator||
name|XE_SODL_UNRUN
operator||
name|XE_SWIDE_OVRUN
operator|)
condition|)
block|{
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
name|XE_EXTRA_DATA
condition|)
name|resid
operator|-=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|extra_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
name|XE_SODL_UNRUN
condition|)
operator|++
name|resid
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
name|XE_SWIDE_OVRUN
condition|)
operator|--
name|resid
expr_stmt|;
block|}
comment|/* 	 *  If all data has been transferred, 	 *  there is no residual. 	 */
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|lastp
operator|==
name|cp
operator|->
name|phys
operator|.
name|goalp
condition|)
return|return
literal|0
return|;
comment|/* 	 *  If no data transfer occurs, or if the data 	 *  pointer is weird, return full residual. 	 */
if|if
condition|(
name|cp
operator|->
name|startp
operator|==
name|cp
operator|->
name|phys
operator|.
name|lastp
operator|||
name|sym_evaluate_dp
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|lastp
argument_list|)
argument_list|,
operator|&
name|dp_ofs
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|cp
operator|->
name|data_len
return|;
block|}
comment|/* 	 *  If we were auto-sensing, then we are done. 	 */
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
block|{
return|return
operator|-
name|dp_ofs
return|;
block|}
comment|/* 	 *  We are now full comfortable in the computation  	 *  of the data residual (2's complement). 	 */
name|dp_sgmin
operator|=
name|SYMCONF_MAX_SG
operator|-
name|cp
operator|->
name|segments
expr_stmt|;
name|resid
operator|=
operator|-
name|cp
operator|->
name|ext_ofs
expr_stmt|;
for|for
control|(
name|dp_sg
operator|=
name|cp
operator|->
name|ext_sg
init|;
name|dp_sg
operator|<
name|SYMCONF_MAX_SG
condition|;
operator|++
name|dp_sg
control|)
block|{
name|u_long
name|tmp
init|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
index|]
operator|.
name|size
argument_list|)
decl_stmt|;
name|resid
operator|+=
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
expr_stmt|;
block|}
comment|/* 	 *  Hopefully, the result is not too wrong. 	 */
return|return
name|resid
return|;
block|}
end_function

begin_comment
comment|/*  *  Print out the containt of a SCSI message.  */
end_comment

begin_function
specifier|static
name|int
name|sym_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|u_char
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
name|M_EXTENDED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|-
literal|1
operator|>
name|msg
index|[
literal|1
index|]
condition|)
break|break;
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|msg
operator|&
literal|0xf0
operator|)
operator|==
literal|0x20
condition|)
block|{
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_print_msg
parameter_list|(
name|ccb_p
name|cp
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sym_show_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Negotiation for WIDE and SYNCHRONOUS DATA TRANSFER.  *  *  We try to negotiate sync and wide transfer only after  *  a successfull inquire command. We look at byte 7 of the  *  inquire data to determine the capabilities of the target.  *  *  When we try to negotiate, we append the negotiation message  *  to the identify and (maybe) simple tag message.  *  The host status field is set to HS_NEGOTIATE to mark this  *  situation.  *  *  If the target doesn't answer this message immediately  *  (as required by the standard), the SIR_NEGO_FAILED interrupt  *  will be raised eventually.  *  The handler removes the HS_NEGOTIATE status, and sets the  *  negotiated value to the default (async / nowide).  *  *  If we receive a matching answer immediately, we check it  *  for validity, and set the values.  *  *  If we receive a Reject message immediately, we assume the  *  negotiation has failed, and fall back to standard values.  *  *  If we receive a negotiation message while not in HS_NEGOTIATE  *  state, it's a target initiated negotiation. We prepare a  *  (hopefully) valid answer, set our parameters, and send back   *  this answer to the target.  *  *  If the target doesn't fetch the answer (no message out phase),  *  we assume the negotiation has failed, and fall back to default  *  settings (SIR_NEGO_PROTO interrupt).  *  *  When we set the values, we adjust them in all ccbs belonging   *  to this target, in the controller's register, and in the "phys"  *  field of the controller's struct sym_hcb.  */
end_comment

begin_comment
comment|/*  *  chip handler for SYNCHRONOUS DATA TRANSFER REQUEST (SDTR) message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_sync_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|ofs
decl_stmt|,
name|per
decl_stmt|,
name|fak
decl_stmt|,
name|div
decl_stmt|;
name|int
name|req
init|=
literal|1
decl_stmt|;
comment|/* 	 *  Synchronous request message received. 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msg in"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * request or answer ? 	 */
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|nego_status
operator|&&
name|cp
operator|->
name|nego_status
operator|!=
name|NS_SYNC
condition|)
goto|goto
name|reject_it
goto|;
name|req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  get requested values. 	 */
name|chg
operator|=
literal|0
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|msgin
index|[
literal|4
index|]
expr_stmt|;
comment|/* 	 *  check values against our limits. 	 */
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|np
operator|->
name|maxoffs
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|minsync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
expr_stmt|;
block|}
block|}
block|}
name|div
operator|=
name|fak
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ofs
operator|&&
name|sym_getsync
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|per
argument_list|,
operator|&
name|div
argument_list|,
operator|&
name|fak
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|reject_it
goto|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sdtr: ofs=%d per=%d div=%d fak=%d chg=%d.\n"
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|div
argument_list|,
name|fak
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  This was an answer message 	 */
if|if
condition|(
name|req
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chg
condition|)
comment|/* Answer wasn't acceptable. */
goto|goto
name|reject_it
goto|;
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  It was a request. Set value and 	 *  prepare an answer message 	 */
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|per
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
name|ofs
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_SYNC
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|sdtr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reject_it
label|:
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for PARALLEL PROTOCOL REQUEST (PPR) message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_ppr_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|ofs
decl_stmt|,
name|per
decl_stmt|,
name|fak
decl_stmt|,
name|dt
decl_stmt|,
name|div
decl_stmt|,
name|wide
decl_stmt|;
name|int
name|req
init|=
literal|1
decl_stmt|;
comment|/* 	 * Synchronous request message received. 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msg in"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * request or answer ? 	 */
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|nego_status
operator|&&
name|cp
operator|->
name|nego_status
operator|!=
name|NS_PPR
condition|)
goto|goto
name|reject_it
goto|;
name|req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  get requested values. 	 */
name|chg
operator|=
literal|0
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|msgin
index|[
literal|5
index|]
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|msgin
index|[
literal|6
index|]
expr_stmt|;
name|dt
operator|=
name|np
operator|->
name|msgin
index|[
literal|7
index|]
operator|&
name|PPR_OPT_DT
expr_stmt|;
comment|/* 	 *  check values against our limits. 	 */
if|if
condition|(
name|wide
operator|>
name|np
operator|->
name|maxwide
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wide
operator|||
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
operator|)
condition|)
name|dt
operator|&=
operator|~
name|PPR_OPT_DT
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|wide
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
operator|)
condition|)
comment|/* Broken U3EN bit not supported */
name|dt
operator|&=
operator|~
name|PPR_OPT_DT
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dt
operator|!=
operator|(
name|np
operator|->
name|msgin
index|[
literal|7
index|]
operator|&
name|PPR_OPT_MASK
operator|)
condition|)
name|chg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|np
operator|->
name|maxoffs
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|dt
operator|&&
name|per
operator|<
name|np
operator|->
name|minsync_dt
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync_dt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|minsync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
expr_stmt|;
block|}
block|}
block|}
name|div
operator|=
name|fak
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ofs
operator|&&
name|sym_getsync
argument_list|(
name|np
argument_list|,
name|dt
argument_list|,
name|per
argument_list|,
operator|&
name|div
argument_list|,
operator|&
name|fak
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|reject_it
goto|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppr: "
literal|"dt=%x ofs=%d per=%d wide=%d div=%d fak=%d chg=%d.\n"
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  It was an answer. 	 */
if|if
condition|(
name|req
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chg
condition|)
comment|/* Answer wasn't acceptable */
goto|goto
name|reject_it
goto|;
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  It was a request. Set value and 	 *  prepare an answer message 	 */
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|6
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_PPR_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|per
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|5
index|]
operator|=
name|ofs
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|6
index|]
operator|=
name|wide
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|7
index|]
operator|=
name|dt
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_PPR
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|ppr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reject_it
label|:
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for WIDE DATA TRANSFER REQUEST (WDTR) message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_wide_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|wide
decl_stmt|;
name|int
name|req
init|=
literal|1
decl_stmt|;
comment|/* 	 *  Wide request message received. 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"wide msgin"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * Is it an request from the device? 	 */
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|nego_status
operator|&&
name|cp
operator|->
name|nego_status
operator|!=
name|NS_WIDE
condition|)
goto|goto
name|reject_it
goto|;
name|req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  get requested values. 	 */
name|chg
operator|=
literal|0
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
comment|/* 	 *  check values against driver limits. 	 */
if|if
condition|(
name|wide
operator|>
name|np
operator|->
name|maxoffs
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|wide
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wdtr: wide=%d chg=%d.\n"
argument_list|,
name|wide
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This was an answer message 	 */
if|if
condition|(
name|req
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chg
condition|)
comment|/*  Answer wasn't acceptable. */
goto|goto
name|reject_it
goto|;
name|sym_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 	 *  It was a request, set value and 	 *  prepare an answer message 	 */
name|sym_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_WIDE_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|wide
expr_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_WIDE
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"wide msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|wdtr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reject_it
label|:
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Reset SYNC or WIDE to default settings.  *  *  Called when a negotiation does not succeed either   *  on rejection or on protocol error.  */
end_comment

begin_function
specifier|static
name|void
name|sym_nego_default
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
comment|/* 	 *  any error in negotiation: 	 *  fall back to default mode. 	 */
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_PPR
case|:
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_SYNC
case|:
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|sym_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for MESSAGE REJECT received in response to   *  a WIDE or SYNCHRONOUS negotiation.  */
end_comment

begin_function
specifier|static
name|void
name|sym_nego_rejected
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|sym_nego_default
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for programmed interrupts.  */
end_comment

begin_function
name|void
name|sym_int_sir
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|num
init|=
name|INB
argument_list|(
name|nc_dsps
argument_list|)
decl_stmt|;
name|u_long
name|dsa
init|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
decl_stmt|;
name|ccb_p
name|cp
init|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
decl_stmt|;
name|u_char
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"I#%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* 	 *  Command has been completed with error condition  	 *  or has been auto-sensed. 	 */
case|case
name|SIR_COMPLETE_ERROR
case|:
name|sym_complete_error
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  The C code is currently trying to recover from something. 	 *  Typically, user want to abort some command. 	 */
case|case
name|SIR_SCRIPT_STOPPED
case|:
case|case
name|SIR_TARGET_SELECTED
case|:
case|case
name|SIR_ABORT_SENT
case|:
name|sym_sir_task_recovery
argument_list|(
name|np
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  The device didn't go to MSG OUT phase after having  	 *  been selected with ATN. We donnot want to handle  	 *  that. 	 */
case|case
name|SIR_SEL_ATN_NO_MSG_OUT
case|:
name|printf
argument_list|(
literal|"%s:%d: No MSG OUT phase after selection with ATN.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
goto|goto
name|out_stuck
goto|;
comment|/* 	 *  The device didn't switch to MSG IN phase after  	 *  having reseleted the initiator. 	 */
case|case
name|SIR_RESEL_NO_MSG_IN
case|:
comment|/* 	 *  After reselection, the device sent a message that wasn't  	 *  an IDENTIFY. 	 */
case|case
name|SIR_RESEL_NO_IDENTIFY
case|:
comment|/* 		 *  If devices reselecting without sending an IDENTIFY  		 *  message still exist, this should help. 		 *  We just assume lun=0, 1 CCB, no tag. 		 */
if|if
condition|(
name|tp
operator|->
name|lun0p
condition|)
block|{
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|scr_to_cpu
argument_list|(
name|tp
operator|->
name|lun0p
operator|->
name|itl_task_sa
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|resel_dsa1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  The device reselected a LUN we donnot know about. 	 */
case|case
name|SIR_RESEL_BAD_LUN
case|:
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_RESET
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The device reselected for an untagged nexus and we  	 *  haven't any. 	 */
case|case
name|SIR_RESEL_BAD_I_T_L
case|:
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_ABORT
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The device reselected for a tagged nexus that we donnot  	 *  have. 	 */
case|case
name|SIR_RESEL_BAD_I_T_L_Q
case|:
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_ABORT_TAG
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The SCRIPTS let us know that the device has grabbed  	 *  our message and will abort the job. 	 */
case|case
name|SIR_RESEL_ABORTED
case|:
name|np
operator|->
name|lastmsg
operator|=
name|np
operator|->
name|msgout
index|[
literal|0
index|]
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d: message %x sent on bad reselection.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|,
name|np
operator|->
name|lastmsg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The SCRIPTS let us know that a message has been  	 *  successfully sent to the device. 	 */
case|case
name|SIR_MSG_OUT_DONE
case|:
name|np
operator|->
name|lastmsg
operator|=
name|np
operator|->
name|msgout
index|[
literal|0
index|]
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
comment|/* Should we really care of that */
if|if
condition|(
name|np
operator|->
name|lastmsg
operator|==
name|M_PARITY
operator|||
name|np
operator|->
name|lastmsg
operator|==
name|M_ID_ERROR
condition|)
block|{
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|->
name|xerr_status
operator|&=
operator|~
name|XE_PARITY_ERR
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|->
name|xerr_status
condition|)
name|OUTOFFB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  The device didn't send a GOOD SCSI status. 	 *  We may have some work to do prior to allow  	 *  the SCRIPTS processor to continue. 	 */
case|case
name|SIR_BAD_SCSI_STATUS
case|:
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|out
goto|;
name|sym_sir_bad_scsi_status
argument_list|(
name|np
argument_list|,
name|num
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  We are asked by the SCRIPTS to prepare a  	 *  REJECT message. 	 */
case|case
name|SIR_REJECT_TO_SEND
case|:
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"M_REJECT to send for "
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_REJECT
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  We have been ODD at the end of a DATA IN  	 *  transfer and the device didn't send a  	 *  IGNORE WIDE RESIDUE message. 	 *  It is a data overrun condition. 	 */
case|case
name|SIR_SWIDE_OVERRUN
case|:
if|if
condition|(
name|cp
condition|)
block|{
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_SWIDE_OVRUN
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  We have been ODD at the end of a DATA OUT  	 *  transfer. 	 *  It is a data underrun condition. 	 */
case|case
name|SIR_SODL_UNDERRUN
case|:
if|if
condition|(
name|cp
condition|)
block|{
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_SODL_UNRUN
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  We received a message. 	 */
case|case
name|SIR_MSG_RECEIVED
case|:
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|out_stuck
goto|;
switch|switch
condition|(
name|np
operator|->
name|msgin
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 *  We received an extended message. 		 *  We handle MODIFY DATA POINTER, SDTR, WDTR  		 *  and reject all other extended messages. 		 */
case|case
name|M_EXTENDED
case|:
switch|switch
condition|(
name|np
operator|->
name|msgin
index|[
literal|2
index|]
condition|)
block|{
case|case
name|M_X_MODIFY_DP
case|:
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_POINTER
condition|)
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"modify DP"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|np
operator|->
name|msgin
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|np
operator|->
name|msgin
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|np
operator|->
name|msgin
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|np
operator|->
name|msgin
index|[
literal|6
index|]
operator|)
expr_stmt|;
name|sym_modify_dp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_X_SYNC_REQ
case|:
name|sym_sync_nego
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_X_PPR_REQ
case|:
name|sym_ppr_nego
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_X_WIDE_REQ
case|:
name|sym_wide_nego
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
default|default:
goto|goto
name|out_reject
goto|;
block|}
break|break;
comment|/* 		 *  We received a 1/2 byte message not handled from SCRIPTS. 		 *  We are only expecting MESSAGE REJECT and IGNORE WIDE  		 *  RESIDUE messages that haven't been anticipated by  		 *  SCRIPTS on SWIDE full condition. Unanticipated IGNORE  		 *  WIDE RESIDUE messages are aliased as MODIFY DP (-1). 		 */
case|case
name|M_IGN_RESIDUE
case|:
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_POINTER
condition|)
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"ign wide residue"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|sym_modify_dp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_REJECT
case|:
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
name|sym_nego_rejected
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"M_REJECT received (%x:%x).\n"
argument_list|,
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|lastmsg
argument_list|)
argument_list|,
name|np
operator|->
name|msgout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out_clrack
goto|;
break|break;
default|default:
goto|goto
name|out_reject
goto|;
block|}
break|break;
comment|/* 	 *  We received an unknown message. 	 *  Ignore all MSG IN phases and reject it. 	 */
case|case
name|SIR_MSG_WEIRD
case|:
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"WEIRD message received"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|msg_weird
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  Negotiation failed. 	 *  Target does not send us the reply. 	 *  Remove the HS_NEGOTIATE status. 	 */
case|case
name|SIR_NEGO_FAILED
case|:
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
comment|/* 	 *  Negotiation failed. 	 *  Target does not want answer message. 	 */
case|case
name|SIR_NEGO_PROTO
case|:
name|sym_nego_default
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
empty_stmt|;
name|out
label|:
name|OUTONB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|STD
operator||
name|NOCOM
operator|)
argument_list|)
expr_stmt|;
return|return;
name|out_reject
label|:
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|out_clrack
label|:
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|out_stuck
label|:
block|}
end_function

begin_comment
comment|/*  *  Acquire a control block  */
end_comment

begin_function
specifier|static
name|ccb_p
name|sym_get_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|,
name|u_char
name|tag_order
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|)
decl_stmt|;
name|u_short
name|tag
init|=
name|NO_TAG
decl_stmt|;
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
init|=
operator|(
name|ccb_p
operator|)
literal|0
decl_stmt|;
comment|/* 	 *  Look for a free CCB 	 */
if|if
condition|(
name|sym_que_empty
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
condition|)
operator|(
name|void
operator|)
name|sym_alloc_ccb
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
goto|goto
name|out
goto|;
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  If the LCB is not yet available and the LUN 	 *  has been probed ok, try to allocate the LCB. 	 */
if|if
condition|(
operator|!
name|lp
operator|&&
name|sym_is_bit
argument_list|(
name|tp
operator|->
name|lun_map
argument_list|,
name|ln
argument_list|)
condition|)
block|{
name|lp
operator|=
name|sym_alloc_lcb
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
goto|goto
name|out_free
goto|;
block|}
comment|/* 	 *  If the LCB is not available here, then the  	 *  logical unit is not yet discovered. For those  	 *  ones only accept 1 SCSI IO per logical unit,  	 *  since we cannot allow disconnections. 	 */
if|if
condition|(
operator|!
name|lp
condition|)
block|{
if|if
condition|(
operator|!
name|sym_is_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|ln
argument_list|)
condition|)
name|sym_set_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|ln
argument_list|)
expr_stmt|;
else|else
goto|goto
name|out_free
goto|;
block|}
else|else
block|{
comment|/* 		 *  If we have been asked for a tagged command. 		 */
if|if
condition|(
name|tag_order
condition|)
block|{
comment|/* 			 *  Debugging purpose. 			 */
name|assert
argument_list|(
name|lp
operator|->
name|busy_itl
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 *  Allocate resources for tags if not yet. 			 */
if|if
condition|(
operator|!
name|lp
operator|->
name|cb_tags
condition|)
block|{
name|sym_alloc_lcb_tags
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|cb_tags
condition|)
goto|goto
name|out_free
goto|;
block|}
comment|/* 			 *  Get a tag for this SCSI IO and set up 			 *  the CCB bus address for reselection,  			 *  and count it for this LUN. 			 *  Toggle reselect patch to tagged. 			 */
if|if
condition|(
name|lp
operator|->
name|busy_itlq
operator|<
name|SYMCONF_MAX_TASK
condition|)
block|{
name|tag
operator|=
name|lp
operator|->
name|cb_tags
index|[
name|lp
operator|->
name|ia_tag
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|lp
operator|->
name|ia_tag
operator|==
name|SYMCONF_MAX_TASK
condition|)
name|lp
operator|->
name|ia_tag
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|itlq_tbl
index|[
name|tag
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
operator|++
name|lp
operator|->
name|busy_itlq
expr_stmt|;
name|lp
operator|->
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|resel_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|out_free
goto|;
block|}
comment|/* 		 *  This command will not be tagged. 		 *  If we already have either a tagged or untagged  		 *  one, refuse to overlap this untagged one. 		 */
else|else
block|{
comment|/* 			 *  Debugging purpose. 			 */
name|assert
argument_list|(
name|lp
operator|->
name|busy_itl
operator|==
literal|0
operator|&&
name|lp
operator|->
name|busy_itlq
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 *  Count this nexus for this LUN. 			 *  Set up the CCB bus address for reselection. 			 *  Toggle reselect path to untagged. 			 */
if|if
condition|(
operator|++
name|lp
operator|->
name|busy_itl
operator|==
literal|1
condition|)
block|{
name|lp
operator|->
name|itl_task_sa
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
name|lp
operator|->
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|resel_no_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|out_free
goto|;
block|}
block|}
comment|/* 	 *  Put the CCB into the busy queue. 	 */
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  Remember all informations needed to free this CCB. 	 */
name|cp
operator|->
name|to_abort
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|cp
operator|->
name|target
operator|=
name|tn
expr_stmt|;
name|cp
operator|->
name|lun
operator|=
name|ln
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
block|{
name|PRINT_LUN
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ccb @%p using tag %d.\n"
argument_list|,
name|cp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|cp
return|;
name|out_free
label|:
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccb_p
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Release one control block  */
end_comment

begin_function
specifier|static
name|void
name|sym_free_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
block|{
name|PRINT_LUN
argument_list|(
name|np
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ccb @%p freeing tag %d.\n"
argument_list|,
name|cp
argument_list|,
name|cp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If LCB available, 	 */
if|if
condition|(
name|lp
condition|)
block|{
comment|/* 		 *  If tagged, release the tag, set the relect path  		 */
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
condition|)
block|{
comment|/* 			 *  Free the tag value. 			 */
name|lp
operator|->
name|cb_tags
index|[
name|lp
operator|->
name|if_tag
index|]
operator|=
name|cp
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|++
name|lp
operator|->
name|if_tag
operator|==
name|SYMCONF_MAX_TASK
condition|)
name|lp
operator|->
name|if_tag
operator|=
literal|0
expr_stmt|;
comment|/* 			 *  Make the reselect path invalid,  			 *  and uncount this CCB. 			 */
name|lp
operator|->
name|itlq_tbl
index|[
name|cp
operator|->
name|tag
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|bad_itlq_ba
argument_list|)
expr_stmt|;
operator|--
name|lp
operator|->
name|busy_itlq
expr_stmt|;
block|}
else|else
block|{
comment|/* Untagged */
comment|/* 			 *  Make the reselect path invalid,  			 *  and uncount this CCB. 			 */
name|lp
operator|->
name|itl_task_sa
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|bad_itl_ba
argument_list|)
expr_stmt|;
operator|--
name|lp
operator|->
name|busy_itl
expr_stmt|;
block|}
comment|/* 		 *  If no JOB active, make the LUN reselect path invalid. 		 */
if|if
condition|(
name|lp
operator|->
name|busy_itlq
operator|==
literal|0
operator|&&
name|lp
operator|->
name|busy_itl
operator|==
literal|0
condition|)
name|lp
operator|->
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|resel_bad_lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Otherwise, we only accept 1 IO per LUN. 	 *  Clear the bit that keeps track of this IO. 	 */
else|else
name|sym_clr_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 *  We donnot queue more than 1 ccb per target  	 *  with negotiation at any time. If this ccb was  	 *  used for negotiation, clear this info in the tcb. 	 */
if|if
condition|(
name|cp
operator|==
name|tp
operator|->
name|nego_cp
condition|)
name|tp
operator|->
name|nego_cp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 	 *  If we just complete the last queued CCB, 	 *  clear this info that is no longer relevant. 	 */
if|if
condition|(
name|cp
operator|==
name|np
operator|->
name|last_cp
condition|)
name|np
operator|->
name|last_cp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Make this CCB available. 	 */
name|cp
operator|->
name|cam_ccb
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|HS_IDLE
expr_stmt|;
name|sym_remque
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Allocate a CCB from memory and initialize its fixed part.  */
end_comment

begin_function
specifier|static
name|ccb_p
name|sym_alloc_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|ccb_p
name|cp
init|=
literal|0
decl_stmt|;
name|int
name|hcode
decl_stmt|;
comment|/* 	 *  Prevent from allocating more CCBs than we can  	 *  queue to the controller. 	 */
if|if
condition|(
name|np
operator|->
name|actccbs
operator|>=
name|SYMCONF_MAX_START
condition|)
return|return
literal|0
return|;
comment|/* 	 *  Allocate memory for this CCB. 	 */
name|cp
operator|=
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ccb
argument_list|)
argument_list|,
literal|"CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
literal|0
return|;
comment|/* 	 *  Count it. 	 */
name|np
operator|->
name|actccbs
operator|++
expr_stmt|;
comment|/* 	 *  Compute the bus address of this ccb. 	 */
name|cp
operator|->
name|ccb_ba
operator|=
name|vtobus
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 *  Insert this ccb into the hashed list. 	 */
name|hcode
operator|=
name|CCB_HASH_CODE
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
name|cp
operator|->
name|link_ccbh
operator|=
name|np
operator|->
name|ccbh
index|[
name|hcode
index|]
expr_stmt|;
name|np
operator|->
name|ccbh
index|[
name|hcode
index|]
operator|=
name|cp
expr_stmt|;
comment|/* 	 *  Initialyze the start and restart actions. 	 */
name|cp
operator|->
name|phys
operator|.
name|go
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|go
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Initilialyze some other fields. 	 */
name|cp
operator|->
name|phys
operator|.
name|smsg_ext
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|msgin
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Chain into wakeup list and into free ccb queue. 	 */
name|cp
operator|->
name|link_ccb
operator|=
name|np
operator|->
name|ccbc
expr_stmt|;
name|np
operator|->
name|ccbc
operator|=
name|cp
expr_stmt|;
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  *  Look up a CCB from a DSA value.  */
end_comment

begin_function
specifier|static
name|ccb_p
name|sym_ccb_from_dsa
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_long
name|dsa
parameter_list|)
block|{
name|int
name|hcode
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|hcode
operator|=
name|CCB_HASH_CODE
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
name|np
operator|->
name|ccbh
index|[
name|hcode
index|]
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|ccb_ba
operator|==
name|dsa
condition|)
break|break;
name|cp
operator|=
name|cp
operator|->
name|link_ccbh
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  *  Target control block initialisation.  *  Nothing important to do at the moment.  */
end_comment

begin_function
specifier|static
name|void
name|sym_init_tcb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|)
block|{
comment|/* 	 *  Check some alignments required by the chip. 	 */
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_sxfer
argument_list|)
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|sval
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_scntl3
argument_list|)
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|wval
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Lun control block allocation and initialization.  */
end_comment

begin_function
specifier|static
name|lcb_p
name|sym_alloc_lcb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|)
decl_stmt|;
comment|/* 	 *  Already done, just return. 	 */
if|if
condition|(
name|lp
condition|)
return|return
name|lp
return|;
comment|/* 	 *  Check against some race. 	 */
name|assert
argument_list|(
operator|!
name|sym_is_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|ln
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Initialize the target control block if not yet. 	 */
name|sym_init_tcb
argument_list|(
name|np
argument_list|,
name|tn
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate the LCB bus address array. 	 *  Compute the bus address of this table. 	 */
if|if
condition|(
name|ln
operator|&&
operator|!
name|tp
operator|->
name|luntbl
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tp
operator|->
name|luntbl
operator|=
name|sym_calloc
argument_list|(
literal|256
argument_list|,
literal|"LUNTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|luntbl
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|tp
operator|->
name|luntbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|badlun_sa
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|luntbl_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|tp
operator|->
name|luntbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Allocate the table of pointers for LUN(s)> 0, if needed. 	 */
if|if
condition|(
name|ln
operator|&&
operator|!
name|tp
operator|->
name|lunmp
condition|)
block|{
name|tp
operator|->
name|lunmp
operator|=
name|sym_calloc
argument_list|(
name|SYMCONF_MAX_LUN
operator|*
sizeof|sizeof
argument_list|(
name|lcb_p
argument_list|)
argument_list|,
literal|"LUNMP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|lunmp
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* 	 *  Allocate the lcb. 	 *  Make it available to the chip. 	 */
name|lp
operator|=
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_lcb
argument_list|)
argument_list|,
literal|"LCB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ln
condition|)
block|{
name|tp
operator|->
name|lunmp
index|[
name|ln
index|]
operator|=
name|lp
expr_stmt|;
name|tp
operator|->
name|luntbl
index|[
name|ln
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|lun0p
operator|=
name|lp
expr_stmt|;
name|tp
operator|->
name|lun0_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Let the itl task point to error handling. 	 */
name|lp
operator|->
name|itl_task_sa
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|bad_itl_ba
argument_list|)
expr_stmt|;
comment|/* 	 *  Set the reselect pattern to our default. :) 	 */
name|lp
operator|->
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|resel_bad_lun
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Set user capabilities. 	 */
name|lp
operator|->
name|user_flags
operator|=
name|tp
operator|->
name|usrflags
operator|&
operator|(
name|SYM_DISC_ENABLED
operator||
name|SYM_TAGS_ENABLED
operator|)
expr_stmt|;
name|fail
label|:
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/*  *  Allocate LCB resources for tagged command queuing.  */
end_comment

begin_function
specifier|static
name|void
name|sym_alloc_lcb_tags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  If LCB not available, try to allocate it. 	 */
if|if
condition|(
operator|!
name|lp
operator|&&
operator|!
operator|(
name|lp
operator|=
name|sym_alloc_lcb
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 *  Allocate the task table and and the tag allocation  	 *  circular buffer. We want both or none. 	 */
name|lp
operator|->
name|itlq_tbl
operator|=
name|sym_calloc
argument_list|(
name|SYMCONF_MAX_TASK
operator|*
literal|4
argument_list|,
literal|"ITLQ_TBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|itlq_tbl
condition|)
goto|goto
name|fail
goto|;
name|lp
operator|->
name|cb_tags
operator|=
name|sym_calloc
argument_list|(
name|SYMCONF_MAX_TASK
argument_list|,
literal|"CB_TAGS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|cb_tags
condition|)
block|{
name|sym_mfree
argument_list|(
name|lp
operator|->
name|itlq_tbl
argument_list|,
name|SYMCONF_MAX_TASK
operator|*
literal|4
argument_list|,
literal|"ITLQ_TBL"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|itlq_tbl
operator|=
literal|0
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 *  Initialize the task table with invalid entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TASK
condition|;
name|i
operator|++
control|)
name|lp
operator|->
name|itlq_tbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|notask_ba
argument_list|)
expr_stmt|;
comment|/* 	 *  Fill up the tag buffer with tag numbers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TASK
condition|;
name|i
operator|++
control|)
name|lp
operator|->
name|cb_tags
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* 	 *  Make the task table available to SCRIPTS,  	 *  And accept tagged commands now. 	 */
name|lp
operator|->
name|itlq_tbl_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|lp
operator|->
name|itlq_tbl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|fail
label|:
block|}
end_function

begin_comment
comment|/*  *  Test the pci bus snoop logic :-(  *  *  Has to be called with interrupts disabled.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYMCONF_IOMAPPED
end_ifndef

begin_function
specifier|static
name|int
name|sym_regtest
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
specifier|register
specifier|volatile
name|u32
name|data
decl_stmt|;
comment|/* 	 *  chip registers may NOT be cached. 	 *  write 0xffffffff to a read only register area, 	 *  and try to read it back. 	 */
name|data
operator|=
literal|0xffffffff
expr_stmt|;
name|OUTL_OFF
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_dstat
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|INL_OFF
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_dstat
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|data
operator|==
literal|0xffffffff
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|data
operator|&
literal|0xe2f0fffd
operator|)
operator|!=
literal|0x02000080
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
literal|"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|sym_snooptest
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u32
name|sym_rd
decl_stmt|,
name|sym_wr
decl_stmt|,
name|sym_bk
decl_stmt|,
name|host_rd
decl_stmt|,
name|host_wr
decl_stmt|,
name|pc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|SYMCONF_IOMAPPED
name|err
operator||=
name|sym_regtest
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
endif|#
directive|endif
comment|/* 	 *  init 	 */
name|pc
operator|=
name|SCRIPTH0_BA
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
expr_stmt|;
name|host_wr
operator|=
literal|1
expr_stmt|;
name|sym_wr
operator|=
literal|2
expr_stmt|;
comment|/* 	 *  Set memory and register. 	 */
name|np
operator|->
name|cache
operator|=
name|cpu_to_scr
argument_list|(
name|host_wr
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|sym_wr
argument_list|)
expr_stmt|;
comment|/* 	 *  Start script (exchange values) 	 */
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|vtobus
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* 	 *  Wait 'til done (with timeout) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_SNOOP_TIMEOUT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
break|break;
comment|/* 	 *  Save termination position. 	 */
name|pc
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
comment|/* 	 *  Read memory and register. 	 */
name|host_rd
operator|=
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|cache
argument_list|)
expr_stmt|;
name|sym_rd
operator|=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
name|sym_bk
operator|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
expr_stmt|;
comment|/* 	 *  check for timeout 	 */
if|if
condition|(
name|i
operator|>=
name|SYM_SNOOP_TIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x20
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	 *  Check termination position. 	 */
if|if
condition|(
name|pc
operator|!=
name|SCRIPTH0_BA
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: script execution failed.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"start=%08lx, pc=%08lx, end=%08lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|SCRIPTH0_BA
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|pc
argument_list|,
operator|(
name|u_long
operator|)
name|SCRIPTH0_BA
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x40
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	 *  Show results. 	 */
if|if
condition|(
name|host_wr
operator|!=
name|sym_rd
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: host wrote %d, chip read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|host_wr
argument_list|,
operator|(
name|int
operator|)
name|sym_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|host_rd
operator|!=
name|sym_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: chip wrote %d, host read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|sym_wr
argument_list|,
operator|(
name|int
operator|)
name|host_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|2
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sym_bk
operator|!=
name|sym_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: chip wrote %d, read back %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|sym_wr
argument_list|,
operator|(
name|int
operator|)
name|sym_bk
argument_list|)
expr_stmt|;
name|err
operator||=
literal|4
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  *  Determine the chip's clock frequency.  *  *  This is essential for the negotiation of the synchronous   *  transfer rate.  *  *  Note: we have to return the correct value.  *  THERE IS NO SAFE DEFAULT VALUE.  *  *  Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.  *  53C860 and 53C875 rev. 1 support fast20 transfers but   *  do not have a clock doubler and so are provided with a   *  80 MHz clock. All other fast20 boards incorporate a doubler   *  and so should be delivered with a 40 MHz clock.  *  The recent fast40 chips (895/896/895A/1010) use a 40 Mhz base   *  clock and provide a clock quadrupler (160 Mhz).  */
comment|/*  *  Select SCSI clock frequency  */
specifier|static
name|void
name|sym_selectclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|scntl3
parameter_list|)
block|{
comment|/* 	 *  If multiplier not present or not selected, leave here. 	 */
if|if
condition|(
name|np
operator|->
name|multiplier
operator|<=
literal|1
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: enabling clock multiplier\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|DBLEN
argument_list|)
expr_stmt|;
comment|/* Enable clock multiplier		  */
comment|/* 	 *  Wait for the LCKFRQ bit to be set if supported by the chip. 	 *  Otherwise wait 20 micro-seconds. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LCKFRQ
condition|)
block|{
name|int
name|i
init|=
literal|20
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|LCKFRQ
operator|)
operator|&&
operator|--
name|i
operator|>
literal|0
condition|)
name|UDELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|printf
argument_list|(
literal|"%s: the chip cannot lock the frequency\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|UDELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|HSC
argument_list|)
expr_stmt|;
comment|/* Halt the scsi clock		*/
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
operator|(
name|DBLEN
operator||
name|DBLSEL
operator|)
argument_list|)
expr_stmt|;
comment|/* Select clock multiplier	*/
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Restart scsi clock 		*/
block|}
comment|/*  *  calculate SCSI clock frequency (in KHz)  */
specifier|static
name|unsigned
name|getfreq
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|unsigned
name|int
name|ms
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|f
decl_stmt|;
comment|/* 	 * Measure GEN timer delay in order  	 * to calculate SCSI clock frequency 	 * 	 * This code will never execute too 	 * many loop iterations (if DELAY is  	 * reasonably correct). It could get 	 * too low a delay (too high a freq.) 	 * if the CPU is slow executing the  	 * loop for some reason (an NMI, for 	 * example). For this reason we will 	 * if multiple measurements are to be  	 * performed trust the higher delay  	 * (lower frequency returned). 	 */
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all scsi interrupts */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* clear pending scsi interrupt */
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all dma interrupts */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* another one, just to be sure :) */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* set pre-scaler to divide by 3 */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* set to nominal delay of 1<<gen * 125us */
while|while
condition|(
operator|!
operator|(
name|INW
argument_list|(
name|nc_sist
argument_list|)
operator|&
name|GEN
operator|)
operator|&&
name|ms
operator|++
operator|<
literal|100000
condition|)
name|UDELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* count ms */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer */
comment|/*  	 * set prescaler to divide by whatever 0 means  	 * 0 ought to choose divide by 2, but appears  	 * to set divide by 3.5 mode in my 53c810 ...  	 */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  	 * adjust for prescaler, and convert into KHz    	 */
name|f
operator|=
name|ms
condition|?
operator|(
operator|(
literal|1
operator|<<
name|gen
operator|)
operator|*
literal|4340
operator|)
operator|/
name|ms
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: Delay (GEN=%d): %u msec, %u KHz\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|gen
argument_list|,
name|ms
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
specifier|static
name|unsigned
name|sym_getfreq
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|int
name|gen
init|=
literal|11
decl_stmt|;
operator|(
name|void
operator|)
name|getfreq
argument_list|(
name|np
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* throw away first result */
name|f1
operator|=
name|getfreq
argument_list|(
name|np
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|f2
operator|=
name|getfreq
argument_list|(
name|np
argument_list|,
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|>
name|f2
condition|)
name|f1
operator|=
name|f2
expr_stmt|;
comment|/* trust lower result	*/
return|return
name|f1
return|;
block|}
comment|/*  *  Get/probe chip SCSI clock frequency  */
specifier|static
name|void
name|sym_getclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|mult
parameter_list|)
block|{
name|unsigned
name|char
name|scntl3
init|=
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|stest1
init|=
name|INB
argument_list|(
name|nc_stest1
argument_list|)
decl_stmt|;
name|unsigned
name|f1
decl_stmt|;
comment|/* 	 *  For the C10 core, assume 40 MHz. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|np
operator|->
name|multiplier
operator|=
name|mult
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
literal|40000
operator|*
name|mult
expr_stmt|;
return|return;
block|}
name|np
operator|->
name|multiplier
operator|=
literal|1
expr_stmt|;
name|f1
operator|=
literal|40000
expr_stmt|;
comment|/* 	 *  True with 875/895/896/895A with clock multiplier selected 	 */
if|if
condition|(
name|mult
operator|>
literal|1
operator|&&
operator|(
name|stest1
operator|&
operator|(
name|DBLEN
operator|+
name|DBLSEL
operator|)
operator|)
operator|==
name|DBLEN
operator|+
name|DBLSEL
condition|)
block|{
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: clock multiplier found\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|multiplier
operator|=
name|mult
expr_stmt|;
block|}
comment|/* 	 *  If multiplier not found or scntl3 not 7,5,3, 	 *  reset chip and get frequency from general purpose timer. 	 *  Otherwise trust scntl3 BIOS setting. 	 */
if|if
condition|(
name|np
operator|->
name|multiplier
operator|!=
name|mult
operator|||
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|<
literal|3
operator|||
operator|!
operator|(
name|scntl3
operator|&
literal|1
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure doubler is OFF */
name|f1
operator|=
name|sym_getfreq
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_verbose
condition|)
name|printf
argument_list|(
literal|"%s: chip clock is %uKHz\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|f1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|45000
condition|)
name|f1
operator|=
literal|40000
expr_stmt|;
elseif|else
if|if
condition|(
name|f1
operator|<
literal|55000
condition|)
name|f1
operator|=
literal|50000
expr_stmt|;
else|else
name|f1
operator|=
literal|80000
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|80000
operator|&&
name|mult
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: clock multiplier assumed\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|multiplier
operator|=
name|mult
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|3
condition|)
name|f1
operator|=
literal|40000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|5
condition|)
name|f1
operator|=
literal|80000
expr_stmt|;
else|else
name|f1
operator|=
literal|160000
expr_stmt|;
name|f1
operator|/=
name|np
operator|->
name|multiplier
expr_stmt|;
block|}
comment|/* 	 *  Compute controller synchronous parameters. 	 */
name|f1
operator|*=
name|np
operator|->
name|multiplier
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
name|f1
expr_stmt|;
block|}
comment|/*  *  Get/probe PCI clock frequency  */
specifier|static
name|int
name|sym_getpciclock
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
specifier|static
name|int
name|f
init|=
literal|0
decl_stmt|;
comment|/* For the C10, this will not work */
if|if
condition|(
operator|!
name|f
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|SCLK
argument_list|)
expr_stmt|;
comment|/* Use the PCI clock as SCSI clock */
name|f
operator|=
operator|(
name|int
operator|)
name|sym_getfreq
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
comment|/*============= DRIVER ACTION/COMPLETION ====================*/
comment|/*  *  Print something that tells about extended errors.  */
specifier|static
name|void
name|sym_print_xerr
parameter_list|(
name|ccb_p
name|cp
parameter_list|,
name|int
name|x_status
parameter_list|)
block|{
if|if
condition|(
name|x_status
operator|&
name|XE_PARITY_ERR
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unrecovered SCSI parity error.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_EXTRA_DATA
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extraneous data discarded.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_BAD_PHASE
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"illegal scsi phase (4/5).\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_SODL_UNRUN
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ODD transfer in DATA OUT phase.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_SWIDE_OVRUN
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ODD transfer in DATA IN phase.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *  Choose the more appropriate CAM status if   *  the IO encountered an extended error.  */
specifier|static
name|int
name|sym_xerr_cam_status
parameter_list|(
name|int
name|cam_status
parameter_list|,
name|int
name|x_status
parameter_list|)
block|{
if|if
condition|(
name|x_status
condition|)
block|{
if|if
condition|(
name|x_status
operator|&
name|XE_PARITY_ERR
condition|)
name|cam_status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
elseif|else
if|if
condition|(
name|x_status
operator|&
operator|(
name|XE_EXTRA_DATA
operator||
name|XE_SODL_UNRUN
operator||
name|XE_SWIDE_OVRUN
operator|)
condition|)
name|cam_status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|x_status
operator|&
name|XE_BAD_PHASE
condition|)
name|cam_status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
else|else
name|cam_status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
return|return
name|cam_status
return|;
block|}
comment|/*  *  Complete execution of a SCSI command with extented   *  error, SCSI status error, or having been auto-sensed.  *  *  The SCRIPTS processor is not running there, so we   *  can safely access IO registers and remove JOBs from    *  the START queue.  *  SCRATCHA is assumed to have been loaded with STARTPOS   *  before the SCRIPTS called the C code.  */
specifier|static
name|void
name|sym_complete_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|u_int
name|cam_status
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  Paranoid check. :) 	 */
if|if
condition|(
operator|!
name|cp
operator|||
operator|!
name|cp
operator|->
name|cam_ccb
condition|)
return|return;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_TINY
operator||
name|DEBUG_RESULT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"CCB=%lx STAT=%x/%x/%x DEV=%d/%d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cp
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|ssss_status
argument_list|,
name|cp
operator|->
name|host_flags
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
name|MDELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Get command, target and lun pointers. 	 */
name|csio
operator|=
operator|&
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
expr_stmt|;
comment|/* 	 *  Check for extended errors. 	 */
if|if
condition|(
name|cp
operator|->
name|xerr_status
condition|)
block|{
if|if
condition|(
name|sym_verbose
condition|)
name|sym_print_xerr
argument_list|(
name|cp
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
name|cp
operator|->
name|host_status
operator|=
name|HS_COMP_ERR
expr_stmt|;
block|}
comment|/* 	 *  Calculate the residual. 	 */
name|csio
operator|->
name|sense_resid
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|sym_compute_residual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SYMCONF_RESIDUAL_SUPPORT
condition|)
block|{
comment|/* If user does not want residuals */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* throw them away. :)		   */
name|cp
operator|->
name|sv_resid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
block|{
comment|/* Auto sense     */
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|sv_scsi_status
expr_stmt|;
comment|/* Restore status */
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
comment|/* Swap residuals */
name|csio
operator|->
name|resid
operator|=
name|cp
operator|->
name|sv_resid
expr_stmt|;
name|cp
operator|->
name|sv_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sym_verbose
operator|&&
name|cp
operator|->
name|sv_xerr_status
condition|)
name|sym_print_xerr
argument_list|(
name|cp
argument_list|,
name|cp
operator|->
name|sv_xerr_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
operator|&&
name|cp
operator|->
name|ssss_status
operator|==
name|S_GOOD
operator|&&
name|cp
operator|->
name|xerr_status
operator|==
literal|0
condition|)
block|{
name|cam_status
operator|=
name|sym_xerr_cam_status
argument_list|(
name|CAM_SCSI_STATUS_ERROR
argument_list|,
name|cp
operator|->
name|sv_xerr_status
argument_list|)
expr_stmt|;
name|cam_status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 *  If the device reports a UNIT ATTENTION condition  			 *  due to a RESET condition, we should consider all  			 *  disconnect CCBs for this unit as aborted. 			 */
block|if (1) { 				u_char *p; 				p  = (u_char *)&cp->cam_ccb->csio.sense_data; 				if (p[0]==0x70&& p[2]==0x6&& p[12]==0x29) 					sym_clear_tasks(np, CAM_REQ_ABORTED, 							cp->target,cp->lun, -1); 			}
endif|#
directive|endif
block|}
else|else
name|cam_status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
block|{
comment|/* Bad SCSI status */
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
name|cam_status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_SEL_TIMEOUT
condition|)
comment|/* Selection timeout */
name|cam_status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_UNEXPECTED
condition|)
comment|/* Unexpected BUS FREE*/
name|cam_status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
else|else
block|{
comment|/* Extended error */
if|if
condition|(
name|sym_verbose
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"COMMAND FAILED (%x %x %x).\n"
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|ssss_status
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
block|}
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
comment|/* 		 *  Set the most appropriate value for CAM status. 		 */
name|cam_status
operator|=
name|sym_xerr_cam_status
argument_list|(
name|CAM_REQ_CMP_ERR
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Dequeue all queued CCBs for that device  	 *  not yet started by SCRIPTS. 	 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|vtobus
argument_list|(
name|np
operator|->
name|squeue
argument_list|)
operator|)
operator|/
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 *  Restart the SCRIPTS processor. 	 */
name|OUTL
argument_list|(
name|nc_dsp
argument_list|,
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Add this one to the COMP queue. 	 *  Complete all those commands with either error  	 *  or requeue condition. 	 */
name|sym_set_cam_status
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
name|sym_remque
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Complete execution of a successful SCSI command.  *  *  Only successful commands go to the DONE queue,   *  since we need to have the SCRIPTS processor   *  stopped on any error condition.  *  The SCRIPTS processor is running while we are   *  completing successful commands.  */
specifier|static
name|void
name|sym_complete_ok
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
comment|/* 	 *  Paranoid check. :) 	 */
if|if
condition|(
operator|!
name|cp
operator|||
operator|!
name|cp
operator|->
name|cam_ccb
condition|)
return|return;
name|assert
argument_list|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
argument_list|)
expr_stmt|;
comment|/* 	 *  Get command, target and lun pointers. 	 */
name|csio
operator|=
operator|&
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
expr_stmt|;
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 *  Assume device discovered on first success. 	 */
if|if
condition|(
operator|!
name|lp
condition|)
name|sym_set_bit
argument_list|(
name|tp
operator|->
name|lun_map
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 *  If all data have been transferred, given than no 	 *  extended error did occur, there is no residual. 	 */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|lastp
operator|!=
name|cp
operator|->
name|phys
operator|.
name|goalp
condition|)
name|csio
operator|->
name|resid
operator|=
name|sym_compute_residual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 *  Wrong transfer residuals may be worse than just always  	 *  returning zero. User can disable this feature from  	 *  sym_conf.h. Residual support is enabled by default. 	 */
if|if
condition|(
operator|!
name|SYMCONF_RESIDUAL_SUPPORT
condition|)
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Set status and complete the command. 	 */
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
name|sym_set_cam_status
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Our timeout handler.  */
specifier|static
name|void
name|sym_timeout1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|arg
decl_stmt|;
name|hcb_p
name|np
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|sym_hcb_ptr
decl_stmt|;
comment|/* 	 *  Check that the CAM CCB is still queued. 	 */
if|if
condition|(
operator|!
name|np
condition|)
return|return;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
operator|(
name|void
operator|)
name|sym_abort_scsiio
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
specifier|static
name|void
name|sym_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|s
init|=
name|splcam
argument_list|()
decl_stmt|;
name|sym_timeout1
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Abort an SCSI IO.  */
specifier|static
name|int
name|sym_abort_scsiio
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|timed_out
parameter_list|)
block|{
name|ccb_p
name|cp
decl_stmt|;
comment|/* 	 *  Look up our CCB control block. 	 */
for|for
control|(
name|cp
operator|=
name|np
operator|->
name|ccbc
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|link_ccb
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_IDLE
operator|&&
name|cp
operator|->
name|cam_ccb
operator|==
name|ccb
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|cp
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 *  If a previous abort didn't succeed in time, 	 *  perform a BUS reset. 	 */
if|if
condition|(
name|cp
operator|->
name|to_abort
condition|)
block|{
name|sym_reset_scsi_bus
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 *  Mark the CCB for abort and allow time for. 	 */
name|cp
operator|->
name|to_abort
operator|=
name|timed_out
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|sym_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCRIPTS processor to stop and synchronize with us. 	 */
name|np
operator|->
name|istat_sem
operator|=
name|SEM
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
operator||
name|SEM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  Reset a SCSI device (all LUNs of a target).  */
specifier|static
name|void
name|sym_reset_dev
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|tcb_p
name|tp
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|target_id
operator|==
name|np
operator|->
name|myaddr
operator|||
name|ccb_h
operator|->
name|target_id
operator|>=
name|SYMCONF_MAX_TARGET
operator|||
name|ccb_h
operator|->
name|target_lun
operator|>=
name|SYMCONF_MAX_LUN
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|1
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|np
operator|->
name|istat_sem
operator|=
name|SEM
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
operator||
name|SEM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  *  SIM action entry point.  */
specifier|static
name|void
name|sym_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|s
init|=
name|splcam
argument_list|()
decl_stmt|;
name|sym_action1
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|sym_action1
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|hcb_p
name|np
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|u_char
name|idmsg
decl_stmt|,
modifier|*
name|msgptr
decl_stmt|;
name|u_int
name|msglen
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"sym_action\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Retrieve our controller data structure. 	 */
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
comment|/* 	 *  The common case is SCSI IO. 	 *  We deal with other ones elsewhere. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_SCSI_IO
condition|)
block|{
name|sym_action2
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 *  Work around races. 	 */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Minimal checkings, so that we will not  	 *  go outside our tables. 	 */
if|if
condition|(
name|ccb_h
operator|->
name|target_id
operator|==
name|np
operator|->
name|myaddr
operator|||
name|ccb_h
operator|->
name|target_id
operator|>=
name|SYMCONF_MAX_TARGET
operator|||
name|ccb_h
operator|->
name|target_lun
operator|>=
name|SYMCONF_MAX_LUN
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Retreive the target and lun descriptors. 	 */
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
comment|/* 	 *  Complete the 1st INQUIRY command with error  	 *  condition if the device is flagged NOSCAN  	 *  at BOOT in the NVRAM. This may speed up  	 *  the boot and maintain coherency with BIOS  	 *  device numbering. Clearing the flag allows  	 *  user to rescan skipped devices later. 	 *  We also return error for devices not flagged  	 *  for SCAN LUNS in the NVRAM since some mono-lun  	 *  devices behave badly when asked for some non  	 *  zero LUN. Btw, this is an absolute hack.:-) 	 */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|&&
operator|(
literal|0x12
operator|==
operator|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
index|[
literal|0
index|]
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|usrflags
operator|&
name|SYM_SCAN_BOOT_DISABLED
operator|)
operator|||
operator|(
operator|(
name|tp
operator|->
name|usrflags
operator|&
name|SYM_SCAN_LUNS_DISABLED
operator|)
operator|&&
name|ccb_h
operator|->
name|target_lun
operator|!=
literal|0
operator|)
condition|)
block|{
name|tp
operator|->
name|usrflags
operator|&=
operator|~
name|SYM_SCAN_BOOT_DISABLED
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 *  Get a control block for this IO. 	 */
name|tmp
operator|=
operator|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|cp
operator|=
name|sym_get_ccb
argument_list|(
name|np
argument_list|,
name|ccb_h
operator|->
name|target_id
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_RESRC_UNAVAIL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Enqueue this IO in our pending queue. 	 */
name|cp
operator|->
name|cam_ccb
operator|=
name|ccb
expr_stmt|;
name|sym_enqueue_cam_ccb
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 *  Build the IDENTIFY message. 	 */
name|idmsg
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
operator|||
operator|(
name|lp
operator|&&
operator|(
name|lp
operator|->
name|current_flags
operator|&
name|SYM_DISC_ENABLED
operator|)
operator|)
condition|)
name|idmsg
operator||=
literal|0x40
expr_stmt|;
name|msgptr
operator|=
name|cp
operator|->
name|scsi_smsg
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|idmsg
expr_stmt|;
comment|/* 	 *  Build the tag message if present. 	 */
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
condition|)
block|{
name|u_char
name|order
init|=
name|csio
operator|->
name|tag_action
decl_stmt|;
switch|switch
condition|(
name|order
condition|)
block|{
case|case
name|M_ORDERED_TAG
case|:
break|break;
case|case
name|M_HEAD_TAG
case|:
break|break;
default|default:
name|order
operator|=
name|M_SIMPLE_TAG
expr_stmt|;
block|}
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|order
expr_stmt|;
comment|/* 		 *  For less than 128 tags, actual tags are numbered  		 *  1,3,5,..2*MAXTAGS+1,since we may have to deal  		 *  with devices that have problems with #TAG 0 or too  		 *  great #TAG numbers. For more tags (up to 256),  		 *  we use directly our tag number. 		 */
if|#
directive|if
name|SYMCONF_MAX_TASK
operator|>
operator|(
literal|512
operator|/
literal|4
operator|)
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|cp
operator|->
name|tag
expr_stmt|;
else|#
directive|else
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
operator|(
name|cp
operator|->
name|tag
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 *  Build a negotiation message if needed. 	 *  (nego_status is filled by sym_prepare_nego()) 	 */
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|||
if|#
directive|if
literal|0
comment|/* For now only renegotiate, based on width, period and offset */
expr|tp->tinfo.current.options != tp->tinfo.goal.options) {
else|#
directive|else
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|!
name|tp
operator|->
name|nego_cp
operator|&&
name|lp
condition|)
name|msglen
operator|+=
name|sym_prepare_nego
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
name|msgptr
operator|+
name|msglen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Fill in our ccb 	 */
comment|/* 	 *  Startqueue 	 */
name|cp
operator|->
name|phys
operator|.
name|go
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|go
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|resel_dsa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  select 	 */
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_id
operator|=
name|cp
operator|->
name|target
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|wval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|sval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl4
operator|=
name|tp
operator|->
name|uval
expr_stmt|;
comment|/* 	 *  message 	 */
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|CCB_PHYS
argument_list|(
name|cp
argument_list|,
name|scsi_smsg
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
comment|/* 	 *  command 	 */
if|if
condition|(
name|sym_setup_cdb
argument_list|(
name|np
argument_list|,
name|csio
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  status 	 */
if|#
directive|if
literal|0
comment|/* Provision */
block|cp->actualquirks	= tp->quirks;
endif|#
directive|endif
name|cp
operator|->
name|actualquirks
operator|=
name|SYM_QUIRK_AUTOSAVE
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|cp
operator|->
name|nego_status
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|ssss_status
operator|=
name|S_ILLEGAL
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|host_flags
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|extra_bytes
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  extreme data pointer. 	 *  shall be positive, so -1 is lower than lowest.:) 	 */
name|cp
operator|->
name|ext_sg
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|->
name|ext_ofs
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Build the data descriptor block  	 *  and start the IO. 	 */
if|if
condition|(
name|sym_setup_data
argument_list|(
name|np
argument_list|,
name|csio
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/*  *  How complex it gets to deal with the CDB in CAM.  *  I bet, physical CDBs will never be used on the planet.  */
specifier|static
name|int
name|sym_setup_cdb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|u32
name|cmd_ba
decl_stmt|;
name|int
name|cmd_len
decl_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 *  CDB is 16 bytes max. 	 */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
literal|16
condition|)
block|{
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cmd_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
comment|/* CDB is a pointer */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
condition|)
block|{
comment|/* CDB pointer is virtual */
name|cmd_ba
operator|=
name|vtobus
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CDB pointer is physical */
if|#
directive|if
literal|0
block|cmd_ba = ((u32)csio->cdb_io.cdb_ptr)& 0xffffffff;
else|#
directive|else
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* CDB is in the ccb (buffer) */
name|cmd_ba
operator|=
name|vtobus
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|cmd_ba
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|cmd_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  How complex it gets to deal with the data in CAM.  *  I bet physical data will never be used in our galaxy.  */
specifier|static
name|int
name|sym_setup_data
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|retv
decl_stmt|;
name|u32
name|lastp
decl_stmt|,
name|goalp
decl_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 *  Now deal with the data. 	 */
name|cp
operator|->
name|data_len
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|segments
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  No direction means no data. 	 */
name|dir
operator|=
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|CAM_DIR_NONE
condition|)
goto|goto
name|end_scatter
goto|;
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
condition|)
block|{
comment|/* Single buffer */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* Buffer is virtual */
name|retv
operator|=
name|sym_scatter_virtual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
argument_list|,
operator|(
name|vm_size_t
operator|)
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Buffer is physical */
name|retv
operator|=
name|sym_scatter_physical
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|csio
operator|->
name|data_ptr
argument_list|,
operator|(
name|vm_size_t
operator|)
name|csio
operator|->
name|dxfer_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
goto|goto
name|too_big
goto|;
block|}
else|else
block|{
comment|/* Scatter/gather list */
name|int
name|i
decl_stmt|;
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The SG list pointer is physical */
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|retv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* SG buffer pointers are virtual */
for|for
control|(
name|i
operator|=
name|csio
operator|->
name|sglist_cnt
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|retv
operator|=
name|sym_scatter_virtual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
break|break;
block|}
block|}
else|else
block|{
comment|/* SG buffer pointers are physical */
for|for
control|(
name|i
operator|=
name|csio
operator|->
name|sglist_cnt
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|retv
operator|=
name|sym_scatter_physical
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
goto|goto
name|too_big
goto|;
block|}
name|end_scatter
label|:
comment|/* 	 *  No segments means no data. 	 */
if|if
condition|(
operator|!
name|cp
operator|->
name|segments
condition|)
name|dir
operator|=
name|CAM_DIR_NONE
expr_stmt|;
comment|/* 	 *  Set the data pointer. 	 */
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|CAM_DIR_OUT
case|:
name|goalp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|data_out2
argument_list|)
operator|+
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_U3EN
operator|)
operator|)
operator|==
name|FE_C10
condition|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|&
name|PPR_OPT_DT
condition|)
name|goalp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|dt_data_out2
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
endif|#
directive|endif
name|lastp
operator|=
name|goalp
operator|-
literal|8
operator|-
operator|(
name|cp
operator|->
name|segments
operator|*
operator|(
literal|2
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CAM_DIR_IN
case|:
name|goalp
operator|=
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|data_in2
argument_list|)
operator|+
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMCONF_BROKEN_U3EN_SUPPORT
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_U3EN
operator|)
operator|)
operator|==
name|FE_C10
condition|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|&
name|PPR_OPT_DT
condition|)
name|goalp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|dt_data_in2
argument_list|)
operator|+
literal|8
expr_stmt|;
block|}
endif|#
directive|endif
name|lastp
operator|=
name|goalp
operator|-
literal|8
operator|-
operator|(
name|cp
operator|->
name|segments
operator|*
operator|(
literal|2
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
default|default:
name|lastp
operator|=
name|goalp
operator|=
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|no_data
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|->
name|phys
operator|.
name|lastp
operator|=
name|cpu_to_scr
argument_list|(
name|lastp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|goalp
operator|=
name|cpu_to_scr
argument_list|(
name|goalp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|savep
operator|=
name|cpu_to_scr
argument_list|(
name|lastp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|startp
operator|=
name|cp
operator|->
name|phys
operator|.
name|savep
expr_stmt|;
comment|/* 	 *  Activate this job. 	 *  If we have awaiting commands for that unit, 2 max  	 *  at a time is enough to flush the CCB wait queue. 	 */
name|sym_put_start_queue
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 *  Command is successfully queued. 	 */
return|return
literal|0
return|;
name|too_big
label|:
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*  *  Scatter a virtual buffer into bus addressable chunks.  */
specifier|static
name|int
name|sym_scatter_virtual
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
name|u_long
name|pe
decl_stmt|,
name|pn
decl_stmt|;
name|u_long
name|n
decl_stmt|,
name|k
decl_stmt|;
name|int
name|s
decl_stmt|;
name|cp
operator|->
name|data_len
operator|+=
name|len
expr_stmt|;
name|pe
operator|=
name|vaddr
operator|+
name|len
expr_stmt|;
name|n
operator|=
name|len
expr_stmt|;
name|s
operator|=
name|SYMCONF_MAX_SG
operator|-
literal|1
operator|-
name|cp
operator|->
name|segments
expr_stmt|;
while|while
condition|(
name|n
operator|&&
name|s
operator|>=
literal|0
condition|)
block|{
name|pn
operator|=
operator|(
name|pe
operator|-
literal|1
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|k
operator|=
name|pe
operator|-
name|pn
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|n
condition|)
block|{
name|k
operator|=
name|n
expr_stmt|;
name|pn
operator|=
name|pe
operator|-
name|n
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
block|{
name|printf
argument_list|(
literal|"%s scatter: va=%lx pa=%lx siz=%lx\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|pn
argument_list|,
operator|(
name|u_long
operator|)
name|vtobus
argument_list|(
name|pn
argument_list|)
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|s
index|]
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|pn
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|s
index|]
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|k
argument_list|)
expr_stmt|;
name|pe
operator|=
name|pn
expr_stmt|;
name|n
operator|-=
name|k
expr_stmt|;
operator|--
name|s
expr_stmt|;
block|}
name|cp
operator|->
name|segments
operator|=
name|SYMCONF_MAX_SG
operator|-
literal|1
operator|-
name|s
expr_stmt|;
return|return
name|n
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
comment|/*  *  Will stay so forever, in my opinion.  */
specifier|static
name|int
name|sym_scatter_physical
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|vm_offset_t
name|vaddr
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/*  *  SIM action for non performance critical stuff.  */
specifier|static
name|void
name|sym_action2
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|hcb_p
name|np
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
comment|/* 	 *  Retrieve our controller data structure. 	 */
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
switch|switch
condition|(
name|ccb_h
operator|->
name|func_code
condition|)
block|{
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
comment|/* 		 *  Update user transfer settings if asked by user. 		 */
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|sym_update_trans
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|user
argument_list|,
name|cts
argument_list|)
expr_stmt|;
comment|/* 		 *  Update current wished settings if asked by user. 		 *  Force negotiations if something has changed. 		 */
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|sym_update_trans
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|goal
argument_list|,
name|cts
argument_list|)
expr_stmt|;
comment|/* 		 *  The guys that have implemented this CAM seem to  		 *  have made the common mistake about the CmdQue flag. 		 *  This feature is a device feature and so must be  		 *  handled per logical unit. 		 */
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_USER_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|sym_update_dflags
argument_list|(
name|np
argument_list|,
operator|&
name|lp
operator|->
name|user_flags
argument_list|,
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
name|sym_update_dflags
argument_list|(
name|np
argument_list|,
operator|&
name|lp
operator|->
name|current_flags
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|sym_trans
modifier|*
name|tip
decl_stmt|;
name|u_char
name|dflags
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_CURRENT_SETTINGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|tip
operator|=
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|current
expr_stmt|;
name|dflags
operator|=
name|lp
condition|?
name|lp
operator|->
name|current_flags
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tip
operator|=
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|user
expr_stmt|;
name|dflags
operator|=
name|lp
condition|?
name|lp
operator|->
name|user_flags
else|:
name|tp
operator|->
name|usrflags
expr_stmt|;
block|}
name|cts
operator|->
name|sync_period
operator|=
name|tip
operator|->
name|period
expr_stmt|;
name|cts
operator|->
name|sync_offset
operator|=
name|tip
operator|->
name|offset
expr_stmt|;
name|cts
operator|->
name|bus_width
operator|=
name|tip
operator|->
name|width
expr_stmt|;
name|cts
operator|->
name|valid
operator|=
name|CCB_TRANS_SYNC_RATE_VALID
operator||
name|CCB_TRANS_SYNC_OFFSET_VALID
operator||
name|CCB_TRANS_BUS_WIDTH_VALID
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
name|cts
operator|->
name|flags
operator|&=
operator|~
operator|(
name|CCB_TRANS_DISC_ENB
operator||
name|CCB_TRANS_TAG_ENB
operator|)
expr_stmt|;
if|if
condition|(
name|dflags
operator|&
name|SYM_DISC_ENABLED
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|dflags
operator|&
name|SYM_TAGS_ENABLED
condition|)
name|cts
operator|->
name|flags
operator||=
name|CCB_TRANS_TAG_ENB
expr_stmt|;
name|cts
operator|->
name|valid
operator||=
name|CCB_TRANS_DISC_VALID
expr_stmt|;
name|cts
operator|->
name|valid
operator||=
name|CCB_TRANS_TQ_VALID
expr_stmt|;
block|}
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|struct
name|ccb_calc_geometry
modifier|*
name|ccg
decl_stmt|;
name|u32
name|size_mb
decl_stmt|;
name|u32
name|secs_per_cylinder
decl_stmt|;
name|int
name|extended
decl_stmt|;
comment|/* 		 *  Silly DOS geometry.   		 */
name|ccg
operator|=
operator|&
name|ccb
operator|->
name|ccg
expr_stmt|;
name|size_mb
operator|=
name|ccg
operator|->
name|volume_size
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|ccg
operator|->
name|block_size
operator|)
expr_stmt|;
name|extended
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|size_mb
operator|>
literal|1024
operator|&&
name|extended
condition|)
block|{
name|ccg
operator|->
name|heads
operator|=
literal|255
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|63
expr_stmt|;
block|}
else|else
block|{
name|ccg
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|ccg
operator|->
name|secs_per_track
operator|=
literal|32
expr_stmt|;
block|}
name|secs_per_cylinder
operator|=
name|ccg
operator|->
name|heads
operator|*
name|ccg
operator|->
name|secs_per_track
expr_stmt|;
name|ccg
operator|->
name|cylinders
operator|=
name|ccg
operator|->
name|volume_size
operator|/
name|secs_per_cylinder
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_MDP_ABLE
operator||
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
comment|/* Semantic problem:)LUN number max = max number of LUNs - 1 */
name|cpi
operator|->
name|max_lun
operator|=
name|SYMCONF_MAX_LUN
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|np
operator|->
name|myaddr
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"Gerard Roudier"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Symbios"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
init|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
decl_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
name|sym_abort_scsiio
argument_list|(
name|np
argument_list|,
name|abort_ccb
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_UA_ABORT
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
block|{
name|sym_reset_dev
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
block|{
name|sym_reset_scsi_bus
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sym_init
argument_list|(
name|np
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_verbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI bus reset delivered.\n"
argument_list|)
expr_stmt|;
block|}
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
case|case
name|XPT_EN_LUN
case|:
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_TERM_IO
case|:
default|default:
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*  *  Update transfer settings of a target.  */
specifier|static
name|void
name|sym_update_trans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|struct
name|sym_trans
modifier|*
name|tip
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
comment|/* 	 *  Update the infos. 	 */
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_BUS_WIDTH_VALID
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|width
operator|=
name|cts
operator|->
name|bus_width
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_OFFSET_VALID
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|offset
operator|=
name|cts
operator|->
name|sync_offset
expr_stmt|;
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_SYNC_RATE_VALID
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|period
operator|=
name|cts
operator|->
name|sync_period
expr_stmt|;
comment|/* 	 *  Scale against out limits. 	 */
if|if
condition|(
name|tip
operator|->
name|width
operator|>
name|SYMSETUP_MAX_WIDE
condition|)
name|tip
operator|->
name|width
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|width
operator|>
name|np
operator|->
name|maxwide
condition|)
name|tip
operator|->
name|width
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|offset
operator|>
name|SYMSETUP_MAX_OFFS
condition|)
name|tip
operator|->
name|offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|offset
operator|>
name|np
operator|->
name|maxoffs
condition|)
name|tip
operator|->
name|offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|period
condition|)
block|{
if|if
condition|(
name|tip
operator|->
name|period
operator|<
name|SYMSETUP_MIN_SYNC
condition|)
name|tip
operator|->
name|period
operator|=
name|SYMSETUP_MIN_SYNC
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
condition|)
block|{
if|if
condition|(
name|tip
operator|->
name|period
operator|<
name|np
operator|->
name|minsync_dt
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|minsync_dt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tip
operator|->
name|period
operator|<
name|np
operator|->
name|minsync
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|tip
operator|->
name|period
operator|>
name|np
operator|->
name|maxsync
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|maxsync
expr_stmt|;
block|}
block|}
comment|/*  *  Update flags for a device (logical unit).  */
specifier|static
name|void
name|sym_update_dflags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|flags
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_DISC_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|flags
operator||=
name|SYM_DISC_ENABLED
expr_stmt|;
else|else
operator|*
name|flags
operator|&=
operator|~
name|SYM_DISC_ENABLED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts
operator|->
name|valid
operator|&
name|CCB_TRANS_TQ_VALID
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts
operator|->
name|flags
operator|&
name|CCB_TRANS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|flags
operator||=
name|SYM_TAGS_ENABLED
expr_stmt|;
else|else
operator|*
name|flags
operator|&=
operator|~
name|SYM_TAGS_ENABLED
expr_stmt|;
block|}
block|}
comment|/*============= DRIVER INITIALISATION ==================*/
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
specifier|static
name|device_method_t
name|sym_pci_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sym_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sym_pci_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|driver_t
name|sym_pci_driver
init|=
block|{
literal|"sym"
block|,
name|sym_pci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|sym_hcb
operator|)
block|}
decl_stmt|;
specifier|static
name|devclass_t
name|sym_devclass
decl_stmt|;
name|DRIVER_MODULE
argument_list|(
name|sym
argument_list|,
name|pci
argument_list|,
name|sym_pci_driver
argument_list|,
name|sym_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Pre-FreeBSD_4_Bus */
specifier|static
name|u_long
name|sym_unit
decl_stmt|;
specifier|static
name|struct
name|pci_device
name|sym_pci_driver
init|=
block|{
literal|"sym"
block|,
name|sym_pci_probe
block|,
name|sym_pci_attach
block|,
operator|&
name|sym_unit
block|,
name|NULL
block|}
decl_stmt|;
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|sym_pci_driver
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FreeBSD_4_Bus */
specifier|static
name|struct
name|sym_pci_chip
name|sym_pci_dev_table
index|[]
init|=
block|{
block|{
name|PCI_ID_SYM53C810
block|,
literal|0xff
block|,
literal|"810a"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
name|FE_CACHE_SET
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_BOF
block|}
block|,
block|{
name|PCI_ID_SYM53C825
block|,
literal|0xff
block|,
literal|"825a"
block|,
literal|6
block|,
literal|8
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C860
block|,
literal|0xff
block|,
literal|"860"
block|,
literal|4
block|,
literal|8
block|,
literal|5
block|,
name|FE_ULTRA
operator||
name|FE_CLK80
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
block|}
block|,
block|{
name|PCI_ID_SYM53C875
block|,
literal|0x01
block|,
literal|"875"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_CLK80
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C875
block|,
literal|0xff
block|,
literal|"875"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C875_2
block|,
literal|0xff
block|,
literal|"875_2"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C885
block|,
literal|0xff
block|,
literal|"885"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C895
block|,
literal|0xff
block|,
literal|"895"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_LCKFRQ
block|}
block|,
block|{
name|PCI_ID_SYM53C896
block|,
literal|0xff
block|,
literal|"896"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_LCKFRQ
block|}
block|,
block|{
name|PCI_ID_SYM53C895A
block|,
literal|0xff
block|,
literal|"895a"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_LCKFRQ
block|}
block|,
block|{
name|PCI_ID_LSI53C1010
block|,
literal|0x45
block|,
literal|"1010"
block|,
literal|6
block|,
literal|62
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA3
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFBC
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_PCI66
operator||
name|FE_CRC
operator||
name|FE_C10
block|}
block|,
block|{
name|PCI_ID_LSI53C1010
block|,
literal|0xff
block|,
literal|"1010"
block|,
literal|6
block|,
literal|62
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA3
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFBC
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_PCI66
operator||
name|FE_CRC
operator||
name|FE_C10
operator||
name|FE_U3EN
block|}
block|,
block|{
name|PCI_ID_LSI53C1510D
block|,
literal|0xff
block|,
literal|"1510D"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_IO256
operator||
name|FE_LEDC
block|}
block|}
decl_stmt|;
define|#
directive|define
name|sym_pci_num_devs
define|\
value|(sizeof(sym_pci_dev_table) / sizeof(sym_pci_dev_table[0]))
comment|/*  *  Look up the chip table.  *  *  Return a pointer to the chip entry if found,   *  zero otherwise.  */
specifier|static
name|struct
name|sym_pci_chip
modifier|*
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|sym_find_pci_chip
parameter_list|(
name|device_t
name|dev
parameter_list|)
else|#
directive|else
function|sym_find_pci_chip
parameter_list|(
name|pcici_t
name|pci_tag
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_short
name|device_id
decl_stmt|;
name|u_char
name|revision
decl_stmt|;
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_VENDOR_NCR
condition|)
return|return
literal|0
return|;
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|revision
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
operator|!=
name|PCI_VENDOR_NCR
condition|)
return|return
literal|0
return|;
name|device_id
operator|=
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|revision
operator|=
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_pci_num_devs
condition|;
name|i
operator|++
control|)
block|{
name|chip
operator|=
operator|&
name|sym_pci_dev_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_id
operator|!=
name|chip
operator|->
name|device_id
condition|)
continue|continue;
if|if
condition|(
name|revision
operator|>
name|chip
operator|->
name|revision_id
condition|)
continue|continue;
if|if
condition|(
name|FE_LDSTR
operator|&
name|chip
operator|->
name|features
condition|)
return|return
name|chip
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  *  Tell upper layer if the chip is supported.  */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
specifier|static
name|int
name|sym_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|chip
operator|=
name|sym_find_pci_chip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|chip
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
else|#
directive|else
comment|/* Pre-FreeBSD_4_Bus */
specifier|static
specifier|const
name|char
modifier|*
name|sym_pci_probe
parameter_list|(
name|pcici_t
name|pci_tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|chip
operator|=
name|sym_find_pci_chip
argument_list|(
name|pci_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip
condition|)
return|return
name|chip
operator|->
name|name
return|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*  *  Attach a sym53c8xx device.  */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
specifier|static
name|int
name|sym_pci_attach
argument_list|(
name|device_t
name|dev
argument_list|)
else|#
directive|else
decl|static
name|void
name|sym_pci_attach
argument_list|(
name|pcici_t
name|pci_tag
argument_list|,
name|int
name|unit
argument_list|)
block|{
name|int
name|err
init|=
name|sym_pci_attach2
argument_list|(
name|pci_tag
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
name|printf
argument_list|(
literal|"sym: failed to attach unit %d - err=%d.\n"
argument_list|,
name|unit
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|sym_pci_attach2
parameter_list|(
name|pcici_t
name|pci_tag
parameter_list|,
name|int
name|unit
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|u_short
name|command
decl_stmt|;
name|u_char
name|cachelnsz
decl_stmt|;
name|struct
name|sym_hcb
modifier|*
name|np
init|=
literal|0
decl_stmt|;
name|struct
name|sym_nvram
name|nvram
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  Only probed devices should be attached. 	 *  We just enjoy being paranoid. :) 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|chip
operator|=
name|sym_find_pci_chip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|#
directive|else
name|chip
operator|=
name|sym_find_pci_chip
argument_list|(
name|pci_tag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 *  Allocate immediately the host control block,  	 *  since we are only expecting to succeed. :) 	 *  We keep track in the HCB of all the resources that  	 *  are to be released on error. 	 */
name|np
operator|=
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
literal|"HCB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Copy some useful infos to the HCB. 	 */
name|np
operator|->
name|verbose
operator|=
name|bootverbose
expr_stmt|;
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|np
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|np
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|np
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|np
operator|->
name|revision_id
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|#
directive|else
name|np
operator|->
name|pci_tag
operator|=
name|pci_tag
expr_stmt|;
name|np
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|np
operator|->
name|device_id
operator|=
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|np
operator|->
name|revision_id
operator|=
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_REVID
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|->
name|features
operator|=
name|chip
operator|->
name|features
expr_stmt|;
name|np
operator|->
name|clock_divn
operator|=
name|chip
operator|->
name|nr_divisor
expr_stmt|;
name|np
operator|->
name|maxoffs
operator|=
name|chip
operator|->
name|offset_max
expr_stmt|;
name|np
operator|->
name|maxburst
operator|=
name|chip
operator|->
name|burst_max
expr_stmt|;
comment|/* 	 * Edit its name. 	 */
name|snprintf
argument_list|(
name|np
operator|->
name|inst_name
argument_list|,
sizeof|sizeof
argument_list|(
name|np
operator|->
name|inst_name
argument_list|)
argument_list|,
literal|"sym%d"
argument_list|,
name|np
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 *  Read and apply some fix-ups to the PCI COMMAND  	 *  register. We want the chip to be enabled for: 	 *  - BUS mastering 	 *  - PCI parity checking (reporting would also be fine) 	 *  - Write And Invalidate. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|command
operator|=
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_PERRESPEN
expr_stmt|;
name|command
operator||=
comment|/* PCIM_CMD_MWIEN */
literal|0x0010
expr_stmt|;
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_cfgwrite
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Let the device know about the cache line size,  	 *  if it doesn't yet. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|cachelnsz
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|cachelnsz
operator|=
name|pci_cfgread
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cachelnsz
condition|)
block|{
name|cachelnsz
operator|=
literal|8
expr_stmt|;
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pci_cfgwrite
argument_list|(
name|pci_tag
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 *  Alloc/get/map/retrieve everything that deals with MMIO. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
if|if
condition|(
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regs_id
init|=
name|SYM_PCI_MMIO
decl_stmt|;
name|np
operator|->
name|mmio_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|regs_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|mmio_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate MMIO resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|mmio_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|mmio_tag
operator|=
name|rman_get_bustag
argument_list|(
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|mmio_pa
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|mmio_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|mmio_ba
operator|=
name|np
operator|->
name|mmio_pa
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|vm_offset_t
name|vaddr
decl_stmt|,
name|paddr
decl_stmt|;
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|pci_tag
argument_list|,
name|SYM_PCI_MMIO
argument_list|,
operator|&
name|vaddr
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to map MMIO window\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|mmio_va
operator|=
name|vaddr
expr_stmt|;
name|np
operator|->
name|mmio_pa
operator|=
name|paddr
expr_stmt|;
name|np
operator|->
name|mmio_ba
operator|=
name|paddr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 *  Allocate the IRQ. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|i
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|irq_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate IRQ resource\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYMCONF_IOMAPPED
comment|/* 	 *  User want us to use normal IO with PCI. 	 *  Alloc/get/map/retrieve everything that deals with IO. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
if|if
condition|(
operator|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regs_id
init|=
name|SYM_PCI_IO
decl_stmt|;
name|np
operator|->
name|io_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|regs_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|io_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate IO resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|io_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|np
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|io_tag
operator|=
name|rman_get_bustag
argument_list|(
name|np
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|io_port
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|io_res
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|pci_port_t
name|io_port
decl_stmt|;
if|if
condition|(
operator|!
name|pci_map_port
argument_list|(
name|pci_tag
argument_list|,
name|SYM_PCI_IO
argument_list|,
operator|&
name|io_port
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to map IO window\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|io_port
operator|=
name|io_port
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* SYMCONF_IOMAPPED */
comment|/* 	 *  If the chip has RAM. 	 *  Alloc/get/map/retrieve the corresponding resources. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_RAM
operator||
name|FE_RAM8K
operator|)
operator|)
operator|&&
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|int
name|regs_id
init|=
name|SYM_PCI_RAM
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
condition|)
name|regs_id
operator|=
name|SYM_PCI_RAM64
expr_stmt|;
name|np
operator|->
name|ram_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|regs_id
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|ram_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate RAM resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|ram_id
operator|=
name|regs_id
expr_stmt|;
name|np
operator|->
name|ram_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|ram_tag
operator|=
name|rman_get_bustag
argument_list|(
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|ram_pa
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|ram_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
name|np
operator|->
name|ram_ba
operator|=
name|np
operator|->
name|ram_pa
expr_stmt|;
else|#
directive|else
name|vm_offset_t
name|vaddr
decl_stmt|,
name|paddr
decl_stmt|;
name|int
name|regs_id
init|=
name|SYM_PCI_RAM
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
condition|)
name|regs_id
operator|=
name|SYM_PCI_RAM64
expr_stmt|;
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|pci_tag
argument_list|,
name|regs_id
argument_list|,
operator|&
name|vaddr
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to map RAM window\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|ram_va
operator|=
name|vaddr
expr_stmt|;
name|np
operator|->
name|ram_pa
operator|=
name|paddr
expr_stmt|;
name|np
operator|->
name|ram_ba
operator|=
name|paddr
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 *  Try to read the user set-up. 	 */
operator|(
name|void
operator|)
name|sym_read_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvram
argument_list|)
expr_stmt|;
comment|/* 	 *  Prepare controller and devices settings, according  	 *  to chip features, user set-up and driver set-up. 	 */
operator|(
name|void
operator|)
name|sym_prepare_setting
argument_list|(
name|np
argument_list|,
operator|&
name|nvram
argument_list|)
expr_stmt|;
comment|/* 	 *  Check the PCI clock frequency. 	 *  Must be performed after prepare_setting since it destroys  	 *  STEST1 that is used to probe for the clock doubler. 	 */
name|i
operator|=
name|sym_getpciclock
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|37000
condition|)
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI BUS clock seems too high: %u KHz.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s: PCI BUS clock seems too high: %u KHz.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Allocate the start queue. 	 */
name|np
operator|->
name|squeue
operator|=
operator|(
name|u32
operator|*
operator|)
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"SQUEUE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|squeue
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Allocate the done queue. 	 */
name|np
operator|->
name|dqueue
operator|=
operator|(
name|u32
operator|*
operator|)
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"DQUEUE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|dqueue
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Allocate the target bus address array. 	 */
name|np
operator|->
name|targtbl
operator|=
operator|(
name|u32
operator|*
operator|)
name|sym_calloc
argument_list|(
literal|256
argument_list|,
literal|"TARGTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|targtbl
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Allocate SCRIPTS areas. 	 */
name|np
operator|->
name|script0
operator|=
operator|(
expr|struct
name|sym_scr
operator|*
operator|)
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
argument_list|,
literal|"SCRIPT0"
argument_list|)
expr_stmt|;
name|np
operator|->
name|scripth0
operator|=
operator|(
expr|struct
name|sym_scrh
operator|*
operator|)
name|sym_calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
argument_list|,
literal|"SCRIPTH0"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|script0
operator|||
operator|!
name|np
operator|->
name|scripth0
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Initialyze the CCB free and busy queues. 	 *  Allocate some CCB. We need at least ONE. 	 */
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym_alloc_ccb
argument_list|(
name|np
argument_list|)
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 * Initialyze the CAM CCB pending queue. 	 */
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|cam_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  Fill-up variable-size parts of the SCRIPTS. 	 */
name|sym_fill_scripts
argument_list|(
operator|&
name|script0
argument_list|,
operator|&
name|scripth0
argument_list|)
expr_stmt|;
comment|/* 	 *  Calculate BUS addresses where we are going  	 *  to load the SCRIPTS. 	 */
name|np
operator|->
name|script_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|script0
argument_list|)
expr_stmt|;
name|np
operator|->
name|scripth_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|scripth0
argument_list|)
expr_stmt|;
name|np
operator|->
name|scripth0_ba
operator|=
name|np
operator|->
name|scripth_ba
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ram_ba
condition|)
block|{
name|np
operator|->
name|script_ba
operator|=
name|np
operator|->
name|ram_ba
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_RAM8K
condition|)
block|{
name|np
operator|->
name|ram_ws
operator|=
literal|8192
expr_stmt|;
name|np
operator|->
name|scripth_ba
operator|=
name|np
operator|->
name|script_ba
operator|+
literal|4096
expr_stmt|;
if|#
directive|if
name|BITS_PER_LONG
operator|>
literal|32
name|np
operator|->
name|scr_ram_seg
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|script_ba
operator|>>
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|np
operator|->
name|ram_ws
operator|=
literal|4096
expr_stmt|;
block|}
comment|/* 	 *  Bind SCRIPTS with physical addresses usable by the  	 *  SCRIPTS processor (as seen from the BUS = BUS addresses). 	 */
name|sym_bind_script
argument_list|(
name|np
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|script0
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|np
operator|->
name|script0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
argument_list|)
expr_stmt|;
name|sym_bind_script
argument_list|(
name|np
argument_list|,
operator|(
name|u32
operator|*
operator|)
operator|&
name|scripth0
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|np
operator|->
name|scripth0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  If not 64 bit chip, patch some places in SCRIPTS. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
operator|)
condition|)
block|{
name|np
operator|->
name|scripth0
operator|->
name|swide_fin_32
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_JUMP
argument_list|)
expr_stmt|;
name|np
operator|->
name|scripth0
operator|->
name|swide_fin_32
index|[
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Patch some variables in SCRIPTS. 	 *  These ones are loaded by the SCRIPTS processor. 	 */
name|np
operator|->
name|scripth0
operator|->
name|pm0_data_addr
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|scripth0
operator|->
name|pm1_data_addr
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Still some for LED support. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
condition|)
block|{
name|np
operator|->
name|script0
operator|->
name|idle
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_OR
argument_list|,
literal|0x01
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|script0
operator|->
name|reselected
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfe
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|script0
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_REG_REG
argument_list|(
name|gpreg
argument_list|,
name|SCR_AND
argument_list|,
literal|0xfe
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Load SCNTL4 on reselection for the C10. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|np
operator|->
name|script0
operator|->
name|resel_scntl4
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_LOAD_REL
argument_list|(
name|scntl4
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|script0
operator|->
name|resel_scntl4
index|[
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|uval
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYMCONF_IARB_SUPPORT
comment|/* 	 *    If user does not want to use IMMEDIATE ARBITRATION 	 *    when we are reselected while attempting to arbitrate, 	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP. 	 */
if|if
condition|(
operator|!
name|SYMCONF_SET_IARB_ON_ARB_LOST
condition|)
name|np
operator|->
name|script0
operator|->
name|ungetjob
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
comment|/* 	 *    If user wants IARB to be set when we win arbitration  	 *    and have other jobs, compute the max number of consecutive  	 *    settings of IARB hints before we leave devices a chance to  	 *    arbitrate for reselection. 	 */
ifdef|#
directive|ifdef
name|SYMSETUP_IARB_MAX
name|np
operator|->
name|iarb_max
operator|=
name|SYMSETUP_IARB_MAX
expr_stmt|;
else|#
directive|else
name|np
operator|->
name|iarb_max
operator|=
literal|4
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 *  Prepare the idle and invalid task actions. 	 */
name|np
operator|->
name|idletask
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|idletask
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|idletask_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|idletask
argument_list|)
expr_stmt|;
name|np
operator|->
name|notask
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|notask
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|notask_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|notask
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itl
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itl
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itl_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|bad_itl
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itlq
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPT_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itlq
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l_q
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itlq_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|bad_itlq
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate and prepare the lun JUMP table that is used  	 *  for a target prior the probing of devices (bad lun table). 	 *  A private table will be allocated for the target on the  	 *  first INQUIRY response received. 	 */
name|np
operator|->
name|badluntbl
operator|=
name|sym_calloc
argument_list|(
literal|256
argument_list|,
literal|"BADLUNTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|badluntbl
condition|)
goto|goto
name|attach_failed
goto|;
name|np
operator|->
name|badlun_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTH_BA
argument_list|(
name|np
argument_list|,
name|resel_bad_lun
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
comment|/* 64 luns/target, no less */
name|np
operator|->
name|badluntbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|badlun_sa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Prepare the bus address array that contains the bus  	 *  address of each target control bloc. 	 *  For now, assume all logical unit are wrong. :) 	 */
name|np
operator|->
name|scripth0
operator|->
name|targtbl
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|np
operator|->
name|targtbl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYMCONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|np
operator|->
name|targtbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|target
index|[
name|i
index|]
operator|.
name|luntbl_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|np
operator|->
name|badluntbl
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|target
index|[
name|i
index|]
operator|.
name|lun0_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|badlun_sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Reset the chip. 	 *  We should use sym_soft_reset(), but we donnot want to do  	 *  so, since we may not be safe if ABRT interrupt occurs due  	 *  to the BIOS or previous O/S having enable this interrupt. 	 */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  Now check the cache handling of the pci chipset. 	 */
if|if
condition|(
name|sym_snooptest
argument_list|(
name|np
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CACHE INCORRECTLY CONFIGURED.\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s: CACHE INCORRECTLY CONFIGURED.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|attach_failed
goto|;
block|}
empty_stmt|;
comment|/* 	 *  Now deal with CAM. 	 *  Hopefully, we will succeed with that one.:) 	 */
if|if
condition|(
operator|!
name|sym_cam_attach
argument_list|(
name|np
argument_list|)
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Sigh! we are done. 	 */
return|return
literal|0
return|;
comment|/* 	 *  We have failed. 	 *  We will try to free all the resources we have  	 *  allocated, but if we are a boot device, this  	 *  will not help that much.;) 	 */
name|attach_failed
label|:
if|if
condition|(
name|np
condition|)
name|sym_pci_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/*  *  Free everything that have been allocated for this device.  */
specifier|static
name|void
name|sym_pci_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|ccb_p
name|cp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 *  First free CAM resources. 	 */
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|sym_cam_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 *  Now every should be quiet for us to  	 *  free other resources. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
if|if
condition|(
name|np
operator|->
name|ram_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|np
operator|->
name|ram_id
argument_list|,
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|mmio_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|SYM_PCI_MMIO
argument_list|,
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|io_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|SYM_PCI_IO
argument_list|,
name|np
operator|->
name|io_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|np
operator|->
name|irq_res
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 *  YEAH!!! 	 *  It seems there is no means to free MMIO resources. 	 */
endif|#
directive|endif
if|if
condition|(
name|np
operator|->
name|scripth0
condition|)
name|sym_mfree
argument_list|(
name|np
operator|->
name|scripth0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scrh
argument_list|)
argument_list|,
literal|"SCRIPTH0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|script0
condition|)
name|sym_mfree
argument_list|(
name|np
operator|->
name|script0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sym_scr
argument_list|)
argument_list|,
literal|"SCRIPT0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|squeue
condition|)
name|sym_mfree
argument_list|(
name|np
operator|->
name|squeue
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"SQUEUE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|dqueue
condition|)
name|sym_mfree
argument_list|(
name|np
operator|->
name|dqueue
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"DQUEUE"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|np
operator|->
name|ccbc
operator|)
operator|!=
name|NULL
condition|)
block|{
name|np
operator|->
name|ccbc
operator|=
name|cp
operator|->
name|link_ccb
expr_stmt|;
name|sym_mfree
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|,
literal|"CCB"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|badluntbl
condition|)
name|sym_mfree
argument_list|(
name|np
operator|->
name|badluntbl
argument_list|,
literal|256
argument_list|,
literal|"BADLUNTBL"
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
name|SYMCONF_MAX_TARGET
condition|;
name|target
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|SYMCONF_MAX_LUN
condition|;
name|lun
operator|++
control|)
block|{
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
continue|continue;
if|if
condition|(
name|lp
operator|->
name|itlq_tbl
condition|)
name|sym_mfree
argument_list|(
name|lp
operator|->
name|itlq_tbl
argument_list|,
name|SYMCONF_MAX_TASK
operator|*
literal|4
argument_list|,
literal|"ITLQ_TBL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|cb_tags
condition|)
name|sym_mfree
argument_list|(
name|lp
operator|->
name|cb_tags
argument_list|,
name|SYMCONF_MAX_TASK
argument_list|,
literal|"CB_TAGS"
argument_list|)
expr_stmt|;
name|sym_mfree
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|,
literal|"LCB"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SYMCONF_MAX_LUN
operator|>
literal|1
if|if
condition|(
name|tp
operator|->
name|lunmp
condition|)
name|sym_mfree
argument_list|(
name|tp
operator|->
name|lunmp
argument_list|,
name|SYMCONF_MAX_LUN
operator|*
sizeof|sizeof
argument_list|(
name|lcb_p
argument_list|)
argument_list|,
literal|"LUNMP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sym_mfree
argument_list|(
name|np
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
literal|"HCB"
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Allocate CAM resources and register a bus to CAM.  */
name|int
name|sym_cam_attach
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
init|=
literal|0
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
init|=
literal|0
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 	 *  Establish our interrupt handler. 	 */
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|np
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|sym_intr
argument_list|,
name|np
argument_list|,
operator|&
name|np
operator|->
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|np
operator|->
name|device
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|np
operator|->
name|pci_tag
argument_list|,
name|sym_intr
argument_list|,
name|np
argument_list|,
operator|&
name|cam_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: failed to map interrupt\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
endif|#
directive|endif
comment|/* 	 *  Create the device queue for our sym SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|SYMCONF_MAX_START
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devq
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 *  Construct our SIM entry. 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|sym_action
argument_list|,
name|sym_poll
argument_list|,
literal|"sym"
argument_list|,
name|np
argument_list|,
name|np
operator|->
name|unit
argument_list|,
literal|1
argument_list|,
name|SYMSETUP_MAX_TAG
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sim
condition|)
goto|goto
name|fail
goto|;
name|devq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|np
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
name|sim
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
literal|0
argument_list|,
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|np
operator|->
name|path
operator|=
name|path
expr_stmt|;
comment|/* 	 *  Hmmm... This should be useful, but I donnot want to  	 *  know about. 	 */
ifdef|#
directive|ifdef
name|__alpha__
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
name|alpha_register_pci_scsi
argument_list|(
name|pci_get_bus
argument_list|(
name|np
operator|->
name|device
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|np
operator|->
name|device
argument_list|)
argument_list|,
name|np
operator|->
name|sim
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*__i386__*/
name|alpha_register_pci_scsi
argument_list|(
name|pci_tag
operator|->
name|bus
argument_list|,
name|pci_tag
operator|->
name|slot
argument_list|,
name|np
operator|->
name|sim
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 *  Establish our async notification handler. 	 */
block|{ 	struct ccb_setasync csa; 	xpt_setup_ccb(&csa.ccb_h, np->path, 5); 	csa.ccb_h.func_code = XPT_SASYNC_CB; 	csa.event_enable    = AC_LOST_DEVICE; 	csa.callback	    = sym_async; 	csa.callback_arg    = np->sim; 	xpt_action((union ccb *)&csa); 	}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|fail
label|:
if|if
condition|(
name|sim
condition|)
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
condition|)
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|sym_cam_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  Free everything that deals with CAM.  */
name|void
name|sym_cam_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FreeBSD_4_Bus
if|if
condition|(
name|np
operator|->
name|intr
condition|)
name|bus_teardown_intr
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|np
operator|->
name|irq_res
argument_list|,
name|np
operator|->
name|intr
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* pci_unmap_int(np->pci_tag); */
comment|/* Does nothing */
endif|#
directive|endif
if|if
condition|(
name|np
operator|->
name|sim
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|np
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|path
condition|)
name|xpt_free_path
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
comment|/*============ OPTIONNAL NVRAM SUPPORT =================*/
comment|/*  *  Get host setup from NVRAM.  */
specifier|static
name|void
name|sym_nvram_setup_host
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
comment|/* 	 *  Get parity checking, host ID and verbose mode from NVRAM 	 */
switch|switch
condition|(
name|nvram
operator|->
name|type
condition|)
block|{
case|case
name|SYM_SYMBIOS_NVRAM
case|:
if|if
condition|(
operator|!
operator|(
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|flags
operator|&
name|SYMBIOS_PARITY_ENABLE
operator|)
condition|)
name|np
operator|->
name|rv_scntl0
operator|&=
operator|~
literal|0x0a
expr_stmt|;
name|np
operator|->
name|myaddr
operator|=
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|host_id
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|flags
operator|&
name|SYMBIOS_VERBOSE_MSGS
condition|)
name|np
operator|->
name|verbose
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|SYM_TEKRAM_NVRAM
case|:
name|np
operator|->
name|myaddr
operator|=
name|nvram
operator|->
name|data
operator|.
name|Tekram
operator|.
name|host_id
operator|&
literal|0x0f
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
block|}
comment|/*  *  Get target setup from NVRAM.  */
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
specifier|static
name|void
name|sym_Symbios_setup_target
argument_list|(
name|hcb_p
name|np
argument_list|,
name|int
name|target
argument_list|,
name|Symbios_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
specifier|static
name|void
name|sym_Tekram_setup_target
argument_list|(
name|hcb_p
name|np
argument_list|,
name|int
name|target
argument_list|,
name|Tekram_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|static
name|void
name|sym_nvram_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
switch|switch
condition|(
name|nvp
operator|->
name|type
condition|)
block|{
case|case
name|SYM_SYMBIOS_NVRAM
case|:
name|sym_Symbios_setup_target
argument_list|(
name|np
argument_list|,
name|target
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Symbios
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_TEKRAM_NVRAM
case|:
name|sym_Tekram_setup_target
argument_list|(
name|np
argument_list|,
name|target
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Tekram
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
comment|/*  *  Get target set-up from Symbios format NVRAM.  */
specifier|static
name|void
name|sym_Symbios_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|Symbios_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|Symbios_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|tn
operator|->
name|sync_period
condition|?
operator|(
name|tn
operator|->
name|sync_period
operator|+
literal|3
operator|)
operator|/
literal|4
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|tn
operator|->
name|bus_width
operator|==
literal|0x10
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|usrtags
operator|=
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_QUEUE_TAGS_ENABLED
operator|)
condition|?
name|SYMSETUP_MAX_TAG
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_DISCONNECT_ENABLE
operator|)
condition|)
name|tp
operator|->
name|usrflags
operator|&=
operator|~
name|SYM_DISC_ENABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_AT_BOOT_TIME
operator|)
condition|)
name|tp
operator|->
name|usrflags
operator||=
name|SYM_SCAN_BOOT_DISABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_LUNS
operator|)
condition|)
name|tp
operator|->
name|usrflags
operator||=
name|SYM_SCAN_LUNS_DISABLED
expr_stmt|;
block|}
comment|/*  *  Get target set-up from Tekram format NVRAM.  */
specifier|static
name|void
name|sym_Tekram_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|struct
name|Tekram_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_SYNC_NEGO
condition|)
block|{
name|i
operator|=
name|tn
operator|->
name|sync_index
operator|&
literal|0xf
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|Tekram_sync
index|[
name|i
index|]
expr_stmt|;
block|}
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_WIDE_NEGO
operator|)
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_TAGGED_COMMANDS
condition|)
block|{
name|tp
operator|->
name|usrtags
operator|=
literal|2
operator|<<
name|nvram
operator|->
name|max_tags_index
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_DISCONNECT_ENABLE
condition|)
name|tp
operator|->
name|usrflags
operator||=
name|SYM_DISC_ENABLED
expr_stmt|;
comment|/* If any device does not support parity, we will not use this option */
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_PARITY_CHECK
operator|)
condition|)
name|np
operator|->
name|rv_scntl0
operator|&=
operator|~
literal|0x0a
expr_stmt|;
comment|/* SCSI parity checking disabled */
block|}
ifdef|#
directive|ifdef
name|SYMCONF_DEBUG_NVRAM
comment|/*  *  Dump Symbios format NVRAM for debugging purpose.  */
name|void
name|sym_display_Symbios_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Symbios_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* display Symbios nvram host data */
name|printf
argument_list|(
literal|"%s: HOST ID=%d%s%s%s%s%s\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|nvram
operator|->
name|host_id
operator|&
literal|0x0f
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_SCAM_ENABLE
operator|)
condition|?
literal|" SCAM"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_PARITY_ENABLE
operator|)
condition|?
literal|" PARITY"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_VERBOSE_MSGS
operator|)
condition|?
literal|" VERBOSE"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_CHS_MAPPING
operator|)
condition|?
literal|" CHS_ALT"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags1
operator|&
name|SYMBIOS_SCAN_HI_LO
operator|)
condition|?
literal|" HI_LO"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* display Symbios nvram drive data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Symbios_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_DISCONNECT_ENABLE
operator|)
condition|?
literal|" DISC"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_AT_BOOT_TIME
operator|)
condition|?
literal|" SCAN_BOOT"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_LUNS
operator|)
condition|?
literal|" SCAN_LUNS"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_QUEUE_TAGS_ENABLED
operator|)
condition|?
literal|" TCQ"
else|:
literal|""
argument_list|,
name|tn
operator|->
name|bus_width
argument_list|,
name|tn
operator|->
name|sync_period
operator|/
literal|4
argument_list|,
name|tn
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *  Dump TEKRAM format NVRAM for debugging purpose.  */
specifier|static
name|u_char
name|Tekram_boot_delay
index|[
literal|7
index|]
name|__initdata
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|20
block|,
literal|30
block|,
literal|60
block|,
literal|120
block|}
decl_stmt|;
name|void
name|sym_display_Tekram_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tags
decl_stmt|,
name|boot_delay
decl_stmt|;
name|char
modifier|*
name|rem
decl_stmt|;
comment|/* display Tekram nvram host data */
name|tags
operator|=
literal|2
operator|<<
name|nvram
operator|->
name|max_tags_index
expr_stmt|;
name|boot_delay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvram
operator|->
name|boot_delay_index
operator|<
literal|6
condition|)
name|boot_delay
operator|=
name|Tekram_boot_delay
index|[
name|nvram
operator|->
name|boot_delay_index
index|]
expr_stmt|;
switch|switch
condition|(
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_REMOVABLE_FLAGS
operator|)
operator|>>
literal|6
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|rem
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rem
operator|=
literal|" REMOVABLE=boot device"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rem
operator|=
literal|" REMOVABLE=all"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|nvram
operator|->
name|host_id
operator|&
literal|0x0f
argument_list|,
operator|(
name|nvram
operator|->
name|flags1
operator|&
name|SYMBIOS_SCAM_ENABLE
operator|)
condition|?
literal|" SCAM"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_MORE_THAN_2_DRIVES
operator|)
condition|?
literal|">2DRIVES"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_DRIVES_SUP_1GB
operator|)
condition|?
literal|">1GB"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_RESET_ON_POWER_ON
operator|)
condition|?
literal|" RESET"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_ACTIVE_NEGATION
operator|)
condition|?
literal|" ACT_NEG"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_IMMEDIATE_SEEK
operator|)
condition|?
literal|" IMM_SEEK"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_SCAN_LUNS
operator|)
condition|?
literal|" SCAN_LUNS"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags1
operator|&
name|TEKRAM_F2_F6_ENABLED
operator|)
condition|?
literal|" F2_F6"
else|:
literal|""
argument_list|,
name|rem
argument_list|,
name|boot_delay
argument_list|,
name|tags
argument_list|)
expr_stmt|;
comment|/* display Tekram nvram drive data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|15
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sync
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|Tekram_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|j
operator|=
name|tn
operator|->
name|sync_index
operator|&
literal|0xf
expr_stmt|;
name|sync
operator|=
name|Tekram_sync
index|[
name|j
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s-%d:%s%s%s%s%s%s PERIOD=%d\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_PARITY_CHECK
operator|)
condition|?
literal|" PARITY"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_SYNC_NEGO
operator|)
condition|?
literal|" SYNC"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_DISCONNECT_ENABLE
operator|)
condition|?
literal|" DISC"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_START_CMD
operator|)
condition|?
literal|" START"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_TAGGED_COMMANDS
operator|)
condition|?
literal|" TCQ"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_WIDE_NEGO
operator|)
condition|?
literal|" WIDE"
else|:
literal|""
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYMCONF_DEBUG_NVRAM */
endif|#
directive|endif
comment|/* SYMCONF_NVRAM_SUPPORT */
comment|/*  *  Try reading Symbios or Tekram NVRAM  */
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
specifier|static
name|int
name|sym_read_Symbios_nvram
argument_list|(
name|hcb_p
name|np
argument_list|,
name|Symbios_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
specifier|static
name|int
name|sym_read_Tekram_nvram
argument_list|(
name|hcb_p
name|np
argument_list|,
name|Tekram_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|sym_read_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
comment|/* 	 *  Try to read SYMBIOS nvram. 	 *  Try to read TEKRAM nvram if Symbios nvram not found. 	 */
if|if
condition|(
name|SYMSETUP_SYMBIOS_NVRAM
operator|&&
operator|!
name|sym_read_Symbios_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Symbios
argument_list|)
condition|)
name|nvp
operator|->
name|type
operator|=
name|SYM_SYMBIOS_NVRAM
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMSETUP_TEKRAM_NVRAM
operator|&&
operator|!
name|sym_read_Tekram_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Tekram
argument_list|)
condition|)
name|nvp
operator|->
name|type
operator|=
name|SYM_TEKRAM_NVRAM
expr_stmt|;
else|else
name|nvp
operator|->
name|type
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|nvp
operator|->
name|type
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|nvp
operator|->
name|type
return|;
block|}
ifdef|#
directive|ifdef
name|SYMCONF_NVRAM_SUPPORT
comment|/*  *  24C16 EEPROM reading.  *  *  GPOI0 - data in/data out  *  GPIO1 - clock  *  Symbios NVRAM wiring now also used by Tekram.  */
define|#
directive|define
name|SET_BIT
value|0
define|#
directive|define
name|CLR_BIT
value|1
define|#
directive|define
name|SET_CLK
value|2
define|#
directive|define
name|CLR_CLK
value|3
comment|/*  *  Set/clear data/clock bit in GPIO0  */
specifier|static
name|void
name|S24C16_set_bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|int
name|bit_mode
parameter_list|)
block|{
name|UDELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bit_mode
condition|)
block|{
case|case
name|SET_BIT
case|:
operator|*
name|gpreg
operator||=
name|write_bit
expr_stmt|;
break|break;
case|case
name|CLR_BIT
case|:
operator|*
name|gpreg
operator|&=
literal|0xfe
expr_stmt|;
break|break;
case|case
name|SET_CLK
case|:
operator|*
name|gpreg
operator||=
literal|0x02
expr_stmt|;
break|break;
case|case
name|CLR_CLK
case|:
operator|*
name|gpreg
operator|&=
literal|0xfd
expr_stmt|;
break|break;
block|}
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send START condition to NVRAM to wake it up.  */
specifier|static
name|void
name|S24C16_start
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|,
name|SET_BIT
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|SET_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_BIT
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_CLK
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!  */
specifier|static
name|void
name|S24C16_stop
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|SET_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|,
name|SET_BIT
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Read or write a bit to the NVRAM,  *  read if GPIO0 input else write if GPIO0 output  */
specifier|static
name|void
name|S24C16_do_bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
name|write_bit
argument_list|,
name|gpreg
argument_list|,
name|SET_BIT
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|SET_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bit
condition|)
operator|*
name|read_bit
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_BIT
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Output an ACK to the NVRAM after reading,  *  change GPIO0 to output and when done back to an input  */
specifier|static
name|void
name|S24C16_write_ack
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
operator|&
literal|0xfe
argument_list|)
expr_stmt|;
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|write_bit
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Input an ACK from NVRAM after writing,  *  change GPIO0 to input and when done back to an output  */
specifier|static
name|void
name|S24C16_read_ack
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
name|read_bit
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,  *  GPIO0 must already be set as an output  */
specifier|static
name|void
name|S24C16_write_byte
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|ack_data
parameter_list|,
name|u_char
name|write_data
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
name|x
operator|++
control|)
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|(
name|write_data
operator|>>
operator|(
literal|7
operator|-
name|x
operator|)
operator|)
operator|&
literal|0x01
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|S24C16_read_ack
argument_list|(
name|np
argument_list|,
name|ack_data
argument_list|,
name|gpreg
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  READ a byte from the NVRAM and then send an ACK to say we have got it,  *  GPIO0 must already be set as an input  */
specifier|static
name|void
name|S24C16_read_byte
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_data
parameter_list|,
name|u_char
name|ack_data
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_char
name|read_bit
decl_stmt|;
operator|*
name|read_data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
name|x
operator|++
control|)
block|{
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
operator|&
name|read_bit
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
operator|*
name|read_data
operator||=
operator|(
operator|(
name|read_bit
operator|&
literal|0x01
operator|)
operator|<<
operator|(
literal|7
operator|-
name|x
operator|)
operator|)
expr_stmt|;
block|}
name|S24C16_write_ack
argument_list|(
name|np
argument_list|,
name|ack_data
argument_list|,
name|gpreg
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Read 'len' bytes starting at 'offset'.  */
specifier|static
name|int
name|sym_read_S24C16_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
name|gpcntl
decl_stmt|,
name|gpreg
decl_stmt|;
name|u_char
name|old_gpcntl
decl_stmt|,
name|old_gpreg
decl_stmt|;
name|u_char
name|ack_data
decl_stmt|;
name|int
name|retv
init|=
literal|1
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* save current state of GPCNTL and GPREG */
name|old_gpreg
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
name|old_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
name|gpcntl
operator|=
name|old_gpcntl
operator|&
literal|0xfc
expr_stmt|;
comment|/* set up GPREG& GPCNTL to set GPIO0 and GPIO1 in to known state */
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|old_gpreg
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
name|gpreg
operator|=
name|old_gpreg
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|&
name|gpreg
argument_list|,
name|CLR_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|&
name|gpreg
argument_list|,
name|CLR_BIT
argument_list|)
expr_stmt|;
comment|/* now set NVRAM inactive with GPIO0/1 both high */
name|S24C16_stop
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* activate NVRAM */
name|S24C16_start
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* write device code and random address MSB */
name|S24C16_write_byte
argument_list|(
name|np
argument_list|,
operator|&
name|ack_data
argument_list|,
literal|0xa0
operator||
operator|(
operator|(
name|offset
operator|>>
literal|7
operator|)
operator|&
literal|0x0e
operator|)
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_data
operator|&
literal|0x01
condition|)
goto|goto
name|out
goto|;
comment|/* write random address LSB */
name|S24C16_write_byte
argument_list|(
name|np
argument_list|,
operator|&
name|ack_data
argument_list|,
operator|(
name|offset
operator|&
literal|0x7f
operator|)
operator|<<
literal|1
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_data
operator|&
literal|0x01
condition|)
goto|goto
name|out
goto|;
comment|/* regenerate START state to set up for reading */
name|S24C16_start
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
name|S24C16_write_byte
argument_list|(
name|np
argument_list|,
operator|&
name|ack_data
argument_list|,
literal|0xa1
operator||
operator|(
operator|(
name|offset
operator|>>
literal|7
operator|)
operator|&
literal|0x0e
operator|)
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_data
operator|&
literal|0x01
condition|)
goto|goto
name|out
goto|;
comment|/* now set up GPIO0 for inputting data */
name|gpcntl
operator||=
literal|0x01
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* input all requested data - only part of total NVRAM */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
name|S24C16_read_byte
argument_list|(
name|np
argument_list|,
operator|&
name|data
index|[
name|x
index|]
argument_list|,
operator|(
name|x
operator|==
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* finally put NVRAM back in inactive mode */
name|gpcntl
operator|&=
literal|0xfe
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
name|S24C16_stop
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
name|retv
operator|=
literal|0
expr_stmt|;
name|out
label|:
comment|/* return GPIO0/1 to original states after having accessed NVRAM */
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|old_gpcntl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|old_gpreg
argument_list|)
expr_stmt|;
return|return
name|retv
return|;
block|}
undef|#
directive|undef
name|SET_BIT
name|0
undef|#
directive|undef
name|CLR_BIT
name|1
undef|#
directive|undef
name|SET_CLK
name|2
undef|#
directive|undef
name|CLR_CLK
name|3
comment|/*  *  Try reading Symbios NVRAM.  *  Return 0 if OK.  */
specifier|static
name|int
name|sym_read_Symbios_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Symbios_nvram
modifier|*
name|nvram
parameter_list|)
block|{
specifier|static
name|u_char
name|Symbios_trailer
index|[
literal|6
index|]
init|=
block|{
literal|0xfe
block|,
literal|0xfe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|nvram
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|nvram
argument_list|)
decl_stmt|;
name|u_short
name|csum
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* probe the 24c16 and read the SYMBIOS 24c16 area */
if|if
condition|(
name|sym_read_S24C16_nvram
argument_list|(
name|np
argument_list|,
name|SYMBIOS_NVRAM_ADDRESS
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* check valid NVRAM signature, verify byte count and checksum */
if|if
condition|(
name|nvram
operator|->
name|type
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
name|nvram
operator|->
name|trailer
argument_list|,
name|Symbios_trailer
argument_list|,
literal|6
argument_list|)
operator|||
name|nvram
operator|->
name|byte_count
operator|!=
name|len
operator|-
literal|12
condition|)
return|return
literal|1
return|;
comment|/* verify checksum */
for|for
control|(
name|x
operator|=
literal|6
operator|,
name|csum
operator|=
literal|0
init|;
name|x
operator|<
name|len
operator|-
literal|6
condition|;
name|x
operator|++
control|)
name|csum
operator|+=
name|data
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|nvram
operator|->
name|checksum
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/*  *  93C46 EEPROM reading.  *  *  GPOI0 - data in  *  GPIO1 - data out  *  GPIO2 - clock  *  GPIO4 - chip select  *  *  Used by Tekram.  */
comment|/*  *  Pulse clock bit in GPIO0  */
specifier|static
name|void
name|T93C46_Clk
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
operator||
literal|0x04
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*   *  Read bit from NVRAM  */
specifier|static
name|void
name|T93C46_Read_Bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|T93C46_Clk
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
operator|*
name|read_bit
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Write bit to GPIO0  */
specifier|static
name|void
name|T93C46_Write_Bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
if|if
condition|(
name|write_bit
operator|&
literal|0x01
condition|)
operator|*
name|gpreg
operator||=
literal|0x02
expr_stmt|;
else|else
operator|*
name|gpreg
operator|&=
literal|0xfd
expr_stmt|;
operator|*
name|gpreg
operator||=
literal|0x10
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|T93C46_Clk
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!  */
specifier|static
name|void
name|T93C46_Stop
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
operator|*
name|gpreg
operator|&=
literal|0xef
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|T93C46_Clk
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send read command and address to NVRAM  */
specifier|static
name|void
name|T93C46_Send_Command
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|write_data
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* send 9 bits, start bit (1), command (2), address (6)  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|9
condition|;
name|x
operator|++
control|)
name|T93C46_Write_Bit
argument_list|(
name|np
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|write_data
operator|>>
operator|(
literal|8
operator|-
name|x
operator|)
argument_list|)
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
operator|*
name|read_bit
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  READ 2 bytes from the NVRAM  */
specifier|static
name|void
name|T93C46_Read_Word
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
modifier|*
name|nvram_data
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_char
name|read_bit
decl_stmt|;
operator|*
name|nvram_data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|16
condition|;
name|x
operator|++
control|)
block|{
name|T93C46_Read_Bit
argument_list|(
name|np
argument_list|,
operator|&
name|read_bit
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bit
operator|&
literal|0x01
condition|)
operator|*
name|nvram_data
operator||=
operator|(
literal|0x01
operator|<<
operator|(
literal|15
operator|-
name|x
operator|)
operator|)
expr_stmt|;
else|else
operator|*
name|nvram_data
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
literal|15
operator|-
name|x
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/*  *  Read Tekram NvRAM data.  */
specifier|static
name|int
name|T93C46_Read_Data
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|u_char
name|read_bit
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
block|{
comment|/* output read command and address */
name|T93C46_Send_Command
argument_list|(
name|np
argument_list|,
literal|0x180
operator||
name|x
argument_list|,
operator|&
name|read_bit
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bit
operator|&
literal|0x01
condition|)
return|return
literal|1
return|;
comment|/* Bad */
name|T93C46_Read_Word
argument_list|(
name|np
argument_list|,
operator|&
name|data
index|[
name|x
index|]
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|T93C46_Stop
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  *  Try reading 93C46 Tekram NVRAM.  */
specifier|static
name|int
name|sym_read_T93C46_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|u_char
name|gpcntl
decl_stmt|,
name|gpreg
decl_stmt|;
name|u_char
name|old_gpcntl
decl_stmt|,
name|old_gpreg
decl_stmt|;
name|int
name|retv
init|=
literal|1
decl_stmt|;
comment|/* save current state of GPCNTL and GPREG */
name|old_gpreg
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
name|old_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
comment|/* set up GPREG& GPCNTL to set GPIO0/1/2/4 in to known state, 0 in, 	   1/2/4 out */
name|gpreg
operator|=
name|old_gpreg
operator|&
literal|0xe9
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|gpcntl
operator|=
operator|(
name|old_gpcntl
operator|&
literal|0xe9
operator|)
operator||
literal|0x09
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* input all of NVRAM, 64 words */
name|retv
operator|=
name|T93C46_Read_Data
argument_list|(
name|np
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|nvram
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nvram
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|old_gpcntl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|old_gpreg
argument_list|)
expr_stmt|;
return|return
name|retv
return|;
block|}
comment|/*  *  Try reading Tekram NVRAM.  *  Return 0 if OK.  */
specifier|static
name|int
name|sym_read_Tekram_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|nvram
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|nvram
argument_list|)
decl_stmt|;
name|u_short
name|csum
decl_stmt|;
name|int
name|x
decl_stmt|;
switch|switch
condition|(
name|np
operator|->
name|device_id
condition|)
block|{
case|case
name|PCI_ID_SYM53C885
case|:
case|case
name|PCI_ID_SYM53C895
case|:
case|case
name|PCI_ID_SYM53C896
case|:
name|x
operator|=
name|sym_read_S24C16_nvram
argument_list|(
name|np
argument_list|,
name|TEKRAM_24C16_NVRAM_ADDRESS
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_ID_SYM53C875
case|:
name|x
operator|=
name|sym_read_S24C16_nvram
argument_list|(
name|np
argument_list|,
name|TEKRAM_24C16_NVRAM_ADDRESS
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
break|break;
default|default:
name|x
operator|=
name|sym_read_T93C46_nvram
argument_list|(
name|np
argument_list|,
name|nvram
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
condition|)
return|return
literal|1
return|;
comment|/* verify checksum */
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|csum
operator|=
literal|0
init|;
name|x
operator|<
name|len
operator|-
literal|1
condition|;
name|x
operator|+=
literal|2
control|)
name|csum
operator|+=
name|data
index|[
name|x
index|]
operator|+
operator|(
name|data
index|[
name|x
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0x1234
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMCONF_NVRAM_SUPPORT */
end_comment

end_unit

