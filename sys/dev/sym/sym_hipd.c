begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  Device driver optimized for the Symbios/LSI 53C896/53C895A/53C1010  *  PCI-SCSI controllers.  *  *  Copyright (C) 1999-2001  Gerard Roudier<groudier@free.fr>  *  *  This driver also supports the following Symbios/LSI PCI-SCSI chips:  *	53C810A, 53C825A, 53C860, 53C875, 53C876, 53C885, 53C895,  *	53C810,  53C815,  53C825 and the 53C1510D is 53C8XX mode.  *  *  *  This driver for FreeBSD-CAM is derived from the Linux sym53c8xx driver.  *  Copyright (C) 1998-1999  Gerard Roudier  *  *  The sym53c8xx driver is derived from the ncr53c8xx driver that had been  *  a port of the FreeBSD ncr driver to Linux-1.2.13.  *  *  The original ncr driver has been written for 386bsd and FreeBSD by  *          Wolfgang Stanglmeier<wolf@cologne.de>  *          Stefan Esser<se@mi.Uni-Koeln.de>  *  Copyright (C) 1994  Wolfgang Stanglmeier  *  *  The initialisation code, and part of the code that addresses  *  FreeBSD-CAM services is based on the aic7xxx driver for FreeBSD-CAM  *  written by Justin T. Gibbs.  *  *  Other major contributions:  *  *  NVRAM detection and reading.  *  Copyright (C) 1997 Richard Waltham<dormouse@farsrobt.demon.co.uk>  *  *-----------------------------------------------------------------------------  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SYM_DRIVER_NAME
value|"sym-1.6.5-20000902"
end_define

begin_comment
comment|/* #define SYM_DEBUG_GENERIC_SUPPORT */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/*  *  Driver configuration options.  */
end_comment

begin_include
include|#
directive|include
file|"opt_sym.h"
end_include

begin_include
include|#
directive|include
file|<dev/sym/sym_conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<machine/ofw_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_comment
comment|/* Short and quite clear integer types */
end_comment

begin_typedef
typedef|typedef
name|int8_t
name|s8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int16_t
name|s16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int32_t
name|s32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int8_t
name|u8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int16_t
name|u16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int32_t
name|u32
typedef|;
end_typedef

begin_comment
comment|/*  *  Driver definitions.  */
end_comment

begin_include
include|#
directive|include
file|<dev/sym/sym_defs.h>
end_include

begin_include
include|#
directive|include
file|<dev/sym/sym_fw.h>
end_include

begin_comment
comment|/*  *  IA32 architecture does not reorder STORES and prevents  *  LOADS from passing STORES. It is called `program order'  *  by Intel and allows device drivers to deal with memory  *  ordering by only ensuring that the code is not reordered  *  by the compiler when ordering is required.  *  Other architectures implement a weaker ordering that  *  requires memory barriers (and also IO barriers when they  *  make sense) to be used.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|__i386__
operator|||
name|defined
name|__amd64__
end_if

begin_define
define|#
directive|define
name|MEMORY_BARRIER
parameter_list|()
value|do { ; } while(0)
end_define

begin_elif
elif|#
directive|elif
name|defined
name|__powerpc__
end_elif

begin_define
define|#
directive|define
name|MEMORY_BARRIER
parameter_list|()
value|__asm__ volatile("eieio; sync" : : : "memory")
end_define

begin_elif
elif|#
directive|elif
name|defined
name|__ia64__
end_elif

begin_define
define|#
directive|define
name|MEMORY_BARRIER
parameter_list|()
value|__asm__ volatile("mf.a; mf" : : : "memory")
end_define

begin_elif
elif|#
directive|elif
name|defined
name|__sparc64__
end_elif

begin_define
define|#
directive|define
name|MEMORY_BARRIER
parameter_list|()
value|__asm__ volatile("membar #Sync" : : : "memory")
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Not supported platform"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  A la VMS/CAM-3 queue management.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|sym_quehead
block|{
name|struct
name|sym_quehead
modifier|*
name|flink
decl_stmt|;
comment|/* Forward  pointer */
name|struct
name|sym_quehead
modifier|*
name|blink
decl_stmt|;
comment|/* Backward pointer */
block|}
name|SYM_QUEHEAD
typedef|;
end_typedef

begin_define
define|#
directive|define
name|sym_que_init
parameter_list|(
name|ptr
parameter_list|)
value|do { \ 	(ptr)->flink = (ptr); (ptr)->blink = (ptr); \ } while (0)
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sym_quehead
operator|*
name|sym_que_first
argument_list|(
argument|struct sym_quehead *head
argument_list|)
block|{
return|return
operator|(
name|head
operator|->
name|flink
operator|==
name|head
operator|)
operator|?
name|NULL
operator|:
name|head
operator|->
name|flink
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sym_quehead
operator|*
name|sym_que_last
argument_list|(
argument|struct sym_quehead *head
argument_list|)
block|{
return|return
operator|(
name|head
operator|->
name|blink
operator|==
name|head
operator|)
operator|?
name|NULL
operator|:
name|head
operator|->
name|blink
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|__sym_que_add
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|new
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|blink
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|flink
parameter_list|)
block|{
name|flink
operator|->
name|blink
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|flink
operator|=
name|flink
expr_stmt|;
name|new
operator|->
name|blink
operator|=
name|blink
expr_stmt|;
name|blink
operator|->
name|flink
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__sym_que_del
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|blink
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|flink
parameter_list|)
block|{
name|flink
operator|->
name|blink
operator|=
name|blink
expr_stmt|;
name|blink
operator|->
name|flink
operator|=
name|flink
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|sym_que_empty
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|head
parameter_list|)
block|{
return|return
name|head
operator|->
name|flink
operator|==
name|head
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sym_que_splice
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|list
parameter_list|,
name|struct
name|sym_quehead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|sym_quehead
modifier|*
name|first
init|=
name|list
operator|->
name|flink
decl_stmt|;
if|if
condition|(
name|first
operator|!=
name|list
condition|)
block|{
name|struct
name|sym_quehead
modifier|*
name|last
init|=
name|list
operator|->
name|blink
decl_stmt|;
name|struct
name|sym_quehead
modifier|*
name|at
init|=
name|head
operator|->
name|flink
decl_stmt|;
name|first
operator|->
name|blink
operator|=
name|head
expr_stmt|;
name|head
operator|->
name|flink
operator|=
name|first
expr_stmt|;
name|last
operator|->
name|flink
operator|=
name|at
expr_stmt|;
name|at
operator|->
name|blink
operator|=
name|last
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|sym_que_entry
parameter_list|(
name|ptr
parameter_list|,
name|type
parameter_list|,
name|member
parameter_list|)
define|\
value|((type *)((char *)(ptr)-(size_t)(&((type *)0)->member)))
end_define

begin_define
define|#
directive|define
name|sym_insque
parameter_list|(
name|new
parameter_list|,
name|pos
parameter_list|)
value|__sym_que_add(new, pos, (pos)->flink)
end_define

begin_define
define|#
directive|define
name|sym_remque
parameter_list|(
name|el
parameter_list|)
value|__sym_que_del((el)->blink, (el)->flink)
end_define

begin_define
define|#
directive|define
name|sym_insque_head
parameter_list|(
name|new
parameter_list|,
name|head
parameter_list|)
value|__sym_que_add(new, head, (head)->flink)
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|sym_quehead
operator|*
name|sym_remque_head
argument_list|(
argument|struct sym_quehead *head
argument_list|)
block|{ 	struct
name|sym_quehead
operator|*
name|elem
operator|=
name|head
operator|->
name|flink
block|;
if|if
condition|(
name|elem
operator|!=
name|head
condition|)
name|__sym_que_del
argument_list|(
name|head
argument_list|,
name|elem
operator|->
name|flink
argument_list|)
expr_stmt|;
else|else
name|elem
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|elem
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|sym_insque_tail
parameter_list|(
name|new
parameter_list|,
name|head
parameter_list|)
value|__sym_que_add(new, (head)->blink, head)
end_define

begin_function
unit|static
name|__inline
name|struct
name|sym_quehead
modifier|*
name|sym_remque_tail
parameter_list|(
name|struct
name|sym_quehead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|sym_quehead
modifier|*
name|elem
init|=
name|head
operator|->
name|blink
decl_stmt|;
if|if
condition|(
name|elem
operator|!=
name|head
condition|)
name|__sym_que_del
argument_list|(
name|elem
operator|->
name|blink
argument_list|,
name|head
argument_list|)
expr_stmt|;
else|else
name|elem
operator|=
name|NULL
expr_stmt|;
return|return
name|elem
return|;
block|}
end_function

begin_comment
comment|/*  *  This one may be useful.  */
end_comment

begin_define
define|#
directive|define
name|FOR_EACH_QUEUED_ELEMENT
parameter_list|(
name|head
parameter_list|,
name|qp
parameter_list|)
define|\
value|for (qp = (head)->flink; qp != (head); qp = qp->flink)
end_define

begin_comment
comment|/*  *  FreeBSD does not offer our kind of queue in the CAM CCB.  *  So, we have to cast.  */
end_comment

begin_define
define|#
directive|define
name|sym_qptr
parameter_list|(
name|p
parameter_list|)
value|((struct sym_quehead *) (p))
end_define

begin_comment
comment|/*  *  Simple bitmap operations.  */
end_comment

begin_define
define|#
directive|define
name|sym_set_bit
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(((u32 *)(p))[(n)>>5] |=  (1<<((n)&0x1f)))
end_define

begin_define
define|#
directive|define
name|sym_clr_bit
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(((u32 *)(p))[(n)>>5]&= ~(1<<((n)&0x1f)))
end_define

begin_define
define|#
directive|define
name|sym_is_bit
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
value|(((u32 *)(p))[(n)>>5]&   (1<<((n)&0x1f)))
end_define

begin_comment
comment|/*  *  Number of tasks per device we want to handle.  */
end_comment

begin_if
if|#
directive|if
name|SYM_CONF_MAX_TAG_ORDER
operator|>
literal|8
end_if

begin_error
error|#
directive|error
literal|"more than 256 tags per logical unit not allowed."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYM_CONF_MAX_TASK
value|(1<<SYM_CONF_MAX_TAG_ORDER)
end_define

begin_comment
comment|/*  *  Donnot use more tasks that we can handle.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYM_CONF_MAX_TAG
end_ifndef

begin_define
define|#
directive|define
name|SYM_CONF_MAX_TAG
value|SYM_CONF_MAX_TASK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SYM_CONF_MAX_TAG
operator|>
name|SYM_CONF_MAX_TASK
end_if

begin_undef
undef|#
directive|undef
name|SYM_CONF_MAX_TAG
end_undef

begin_define
define|#
directive|define
name|SYM_CONF_MAX_TAG
value|SYM_CONF_MAX_TASK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *    This one means 'NO TAG for this job'  */
end_comment

begin_define
define|#
directive|define
name|NO_TAG
value|(256)
end_define

begin_comment
comment|/*  *  Number of SCSI targets.  */
end_comment

begin_if
if|#
directive|if
name|SYM_CONF_MAX_TARGET
operator|>
literal|16
end_if

begin_error
error|#
directive|error
literal|"more than 16 targets not allowed."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Number of logical units per target.  */
end_comment

begin_if
if|#
directive|if
name|SYM_CONF_MAX_LUN
operator|>
literal|64
end_if

begin_error
error|#
directive|error
literal|"more than 64 logical units per target not allowed."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *    Asynchronous pre-scaler (ns). Shall be 40 for  *    the SCSI timings to be compliant.  */
end_comment

begin_define
define|#
directive|define
name|SYM_CONF_MIN_ASYNC
value|(40)
end_define

begin_comment
comment|/*  *  Number of entries in the START and DONE queues.  *  *  We limit to 1 PAGE in order to succeed allocation of  *  these queues. Each entry is 8 bytes long (2 DWORDS).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_MAX_START
end_ifdef

begin_define
define|#
directive|define
name|SYM_CONF_MAX_QUEUE
value|(SYM_CONF_MAX_START+2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SYM_CONF_MAX_QUEUE
value|(7*SYM_CONF_MAX_TASK+2)
end_define

begin_define
define|#
directive|define
name|SYM_CONF_MAX_START
value|(SYM_CONF_MAX_QUEUE-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SYM_CONF_MAX_QUEUE
operator|>
name|PAGE_SIZE
operator|/
literal|8
end_if

begin_undef
undef|#
directive|undef
name|SYM_CONF_MAX_QUEUE
end_undef

begin_define
define|#
directive|define
name|SYM_CONF_MAX_QUEUE
value|PAGE_SIZE/8
end_define

begin_undef
undef|#
directive|undef
name|SYM_CONF_MAX_START
end_undef

begin_define
define|#
directive|define
name|SYM_CONF_MAX_START
value|(SYM_CONF_MAX_QUEUE-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  For this one, we want a short name :-)  */
end_comment

begin_define
define|#
directive|define
name|MAX_QUEUE
value|SYM_CONF_MAX_QUEUE
end_define

begin_comment
comment|/*  *  Active debugging tags and verbosity.  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_ALLOC
value|(0x0001)
end_define

begin_define
define|#
directive|define
name|DEBUG_PHASE
value|(0x0002)
end_define

begin_define
define|#
directive|define
name|DEBUG_POLL
value|(0x0004)
end_define

begin_define
define|#
directive|define
name|DEBUG_QUEUE
value|(0x0008)
end_define

begin_define
define|#
directive|define
name|DEBUG_RESULT
value|(0x0010)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCATTER
value|(0x0020)
end_define

begin_define
define|#
directive|define
name|DEBUG_SCRIPT
value|(0x0040)
end_define

begin_define
define|#
directive|define
name|DEBUG_TINY
value|(0x0080)
end_define

begin_define
define|#
directive|define
name|DEBUG_TIMING
value|(0x0100)
end_define

begin_define
define|#
directive|define
name|DEBUG_NEGO
value|(0x0200)
end_define

begin_define
define|#
directive|define
name|DEBUG_TAGS
value|(0x0400)
end_define

begin_define
define|#
directive|define
name|DEBUG_POINTER
value|(0x0800)
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|static int sym_debug = 0;
define|#
directive|define
name|DEBUG_FLAGS
value|sym_debug
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*	#define DEBUG_FLAGS (0x0631) */
end_comment

begin_define
define|#
directive|define
name|DEBUG_FLAGS
value|(0x0000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|sym_verbose
value|(np->verbose)
end_define

begin_comment
comment|/*  *  Insert a delay in micro-seconds and milli-seconds.  */
end_comment

begin_function
specifier|static
name|void
name|UDELAY
parameter_list|(
name|int
name|us
parameter_list|)
block|{
name|DELAY
argument_list|(
name|us
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|MDELAY
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
while|while
condition|(
name|ms
operator|--
condition|)
name|UDELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Simple power of two buddy-like allocator.  *  *  This simple code is not intended to be fast, but to  *  provide power of 2 aligned memory allocations.  *  Since the SCRIPTS processor only supplies 8 bit arithmetic,  *  this allocator allows simple and fast address calculations  *  from the SCRIPTS code. In addition, cache line alignment  *  is guaranteed for power of 2 cache line size.  *  *  This allocator has been developed for the Linux sym53c8xx  *  driver, since this O/S does not provide naturally aligned  *  allocations.  *  It has the advantage of allowing the driver to use private  *  pages of memory that will be useful if we ever need to deal  *  with IO MMUs for PCI.  */
end_comment

begin_define
define|#
directive|define
name|MEMO_SHIFT
value|4
end_define

begin_comment
comment|/* 16 bytes minimum memory chunk */
end_comment

begin_define
define|#
directive|define
name|MEMO_PAGE_ORDER
value|0
end_define

begin_comment
comment|/* 1 PAGE  maximum */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|MEMO_FREE_UNUSED
end_define

begin_comment
comment|/* Free unused pages immediately */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MEMO_WARN
value|1
end_define

begin_define
define|#
directive|define
name|MEMO_CLUSTER_SHIFT
value|(PAGE_SHIFT+MEMO_PAGE_ORDER)
end_define

begin_define
define|#
directive|define
name|MEMO_CLUSTER_SIZE
value|(1UL<< MEMO_CLUSTER_SHIFT)
end_define

begin_define
define|#
directive|define
name|MEMO_CLUSTER_MASK
value|(MEMO_CLUSTER_SIZE-1)
end_define

begin_define
define|#
directive|define
name|get_pages
parameter_list|()
value|malloc(MEMO_CLUSTER_SIZE, M_DEVBUF, M_NOWAIT)
end_define

begin_define
define|#
directive|define
name|free_pages
parameter_list|(
name|p
parameter_list|)
value|free((p), M_DEVBUF)
end_define

begin_typedef
typedef|typedef
name|u_long
name|m_addr_t
typedef|;
end_typedef

begin_comment
comment|/* Enough bits to bit-hack addresses */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|m_link
block|{
comment|/* Link between free memory chunks */
name|struct
name|m_link
modifier|*
name|next
decl_stmt|;
block|}
name|m_link_s
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|m_vtob
block|{
comment|/* Virtual to Bus address translation */
name|struct
name|m_vtob
modifier|*
name|next
decl_stmt|;
name|bus_dmamap_t
name|dmamap
decl_stmt|;
comment|/* Map for this chunk */
name|m_addr_t
name|vaddr
decl_stmt|;
comment|/* Virtual address */
name|m_addr_t
name|baddr
decl_stmt|;
comment|/* Bus physical address */
block|}
name|m_vtob_s
typedef|;
end_typedef

begin_comment
comment|/* Hash this stuff a bit to speed up translations */
end_comment

begin_define
define|#
directive|define
name|VTOB_HASH_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|VTOB_HASH_SIZE
value|(1UL<< VTOB_HASH_SHIFT)
end_define

begin_define
define|#
directive|define
name|VTOB_HASH_MASK
value|(VTOB_HASH_SIZE-1)
end_define

begin_define
define|#
directive|define
name|VTOB_HASH_CODE
parameter_list|(
name|m
parameter_list|)
define|\
value|((((m_addr_t) (m))>> MEMO_CLUSTER_SHIFT)& VTOB_HASH_MASK)
end_define

begin_typedef
typedef|typedef
struct|struct
name|m_pool
block|{
comment|/* Memory pool of a given kind */
name|bus_dma_tag_t
name|dev_dmat
decl_stmt|;
comment|/* Identifies the pool */
name|bus_dma_tag_t
name|dmat
decl_stmt|;
comment|/* Tag for our fixed allocations */
name|m_addr_t
function_decl|(
modifier|*
name|getp
function_decl|)
parameter_list|(
name|struct
name|m_pool
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
name|void
function_decl|(
modifier|*
name|freep
function_decl|)
parameter_list|(
name|struct
name|m_pool
modifier|*
parameter_list|,
name|m_addr_t
parameter_list|)
function_decl|;
endif|#
directive|endif
define|#
directive|define
name|M_GETP
parameter_list|()
value|mp->getp(mp)
define|#
directive|define
name|M_FREEP
parameter_list|(
name|p
parameter_list|)
value|mp->freep(mp, p)
name|int
name|nump
decl_stmt|;
name|m_vtob_s
argument_list|*
operator|(
name|vtob
index|[
name|VTOB_HASH_SIZE
index|]
operator|)
argument_list|;
expr|struct
name|m_pool
operator|*
name|next
argument_list|;
expr|struct
name|m_link
name|h
index|[
name|MEMO_CLUSTER_SHIFT
operator|-
name|MEMO_SHIFT
operator|+
literal|1
index|]
argument_list|;
block|}
name|m_pool_s
typedef|;
end_typedef

begin_function
specifier|static
name|void
modifier|*
name|___sym_malloc
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
operator|(
literal|1
operator|<<
name|MEMO_SHIFT
operator|)
decl_stmt|;
name|int
name|j
decl_stmt|;
name|m_addr_t
name|a
decl_stmt|;
name|m_link_s
modifier|*
name|h
init|=
name|mp
operator|->
name|h
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|MEMO_CLUSTER_SIZE
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|size
operator|>
name|s
condition|)
block|{
name|s
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
operator|!
name|h
index|[
name|j
index|]
operator|.
name|next
condition|)
block|{
if|if
condition|(
name|s
operator|==
name|MEMO_CLUSTER_SIZE
condition|)
block|{
name|h
index|[
name|j
index|]
operator|.
name|next
operator|=
operator|(
name|m_link_s
operator|*
operator|)
name|M_GETP
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
index|[
name|j
index|]
operator|.
name|next
condition|)
name|h
index|[
name|j
index|]
operator|.
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
operator|++
name|j
expr_stmt|;
name|s
operator|<<=
literal|1
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|m_addr_t
operator|)
name|h
index|[
name|j
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|a
condition|)
block|{
name|h
index|[
name|j
index|]
operator|.
name|next
operator|=
name|h
index|[
name|j
index|]
operator|.
name|next
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|j
operator|>
name|i
condition|)
block|{
name|j
operator|-=
literal|1
expr_stmt|;
name|s
operator|>>=
literal|1
expr_stmt|;
name|h
index|[
name|j
index|]
operator|.
name|next
operator|=
operator|(
name|m_link_s
operator|*
operator|)
operator|(
name|a
operator|+
name|s
operator|)
expr_stmt|;
name|h
index|[
name|j
index|]
operator|.
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"___sym_malloc(%d) = %p\n"
argument_list|,
name|size
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|void
operator|*
operator|)
name|a
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|___sym_mfree
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
operator|(
literal|1
operator|<<
name|MEMO_SHIFT
operator|)
decl_stmt|;
name|m_link_s
modifier|*
name|q
decl_stmt|;
name|m_addr_t
name|a
decl_stmt|,
name|b
decl_stmt|;
name|m_link_s
modifier|*
name|h
init|=
name|mp
operator|->
name|h
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"___sym_mfree(%p, %d)\n"
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|size
operator|>
name|MEMO_CLUSTER_SIZE
condition|)
return|return;
while|while
condition|(
name|size
operator|>
name|s
condition|)
block|{
name|s
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|a
operator|=
operator|(
name|m_addr_t
operator|)
name|ptr
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
if|if
condition|(
name|s
operator|==
name|MEMO_CLUSTER_SIZE
condition|)
block|{
name|M_FREEP
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|b
operator|=
name|a
operator|^
name|s
expr_stmt|;
name|q
operator|=
operator|&
name|h
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|next
operator|&&
name|q
operator|->
name|next
operator|!=
operator|(
name|m_link_s
operator|*
operator|)
name|b
condition|)
block|{
name|q
operator|=
name|q
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q
operator|->
name|next
condition|)
block|{
operator|(
operator|(
name|m_link_s
operator|*
operator|)
name|a
operator|)
operator|->
name|next
operator|=
name|h
index|[
name|i
index|]
operator|.
name|next
expr_stmt|;
name|h
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|(
name|m_link_s
operator|*
operator|)
name|a
expr_stmt|;
break|break;
block|}
name|q
operator|->
name|next
operator|=
name|q
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|a
operator|=
name|a
operator|&
name|b
expr_stmt|;
name|s
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|__sym_calloc2
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|uflags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|___sym_malloc
argument_list|(
name|mp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_ALLOC
condition|)
name|printf
argument_list|(
literal|"new %-10s[%4d] @%p.\n"
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|bzero
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uflags
operator|&
name|MEMO_WARN
condition|)
name|printf
argument_list|(
literal|"__sym_calloc2: failed to allocate %s[%d]\n"
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_define
define|#
directive|define
name|__sym_calloc
parameter_list|(
name|mp
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|__sym_calloc2(mp, s, n, MEMO_WARN)
end_define

begin_function
specifier|static
name|void
name|__sym_mfree
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_ALLOC
condition|)
name|printf
argument_list|(
literal|"freeing %-10s[%4d] @%p.\n"
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|___sym_mfree
argument_list|(
name|mp
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Default memory pool we donnot need to involve in DMA.  */
end_comment

begin_comment
comment|/*  * With the `bus dma abstraction', we use a separate pool for  * memory we donnot need to involve in DMA.  */
end_comment

begin_function
specifier|static
name|m_addr_t
name|___mp0_getp
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|)
block|{
name|m_addr_t
name|m
init|=
operator|(
name|m_addr_t
operator|)
name|get_pages
argument_list|()
decl_stmt|;
if|if
condition|(
name|m
condition|)
operator|++
name|mp
operator|->
name|nump
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
end_ifdef

begin_function
specifier|static
name|void
name|___mp0_freep
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|,
name|m_addr_t
name|m
parameter_list|)
block|{
name|free_pages
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|--
name|mp
operator|->
name|nump
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
end_ifdef

begin_decl_stmt
specifier|static
name|m_pool_s
name|mp0
init|=
block|{
literal|0
block|,
literal|0
block|,
name|___mp0_getp
block|,
name|___mp0_freep
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|m_pool_s
name|mp0
init|=
block|{
literal|0
block|,
literal|0
block|,
name|___mp0_getp
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Actual memory allocation routine for non-DMAed memory.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|sym_calloc
parameter_list|(
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|void
modifier|*
name|m
decl_stmt|;
comment|/* Lock */
name|m
operator|=
name|__sym_calloc
argument_list|(
operator|&
name|mp0
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Unlock */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Actual memory allocation routine for non-DMAed memory.  */
end_comment

begin_function
specifier|static
name|void
name|sym_mfree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Lock */
name|__sym_mfree
argument_list|(
operator|&
name|mp0
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Unlock */
block|}
end_function

begin_comment
comment|/*  * DMAable pools.  */
end_comment

begin_comment
comment|/*  * With `bus dma abstraction', we use a separate pool per parent  * BUS handle. A reverse table (hashed) is maintained for virtual  * to BUS address translation.  */
end_comment

begin_function
specifier|static
name|void
name|getbaddrcb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|baddr
decl_stmt|;
name|baddr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|baddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|m_addr_t
name|___dma_getp
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|)
block|{
name|m_vtob_s
modifier|*
name|vbp
decl_stmt|;
name|void
modifier|*
name|vaddr
init|=
name|NULL
decl_stmt|;
name|bus_addr_t
name|baddr
init|=
literal|0
decl_stmt|;
name|vbp
operator|=
name|__sym_calloc
argument_list|(
operator|&
name|mp0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vbp
argument_list|)
argument_list|,
literal|"VTOB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vbp
condition|)
goto|goto
name|out_err
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
operator|&
name|vaddr
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_WAITOK
argument_list|,
operator|&
name|vbp
operator|->
name|dmamap
argument_list|)
condition|)
goto|goto
name|out_err
goto|;
name|bus_dmamap_load
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|,
name|vaddr
argument_list|,
name|MEMO_CLUSTER_SIZE
argument_list|,
name|getbaddrcb
argument_list|,
operator|&
name|baddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|baddr
condition|)
block|{
name|int
name|hc
init|=
name|VTOB_HASH_CODE
argument_list|(
name|vaddr
argument_list|)
decl_stmt|;
name|vbp
operator|->
name|vaddr
operator|=
operator|(
name|m_addr_t
operator|)
name|vaddr
expr_stmt|;
name|vbp
operator|->
name|baddr
operator|=
operator|(
name|m_addr_t
operator|)
name|baddr
expr_stmt|;
name|vbp
operator|->
name|next
operator|=
name|mp
operator|->
name|vtob
index|[
name|hc
index|]
expr_stmt|;
name|mp
operator|->
name|vtob
index|[
name|hc
index|]
operator|=
name|vbp
expr_stmt|;
operator|++
name|mp
operator|->
name|nump
expr_stmt|;
return|return
operator|(
name|m_addr_t
operator|)
name|vaddr
return|;
block|}
name|out_err
label|:
if|if
condition|(
name|baddr
condition|)
name|bus_dmamap_unload
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddr
condition|)
name|bus_dmamem_free
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
name|vaddr
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vbp
condition|)
block|{
if|if
condition|(
name|vbp
operator|->
name|dmamap
condition|)
name|bus_dmamap_destroy
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|__sym_mfree
argument_list|(
operator|&
name|mp0
argument_list|,
name|vbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vbp
argument_list|)
argument_list|,
literal|"VTOB"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
end_ifdef

begin_function
specifier|static
name|void
name|___dma_freep
parameter_list|(
name|m_pool_s
modifier|*
name|mp
parameter_list|,
name|m_addr_t
name|m
parameter_list|)
block|{
name|m_vtob_s
modifier|*
modifier|*
name|vbpp
decl_stmt|,
modifier|*
name|vbp
decl_stmt|;
name|int
name|hc
init|=
name|VTOB_HASH_CODE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|vbpp
operator|=
operator|&
name|mp
operator|->
name|vtob
index|[
name|hc
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|vbpp
operator|&&
operator|(
operator|*
name|vbpp
operator|)
operator|->
name|vaddr
operator|!=
name|m
condition|)
name|vbpp
operator|=
operator|&
operator|(
operator|*
name|vbpp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|vbpp
condition|)
block|{
name|vbp
operator|=
operator|*
name|vbpp
expr_stmt|;
operator|*
name|vbpp
operator|=
operator|(
operator|*
name|vbpp
operator|)
operator|->
name|next
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vbp
operator|->
name|vaddr
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|mp
operator|->
name|dmat
argument_list|,
name|vbp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|__sym_mfree
argument_list|(
operator|&
name|mp0
argument_list|,
name|vbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vbp
argument_list|)
argument_list|,
literal|"VTOB"
argument_list|)
expr_stmt|;
operator|--
name|mp
operator|->
name|nump
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|m_pool_s
modifier|*
name|___get_dma_pool
parameter_list|(
name|bus_dma_tag_t
name|dev_dmat
parameter_list|)
block|{
name|m_pool_s
modifier|*
name|mp
decl_stmt|;
for|for
control|(
name|mp
operator|=
name|mp0
operator|.
name|next
init|;
name|mp
operator|&&
name|mp
operator|->
name|dev_dmat
operator|!=
name|dev_dmat
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
empty_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_function
specifier|static
name|m_pool_s
modifier|*
name|___cre_dma_pool
parameter_list|(
name|bus_dma_tag_t
name|dev_dmat
parameter_list|)
block|{
name|m_pool_s
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|mp
operator|=
name|__sym_calloc
argument_list|(
operator|&
name|mp0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|,
literal|"MPOOL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|mp
operator|->
name|dev_dmat
operator|=
name|dev_dmat
expr_stmt|;
if|if
condition|(
operator|!
name|bus_dma_tag_create
argument_list|(
name|dev_dmat
argument_list|,
literal|1
argument_list|,
name|MEMO_CLUSTER_SIZE
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MEMO_CLUSTER_SIZE
argument_list|,
literal|1
argument_list|,
name|MEMO_CLUSTER_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|mp
operator|->
name|dmat
argument_list|)
condition|)
block|{
name|mp
operator|->
name|getp
operator|=
name|___dma_getp
expr_stmt|;
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
name|mp
operator|->
name|freep
operator|=
name|___dma_freep
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|next
operator|=
name|mp0
operator|.
name|next
expr_stmt|;
name|mp0
operator|.
name|next
operator|=
name|mp
expr_stmt|;
return|return
name|mp
return|;
block|}
block|}
if|if
condition|(
name|mp
condition|)
name|__sym_mfree
argument_list|(
operator|&
name|mp0
argument_list|,
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|,
literal|"MPOOL"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
end_ifdef

begin_function
specifier|static
name|void
name|___del_dma_pool
parameter_list|(
name|m_pool_s
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|m_pool
modifier|*
modifier|*
name|pp
init|=
operator|&
name|mp0
operator|.
name|next
decl_stmt|;
while|while
condition|(
operator|*
name|pp
operator|&&
operator|*
name|pp
operator|!=
name|p
condition|)
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|*
name|pp
condition|)
block|{
operator|*
name|pp
operator|=
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|p
operator|->
name|dmat
argument_list|)
expr_stmt|;
name|__sym_mfree
argument_list|(
operator|&
name|mp0
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
literal|"MPOOL"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
modifier|*
name|__sym_calloc_dma
parameter_list|(
name|bus_dma_tag_t
name|dev_dmat
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|m_pool
modifier|*
name|mp
decl_stmt|;
name|void
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
comment|/* Lock */
name|mp
operator|=
name|___get_dma_pool
argument_list|(
name|dev_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
name|mp
operator|=
name|___cre_dma_pool
argument_list|(
name|dev_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|m
operator|=
name|__sym_calloc
argument_list|(
name|mp
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
if|if
condition|(
name|mp
operator|&&
operator|!
name|mp
operator|->
name|nump
condition|)
name|___del_dma_pool
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Unlock */
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__sym_mfree_dma
parameter_list|(
name|bus_dma_tag_t
name|dev_dmat
parameter_list|,
name|void
modifier|*
name|m
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|m_pool
modifier|*
name|mp
decl_stmt|;
comment|/* Lock */
name|mp
operator|=
name|___get_dma_pool
argument_list|(
name|dev_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|__sym_mfree
argument_list|(
name|mp
argument_list|,
name|m
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MEMO_FREE_UNUSED
if|if
condition|(
name|mp
operator|&&
operator|!
name|mp
operator|->
name|nump
condition|)
name|___del_dma_pool
argument_list|(
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Unlock */
block|}
end_function

begin_function
specifier|static
name|m_addr_t
name|__vtobus
parameter_list|(
name|bus_dma_tag_t
name|dev_dmat
parameter_list|,
name|void
modifier|*
name|m
parameter_list|)
block|{
name|m_pool_s
modifier|*
name|mp
decl_stmt|;
name|int
name|hc
init|=
name|VTOB_HASH_CODE
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|m_vtob_s
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|m_addr_t
name|a
init|=
operator|(
operator|(
name|m_addr_t
operator|)
name|m
operator|)
operator|&
operator|~
name|MEMO_CLUSTER_MASK
decl_stmt|;
comment|/* Lock */
name|mp
operator|=
name|___get_dma_pool
argument_list|(
name|dev_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|vp
operator|=
name|mp
operator|->
name|vtob
index|[
name|hc
index|]
expr_stmt|;
while|while
condition|(
name|vp
operator|&&
operator|(
name|m_addr_t
operator|)
name|vp
operator|->
name|vaddr
operator|!=
name|a
condition|)
name|vp
operator|=
name|vp
operator|->
name|next
expr_stmt|;
block|}
comment|/* Unlock */
if|if
condition|(
operator|!
name|vp
condition|)
name|panic
argument_list|(
literal|"sym: VTOBUS FAILED!\n"
argument_list|)
expr_stmt|;
return|return
name|vp
condition|?
name|vp
operator|->
name|baddr
operator|+
operator|(
operator|(
operator|(
name|m_addr_t
operator|)
name|m
operator|)
operator|-
name|a
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Verbs for DMAable memory handling.  * The _uvptv_ macro avoids a nasty warning about pointer to volatile  * being discarded.  */
end_comment

begin_define
define|#
directive|define
name|_uvptv_
parameter_list|(
name|p
parameter_list|)
value|((void *)((vm_offset_t)(p)))
end_define

begin_define
define|#
directive|define
name|_sym_calloc_dma
parameter_list|(
name|np
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|__sym_calloc_dma(np->bus_dmat, s, n)
end_define

begin_define
define|#
directive|define
name|_sym_mfree_dma
parameter_list|(
name|np
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
define|\
value|__sym_mfree_dma(np->bus_dmat, _uvptv_(p), s, n)
end_define

begin_define
define|#
directive|define
name|sym_calloc_dma
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|_sym_calloc_dma(np, s, n)
end_define

begin_define
define|#
directive|define
name|sym_mfree_dma
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|_sym_mfree_dma(np, p, s, n)
end_define

begin_define
define|#
directive|define
name|_vtobus
parameter_list|(
name|np
parameter_list|,
name|p
parameter_list|)
value|__vtobus(np->bus_dmat, _uvptv_(p))
end_define

begin_define
define|#
directive|define
name|vtobus
parameter_list|(
name|p
parameter_list|)
value|_vtobus(np, p)
end_define

begin_comment
comment|/*  *  Print a buffer in hexadecimal format.  */
end_comment

begin_function
specifier|static
name|void
name|sym_printb_hex
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" %x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Same with a label at beginning and .\n at end.  */
end_comment

begin_function
specifier|static
name|void
name|sym_printl_hex
parameter_list|(
name|char
modifier|*
name|label
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|sym_printb_hex
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Return a string for SCSI BUS mode.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sym_scsi_bus_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SMODE_HVD
case|:
return|return
literal|"HVD"
return|;
case|case
name|SMODE_SE
case|:
return|return
literal|"SE"
return|;
case|case
name|SMODE_LVD
case|:
return|return
literal|"LVD"
return|;
block|}
return|return
literal|"??"
return|;
block|}
end_function

begin_comment
comment|/*  *  Some poor and bogus sync table that refers to Tekram NVRAM layout.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|Tekram_sync
index|[
literal|16
index|]
init|=
block|{
literal|25
block|,
literal|31
block|,
literal|37
block|,
literal|43
block|,
literal|50
block|,
literal|62
block|,
literal|75
block|,
literal|125
block|,
literal|12
block|,
literal|15
block|,
literal|18
block|,
literal|21
block|,
literal|6
block|,
literal|7
block|,
literal|9
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Union of supported NVRAM formats.  */
end_comment

begin_struct
struct|struct
name|sym_nvram
block|{
name|int
name|type
decl_stmt|;
define|#
directive|define
name|SYM_SYMBIOS_NVRAM
value|(1)
define|#
directive|define
name|SYM_TEKRAM_NVRAM
value|(2)
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
union|union
block|{
name|Symbios_nvram
name|Symbios
decl_stmt|;
name|Tekram_nvram
name|Tekram
decl_stmt|;
block|}
name|data
union|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  *  This one is hopefully useless, but actually useful. :-)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|assert
end_ifndef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|expression
parameter_list|)
value|{ \ 	if (!(expression)) { \ 		(void)panic( \ 			"assertion \"%s\" failed: file \"%s\", line %d\n", \ 			#expression, \ 			__FILE__, __LINE__); \ 	} \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Some provision for a possible big endian mode supported by  *  Symbios chips (never seen, by the way).  *  For now, this stuff does not deserve any comments. :)  */
end_comment

begin_define
define|#
directive|define
name|sym_offb
parameter_list|(
name|o
parameter_list|)
value|(o)
end_define

begin_define
define|#
directive|define
name|sym_offw
parameter_list|(
name|o
parameter_list|)
value|(o)
end_define

begin_comment
comment|/*  *  Some provision for support for BIG ENDIAN CPU.  */
end_comment

begin_define
define|#
directive|define
name|cpu_to_scr
parameter_list|(
name|dw
parameter_list|)
value|htole32(dw)
end_define

begin_define
define|#
directive|define
name|scr_to_cpu
parameter_list|(
name|dw
parameter_list|)
value|le32toh(dw)
end_define

begin_comment
comment|/*  *  Access to the chip IO registers and on-chip RAM.  *  We use the `bus space' interface under FreeBSD-4 and  *  later kernel versions.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYM_CONF_IOMAPPED
argument_list|)
end_if

begin_define
define|#
directive|define
name|INB_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_read_1(np->io_res, (o))
end_define

begin_define
define|#
directive|define
name|INW_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_read_2(np->io_res, (o))
end_define

begin_define
define|#
directive|define
name|INL_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_read_4(np->io_res, (o))
end_define

begin_define
define|#
directive|define
name|OUTB_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_1(np->io_res, (o), (v))
end_define

begin_define
define|#
directive|define
name|OUTW_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_2(np->io_res, (o), (v))
end_define

begin_define
define|#
directive|define
name|OUTL_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_4(np->io_res, (o), (v))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Memory mapped IO */
end_comment

begin_define
define|#
directive|define
name|INB_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_read_1(np->mmio_res, (o))
end_define

begin_define
define|#
directive|define
name|INW_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_read_2(np->mmio_res, (o))
end_define

begin_define
define|#
directive|define
name|INL_OFF
parameter_list|(
name|o
parameter_list|)
value|bus_read_4(np->mmio_res, (o))
end_define

begin_define
define|#
directive|define
name|OUTB_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_1(np->mmio_res, (o), (v))
end_define

begin_define
define|#
directive|define
name|OUTW_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_2(np->mmio_res, (o), (v))
end_define

begin_define
define|#
directive|define
name|OUTL_OFF
parameter_list|(
name|o
parameter_list|,
name|v
parameter_list|)
value|bus_write_4(np->mmio_res, (o), (v))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYM_CONF_IOMAPPED */
end_comment

begin_define
define|#
directive|define
name|OUTRAM_OFF
parameter_list|(
name|o
parameter_list|,
name|a
parameter_list|,
name|l
parameter_list|)
define|\
value|bus_write_region_1(np->ram_res, (o), (a), (l))
end_define

begin_comment
comment|/*  *  Common definitions for both bus space and legacy IO methods.  */
end_comment

begin_define
define|#
directive|define
name|INB
parameter_list|(
name|r
parameter_list|)
value|INB_OFF(offsetof(struct sym_reg,r))
end_define

begin_define
define|#
directive|define
name|INW
parameter_list|(
name|r
parameter_list|)
value|INW_OFF(offsetof(struct sym_reg,r))
end_define

begin_define
define|#
directive|define
name|INL
parameter_list|(
name|r
parameter_list|)
value|INL_OFF(offsetof(struct sym_reg,r))
end_define

begin_define
define|#
directive|define
name|OUTB
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|OUTB_OFF(offsetof(struct sym_reg,r), (v))
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|OUTW_OFF(offsetof(struct sym_reg,r), (v))
end_define

begin_define
define|#
directive|define
name|OUTL
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|OUTL_OFF(offsetof(struct sym_reg,r), (v))
end_define

begin_define
define|#
directive|define
name|OUTONB
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTB(r, INB(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFB
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTB(r, INB(r)& ~(m))
end_define

begin_define
define|#
directive|define
name|OUTONW
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTW(r, INW(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFW
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTW(r, INW(r)& ~(m))
end_define

begin_define
define|#
directive|define
name|OUTONL
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTL(r, INL(r) | (m))
end_define

begin_define
define|#
directive|define
name|OUTOFFL
parameter_list|(
name|r
parameter_list|,
name|m
parameter_list|)
value|OUTL(r, INL(r)& ~(m))
end_define

begin_comment
comment|/*  *  We normally want the chip to have a consistent view  *  of driver internal data structures when we restart it.  *  Thus these macros.  */
end_comment

begin_define
define|#
directive|define
name|OUTL_DSP
parameter_list|(
name|v
parameter_list|)
define|\
value|do {					\ 		MEMORY_BARRIER();		\ 		OUTL (nc_dsp, (v));		\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|OUTONB_STD
parameter_list|()
define|\
value|do {					\ 		MEMORY_BARRIER();		\ 		OUTONB (nc_dcntl, (STD|NOCOM));	\ 	} while (0)
end_define

begin_comment
comment|/*  *  Command control block states.  */
end_comment

begin_define
define|#
directive|define
name|HS_IDLE
value|(0)
end_define

begin_define
define|#
directive|define
name|HS_BUSY
value|(1)
end_define

begin_define
define|#
directive|define
name|HS_NEGOTIATE
value|(2)
end_define

begin_comment
comment|/* sync/wide data transfer*/
end_comment

begin_define
define|#
directive|define
name|HS_DISCONNECT
value|(3)
end_define

begin_comment
comment|/* Disconnected by target */
end_comment

begin_define
define|#
directive|define
name|HS_WAIT
value|(4)
end_define

begin_comment
comment|/* waiting for resource	  */
end_comment

begin_define
define|#
directive|define
name|HS_DONEMASK
value|(0x80)
end_define

begin_define
define|#
directive|define
name|HS_COMPLETE
value|(4|HS_DONEMASK)
end_define

begin_define
define|#
directive|define
name|HS_SEL_TIMEOUT
value|(5|HS_DONEMASK)
end_define

begin_comment
comment|/* Selection timeout      */
end_comment

begin_define
define|#
directive|define
name|HS_UNEXPECTED
value|(6|HS_DONEMASK)
end_define

begin_comment
comment|/* Unexpected disconnect  */
end_comment

begin_define
define|#
directive|define
name|HS_COMP_ERR
value|(7|HS_DONEMASK)
end_define

begin_comment
comment|/* Completed with error	  */
end_comment

begin_comment
comment|/*  *  Software Interrupt Codes  */
end_comment

begin_define
define|#
directive|define
name|SIR_BAD_SCSI_STATUS
value|(1)
end_define

begin_define
define|#
directive|define
name|SIR_SEL_ATN_NO_MSG_OUT
value|(2)
end_define

begin_define
define|#
directive|define
name|SIR_MSG_RECEIVED
value|(3)
end_define

begin_define
define|#
directive|define
name|SIR_MSG_WEIRD
value|(4)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_FAILED
value|(5)
end_define

begin_define
define|#
directive|define
name|SIR_NEGO_PROTO
value|(6)
end_define

begin_define
define|#
directive|define
name|SIR_SCRIPT_STOPPED
value|(7)
end_define

begin_define
define|#
directive|define
name|SIR_REJECT_TO_SEND
value|(8)
end_define

begin_define
define|#
directive|define
name|SIR_SWIDE_OVERRUN
value|(9)
end_define

begin_define
define|#
directive|define
name|SIR_SODL_UNDERRUN
value|(10)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_NO_MSG_IN
value|(11)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_NO_IDENTIFY
value|(12)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_BAD_LUN
value|(13)
end_define

begin_define
define|#
directive|define
name|SIR_TARGET_SELECTED
value|(14)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_BAD_I_T_L
value|(15)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_BAD_I_T_L_Q
value|(16)
end_define

begin_define
define|#
directive|define
name|SIR_ABORT_SENT
value|(17)
end_define

begin_define
define|#
directive|define
name|SIR_RESEL_ABORTED
value|(18)
end_define

begin_define
define|#
directive|define
name|SIR_MSG_OUT_DONE
value|(19)
end_define

begin_define
define|#
directive|define
name|SIR_COMPLETE_ERROR
value|(20)
end_define

begin_define
define|#
directive|define
name|SIR_DATA_OVERRUN
value|(21)
end_define

begin_define
define|#
directive|define
name|SIR_BAD_PHASE
value|(22)
end_define

begin_define
define|#
directive|define
name|SIR_MAX
value|(22)
end_define

begin_comment
comment|/*  *  Extended error bit codes.  *  xerr_status field of struct sym_ccb.  */
end_comment

begin_define
define|#
directive|define
name|XE_EXTRA_DATA
value|(1)
end_define

begin_comment
comment|/* unexpected data phase	 */
end_comment

begin_define
define|#
directive|define
name|XE_BAD_PHASE
value|(1<<1)
end_define

begin_comment
comment|/* illegal phase (4/5)		 */
end_comment

begin_define
define|#
directive|define
name|XE_PARITY_ERR
value|(1<<2)
end_define

begin_comment
comment|/* unrecovered SCSI parity error */
end_comment

begin_define
define|#
directive|define
name|XE_SODL_UNRUN
value|(1<<3)
end_define

begin_comment
comment|/* ODD transfer in DATA OUT phase */
end_comment

begin_define
define|#
directive|define
name|XE_SWIDE_OVRUN
value|(1<<4)
end_define

begin_comment
comment|/* ODD transfer in DATA IN phase */
end_comment

begin_comment
comment|/*  *  Negotiation status.  *  nego_status field of struct sym_ccb.  */
end_comment

begin_define
define|#
directive|define
name|NS_SYNC
value|(1)
end_define

begin_define
define|#
directive|define
name|NS_WIDE
value|(2)
end_define

begin_define
define|#
directive|define
name|NS_PPR
value|(3)
end_define

begin_comment
comment|/*  *  A CCB hashed table is used to retrieve CCB address  *  from DSA value.  */
end_comment

begin_define
define|#
directive|define
name|CCB_HASH_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|CCB_HASH_SIZE
value|(1UL<< CCB_HASH_SHIFT)
end_define

begin_define
define|#
directive|define
name|CCB_HASH_MASK
value|(CCB_HASH_SIZE-1)
end_define

begin_define
define|#
directive|define
name|CCB_HASH_CODE
parameter_list|(
name|dsa
parameter_list|)
value|(((dsa)>> 9)& CCB_HASH_MASK)
end_define

begin_comment
comment|/*  *  Device flags.  */
end_comment

begin_define
define|#
directive|define
name|SYM_DISC_ENABLED
value|(1)
end_define

begin_define
define|#
directive|define
name|SYM_TAGS_ENABLED
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|SYM_SCAN_BOOT_DISABLED
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|SYM_SCAN_LUNS_DISABLED
value|(1<<3)
end_define

begin_comment
comment|/*  *  Host adapter miscellaneous flags.  */
end_comment

begin_define
define|#
directive|define
name|SYM_AVOID_BUS_RESET
value|(1)
end_define

begin_define
define|#
directive|define
name|SYM_SCAN_TARGETS_HILO
value|(1<<1)
end_define

begin_comment
comment|/*  *  Device quirks.  *  Some devices, for example the CHEETAH 2 LVD, disconnects without  *  saving the DATA POINTER then reselects and terminates the IO.  *  On reselection, the automatic RESTORE DATA POINTER makes the  *  CURRENT DATA POINTER not point at the end of the IO.  *  This behaviour just breaks our calculation of the residual.  *  For now, we just force an AUTO SAVE on disconnection and will  *  fix that in a further driver version.  */
end_comment

begin_define
define|#
directive|define
name|SYM_QUIRK_AUTOSAVE
value|1
end_define

begin_comment
comment|/*  *  Misc.  */
end_comment

begin_define
define|#
directive|define
name|SYM_LOCK
parameter_list|()
value|mtx_lock(&np->mtx)
end_define

begin_define
define|#
directive|define
name|SYM_LOCK_ASSERT
parameter_list|(
name|_what
parameter_list|)
value|mtx_assert(&np->mtx, (_what))
end_define

begin_define
define|#
directive|define
name|SYM_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&np->mtx)
end_define

begin_define
define|#
directive|define
name|SYM_LOCK_INIT
parameter_list|()
value|mtx_init(&np->mtx, "sym_lock", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SYM_LOCK_INITIALIZED
parameter_list|()
value|mtx_initialized(&np->mtx)
end_define

begin_define
define|#
directive|define
name|SYM_UNLOCK
parameter_list|()
value|mtx_unlock(&np->mtx)
end_define

begin_define
define|#
directive|define
name|SYM_SNOOP_TIMEOUT
value|(10000000)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_IO
value|PCIR_BAR(0)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_MMIO
value|PCIR_BAR(1)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_RAM
value|PCIR_BAR(2)
end_define

begin_define
define|#
directive|define
name|SYM_PCI_RAM64
value|PCIR_BAR(3)
end_define

begin_comment
comment|/*  *  Back-pointer from the CAM CCB to our data structures.  */
end_comment

begin_define
define|#
directive|define
name|sym_hcb_ptr
value|spriv_ptr0
end_define

begin_comment
comment|/* #define sym_ccb_ptr	spriv_ptr1 */
end_comment

begin_comment
comment|/*  *  We mostly have to deal with pointers.  *  Thus these typedef's.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|sym_tcb
modifier|*
name|tcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_lcb
modifier|*
name|lcb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_ccb
modifier|*
name|ccb_p
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|sym_hcb
modifier|*
name|hcb_p
typedef|;
end_typedef

begin_comment
comment|/*  *  Gather negotiable parameters value  */
end_comment

begin_struct
struct|struct
name|sym_trans
block|{
name|u8
name|scsi_version
decl_stmt|;
name|u8
name|spi_version
decl_stmt|;
name|u8
name|period
decl_stmt|;
name|u8
name|offset
decl_stmt|;
name|u8
name|width
decl_stmt|;
name|u8
name|options
decl_stmt|;
comment|/* PPR options */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sym_tinfo
block|{
name|struct
name|sym_trans
name|current
decl_stmt|;
name|struct
name|sym_trans
name|goal
decl_stmt|;
name|struct
name|sym_trans
name|user
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BUS_8_BIT
value|MSG_EXT_WDTR_BUS_8_BIT
end_define

begin_define
define|#
directive|define
name|BUS_16_BIT
value|MSG_EXT_WDTR_BUS_16_BIT
end_define

begin_comment
comment|/*  *  Global TCB HEADER.  *  *  Due to lack of indirect addressing on earlier NCR chips,  *  this substructure is copied from the TCB to a global  *  address after selection.  *  For SYMBIOS chips that support LOAD/STORE this copy is  *  not needed and thus not performed.  */
end_comment

begin_struct
struct|struct
name|sym_tcbh
block|{
comment|/* 	 *  Scripts bus addresses of LUN table accessed from scripts. 	 *  LUN #0 is a special case, since multi-lun devices are rare, 	 *  and we we want to speed-up the general case and not waste 	 *  resources. 	 */
name|u32
name|luntbl_sa
decl_stmt|;
comment|/* bus address of this table	*/
name|u32
name|lun0_sa
decl_stmt|;
comment|/* bus address of LCB #0	*/
comment|/* 	 *  Actual SYNC/WIDE IO registers value for this target. 	 *  'sval', 'wval' and 'uval' are read from SCRIPTS and 	 *  so have alignment constraints. 	 */
comment|/*0*/
name|u_char
name|uval
decl_stmt|;
comment|/* -> SCNTL4 register		*/
comment|/*1*/
name|u_char
name|sval
decl_stmt|;
comment|/* -> SXFER  io register	*/
comment|/*2*/
name|u_char
name|filler1
decl_stmt|;
comment|/*3*/
name|u_char
name|wval
decl_stmt|;
comment|/* -> SCNTL3 io register	*/
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Target Control Block  */
end_comment

begin_struct
struct|struct
name|sym_tcb
block|{
comment|/* 	 *  TCB header. 	 *  Assumed at offset 0. 	 */
comment|/*0*/
name|struct
name|sym_tcbh
name|head
decl_stmt|;
comment|/* 	 *  LUN table used by the SCRIPTS processor. 	 *  An array of bus addresses is used on reselection. 	 */
name|u32
modifier|*
name|luntbl
decl_stmt|;
comment|/* LCBs bus address table	*/
comment|/* 	 *  LUN table used by the C code. 	 */
name|lcb_p
name|lun0p
decl_stmt|;
comment|/* LCB of LUN #0 (usual case)	*/
if|#
directive|if
name|SYM_CONF_MAX_LUN
operator|>
literal|1
name|lcb_p
modifier|*
name|lunmp
decl_stmt|;
comment|/* Other LCBs [1..MAX_LUN]	*/
endif|#
directive|endif
comment|/* 	 *  Bitmap that tells about LUNs that succeeded at least 	 *  1 IO and therefore assumed to be a real device. 	 *  Avoid useless allocation of the LCB structure. 	 */
name|u32
name|lun_map
index|[
operator|(
name|SYM_CONF_MAX_LUN
operator|+
literal|31
operator|)
operator|/
literal|32
index|]
decl_stmt|;
comment|/* 	 *  Bitmap that tells about LUNs that haven't yet an LCB 	 *  allocated (not discovered or LCB allocation failed). 	 */
name|u32
name|busy0_map
index|[
operator|(
name|SYM_CONF_MAX_LUN
operator|+
literal|31
operator|)
operator|/
literal|32
index|]
decl_stmt|;
comment|/* 	 *  Transfer capabilities (SIP) 	 */
name|struct
name|sym_tinfo
name|tinfo
decl_stmt|;
comment|/* 	 * Keep track of the CCB used for the negotiation in order 	 * to ensure that only 1 negotiation is queued at a time. 	 */
name|ccb_p
name|nego_cp
decl_stmt|;
comment|/* CCB used for the nego		*/
comment|/* 	 *  Set when we want to reset the device. 	 */
name|u_char
name|to_reset
decl_stmt|;
comment|/* 	 *  Other user settable limits and options. 	 *  These limits are read from the NVRAM if present. 	 */
name|u_char
name|usrflags
decl_stmt|;
name|u_short
name|usrtags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Global LCB HEADER.  *  *  Due to lack of indirect addressing on earlier NCR chips,  *  this substructure is copied from the LCB to a global  *  address after selection.  *  For SYMBIOS chips that support LOAD/STORE this copy is  *  not needed and thus not performed.  */
end_comment

begin_struct
struct|struct
name|sym_lcbh
block|{
comment|/* 	 *  SCRIPTS address jumped by SCRIPTS on reselection. 	 *  For not probed logical units, this address points to 	 *  SCRIPTS that deal with bad LU handling (must be at 	 *  offset zero of the LCB for that reason). 	 */
comment|/*0*/
name|u32
name|resel_sa
decl_stmt|;
comment|/* 	 *  Task (bus address of a CCB) read from SCRIPTS that points 	 *  to the unique ITL nexus allowed to be disconnected. 	 */
name|u32
name|itl_task_sa
decl_stmt|;
comment|/* 	 *  Task table bus address (read from SCRIPTS). 	 */
name|u32
name|itlq_tbl_sa
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Logical Unit Control Block  */
end_comment

begin_struct
struct|struct
name|sym_lcb
block|{
comment|/* 	 *  TCB header. 	 *  Assumed at offset 0. 	 */
comment|/*0*/
name|struct
name|sym_lcbh
name|head
decl_stmt|;
comment|/* 	 *  Task table read from SCRIPTS that contains pointers to 	 *  ITLQ nexuses. The bus address read from SCRIPTS is 	 *  inside the header. 	 */
name|u32
modifier|*
name|itlq_tbl
decl_stmt|;
comment|/* Kernel virtual address	*/
comment|/* 	 *  Busy CCBs management. 	 */
name|u_short
name|busy_itlq
decl_stmt|;
comment|/* Number of busy tagged CCBs	*/
name|u_short
name|busy_itl
decl_stmt|;
comment|/* Number of busy untagged CCBs	*/
comment|/* 	 *  Circular tag allocation buffer. 	 */
name|u_short
name|ia_tag
decl_stmt|;
comment|/* Tag allocation index		*/
name|u_short
name|if_tag
decl_stmt|;
comment|/* Tag release index		*/
name|u_char
modifier|*
name|cb_tags
decl_stmt|;
comment|/* Circular tags buffer		*/
comment|/* 	 *  Set when we want to clear all tasks. 	 */
name|u_char
name|to_clear
decl_stmt|;
comment|/* 	 *  Capabilities. 	 */
name|u_char
name|user_flags
decl_stmt|;
name|u_char
name|current_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Action from SCRIPTS on a task.  *  Is part of the CCB, but is also used separately to plug  *  error handling action to perform from SCRIPTS.  */
end_comment

begin_struct
struct|struct
name|sym_actscr
block|{
name|u32
name|start
decl_stmt|;
comment|/* Jumped by SCRIPTS after selection	*/
name|u32
name|restart
decl_stmt|;
comment|/* Jumped by SCRIPTS on relection	*/
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Phase mismatch context.  *  *  It is part of the CCB and is used as parameters for the  *  DATA pointer. We need two contexts to handle correctly the  *  SAVED DATA POINTER.  */
end_comment

begin_struct
struct|struct
name|sym_pmc
block|{
name|struct
name|sym_tblmove
name|sg
decl_stmt|;
comment|/* Updated interrupted SG block	*/
name|u32
name|ret
decl_stmt|;
comment|/* SCRIPT return address	*/
block|}
struct|;
end_struct

begin_comment
comment|/*  *  LUN control block lookup.  *  We use a direct pointer for LUN #0, and a table of  *  pointers which is only allocated for devices that support  *  LUN(s)> 0.  */
end_comment

begin_if
if|#
directive|if
name|SYM_CONF_MAX_LUN
operator|<=
literal|1
end_if

begin_define
define|#
directive|define
name|sym_lp
parameter_list|(
name|np
parameter_list|,
name|tp
parameter_list|,
name|lun
parameter_list|)
value|(!lun) ? (tp)->lun0p : 0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|sym_lp
parameter_list|(
name|np
parameter_list|,
name|tp
parameter_list|,
name|lun
parameter_list|)
define|\
value|(!lun) ? (tp)->lun0p : (tp)->lunmp ? (tp)->lunmp[(lun)] : 0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Status are used by the host and the script processor.  *  *  The last four bytes (status[4]) are copied to the  *  scratchb register (declared as scr0..scr3) just after the  *  select/reselect, and copied back just after disconnecting.  *  Inside the script the XX_REG are used.  */
end_comment

begin_comment
comment|/*  *  Last four bytes (script)  */
end_comment

begin_define
define|#
directive|define
name|QU_REG
value|scr0
end_define

begin_define
define|#
directive|define
name|HS_REG
value|scr1
end_define

begin_define
define|#
directive|define
name|HS_PRT
value|nc_scr1
end_define

begin_define
define|#
directive|define
name|SS_REG
value|scr2
end_define

begin_define
define|#
directive|define
name|SS_PRT
value|nc_scr2
end_define

begin_define
define|#
directive|define
name|HF_REG
value|scr3
end_define

begin_define
define|#
directive|define
name|HF_PRT
value|nc_scr3
end_define

begin_comment
comment|/*  *  Last four bytes (host)  */
end_comment

begin_define
define|#
directive|define
name|actualquirks
value|phys.head.status[0]
end_define

begin_define
define|#
directive|define
name|host_status
value|phys.head.status[1]
end_define

begin_define
define|#
directive|define
name|ssss_status
value|phys.head.status[2]
end_define

begin_define
define|#
directive|define
name|host_flags
value|phys.head.status[3]
end_define

begin_comment
comment|/*  *  Host flags  */
end_comment

begin_define
define|#
directive|define
name|HF_IN_PM0
value|1u
end_define

begin_define
define|#
directive|define
name|HF_IN_PM1
value|(1u<<1)
end_define

begin_define
define|#
directive|define
name|HF_ACT_PM
value|(1u<<2)
end_define

begin_define
define|#
directive|define
name|HF_DP_SAVED
value|(1u<<3)
end_define

begin_define
define|#
directive|define
name|HF_SENSE
value|(1u<<4)
end_define

begin_define
define|#
directive|define
name|HF_EXT_ERR
value|(1u<<5)
end_define

begin_define
define|#
directive|define
name|HF_DATA_IN
value|(1u<<6)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
end_ifdef

begin_define
define|#
directive|define
name|HF_HINT_IARB
value|(1u<<7)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Global CCB HEADER.  *  *  Due to lack of indirect addressing on earlier NCR chips,  *  this substructure is copied from the ccb to a global  *  address after selection (or reselection) and copied back  *  before disconnect.  *  For SYMBIOS chips that support LOAD/STORE this copy is  *  not needed and thus not performed.  */
end_comment

begin_struct
struct|struct
name|sym_ccbh
block|{
comment|/* 	 *  Start and restart SCRIPTS addresses (must be at 0). 	 */
comment|/*0*/
name|struct
name|sym_actscr
name|go
decl_stmt|;
comment|/* 	 *  SCRIPTS jump address that deal with data pointers. 	 *  'savep' points to the position in the script responsible 	 *  for the actual transfer of data. 	 *  It's written on reception of a SAVE_DATA_POINTER message. 	 */
name|u32
name|savep
decl_stmt|;
comment|/* Jump address to saved data pointer	*/
name|u32
name|lastp
decl_stmt|;
comment|/* SCRIPTS address at end of data	*/
name|u32
name|goalp
decl_stmt|;
comment|/* Not accessed for now from SCRIPTS	*/
comment|/* 	 *  Status fields. 	 */
name|u8
name|status
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Data Structure Block  *  *  During execution of a ccb by the script processor, the  *  DSA (data structure address) register points to this  *  substructure of the ccb.  */
end_comment

begin_struct
struct|struct
name|sym_dsb
block|{
comment|/* 	 *  CCB header. 	 *  Also assumed at offset 0 of the sym_ccb structure. 	 */
comment|/*0*/
name|struct
name|sym_ccbh
name|head
decl_stmt|;
comment|/* 	 *  Phase mismatch contexts. 	 *  We need two to handle correctly the SAVED DATA POINTER. 	 *  MUST BOTH BE AT OFFSET< 256, due to using 8 bit arithmetic 	 *  for address calculation from SCRIPTS. 	 */
name|struct
name|sym_pmc
name|pm0
decl_stmt|;
name|struct
name|sym_pmc
name|pm1
decl_stmt|;
comment|/* 	 *  Table data for Script 	 */
name|struct
name|sym_tblsel
name|select
decl_stmt|;
name|struct
name|sym_tblmove
name|smsg
decl_stmt|;
name|struct
name|sym_tblmove
name|smsg_ext
decl_stmt|;
name|struct
name|sym_tblmove
name|cmd
decl_stmt|;
name|struct
name|sym_tblmove
name|sense
decl_stmt|;
name|struct
name|sym_tblmove
name|wresid
decl_stmt|;
name|struct
name|sym_tblmove
name|data
index|[
name|SYM_CONF_MAX_SG
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Our Command Control Block  */
end_comment

begin_struct
struct|struct
name|sym_ccb
block|{
comment|/* 	 *  This is the data structure which is pointed by the DSA 	 *  register when it is executed by the script processor. 	 *  It must be the first entry. 	 */
name|struct
name|sym_dsb
name|phys
decl_stmt|;
comment|/* 	 *  Pointer to CAM ccb and related stuff. 	 */
name|struct
name|callout
name|ch
decl_stmt|;
comment|/* callout handle		*/
name|union
name|ccb
modifier|*
name|cam_ccb
decl_stmt|;
comment|/* CAM scsiio ccb		*/
name|u8
name|cdb_buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* Copy of CDB			*/
name|u8
modifier|*
name|sns_bbuf
decl_stmt|;
comment|/* Bounce buffer for sense data	*/
define|#
directive|define
name|SYM_SNS_BBUF_LEN
value|sizeof(struct scsi_sense_data)
name|int
name|data_len
decl_stmt|;
comment|/* Total data length		*/
name|int
name|segments
decl_stmt|;
comment|/* Number of SG segments	*/
comment|/* 	 *  Miscellaneous status'. 	 */
name|u_char
name|nego_status
decl_stmt|;
comment|/* Negotiation status		*/
name|u_char
name|xerr_status
decl_stmt|;
comment|/* Extended error flags		*/
name|u32
name|extra_bytes
decl_stmt|;
comment|/* Extraneous bytes transferred	*/
comment|/* 	 *  Message areas. 	 *  We prepare a message to be sent after selection. 	 *  We may use a second one if the command is rescheduled 	 *  due to CHECK_CONDITION or COMMAND TERMINATED. 	 *  Contents are IDENTIFY and SIMPLE_TAG. 	 *  While negotiating sync or wide transfer, 	 *  a SDTR or WDTR message is appended. 	 */
name|u_char
name|scsi_smsg
index|[
literal|12
index|]
decl_stmt|;
name|u_char
name|scsi_smsg2
index|[
literal|12
index|]
decl_stmt|;
comment|/* 	 *  Auto request sense related fields. 	 */
name|u_char
name|sensecmd
index|[
literal|6
index|]
decl_stmt|;
comment|/* Request Sense command	*/
name|u_char
name|sv_scsi_status
decl_stmt|;
comment|/* Saved SCSI status 		*/
name|u_char
name|sv_xerr_status
decl_stmt|;
comment|/* Saved extended status	*/
name|int
name|sv_resid
decl_stmt|;
comment|/* Saved residual		*/
comment|/* 	 *  Map for the DMA of user data. 	 */
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* Argument for some callback	*/
name|bus_dmamap_t
name|dmamap
decl_stmt|;
comment|/* DMA map for user data	*/
name|u_char
name|dmamapped
decl_stmt|;
define|#
directive|define
name|SYM_DMA_NONE
value|0
define|#
directive|define
name|SYM_DMA_READ
value|1
define|#
directive|define
name|SYM_DMA_WRITE
value|2
comment|/* 	 *  Other fields. 	 */
name|u32
name|ccb_ba
decl_stmt|;
comment|/* BUS address of this CCB	*/
name|u_short
name|tag
decl_stmt|;
comment|/* Tag for this transfer	*/
comment|/*  NO_TAG means no tag		*/
name|u_char
name|target
decl_stmt|;
name|u_char
name|lun
decl_stmt|;
name|ccb_p
name|link_ccbh
decl_stmt|;
comment|/* Host adapter CCB hash chain	*/
name|SYM_QUEHEAD
name|link_ccbq
decl_stmt|;
comment|/* Link to free/busy CCB queue	*/
name|u32
name|startp
decl_stmt|;
comment|/* Initial data pointer		*/
name|int
name|ext_sg
decl_stmt|;
comment|/* Extreme data pointer, used	*/
name|int
name|ext_ofs
decl_stmt|;
comment|/*  to calculate the residual.	*/
name|u_char
name|to_abort
decl_stmt|;
comment|/* Want this IO to be aborted	*/
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CCB_BA
parameter_list|(
name|cp
parameter_list|,
name|lbl
parameter_list|)
value|(cp->ccb_ba + offsetof(struct sym_ccb, lbl))
end_define

begin_comment
comment|/*  *  Host Control Block  */
end_comment

begin_struct
struct|struct
name|sym_hcb
block|{
name|struct
name|mtx
name|mtx
decl_stmt|;
comment|/* 	 *  Global headers. 	 *  Due to poorness of addressing capabilities, earlier 	 *  chips (810, 815, 825) copy part of the data structures 	 *  (CCB, TCB and LCB) in fixed areas. 	 */
ifdef|#
directive|ifdef
name|SYM_CONF_GENERIC_SUPPORT
name|struct
name|sym_ccbh
name|ccb_head
decl_stmt|;
name|struct
name|sym_tcbh
name|tcb_head
decl_stmt|;
name|struct
name|sym_lcbh
name|lcb_head
decl_stmt|;
endif|#
directive|endif
comment|/* 	 *  Idle task and invalid task actions and 	 *  their bus addresses. 	 */
name|struct
name|sym_actscr
name|idletask
decl_stmt|,
name|notask
decl_stmt|,
name|bad_itl
decl_stmt|,
name|bad_itlq
decl_stmt|;
name|vm_offset_t
name|idletask_ba
decl_stmt|,
name|notask_ba
decl_stmt|,
name|bad_itl_ba
decl_stmt|,
name|bad_itlq_ba
decl_stmt|;
comment|/* 	 *  Dummy lun table to protect us against target 	 *  returning bad lun number on reselection. 	 */
name|u32
modifier|*
name|badluntbl
decl_stmt|;
comment|/* Table physical address	*/
name|u32
name|badlun_sa
decl_stmt|;
comment|/* SCRIPT handler BUS address	*/
comment|/* 	 *  Bus address of this host control block. 	 */
name|u32
name|hcb_ba
decl_stmt|;
comment|/* 	 *  Bit 32-63 of the on-chip RAM bus address in LE format. 	 *  The START_RAM64 script loads the MMRS and MMWS from this 	 *  field. 	 */
name|u32
name|scr_ram_seg
decl_stmt|;
comment|/* 	 *  Chip and controller indentification. 	 */
name|device_t
name|device
decl_stmt|;
comment|/* 	 *  Initial value of some IO register bits. 	 *  These values are assumed to have been set by BIOS, and may 	 *  be used to probe adapter implementation differences. 	 */
name|u_char
name|sv_scntl0
decl_stmt|,
name|sv_scntl3
decl_stmt|,
name|sv_dmode
decl_stmt|,
name|sv_dcntl
decl_stmt|,
name|sv_ctest3
decl_stmt|,
name|sv_ctest4
decl_stmt|,
name|sv_ctest5
decl_stmt|,
name|sv_gpcntl
decl_stmt|,
name|sv_stest2
decl_stmt|,
name|sv_stest4
decl_stmt|,
name|sv_scntl4
decl_stmt|,
name|sv_stest1
decl_stmt|;
comment|/* 	 *  Actual initial value of IO register bits used by the 	 *  driver. They are loaded at initialisation according to 	 *  features that are to be enabled/disabled. 	 */
name|u_char
name|rv_scntl0
decl_stmt|,
name|rv_scntl3
decl_stmt|,
name|rv_dmode
decl_stmt|,
name|rv_dcntl
decl_stmt|,
name|rv_ctest3
decl_stmt|,
name|rv_ctest4
decl_stmt|,
name|rv_ctest5
decl_stmt|,
name|rv_stest2
decl_stmt|,
name|rv_ccntl0
decl_stmt|,
name|rv_ccntl1
decl_stmt|,
name|rv_scntl4
decl_stmt|;
comment|/* 	 *  Target data. 	 */
ifdef|#
directive|ifdef
name|__amd64__
name|struct
name|sym_tcb
modifier|*
name|target
decl_stmt|;
else|#
directive|else
name|struct
name|sym_tcb
name|target
index|[
name|SYM_CONF_MAX_TARGET
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 *  Target control block bus address array used by the SCRIPT 	 *  on reselection. 	 */
name|u32
modifier|*
name|targtbl
decl_stmt|;
name|u32
name|targtbl_ba
decl_stmt|;
comment|/* 	 *  CAM SIM information for this instance. 	 */
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
comment|/* 	 *  Allocated hardware resources. 	 */
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|io_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|mmio_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|ram_res
decl_stmt|;
name|int
name|ram_id
decl_stmt|;
name|void
modifier|*
name|intr
decl_stmt|;
comment|/* 	 *  Bus stuff. 	 * 	 *  My understanding of PCI is that all agents must share the 	 *  same addressing range and model. 	 *  But some hardware architecture guys provide complex and 	 *  brain-deaded stuff that makes shit. 	 *  This driver only support PCI compliant implementations and 	 *  deals with part of the BUS stuff complexity only to fit O/S 	 *  requirements. 	 */
comment|/* 	 *  DMA stuff. 	 */
name|bus_dma_tag_t
name|bus_dmat
decl_stmt|;
comment|/* DMA tag from parent BUS	*/
name|bus_dma_tag_t
name|data_dmat
decl_stmt|;
comment|/* DMA tag for user data	*/
comment|/* 	 *  BUS addresses of the chip 	 */
name|vm_offset_t
name|mmio_ba
decl_stmt|;
comment|/* MMIO BUS address		*/
name|int
name|mmio_ws
decl_stmt|;
comment|/* MMIO Window size		*/
name|vm_offset_t
name|ram_ba
decl_stmt|;
comment|/* RAM BUS address		*/
name|int
name|ram_ws
decl_stmt|;
comment|/* RAM window size		*/
comment|/* 	 *  SCRIPTS virtual and physical bus addresses. 	 *  'script'  is loaded in the on-chip RAM if present. 	 *  'scripth' stays in main memory for all chips except the 	 *  53C895A, 53C896 and 53C1010 that provide 8K on-chip RAM. 	 */
name|u_char
modifier|*
name|scripta0
decl_stmt|;
comment|/* Copies of script and scripth	*/
name|u_char
modifier|*
name|scriptb0
decl_stmt|;
comment|/* Copies of script and scripth	*/
name|vm_offset_t
name|scripta_ba
decl_stmt|;
comment|/* Actual script and scripth	*/
name|vm_offset_t
name|scriptb_ba
decl_stmt|;
comment|/*  bus addresses.		*/
name|vm_offset_t
name|scriptb0_ba
decl_stmt|;
name|u_short
name|scripta_sz
decl_stmt|;
comment|/* Actual size of script A	*/
name|u_short
name|scriptb_sz
decl_stmt|;
comment|/* Actual size of script B	*/
comment|/* 	 *  Bus addresses, setup and patch methods for 	 *  the selected firmware. 	 */
name|struct
name|sym_fwa_ba
name|fwa_bas
decl_stmt|;
comment|/* Useful SCRIPTA bus addresses	*/
name|struct
name|sym_fwb_ba
name|fwb_bas
decl_stmt|;
comment|/* Useful SCRIPTB bus addresses	*/
name|void
function_decl|(
modifier|*
name|fw_setup
function_decl|)
parameter_list|(
name|hcb_p
name|np
parameter_list|,
specifier|const
name|struct
name|sym_fw
modifier|*
name|fw
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|fw_patch
function_decl|)
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|fw_name
decl_stmt|;
comment|/* 	 *  General controller parameters and configuration. 	 */
name|u_short
name|device_id
decl_stmt|;
comment|/* PCI device id		*/
name|u_char
name|revision_id
decl_stmt|;
comment|/* PCI device revision id	*/
name|u_int
name|features
decl_stmt|;
comment|/* Chip features map		*/
name|u_char
name|myaddr
decl_stmt|;
comment|/* SCSI id of the adapter	*/
name|u_char
name|maxburst
decl_stmt|;
comment|/* log base 2 of dwords burst	*/
name|u_char
name|maxwide
decl_stmt|;
comment|/* Maximum transfer width	*/
name|u_char
name|minsync
decl_stmt|;
comment|/* Min sync period factor (ST)	*/
name|u_char
name|maxsync
decl_stmt|;
comment|/* Max sync period factor (ST)	*/
name|u_char
name|maxoffs
decl_stmt|;
comment|/* Max scsi offset        (ST)	*/
name|u_char
name|minsync_dt
decl_stmt|;
comment|/* Min sync period factor (DT)	*/
name|u_char
name|maxsync_dt
decl_stmt|;
comment|/* Max sync period factor (DT)	*/
name|u_char
name|maxoffs_dt
decl_stmt|;
comment|/* Max scsi offset        (DT)	*/
name|u_char
name|multiplier
decl_stmt|;
comment|/* Clock multiplier (1,2,4)	*/
name|u_char
name|clock_divn
decl_stmt|;
comment|/* Number of clock divisors	*/
name|u32
name|clock_khz
decl_stmt|;
comment|/* SCSI clock frequency in KHz	*/
name|u32
name|pciclk_khz
decl_stmt|;
comment|/* Estimated PCI clock  in KHz	*/
comment|/* 	 *  Start queue management. 	 *  It is filled up by the host processor and accessed by the 	 *  SCRIPTS processor in order to start SCSI commands. 	 */
specifier|volatile
comment|/* Prevent code optimizations	*/
name|u32
modifier|*
name|squeue
decl_stmt|;
comment|/* Start queue virtual address	*/
name|u32
name|squeue_ba
decl_stmt|;
comment|/* Start queue BUS address	*/
name|u_short
name|squeueput
decl_stmt|;
comment|/* Next free slot of the queue	*/
name|u_short
name|actccbs
decl_stmt|;
comment|/* Number of allocated CCBs	*/
comment|/* 	 *  Command completion queue. 	 *  It is the same size as the start queue to avoid overflow. 	 */
name|u_short
name|dqueueget
decl_stmt|;
comment|/* Next position to scan	*/
specifier|volatile
comment|/* Prevent code optimizations	*/
name|u32
modifier|*
name|dqueue
decl_stmt|;
comment|/* Completion (done) queue	*/
name|u32
name|dqueue_ba
decl_stmt|;
comment|/* Done queue BUS address	*/
comment|/* 	 *  Miscellaneous buffers accessed by the scripts-processor. 	 *  They shall be DWORD aligned, because they may be read or 	 *  written with a script command. 	 */
name|u_char
name|msgout
index|[
literal|8
index|]
decl_stmt|;
comment|/* Buffer for MESSAGE OUT 	*/
name|u_char
name|msgin
index|[
literal|8
index|]
decl_stmt|;
comment|/* Buffer for MESSAGE IN	*/
name|u32
name|lastmsg
decl_stmt|;
comment|/* Last SCSI message sent	*/
name|u_char
name|scratch
decl_stmt|;
comment|/* Scratch for SCSI receive	*/
comment|/* 	 *  Miscellaneous configuration and status parameters. 	 */
name|u_char
name|usrflags
decl_stmt|;
comment|/* Miscellaneous user flags	*/
name|u_char
name|scsi_mode
decl_stmt|;
comment|/* Current SCSI BUS mode	*/
name|u_char
name|verbose
decl_stmt|;
comment|/* Verbosity for this controller*/
name|u32
name|cache
decl_stmt|;
comment|/* Used for cache test at init.	*/
comment|/* 	 *  CCB lists and queue. 	 */
name|ccb_p
name|ccbh
index|[
name|CCB_HASH_SIZE
index|]
decl_stmt|;
comment|/* CCB hashed by DSA value	*/
name|SYM_QUEHEAD
name|free_ccbq
decl_stmt|;
comment|/* Queue of available CCBs	*/
name|SYM_QUEHEAD
name|busy_ccbq
decl_stmt|;
comment|/* Queue of busy CCBs		*/
comment|/* 	 *  During error handling and/or recovery, 	 *  active CCBs that are to be completed with 	 *  error or requeued are moved from the busy_ccbq 	 *  to the comp_ccbq prior to completion. 	 */
name|SYM_QUEHEAD
name|comp_ccbq
decl_stmt|;
comment|/* 	 *  CAM CCB pending queue. 	 */
name|SYM_QUEHEAD
name|cam_ccbq
decl_stmt|;
comment|/* 	 *  IMMEDIATE ARBITRATION (IARB) control. 	 * 	 *  We keep track in 'last_cp' of the last CCB that has been 	 *  queued to the SCRIPTS processor and clear 'last_cp' when 	 *  this CCB completes. If last_cp is not zero at the moment 	 *  we queue a new CCB, we set a flag in 'last_cp' that is 	 *  used by the SCRIPTS as a hint for setting IARB. 	 *  We donnot set more than 'iarb_max' consecutive hints for 	 *  IARB in order to leave devices a chance to reselect. 	 *  By the way, any non zero value of 'iarb_max' is unfair. :) 	 */
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
name|u_short
name|iarb_max
decl_stmt|;
comment|/* Max. # consecutive IARB hints*/
name|u_short
name|iarb_count
decl_stmt|;
comment|/* Actual # of these hints	*/
name|ccb_p
name|last_cp
decl_stmt|;
endif|#
directive|endif
comment|/* 	 *  Command abort handling. 	 *  We need to synchronize tightly with the SCRIPTS 	 *  processor in order to handle things correctly. 	 */
name|u_char
name|abrt_msg
index|[
literal|4
index|]
decl_stmt|;
comment|/* Message to send buffer	*/
name|struct
name|sym_tblmove
name|abrt_tbl
decl_stmt|;
comment|/* Table for the MOV of it 	*/
name|struct
name|sym_tblsel
name|abrt_sel
decl_stmt|;
comment|/* Sync params for selection	*/
name|u_char
name|istat_sem
decl_stmt|;
comment|/* Tells the chip to stop (SEM)	*/
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HCB_BA
parameter_list|(
name|np
parameter_list|,
name|lbl
parameter_list|)
value|(np->hcb_ba      + offsetof(struct sym_hcb, lbl))
end_define

begin_comment
comment|/*  *  Return the name of the controller.  */
end_comment

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|sym_name
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
return|return
name|device_get_nameunit
argument_list|(
name|np
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*------------------------------ FIRMWARES ---------------------------------*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *  This stuff will be moved to a separate source file when  *  the driver will be broken into several source modules.  */
end_comment

begin_comment
comment|/*  *  Macros used for all firmwares.  */
end_comment

begin_define
define|#
directive|define
name|SYM_GEN_A
parameter_list|(
name|s
parameter_list|,
name|label
parameter_list|)
value|((short) offsetof(s, label)),
end_define

begin_define
define|#
directive|define
name|SYM_GEN_B
parameter_list|(
name|s
parameter_list|,
name|label
parameter_list|)
value|((short) offsetof(s, label)),
end_define

begin_define
define|#
directive|define
name|PADDR_A
parameter_list|(
name|label
parameter_list|)
value|SYM_GEN_PADDR_A(struct SYM_FWA_SCR, label)
end_define

begin_define
define|#
directive|define
name|PADDR_B
parameter_list|(
name|label
parameter_list|)
value|SYM_GEN_PADDR_B(struct SYM_FWB_SCR, label)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_GENERIC_SUPPORT
end_ifdef

begin_comment
comment|/*  *  Allocate firmware #1 script area.  */
end_comment

begin_define
define|#
directive|define
name|SYM_FWA_SCR
value|sym_fw1a_scr
end_define

begin_define
define|#
directive|define
name|SYM_FWB_SCR
value|sym_fw1b_scr
end_define

begin_include
include|#
directive|include
file|<dev/sym/sym_fw1.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sym_fwa_ofs
name|sym_fw1a_ofs
init|=
block|{
name|SYM_GEN_FW_A
argument_list|(
argument|struct SYM_FWA_SCR
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sym_fwb_ofs
name|sym_fw1b_ofs
init|=
block|{
name|SYM_GEN_FW_B
argument_list|(
argument|struct SYM_FWB_SCR
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|SYM_FWA_SCR
end_undef

begin_undef
undef|#
directive|undef
name|SYM_FWB_SCR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYM_CONF_GENERIC_SUPPORT */
end_comment

begin_comment
comment|/*  *  Allocate firmware #2 script area.  */
end_comment

begin_define
define|#
directive|define
name|SYM_FWA_SCR
value|sym_fw2a_scr
end_define

begin_define
define|#
directive|define
name|SYM_FWB_SCR
value|sym_fw2b_scr
end_define

begin_include
include|#
directive|include
file|<dev/sym/sym_fw2.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sym_fwa_ofs
name|sym_fw2a_ofs
init|=
block|{
name|SYM_GEN_FW_A
argument_list|(
argument|struct SYM_FWA_SCR
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sym_fwb_ofs
name|sym_fw2b_ofs
init|=
block|{
name|SYM_GEN_FW_B
argument_list|(
argument|struct SYM_FWB_SCR
argument_list|)
name|SYM_GEN_B
argument_list|(
argument|struct SYM_FWB_SCR
argument_list|,
argument|start64
argument_list|)
name|SYM_GEN_B
argument_list|(
argument|struct SYM_FWB_SCR
argument_list|,
argument|pm_handle
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|SYM_FWA_SCR
end_undef

begin_undef
undef|#
directive|undef
name|SYM_FWB_SCR
end_undef

begin_undef
undef|#
directive|undef
name|SYM_GEN_A
end_undef

begin_undef
undef|#
directive|undef
name|SYM_GEN_B
end_undef

begin_undef
undef|#
directive|undef
name|PADDR_A
end_undef

begin_undef
undef|#
directive|undef
name|PADDR_B
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_GENERIC_SUPPORT
end_ifdef

begin_comment
comment|/*  *  Patch routine for firmware #1.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw1_patch
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|struct
name|sym_fw1a_scr
modifier|*
name|scripta0
decl_stmt|;
name|struct
name|sym_fw1b_scr
modifier|*
name|scriptb0
decl_stmt|;
name|scripta0
operator|=
operator|(
expr|struct
name|sym_fw1a_scr
operator|*
operator|)
name|np
operator|->
name|scripta0
expr_stmt|;
name|scriptb0
operator|=
operator|(
expr|struct
name|sym_fw1b_scr
operator|*
operator|)
name|np
operator|->
name|scriptb0
expr_stmt|;
comment|/* 	 *  Remove LED support if not needed. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
operator|)
condition|)
block|{
name|scripta0
operator|->
name|idle
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|reselected
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *    If user does not want to use IMMEDIATE ARBITRATION 	 *    when we are reselected while attempting to arbitrate, 	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP. 	 */
if|if
condition|(
operator|!
name|SYM_CONF_SET_IARB_ON_ARB_LOST
condition|)
name|scripta0
operator|->
name|ungetjob
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Patch some data in SCRIPTS. 	 *  - start and done queue initial bus address. 	 *  - target bus address table bus address. 	 */
name|scriptb0
operator|->
name|startpos
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|squeue_ba
argument_list|)
expr_stmt|;
name|scriptb0
operator|->
name|done_pos
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|dqueue_ba
argument_list|)
expr_stmt|;
name|scriptb0
operator|->
name|targtbl
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|targtbl_ba
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYM_CONF_GENERIC_SUPPORT */
end_comment

begin_comment
comment|/*  *  Patch routine for firmware #2.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw2_patch
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|struct
name|sym_fw2a_scr
modifier|*
name|scripta0
decl_stmt|;
name|struct
name|sym_fw2b_scr
modifier|*
name|scriptb0
decl_stmt|;
name|scripta0
operator|=
operator|(
expr|struct
name|sym_fw2a_scr
operator|*
operator|)
name|np
operator|->
name|scripta0
expr_stmt|;
name|scriptb0
operator|=
operator|(
expr|struct
name|sym_fw2b_scr
operator|*
operator|)
name|np
operator|->
name|scriptb0
expr_stmt|;
comment|/* 	 *  Remove LED support if not needed. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
operator|)
condition|)
block|{
name|scripta0
operator|->
name|idle
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|reselected
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|start
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *    If user does not want to use IMMEDIATE ARBITRATION 	 *    when we are reselected while attempting to arbitrate, 	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP. 	 */
if|if
condition|(
operator|!
name|SYM_CONF_SET_IARB_ON_ARB_LOST
condition|)
name|scripta0
operator|->
name|ungetjob
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Patch some variable in SCRIPTS. 	 *  - start and done queue initial bus address. 	 *  - target bus address table bus address. 	 */
name|scriptb0
operator|->
name|startpos
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|squeue_ba
argument_list|)
expr_stmt|;
name|scriptb0
operator|->
name|done_pos
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|dqueue_ba
argument_list|)
expr_stmt|;
name|scriptb0
operator|->
name|targtbl
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|targtbl_ba
argument_list|)
expr_stmt|;
comment|/* 	 *  Remove the load of SCNTL4 on reselection if not a C10. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
block|{
name|scripta0
operator|->
name|resel_scntl4
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|resel_scntl4
index|[
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Remove a couple of work-arounds specific to C1010 if 	 *  they are not desirable. See `sym_fw2.h' for more details. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010_2
operator|&&
name|np
operator|->
name|revision_id
operator|<
literal|0x1
operator|&&
name|np
operator|->
name|pciclk_khz
operator|<
literal|60000
operator|)
condition|)
block|{
name|scripta0
operator|->
name|datao_phase
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|datao_phase
index|[
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010
operator|&&
comment|/* np->revision_id< 0xff */
literal|1
operator|)
condition|)
block|{
name|scripta0
operator|->
name|sel_done
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|SCR_NO_OP
argument_list|)
expr_stmt|;
name|scripta0
operator|->
name|sel_done
index|[
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Patch some other variables in SCRIPTS. 	 *  These ones are loaded by the SCRIPTS processor. 	 */
name|scriptb0
operator|->
name|pm0_data_addr
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|scripta_ba
operator|+
name|offsetof
argument_list|(
expr|struct
name|sym_fw2a_scr
argument_list|,
name|pm0_data
argument_list|)
argument_list|)
expr_stmt|;
name|scriptb0
operator|->
name|pm1_data_addr
index|[
literal|0
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|scripta_ba
operator|+
name|offsetof
argument_list|(
expr|struct
name|sym_fw2a_scr
argument_list|,
name|pm1_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Fill the data area in scripts.  *  To be done for all firmwares.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw_fill_data
parameter_list|(
name|u32
modifier|*
name|in
parameter_list|,
name|u32
modifier|*
name|out
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_SG
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|in
operator|++
operator|=
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_IN
expr_stmt|;
operator|*
name|in
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|SCR_CHMOV_TBL
operator|^
name|SCR_DATA_OUT
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|offsetof
argument_list|(
expr|struct
name|sym_dsb
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Setup useful script bus addresses.  *  To be done for all firmwares.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw_setup_bus_addresses
parameter_list|(
name|hcb_p
name|np
parameter_list|,
specifier|const
name|struct
name|sym_fw
modifier|*
name|fw
parameter_list|)
block|{
name|u32
modifier|*
name|pa
decl_stmt|;
specifier|const
name|u_short
modifier|*
name|po
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  Build the bus address table for script A 	 *  from the script A offset table. 	 */
name|po
operator|=
operator|(
specifier|const
name|u_short
operator|*
operator|)
name|fw
operator|->
name|a_ofs
expr_stmt|;
name|pa
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|np
operator|->
name|fwa_bas
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|np
operator|->
name|fwa_bas
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|i
operator|++
control|)
name|pa
index|[
name|i
index|]
operator|=
name|np
operator|->
name|scripta_ba
operator|+
name|po
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 *  Same for script B. 	 */
name|po
operator|=
operator|(
specifier|const
name|u_short
operator|*
operator|)
name|fw
operator|->
name|b_ofs
expr_stmt|;
name|pa
operator|=
operator|(
name|u32
operator|*
operator|)
operator|&
name|np
operator|->
name|fwb_bas
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|np
operator|->
name|fwb_bas
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
condition|;
name|i
operator|++
control|)
name|pa
index|[
name|i
index|]
operator|=
name|np
operator|->
name|scriptb_ba
operator|+
name|po
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_GENERIC_SUPPORT
end_ifdef

begin_comment
comment|/*  *  Setup routine for firmware #1.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw1_setup
parameter_list|(
name|hcb_p
name|np
parameter_list|,
specifier|const
name|struct
name|sym_fw
modifier|*
name|fw
parameter_list|)
block|{
name|struct
name|sym_fw1a_scr
modifier|*
name|scripta0
decl_stmt|;
name|scripta0
operator|=
operator|(
expr|struct
name|sym_fw1a_scr
operator|*
operator|)
name|np
operator|->
name|scripta0
expr_stmt|;
comment|/* 	 *  Fill variable parts in scripts. 	 */
name|sym_fw_fill_data
argument_list|(
name|scripta0
operator|->
name|data_in
argument_list|,
name|scripta0
operator|->
name|data_out
argument_list|)
expr_stmt|;
comment|/* 	 *  Setup bus addresses used from the C code.. 	 */
name|sym_fw_setup_bus_addresses
argument_list|(
name|np
argument_list|,
name|fw
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYM_CONF_GENERIC_SUPPORT */
end_comment

begin_comment
comment|/*  *  Setup routine for firmware #2.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw2_setup
parameter_list|(
name|hcb_p
name|np
parameter_list|,
specifier|const
name|struct
name|sym_fw
modifier|*
name|fw
parameter_list|)
block|{
name|struct
name|sym_fw2a_scr
modifier|*
name|scripta0
decl_stmt|;
name|scripta0
operator|=
operator|(
expr|struct
name|sym_fw2a_scr
operator|*
operator|)
name|np
operator|->
name|scripta0
expr_stmt|;
comment|/* 	 *  Fill variable parts in scripts. 	 */
name|sym_fw_fill_data
argument_list|(
name|scripta0
operator|->
name|data_in
argument_list|,
name|scripta0
operator|->
name|data_out
argument_list|)
expr_stmt|;
comment|/* 	 *  Setup bus addresses used from the C code.. 	 */
name|sym_fw_setup_bus_addresses
argument_list|(
name|np
argument_list|,
name|fw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Allocate firmware descriptors.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYM_CONF_GENERIC_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sym_fw
name|sym_fw1
init|=
name|SYM_FW_ENTRY
argument_list|(
name|sym_fw1
argument_list|,
literal|"NCR-generic"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYM_CONF_GENERIC_SUPPORT */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sym_fw
name|sym_fw2
init|=
name|SYM_FW_ENTRY
argument_list|(
name|sym_fw2
argument_list|,
literal|"LOAD/STORE-based"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Find the most appropriate firmware for a chip.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|sym_fw
modifier|*
name|sym_find_firmware
parameter_list|(
specifier|const
name|struct
name|sym_pci_chip
modifier|*
name|chip
parameter_list|)
block|{
if|if
condition|(
name|chip
operator|->
name|features
operator|&
name|FE_LDSTR
condition|)
return|return
operator|&
name|sym_fw2
return|;
ifdef|#
directive|ifdef
name|SYM_CONF_GENERIC_SUPPORT
elseif|else
if|if
condition|(
operator|!
operator|(
name|chip
operator|->
name|features
operator|&
operator|(
name|FE_PFEN
operator||
name|FE_NOPM
operator||
name|FE_DAC
operator|)
operator|)
condition|)
return|return
operator|&
name|sym_fw1
return|;
endif|#
directive|endif
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  Bind a script to physical addresses.  */
end_comment

begin_function
specifier|static
name|void
name|sym_fw_bind_script
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u32
modifier|*
name|start
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u32
name|opcode
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|u32
modifier|*
name|end
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|int
name|relocs
decl_stmt|;
name|cur
operator|=
name|start
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|len
operator|/
literal|4
expr_stmt|;
while|while
condition|(
name|cur
operator|<
name|end
condition|)
block|{
name|opcode
operator|=
operator|*
name|cur
expr_stmt|;
comment|/* 		 *  If we forget to change the length 		 *  in scripts, a field will be 		 *  padded with 0. This is an illegal 		 *  command. 		 */
if|if
condition|(
name|opcode
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR0 IN SCRIPT at %d.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cur
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|MDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
operator|++
name|cur
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
comment|/* 		 *  We use the bogus value 0xf00ff00f ;-) 		 *  to reserve data area in SCRIPTS. 		 */
if|if
condition|(
name|opcode
operator|==
name|SCR_DATA_ZERO
condition|)
block|{
operator|*
name|cur
operator|++
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCRIPT
condition|)
name|printf
argument_list|(
literal|"%d:<%x>\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cur
operator|-
name|start
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|opcode
argument_list|)
expr_stmt|;
comment|/* 		 *  We don't have to decode ALL commands 		 */
switch|switch
condition|(
name|opcode
operator|>>
literal|28
condition|)
block|{
case|case
literal|0xf
case|:
comment|/* 			 *  LOAD / STORE DSA relative, don't relocate. 			 */
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/* 			 *  LOAD / STORE absolute. 			 */
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/* 			 *  COPY has TWO arguments. 			 */
name|relocs
operator|=
literal|2
expr_stmt|;
name|tmp1
operator|=
name|cur
index|[
literal|1
index|]
expr_stmt|;
name|tmp2
operator|=
name|cur
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tmp1
operator|^
name|tmp2
operator|)
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ERROR1 IN SCRIPT at %d.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cur
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|MDELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/* 			 *  If PREFETCH feature not enabled, remove 			 *  the NO FLUSH bit if present. 			 */
if|if
condition|(
operator|(
name|opcode
operator|&
name|SCR_NO_FLUSH
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
condition|)
block|{
name|opcode
operator|=
operator|(
name|opcode
operator|&
operator|~
name|SCR_NO_FLUSH
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x0
case|:
comment|/* 			 *  MOVE/CHMOV (absolute address) 			 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|)
name|opcode
operator|=
operator|(
name|opcode
operator||
name|OPC_MOVE
operator|)
expr_stmt|;
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/* 			 *  MOVE/CHMOV (table indirect) 			 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|)
name|opcode
operator|=
operator|(
name|opcode
operator||
name|OPC_MOVE
operator|)
expr_stmt|;
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
comment|/* 			 *  JUMP / CALL 			 *  dont't relocate if relative :-) 			 */
if|if
condition|(
name|opcode
operator|&
literal|0x00800000
condition|)
name|relocs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|opcode
operator|&
literal|0xf8400000
operator|)
operator|==
literal|0x80400000
condition|)
comment|/*JUMP64*/
name|relocs
operator|=
literal|2
expr_stmt|;
else|else
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
name|relocs
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|relocs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
empty_stmt|;
comment|/* 		 *  Scriptify:) the opcode. 		 */
operator|*
name|cur
operator|++
operator|=
name|cpu_to_scr
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
comment|/* 		 *  If no relocation, assume 1 argument 		 *  and just scriptize:) it. 		 */
if|if
condition|(
operator|!
name|relocs
condition|)
block|{
operator|*
name|cur
operator|=
name|cpu_to_scr
argument_list|(
operator|*
name|cur
argument_list|)
expr_stmt|;
operator|++
name|cur
expr_stmt|;
continue|continue;
block|}
comment|/* 		 *  Otherwise performs all needed relocations. 		 */
while|while
condition|(
name|relocs
operator|--
condition|)
block|{
name|old
operator|=
operator|*
name|cur
expr_stmt|;
switch|switch
condition|(
name|old
operator|&
name|RELOC_MASK
condition|)
block|{
case|case
name|RELOC_REGISTER
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|mmio_ba
expr_stmt|;
break|break;
case|case
name|RELOC_LABEL_A
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|scripta_ba
expr_stmt|;
break|break;
case|case
name|RELOC_LABEL_B
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|scriptb_ba
expr_stmt|;
break|break;
case|case
name|RELOC_SOFTC
case|:
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|RELOC_MASK
operator|)
operator|+
name|np
operator|->
name|hcb_ba
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 				 *  Don't relocate a 0 address. 				 *  They are mostly used for patched or 				 *  script self-modified areas. 				 */
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|new
operator|=
name|old
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|new
operator|=
literal|0
expr_stmt|;
name|panic
argument_list|(
literal|"sym_fw_bind_script: "
literal|"weird relocation %x\n"
argument_list|,
name|old
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|cur
operator|++
operator|=
name|cpu_to_scr
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*--------------------------- END OF FIRMWARES  -----------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *  Function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|void
name|sym_save_initial_setting
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_prepare_setting
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_prepare_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|nego
parameter_list|,
name|u_char
modifier|*
name|msgptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_put_start_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_chip_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_soft_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_start_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_reset_scsi_bus
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|enab_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_wakeup_done
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_flush_busy_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_flush_comp_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_init
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|reason
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_getsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|sfac
parameter_list|,
name|u_char
modifier|*
name|divp
parameter_list|,
name|u_char
modifier|*
name|fakp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setwide
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setpprot
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_settrans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_log_hard_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|,
name|u_char
name|dstat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_recover_scsi_int
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|hsts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_sto
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_udc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_sbmc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_par
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_ma
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_dequeue_from_squeue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_sir_bad_scsi_status
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_clear_tasks
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|targ
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_sir_task_recovery
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_evaluate_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u32
name|scr
parameter_list|,
name|int
modifier|*
name|ofs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_modify_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|ofs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_compute_residual
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_print_msg
parameter_list|(
name|ccb_p
name|cp
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_sync_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_ppr_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_wide_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nego_default
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nego_rejected
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_int_sir
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_free_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|sym_get_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|,
name|u_char
name|tag_order
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|sym_alloc_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ccb_p
name|sym_ccb_from_dsa
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u32
name|dsa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|lcb_p
name|sym_alloc_lcb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_alloc_lcb_tags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_snooptest
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_selectclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|scntl3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_getclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|mult
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_getpciclock
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_complete_ok
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_complete_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_abort_scsiio
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|timed_out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_reset_dev
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_setup_cdb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_setup_data_and_start
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_fast_scatter_sg_physical
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|psegs
parameter_list|,
name|int
name|nsegs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_scatter_sg_physical
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|psegs
parameter_list|,
name|int
name|nsegs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_action2
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_update_trans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|struct
name|sym_trans
modifier|*
name|tip
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_update_dflags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|flags
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|sym_pci_chip
modifier|*
name|sym_find_pci_chip
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_pci_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_cam_attach
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_cam_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nvram_setup_host
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sym_nvram_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|targ
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sym_read_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  Print something which allows to retrieve the controller type,  *  unit, target, lun concerned by a kernel message.  */
end_comment

begin_function
specifier|static
name|void
name|PRINT_TARGET
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%d:"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PRINT_LUN
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s:%d:%d:"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PRINT_ADDR
parameter_list|(
name|ccb_p
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|&&
name|cp
operator|->
name|cam_ccb
condition|)
name|xpt_print_path
argument_list|(
name|cp
operator|->
name|cam_ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Take into account this ccb in the freeze count.  */
end_comment

begin_function
specifier|static
name|void
name|sym_freeze_cam_ccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFRZDIS
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Set the status field of a CAM CCB.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sym_set_cam_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|cam_status
name|status
parameter_list|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|status
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Get the status field of a CAM CCB.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|sym_get_cam_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
return|return
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
return|;
block|}
end_function

begin_comment
comment|/*  *  Enqueue a CAM CCB.  */
end_comment

begin_function
specifier|static
name|void
name|sym_enqueue_cam_ccb
parameter_list|(
name|ccb_p
name|cp
parameter_list|)
block|{
name|hcb_p
name|np
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cp
operator|->
name|arg
expr_stmt|;
name|assert
argument_list|(
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INPROG
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|cp
operator|->
name|ch
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|1000
argument_list|,
name|sym_callout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|sym_hcb_ptr
operator|=
name|np
expr_stmt|;
name|sym_insque_tail
argument_list|(
name|sym_qptr
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|sim_links
argument_list|)
argument_list|,
operator|&
name|np
operator|->
name|cam_ccbq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Complete a pending CAM CCB.  */
end_comment

begin_function
specifier|static
name|void
name|_sym_xpt_done
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: status=CAM_SIM_QUEUED"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DEV_QFREEZE
condition|)
name|sym_freeze_cam_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_xpt_done
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_SIM_QUEUED
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|cp
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sym_remque
argument_list|(
name|sym_qptr
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|sim_links
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_SIM_QUEUED
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|sym_hcb_ptr
operator|=
name|NULL
expr_stmt|;
block|}
name|_sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_xpt_done2
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|cam_status
parameter_list|)
block|{
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sym_set_cam_status
argument_list|(
name|ccb
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
name|_sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  SYMBIOS chip clock divisor table.  *  *  Divisors are multiplied by 10,000,000 in order to make  *  calculations more simple.  */
end_comment

begin_define
define|#
directive|define
name|_5M
value|5000000
end_define

begin_decl_stmt
specifier|static
specifier|const
name|u32
name|div_10M
index|[]
init|=
block|{
literal|2
operator|*
name|_5M
block|,
literal|3
operator|*
name|_5M
block|,
literal|4
operator|*
name|_5M
block|,
literal|6
operator|*
name|_5M
block|,
literal|8
operator|*
name|_5M
block|,
literal|12
operator|*
name|_5M
block|,
literal|16
operator|*
name|_5M
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  SYMBIOS chips allow burst lengths of 2, 4, 8, 16, 32, 64,  *  128 transfers. All chips support at least 16 transfers  *  bursts. The 825A, 875 and 895 chips support bursts of up  *  to 128 transfers and the 895A and 896 support bursts of up  *  to 64 transfers. All other chips support up to 16  *  transfers bursts.  *  *  For PCI 32 bit data transfers each transfer is a DWORD.  *  It is a QUADWORD (8 bytes) for PCI 64 bit data transfers.  *  *  We use log base 2 (burst length) as internal code, with  *  value 0 meaning "burst disabled".  */
end_comment

begin_comment
comment|/*  *  Burst length from burst code.  */
end_comment

begin_define
define|#
directive|define
name|burst_length
parameter_list|(
name|bc
parameter_list|)
value|(!(bc))? 0 : 1<< (bc)
end_define

begin_comment
comment|/*  *  Burst code from io register bits.  */
end_comment

begin_define
define|#
directive|define
name|burst_code
parameter_list|(
name|dmode
parameter_list|,
name|ctest4
parameter_list|,
name|ctest5
parameter_list|)
define|\
value|(ctest4)& 0x80? 0 : (((dmode)& 0xc0)>> 6) + ((ctest5)& 0x04) + 1
end_define

begin_comment
comment|/*  *  Set initial io register bits from burst code.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sym_init_burst
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|bc
parameter_list|)
block|{
name|np
operator|->
name|rv_ctest4
operator|&=
operator|~
literal|0x80
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator|&=
operator|~
operator|(
literal|0x3
operator|<<
literal|6
operator|)
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator|&=
operator|~
literal|0x4
expr_stmt|;
if|if
condition|(
operator|!
name|bc
condition|)
block|{
name|np
operator|->
name|rv_ctest4
operator||=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
operator|--
name|bc
expr_stmt|;
name|np
operator|->
name|rv_dmode
operator||=
operator|(
operator|(
name|bc
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|np
operator|->
name|rv_ctest5
operator||=
operator|(
name|bc
operator|&
literal|0x4
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out the list of targets that have some flag disabled by user.  */
end_comment

begin_function
specifier|static
name|void
name|sym_print_targets_flag
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|mask
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|np
operator|->
name|myaddr
condition|)
continue|continue;
if|if
condition|(
name|np
operator|->
name|target
index|[
name|i
index|]
operator|.
name|usrflags
operator|&
name|mask
condition|)
block|{
if|if
condition|(
operator|!
name|cnt
operator|++
condition|)
name|printf
argument_list|(
literal|"%s: %s disabled for targets"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
condition|)
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Save initial settings of some IO registers.  *  Assumed to have been set by BIOS.  *  We cannot reset the chip prior to reading the  *  IO registers, since informations will be lost.  *  Since the SCRIPTS processor may be running, this  *  is not safe on paper, but it seems to work quite  *  well. :)  */
end_comment

begin_function
specifier|static
name|void
name|sym_save_initial_setting
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|np
operator|->
name|sv_scntl0
operator|=
name|INB
argument_list|(
name|nc_scntl0
argument_list|)
operator|&
literal|0x0a
expr_stmt|;
name|np
operator|->
name|sv_scntl3
operator|=
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
operator|&
literal|0x07
expr_stmt|;
name|np
operator|->
name|sv_dmode
operator|=
name|INB
argument_list|(
name|nc_dmode
argument_list|)
operator|&
literal|0xce
expr_stmt|;
name|np
operator|->
name|sv_dcntl
operator|=
name|INB
argument_list|(
name|nc_dcntl
argument_list|)
operator|&
literal|0xa8
expr_stmt|;
name|np
operator|->
name|sv_ctest3
operator|=
name|INB
argument_list|(
name|nc_ctest3
argument_list|)
operator|&
literal|0x01
expr_stmt|;
name|np
operator|->
name|sv_ctest4
operator|=
name|INB
argument_list|(
name|nc_ctest4
argument_list|)
operator|&
literal|0x80
expr_stmt|;
name|np
operator|->
name|sv_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
name|np
operator|->
name|sv_stest1
operator|=
name|INB
argument_list|(
name|nc_stest1
argument_list|)
expr_stmt|;
name|np
operator|->
name|sv_stest2
operator|=
name|INB
argument_list|(
name|nc_stest2
argument_list|)
operator|&
literal|0x20
expr_stmt|;
name|np
operator|->
name|sv_stest4
operator|=
name|INB
argument_list|(
name|nc_stest4
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
comment|/* Always large DMA fifo + ultra3 */
name|np
operator|->
name|sv_scntl4
operator|=
name|INB
argument_list|(
name|nc_scntl4
argument_list|)
expr_stmt|;
name|np
operator|->
name|sv_ctest5
operator|=
name|INB
argument_list|(
name|nc_ctest5
argument_list|)
operator|&
literal|0x04
expr_stmt|;
block|}
else|else
name|np
operator|->
name|sv_ctest5
operator|=
name|INB
argument_list|(
name|nc_ctest5
argument_list|)
operator|&
literal|0x24
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Prepare io register values used by sym_init() according  *  to selected and supported features.  */
end_comment

begin_function
specifier|static
name|int
name|sym_prepare_setting
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|u_char
name|burst_max
decl_stmt|;
name|u32
name|period
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  Wide ? 	 */
name|np
operator|->
name|maxwide
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 *  Get the frequency of the chip's clock. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_QUAD
condition|)
name|np
operator|->
name|multiplier
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DBLR
condition|)
name|np
operator|->
name|multiplier
operator|=
literal|2
expr_stmt|;
else|else
name|np
operator|->
name|multiplier
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_CLK80
operator|)
condition|?
literal|80000
else|:
literal|40000
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|*=
name|np
operator|->
name|multiplier
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|clock_khz
operator|!=
literal|40000
condition|)
name|sym_getclock
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|multiplier
argument_list|)
expr_stmt|;
comment|/* 	 * Divisor to be used for async (timer pre-scaler). 	 */
name|i
operator|=
name|np
operator|->
name|clock_divn
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
literal|10ul
operator|*
name|SYM_CONF_MIN_ASYNC
operator|*
name|np
operator|->
name|clock_khz
operator|>
name|div_10M
index|[
name|i
index|]
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
name|np
operator|->
name|rv_scntl3
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 * The C1010 uses hardwired divisors for async. 	 * So, we just throw away, the async. divisor.:-) 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
name|np
operator|->
name|rv_scntl3
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Minimum synchronous period factor supported by the chip. 	 * Btw, 'period' is in tenths of nanoseconds. 	 */
name|period
operator|=
operator|(
literal|4
operator|*
name|div_10M
index|[
literal|0
index|]
operator|+
name|np
operator|->
name|clock_khz
operator|-
literal|1
operator|)
operator|/
name|np
operator|->
name|clock_khz
expr_stmt|;
if|if
condition|(
name|period
operator|<=
literal|250
condition|)
name|np
operator|->
name|minsync
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
literal|303
condition|)
name|np
operator|->
name|minsync
operator|=
literal|11
expr_stmt|;
elseif|else
if|if
condition|(
name|period
operator|<=
literal|500
condition|)
name|np
operator|->
name|minsync
operator|=
literal|12
expr_stmt|;
else|else
name|np
operator|->
name|minsync
operator|=
operator|(
name|period
operator|+
literal|40
operator|-
literal|1
operator|)
operator|/
literal|40
expr_stmt|;
comment|/* 	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2). 	 */
if|if
condition|(
name|np
operator|->
name|minsync
operator|<
literal|25
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA
operator||
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
operator|)
condition|)
name|np
operator|->
name|minsync
operator|=
literal|25
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|minsync
operator|<
literal|12
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
operator|)
condition|)
name|np
operator|->
name|minsync
operator|=
literal|12
expr_stmt|;
comment|/* 	 * Maximum synchronous period factor supported by the chip. 	 */
name|period
operator|=
operator|(
literal|11
operator|*
name|div_10M
index|[
name|np
operator|->
name|clock_divn
operator|-
literal|1
index|]
operator|)
operator|/
operator|(
literal|4
operator|*
name|np
operator|->
name|clock_khz
operator|)
expr_stmt|;
name|np
operator|->
name|maxsync
operator|=
name|period
operator|>
literal|2540
condition|?
literal|254
else|:
name|period
operator|/
literal|10
expr_stmt|;
comment|/* 	 * If chip is a C1010, guess the sync limits in DT mode. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_ULTRA3
operator|)
operator|)
operator|==
operator|(
name|FE_C10
operator||
name|FE_ULTRA3
operator|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|clock_khz
operator|==
literal|160000
condition|)
block|{
name|np
operator|->
name|minsync_dt
operator|=
literal|9
expr_stmt|;
name|np
operator|->
name|maxsync_dt
operator|=
literal|50
expr_stmt|;
name|np
operator|->
name|maxoffs_dt
operator|=
literal|62
expr_stmt|;
block|}
block|}
comment|/* 	 *  64 bit addressing  (895A/896/1010) ? 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DAC
condition|)
ifdef|#
directive|ifdef
name|__LP64__
name|np
operator|->
name|rv_ccntl1
operator||=
operator|(
name|XTIMOD
operator||
name|EXTIBMV
operator|)
expr_stmt|;
else|#
directive|else
name|np
operator|->
name|rv_ccntl1
operator||=
operator|(
name|DDAC
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Phase mismatch handled by SCRIPTS (895A/896/1010) ?   	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_NOPM
condition|)
name|np
operator|->
name|rv_ccntl0
operator||=
operator|(
name|ENPMJ
operator|)
expr_stmt|;
comment|/* 	 *  C1010 Errata. 	 *  In dual channel mode, contention occurs if internal cycles 	 *  are used. Disable internal cycles. 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010
operator|&&
name|np
operator|->
name|revision_id
operator|<
literal|0x2
condition|)
name|np
operator|->
name|rv_ccntl0
operator||=
name|DILS
expr_stmt|;
comment|/* 	 *  Select burst length (dwords) 	 */
name|burst_max
operator|=
name|SYM_SETUP_BURST_ORDER
expr_stmt|;
if|if
condition|(
name|burst_max
operator|==
literal|255
condition|)
name|burst_max
operator|=
name|burst_code
argument_list|(
name|np
operator|->
name|sv_dmode
argument_list|,
name|np
operator|->
name|sv_ctest4
argument_list|,
name|np
operator|->
name|sv_ctest5
argument_list|)
expr_stmt|;
if|if
condition|(
name|burst_max
operator|>
literal|7
condition|)
name|burst_max
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|burst_max
operator|>
name|np
operator|->
name|maxburst
condition|)
name|burst_max
operator|=
name|np
operator|->
name|maxburst
expr_stmt|;
comment|/* 	 *  DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2. 	 *  This chip and the 860 Rev 1 may wrongly use PCI cache line 	 *  based transactions on LOAD/STORE instructions. So we have 	 *  to prevent these chips from using such PCI transactions in 	 *  this driver. The generic ncr driver that does not use 	 *  LOAD/STORE instructions does not need this work-around. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C810
operator|&&
name|np
operator|->
name|revision_id
operator|>=
literal|0x10
operator|&&
name|np
operator|->
name|revision_id
operator|<=
literal|0x11
operator|)
operator|||
operator|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C860
operator|&&
name|np
operator|->
name|revision_id
operator|<=
literal|0x1
operator|)
condition|)
name|np
operator|->
name|features
operator|&=
operator|~
operator|(
name|FE_WRIE
operator||
name|FE_ERL
operator||
name|FE_ERMP
operator|)
expr_stmt|;
comment|/* 	 *  Select all supported special features. 	 *  If we are using on-board RAM for scripts, prefetch (PFEN) 	 *  does not help, but burst op fetch (BOF) does. 	 *  Disabling PFEN makes sure BOF will be used. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ERL
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|ERL
expr_stmt|;
comment|/* Enable Read Line */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_BOF
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|BOF
expr_stmt|;
comment|/* Burst Opcode Fetch */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ERMP
condition|)
name|np
operator|->
name|rv_dmode
operator||=
name|ERMP
expr_stmt|;
comment|/* Enable Read Multiple */
if|#
directive|if
literal|1
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
operator|)
operator|&&
operator|!
name|np
operator|->
name|ram_ba
condition|)
else|#
directive|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_PFEN
condition|)
endif|#
directive|endif
name|np
operator|->
name|rv_dcntl
operator||=
name|PFEN
expr_stmt|;
comment|/* Prefetch Enable */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_CLSE
condition|)
name|np
operator|->
name|rv_dcntl
operator||=
name|CLSE
expr_stmt|;
comment|/* Cache Line Size Enable */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_WRIE
condition|)
name|np
operator|->
name|rv_ctest3
operator||=
name|WRIE
expr_stmt|;
comment|/* Write and Invalidate */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DFS
condition|)
name|np
operator|->
name|rv_ctest5
operator||=
name|DFS
expr_stmt|;
comment|/* Dma Fifo Size */
comment|/* 	 *  Select some other 	 */
if|if
condition|(
name|SYM_SETUP_PCI_PARITY
condition|)
name|np
operator|->
name|rv_ctest4
operator||=
name|MPEE
expr_stmt|;
comment|/* Master parity checking */
if|if
condition|(
name|SYM_SETUP_SCSI_PARITY
condition|)
name|np
operator|->
name|rv_scntl0
operator||=
literal|0x0a
expr_stmt|;
comment|/*  full arb., ena parity, par->ATN  */
comment|/* 	 *  Get parity checking, host ID and verbose mode from NVRAM 	 */
name|np
operator|->
name|myaddr
operator|=
literal|255
expr_stmt|;
name|sym_nvram_setup_host
argument_list|(
name|np
argument_list|,
name|nvram
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__sparc64__
name|np
operator|->
name|myaddr
operator|=
name|OF_getscsinitid
argument_list|(
name|np
operator|->
name|device
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Get SCSI addr of host adapter (set by bios?). 	 */
if|if
condition|(
name|np
operator|->
name|myaddr
operator|==
literal|255
condition|)
block|{
name|np
operator|->
name|myaddr
operator|=
name|INB
argument_list|(
name|nc_scid
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|myaddr
condition|)
name|np
operator|->
name|myaddr
operator|=
name|SYM_SETUP_HOST_ID
expr_stmt|;
block|}
comment|/* 	 *  Prepare initial io register bits for burst length 	 */
name|sym_init_burst
argument_list|(
name|np
argument_list|,
name|burst_max
argument_list|)
expr_stmt|;
comment|/* 	 *  Set SCSI BUS mode. 	 *  - LVD capable chips (895/895A/896/1010) report the 	 *    current BUS mode through the STEST4 IO register. 	 *  - For previous generation chips (825/825A/875), 	 *    user has to tell us how to check against HVD, 	 *    since a 100% safe algorithm is not possible. 	 */
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_SE
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
condition|)
name|np
operator|->
name|scsi_mode
operator|=
operator|(
name|np
operator|->
name|sv_stest4
operator|&
name|SMODE
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DIFF
condition|)
block|{
if|if
condition|(
name|SYM_SETUP_SCSI_DIFF
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|sv_scntl3
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|sv_stest2
operator|&
literal|0x20
condition|)
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_HVD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvram
operator|->
name|type
operator|==
name|SYM_SYMBIOS_NVRAM
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_HVD
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SYM_SETUP_SCSI_DIFF
operator|==
literal|2
condition|)
name|np
operator|->
name|scsi_mode
operator|=
name|SMODE_HVD
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|scsi_mode
operator|==
name|SMODE_HVD
condition|)
name|np
operator|->
name|rv_stest2
operator||=
literal|0x20
expr_stmt|;
comment|/* 	 *  Set LED support from SCRIPTS. 	 *  Ignore this feature for boards known to use a 	 *  specific GPIO wiring and for the 895A, 896 	 *  and 1010 that drive the LED directly. 	 */
if|if
condition|(
operator|(
name|SYM_SETUP_SCSI_LED
operator|||
operator|(
name|nvram
operator|->
name|type
operator|==
name|SYM_SYMBIOS_NVRAM
operator|||
operator|(
name|nvram
operator|->
name|type
operator|==
name|SYM_TEKRAM_NVRAM
operator|&&
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C895
operator|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_LEDC
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|sv_gpcntl
operator|&
literal|0x01
operator|)
condition|)
name|np
operator|->
name|features
operator||=
name|FE_LED0
expr_stmt|;
comment|/* 	 *  Set irq mode. 	 */
switch|switch
condition|(
name|SYM_SETUP_IRQ_MODE
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
name|np
operator|->
name|rv_dcntl
operator||=
name|IRQM
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|np
operator|->
name|rv_dcntl
operator||=
operator|(
name|np
operator|->
name|sv_dcntl
operator|&
name|IRQM
operator|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 *  Configure targets according to driver setup. 	 *  If NVRAM present get targets setup from NVRAM. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|scsi_version
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|scsi_version
operator|=
literal|2
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|spi_version
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|spi_version
operator|=
literal|2
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|np
operator|->
name|minsync_dt
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|np
operator|->
name|maxwide
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|usrflags
operator||=
operator|(
name|SYM_DISC_ENABLED
operator||
name|SYM_TAGS_ENABLED
operator|)
expr_stmt|;
name|tp
operator|->
name|usrtags
operator|=
name|SYM_SETUP_MAX_TAG
expr_stmt|;
name|sym_nvram_setup_target
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|nvram
argument_list|)
expr_stmt|;
comment|/* 		 *  For now, guess PPR/DT support from the period 		 *  and BUS width. 		 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|<=
literal|9
operator|&&
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|==
name|BUS_16_BIT
condition|)
block|{
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|options
operator||=
name|PPR_OPT_DT
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
name|np
operator|->
name|maxoffs_dt
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|spi_version
operator|=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|usrtags
condition|)
name|tp
operator|->
name|usrflags
operator|&=
operator|~
name|SYM_TAGS_ENABLED
expr_stmt|;
block|}
comment|/* 	 *  Let user know about the settings. 	 */
name|i
operator|=
name|nvram
operator|->
name|type
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s NVRAM, ID %d, Fast-%d, %s, %s\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
operator|==
name|SYM_SYMBIOS_NVRAM
condition|?
literal|"Symbios"
else|:
operator|(
name|i
operator|==
name|SYM_TEKRAM_NVRAM
condition|?
literal|"Tekram"
else|:
literal|"No"
operator|)
argument_list|,
name|np
operator|->
name|myaddr
argument_list|,
operator|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
operator|)
condition|?
literal|80
else|:
operator|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA2
operator|)
condition|?
literal|40
else|:
operator|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA
operator|)
condition|?
literal|20
else|:
literal|10
argument_list|,
name|sym_scsi_bus_mode
argument_list|(
name|np
operator|->
name|scsi_mode
argument_list|)
argument_list|,
operator|(
name|np
operator|->
name|rv_scntl0
operator|&
literal|0xa
operator|)
condition|?
literal|"parity checking"
else|:
literal|"NO parity"
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell him more on demand. 	 */
if|if
condition|(
name|sym_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s IRQ line driver%s\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|rv_dcntl
operator|&
name|IRQM
condition|?
literal|"totem pole"
else|:
literal|"open drain"
argument_list|,
name|np
operator|->
name|ram_ba
condition|?
literal|", using on-chip SRAM"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: using %s firmware.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|fw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_NOPM
condition|)
name|printf
argument_list|(
literal|"%s: handling phase mismatch from SCRIPTS.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  And still more. 	 */
if|if
condition|(
name|sym_verbose
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "
literal|"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|sv_scntl3
argument_list|,
name|np
operator|->
name|sv_dmode
argument_list|,
name|np
operator|->
name|sv_dcntl
argument_list|,
name|np
operator|->
name|sv_ctest3
argument_list|,
name|np
operator|->
name|sv_ctest4
argument_list|,
name|np
operator|->
name|sv_ctest5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "
literal|"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|,
name|np
operator|->
name|rv_dcntl
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Let user be aware of targets that have some disable flags set. 	 */
name|sym_print_targets_flag
argument_list|(
name|np
argument_list|,
name|SYM_SCAN_BOOT_DISABLED
argument_list|,
literal|"SCAN AT BOOT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_verbose
condition|)
name|sym_print_targets_flag
argument_list|(
name|np
argument_list|,
name|SYM_SCAN_LUNS_DISABLED
argument_list|,
literal|"SCAN FOR LUNS"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  Prepare the next negotiation message if needed.  *  *  Fill in the part of message buffer that contains the  *  negotiation and the nego_status field of the CCB.  *  Returns the size of the message in bytes.  */
end_comment

begin_function
specifier|static
name|int
name|sym_prepare_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|nego
parameter_list|,
name|u_char
modifier|*
name|msgptr
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|int
name|msglen
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Early C1010 chips need a work-around for DT 	 *  data transfer to work. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
operator|)
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  negotiate using PPR ? 	 */
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|&
name|PPR_OPT_MASK
condition|)
name|nego
operator|=
name|NS_PPR
expr_stmt|;
comment|/* 	 *  negotiate wide transfers ? 	 */
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
condition|)
name|nego
operator|=
name|NS_WIDE
expr_stmt|;
comment|/* 	 *  negotiate synchronous transfers? 	 */
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
condition|)
name|nego
operator|=
name|NS_SYNC
expr_stmt|;
switch|switch
condition|(
name|nego
condition|)
block|{
case|case
name|NS_SYNC
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|3
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|2
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_WIDE_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
expr_stmt|;
break|break;
case|case
name|NS_PPR
case|:
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|6
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|M_X_PPR_REQ
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|&
name|PPR_OPT_DT
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|nego
expr_stmt|;
if|if
condition|(
name|nego
condition|)
block|{
name|tp
operator|->
name|nego_cp
operator|=
name|cp
expr_stmt|;
comment|/* Keep track a nego will be performed */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
name|nego
operator|==
name|NS_SYNC
condition|?
literal|"sync msgout"
else|:
name|nego
operator|==
name|NS_WIDE
condition|?
literal|"wide msgout"
else|:
literal|"ppr msgout"
argument_list|,
name|msgptr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
name|msglen
return|;
block|}
end_function

begin_comment
comment|/*  *  Insert a job into the start queue.  */
end_comment

begin_function
specifier|static
name|void
name|sym_put_start_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_short
name|qidx
decl_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *  If the previously queued CCB is not yet done, 	 *  set the IARB hint. The SCRIPTS will go with IARB 	 *  for this job when starting the previous one. 	 *  We leave devices a chance to win arbitration by 	 *  not using more than 'iarb_max' consecutive 	 *  immediate arbitrations. 	 */
if|if
condition|(
name|np
operator|->
name|last_cp
operator|&&
name|np
operator|->
name|iarb_count
operator|<
name|np
operator|->
name|iarb_max
condition|)
block|{
name|np
operator|->
name|last_cp
operator|->
name|host_flags
operator||=
name|HF_HINT_IARB
expr_stmt|;
operator|++
name|np
operator|->
name|iarb_count
expr_stmt|;
block|}
else|else
name|np
operator|->
name|iarb_count
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|last_cp
operator|=
name|cp
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Insert first the idle task and then our job. 	 *  The MB should ensure proper ordering. 	 */
name|qidx
operator|=
name|np
operator|->
name|squeueput
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|qidx
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|qidx
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|qidx
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|idletask_ba
argument_list|)
expr_stmt|;
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|np
operator|->
name|squeueput
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeueput
operator|=
name|qidx
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_QUEUE
condition|)
name|printf
argument_list|(
literal|"%s: queuepos=%d.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|np
operator|->
name|squeueput
argument_list|)
expr_stmt|;
comment|/* 	 *  Script processor may be waiting for reselect. 	 *  Wake it up. 	 */
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
operator||
name|np
operator|->
name|istat_sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Soft reset the chip.  *  *  Raising SRST when the chip is running may cause  *  problems on dual function chips (see below).  *  On the other hand, LVD devices need some delay  *  to settle and report actual BUS mode in STEST4.  */
end_comment

begin_function
specifier|static
name|void
name|sym_chip_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SRST
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* For BUS MODE to settle */
block|}
end_function

begin_comment
comment|/*  *  Soft reset the chip.  *  *  Some 896 and 876 chip revisions may hang-up if we set  *  the SRST (soft reset) bit at the wrong time when SCRIPTS  *  are running.  *  So, we need to abort the current operation prior to  *  soft resetting the chip.  */
end_comment

begin_function
specifier|static
name|void
name|sym_soft_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|istat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|CABRT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|&
name|SIP
condition|)
block|{
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|istat
operator|&
name|DIP
condition|)
block|{
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INB
argument_list|(
name|nc_dstat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|i
condition|)
name|printf
argument_list|(
literal|"%s: unable to abort current chip operation.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|sym_chip_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Start reset process.  *  *  The interrupt handler will reinitialize the chip.  */
end_comment

begin_function
specifier|static
name|void
name|sym_start_reset
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sym_reset_scsi_bus
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sym_reset_scsi_bus
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|enab_int
parameter_list|)
block|{
name|u32
name|term
decl_stmt|;
name|int
name|retv
init|=
literal|0
decl_stmt|;
name|sym_soft_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* Soft reset the chip */
if|if
condition|(
name|enab_int
condition|)
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
name|RST
argument_list|)
expr_stmt|;
comment|/* 	 *  Enable Tolerant, reset IRQD if present and 	 *  properly set IRQ mode, prior to resetting the bus. 	 */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
operator|(
name|np
operator|->
name|rv_dcntl
operator|&
name|IRQM
operator|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
name|CRST
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SYM_SETUP_SCSI_BUS_CHECK
condition|)
goto|goto
name|out
goto|;
comment|/* 	 *  Check for no terminators or SCSI bus shorts to ground. 	 *  Read SCSI data bus, data parity bits and control signals. 	 *  We are expecting RESET to be TRUE and other signals to be 	 *  FALSE. 	 */
name|term
operator|=
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
expr_stmt|;
name|term
operator|=
operator|(
operator|(
name|term
operator|&
literal|2
operator|)
operator|<<
literal|7
operator|)
operator|+
operator|(
operator|(
name|term
operator|&
literal|1
operator|)
operator|<<
literal|17
operator|)
expr_stmt|;
comment|/* rst sdp0 */
name|term
operator||=
operator|(
operator|(
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
operator|&
literal|0x01
operator|)
operator|<<
literal|26
operator|)
operator||
comment|/* sdp1     */
operator|(
operator|(
name|INW
argument_list|(
name|nc_sbdl
argument_list|)
operator|&
literal|0xff
operator|)
operator|<<
literal|9
operator|)
operator||
comment|/* d7-0     */
operator|(
operator|(
name|INW
argument_list|(
name|nc_sbdl
argument_list|)
operator|&
literal|0xff00
operator|)
operator|<<
literal|10
operator|)
operator||
comment|/* d15-8    */
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
expr_stmt|;
comment|/* req ack bsy sel atn msg cd io    */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|)
name|term
operator|&=
literal|0x3ffff
expr_stmt|;
if|if
condition|(
name|term
operator|!=
operator|(
literal|2
operator|<<
literal|7
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: suspicious SCSI data while resetting the BUS.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = "
literal|"0x%lx, expecting 0x%lx\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|"dp1,d15-8,"
else|:
literal|""
argument_list|,
operator|(
name|u_long
operator|)
name|term
argument_list|,
call|(
name|u_long
call|)
argument_list|(
literal|2
operator|<<
literal|7
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYM_SETUP_SCSI_BUS_CHECK
operator|==
literal|1
condition|)
name|retv
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MDELAY(100); */
return|return
name|retv
return|;
block|}
end_function

begin_comment
comment|/*  *  The chip may have completed jobs. Look at the DONE QUEUE.  *  *  On architectures that may reorder LOAD/STORE operations,  *  a memory barrier may be needed after the reading of the  *  so-called `flag' and prior to dealing with the data.  */
end_comment

begin_function
specifier|static
name|int
name|sym_wakeup_done
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|ccb_p
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u32
name|dsa
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|np
operator|->
name|dqueueget
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|dsa
operator|=
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|dqueue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsa
condition|)
break|break;
name|np
operator|->
name|dqueue
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|i
operator|+
literal|2
operator|)
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
name|sym_complete_ok
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: bad DSA (%x) in done queue.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|dsa
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|dqueueget
operator|=
name|i
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  *  Complete all active CCBs with error.  *  Used on CHIP/SCSI RESET.  */
end_comment

begin_function
specifier|static
name|void
name|sym_flush_busy_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
block|{
comment|/* 	 *  Move all active CCBs to the COMP queue 	 *  and flush this queue. 	 */
name|sym_que_splice
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Start chip.  *  *  'reason' means:  *     0: initialisation.  *     1: SCSI BUS RESET delivered or received.  *     2: SCSI BUS MODE changed.  */
end_comment

begin_function
specifier|static
name|void
name|sym_init
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u32
name|phys
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Reset chip if asked, otherwise just clear fifos.  	 */
if|if
condition|(
name|reason
operator|==
literal|1
condition|)
name|sym_soft_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
else|else
block|{
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
name|OUTONB
argument_list|(
name|nc_ctest3
argument_list|,
name|CLF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Clear Start Queue 	 */
name|phys
operator|=
name|np
operator|->
name|squeue_ba
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_QUEUE
operator|*
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|np
operator|->
name|squeue
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|idletask_ba
argument_list|)
expr_stmt|;
name|np
operator|->
name|squeue
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
operator|+
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|squeue
index|[
name|MAX_QUEUE
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Start at first entry. 	 */
name|np
operator|->
name|squeueput
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Clear Done Queue 	 */
name|phys
operator|=
name|np
operator|->
name|dqueue_ba
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_QUEUE
operator|*
literal|2
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|np
operator|->
name|dqueue
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|dqueue
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
operator|+
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|dqueue
index|[
name|MAX_QUEUE
operator|*
literal|2
operator|-
literal|1
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Start at first entry. 	 */
name|np
operator|->
name|dqueueget
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Install patches in scripts. 	 *  This also let point to first position the start 	 *  and done queue pointers used from SCRIPTS. 	 */
name|np
operator|->
name|fw_patch
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* 	 *  Wakeup all pending jobs. 	 */
name|sym_flush_busy_queue
argument_list|(
name|np
argument_list|,
name|CAM_SCSI_BUS_RESET
argument_list|)
expr_stmt|;
comment|/* 	 *  Init chip. 	 */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  Remove Reset, abort */
name|UDELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* The 895 needs time for the bus mode to settle */
name|OUTB
argument_list|(
name|nc_scntl0
argument_list|,
name|np
operator|->
name|rv_scntl0
operator||
literal|0xc0
argument_list|)
expr_stmt|;
comment|/*  full arb., ena parity, par->ATN  */
name|OUTB
argument_list|(
name|nc_scntl1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*  odd parity, and remove CRST!! */
name|sym_selectclock
argument_list|(
name|np
argument_list|,
name|np
operator|->
name|rv_scntl3
argument_list|)
expr_stmt|;
comment|/* Select SCSI clock */
name|OUTB
argument_list|(
name|nc_scid
argument_list|,
name|RRE
operator||
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/* Adapter SCSI address */
name|OUTW
argument_list|(
name|nc_respid
argument_list|,
literal|1ul
operator|<<
name|np
operator|->
name|myaddr
argument_list|)
expr_stmt|;
comment|/* Id to respond to */
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
comment|/*  Signal Process */
name|OUTB
argument_list|(
name|nc_dmode
argument_list|,
name|np
operator|->
name|rv_dmode
argument_list|)
expr_stmt|;
comment|/* Burst length, dma mode */
name|OUTB
argument_list|(
name|nc_ctest5
argument_list|,
name|np
operator|->
name|rv_ctest5
argument_list|)
expr_stmt|;
comment|/* Large fifo + large burst */
name|OUTB
argument_list|(
name|nc_dcntl
argument_list|,
name|NOCOM
operator||
name|np
operator|->
name|rv_dcntl
argument_list|)
expr_stmt|;
comment|/* Protect SFBR */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
argument_list|)
expr_stmt|;
comment|/* Write and invalidate */
name|OUTB
argument_list|(
name|nc_ctest4
argument_list|,
name|np
operator|->
name|rv_ctest4
argument_list|)
expr_stmt|;
comment|/* Master parity checking */
comment|/* Extended Sreq/Sack filtering not supported on the C10 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
name|np
operator|->
name|rv_stest2
argument_list|)
expr_stmt|;
else|else
name|OUTB
argument_list|(
name|nc_stest2
argument_list|,
name|EXT
operator||
name|np
operator|->
name|rv_stest2
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
argument_list|)
expr_stmt|;
comment|/* TolerANT enable */
name|OUTB
argument_list|(
name|nc_stime0
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* HTH disabled  STO 0.25 sec */
comment|/* 	 *  For now, disable AIP generation on C1010-66. 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010_2
condition|)
name|OUTB
argument_list|(
name|nc_aipcntl1
argument_list|,
name|DISAIP
argument_list|)
expr_stmt|;
comment|/* 	 *  C10101 Errata. 	 *  Errant SGE's when in narrow. Write bits 4& 5 of 	 *  STEST1 register to disable SGE. We probably should do 	 *  that from SCRIPTS for each selection/reselection, but 	 *  I just don't want. :) 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_LSI53C1010
operator|&&
comment|/* np->revision_id< 0xff */
literal|1
condition|)
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|INB
argument_list|(
name|nc_stest1
argument_list|)
operator||
literal|0x30
argument_list|)
expr_stmt|;
comment|/* 	 *  DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2. 	 *  Disable overlapped arbitration for some dual function devices, 	 *  regardless revision id (kind of post-chip-design feature. ;-)) 	 */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C875
condition|)
name|OUTB
argument_list|(
name|nc_ctest0
argument_list|,
operator|(
literal|1
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C896
condition|)
name|np
operator|->
name|rv_ccntl0
operator||=
name|DPR
expr_stmt|;
comment|/* 	 *  Write CCNTL0/CCNTL1 for chips capable of 64 bit addressing 	 *  and/or hardware phase mismatch, since only such chips 	 *  seem to support those IO registers. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_DAC
operator||
name|FE_NOPM
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_ccntl0
argument_list|,
name|np
operator|->
name|rv_ccntl0
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_ccntl1
argument_list|,
name|np
operator|->
name|rv_ccntl1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If phase mismatch handled by scripts (895A/896/1010), 	 *  set PM jump addresses. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_NOPM
condition|)
block|{
name|OUTL
argument_list|(
name|nc_pmjad1
argument_list|,
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|pm_handle
argument_list|)
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_pmjad2
argument_list|,
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|pm_handle
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *    Enable GPIO0 pin for writing if LED support from SCRIPTS. 	 *    Also set GPIO5 and clear GPIO6 if hardware LED control. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LED0
condition|)
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
operator|&
operator|~
literal|0x01
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LEDC
condition|)
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|(
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
operator|&
operator|~
literal|0x41
operator|)
operator||
literal|0x20
argument_list|)
expr_stmt|;
comment|/* 	 *      enable ints 	 */
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
name|STO
operator||
name|HTH
operator||
name|MA
operator||
name|SGE
operator||
name|UDC
operator||
name|RST
operator||
name|PAR
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
name|MDPE
operator||
name|BF
operator||
name|SSI
operator||
name|SIR
operator||
name|IID
argument_list|)
expr_stmt|;
comment|/* 	 *  For 895/6 enable SBMC interrupt and save current SCSI bus mode. 	 *  Try to eat the spurious SBMC interrupt that may occur when 	 *  we reset the chip but not the SCSI BUS (at initialization). 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_ULTRA2
operator||
name|FE_ULTRA3
operator|)
condition|)
block|{
name|OUTONW
argument_list|(
name|nc_sien
argument_list|,
name|SBMC
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
literal|0
condition|)
block|{
name|MDELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|scsi_mode
operator|=
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|SMODE
expr_stmt|;
block|}
comment|/* 	 *  Fill in target structure. 	 *  Reinitialize usrsync. 	 *  Reinitialize usrwide. 	 *  Prepare sync negotiation according to actual SCSI bus mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|uval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  Download SCSI SCRIPTS to on-chip RAM if present, 	 *  and start script processor. 	 */
if|if
condition|(
name|np
operator|->
name|ram_ba
condition|)
block|{
if|if
condition|(
name|sym_verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s: Downloading SCSI SCRIPTS.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ram_ws
operator|==
literal|8192
condition|)
block|{
name|OUTRAM_OFF
argument_list|(
literal|4096
argument_list|,
name|np
operator|->
name|scriptb0
argument_list|,
name|np
operator|->
name|scriptb_sz
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_mmws
argument_list|,
name|np
operator|->
name|scr_ram_seg
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_mmrs
argument_list|,
name|np
operator|->
name|scr_ram_seg
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_sfs
argument_list|,
name|np
operator|->
name|scr_ram_seg
argument_list|)
expr_stmt|;
name|phys
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|start64
argument_list|)
expr_stmt|;
block|}
else|else
name|phys
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|OUTRAM_OFF
argument_list|(
literal|0
argument_list|,
name|np
operator|->
name|scripta0
argument_list|,
name|np
operator|->
name|scripta_sz
argument_list|)
expr_stmt|;
block|}
else|else
name|phys
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|np
operator|->
name|istat_sem
operator|=
literal|0
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|np
operator|->
name|hcb_ba
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|phys
argument_list|)
expr_stmt|;
comment|/* 	 *  Notify the XPT about the RESET condition. 	 */
if|if
condition|(
name|reason
operator|!=
literal|0
condition|)
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|np
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Get clock factor and sync divisor for a given  *  synchronous factor period.  */
end_comment

begin_function
specifier|static
name|int
name|sym_getsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|sfac
parameter_list|,
name|u_char
modifier|*
name|divp
parameter_list|,
name|u_char
modifier|*
name|fakp
parameter_list|)
block|{
name|u32
name|clk
init|=
name|np
operator|->
name|clock_khz
decl_stmt|;
comment|/* SCSI clock frequency in kHz	*/
name|int
name|div
init|=
name|np
operator|->
name|clock_divn
decl_stmt|;
comment|/* Number of divisors supported	*/
name|u32
name|fak
decl_stmt|;
comment|/* Sync factor in sxfer		*/
name|u32
name|per
decl_stmt|;
comment|/* Period in tenths of ns	*/
name|u32
name|kpc
decl_stmt|;
comment|/* (per * clk)			*/
name|int
name|ret
decl_stmt|;
comment|/* 	 *  Compute the synchronous period in tenths of nano-seconds 	 */
if|if
condition|(
name|dt
operator|&&
name|sfac
operator|<=
literal|9
condition|)
name|per
operator|=
literal|125
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|<=
literal|10
condition|)
name|per
operator|=
literal|250
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|==
literal|11
condition|)
name|per
operator|=
literal|303
expr_stmt|;
elseif|else
if|if
condition|(
name|sfac
operator|==
literal|12
condition|)
name|per
operator|=
literal|500
expr_stmt|;
else|else
name|per
operator|=
literal|40
operator|*
name|sfac
expr_stmt|;
name|ret
operator|=
name|per
expr_stmt|;
name|kpc
operator|=
name|per
operator|*
name|clk
expr_stmt|;
if|if
condition|(
name|dt
condition|)
name|kpc
operator|<<=
literal|1
expr_stmt|;
comment|/* 	 *  For earliest C10 revision 0, we cannot use extra 	 *  clocks for the setting of the SCSI clocking. 	 *  Note that this limits the lowest sync data transfer 	 *  to 5 Mega-transfers per second and may result in 	 *  using higher clock divisors. 	 */
if|#
directive|if
literal|1
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_U3EN
operator|)
operator|)
operator|==
name|FE_C10
condition|)
block|{
comment|/* 		 *  Look for the lowest clock divisor that allows an 		 *  output speed not faster than the period. 		 */
while|while
condition|(
name|div
operator|>
literal|0
condition|)
block|{
operator|--
name|div
expr_stmt|;
if|if
condition|(
name|kpc
operator|>
operator|(
name|div_10M
index|[
name|div
index|]
operator|<<
literal|2
operator|)
condition|)
block|{
operator|++
name|div
expr_stmt|;
break|break;
block|}
block|}
name|fak
operator|=
literal|0
expr_stmt|;
comment|/* No extra clocks */
if|if
condition|(
name|div
operator|==
name|np
operator|->
name|clock_divn
condition|)
block|{
comment|/* Are we too fast ? */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|divp
operator|=
name|div
expr_stmt|;
operator|*
name|fakp
operator|=
name|fak
expr_stmt|;
return|return
name|ret
return|;
block|}
endif|#
directive|endif
comment|/* 	 *  Look for the greatest clock divisor that allows an 	 *  input speed faster than the period. 	 */
while|while
condition|(
name|div
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
name|kpc
operator|>=
operator|(
name|div_10M
index|[
name|div
index|]
operator|<<
literal|2
operator|)
condition|)
break|break;
comment|/* 	 *  Calculate the lowest clock factor that allows an output 	 *  speed not faster than the period, and the max output speed. 	 *  If fak>= 1 we will set both XCLKH_ST and XCLKH_DT. 	 *  If fak>= 2 we will also set XCLKS_ST and XCLKS_DT. 	 */
if|if
condition|(
name|dt
condition|)
block|{
name|fak
operator|=
operator|(
name|kpc
operator|-
literal|1
operator|)
operator|/
operator|(
name|div_10M
index|[
name|div
index|]
operator|<<
literal|1
operator|)
operator|+
literal|1
operator|-
literal|2
expr_stmt|;
comment|/* ret = ((2+fak)*div_10M[div])/np->clock_khz; */
block|}
else|else
block|{
name|fak
operator|=
operator|(
name|kpc
operator|-
literal|1
operator|)
operator|/
name|div_10M
index|[
name|div
index|]
operator|+
literal|1
operator|-
literal|4
expr_stmt|;
comment|/* ret = ((4+fak)*div_10M[div])/np->clock_khz; */
block|}
comment|/* 	 *  Check against our hardware limits, or bugs :). 	 */
if|if
condition|(
name|fak
operator|<
literal|0
condition|)
block|{
name|fak
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fak
operator|>
literal|2
condition|)
block|{
name|fak
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 *  Compute and return sync parameters. 	 */
operator|*
name|divp
operator|=
name|div
expr_stmt|;
operator|*
name|fakp
operator|=
name|fak
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  Tell the SCSI layer about the new transfer parameters.  */
end_comment

begin_function
specifier|static
name|void
name|sym_xpt_async_transfer_neg
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|u_int
name|spi_valid
parameter_list|)
block|{
name|struct
name|ccb_trans_settings
name|cts
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
decl_stmt|;
name|int
name|sts
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|sts
operator|=
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|,
name|target
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|!=
name|CAM_REQ_CMP
condition|)
return|return;
name|bzero
argument_list|(
operator|&
name|cts
argument_list|,
sizeof|sizeof
argument_list|(
name|cts
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|cts__scsi
value|(cts.proto_specific.scsi)
define|#
directive|define
name|cts__spi
value|(cts.xport_specific.spi)
name|cts
operator|.
name|type
operator|=
name|CTS_TYPE_CURRENT_SETTINGS
expr_stmt|;
name|cts
operator|.
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|.
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|.
name|protocol_version
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|scsi_version
expr_stmt|;
name|cts
operator|.
name|transport_version
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|spi_version
expr_stmt|;
name|cts__spi
operator|.
name|valid
operator|=
name|spi_valid
expr_stmt|;
if|if
condition|(
name|spi_valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
condition|)
name|cts__spi
operator|.
name|sync_period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
expr_stmt|;
if|if
condition|(
name|spi_valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
condition|)
name|cts__spi
operator|.
name|sync_offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|spi_valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
condition|)
name|cts__spi
operator|.
name|bus_width
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
expr_stmt|;
if|if
condition|(
name|spi_valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
condition|)
name|cts__spi
operator|.
name|ppr_options
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
expr_stmt|;
undef|#
directive|undef
name|cts__spi
undef|#
directive|undef
name|cts__scsi
name|xpt_setup_ccb
argument_list|(
operator|&
name|cts
operator|.
name|ccb_h
argument_list|,
name|path
argument_list|,
comment|/*priority*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|path
argument_list|,
operator|&
name|cts
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SYM_SPI_VALID_WDTR
define|\
value|CTS_SPI_VALID_BUS_WIDTH |	\ 	CTS_SPI_VALID_SYNC_RATE |	\ 	CTS_SPI_VALID_SYNC_OFFSET
end_define

begin_define
define|#
directive|define
name|SYM_SPI_VALID_SDTR
define|\
value|CTS_SPI_VALID_SYNC_RATE |	\ 	CTS_SPI_VALID_SYNC_OFFSET
end_define

begin_define
define|#
directive|define
name|SYM_SPI_VALID_PPR
define|\
value|CTS_SPI_VALID_PPR_OPTIONS |	\ 	CTS_SPI_VALID_BUS_WIDTH |	\ 	CTS_SPI_VALID_SYNC_RATE |	\ 	CTS_SPI_VALID_SYNC_OFFSET
end_define

begin_comment
comment|/*  *  We received a WDTR.  *  Let everything be aware of the changes.  */
end_comment

begin_function
specifier|static
name|void
name|sym_setwide
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|wide
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|sym_settrans
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|wide
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCSI layer about the new transfer parameters. 	 */
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
name|sym_xpt_async_transfer_neg
argument_list|(
name|np
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|SYM_SPI_VALID_WDTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  We received a SDTR.  *  Let everything be aware of the changes.  */
end_comment

begin_function
specifier|static
name|void
name|sym_setsync
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|u_char
name|wide
init|=
operator|(
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|&
name|EWS
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|sym_settrans
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCSI layer about the new transfer parameters. 	 */
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|per
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
name|sym_xpt_async_transfer_neg
argument_list|(
name|np
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|SYM_SPI_VALID_SDTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  We received a PPR.  *  Let everything be aware of the changes.  */
end_comment

begin_function
specifier|static
name|void
name|sym_setpprot
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|sym_settrans
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCSI layer about the new transfer parameters. 	 */
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|per
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
name|dt
expr_stmt|;
name|sym_xpt_async_transfer_neg
argument_list|(
name|np
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|SYM_SPI_VALID_PPR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Switch trans mode for current job and it's target.  */
end_comment

begin_function
specifier|static
name|void
name|sym_settrans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u_char
name|dt
parameter_list|,
name|u_char
name|ofs
parameter_list|,
name|u_char
name|per
parameter_list|,
name|u_char
name|wide
parameter_list|,
name|u_char
name|div
parameter_list|,
name|u_char
name|fak
parameter_list|)
block|{
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|u_char
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|u_char
name|sval
decl_stmt|,
name|wval
decl_stmt|,
name|uval
decl_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
name|assert
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ccb
condition|)
return|return;
name|assert
argument_list|(
name|target
operator|==
operator|(
name|cp
operator|->
name|target
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|sval
operator|=
name|tp
operator|->
name|head
operator|.
name|sval
expr_stmt|;
name|wval
operator|=
name|tp
operator|->
name|head
operator|.
name|wval
expr_stmt|;
name|uval
operator|=
name|tp
operator|->
name|head
operator|.
name|uval
expr_stmt|;
if|#
directive|if
literal|0
block|printf("XXXX sval=%x wval=%x uval=%x (%x)\n", 		sval, wval, uval, np->rv_scntl3);
endif|#
directive|endif
comment|/* 	 *  Set the offset. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
name|sval
operator|=
operator|(
name|sval
operator|&
operator|~
literal|0x1f
operator|)
operator||
name|ofs
expr_stmt|;
else|else
name|sval
operator|=
operator|(
name|sval
operator|&
operator|~
literal|0x3f
operator|)
operator||
name|ofs
expr_stmt|;
comment|/* 	 *  Set the sync divisor and extra clock factor. 	 */
if|if
condition|(
name|ofs
operator|!=
literal|0
condition|)
block|{
name|wval
operator|=
operator|(
name|wval
operator|&
operator|~
literal|0x70
operator|)
operator||
operator|(
operator|(
name|div
operator|+
literal|1
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
name|sval
operator|=
operator|(
name|sval
operator|&
operator|~
literal|0xe0
operator|)
operator||
operator|(
name|fak
operator|<<
literal|5
operator|)
expr_stmt|;
else|else
block|{
name|uval
operator|=
name|uval
operator|&
operator|~
operator|(
name|XCLKH_ST
operator||
name|XCLKH_DT
operator||
name|XCLKS_ST
operator||
name|XCLKS_DT
operator|)
expr_stmt|;
if|if
condition|(
name|fak
operator|>=
literal|1
condition|)
name|uval
operator||=
operator|(
name|XCLKH_ST
operator||
name|XCLKH_DT
operator|)
expr_stmt|;
if|if
condition|(
name|fak
operator|>=
literal|2
condition|)
name|uval
operator||=
operator|(
name|XCLKS_ST
operator||
name|XCLKS_DT
operator|)
expr_stmt|;
block|}
block|}
comment|/* 	 *  Set the bus width. 	 */
name|wval
operator|=
name|wval
operator|&
operator|~
name|EWS
expr_stmt|;
if|if
condition|(
name|wide
operator|!=
literal|0
condition|)
name|wval
operator||=
name|EWS
expr_stmt|;
comment|/* 	 *  Set misc. ultra enable bits. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|uval
operator|=
name|uval
operator|&
operator|~
operator|(
name|U3EN
operator||
name|AIPCKEN
operator|)
expr_stmt|;
if|if
condition|(
name|dt
condition|)
block|{
name|assert
argument_list|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
argument_list|)
expr_stmt|;
name|uval
operator||=
name|U3EN
expr_stmt|;
block|}
block|}
else|else
block|{
name|wval
operator|=
name|wval
operator|&
operator|~
name|ULTRA
expr_stmt|;
if|if
condition|(
name|per
operator|<=
literal|12
condition|)
name|wval
operator||=
name|ULTRA
expr_stmt|;
block|}
comment|/* 	 *   Stop there if sync parameters are unchanged. 	 */
if|if
condition|(
name|tp
operator|->
name|head
operator|.
name|sval
operator|==
name|sval
operator|&&
name|tp
operator|->
name|head
operator|.
name|wval
operator|==
name|wval
operator|&&
name|tp
operator|->
name|head
operator|.
name|uval
operator|==
name|uval
condition|)
return|return;
name|tp
operator|->
name|head
operator|.
name|sval
operator|=
name|sval
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|wval
operator|=
name|wval
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|uval
operator|=
name|uval
expr_stmt|;
comment|/* 	 *  Disable extended Sreq/Sack filtering if per< 50. 	 *  Not supported on the C1010. 	 */
if|if
condition|(
name|per
operator|<
literal|50
operator|&&
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
name|OUTOFFB
argument_list|(
name|nc_stest2
argument_list|,
name|EXT
argument_list|)
expr_stmt|;
comment|/* 	 *  set actual value and sync_status 	 */
name|OUTB
argument_list|(
name|nc_sxfer
argument_list|,
name|tp
operator|->
name|head
operator|.
name|sval
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|tp
operator|->
name|head
operator|.
name|wval
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scntl4
argument_list|,
name|tp
operator|->
name|head
operator|.
name|uval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  patch ALL busy ccbs of this target. 	 */
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|target
operator|!=
name|target
condition|)
continue|continue;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|head
operator|.
name|wval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|head
operator|.
name|sval
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl4
operator|=
name|tp
operator|->
name|head
operator|.
name|uval
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  log message for real hard errors  *  *  sym0 targ 0?: ERROR (ds:si) (so-si-sd) (sxfer/scntl3) @ name (dsp:dbc).  *  	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.  *  *  exception register:  *  	ds:	dstat  *  	si:	sist  *  *  SCSI bus lines:  *  	so:	control lines as driven by chip.  *  	si:	control lines as seen by chip.  *  	sd:	scsi data lines as seen by chip.  *  *  wide/fastmode:  *  	sxfer:	(see the manual)  *  	scntl3:	(see the manual)  *  *  current script command:  *  	dsp:	script address (relative to start of script).  *  	dbc:	first word of script command.  *  *  First 24 register of the chip:  *  	r0..rf  */
end_comment

begin_function
specifier|static
name|void
name|sym_log_hard_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|,
name|u_char
name|dstat
parameter_list|)
block|{
name|u32
name|dsp
decl_stmt|;
name|int
name|script_ofs
decl_stmt|;
name|int
name|script_size
decl_stmt|;
name|char
modifier|*
name|script_name
decl_stmt|;
name|u_char
modifier|*
name|script_base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|scripta_ba
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|scripta_ba
operator|+
name|np
operator|->
name|scripta_sz
condition|)
block|{
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|scripta_ba
expr_stmt|;
name|script_size
operator|=
name|np
operator|->
name|scripta_sz
expr_stmt|;
name|script_base
operator|=
operator|(
name|u_char
operator|*
operator|)
name|np
operator|->
name|scripta0
expr_stmt|;
name|script_name
operator|=
literal|"scripta"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|scriptb_ba
operator|<
name|dsp
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|scriptb_ba
operator|+
name|np
operator|->
name|scriptb_sz
condition|)
block|{
name|script_ofs
operator|=
name|dsp
operator|-
name|np
operator|->
name|scriptb_ba
expr_stmt|;
name|script_size
operator|=
name|np
operator|->
name|scriptb_sz
expr_stmt|;
name|script_base
operator|=
operator|(
name|u_char
operator|*
operator|)
name|np
operator|->
name|scriptb0
expr_stmt|;
name|script_name
operator|=
literal|"scriptb"
expr_stmt|;
block|}
else|else
block|{
name|script_ofs
operator|=
name|dsp
expr_stmt|;
name|script_size
operator|=
literal|0
expr_stmt|;
name|script_base
operator|=
literal|0
expr_stmt|;
name|script_name
operator|=
literal|"mem"
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x) @ (%s %x:%08x).\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_socl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sbdl
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_sxfer
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INB
argument_list|(
name|nc_scntl3
argument_list|)
argument_list|,
name|script_name
argument_list|,
name|script_ofs
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|script_ofs
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|script_ofs
operator|<
name|script_size
condition|)
block|{
name|printf
argument_list|(
literal|"%s: script cmd = %08x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|scr_to_cpu
argument_list|(
operator|(
name|int
operator|)
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|script_base
operator|+
name|script_ofs
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: regdump:"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|INB_OFF
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
comment|/* 	 *  PCI BUS error, read the PCI ststus register. 	 */
if|if
condition|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator|)
condition|)
block|{
name|u_short
name|pci_sts
decl_stmt|;
name|pci_sts
operator|=
name|pci_read_config
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|PCIR_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_sts
operator|&
literal|0xf900
condition|)
block|{
name|pci_write_config
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|PCIR_STATUS
argument_list|,
name|pci_sts
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: PCI STATUS = 0x%04x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|pci_sts
operator|&
literal|0xf900
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  chip interrupt handler  *  *  In normal situations, interrupt conditions occur one at  *  a time. But when something bad happens on the SCSI BUS,  *  the chip may raise several interrupt flags before  *  stopping and interrupting the CPU. The additionnal  *  interrupt flags are stacked in some extra registers  *  after the SIP and/or DIP flag has been raised in the  *  ISTAT. After the CPU has read the interrupt condition  *  flag from SIST or DSTAT, the chip unstacks the other  *  interrupt flags and sets the corresponding bits in  *  SIST or DSTAT. Since the chip starts stacking once the  *  SIP or DIP flag is set, there is a small window of time  *  where the stacking does not occur.  *  *  Typically, multiple interrupt conditions may happen in  *  the following situations:  *  *  - SCSI parity error + Phase mismatch  (PAR|MA)  *    When a parity error is detected in input phase  *    and the device switches to msg-in phase inside a  *    block MOV.  *  - SCSI parity error + Unexpected disconnect (PAR|UDC)  *    When a stupid device does not want to handle the  *    recovery of an SCSI parity error.  *  - Some combinations of STO, PAR, UDC, ...  *    When using non compliant SCSI stuff, when user is  *    doing non compliant hot tampering on the BUS, when  *    something really bad happens to a device, etc ...  *  *  The heuristic suggested by SYMBIOS to handle  *  multiple interrupts is to try unstacking all  *  interrupts conditions and to handle them on some  *  priority based on error severity.  *  This will work when the unstacking has been  *  successful, but we cannot be 100 % sure of that,  *  since the CPU may have been faster to unstack than  *  the chip is able to stack. Hmmm ... But it seems that  *  such a situation is very unlikely to happen.  *  *  If this happen, for example STO caught by the CPU  *  then UDC happenning before the CPU have restarted  *  the SCRIPTS, the driver may wrongly complete the  *  same command on UDC, since the SCRIPTS didn't restart  *  and the DSA still points to the same command.  *  We avoid this situation by setting the DSA to an  *  invalid value when the CCB is completed and before  *  restarting the SCRIPTS.  *  *  Another issue is that we need some section of our  *  recovery procedures to be somehow uninterruptible but  *  the SCRIPTS processor does not provides such a  *  feature. For this reason, we handle recovery preferently  *  from the C code and check against some SCRIPTS critical  *  sections from the C code.  *  *  Hopefully, the interrupt handling of the driver is now  *  able to resist to weird BUS error conditions, but donnot  *  ask me for any guarantee that it will never fail. :-)  *  Use at your own decision and risk.  */
end_comment

begin_function
specifier|static
name|void
name|sym_intr1
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|istat
decl_stmt|,
name|istatc
decl_stmt|;
name|u_char
name|dstat
decl_stmt|;
name|u_short
name|sist
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  interrupt on the fly ? 	 * 	 *  A `dummy read' is needed to ensure that the 	 *  clear of the INTF flag reaches the device 	 *  before the scanning of the DONE queue. 	 */
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
if|if
condition|(
name|istat
operator|&
name|INTF
condition|)
block|{
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
operator|(
name|istat
operator|&
name|SIGP
operator|)
operator||
name|INTF
operator||
name|np
operator|->
name|istat_sem
argument_list|)
expr_stmt|;
name|istat
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
comment|/* DUMMY READ */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"F "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sym_wakeup_done
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
operator|(
name|istat
operator|&
operator|(
name|SIP
operator||
name|DIP
operator|)
operator|)
condition|)
return|return;
if|#
directive|if
literal|0
comment|/* We should never get this one */
block|if (istat& CABRT) 		OUTB (nc_istat, CABRT);
endif|#
directive|endif
comment|/* 	 *  PAR and MA interrupts may occur at the same time, 	 *  and we need to know of both in order to handle 	 *  this situation properly. We try to unstack SCSI 	 *  interrupts for that reason. BTW, I dislike a LOT 	 *  such a loop inside the interrupt routine. 	 *  Even if DMA interrupt stacking is very unlikely to 	 *  happen, we also try unstacking these ones, since 	 *  this has no performance impact. 	 */
name|sist
operator|=
literal|0
expr_stmt|;
name|dstat
operator|=
literal|0
expr_stmt|;
name|istatc
operator|=
name|istat
expr_stmt|;
do|do
block|{
if|if
condition|(
name|istatc
operator|&
name|SIP
condition|)
name|sist
operator||=
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
if|if
condition|(
name|istatc
operator|&
name|DIP
condition|)
name|dstat
operator||=
name|INB
argument_list|(
name|nc_dstat
argument_list|)
expr_stmt|;
name|istatc
operator|=
name|INB
argument_list|(
name|nc_istat
argument_list|)
expr_stmt|;
name|istat
operator||=
name|istatc
expr_stmt|;
block|}
do|while
condition|(
name|istatc
operator|&
operator|(
name|SIP
operator||
name|DIP
operator|)
condition|)
do|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"<%d|%x:%x|%x:%x>"
argument_list|,
operator|(
name|int
operator|)
name|INB
argument_list|(
name|nc_scr0
argument_list|)
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dsp
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|INL
argument_list|(
name|nc_dbc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  On paper, a memory barrier may be needed here. 	 *  And since we are paranoid ... :) 	 */
name|MEMORY_BARRIER
argument_list|()
expr_stmt|;
comment|/* 	 *  First, interrupts we want to service cleanly. 	 * 	 *  Phase mismatch (MA) is the most frequent interrupt 	 *  for chip earlier than the 896 and so we have to service 	 *  it as quickly as possible. 	 *  A SCSI parity error (PAR) may be combined with a phase 	 *  mismatch condition (MA). 	 *  Programmed interrupts (SIR) are used to call the C code 	 *  from SCRIPTS. 	 *  The single step interrupt (SSI) is not used in this 	 *  driver. 	 */
if|if
condition|(
operator|!
operator|(
name|sist
operator|&
operator|(
name|STO
operator||
name|GEN
operator||
name|HTH
operator||
name|SGE
operator||
name|UDC
operator||
name|SBMC
operator||
name|RST
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sist
operator|&
name|PAR
condition|)
name|sym_int_par
argument_list|(
name|np
argument_list|,
name|sist
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sist
operator|&
name|MA
condition|)
name|sym_int_ma
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dstat
operator|&
name|SIR
condition|)
name|sym_int_sir
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dstat
operator|&
name|SSI
condition|)
name|OUTONB_STD
argument_list|()
expr_stmt|;
else|else
goto|goto
name|unknown_int
goto|;
return|return;
block|}
empty_stmt|;
comment|/* 	 *  Now, interrupts that donnot happen in normal 	 *  situations and that we may need to recover from. 	 * 	 *  On SCSI RESET (RST), we reset everything. 	 *  On SCSI BUS MODE CHANGE (SBMC), we complete all 	 *  active CCBs with RESET status, prepare all devices 	 *  for negotiating again and restart the SCRIPTS. 	 *  On STO and UDC, we complete the CCB with the corres- 	 *  ponding status and restart the SCRIPTS. 	 */
if|if
condition|(
name|sist
operator|&
name|RST
condition|)
block|{
name|xpt_print_path
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI BUS reset detected.\n"
argument_list|)
expr_stmt|;
name|sym_init
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
if|if
condition|(
operator|!
operator|(
name|sist
operator|&
operator|(
name|GEN
operator||
name|HTH
operator||
name|SGE
operator|)
operator|)
operator|&&
operator|!
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sist
operator|&
name|SBMC
condition|)
name|sym_int_sbmc
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sist
operator|&
name|STO
condition|)
name|sym_int_sto
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sist
operator|&
name|UDC
condition|)
name|sym_int_udc
argument_list|(
name|np
argument_list|)
expr_stmt|;
else|else
goto|goto
name|unknown_int
goto|;
return|return;
block|}
empty_stmt|;
comment|/* 	 *  Now, interrupts we are not able to recover cleanly. 	 * 	 *  Log message for hard errors. 	 *  Reset everything. 	 */
name|sym_log_hard_error
argument_list|(
name|np
argument_list|,
name|sist
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sist
operator|&
operator|(
name|GEN
operator||
name|HTH
operator||
name|SGE
operator|)
operator|)
operator|||
operator|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|ABRT
operator||
name|IID
operator|)
operator|)
condition|)
block|{
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|unknown_int
label|:
comment|/* 	 *  We just miss the cause of the interrupt. :( 	 *  Print a message. The timeout will do the real work. 	 */
name|printf
argument_list|(
literal|"%s: unknown interrupt(s) ignored, "
literal|"ISTAT=0x%x DSTAT=0x%x SIST=0x%x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|istat
argument_list|,
name|dstat
argument_list|,
name|sist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|hcb_p
name|np
init|=
name|arg
decl_stmt|;
name|SYM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"["
argument_list|)
expr_stmt|;
name|sym_intr1
argument_list|(
operator|(
name|hcb_p
operator|)
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
name|SYM_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|sym_intr1
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  generic recovery from scsi interrupt  *  *  The doc says that when the chip gets an SCSI interrupt,  *  it tries to stop in an orderly fashion, by completing  *  an instruction fetch that had started or by flushing  *  the DMA fifo for a write to memory that was executing.  *  Such a fashion is not enough to know if the instruction  *  that was just before the current DSP value has been  *  executed or not.  *  *  There are some small SCRIPTS sections that deal with  *  the start queue and the done queue that may break any  *  assomption from the C code if we are interrupted  *  inside, so we reset if this happens. Btw, since these  *  SCRIPTS sections are executed while the SCRIPTS hasn't  *  started SCSI operations, it is very unlikely to happen.  *  *  All the driver data structures are supposed to be  *  allocated from the same 4 GB memory window, so there  *  is a 1 to 1 relationship between DSA and driver data  *  structures. Since we are careful :) to invalidate the  *  DSA when we complete a command or when the SCRIPTS  *  pushes a DSA into a queue, we can trust it when it  *  points to a CCB.  */
end_comment

begin_function
specifier|static
name|void
name|sym_recover_scsi_int
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|hsts
parameter_list|)
block|{
name|u32
name|dsp
init|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
decl_stmt|;
name|u32
name|dsa
init|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
decl_stmt|;
name|ccb_p
name|cp
init|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
decl_stmt|;
comment|/* 	 *  If we haven't been interrupted inside the SCRIPTS 	 *  critical pathes, we can safely restart the SCRIPTS 	 *  and trust the DSA value if it matches a CCB. 	 */
if|if
condition|(
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|getjob_begin
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|getjob_end
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|ungetjob
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|reselect
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|sel_for_abort
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|sel_for_abort_1
argument_list|)
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|dsp
operator|>
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|done
argument_list|)
operator|&&
name|dsp
operator|<
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|done_end
argument_list|)
operator|+
literal|1
operator|)
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* clear dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* clear scsi fifo */
comment|/* 		 *  If we have a CCB, let the SCRIPTS call us back for 		 *  the handling of the error with SCRATCHA filled with 		 *  STARTPOS. This way, we will be able to freeze the 		 *  device queue and requeue awaiting IOs. 		 */
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|hsts
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|complete_error
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *  Otherwise just restart the SCRIPTS. 		 */
else|else
block|{
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
literal|0xffffff
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
goto|goto
name|reset_all
goto|;
return|return;
name|reset_all
label|:
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for selection timeout  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_sto
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u32
name|dsp
init|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"T"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsp
operator|==
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|wf_sel_done
argument_list|)
operator|+
literal|8
condition|)
name|sym_recover_scsi_int
argument_list|(
name|np
argument_list|,
name|HS_SEL_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for unexpected disconnect  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_udc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: unexpected disconnect\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|sym_recover_scsi_int
argument_list|(
name|np
argument_list|,
name|HS_UNEXPECTED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for SCSI bus mode change  *  *  spi2-r12 11.2.3 says a transceiver mode change must  *  generate a reset event and a device that detects a reset  *  event shall initiate a hard reset. It says also that a  *  device that detects a mode change shall set data transfer  *  mode to eight bit asynchronous, etc...  *  So, just reinitializing all except chip should be enough.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_sbmc
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|scsi_mode
init|=
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|SMODE
decl_stmt|;
comment|/* 	 *  Notify user. 	 */
name|xpt_print_path
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI BUS mode change from %s to %s.\n"
argument_list|,
name|sym_scsi_bus_mode
argument_list|(
name|np
operator|->
name|scsi_mode
argument_list|)
argument_list|,
name|sym_scsi_bus_mode
argument_list|(
name|scsi_mode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Should suspend command processing for a few seconds and 	 *  reinitialize all except the chip. 	 */
name|sym_init
argument_list|(
name|np
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for SCSI parity error.  *  *  When the chip detects a SCSI parity error and is  *  currently executing a (CH)MOV instruction, it does  *  not interrupt immediately, but tries to finish the  *  transfer of the current scatter entry before  *  interrupting. The following situations may occur:  *  *  - The complete scatter entry has been transferred  *    without the device having changed phase.  *    The chip will then interrupt with the DSP pointing  *    to the instruction that follows the MOV.  *  *  - A phase mismatch occurs before the MOV finished  *    and phase errors are to be handled by the C code.  *    The chip will then interrupt with both PAR and MA  *    conditions set.  *  *  - A phase mismatch occurs before the MOV finished and  *    phase errors are to be handled by SCRIPTS.  *    The chip will load the DSP with the phase mismatch  *    JUMP address and interrupt the host processor.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_par
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|sist
parameter_list|)
block|{
name|u_char
name|hsts
init|=
name|INB
argument_list|(
name|HS_PRT
argument_list|)
decl_stmt|;
name|u32
name|dsp
init|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
decl_stmt|;
name|u32
name|dbc
init|=
name|INL
argument_list|(
name|nc_dbc
argument_list|)
decl_stmt|;
name|u32
name|dsa
init|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
decl_stmt|;
name|u_char
name|sbcl
init|=
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
decl_stmt|;
name|u_char
name|cmd
init|=
name|dbc
operator|>>
literal|24
decl_stmt|;
name|int
name|phase
init|=
name|cmd
operator|&
literal|7
decl_stmt|;
name|ccb_p
name|cp
init|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|hsts
argument_list|,
name|dbc
argument_list|,
name|sbcl
argument_list|)
expr_stmt|;
comment|/* 	 *  Check that the chip is connected to the SCSI BUS. 	 */
if|if
condition|(
operator|!
operator|(
name|INB
argument_list|(
name|nc_scntl1
argument_list|)
operator|&
name|ISCON
operator|)
condition|)
block|{
name|sym_recover_scsi_int
argument_list|(
name|np
argument_list|,
name|HS_UNEXPECTED
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  If the nexus is not clearly identified, reset the bus. 	 *  We will try to do better later. 	 */
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|reset_all
goto|;
comment|/* 	 *  Check instruction was a MOV, direction was INPUT and 	 *  ATN is asserted. 	 */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xc0
operator|)
operator|||
operator|!
operator|(
name|phase
operator|&
literal|1
operator|)
operator|||
operator|!
operator|(
name|sbcl
operator|&
literal|0x8
operator|)
condition|)
goto|goto
name|reset_all
goto|;
comment|/* 	 *  Keep track of the parity error. 	 */
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_PARITY_ERR
expr_stmt|;
comment|/* 	 *  Prepare the message to send to the device. 	 */
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
operator|(
name|phase
operator|==
literal|7
operator|)
condition|?
name|M_PARITY
else|:
name|M_ID_ERROR
expr_stmt|;
comment|/* 	 *  If the old phase was DATA IN phase, we have to deal with 	 *  the 3 situations described above. 	 *  For other input phases (MSG IN and STATUS), the device 	 *  must resend the whole thing that failed parity checking 	 *  or signal error. So, jumping to dispatcher should be OK. 	 */
if|if
condition|(
name|phase
operator|==
literal|1
operator|||
name|phase
operator|==
literal|5
condition|)
block|{
comment|/* Phase mismatch handled by SCRIPTS */
if|if
condition|(
name|dsp
operator|==
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|pm_handle
argument_list|)
condition|)
name|OUTL_DSP
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
comment|/* Phase mismatch handled by the C code */
elseif|else
if|if
condition|(
name|sist
operator|&
name|MA
condition|)
name|sym_int_ma
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* No phase mismatch occurred */
else|else
block|{
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reset_all
label|:
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for phase errors.  *  *  We have to construct a new transfer descriptor,  *  to transfer the rest of the current block.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_ma
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u32
name|dbc
decl_stmt|;
name|u32
name|rest
decl_stmt|;
name|u32
name|dsp
decl_stmt|;
name|u32
name|dsa
decl_stmt|;
name|u32
name|nxtdsp
decl_stmt|;
name|u32
modifier|*
name|vdsp
decl_stmt|;
name|u32
name|oadr
decl_stmt|,
name|olen
decl_stmt|;
name|u32
modifier|*
name|tblp
decl_stmt|;
name|u32
name|newcmd
decl_stmt|;
name|u_int
name|delta
decl_stmt|;
name|u_char
name|cmd
decl_stmt|;
name|u_char
name|hflags
decl_stmt|,
name|hflags0
decl_stmt|;
name|struct
name|sym_pmc
modifier|*
name|pm
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|dsp
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
name|dbc
operator|=
name|INL
argument_list|(
name|nc_dbc
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|dbc
operator|>>
literal|24
expr_stmt|;
name|rest
operator|=
name|dbc
operator|&
literal|0xffffff
expr_stmt|;
name|delta
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  locate matching cp if any. 	 */
name|cp
operator|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
expr_stmt|;
comment|/* 	 *  Donnot take into account dma fifo and various buffers in 	 *  INPUT phase since the chip flushes everything before 	 *  raising the MA interrupt for interrupted INPUT phases. 	 *  For DATA IN phase, we will check for the SWIDE later. 	 */
if|if
condition|(
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|!=
literal|1
operator|&&
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|!=
literal|5
condition|)
block|{
name|u_char
name|ss0
decl_stmt|,
name|ss2
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_DFBC
condition|)
name|delta
operator|=
name|INW
argument_list|(
name|nc_dfbc
argument_list|)
expr_stmt|;
else|else
block|{
name|u32
name|dfifo
decl_stmt|;
comment|/* 			 * Read DFIFO, CTEST[4-6] using 1 PCI bus ownership. 			 */
name|dfifo
operator|=
name|INL
argument_list|(
name|nc_dfifo
argument_list|)
expr_stmt|;
comment|/* 			 *  Calculate remaining bytes in DMA fifo. 			 *  (CTEST5 = dfifo>> 16) 			 */
if|if
condition|(
name|dfifo
operator|&
operator|(
name|DFS
operator|<<
literal|16
operator|)
condition|)
name|delta
operator|=
operator|(
operator|(
operator|(
operator|(
name|dfifo
operator|>>
literal|8
operator|)
operator|&
literal|0x300
operator|)
operator||
operator|(
name|dfifo
operator|&
literal|0xff
operator|)
operator|)
operator|-
name|rest
operator|)
operator|&
literal|0x3ff
expr_stmt|;
else|else
name|delta
operator|=
operator|(
operator|(
name|dfifo
operator|&
literal|0xff
operator|)
operator|-
name|rest
operator|)
operator|&
literal|0x7f
expr_stmt|;
block|}
comment|/* 		 *  The data in the dma fifo has not been transferred to 		 *  the target -> add the amount to the rest 		 *  and clear the data. 		 *  Check the sstat2 register in case of wide transfer. 		 */
name|rest
operator|+=
name|delta
expr_stmt|;
name|ss0
operator|=
name|INB
argument_list|(
name|nc_sstat0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss0
operator|&
name|OLF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
if|if
condition|(
name|ss0
operator|&
name|ORF
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|&&
operator|(
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|&
name|EWS
operator|)
condition|)
block|{
name|ss2
operator|=
name|INB
argument_list|(
name|nc_sstat2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss2
operator|&
name|OLF1
condition|)
name|rest
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
if|if
condition|(
name|ss2
operator|&
name|ORF1
condition|)
name|rest
operator|++
expr_stmt|;
block|}
empty_stmt|;
comment|/* 		 *  Clear fifos. 		 */
name|OUTB
argument_list|(
name|nc_ctest3
argument_list|,
name|np
operator|->
name|rv_ctest3
operator||
name|CLF
argument_list|)
expr_stmt|;
comment|/* dma fifo  */
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|TE
operator||
name|CSF
argument_list|)
expr_stmt|;
comment|/* scsi fifo */
block|}
comment|/* 	 *  log the information 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_TINY
operator||
name|DEBUG_PHASE
operator|)
condition|)
name|printf
argument_list|(
literal|"P%x%x RL=%d D=%d "
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
operator|&
literal|7
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|,
operator|(
name|unsigned
operator|)
name|delta
argument_list|)
expr_stmt|;
comment|/* 	 *  try to find the interrupted script command, 	 *  and the address at which to continue. 	 */
name|vdsp
operator|=
literal|0
expr_stmt|;
name|nxtdsp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|scripta_ba
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|scripta_ba
operator|+
name|np
operator|->
name|scripta_sz
condition|)
block|{
name|vdsp
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|scripta0
operator|+
operator|(
name|dsp
operator|-
name|np
operator|->
name|scripta_ba
operator|-
literal|8
operator|)
operator|)
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|>
name|np
operator|->
name|scriptb_ba
operator|&&
name|dsp
operator|<=
name|np
operator|->
name|scriptb_ba
operator|+
name|np
operator|->
name|scriptb_sz
condition|)
block|{
name|vdsp
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|np
operator|->
name|scriptb0
operator|+
operator|(
name|dsp
operator|-
name|np
operator|->
name|scriptb_ba
operator|-
literal|8
operator|)
operator|)
expr_stmt|;
name|nxtdsp
operator|=
name|dsp
expr_stmt|;
block|}
comment|/* 	 *  log the information 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"\nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x "
argument_list|,
name|cp
argument_list|,
operator|(
name|unsigned
operator|)
name|dsp
argument_list|,
operator|(
name|unsigned
operator|)
name|nxtdsp
argument_list|,
name|vdsp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|vdsp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: interrupted SCRIPT address not found.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reset_all
goto|;
block|}
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI phase error fixup: CCB already dequeued.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|reset_all
goto|;
block|}
comment|/* 	 *  get old startaddress and old length. 	 */
name|oadr
operator|=
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
literal|0x10
condition|)
block|{
comment|/* Table indirect */
name|tblp
operator|=
operator|(
name|u32
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cp
operator|->
name|phys
operator|+
name|oadr
operator|)
expr_stmt|;
name|olen
operator|=
name|scr_to_cpu
argument_list|(
name|tblp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|oadr
operator|=
name|scr_to_cpu
argument_list|(
name|tblp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tblp
operator|=
operator|(
name|u32
operator|*
operator|)
literal|0
expr_stmt|;
name|olen
operator|=
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"OCMD=%x\nTBLP=%p OLEN=%x OADR=%x\n"
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
argument_list|)
argument_list|,
name|tblp
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 *  check cmd against assumed interrupted script command. 	 *  If dt data phase, the MOVE instruction hasn't bit 4 of 	 *  the phase. 	 */
if|if
condition|(
operator|(
operator|(
name|cmd
operator|&
literal|2
operator|)
condition|?
name|cmd
else|:
operator|(
name|cmd
operator|&
operator|~
literal|4
operator|)
operator|)
operator|!=
operator|(
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
operator|)
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"internal error: cmd=%02x != %02x=(vdsp[0]>> 24)\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|cmd
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|vdsp
index|[
literal|0
index|]
argument_list|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
goto|goto
name|reset_all
goto|;
block|}
empty_stmt|;
comment|/* 	 *  if old phase not dataphase, leave here. 	 */
if|if
condition|(
name|cmd
operator|&
literal|2
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"phase change %x-%x %d@%08x resid=%d.\n"
argument_list|,
name|cmd
operator|&
literal|7
argument_list|,
name|INB
argument_list|(
name|nc_sbcl
argument_list|)
operator|&
literal|7
argument_list|,
operator|(
name|unsigned
operator|)
name|olen
argument_list|,
operator|(
name|unsigned
operator|)
name|oadr
argument_list|,
operator|(
name|unsigned
operator|)
name|rest
argument_list|)
expr_stmt|;
goto|goto
name|unexpected_phase
goto|;
block|}
empty_stmt|;
comment|/* 	 *  Choose the correct PM save area. 	 * 	 *  Look at the PM_SAVE SCRIPT if you want to understand 	 *  this stuff. The equivalent code is implemented in 	 *  SCRIPTS for the 895A, 896 and 1010 that are able to 	 *  handle PM from the SCRIPTS processor. 	 */
name|hflags0
operator|=
name|INB
argument_list|(
name|HF_PRT
argument_list|)
expr_stmt|;
name|hflags
operator|=
name|hflags0
expr_stmt|;
if|if
condition|(
name|hflags
operator|&
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
condition|)
block|{
if|if
condition|(
name|hflags
operator|&
name|HF_IN_PM0
condition|)
name|nxtdsp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|pm0
operator|.
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hflags
operator|&
name|HF_IN_PM1
condition|)
name|nxtdsp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|pm1
operator|.
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|hflags
operator|&
name|HF_DP_SAVED
condition|)
name|hflags
operator|^=
name|HF_ACT_PM
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hflags
operator|&
name|HF_ACT_PM
operator|)
condition|)
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm0
expr_stmt|;
name|newcmd
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm1
expr_stmt|;
name|newcmd
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
expr_stmt|;
block|}
name|hflags
operator|&=
operator|~
operator|(
name|HF_IN_PM0
operator||
name|HF_IN_PM1
operator||
name|HF_DP_SAVED
operator|)
expr_stmt|;
if|if
condition|(
name|hflags
operator|!=
name|hflags0
condition|)
name|OUTB
argument_list|(
name|HF_PRT
argument_list|,
name|hflags
argument_list|)
expr_stmt|;
comment|/* 	 *  fillin the phase mismatch context 	 */
name|pm
operator|->
name|sg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|oadr
operator|+
name|olen
operator|-
name|rest
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|pm
operator|->
name|ret
operator|=
name|cpu_to_scr
argument_list|(
name|nxtdsp
argument_list|)
expr_stmt|;
comment|/* 	 *  If we have a SWIDE, 	 *  - prepare the address to write the SWIDE from SCRIPTS, 	 *  - compute the SCRIPTS address to restart from, 	 *  - move current data pointer context by one byte. 	 */
name|nxtdsp
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
literal|7
operator|)
operator|==
literal|1
operator|&&
name|cp
operator|&&
operator|(
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|&
name|EWS
operator|)
operator|&&
operator|(
name|INB
argument_list|(
name|nc_scntl2
argument_list|)
operator|&
name|WSR
operator|)
condition|)
block|{
name|u32
name|tmp
decl_stmt|;
comment|/* 		 *  Set up the table indirect for the MOVE 		 *  of the residual byte and adjust the data 		 *  pointer context. 		 */
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|addr
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|wresid
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|tmp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|size
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|wresid
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
operator|(
name|tmp
operator|&
literal|0xff000000
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|tmp
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *  If only the residual byte is to be moved, 		 *  no PM context is needed. 		 */
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
operator|==
literal|1
condition|)
name|newcmd
operator|=
name|pm
operator|->
name|ret
expr_stmt|;
comment|/* 		 *  Prepare the address of SCRIPTS that will 		 *  move the residual byte to memory. 		 */
name|nxtdsp
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|wsr_ma_helper
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_PHASE
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PM %x %x %x / %x %x %x.\n"
argument_list|,
name|hflags0
argument_list|,
name|hflags
argument_list|,
name|newcmd
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|addr
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|size
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Restart the SCRIPTS processor. 	 */
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|newcmd
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|nxtdsp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  Unexpected phase changes that occurs when the current phase 	 *  is not a DATA IN or DATA OUT phase are due to error conditions. 	 *  Such event may only happen when the SCRIPTS is using a 	 *  multibyte SCSI MOVE. 	 * 	 *  Phase change		Some possible cause 	 * 	 *  COMMAND  --> MSG IN	SCSI parity error detected by target. 	 *  COMMAND  --> STATUS	Bad command or refused by target. 	 *  MSG OUT  --> MSG IN     Message rejected by target. 	 *  MSG OUT  --> COMMAND    Bogus target that discards extended 	 *  			negotiation messages. 	 * 	 *  The code below does not care of the new phase and so 	 *  trusts the target. Why to annoy it ? 	 *  If the interrupted phase is COMMAND phase, we restart at 	 *  dispatcher. 	 *  If a target does not get all the messages after selection, 	 *  the code assumes blindly that the target discards extended 	 *  messages and clears the negotiation status. 	 *  If the target does not want all our response to negotiation, 	 *  we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids 	 *  bloat for such a should_not_happen situation). 	 *  In all other situation, we reset the BUS. 	 *  Are these assumptions reasonnable ? (Wait and see ...) 	 */
name|unexpected_phase
label|:
name|dsp
operator|-=
literal|8
expr_stmt|;
name|nxtdsp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|&
literal|7
condition|)
block|{
case|case
literal|2
case|:
comment|/* COMMAND phase */
name|nxtdsp
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|dispatch
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 3:
comment|/* STATUS  phase */
block|nxtdsp = SCRIPTA_BA (np, dispatch); 		break;
endif|#
directive|endif
case|case
literal|6
case|:
comment|/* MSG OUT phase */
comment|/* 		 *  If the device may want to use untagged when we want 		 *  tagged, we prepare an IDENTIFY without disc. granted, 		 *  since we will not be able to handle reselect. 		 *  Otherwise, we just don't care. 		 */
if|if
condition|(
name|dsp
operator|==
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|send_ident
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
operator|&&
name|olen
operator|-
name|rest
operator|<=
literal|3
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|HS_BUSY
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
name|nxtdsp
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|ident_break_atn
argument_list|)
expr_stmt|;
block|}
else|else
name|nxtdsp
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|ident_break
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|==
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|send_wdtr
argument_list|)
operator|||
name|dsp
operator|==
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|send_sdtr
argument_list|)
operator|||
name|dsp
operator|==
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|send_ppr
argument_list|)
condition|)
block|{
name|nxtdsp
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|nego_bad_phase
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case 7:
comment|/* MSG IN  phase */
block|nxtdsp = SCRIPTA_BA (np, clrack); 		break;
endif|#
directive|endif
block|}
if|if
condition|(
name|nxtdsp
condition|)
block|{
name|OUTL_DSP
argument_list|(
name|nxtdsp
argument_list|)
expr_stmt|;
return|return;
block|}
name|reset_all
label|:
name|sym_start_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Dequeue from the START queue all CCBs that match  *  a given target/lun/task condition (-1 means all),  *  and move them from the BUSY queue to the COMP queue  *  with CAM_REQUEUE_REQ status condition.  *  This function is used during error handling/recovery.  *  It is called with SCRIPTS not running.  */
end_comment

begin_function
specifier|static
name|int
name|sym_dequeue_from_squeue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
comment|/* 	 *  Make sure the starting index is within range. 	 */
name|assert
argument_list|(
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
literal|2
operator|*
name|MAX_QUEUE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Walk until end of START queue and dequeue every job 	 *  that matches the target/lun/task condition. 	 */
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|np
operator|->
name|squeueput
condition|)
block|{
name|cp
operator|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|squeue
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* Forget hints for IARB, they may be no longer relevant */
name|cp
operator|->
name|host_flags
operator|&=
operator|~
name|HF_HINT_IARB
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|target
operator|==
operator|-
literal|1
operator|||
name|cp
operator|->
name|target
operator|==
name|target
operator|)
operator|&&
operator|(
name|lun
operator|==
operator|-
literal|1
operator|||
name|cp
operator|->
name|lun
operator|==
name|lun
operator|)
operator|&&
operator|(
name|task
operator|==
operator|-
literal|1
operator|||
name|cp
operator|->
name|tag
operator|==
name|task
operator|)
condition|)
block|{
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
name|sym_remque
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|np
operator|->
name|squeue
index|[
name|j
index|]
operator|=
name|np
operator|->
name|squeue
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|+=
literal|2
operator|)
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|j
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|+=
literal|2
operator|)
operator|>=
name|MAX_QUEUE
operator|*
literal|2
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|j
condition|)
comment|/* Copy back the idle task if needed */
name|np
operator|->
name|squeue
index|[
name|j
index|]
operator|=
name|np
operator|->
name|squeue
index|[
name|i
index|]
expr_stmt|;
name|np
operator|->
name|squeueput
operator|=
name|j
expr_stmt|;
comment|/* Update our current start queue pointer */
return|return
operator|(
name|i
operator|-
name|j
operator|)
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/*  *  Complete all CCBs queued to the COMP queue.  *  *  These CCBs are assumed:  *  - Not to be referenced either by devices or  *    SCRIPTS-related queues and datas.  *  - To have to be completed with an error condition  *    or requeued.  *  *  The device queue freeze count is incremented  *  for each CCB that does not prevent this.  *  This function is called when all CCBs involved  *  in error handling/recovery have been reaped.  */
end_comment

begin_function
specifier|static
name|void
name|sym_flush_comp_queue
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|)
block|{
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
while|while
condition|(
operator|(
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
comment|/* Leave quiet CCBs waiting for resources */
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_WAIT
condition|)
continue|continue;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
if|if
condition|(
name|cam_status
condition|)
name|sym_set_cam_status
argument_list|(
name|ccb
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
name|sym_freeze_cam_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  chip handler for bad SCSI status condition  *  *  In case of bad SCSI status, we unqueue all the tasks  *  currently queued to the controller but not yet started  *  and then restart the SCRIPTS processor immediately.  *  *  QUEUE FULL and BUSY conditions are handled the same way.  *  Basically all the not yet started tasks are requeued in  *  device queue and the queue is frozen until a completion.  *  *  For CHECK CONDITION and COMMAND TERMINATED status, we use  *  the CCB of the failed command to prepare a REQUEST SENSE  *  SCSI command and queue it to the controller queue.  *  *  SCRATCHA is assumed to have been loaded with STARTPOS  *  before the SCRIPTS called the C code.  */
end_comment

begin_function
specifier|static
name|void
name|sym_sir_bad_scsi_status
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|u32
name|startp
decl_stmt|;
name|u_char
name|s_status
init|=
name|cp
operator|->
name|ssss_status
decl_stmt|;
name|u_char
name|h_flags
init|=
name|cp
operator|->
name|host_flags
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|int
name|nego
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Compute the index of the next job to start from SCRIPTS. 	 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|np
operator|->
name|squeue_ba
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* 	 *  The last CCB queued used for IARB hint may be 	 *  no longer relevant. Forget it. 	 */
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
if|if
condition|(
name|np
operator|->
name|last_cp
condition|)
name|np
operator|->
name|last_cp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Now deal with the SCSI status. 	 */
switch|switch
condition|(
name|s_status
condition|)
block|{
case|case
name|S_BUSY
case|:
case|case
name|S_QUEUE_FULL
case|:
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s_status
operator|==
name|S_BUSY
condition|?
literal|"BUSY"
else|:
literal|"QUEUE FULL\n"
argument_list|)
expr_stmt|;
block|}
default|default:
comment|/* S_INT, S_INT_COND_MET, S_CONFLICT */
name|sym_complete_error
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_TERMINATED
case|:
case|case
name|S_CHECK_COND
case|:
comment|/* 		 *  If we get an SCSI error when requesting sense, give up. 		 */
if|if
condition|(
name|h_flags
operator|&
name|HF_SENSE
condition|)
block|{
name|sym_complete_error
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Dequeue all queued CCBs for that device not yet started, 		 *  and restart the SCRIPTS processor immediately. 		 */
operator|(
name|void
operator|)
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 *  Save some info of the actual IO. 		 *  Compute the data residual. 		 */
name|cp
operator|->
name|sv_scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
name|cp
operator|->
name|sv_xerr_status
operator|=
name|cp
operator|->
name|xerr_status
expr_stmt|;
name|cp
operator|->
name|sv_resid
operator|=
name|sym_compute_residual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 		 *  Prepare all needed data structures for 		 *  requesting sense data. 		 */
comment|/* 		 *  identify message 		 */
name|cp
operator|->
name|scsi_smsg2
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
name|msglen
operator|=
literal|1
expr_stmt|;
comment|/* 		 *  If we are currently using anything different from 		 *  async. 8 bit data transfers with that target, 		 *  start a negotiation, since the device may want 		 *  to report us a UNIT ATTENTION condition due to 		 *  a cause we currently ignore, and we donnot want 		 *  to be stuck with WIDE and/or SYNC data transfer. 		 * 		 *  cp->nego_status is filled by sym_prepare_nego(). 		 */
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
name|nego
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|&
name|PPR_OPT_MASK
condition|)
name|nego
operator|=
name|NS_PPR
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|BUS_8_BIT
condition|)
name|nego
operator|=
name|NS_WIDE
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
literal|0
condition|)
name|nego
operator|=
name|NS_SYNC
expr_stmt|;
if|if
condition|(
name|nego
condition|)
name|msglen
operator|+=
name|sym_prepare_nego
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|nego
argument_list|,
operator|&
name|cp
operator|->
name|scsi_smsg2
index|[
name|msglen
index|]
argument_list|)
expr_stmt|;
comment|/* 		 *  Message table indirect structure. 		 */
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|CCB_BA
argument_list|(
name|cp
argument_list|,
name|scsi_smsg2
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
comment|/* 		 *  sense command 		 */
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|CCB_BA
argument_list|(
name|cp
argument_list|,
name|sensecmd
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
literal|6
argument_list|)
expr_stmt|;
comment|/* 		 *  patch requested size into sense command 		 */
name|cp
operator|->
name|sensecmd
index|[
literal|0
index|]
operator|=
literal|0x03
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|scsi_version
operator|>
literal|2
operator|||
name|cp
operator|->
name|lun
operator|>
literal|7
condition|)
name|cp
operator|->
name|sensecmd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|sensecmd
index|[
literal|4
index|]
operator|=
name|SYM_SNS_BBUF_LEN
expr_stmt|;
name|cp
operator|->
name|data_len
operator|=
name|SYM_SNS_BBUF_LEN
expr_stmt|;
comment|/* 		 *  sense data 		 */
name|bzero
argument_list|(
name|cp
operator|->
name|sns_bbuf
argument_list|,
name|SYM_SNS_BBUF_LEN
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|cp
operator|->
name|sns_bbuf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|sense
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|SYM_SNS_BBUF_LEN
argument_list|)
expr_stmt|;
comment|/* 		 *  requeue the command. 		 */
name|startp
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|sdata_in
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|savep
operator|=
name|cpu_to_scr
argument_list|(
name|startp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|goalp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
operator|+
literal|16
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|lastp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|startp
operator|=
name|cpu_to_scr
argument_list|(
name|startp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|actualquirks
operator|=
name|SYM_QUIRK_AUTOSAVE
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|cp
operator|->
name|nego_status
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|ssss_status
operator|=
name|S_ILLEGAL
expr_stmt|;
name|cp
operator|->
name|host_flags
operator|=
operator|(
name|HF_SENSE
operator||
name|HF_DATA_IN
operator|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|extra_bytes
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 *  Requeue the command. 		 */
name|sym_put_start_queue
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 		 *  Give back to upper layer everything we have dequeued. 		 */
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  After a device has accepted some management message  *  as BUS DEVICE RESET, ABORT TASK, etc ..., or when  *  a device signals a UNIT ATTENTION condition, some  *  tasks are thrown away by the device. We are required  *  to reflect that on our tasks list since the device  *  will never complete these tasks.  *  *  This function move from the BUSY queue to the COMP  *  queue all disconnected CCBs for a given target that  *  match the following criteria:  *  - lun=-1  means any logical UNIT otherwise a given one.  *  - task=-1 means any task, otherwise a given one.  */
end_comment

begin_function
specifier|static
name|int
name|sym_clear_tasks
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|cam_status
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|SYM_QUEHEAD
name|qtmp
decl_stmt|,
modifier|*
name|qp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
comment|/* 	 *  Move the entire BUSY queue to our temporary queue. 	 */
name|sym_que_init
argument_list|(
operator|&
name|qtmp
argument_list|)
expr_stmt|;
name|sym_que_splice
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|,
operator|&
name|qtmp
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  Put all CCBs that matches our criteria into 	 *  the COMP queue and put back other ones into 	 *  the BUSY queue. 	 */
while|while
condition|(
operator|(
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|qtmp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
operator|||
name|cp
operator|->
name|target
operator|!=
name|target
operator|||
operator|(
name|lun
operator|!=
operator|-
literal|1
operator|&&
name|cp
operator|->
name|lun
operator|!=
name|lun
operator|)
operator|||
operator|(
name|task
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
operator|&&
name|cp
operator|->
name|scsi_smsg
index|[
literal|2
index|]
operator|!=
name|task
operator|)
operator|)
condition|)
block|{
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
comment|/* Preserve the software timeout condition */
if|if
condition|(
name|sym_get_cam_status
argument_list|(
name|ccb
argument_list|)
operator|!=
name|CAM_CMD_TIMEOUT
condition|)
name|sym_set_cam_status
argument_list|(
name|ccb
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|#
directive|if
literal|0
block|printf("XXXX TASK @%p CLEARED\n", cp);
endif|#
directive|endif
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for TASKS recovery  *  *  We cannot safely abort a command, while the SCRIPTS  *  processor is running, since we just would be in race  *  with it.  *  *  As long as we have tasks to abort, we keep the SEM  *  bit set in the ISTAT. When this bit is set, the  *  SCRIPTS processor interrupts (SIR_SCRIPT_STOPPED)  *  each time it enters the scheduler.  *  *  If we have to reset a target, clear tasks of a unit,  *  or to perform the abort of a disconnected job, we  *  restart the SCRIPTS for selecting the target. Once  *  selected, the SCRIPTS interrupts (SIR_TARGET_SELECTED).  *  If it loses arbitration, the SCRIPTS will interrupt again  *  the next time it will enter its scheduler, and so on ...  *  *  On SIR_TARGET_SELECTED, we scan for the more  *  appropriate thing to do:  *  *  - If nothing, we just sent a M_ABORT message to the  *    target to get rid of the useless SCSI bus ownership.  *    According to the specs, no tasks shall be affected.  *  - If the target is to be reset, we send it a M_RESET  *    message.  *  - If a logical UNIT is to be cleared , we send the  *    IDENTIFY(lun) + M_ABORT.  *  - If an untagged task is to be aborted, we send the  *    IDENTIFY(lun) + M_ABORT.  *  - If a tagged task is to be aborted, we send the  *    IDENTIFY(lun) + task attributes + M_ABORT_TAG.  *  *  Once our 'kiss of death' :) message has been accepted  *  by the target, the SCRIPTS interrupts again  *  (SIR_ABORT_SENT). On this interrupt, we complete  *  all the CCBs that should have been aborted by the  *  target according to our message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_sir_task_recovery
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|int
name|target
init|=
operator|-
literal|1
decl_stmt|,
name|lun
init|=
operator|-
literal|1
decl_stmt|,
name|task
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* 	 *  The SCRIPTS processor stopped before starting 	 *  the next command in order to allow us to perform 	 *  some task recovery. 	 */
case|case
name|SIR_SCRIPT_STOPPED
case|:
comment|/* 		 *  Do we have any target to reset or unit to clear ? 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|to_reset
operator|||
operator|(
name|tp
operator|->
name|lun0p
operator|&&
name|tp
operator|->
name|lun0p
operator|->
name|to_clear
operator|)
condition|)
block|{
name|target
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|lunmp
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|SYM_CONF_MAX_LUN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|&&
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|->
name|to_clear
condition|)
block|{
name|target
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|target
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
comment|/* 		 *  If not, walk the busy queue for any 		 *  disconnected CCB to be aborted. 		 */
if|if
condition|(
name|target
operator|==
operator|-
literal|1
condition|)
block|{
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|to_abort
condition|)
block|{
name|target
operator|=
name|cp
operator|->
name|target
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 *  If some target is to be selected, 		 *  prepare and start the selection. 		 */
if|if
condition|(
name|target
operator|!=
operator|-
literal|1
condition|)
block|{
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|np
operator|->
name|abrt_sel
operator|.
name|sel_id
operator|=
name|target
expr_stmt|;
name|np
operator|->
name|abrt_sel
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|head
operator|.
name|wval
expr_stmt|;
name|np
operator|->
name|abrt_sel
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|head
operator|.
name|sval
expr_stmt|;
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|np
operator|->
name|hcb_ba
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|sel_for_abort
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 *  Now look for a CCB to abort that haven't started yet. 		 *  Btw, the SCRIPTS processor is still stopped, so 		 *  we are not in race. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_BUSY
operator|&&
name|cp
operator|->
name|host_status
operator|!=
name|HS_NEGOTIATE
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cp
operator|->
name|to_abort
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 			 *    If we are using IMMEDIATE ARBITRATION, we donnot 			 *    want to cancel the last queued CCB, since the 			 *    SCRIPTS may have anticipated the selection. 			 */
if|if
condition|(
name|cp
operator|==
name|np
operator|->
name|last_cp
condition|)
block|{
name|cp
operator|->
name|to_abort
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|i
operator|=
literal|1
expr_stmt|;
comment|/* Means we have found some */
break|break;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* 			 *  We are done, so we donnot need 			 *  to synchronize with the SCRIPTS anylonger. 			 *  Remove the SEM flag from the ISTAT. 			 */
name|np
operator|->
name|istat_sem
operator|=
literal|0
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Compute index of next position in the start 		 *  queue the SCRIPTS intends to start and dequeue 		 *  all CCBs for that device that haven't been started. 		 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|np
operator|->
name|squeue_ba
operator|)
operator|/
literal|4
expr_stmt|;
name|i
operator|=
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 *  Make sure at least our IO to abort has been dequeued. 		 */
name|assert
argument_list|(
name|i
operator|&&
name|sym_get_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|)
operator|==
name|CAM_REQUEUE_REQ
argument_list|)
expr_stmt|;
comment|/* 		 *  Keep track in cam status of the reason of the abort. 		 */
if|if
condition|(
name|cp
operator|->
name|to_abort
operator|==
literal|2
condition|)
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
comment|/* 		 *  Complete with error everything that we have dequeued. 	 	 */
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  The SCRIPTS processor has selected a target 	 *  we may have some manual recovery to perform for. 	 */
case|case
name|SIR_TARGET_SELECTED
case|:
name|target
operator|=
operator|(
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|np
operator|->
name|abrt_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 *  If the target is to be reset, prepare a 		 *  M_RESET message and clear the to_reset flag 		 *  since we donnot expect this operation to fail. 		 */
if|if
condition|(
name|tp
operator|->
name|to_reset
condition|)
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_RESET
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Otherwise, look for some logical unit to be cleared. 		 */
if|if
condition|(
name|tp
operator|->
name|lun0p
operator|&&
name|tp
operator|->
name|lun0p
operator|->
name|to_clear
condition|)
name|lun
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|lunmp
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
name|SYM_CONF_MAX_LUN
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|&&
name|tp
operator|->
name|lunmp
index|[
name|k
index|]
operator|->
name|to_clear
condition|)
block|{
name|lun
operator|=
name|k
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 *  If a logical unit is to be cleared, prepare 		 *  an IDENTIFY(lun) + ABORT MESSAGE. 		 */
if|if
condition|(
name|lun
operator|!=
operator|-
literal|1
condition|)
block|{
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|lun
argument_list|)
decl_stmt|;
name|lp
operator|->
name|to_clear
operator|=
literal|0
expr_stmt|;
comment|/* We donnot expect to fail here */
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|lun
expr_stmt|;
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|=
name|M_ABORT
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Otherwise, look for some disconnected job to 		 *  abort for this target. 		 */
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|!=
name|HS_DISCONNECT
condition|)
continue|continue;
if|if
condition|(
name|cp
operator|->
name|target
operator|!=
name|target
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cp
operator|->
name|to_abort
condition|)
continue|continue;
name|i
operator|=
literal|1
expr_stmt|;
comment|/* Means we have some */
break|break;
block|}
comment|/* 		 *  If we have none, probably since the device has 		 *  completed the command before we won abitration, 		 *  send a M_ABORT message without IDENTIFY. 		 *  According to the specs, the device must just 		 *  disconnect the BUS and not abort any task. 		 */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_ABORT
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 *  We have some task to abort. 		 *  Set the IDENTIFY(lun) 		 */
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
comment|/* 		 *  If we want to abort an untagged command, we 		 *  will send an IDENTIFY + M_ABORT. 		 *  Otherwise (tagged command), we will send 		 *  an IDENTIFY + task attributes + ABORT TAG. 		 */
if|if
condition|(
name|cp
operator|->
name|tag
operator|==
name|NO_TAG
condition|)
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|=
name|M_ABORT
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|=
name|cp
operator|->
name|scsi_smsg
index|[
literal|1
index|]
expr_stmt|;
name|np
operator|->
name|abrt_msg
index|[
literal|2
index|]
operator|=
name|cp
operator|->
name|scsi_smsg
index|[
literal|2
index|]
expr_stmt|;
name|np
operator|->
name|abrt_msg
index|[
literal|3
index|]
operator|=
name|M_ABORT_TAG
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
literal|4
expr_stmt|;
block|}
comment|/* 		 *  Keep track of software timeout condition, since the 		 *  peripheral driver may not count retries on abort 		 *  conditions not due to timeout. 		 */
if|if
condition|(
name|cp
operator|->
name|to_abort
operator|==
literal|2
condition|)
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_CMD_TIMEOUT
argument_list|)
expr_stmt|;
name|cp
operator|->
name|to_abort
operator|=
literal|0
expr_stmt|;
comment|/* We donnot expect to fail here */
break|break;
comment|/* 	 *  The target has accepted our message and switched 	 *  to BUS FREE phase as we expected. 	 */
case|case
name|SIR_ABORT_SENT
case|:
name|target
operator|=
operator|(
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
comment|/* 		**  If we didn't abort anything, leave here. 		*/
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|==
name|M_ABORT
condition|)
break|break;
comment|/* 		 *  If we sent a M_RESET, then a hardware reset has 		 *  been performed by the target. 		 *  - Reset everything to async 8 bit 		 *  - Tell ourself to negotiate next time :-) 		 *  - Prepare to clear all disconnected CCBs for 		 *    this target from our task list (lun=task=-1) 		 */
name|lun
operator|=
operator|-
literal|1
expr_stmt|;
name|task
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|==
name|M_RESET
condition|)
block|{
name|tp
operator|->
name|head
operator|.
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|uval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 *  Otherwise, check for the LUN and TASK(s) 		 *  concerned by the cancelation. 		 *  If it is not ABORT_TAG then it is CLEAR_QUEUE 		 *  or an ABORT message :-) 		 */
else|else
block|{
name|lun
operator|=
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|1
index|]
operator|==
name|M_ABORT_TAG
condition|)
name|task
operator|=
name|np
operator|->
name|abrt_msg
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* 		 *  Complete all the CCBs the device should have 		 *  aborted due to our 'kiss of death' message. 		 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|np
operator|->
name|squeue_ba
operator|)
operator|/
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sym_clear_tasks
argument_list|(
name|np
argument_list|,
name|CAM_REQ_ABORTED
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 *  If we sent a BDR, make uper layer aware of that. 		 */
if|if
condition|(
name|np
operator|->
name|abrt_msg
index|[
literal|0
index|]
operator|==
name|M_RESET
condition|)
name|xpt_async
argument_list|(
name|AC_SENT_BDR
argument_list|,
name|np
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 *  Print to the log the message we intend to send. 	 */
if|if
condition|(
name|num
operator|==
name|SIR_TARGET_SELECTED
condition|)
block|{
name|PRINT_TARGET
argument_list|(
name|np
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|sym_printl_hex
argument_list|(
literal|"control msgout:"
argument_list|,
name|np
operator|->
name|abrt_msg
argument_list|,
name|np
operator|->
name|abrt_tbl
operator|.
name|size
argument_list|)
expr_stmt|;
name|np
operator|->
name|abrt_tbl
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|abrt_tbl
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Let the SCRIPTS processor continue. 	 */
name|OUTONB_STD
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Gerard's alchemy:) that deals with with the data  *  pointer for both MDP and the residual calculation.  *  *  I didn't want to bloat the code by more than 200  *  lignes for the handling of both MDP and the residual.  *  This has been achieved by using a data pointer  *  representation consisting in an index in the data  *  array (dp_sg) and a negative offset (dp_ofs) that  *  have the following meaning:  *  *  - dp_sg = SYM_CONF_MAX_SG  *    we are at the end of the data script.  *  - dp_sg< SYM_CONF_MAX_SG  *    dp_sg points to the next entry of the scatter array  *    we want to transfer.  *  - dp_ofs< 0  *    dp_ofs represents the residual of bytes of the  *    previous entry scatter entry we will send first.  *  - dp_ofs = 0  *    no residual to send first.  *  *  The function sym_evaluate_dp() accepts an arbitray  *  offset (basically from the MDP message) and returns  *  the corresponding values of dp_sg and dp_ofs.  */
end_comment

begin_function
specifier|static
name|int
name|sym_evaluate_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|u32
name|scr
parameter_list|,
name|int
modifier|*
name|ofs
parameter_list|)
block|{
name|u32
name|dp_scr
decl_stmt|;
name|int
name|dp_ofs
decl_stmt|,
name|dp_sg
decl_stmt|,
name|dp_sgmin
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|struct
name|sym_pmc
modifier|*
name|pm
decl_stmt|;
comment|/* 	 *  Compute the resulted data pointer in term of a script 	 *  address within some DATA script and a signed byte offset. 	 */
name|dp_scr
operator|=
name|scr
expr_stmt|;
name|dp_ofs
operator|=
operator|*
name|ofs
expr_stmt|;
if|if
condition|(
name|dp_scr
operator|==
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
condition|)
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm0
expr_stmt|;
elseif|else
if|if
condition|(
name|dp_scr
operator|==
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
condition|)
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm1
expr_stmt|;
else|else
name|pm
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pm
condition|)
block|{
name|dp_scr
operator|=
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|ret
argument_list|)
expr_stmt|;
name|dp_ofs
operator|-=
name|scr_to_cpu
argument_list|(
name|pm
operator|->
name|sg
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If we are auto-sensing, then we are done. 	 */
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
block|{
operator|*
name|ofs
operator|=
name|dp_ofs
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 *  Deduce the index of the sg entry. 	 *  Keep track of the index of the first valid entry. 	 *  If result is dp_sg = SYM_CONF_MAX_SG, then we are at the 	 *  end of the data. 	 */
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|goalp
argument_list|)
expr_stmt|;
name|dp_sg
operator|=
name|SYM_CONF_MAX_SG
expr_stmt|;
if|if
condition|(
name|dp_scr
operator|!=
name|tmp
condition|)
name|dp_sg
operator|-=
operator|(
name|tmp
operator|-
literal|8
operator|-
operator|(
name|int
operator|)
name|dp_scr
operator|)
operator|/
operator|(
literal|2
operator|*
literal|4
operator|)
expr_stmt|;
name|dp_sgmin
operator|=
name|SYM_CONF_MAX_SG
operator|-
name|cp
operator|->
name|segments
expr_stmt|;
comment|/* 	 *  Move to the sg entry the data pointer belongs to. 	 * 	 *  If we are inside the data area, we expect result to be: 	 * 	 *  Either, 	 *      dp_ofs = 0 and dp_sg is the index of the sg entry 	 *      the data pointer belongs to (or the end of the data) 	 *  Or, 	 *      dp_ofs< 0 and dp_sg is the index of the sg entry 	 *      the data pointer belongs to + 1. 	 */
if|if
condition|(
name|dp_ofs
operator|<
literal|0
condition|)
block|{
name|int
name|n
decl_stmt|;
while|while
condition|(
name|dp_sg
operator|>
name|dp_sgmin
condition|)
block|{
operator|--
name|dp_sg
expr_stmt|;
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|n
operator|=
name|dp_ofs
operator|+
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
operator|++
name|dp_sg
expr_stmt|;
break|break;
block|}
name|dp_ofs
operator|=
name|n
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dp_ofs
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|dp_sg
operator|<
name|SYM_CONF_MAX_SG
condition|)
block|{
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|dp_ofs
operator|-=
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
expr_stmt|;
operator|++
name|dp_sg
expr_stmt|;
if|if
condition|(
name|dp_ofs
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 	 *  Make sure the data pointer is inside the data area. 	 *  If not, return some error. 	 */
if|if
condition|(
name|dp_sg
operator|<
name|dp_sgmin
operator|||
operator|(
name|dp_sg
operator|==
name|dp_sgmin
operator|&&
name|dp_ofs
operator|<
literal|0
operator|)
condition|)
goto|goto
name|out_err
goto|;
elseif|else
if|if
condition|(
name|dp_sg
operator|>
name|SYM_CONF_MAX_SG
operator|||
operator|(
name|dp_sg
operator|==
name|SYM_CONF_MAX_SG
operator|&&
name|dp_ofs
operator|>
literal|0
operator|)
condition|)
goto|goto
name|out_err
goto|;
comment|/* 	 *  Save the extreme pointer if needed. 	 */
if|if
condition|(
name|dp_sg
operator|>
name|cp
operator|->
name|ext_sg
operator|||
operator|(
name|dp_sg
operator|==
name|cp
operator|->
name|ext_sg
operator|&&
name|dp_ofs
operator|>
name|cp
operator|->
name|ext_ofs
operator|)
condition|)
block|{
name|cp
operator|->
name|ext_sg
operator|=
name|dp_sg
expr_stmt|;
name|cp
operator|->
name|ext_ofs
operator|=
name|dp_ofs
expr_stmt|;
block|}
comment|/* 	 *  Return data. 	 */
operator|*
name|ofs
operator|=
name|dp_ofs
expr_stmt|;
return|return
name|dp_sg
return|;
name|out_err
label|:
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for MODIFY DATA POINTER MESSAGE  *  *  We also call this function on IGNORE WIDE RESIDUE  *  messages that do not match a SWIDE full condition.  *  Btw, we assume in that situation that such a message  *  is equivalent to a MODIFY DATA POINTER (offset=-1).  */
end_comment

begin_function
specifier|static
name|void
name|sym_modify_dp
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|ofs
parameter_list|)
block|{
name|int
name|dp_ofs
init|=
name|ofs
decl_stmt|;
name|u32
name|dp_scr
init|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
decl_stmt|;
name|u32
name|dp_ret
decl_stmt|;
name|u32
name|tmp
decl_stmt|;
name|u_char
name|hflags
decl_stmt|;
name|int
name|dp_sg
decl_stmt|;
name|struct
name|sym_pmc
modifier|*
name|pm
decl_stmt|;
comment|/* 	 *  Not supported for auto-sense. 	 */
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
goto|goto
name|out_reject
goto|;
comment|/* 	 *  Apply our alchemy:) (see comments in sym_evaluate_dp()), 	 *  to the resulted data pointer. 	 */
name|dp_sg
operator|=
name|sym_evaluate_dp
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dp_scr
argument_list|,
operator|&
name|dp_ofs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp_sg
operator|<
literal|0
condition|)
goto|goto
name|out_reject
goto|;
comment|/* 	 *  And our alchemy:) allows to easily calculate the data 	 *  script address we want to return for the next data phase. 	 */
name|dp_ret
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|goalp
argument_list|)
expr_stmt|;
name|dp_ret
operator|=
name|dp_ret
operator|-
literal|8
operator|-
operator|(
name|SYM_CONF_MAX_SG
operator|-
name|dp_sg
operator|)
operator|*
operator|(
literal|2
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* 	 *  If offset / scatter entry is zero we donnot need 	 *  a context for the new current data pointer. 	 */
if|if
condition|(
name|dp_ofs
operator|==
literal|0
condition|)
block|{
name|dp_scr
operator|=
name|dp_ret
expr_stmt|;
goto|goto
name|out_ok
goto|;
block|}
comment|/* 	 *  Get a context for the new current data pointer. 	 */
name|hflags
operator|=
name|INB
argument_list|(
name|HF_PRT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hflags
operator|&
name|HF_DP_SAVED
condition|)
name|hflags
operator|^=
name|HF_ACT_PM
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hflags
operator|&
name|HF_ACT_PM
operator|)
condition|)
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm0
expr_stmt|;
name|dp_scr
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|pm0_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pm
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|pm1
expr_stmt|;
name|dp_scr
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|pm1_data
argument_list|)
expr_stmt|;
block|}
name|hflags
operator|&=
operator|~
operator|(
name|HF_DP_SAVED
operator|)
expr_stmt|;
name|OUTB
argument_list|(
name|HF_PRT
argument_list|,
name|hflags
argument_list|)
expr_stmt|;
comment|/* 	 *  Set up the new current data pointer. 	 *  ofs< 0 there, and for the next data phase, we 	 *  want to transfer part of the data of the sg entry 	 *  corresponding to index dp_sg-1 prior to returning 	 *  to the main data script. 	 */
name|pm
operator|->
name|ret
operator|=
name|cpu_to_scr
argument_list|(
name|dp_ret
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
operator|-
literal|1
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
operator|-
literal|1
index|]
operator|.
name|size
argument_list|)
operator|+
name|dp_ofs
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
operator|-
name|dp_ofs
argument_list|)
expr_stmt|;
name|out_ok
label|:
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|dp_scr
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|out_reject
label|:
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip calculation of the data residual.  *  *  As I used to say, the requirement of data residual  *  in SCSI is broken, useless and cannot be achieved  *  without huge complexity.  *  But most OSes and even the official CAM require it.  *  When stupidity happens to be so widely spread inside  *  a community, it gets hard to convince.  *  *  Anyway, I don't care, since I am not going to use  *  any software that considers this data residual as  *  a relevant information. :)  */
end_comment

begin_function
specifier|static
name|int
name|sym_compute_residual
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|int
name|dp_sg
decl_stmt|,
name|dp_sgmin
decl_stmt|,
name|resid
init|=
literal|0
decl_stmt|;
name|int
name|dp_ofs
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Check for some data lost or just thrown away. 	 *  We are not required to be quite accurate in this 	 *  situation. Btw, if we are odd for output and the 	 *  device claims some more data, it may well happen 	 *  than our residual be zero. :-) 	 */
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
operator|(
name|XE_EXTRA_DATA
operator||
name|XE_SODL_UNRUN
operator||
name|XE_SWIDE_OVRUN
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
name|XE_EXTRA_DATA
condition|)
name|resid
operator|-=
name|cp
operator|->
name|extra_bytes
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
name|XE_SODL_UNRUN
condition|)
operator|++
name|resid
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|xerr_status
operator|&
name|XE_SWIDE_OVRUN
condition|)
operator|--
name|resid
expr_stmt|;
block|}
comment|/* 	 *  If all data has been transferred, 	 *  there is no residual. 	 */
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|lastp
operator|==
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|goalp
condition|)
return|return
name|resid
return|;
comment|/* 	 *  If no data transfer occurs, or if the data 	 *  pointer is weird, return full residual. 	 */
if|if
condition|(
name|cp
operator|->
name|startp
operator|==
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|lastp
operator|||
name|sym_evaluate_dp
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|lastp
argument_list|)
argument_list|,
operator|&
name|dp_ofs
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|cp
operator|->
name|data_len
return|;
block|}
comment|/* 	 *  If we were auto-sensing, then we are done. 	 */
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
block|{
return|return
operator|-
name|dp_ofs
return|;
block|}
comment|/* 	 *  We are now full comfortable in the computation 	 *  of the data residual (2's complement). 	 */
name|dp_sgmin
operator|=
name|SYM_CONF_MAX_SG
operator|-
name|cp
operator|->
name|segments
expr_stmt|;
name|resid
operator|=
operator|-
name|cp
operator|->
name|ext_ofs
expr_stmt|;
for|for
control|(
name|dp_sg
operator|=
name|cp
operator|->
name|ext_sg
init|;
name|dp_sg
operator|<
name|SYM_CONF_MAX_SG
condition|;
operator|++
name|dp_sg
control|)
block|{
name|u_int
name|tmp
init|=
name|scr_to_cpu
argument_list|(
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|dp_sg
index|]
operator|.
name|size
argument_list|)
decl_stmt|;
name|resid
operator|+=
operator|(
name|tmp
operator|&
literal|0xffffff
operator|)
expr_stmt|;
block|}
comment|/* 	 *  Hopefully, the result is not too wrong. 	 */
return|return
name|resid
return|;
block|}
end_function

begin_comment
comment|/*  *  Print out the content of a SCSI message.  */
end_comment

begin_function
specifier|static
name|int
name|sym_show_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|u_char
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
name|M_EXTENDED
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|-
literal|1
operator|>
name|msg
index|[
literal|1
index|]
condition|)
break|break;
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|msg
operator|&
literal|0xf0
operator|)
operator|==
literal|0x20
condition|)
block|{
name|printf
argument_list|(
literal|"-%x"
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sym_print_msg
parameter_list|(
name|ccb_p
name|cp
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
condition|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|label
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sym_show_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Negotiation for WIDE and SYNCHRONOUS DATA TRANSFER.  *  *  When we try to negotiate, we append the negotiation message  *  to the identify and (maybe) simple tag message.  *  The host status field is set to HS_NEGOTIATE to mark this  *  situation.  *  *  If the target doesn't answer this message immediately  *  (as required by the standard), the SIR_NEGO_FAILED interrupt  *  will be raised eventually.  *  The handler removes the HS_NEGOTIATE status, and sets the  *  negotiated value to the default (async / nowide).  *  *  If we receive a matching answer immediately, we check it  *  for validity, and set the values.  *  *  If we receive a Reject message immediately, we assume the  *  negotiation has failed, and fall back to standard values.  *  *  If we receive a negotiation message while not in HS_NEGOTIATE  *  state, it's a target initiated negotiation. We prepare a  *  (hopefully) valid answer, set our parameters, and send back  *  this answer to the target.  *  *  If the target doesn't fetch the answer (no message out phase),  *  we assume the negotiation has failed, and fall back to default  *  settings (SIR_NEGO_PROTO interrupt).  *  *  When we set the values, we adjust them in all ccbs belonging  *  to this target, in the controller's register, and in the "phys"  *  field of the controller's struct sym_hcb.  */
end_comment

begin_comment
comment|/*  *  chip handler for SYNCHRONOUS DATA TRANSFER REQUEST (SDTR) message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_sync_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|ofs
decl_stmt|,
name|per
decl_stmt|,
name|fak
decl_stmt|,
name|div
decl_stmt|;
name|int
name|req
init|=
literal|1
decl_stmt|;
comment|/* 	 *  Synchronous request message received. 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msgin"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * request or answer ? 	 */
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|nego_status
operator|&&
name|cp
operator|->
name|nego_status
operator|!=
name|NS_SYNC
condition|)
goto|goto
name|reject_it
goto|;
name|req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  get requested values. 	 */
name|chg
operator|=
literal|0
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|msgin
index|[
literal|4
index|]
expr_stmt|;
comment|/* 	 *  check values against our limits. 	 */
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|np
operator|->
name|maxoffs
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|minsync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
expr_stmt|;
block|}
block|}
block|}
name|div
operator|=
name|fak
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ofs
operator|&&
name|sym_getsync
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|per
argument_list|,
operator|&
name|div
argument_list|,
operator|&
name|fak
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|reject_it
goto|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sdtr: ofs=%d per=%d div=%d fak=%d chg=%d.\n"
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|div
argument_list|,
name|fak
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  This was an answer message 	 */
if|if
condition|(
name|req
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chg
condition|)
comment|/* Answer wasn't acceptable. */
goto|goto
name|reject_it
goto|;
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  It was a request. Set value and 	 *  prepare an answer message 	 */
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|per
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
name|ofs
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_SYNC
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|sdtr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reject_it
label|:
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for PARALLEL PROTOCOL REQUEST (PPR) message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_ppr_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|ofs
decl_stmt|,
name|per
decl_stmt|,
name|fak
decl_stmt|,
name|dt
decl_stmt|,
name|div
decl_stmt|,
name|wide
decl_stmt|;
name|int
name|req
init|=
literal|1
decl_stmt|;
comment|/* 	 * Synchronous request message received. 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"ppr msgin"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 *  get requested values. 	 */
name|chg
operator|=
literal|0
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|msgin
index|[
literal|5
index|]
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|msgin
index|[
literal|6
index|]
expr_stmt|;
name|dt
operator|=
name|np
operator|->
name|msgin
index|[
literal|7
index|]
operator|&
name|PPR_OPT_DT
expr_stmt|;
comment|/* 	 * request or answer ? 	 */
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|nego_status
operator|&&
name|cp
operator|->
name|nego_status
operator|!=
name|NS_PPR
condition|)
goto|goto
name|reject_it
goto|;
name|req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  check values against our limits. 	 */
if|if
condition|(
name|wide
operator|>
name|np
operator|->
name|maxwide
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wide
operator|||
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
operator|)
condition|)
name|dt
operator|&=
operator|~
name|PPR_OPT_DT
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|wide
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_U3EN
operator|)
condition|)
comment|/* Broken U3EN bit not supported */
name|dt
operator|&=
operator|~
name|PPR_OPT_DT
expr_stmt|;
if|if
condition|(
name|dt
operator|!=
operator|(
name|np
operator|->
name|msgin
index|[
literal|7
index|]
operator|&
name|PPR_OPT_MASK
operator|)
condition|)
name|chg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|np
operator|->
name|maxoffs_dt
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|maxoffs_dt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ofs
operator|>
name|np
operator|->
name|maxoffs
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|ofs
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|ofs
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ofs
condition|)
block|{
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|minsync_dt
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync_dt
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|per
operator|<
name|np
operator|->
name|minsync
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|per
operator|<
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|per
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
expr_stmt|;
block|}
block|}
block|}
name|div
operator|=
name|fak
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ofs
operator|&&
name|sym_getsync
argument_list|(
name|np
argument_list|,
name|dt
argument_list|,
name|per
argument_list|,
operator|&
name|div
argument_list|,
operator|&
name|fak
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|reject_it
goto|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppr: "
literal|"dt=%x ofs=%d per=%d wide=%d div=%d fak=%d chg=%d.\n"
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  It was an answer. 	 */
if|if
condition|(
name|req
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chg
condition|)
comment|/* Answer wasn't acceptable */
goto|goto
name|reject_it
goto|;
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  It was a request. Set value and 	 *  prepare an answer message 	 */
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|dt
argument_list|,
name|ofs
argument_list|,
name|per
argument_list|,
name|wide
argument_list|,
name|div
argument_list|,
name|fak
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|6
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_PPR_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|per
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|5
index|]
operator|=
name|ofs
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|6
index|]
operator|=
name|wide
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|7
index|]
operator|=
name|dt
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_PPR
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"ppr msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|ppr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reject_it
label|:
name|sym_setpprot
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  If it was a device response that should result in 	 *  ST, we may want to try a legacy negotiation later. 	 */
if|if
condition|(
operator|!
name|req
operator|&&
operator|!
name|dt
condition|)
block|{
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|wide
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|per
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|ofs
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  chip handler for WIDE DATA TRANSFER REQUEST (WDTR) message.  */
end_comment

begin_function
specifier|static
name|void
name|sym_wide_nego
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|u_char
name|chg
decl_stmt|,
name|wide
decl_stmt|;
name|int
name|req
init|=
literal|1
decl_stmt|;
comment|/* 	 *  Wide request message received. 	 */
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"wide msgin"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * Is it a request from the device? 	 */
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
block|{
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|nego_status
operator|&&
name|cp
operator|->
name|nego_status
operator|!=
name|NS_WIDE
condition|)
goto|goto
name|reject_it
goto|;
name|req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  get requested values. 	 */
name|chg
operator|=
literal|0
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|msgin
index|[
literal|3
index|]
expr_stmt|;
comment|/* 	 *  check values against driver limits. 	 */
if|if
condition|(
name|wide
operator|>
name|np
operator|->
name|maxwide
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
block|}
if|if
condition|(
name|req
condition|)
block|{
if|if
condition|(
name|wide
operator|>
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
condition|)
block|{
name|chg
operator|=
literal|1
expr_stmt|;
name|wide
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wdtr: wide=%d chg=%d.\n"
argument_list|,
name|wide
argument_list|,
name|chg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This was an answer message 	 */
if|if
condition|(
name|req
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chg
condition|)
comment|/*  Answer wasn't acceptable. */
goto|goto
name|reject_it
goto|;
name|sym_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|)
expr_stmt|;
comment|/* 		 * Negotiate for SYNC immediately after WIDE response. 		 * This allows to negotiate for both WIDE and SYNC on 		 * a single SCSI command (Suggested by Justin Gibbs). 		 */
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
condition|)
block|{
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_SYNC_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|4
index|]
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"sync msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|nego_status
operator|=
name|NS_SYNC
expr_stmt|;
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_NEGOTIATE
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|sdtr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
comment|/* 	 *  It was a request, set value and 	 *  prepare an answer message 	 */
name|sym_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|wide
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_EXTENDED
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|2
index|]
operator|=
name|M_X_WIDE_REQ
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|3
index|]
operator|=
name|wide
expr_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
name|NS_WIDE
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_NEGO
condition|)
block|{
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"wide msgout"
argument_list|,
name|np
operator|->
name|msgout
argument_list|)
expr_stmt|;
block|}
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|wdtr_resp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|reject_it
label|:
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Reset SYNC or WIDE to default settings.  *  *  Called when a negotiation does not succeed either  *  on rejection or on protocol error.  *  *  If it was a PPR that made problems, we may want to  *  try a legacy negotiation later.  */
end_comment

begin_function
specifier|static
name|void
name|sym_nego_default
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
comment|/* 	 *  any error in negotiation: 	 *  fall back to default mode. 	 */
switch|switch
condition|(
name|cp
operator|->
name|nego_status
condition|)
block|{
case|case
name|NS_PPR
case|:
if|#
directive|if
literal|0
block|sym_setpprot (np, cp, 0, 0, 0, 0, 0, 0);
else|#
directive|else
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|<
name|np
operator|->
name|minsync
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|>
name|np
operator|->
name|maxoffs
condition|)
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|NS_SYNC
case|:
name|sym_setsync
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_WIDE
case|:
name|sym_setwide
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|np
operator|->
name|msgin
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip handler for MESSAGE REJECT received in response to  *  a WIDE or SYNCHRONOUS negotiation.  */
end_comment

begin_function
specifier|static
name|void
name|sym_nego_rejected
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|sym_nego_default
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  chip exception handler for programmed interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|sym_int_sir
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_char
name|num
init|=
name|INB
argument_list|(
name|nc_dsps
argument_list|)
decl_stmt|;
name|u32
name|dsa
init|=
name|INL
argument_list|(
name|nc_dsa
argument_list|)
decl_stmt|;
name|ccb_p
name|cp
init|=
name|sym_ccb_from_dsa
argument_list|(
name|np
argument_list|,
name|dsa
argument_list|)
decl_stmt|;
name|u_char
name|target
init|=
name|INB
argument_list|(
name|nc_sdid
argument_list|)
operator|&
literal|0x0f
decl_stmt|;
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TINY
condition|)
name|printf
argument_list|(
literal|"I#%d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* 	 *  Command has been completed with error condition 	 *  or has been auto-sensed. 	 */
case|case
name|SIR_COMPLETE_ERROR
case|:
name|sym_complete_error
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  The C code is currently trying to recover from something. 	 *  Typically, user want to abort some command. 	 */
case|case
name|SIR_SCRIPT_STOPPED
case|:
case|case
name|SIR_TARGET_SELECTED
case|:
case|case
name|SIR_ABORT_SENT
case|:
name|sym_sir_task_recovery
argument_list|(
name|np
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  The device didn't go to MSG OUT phase after having 	 *  been selected with ATN. We donnot want to handle 	 *  that. 	 */
case|case
name|SIR_SEL_ATN_NO_MSG_OUT
case|:
name|printf
argument_list|(
literal|"%s:%d: No MSG OUT phase after selection with ATN.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
goto|goto
name|out_stuck
goto|;
comment|/* 	 *  The device didn't switch to MSG IN phase after 	 *  having reseleted the initiator. 	 */
case|case
name|SIR_RESEL_NO_MSG_IN
case|:
name|printf
argument_list|(
literal|"%s:%d: No MSG IN phase after reselection.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
goto|goto
name|out_stuck
goto|;
comment|/* 	 *  After reselection, the device sent a message that wasn't 	 *  an IDENTIFY. 	 */
case|case
name|SIR_RESEL_NO_IDENTIFY
case|:
name|printf
argument_list|(
literal|"%s:%d: No IDENTIFY after reselection.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
goto|goto
name|out_stuck
goto|;
comment|/* 	 *  The device reselected a LUN we donnot know about. 	 */
case|case
name|SIR_RESEL_BAD_LUN
case|:
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_RESET
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The device reselected for an untagged nexus and we 	 *  haven't any. 	 */
case|case
name|SIR_RESEL_BAD_I_T_L
case|:
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_ABORT
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The device reselected for a tagged nexus that we donnot 	 *  have. 	 */
case|case
name|SIR_RESEL_BAD_I_T_L_Q
case|:
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_ABORT_TAG
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The SCRIPTS let us know that the device has grabbed 	 *  our message and will abort the job. 	 */
case|case
name|SIR_RESEL_ABORTED
case|:
name|np
operator|->
name|lastmsg
operator|=
name|np
operator|->
name|msgout
index|[
literal|0
index|]
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%d: message %x sent on bad reselection.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|target
argument_list|,
name|np
operator|->
name|lastmsg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  The SCRIPTS let us know that a message has been 	 *  successfully sent to the device. 	 */
case|case
name|SIR_MSG_OUT_DONE
case|:
name|np
operator|->
name|lastmsg
operator|=
name|np
operator|->
name|msgout
index|[
literal|0
index|]
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_NOOP
expr_stmt|;
comment|/* Should we really care of that */
if|if
condition|(
name|np
operator|->
name|lastmsg
operator|==
name|M_PARITY
operator|||
name|np
operator|->
name|lastmsg
operator|==
name|M_ID_ERROR
condition|)
block|{
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|->
name|xerr_status
operator|&=
operator|~
name|XE_PARITY_ERR
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|->
name|xerr_status
condition|)
name|OUTOFFB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  The device didn't send a GOOD SCSI status. 	 *  We may have some work to do prior to allow 	 *  the SCRIPTS processor to continue. 	 */
case|case
name|SIR_BAD_SCSI_STATUS
case|:
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|out
goto|;
name|sym_sir_bad_scsi_status
argument_list|(
name|np
argument_list|,
name|num
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  We are asked by the SCRIPTS to prepare a 	 *  REJECT message. 	 */
case|case
name|SIR_REJECT_TO_SEND
case|:
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"M_REJECT to send for "
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|np
operator|->
name|msgout
index|[
literal|0
index|]
operator|=
name|M_REJECT
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 	 *  We have been ODD at the end of a DATA IN 	 *  transfer and the device didn't send a 	 *  IGNORE WIDE RESIDUE message. 	 *  It is a data overrun condition. 	 */
case|case
name|SIR_SWIDE_OVERRUN
case|:
if|if
condition|(
name|cp
condition|)
block|{
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_SWIDE_OVRUN
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  We have been ODD at the end of a DATA OUT 	 *  transfer. 	 *  It is a data underrun condition. 	 */
case|case
name|SIR_SODL_UNDERRUN
case|:
if|if
condition|(
name|cp
condition|)
block|{
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_SODL_UNRUN
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  The device wants us to tranfer more data than 	 *  expected or in the wrong direction. 	 *  The number of extra bytes is in scratcha. 	 *  It is a data overrun condition. 	 */
case|case
name|SIR_DATA_OVERRUN
case|:
if|if
condition|(
name|cp
condition|)
block|{
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_EXTRA_DATA
expr_stmt|;
name|cp
operator|->
name|extra_bytes
operator|+=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  The device switched to an illegal phase (4/5). 	 */
case|case
name|SIR_BAD_PHASE
case|:
if|if
condition|(
name|cp
condition|)
block|{
name|OUTONB
argument_list|(
name|HF_PRT
argument_list|,
name|HF_EXT_ERR
argument_list|)
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator||=
name|XE_BAD_PHASE
expr_stmt|;
block|}
goto|goto
name|out
goto|;
comment|/* 	 *  We received a message. 	 */
case|case
name|SIR_MSG_RECEIVED
case|:
if|if
condition|(
operator|!
name|cp
condition|)
goto|goto
name|out_stuck
goto|;
switch|switch
condition|(
name|np
operator|->
name|msgin
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 *  We received an extended message. 		 *  We handle MODIFY DATA POINTER, SDTR, WDTR 		 *  and reject all other extended messages. 		 */
case|case
name|M_EXTENDED
case|:
switch|switch
condition|(
name|np
operator|->
name|msgin
index|[
literal|2
index|]
condition|)
block|{
case|case
name|M_X_MODIFY_DP
case|:
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_POINTER
condition|)
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"modify DP"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|np
operator|->
name|msgin
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|+
operator|(
name|np
operator|->
name|msgin
index|[
literal|4
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|np
operator|->
name|msgin
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
name|np
operator|->
name|msgin
index|[
literal|6
index|]
operator|)
expr_stmt|;
name|sym_modify_dp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_X_SYNC_REQ
case|:
name|sym_sync_nego
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_X_PPR_REQ
case|:
name|sym_ppr_nego
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_X_WIDE_REQ
case|:
name|sym_wide_nego
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
default|default:
goto|goto
name|out_reject
goto|;
block|}
break|break;
comment|/* 		 *  We received a 1/2 byte message not handled from SCRIPTS. 		 *  We are only expecting MESSAGE REJECT and IGNORE WIDE 		 *  RESIDUE messages that haven't been anticipated by 		 *  SCRIPTS on SWIDE full condition. Unanticipated IGNORE 		 *  WIDE RESIDUE messages are aliased as MODIFY DP (-1). 		 */
case|case
name|M_IGN_RESIDUE
case|:
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_POINTER
condition|)
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"ign wide residue"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|sym_modify_dp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|M_REJECT
case|:
if|if
condition|(
name|INB
argument_list|(
name|HS_PRT
argument_list|)
operator|==
name|HS_NEGOTIATE
condition|)
name|sym_nego_rejected
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"M_REJECT received (%x:%x).\n"
argument_list|,
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|lastmsg
argument_list|)
argument_list|,
name|np
operator|->
name|msgout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out_clrack
goto|;
break|break;
default|default:
goto|goto
name|out_reject
goto|;
block|}
break|break;
comment|/* 	 *  We received an unknown message. 	 *  Ignore all MSG IN phases and reject it. 	 */
case|case
name|SIR_MSG_WEIRD
case|:
name|sym_print_msg
argument_list|(
name|cp
argument_list|,
literal|"WEIRD message received"
argument_list|,
name|np
operator|->
name|msgin
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|msg_weird
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 *  Negotiation failed. 	 *  Target does not send us the reply. 	 *  Remove the HS_NEGOTIATE status. 	 */
case|case
name|SIR_NEGO_FAILED
case|:
name|OUTB
argument_list|(
name|HS_PRT
argument_list|,
name|HS_BUSY
argument_list|)
expr_stmt|;
comment|/* 	 *  Negotiation failed. 	 *  Target does not want answer message. 	 */
case|case
name|SIR_NEGO_PROTO
case|:
name|sym_nego_default
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
empty_stmt|;
name|out
label|:
name|OUTONB_STD
argument_list|()
expr_stmt|;
return|return;
name|out_reject
label|:
name|OUTL_DSP
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|msg_bad
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|out_clrack
label|:
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|clrack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|out_stuck
label|:
return|return;
block|}
end_function

begin_comment
comment|/*  *  Acquire a control block  */
end_comment

begin_function
specifier|static
name|ccb_p
name|sym_get_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|,
name|u_char
name|tag_order
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|)
decl_stmt|;
name|u_short
name|tag
init|=
name|NO_TAG
decl_stmt|;
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
init|=
operator|(
name|ccb_p
operator|)
name|NULL
decl_stmt|;
comment|/* 	 *  Look for a free CCB 	 */
if|if
condition|(
name|sym_que_empty
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
goto|goto
name|out
goto|;
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  If the LCB is not yet available and the LUN 	 *  has been probed ok, try to allocate the LCB. 	 */
if|if
condition|(
operator|!
name|lp
operator|&&
name|sym_is_bit
argument_list|(
name|tp
operator|->
name|lun_map
argument_list|,
name|ln
argument_list|)
condition|)
block|{
name|lp
operator|=
name|sym_alloc_lcb
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
goto|goto
name|out_free
goto|;
block|}
comment|/* 	 *  If the LCB is not available here, then the 	 *  logical unit is not yet discovered. For those 	 *  ones only accept 1 SCSI IO per logical unit, 	 *  since we cannot allow disconnections. 	 */
if|if
condition|(
operator|!
name|lp
condition|)
block|{
if|if
condition|(
operator|!
name|sym_is_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|ln
argument_list|)
condition|)
name|sym_set_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|ln
argument_list|)
expr_stmt|;
else|else
goto|goto
name|out_free
goto|;
block|}
else|else
block|{
comment|/* 		 *  If we have been asked for a tagged command. 		 */
if|if
condition|(
name|tag_order
condition|)
block|{
comment|/* 			 *  Debugging purpose. 			 */
name|assert
argument_list|(
name|lp
operator|->
name|busy_itl
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 *  Allocate resources for tags if not yet. 			 */
if|if
condition|(
operator|!
name|lp
operator|->
name|cb_tags
condition|)
block|{
name|sym_alloc_lcb_tags
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|cb_tags
condition|)
goto|goto
name|out_free
goto|;
block|}
comment|/* 			 *  Get a tag for this SCSI IO and set up 			 *  the CCB bus address for reselection, 			 *  and count it for this LUN. 			 *  Toggle reselect path to tagged. 			 */
if|if
condition|(
name|lp
operator|->
name|busy_itlq
operator|<
name|SYM_CONF_MAX_TASK
condition|)
block|{
name|tag
operator|=
name|lp
operator|->
name|cb_tags
index|[
name|lp
operator|->
name|ia_tag
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|lp
operator|->
name|ia_tag
operator|==
name|SYM_CONF_MAX_TASK
condition|)
name|lp
operator|->
name|ia_tag
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|itlq_tbl
index|[
name|tag
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
operator|++
name|lp
operator|->
name|busy_itlq
expr_stmt|;
name|lp
operator|->
name|head
operator|.
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|resel_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|out_free
goto|;
block|}
comment|/* 		 *  This command will not be tagged. 		 *  If we already have either a tagged or untagged 		 *  one, refuse to overlap this untagged one. 		 */
else|else
block|{
comment|/* 			 *  Debugging purpose. 			 */
name|assert
argument_list|(
name|lp
operator|->
name|busy_itl
operator|==
literal|0
operator|&&
name|lp
operator|->
name|busy_itlq
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 *  Count this nexus for this LUN. 			 *  Set up the CCB bus address for reselection. 			 *  Toggle reselect path to untagged. 			 */
if|if
condition|(
operator|++
name|lp
operator|->
name|busy_itl
operator|==
literal|1
condition|)
block|{
name|lp
operator|->
name|head
operator|.
name|itl_task_sa
operator|=
name|cpu_to_scr
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
name|lp
operator|->
name|head
operator|.
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|resel_no_tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|out_free
goto|;
block|}
block|}
comment|/* 	 *  Put the CCB into the busy queue. 	 */
name|sym_insque_tail
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  Remember all informations needed to free this CCB. 	 */
name|cp
operator|->
name|to_abort
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|cp
operator|->
name|target
operator|=
name|tn
expr_stmt|;
name|cp
operator|->
name|lun
operator|=
name|ln
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
block|{
name|PRINT_LUN
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ccb @%p using tag %d.\n"
argument_list|,
name|cp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|cp
return|;
name|out_free
label|:
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  Release one control block  */
end_comment

begin_function
specifier|static
name|void
name|sym_free_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_TAGS
condition|)
block|{
name|PRINT_LUN
argument_list|(
name|np
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ccb @%p freeing tag %d.\n"
argument_list|,
name|cp
argument_list|,
name|cp
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If LCB available, 	 */
if|if
condition|(
name|lp
condition|)
block|{
comment|/* 		 *  If tagged, release the tag, set the relect path 		 */
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
condition|)
block|{
comment|/* 			 *  Free the tag value. 			 */
name|lp
operator|->
name|cb_tags
index|[
name|lp
operator|->
name|if_tag
index|]
operator|=
name|cp
operator|->
name|tag
expr_stmt|;
if|if
condition|(
operator|++
name|lp
operator|->
name|if_tag
operator|==
name|SYM_CONF_MAX_TASK
condition|)
name|lp
operator|->
name|if_tag
operator|=
literal|0
expr_stmt|;
comment|/* 			 *  Make the reselect path invalid, 			 *  and uncount this CCB. 			 */
name|lp
operator|->
name|itlq_tbl
index|[
name|cp
operator|->
name|tag
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|bad_itlq_ba
argument_list|)
expr_stmt|;
operator|--
name|lp
operator|->
name|busy_itlq
expr_stmt|;
block|}
else|else
block|{
comment|/* Untagged */
comment|/* 			 *  Make the reselect path invalid, 			 *  and uncount this CCB. 			 */
name|lp
operator|->
name|head
operator|.
name|itl_task_sa
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|bad_itl_ba
argument_list|)
expr_stmt|;
operator|--
name|lp
operator|->
name|busy_itl
expr_stmt|;
block|}
comment|/* 		 *  If no JOB active, make the LUN reselect path invalid. 		 */
if|if
condition|(
name|lp
operator|->
name|busy_itlq
operator|==
literal|0
operator|&&
name|lp
operator|->
name|busy_itl
operator|==
literal|0
condition|)
name|lp
operator|->
name|head
operator|.
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|resel_bad_lun
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Otherwise, we only accept 1 IO per LUN. 	 *  Clear the bit that keeps track of this IO. 	 */
else|else
name|sym_clr_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 *  We donnot queue more than 1 ccb per target 	 *  with negotiation at any time. If this ccb was 	 *  used for negotiation, clear this info in the tcb. 	 */
if|if
condition|(
name|cp
operator|==
name|tp
operator|->
name|nego_cp
condition|)
name|tp
operator|->
name|nego_cp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *  If we just complete the last queued CCB, 	 *  clear this info that is no longer relevant. 	 */
if|if
condition|(
name|cp
operator|==
name|np
operator|->
name|last_cp
condition|)
name|np
operator|->
name|last_cp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *  Unmap user data from DMA map if needed. 	 */
if|if
condition|(
name|cp
operator|->
name|dmamapped
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
name|cp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|cp
operator|->
name|dmamapped
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 *  Make this CCB available. 	 */
name|cp
operator|->
name|cam_ccb
operator|=
name|NULL
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|HS_IDLE
expr_stmt|;
name|sym_remque
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Allocate a CCB from memory and initialize its fixed part.  */
end_comment

begin_function
specifier|static
name|ccb_p
name|sym_alloc_ccb
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|ccb_p
name|cp
init|=
name|NULL
decl_stmt|;
name|int
name|hcode
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Prevent from allocating more CCBs than we can 	 *  queue to the controller. 	 */
if|if
condition|(
name|np
operator|->
name|actccbs
operator|>=
name|SYM_CONF_MAX_START
condition|)
return|return
name|NULL
return|;
comment|/* 	 *  Allocate memory for this CCB. 	 */
name|cp
operator|=
name|sym_calloc_dma
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_ccb
argument_list|)
argument_list|,
literal|"CCB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
return|return
name|NULL
return|;
comment|/* 	 *  Allocate a bounce buffer for sense data. 	 */
name|cp
operator|->
name|sns_bbuf
operator|=
name|sym_calloc_dma
argument_list|(
name|SYM_SNS_BBUF_LEN
argument_list|,
literal|"SNS_BBUF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
operator|->
name|sns_bbuf
condition|)
goto|goto
name|out_free
goto|;
comment|/* 	 *  Allocate a map for the DMA of user data. 	 */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|cp
operator|->
name|dmamap
argument_list|)
condition|)
goto|goto
name|out_free
goto|;
comment|/* 	 *  Count it. 	 */
name|np
operator|->
name|actccbs
operator|++
expr_stmt|;
comment|/* 	 * Initialize the callout. 	 */
name|callout_init
argument_list|(
operator|&
name|cp
operator|->
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 *  Compute the bus address of this ccb. 	 */
name|cp
operator|->
name|ccb_ba
operator|=
name|vtobus
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 *  Insert this ccb into the hashed list. 	 */
name|hcode
operator|=
name|CCB_HASH_CODE
argument_list|(
name|cp
operator|->
name|ccb_ba
argument_list|)
expr_stmt|;
name|cp
operator|->
name|link_ccbh
operator|=
name|np
operator|->
name|ccbh
index|[
name|hcode
index|]
expr_stmt|;
name|np
operator|->
name|ccbh
index|[
name|hcode
index|]
operator|=
name|cp
expr_stmt|;
comment|/* 	 *  Initialize the start and restart actions. 	 */
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Initilialyze some other fields. 	 */
name|cp
operator|->
name|phys
operator|.
name|smsg_ext
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|HCB_BA
argument_list|(
name|np
argument_list|,
name|msgin
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Chain into free ccb queue. 	 */
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
name|out_free
label|:
if|if
condition|(
name|cp
operator|->
name|sns_bbuf
condition|)
name|sym_mfree_dma
argument_list|(
name|cp
operator|->
name|sns_bbuf
argument_list|,
name|SYM_SNS_BBUF_LEN
argument_list|,
literal|"SNS_BBUF"
argument_list|)
expr_stmt|;
name|sym_mfree_dma
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|,
literal|"CCB"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  Look up a CCB from a DSA value.  */
end_comment

begin_function
specifier|static
name|ccb_p
name|sym_ccb_from_dsa
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u32
name|dsa
parameter_list|)
block|{
name|int
name|hcode
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|hcode
operator|=
name|CCB_HASH_CODE
argument_list|(
name|dsa
argument_list|)
expr_stmt|;
name|cp
operator|=
name|np
operator|->
name|ccbh
index|[
name|hcode
index|]
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|ccb_ba
operator|==
name|dsa
condition|)
break|break;
name|cp
operator|=
name|cp
operator|->
name|link_ccbh
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/*  *  Target control block initialisation.  *  Nothing important to do at the moment.  */
end_comment

begin_function
specifier|static
name|void
name|sym_init_tcb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|)
block|{
comment|/* 	 *  Check some alignments required by the chip. 	 */
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_sxfer
argument_list|)
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|sval
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_scntl3
argument_list|)
operator|^
name|offsetof
argument_list|(
expr|struct
name|sym_tcb
argument_list|,
name|head
operator|.
name|wval
argument_list|)
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Lun control block allocation and initialization.  */
end_comment

begin_function
specifier|static
name|lcb_p
name|sym_alloc_lcb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|)
decl_stmt|;
comment|/* 	 *  Already done, just return. 	 */
if|if
condition|(
name|lp
condition|)
return|return
name|lp
return|;
comment|/* 	 *  Check against some race. 	 */
name|assert
argument_list|(
operator|!
name|sym_is_bit
argument_list|(
name|tp
operator|->
name|busy0_map
argument_list|,
name|ln
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Initialize the target control block if not yet. 	 */
name|sym_init_tcb
argument_list|(
name|np
argument_list|,
name|tn
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate the LCB bus address array. 	 *  Compute the bus address of this table. 	 */
if|if
condition|(
name|ln
operator|&&
operator|!
name|tp
operator|->
name|luntbl
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tp
operator|->
name|luntbl
operator|=
name|sym_calloc_dma
argument_list|(
literal|256
argument_list|,
literal|"LUNTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|luntbl
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|tp
operator|->
name|luntbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|badlun_sa
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|luntbl_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|tp
operator|->
name|luntbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Allocate the table of pointers for LUN(s)> 0, if needed. 	 */
if|if
condition|(
name|ln
operator|&&
operator|!
name|tp
operator|->
name|lunmp
condition|)
block|{
name|tp
operator|->
name|lunmp
operator|=
name|sym_calloc
argument_list|(
name|SYM_CONF_MAX_LUN
operator|*
sizeof|sizeof
argument_list|(
name|lcb_p
argument_list|)
argument_list|,
literal|"LUNMP"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|lunmp
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* 	 *  Allocate the lcb. 	 *  Make it available to the chip. 	 */
name|lp
operator|=
name|sym_calloc_dma
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sym_lcb
argument_list|)
argument_list|,
literal|"LCB"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|ln
condition|)
block|{
name|tp
operator|->
name|lunmp
index|[
name|ln
index|]
operator|=
name|lp
expr_stmt|;
name|tp
operator|->
name|luntbl
index|[
name|ln
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|lun0p
operator|=
name|lp
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|lun0_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Let the itl task point to error handling. 	 */
name|lp
operator|->
name|head
operator|.
name|itl_task_sa
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|bad_itl_ba
argument_list|)
expr_stmt|;
comment|/* 	 *  Set the reselect pattern to our default. :) 	 */
name|lp
operator|->
name|head
operator|.
name|resel_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|resel_bad_lun
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Set user capabilities. 	 */
name|lp
operator|->
name|user_flags
operator|=
name|tp
operator|->
name|usrflags
operator|&
operator|(
name|SYM_DISC_ENABLED
operator||
name|SYM_TAGS_ENABLED
operator|)
expr_stmt|;
name|fail
label|:
return|return
name|lp
return|;
block|}
end_function

begin_comment
comment|/*  *  Allocate LCB resources for tagged command queuing.  */
end_comment

begin_function
specifier|static
name|void
name|sym_alloc_lcb_tags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|tn
parameter_list|,
name|u_char
name|ln
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
decl_stmt|;
name|lcb_p
name|lp
init|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ln
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 *  If LCB not available, try to allocate it. 	 */
if|if
condition|(
operator|!
name|lp
operator|&&
operator|!
operator|(
name|lp
operator|=
name|sym_alloc_lcb
argument_list|(
name|np
argument_list|,
name|tn
argument_list|,
name|ln
argument_list|)
operator|)
condition|)
return|return;
comment|/* 	 *  Allocate the task table and and the tag allocation 	 *  circular buffer. We want both or none. 	 */
name|lp
operator|->
name|itlq_tbl
operator|=
name|sym_calloc_dma
argument_list|(
name|SYM_CONF_MAX_TASK
operator|*
literal|4
argument_list|,
literal|"ITLQ_TBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|itlq_tbl
condition|)
return|return;
name|lp
operator|->
name|cb_tags
operator|=
name|sym_calloc
argument_list|(
name|SYM_CONF_MAX_TASK
argument_list|,
literal|"CB_TAGS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|cb_tags
condition|)
block|{
name|sym_mfree_dma
argument_list|(
name|lp
operator|->
name|itlq_tbl
argument_list|,
name|SYM_CONF_MAX_TASK
operator|*
literal|4
argument_list|,
literal|"ITLQ_TBL"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|itlq_tbl
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Initialize the task table with invalid entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TASK
condition|;
name|i
operator|++
control|)
name|lp
operator|->
name|itlq_tbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|notask_ba
argument_list|)
expr_stmt|;
comment|/* 	 *  Fill up the tag buffer with tag numbers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TASK
condition|;
name|i
operator|++
control|)
name|lp
operator|->
name|cb_tags
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* 	 *  Make the task table available to SCRIPTS, 	 *  And accept tagged commands now. 	 */
name|lp
operator|->
name|head
operator|.
name|itlq_tbl_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|lp
operator|->
name|itlq_tbl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Test the pci bus snoop logic :-(  *  *  Has to be called with interrupts disabled.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYM_CONF_IOMAPPED
end_ifndef

begin_function
specifier|static
name|int
name|sym_regtest
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
specifier|register
specifier|volatile
name|u32
name|data
decl_stmt|;
comment|/* 	 *  chip registers may NOT be cached. 	 *  write 0xffffffff to a read only register area, 	 *  and try to read it back. 	 */
name|data
operator|=
literal|0xffffffff
expr_stmt|;
name|OUTL_OFF
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_dstat
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|INL_OFF
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|sym_reg
argument_list|,
name|nc_dstat
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|data
operator|==
literal|0xffffffff
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|data
operator|&
literal|0xe2f0fffd
operator|)
operator|!=
literal|0x02000080
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
literal|"CACHE TEST FAILED: reg dstat-sstat2 readback %x.\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|sym_snooptest
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u32
name|sym_rd
decl_stmt|,
name|sym_wr
decl_stmt|,
name|sym_bk
decl_stmt|,
name|host_rd
decl_stmt|,
name|host_wr
decl_stmt|,
name|pc
decl_stmt|,
name|dstat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|SYM_CONF_IOMAPPED
name|err
operator||=
name|sym_regtest
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
endif|#
directive|endif
name|restart_test
label|:
comment|/* 	 *  Enable Master Parity Checking as we intend 	 *  to enable it for normal operations. 	 */
name|OUTB
argument_list|(
name|nc_ctest4
argument_list|,
operator|(
name|np
operator|->
name|rv_ctest4
operator|&
name|MPEE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  init 	 */
name|pc
operator|=
name|SCRIPTB0_BA
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
expr_stmt|;
name|host_wr
operator|=
literal|1
expr_stmt|;
name|sym_wr
operator|=
literal|2
expr_stmt|;
comment|/* 	 *  Set memory and register. 	 */
name|np
operator|->
name|cache
operator|=
name|cpu_to_scr
argument_list|(
name|host_wr
argument_list|)
expr_stmt|;
name|OUTL
argument_list|(
name|nc_temp
argument_list|,
name|sym_wr
argument_list|)
expr_stmt|;
comment|/* 	 *  Start script (exchange values) 	 */
name|OUTL
argument_list|(
name|nc_dsa
argument_list|,
name|np
operator|->
name|hcb_ba
argument_list|)
expr_stmt|;
name|OUTL_DSP
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* 	 *  Wait 'til done (with timeout) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_SNOOP_TIMEOUT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|INB
argument_list|(
name|nc_istat
argument_list|)
operator|&
operator|(
name|INTF
operator||
name|SIP
operator||
name|DIP
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|SYM_SNOOP_TIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: timeout.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x20
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	 *  Check for fatal DMA errors. 	 */
name|dstat
operator|=
name|INB
argument_list|(
name|nc_dstat
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Band aiding for broken hardwares that fail PCI parity */
if|if
condition|(
operator|(
name|dstat
operator|&
name|MDPE
operator|)
operator|&&
operator|(
name|np
operator|->
name|rv_ctest4
operator|&
name|MPEE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: PCI DATA PARITY ERROR DETECTED - "
literal|"DISABLING MASTER DATA PARITY CHECKING.\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|rv_ctest4
operator|&=
operator|~
name|MPEE
expr_stmt|;
goto|goto
name|restart_test
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dstat
operator|&
operator|(
name|MDPE
operator||
name|BF
operator||
name|IID
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: DMA error (dstat=0x%02x)."
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x80
operator|)
return|;
block|}
comment|/* 	 *  Save termination position. 	 */
name|pc
operator|=
name|INL
argument_list|(
name|nc_dsp
argument_list|)
expr_stmt|;
comment|/* 	 *  Read memory and register. 	 */
name|host_rd
operator|=
name|scr_to_cpu
argument_list|(
name|np
operator|->
name|cache
argument_list|)
expr_stmt|;
name|sym_rd
operator|=
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
expr_stmt|;
name|sym_bk
operator|=
name|INL
argument_list|(
name|nc_temp
argument_list|)
expr_stmt|;
comment|/* 	 *  Check termination position. 	 */
if|if
condition|(
name|pc
operator|!=
name|SCRIPTB0_BA
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: script execution failed.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"start=%08lx, pc=%08lx, end=%08lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|SCRIPTB0_BA
argument_list|(
name|np
argument_list|,
name|snooptest
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|pc
argument_list|,
operator|(
name|u_long
operator|)
name|SCRIPTB0_BA
argument_list|(
name|np
argument_list|,
name|snoopend
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0x40
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	 *  Show results. 	 */
if|if
condition|(
name|host_wr
operator|!=
name|sym_rd
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: host wrote %d, chip read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|host_wr
argument_list|,
operator|(
name|int
operator|)
name|sym_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|host_rd
operator|!=
name|sym_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: chip wrote %d, host read %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|sym_wr
argument_list|,
operator|(
name|int
operator|)
name|host_rd
argument_list|)
expr_stmt|;
name|err
operator||=
literal|2
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|sym_bk
operator|!=
name|sym_wr
condition|)
block|{
name|printf
argument_list|(
literal|"CACHE TEST FAILED: chip wrote %d, read back %d.\n"
argument_list|,
operator|(
name|int
operator|)
name|sym_wr
argument_list|,
operator|(
name|int
operator|)
name|sym_bk
argument_list|)
expr_stmt|;
name|err
operator||=
literal|4
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  *  Determine the chip's clock frequency.  *  *  This is essential for the negotiation of the synchronous  *  transfer rate.  *  *  Note: we have to return the correct value.  *  THERE IS NO SAFE DEFAULT VALUE.  *  *  Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.  *  53C860 and 53C875 rev. 1 support fast20 transfers but  *  do not have a clock doubler and so are provided with a  *  80 MHz clock. All other fast20 boards incorporate a doubler  *  and so should be delivered with a 40 MHz clock.  *  The recent fast40 chips (895/896/895A/1010) use a 40 Mhz base  *  clock and provide a clock quadrupler (160 Mhz).  */
comment|/*  *  Select SCSI clock frequency  */
specifier|static
name|void
name|sym_selectclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|scntl3
parameter_list|)
block|{
comment|/* 	 *  If multiplier not present or not selected, leave here. 	 */
if|if
condition|(
name|np
operator|->
name|multiplier
operator|<=
literal|1
condition|)
block|{
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: enabling clock multiplier\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|DBLEN
argument_list|)
expr_stmt|;
comment|/* Enable clock multiplier		  */
comment|/* 	 *  Wait for the LCKFRQ bit to be set if supported by the chip. 	 *  Otherwise wait 20 micro-seconds. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_LCKFRQ
condition|)
block|{
name|int
name|i
init|=
literal|20
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|INB
argument_list|(
name|nc_stest4
argument_list|)
operator|&
name|LCKFRQ
operator|)
operator|&&
operator|--
name|i
operator|>
literal|0
condition|)
name|UDELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|printf
argument_list|(
literal|"%s: the chip cannot lock the frequency\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|UDELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
name|HSC
argument_list|)
expr_stmt|;
comment|/* Halt the scsi clock		*/
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
name|scntl3
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
operator|(
name|DBLEN
operator||
name|DBLSEL
operator|)
argument_list|)
expr_stmt|;
comment|/* Select clock multiplier	*/
name|OUTB
argument_list|(
name|nc_stest3
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Restart scsi clock 		*/
block|}
comment|/*  *  calculate SCSI clock frequency (in KHz)  */
specifier|static
name|unsigned
name|getfreq
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|unsigned
name|int
name|ms
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|f
decl_stmt|;
comment|/* 	 * Measure GEN timer delay in order 	 * to calculate SCSI clock frequency 	 * 	 * This code will never execute too 	 * many loop iterations (if DELAY is 	 * reasonably correct). It could get 	 * too low a delay (too high a freq.) 	 * if the CPU is slow executing the 	 * loop for some reason (an NMI, for 	 * example). For this reason we will 	 * if multiple measurements are to be 	 * performed trust the higher delay 	 * (lower frequency returned). 	 */
name|OUTW
argument_list|(
name|nc_sien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all scsi interrupts */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* clear pending scsi interrupt */
name|OUTB
argument_list|(
name|nc_dien
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mask all dma interrupts */
operator|(
name|void
operator|)
name|INW
argument_list|(
name|nc_sist
argument_list|)
expr_stmt|;
comment|/* another one, just to be sure :) */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* set pre-scaler to divide by 3 */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* set to nominal delay of 1<<gen * 125us */
while|while
condition|(
operator|!
operator|(
name|INW
argument_list|(
name|nc_sist
argument_list|)
operator|&
name|GEN
operator|)
operator|&&
name|ms
operator|++
operator|<
literal|100000
condition|)
name|UDELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* count ms */
name|OUTB
argument_list|(
name|nc_stime1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable general purpose timer */
comment|/*  	 * set prescaler to divide by whatever 0 means  	 * 0 ought to choose divide by 2, but appears  	 * to set divide by 3.5 mode in my 53c810 ...  	 */
name|OUTB
argument_list|(
name|nc_scntl3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  	 * adjust for prescaler, and convert into KHz   	 */
name|f
operator|=
name|ms
condition|?
operator|(
operator|(
literal|1
operator|<<
name|gen
operator|)
operator|*
literal|4340
operator|)
operator|/
name|ms
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: Delay (GEN=%d): %u msec, %u KHz\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|gen
argument_list|,
name|ms
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|f
return|;
block|}
specifier|static
name|unsigned
name|sym_getfreq
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|u_int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|int
name|gen
init|=
literal|11
decl_stmt|;
operator|(
name|void
operator|)
name|getfreq
argument_list|(
name|np
argument_list|,
name|gen
argument_list|)
expr_stmt|;
comment|/* throw away first result */
name|f1
operator|=
name|getfreq
argument_list|(
name|np
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|f2
operator|=
name|getfreq
argument_list|(
name|np
argument_list|,
name|gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|>
name|f2
condition|)
name|f1
operator|=
name|f2
expr_stmt|;
comment|/* trust lower result	*/
return|return
name|f1
return|;
block|}
comment|/*  *  Get/probe chip SCSI clock frequency  */
specifier|static
name|void
name|sym_getclock
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|mult
parameter_list|)
block|{
name|unsigned
name|char
name|scntl3
init|=
name|np
operator|->
name|sv_scntl3
decl_stmt|;
name|unsigned
name|char
name|stest1
init|=
name|np
operator|->
name|sv_stest1
decl_stmt|;
name|unsigned
name|f1
decl_stmt|;
comment|/* 	 *  For the C10 core, assume 40 MHz. 	 */
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_C10
condition|)
block|{
name|np
operator|->
name|multiplier
operator|=
name|mult
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
literal|40000
operator|*
name|mult
expr_stmt|;
return|return;
block|}
name|np
operator|->
name|multiplier
operator|=
literal|1
expr_stmt|;
name|f1
operator|=
literal|40000
expr_stmt|;
comment|/* 	 *  True with 875/895/896/895A with clock multiplier selected 	 */
if|if
condition|(
name|mult
operator|>
literal|1
operator|&&
operator|(
name|stest1
operator|&
operator|(
name|DBLEN
operator|+
name|DBLSEL
operator|)
operator|)
operator|==
name|DBLEN
operator|+
name|DBLSEL
condition|)
block|{
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: clock multiplier found\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|multiplier
operator|=
name|mult
expr_stmt|;
block|}
comment|/* 	 *  If multiplier not found or scntl3 not 7,5,3, 	 *  reset chip and get frequency from general purpose timer. 	 *  Otherwise trust scntl3 BIOS setting. 	 */
if|if
condition|(
name|np
operator|->
name|multiplier
operator|!=
name|mult
operator|||
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|<
literal|3
operator|||
operator|!
operator|(
name|scntl3
operator|&
literal|1
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure doubler is OFF */
name|f1
operator|=
name|sym_getfreq
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_verbose
condition|)
name|printf
argument_list|(
literal|"%s: chip clock is %uKHz\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|f1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|45000
condition|)
name|f1
operator|=
literal|40000
expr_stmt|;
elseif|else
if|if
condition|(
name|f1
operator|<
literal|55000
condition|)
name|f1
operator|=
literal|50000
expr_stmt|;
else|else
name|f1
operator|=
literal|80000
expr_stmt|;
if|if
condition|(
name|f1
operator|<
literal|80000
operator|&&
name|mult
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|sym_verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"%s: clock multiplier assumed\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|multiplier
operator|=
name|mult
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|3
condition|)
name|f1
operator|=
literal|40000
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scntl3
operator|&
literal|7
operator|)
operator|==
literal|5
condition|)
name|f1
operator|=
literal|80000
expr_stmt|;
else|else
name|f1
operator|=
literal|160000
expr_stmt|;
name|f1
operator|/=
name|np
operator|->
name|multiplier
expr_stmt|;
block|}
comment|/* 	 *  Compute controller synchronous parameters. 	 */
name|f1
operator|*=
name|np
operator|->
name|multiplier
expr_stmt|;
name|np
operator|->
name|clock_khz
operator|=
name|f1
expr_stmt|;
block|}
comment|/*  *  Get/probe PCI clock frequency  */
specifier|static
name|int
name|sym_getpciclock
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
comment|/* 	 *  For the C1010-33, this doesn't work. 	 *  For the C1010-66, this will be tested when I'll have 	 *  such a beast to play with. 	 */
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|features
operator|&
name|FE_C10
operator|)
condition|)
block|{
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
name|SCLK
argument_list|)
expr_stmt|;
comment|/* Use the PCI clock as SCSI clock */
name|f
operator|=
operator|(
name|int
operator|)
name|sym_getfreq
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_stest1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|np
operator|->
name|pciclk_khz
operator|=
name|f
expr_stmt|;
return|return
name|f
return|;
block|}
comment|/*============= DRIVER ACTION/COMPLETION ====================*/
comment|/*  *  Print something that tells about extended errors.  */
specifier|static
name|void
name|sym_print_xerr
parameter_list|(
name|ccb_p
name|cp
parameter_list|,
name|int
name|x_status
parameter_list|)
block|{
if|if
condition|(
name|x_status
operator|&
name|XE_PARITY_ERR
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unrecovered SCSI parity error.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_EXTRA_DATA
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extraneous data discarded.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_BAD_PHASE
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"illegal scsi phase (4/5).\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_SODL_UNRUN
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ODD transfer in DATA OUT phase.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x_status
operator|&
name|XE_SWIDE_OVRUN
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ODD transfer in DATA IN phase.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *  Choose the more appropriate CAM status if  *  the IO encountered an extended error.  */
specifier|static
name|int
name|sym_xerr_cam_status
parameter_list|(
name|int
name|cam_status
parameter_list|,
name|int
name|x_status
parameter_list|)
block|{
if|if
condition|(
name|x_status
condition|)
block|{
if|if
condition|(
name|x_status
operator|&
name|XE_PARITY_ERR
condition|)
name|cam_status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
elseif|else
if|if
condition|(
name|x_status
operator|&
operator|(
name|XE_EXTRA_DATA
operator||
name|XE_SODL_UNRUN
operator||
name|XE_SWIDE_OVRUN
operator|)
condition|)
name|cam_status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|x_status
operator|&
name|XE_BAD_PHASE
condition|)
name|cam_status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
else|else
name|cam_status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
return|return
name|cam_status
return|;
block|}
comment|/*  *  Complete execution of a SCSI command with extented  *  error, SCSI status error, or having been auto-sensed.  *  *  The SCRIPTS processor is not running there, so we  *  can safely access IO registers and remove JOBs from  *  the START queue.  *  SCRATCHA is assumed to have been loaded with STARTPOS  *  before the SCRIPTS called the C code.  */
specifier|static
name|void
name|sym_complete_error
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|u_int
name|cam_status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Paranoid check. :) 	 */
if|if
condition|(
operator|!
name|cp
operator|||
operator|!
name|cp
operator|->
name|cam_ccb
condition|)
return|return;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
operator|(
name|DEBUG_TINY
operator||
name|DEBUG_RESULT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"CCB=%lx STAT=%x/%x/%x DEV=%d/%d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cp
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|ssss_status
argument_list|,
name|cp
operator|->
name|host_flags
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
name|MDELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Get CAM command pointer. 	 */
name|csio
operator|=
operator|&
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
expr_stmt|;
comment|/* 	 *  Check for extended errors. 	 */
if|if
condition|(
name|cp
operator|->
name|xerr_status
condition|)
block|{
if|if
condition|(
name|sym_verbose
condition|)
name|sym_print_xerr
argument_list|(
name|cp
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
name|cp
operator|->
name|host_status
operator|=
name|HS_COMP_ERR
expr_stmt|;
block|}
comment|/* 	 *  Calculate the residual. 	 */
name|csio
operator|->
name|sense_resid
operator|=
literal|0
expr_stmt|;
name|csio
operator|->
name|resid
operator|=
name|sym_compute_residual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SYM_CONF_RESIDUAL_SUPPORT
condition|)
block|{
comment|/* If user does not want residuals */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* throw them away. :)		   */
name|cp
operator|->
name|sv_resid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|host_flags
operator|&
name|HF_SENSE
condition|)
block|{
comment|/* Auto sense     */
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|sv_scsi_status
expr_stmt|;
comment|/* Restore status */
name|csio
operator|->
name|sense_resid
operator|=
name|csio
operator|->
name|resid
expr_stmt|;
comment|/* Swap residuals */
name|csio
operator|->
name|resid
operator|=
name|cp
operator|->
name|sv_resid
expr_stmt|;
name|cp
operator|->
name|sv_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sym_verbose
operator|&&
name|cp
operator|->
name|sv_xerr_status
condition|)
name|sym_print_xerr
argument_list|(
name|cp
argument_list|,
name|cp
operator|->
name|sv_xerr_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
operator|&&
name|cp
operator|->
name|ssss_status
operator|==
name|S_GOOD
operator|&&
name|cp
operator|->
name|xerr_status
operator|==
literal|0
condition|)
block|{
name|cam_status
operator|=
name|sym_xerr_cam_status
argument_list|(
name|CAM_SCSI_STATUS_ERROR
argument_list|,
name|cp
operator|->
name|sv_xerr_status
argument_list|)
expr_stmt|;
name|cam_status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
comment|/* 			 *  Bounce back the sense data to user and 			 *  fix the residual. 			 */
name|bzero
argument_list|(
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|csio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
operator|->
name|sns_bbuf
argument_list|,
operator|&
name|csio
operator|->
name|sense_data
argument_list|,
name|MIN
argument_list|(
name|csio
operator|->
name|sense_len
argument_list|,
name|SYM_SNS_BBUF_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|+=
name|csio
operator|->
name|sense_len
expr_stmt|;
name|csio
operator|->
name|sense_resid
operator|-=
name|SYM_SNS_BBUF_LEN
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 *  If the device reports a UNIT ATTENTION condition 			 *  due to a RESET condition, we should consider all 			 *  disconnect CCBs for this unit as aborted. 			 */
block|if (1) { 				u_char *p; 				p  = (u_char *) csio->sense_data; 				if (p[0]==0x70&& p[2]==0x6&& p[12]==0x29) 					sym_clear_tasks(np, CAM_REQ_ABORTED, 							cp->target,cp->lun, -1); 			}
endif|#
directive|endif
block|}
else|else
name|cam_status
operator|=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
condition|)
block|{
comment|/* Bad SCSI status */
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
name|cam_status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_SEL_TIMEOUT
condition|)
comment|/* Selection timeout */
name|cam_status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|cp
operator|->
name|host_status
operator|==
name|HS_UNEXPECTED
condition|)
comment|/* Unexpected BUS FREE*/
name|cam_status
operator|=
name|CAM_UNEXP_BUSFREE
expr_stmt|;
else|else
block|{
comment|/* Extended error */
if|if
condition|(
name|sym_verbose
condition|)
block|{
name|PRINT_ADDR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"COMMAND FAILED (%x %x %x).\n"
argument_list|,
name|cp
operator|->
name|host_status
argument_list|,
name|cp
operator|->
name|ssss_status
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
block|}
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
comment|/* 		 *  Set the most appropriate value for CAM status. 		 */
name|cam_status
operator|=
name|sym_xerr_cam_status
argument_list|(
name|CAM_REQ_CMP_ERR
argument_list|,
name|cp
operator|->
name|xerr_status
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Dequeue all queued CCBs for that device 	 *  not yet started by SCRIPTS. 	 */
name|i
operator|=
operator|(
name|INL
argument_list|(
name|nc_scratcha
argument_list|)
operator|-
name|np
operator|->
name|squeue_ba
operator|)
operator|/
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|sym_dequeue_from_squeue
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|cp
operator|->
name|target
argument_list|,
name|cp
operator|->
name|lun
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 *  Restart the SCRIPTS processor. 	 */
name|OUTL_DSP
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Synchronize DMA map if needed. 	 */
if|if
condition|(
name|cp
operator|->
name|dmamapped
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
name|cp
operator|->
name|dmamap
argument_list|,
operator|(
name|cp
operator|->
name|dmamapped
operator|==
name|SYM_DMA_READ
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Add this one to the COMP queue. 	 *  Complete all those commands with either error 	 *  or requeue condition. 	 */
name|sym_set_cam_status
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
name|cam_status
argument_list|)
expr_stmt|;
name|sym_remque
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|)
expr_stmt|;
name|sym_insque_head
argument_list|(
operator|&
name|cp
operator|->
name|link_ccbq
argument_list|,
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
name|sym_flush_comp_queue
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Complete execution of a successful SCSI command.  *  *  Only successful commands go to the DONE queue,  *  since we need to have the SCRIPTS processor  *  stopped on any error condition.  *  The SCRIPTS processor is running while we are  *  completing successful commands.  */
specifier|static
name|void
name|sym_complete_ok
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Paranoid check. :) 	 */
if|if
condition|(
operator|!
name|cp
operator|||
operator|!
name|cp
operator|->
name|cam_ccb
condition|)
return|return;
name|assert
argument_list|(
name|cp
operator|->
name|host_status
operator|==
name|HS_COMPLETE
argument_list|)
expr_stmt|;
comment|/* 	 *  Get command, target and lun pointers. 	 */
name|csio
operator|=
operator|&
name|cp
operator|->
name|cam_ccb
operator|->
name|csio
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|cp
operator|->
name|target
index|]
expr_stmt|;
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 *  Assume device discovered on first success. 	 */
if|if
condition|(
operator|!
name|lp
condition|)
name|sym_set_bit
argument_list|(
name|tp
operator|->
name|lun_map
argument_list|,
name|cp
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* 	 *  If all data have been transferred, given than no 	 *  extended error did occur, there is no residual. 	 */
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|lastp
operator|!=
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|goalp
condition|)
name|csio
operator|->
name|resid
operator|=
name|sym_compute_residual
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 *  Wrong transfer residuals may be worse than just always 	 *  returning zero. User can disable this feature from 	 *  sym_conf.h. Residual support is enabled by default. 	 */
if|if
condition|(
operator|!
name|SYM_CONF_RESIDUAL_SUPPORT
condition|)
name|csio
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Synchronize DMA map if needed. 	 */
if|if
condition|(
name|cp
operator|->
name|dmamapped
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
name|cp
operator|->
name|dmamap
argument_list|,
operator|(
name|cp
operator|->
name|dmamapped
operator|==
name|SYM_DMA_READ
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Set status and complete the command. 	 */
name|csio
operator|->
name|scsi_status
operator|=
name|cp
operator|->
name|ssss_status
expr_stmt|;
name|sym_set_cam_status
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Our callout handler  */
specifier|static
name|void
name|sym_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
init|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|arg
decl_stmt|;
name|hcb_p
name|np
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|sym_hcb_ptr
decl_stmt|;
comment|/* 	 *  Check that the CAM CCB is still queued. 	 */
if|if
condition|(
operator|!
name|np
condition|)
return|return;
name|SYM_LOCK
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
operator|(
name|void
operator|)
name|sym_abort_scsiio
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|SYM_UNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/*  *  Abort an SCSI IO.  */
specifier|static
name|int
name|sym_abort_scsiio
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|timed_out
parameter_list|)
block|{
name|ccb_p
name|cp
decl_stmt|;
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Look up our CCB control block. 	 */
name|cp
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_QUEUED_ELEMENT
argument_list|(
argument|&np->busy_ccbq
argument_list|,
argument|qp
argument_list|)
block|{
name|ccb_p
name|cp2
init|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp2
operator|->
name|cam_ccb
operator|==
name|ccb
condition|)
block|{
name|cp
operator|=
name|cp2
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|cp
operator|||
name|cp
operator|->
name|host_status
operator|==
name|HS_WAIT
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 *  If a previous abort didn't succeed in time, 	 *  perform a BUS reset. 	 */
if|if
condition|(
name|cp
operator|->
name|to_abort
condition|)
block|{
name|sym_reset_scsi_bus
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 *  Mark the CCB for abort and allow time for. 	 */
name|cp
operator|->
name|to_abort
operator|=
name|timed_out
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|cp
operator|->
name|ch
argument_list|,
literal|10
operator|*
name|hz
argument_list|,
name|sym_callout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
comment|/* 	 *  Tell the SCRIPTS processor to stop and synchronize with us. 	 */
name|np
operator|->
name|istat_sem
operator|=
name|SEM
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
operator||
name|SEM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  Reset a SCSI device (all LUNs of a target).  */
specifier|static
name|void
name|sym_reset_dev
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|tcb_p
name|tp
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
init|=
operator|&
name|ccb
operator|->
name|ccb_h
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|target_id
operator|==
name|np
operator|->
name|myaddr
operator|||
name|ccb_h
operator|->
name|target_id
operator|>=
name|SYM_CONF_MAX_TARGET
operator|||
name|ccb_h
operator|->
name|target_lun
operator|>=
name|SYM_CONF_MAX_LUN
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|1
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
name|np
operator|->
name|istat_sem
operator|=
name|SEM
expr_stmt|;
name|OUTB
argument_list|(
name|nc_istat
argument_list|,
name|SIGP
operator||
name|SEM
argument_list|)
expr_stmt|;
block|}
comment|/*  *  SIM action entry point.  */
specifier|static
name|void
name|sym_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|hcb_p
name|np
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|u_char
name|idmsg
decl_stmt|,
modifier|*
name|msgptr
decl_stmt|;
name|u_int
name|msglen
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"sym_action\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Retrieve our controller data structure. 	 */
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  The common case is SCSI IO. 	 *  We deal with other ones elsewhere. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_SCSI_IO
condition|)
block|{
name|sym_action2
argument_list|(
name|sim
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 *  Work around races. 	 */
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Minimal checkings, so that we will not 	 *  go outside our tables. 	 */
if|if
condition|(
name|ccb_h
operator|->
name|target_id
operator|==
name|np
operator|->
name|myaddr
operator|||
name|ccb_h
operator|->
name|target_id
operator|>=
name|SYM_CONF_MAX_TARGET
operator|||
name|ccb_h
operator|->
name|target_lun
operator|>=
name|SYM_CONF_MAX_LUN
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Retrieve the target and lun descriptors. 	 */
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
comment|/* 	 *  Complete the 1st INQUIRY command with error 	 *  condition if the device is flagged NOSCAN 	 *  at BOOT in the NVRAM. This may speed up 	 *  the boot and maintain coherency with BIOS 	 *  device numbering. Clearing the flag allows 	 *  user to rescan skipped devices later. 	 *  We also return error for devices not flagged 	 *  for SCAN LUNS in the NVRAM since some mono-lun 	 *  devices behave badly when asked for some non 	 *  zero LUN. Btw, this is an absolute hack.:-) 	 */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|&&
operator|(
literal|0x12
operator|==
operator|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
index|[
literal|0
index|]
else|:
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|usrflags
operator|&
name|SYM_SCAN_BOOT_DISABLED
operator|)
operator|||
operator|(
operator|(
name|tp
operator|->
name|usrflags
operator|&
name|SYM_SCAN_LUNS_DISABLED
operator|)
operator|&&
name|ccb_h
operator|->
name|target_lun
operator|!=
literal|0
operator|)
condition|)
block|{
name|tp
operator|->
name|usrflags
operator|&=
operator|~
name|SYM_SCAN_BOOT_DISABLED
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_DEV_NOT_THERE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 *  Get a control block for this IO. 	 */
name|tmp
operator|=
operator|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_TAG_ACTION_VALID
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|cp
operator|=
name|sym_get_ccb
argument_list|(
name|np
argument_list|,
name|ccb_h
operator|->
name|target_id
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_RESRC_UNAVAIL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Keep track of the IO in our CCB. 	 */
name|cp
operator|->
name|cam_ccb
operator|=
name|ccb
expr_stmt|;
comment|/* 	 *  Build the IDENTIFY message. 	 */
name|idmsg
operator|=
name|M_IDENTIFY
operator||
name|cp
operator|->
name|lun
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
operator|||
operator|(
name|lp
operator|&&
operator|(
name|lp
operator|->
name|current_flags
operator|&
name|SYM_DISC_ENABLED
operator|)
operator|)
condition|)
name|idmsg
operator||=
literal|0x40
expr_stmt|;
name|msgptr
operator|=
name|cp
operator|->
name|scsi_smsg
expr_stmt|;
name|msglen
operator|=
literal|0
expr_stmt|;
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|idmsg
expr_stmt|;
comment|/* 	 *  Build the tag message if present. 	 */
if|if
condition|(
name|cp
operator|->
name|tag
operator|!=
name|NO_TAG
condition|)
block|{
name|u_char
name|order
init|=
name|csio
operator|->
name|tag_action
decl_stmt|;
switch|switch
condition|(
name|order
condition|)
block|{
case|case
name|M_ORDERED_TAG
case|:
break|break;
case|case
name|M_HEAD_TAG
case|:
break|break;
default|default:
name|order
operator|=
name|M_SIMPLE_TAG
expr_stmt|;
block|}
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|order
expr_stmt|;
comment|/* 		 *  For less than 128 tags, actual tags are numbered 		 *  1,3,5,..2*MAXTAGS+1,since we may have to deal 		 *  with devices that have problems with #TAG 0 or too 		 *  great #TAG numbers. For more tags (up to 256), 		 *  we use directly our tag number. 		 */
if|#
directive|if
name|SYM_CONF_MAX_TASK
operator|>
operator|(
literal|512
operator|/
literal|4
operator|)
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
name|cp
operator|->
name|tag
expr_stmt|;
else|#
directive|else
name|msgptr
index|[
name|msglen
operator|++
index|]
operator|=
operator|(
name|cp
operator|->
name|tag
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 *  Build a negotiation message if needed. 	 *  (nego_status is filled by sym_prepare_nego()) 	 */
name|cp
operator|->
name|nego_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|||
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|!=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
condition|)
block|{
if|if
condition|(
operator|!
name|tp
operator|->
name|nego_cp
operator|&&
name|lp
condition|)
name|msglen
operator|+=
name|sym_prepare_nego
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
name|msgptr
operator|+
name|msglen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Fill in our ccb 	 */
comment|/* 	 *  Startqueue 	 */
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|select
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|go
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|resel_dsa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  select 	 */
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_id
operator|=
name|cp
operator|->
name|target
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl3
operator|=
name|tp
operator|->
name|head
operator|.
name|wval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_sxfer
operator|=
name|tp
operator|->
name|head
operator|.
name|sval
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|select
operator|.
name|sel_scntl4
operator|=
name|tp
operator|->
name|head
operator|.
name|uval
expr_stmt|;
comment|/* 	 *  message 	 */
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|CCB_BA
argument_list|(
name|cp
argument_list|,
name|scsi_smsg
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|smsg
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|msglen
argument_list|)
expr_stmt|;
comment|/* 	 *  command 	 */
if|if
condition|(
name|sym_setup_cdb
argument_list|(
name|np
argument_list|,
name|csio
argument_list|,
name|cp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  status 	 */
if|#
directive|if
literal|0
comment|/* Provision */
block|cp->actualquirks	= tp->quirks;
endif|#
directive|endif
name|cp
operator|->
name|actualquirks
operator|=
name|SYM_QUIRK_AUTOSAVE
expr_stmt|;
name|cp
operator|->
name|host_status
operator|=
name|cp
operator|->
name|nego_status
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
name|cp
operator|->
name|ssss_status
operator|=
name|S_ILLEGAL
expr_stmt|;
name|cp
operator|->
name|xerr_status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|host_flags
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|extra_bytes
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  extreme data pointer. 	 *  shall be positive, so -1 is lower than lowest.:) 	 */
name|cp
operator|->
name|ext_sg
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|->
name|ext_ofs
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  Build the data descriptor block 	 *  and start the IO. 	 */
name|sym_setup_data_and_start
argument_list|(
name|np
argument_list|,
name|csio
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Setup buffers and pointers that address the CDB.  *  I bet, physical CDBs will never be used on the planet,  *  since they can be bounced without significant overhead.  */
specifier|static
name|int
name|sym_setup_cdb
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|u32
name|cmd_ba
decl_stmt|;
name|int
name|cmd_len
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 *  CDB is 16 bytes max. 	 */
if|if
condition|(
name|csio
operator|->
name|cdb_len
operator|>
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|cdb_buf
argument_list|)
condition|)
block|{
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cmd_len
operator|=
name|csio
operator|->
name|cdb_len
expr_stmt|;
if|if
condition|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
block|{
comment|/* CDB is a pointer */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
condition|)
block|{
comment|/* CDB pointer is virtual */
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|cp
operator|->
name|cdb_buf
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
name|cmd_ba
operator|=
name|CCB_BA
argument_list|(
name|cp
argument_list|,
name|cdb_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* CDB pointer is physical */
if|#
directive|if
literal|0
block|cmd_ba = ((u32)csio->cdb_io.cdb_ptr)& 0xffffffff;
else|#
directive|else
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* CDB is in the CAM ccb (buffer) */
name|bcopy
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|cp
operator|->
name|cdb_buf
argument_list|,
name|cmd_len
argument_list|)
expr_stmt|;
name|cmd_ba
operator|=
name|CCB_BA
argument_list|(
name|cp
argument_list|,
name|cdb_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|cmd_ba
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|cmd
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|cmd_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  Set up data pointers used by SCRIPTS.  */
specifier|static
name|void
name|__inline
name|sym_setup_data_pointers
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|u32
name|lastp
decl_stmt|,
name|goalp
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  No segments means no data. 	 */
if|if
condition|(
operator|!
name|cp
operator|->
name|segments
condition|)
name|dir
operator|=
name|CAM_DIR_NONE
expr_stmt|;
comment|/* 	 *  Set the data pointer. 	 */
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|CAM_DIR_OUT
case|:
name|goalp
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|data_out2
argument_list|)
operator|+
literal|8
expr_stmt|;
name|lastp
operator|=
name|goalp
operator|-
literal|8
operator|-
operator|(
name|cp
operator|->
name|segments
operator|*
operator|(
literal|2
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CAM_DIR_IN
case|:
name|cp
operator|->
name|host_flags
operator||=
name|HF_DATA_IN
expr_stmt|;
name|goalp
operator|=
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|data_in2
argument_list|)
operator|+
literal|8
expr_stmt|;
name|lastp
operator|=
name|goalp
operator|-
literal|8
operator|-
operator|(
name|cp
operator|->
name|segments
operator|*
operator|(
literal|2
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CAM_DIR_NONE
case|:
default|default:
name|lastp
operator|=
name|goalp
operator|=
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|no_data
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|lastp
operator|=
name|cpu_to_scr
argument_list|(
name|lastp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|goalp
operator|=
name|cpu_to_scr
argument_list|(
name|goalp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|savep
operator|=
name|cpu_to_scr
argument_list|(
name|lastp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|startp
operator|=
name|cp
operator|->
name|phys
operator|.
name|head
operator|.
name|savep
expr_stmt|;
block|}
comment|/*  *  Call back routine for the DMA map service.  *  If bounce buffers are used (why ?), we may sleep and then  *  be called there in another context.  */
specifier|static
name|void
name|sym_execute_ccb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|psegs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|ccb_p
name|cp
decl_stmt|;
name|hcb_p
name|np
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|cp
operator|=
operator|(
name|ccb_p
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|cp
operator|->
name|cam_ccb
expr_stmt|;
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cp
operator|->
name|arg
expr_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Deal with weird races. 	 */
if|if
condition|(
name|sym_get_cam_status
argument_list|(
name|ccb
argument_list|)
operator|!=
name|CAM_REQ_INPROG
condition|)
goto|goto
name|out_abort
goto|;
comment|/* 	 *  Deal with weird errors. 	 */
if|if
condition|(
name|error
condition|)
block|{
name|cp
operator|->
name|dmamapped
operator|=
literal|0
expr_stmt|;
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_ABORTED
argument_list|)
expr_stmt|;
goto|goto
name|out_abort
goto|;
block|}
comment|/* 	 *  Build the data descriptor for the chip. 	 */
if|if
condition|(
name|nsegs
condition|)
block|{
name|int
name|retv
decl_stmt|;
comment|/* 896 rev 1 requires to be careful about boundaries */
if|if
condition|(
name|np
operator|->
name|device_id
operator|==
name|PCI_ID_SYM53C896
operator|&&
name|np
operator|->
name|revision_id
operator|<=
literal|1
condition|)
name|retv
operator|=
name|sym_scatter_sg_physical
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|psegs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
else|else
name|retv
operator|=
name|sym_fast_scatter_sg_physical
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
name|psegs
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|<
literal|0
condition|)
block|{
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_TOO_BIG
argument_list|)
expr_stmt|;
goto|goto
name|out_abort
goto|;
block|}
block|}
comment|/* 	 *  Synchronize the DMA map only if we have 	 *  actually mapped the data. 	 */
if|if
condition|(
name|cp
operator|->
name|dmamapped
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
name|cp
operator|->
name|dmamap
argument_list|,
operator|(
name|cp
operator|->
name|dmamapped
operator|==
name|SYM_DMA_READ
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Set host status to busy state. 	 *  May have been set back to HS_WAIT to avoid a race. 	 */
name|cp
operator|->
name|host_status
operator|=
name|cp
operator|->
name|nego_status
condition|?
name|HS_NEGOTIATE
else|:
name|HS_BUSY
expr_stmt|;
comment|/* 	 *  Set data pointers. 	 */
name|sym_setup_data_pointers
argument_list|(
name|np
argument_list|,
name|cp
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Enqueue this IO in our pending queue. 	 */
name|sym_enqueue_cam_ccb
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 *  When `#ifed 1', the code below makes the driver 	 *  panic on the first attempt to write to a SCSI device. 	 *  It is the first test we want to do after a driver 	 *  change that does not seem obviously safe. :) 	 */
if|#
directive|if
literal|0
block|switch (cp->cdb_buf[0]) { 	case 0x0A: case 0x2A: case 0xAA: 		panic("XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX\n"); 		MDELAY(10000); 		break; 	default: 		break; 	}
endif|#
directive|endif
comment|/* 	 *  Activate this job. 	 */
name|sym_put_start_queue
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
name|out_abort
label|:
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*  *  How complex it gets to deal with the data in CAM.  *  The Bus Dma stuff makes things still more complex.  */
specifier|static
name|void
name|sym_setup_data_and_start
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|ccb_p
name|cp
parameter_list|)
block|{
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|retv
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|csio
operator|->
name|ccb_h
expr_stmt|;
comment|/* 	 *  Now deal with the data. 	 */
name|cp
operator|->
name|data_len
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
name|cp
operator|->
name|arg
operator|=
name|np
expr_stmt|;
comment|/* 	 *  No direction means no data. 	 */
name|dir
operator|=
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|CAM_DIR_NONE
condition|)
block|{
name|sym_execute_ccb
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
condition|)
block|{
comment|/* Single buffer */
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* Buffer is virtual */
name|cp
operator|->
name|dmamapped
operator|=
operator|(
name|dir
operator|==
name|CAM_DIR_IN
operator|)
condition|?
name|SYM_DMA_READ
else|:
name|SYM_DMA_WRITE
expr_stmt|;
name|retv
operator|=
name|bus_dmamap_load
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
name|cp
operator|->
name|dmamap
argument_list|,
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
name|sym_execute_ccb
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|==
name|EINPROGRESS
condition|)
block|{
name|cp
operator|->
name|host_status
operator|=
name|HS_WAIT
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|np
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csio
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Buffer is physical */
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|sym_execute_ccb
argument_list|(
name|cp
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Scatter/gather list */
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The SG list pointer is physical */
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|out_abort
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|ccb_h
operator|->
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
condition|)
block|{
comment|/* SG buffer pointers are virtual */
name|sym_set_cam_status
argument_list|(
name|cp
operator|->
name|cam_ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|out_abort
goto|;
block|}
comment|/* SG buffer pointers are physical */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|csio
operator|->
name|data_ptr
expr_stmt|;
name|sym_execute_ccb
argument_list|(
name|cp
argument_list|,
name|segs
argument_list|,
name|csio
operator|->
name|sglist_cnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
name|out_abort
label|:
name|sym_xpt_done
argument_list|(
name|np
argument_list|,
operator|(
expr|union
name|ccb
operator|*
operator|)
name|csio
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sym_free_ccb
argument_list|(
name|np
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Move the scatter list to our data block.  */
specifier|static
name|int
name|sym_fast_scatter_sg_physical
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|psegs
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|struct
name|sym_tblmove
modifier|*
name|data
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|psegs2
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>
name|SYM_CONF_MAX_SG
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|=
operator|&
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|SYM_CONF_MAX_SG
operator|-
literal|1
index|]
expr_stmt|;
name|psegs2
operator|=
operator|&
name|psegs
index|[
name|nsegs
operator|-
literal|1
index|]
expr_stmt|;
name|cp
operator|->
name|segments
operator|=
name|nsegs
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|data
operator|->
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|psegs2
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|data
operator|->
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|psegs2
operator|->
name|ds_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
block|{
name|printf
argument_list|(
literal|"%s scatter: paddr=%lx len=%ld\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|psegs2
operator|->
name|ds_addr
argument_list|,
operator|(
name|long
operator|)
name|psegs2
operator|->
name|ds_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|psegs2
operator|!=
name|psegs
condition|)
block|{
operator|--
name|data
expr_stmt|;
operator|--
name|psegs2
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/*  *  Scatter a SG list with physical addresses into bus addressable chunks.  *  We need to ensure 16MB boundaries not to be crossed during DMA of  *  each segment, due to some chips being flawed.  */
define|#
directive|define
name|BOUND_MASK
value|((1UL<<24)-1)
specifier|static
name|int
name|sym_scatter_sg_physical
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|ccb_p
name|cp
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|psegs
parameter_list|,
name|int
name|nsegs
parameter_list|)
block|{
name|u_long
name|ps
decl_stmt|,
name|pe
decl_stmt|,
name|pn
decl_stmt|;
name|u_long
name|k
decl_stmt|;
name|int
name|s
decl_stmt|,
name|t
decl_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|s
operator|=
name|SYM_CONF_MAX_SG
operator|-
literal|1
expr_stmt|;
name|t
operator|=
name|nsegs
operator|-
literal|1
expr_stmt|;
name|ps
operator|=
name|psegs
index|[
name|t
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pe
operator|=
name|ps
operator|+
name|psegs
index|[
name|t
index|]
operator|.
name|ds_len
expr_stmt|;
while|while
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
name|pn
operator|=
operator|(
name|pe
operator|-
literal|1
operator|)
operator|&
operator|~
name|BOUND_MASK
expr_stmt|;
if|if
condition|(
name|pn
operator|<=
name|ps
condition|)
name|pn
operator|=
name|ps
expr_stmt|;
name|k
operator|=
name|pe
operator|-
name|pn
expr_stmt|;
if|if
condition|(
name|DEBUG_FLAGS
operator|&
name|DEBUG_SCATTER
condition|)
block|{
name|printf
argument_list|(
literal|"%s scatter: paddr=%lx len=%ld\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|pn
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|s
index|]
operator|.
name|addr
operator|=
name|cpu_to_scr
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|cp
operator|->
name|phys
operator|.
name|data
index|[
name|s
index|]
operator|.
name|size
operator|=
name|cpu_to_scr
argument_list|(
name|k
argument_list|)
expr_stmt|;
operator|--
name|s
expr_stmt|;
if|if
condition|(
name|pn
operator|==
name|ps
condition|)
block|{
if|if
condition|(
operator|--
name|t
operator|<
literal|0
condition|)
break|break;
name|ps
operator|=
name|psegs
index|[
name|t
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pe
operator|=
name|ps
operator|+
name|psegs
index|[
name|t
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
else|else
name|pe
operator|=
name|pn
expr_stmt|;
block|}
name|cp
operator|->
name|segments
operator|=
name|SYM_CONF_MAX_SG
operator|-
literal|1
operator|-
name|s
expr_stmt|;
return|return
name|t
operator|>=
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
undef|#
directive|undef
name|BOUND_MASK
comment|/*  *  SIM action for non performance critical stuff.  */
specifier|static
name|void
name|sym_action2
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|hcb_p
name|np
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
comment|/* 	 *  Retrieve our controller data structure. 	 */
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ccb_h
operator|=
operator|&
name|ccb
operator|->
name|ccb_h
expr_stmt|;
switch|switch
condition|(
name|ccb_h
operator|->
name|func_code
condition|)
block|{
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
comment|/* 		 *  Update SPI transport settings in TARGET control block. 		 *  Update SCSI device settings in LUN control block. 		 */
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|sym_update_trans
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|goal
argument_list|,
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
name|sym_update_dflags
argument_list|(
name|np
argument_list|,
operator|&
name|lp
operator|->
name|current_flags
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
block|{
name|sym_update_trans
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|user
argument_list|,
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
condition|)
name|sym_update_dflags
argument_list|(
name|np
argument_list|,
operator|&
name|lp
operator|->
name|user_flags
argument_list|,
name|cts
argument_list|)
expr_stmt|;
block|}
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
decl_stmt|;
name|struct
name|sym_trans
modifier|*
name|tip
decl_stmt|;
name|u_char
name|dflags
decl_stmt|;
name|cts
operator|=
operator|&
name|ccb
operator|->
name|cts
expr_stmt|;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|ccb_h
operator|->
name|target_id
index|]
expr_stmt|;
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|ccb_h
operator|->
name|target_lun
argument_list|)
expr_stmt|;
define|#
directive|define
name|cts__scsi
value|(&cts->proto_specific.scsi)
define|#
directive|define
name|cts__spi
value|(&cts->xport_specific.spi)
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|tip
operator|=
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|current
expr_stmt|;
name|dflags
operator|=
name|lp
condition|?
name|lp
operator|->
name|current_flags
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tip
operator|=
operator|&
name|tp
operator|->
name|tinfo
operator|.
name|user
expr_stmt|;
name|dflags
operator|=
name|lp
condition|?
name|lp
operator|->
name|user_flags
else|:
name|tp
operator|->
name|usrflags
expr_stmt|;
block|}
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|tip
operator|->
name|scsi_version
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|tip
operator|->
name|spi_version
expr_stmt|;
name|cts__spi
operator|->
name|sync_period
operator|=
name|tip
operator|->
name|period
expr_stmt|;
name|cts__spi
operator|->
name|sync_offset
operator|=
name|tip
operator|->
name|offset
expr_stmt|;
name|cts__spi
operator|->
name|bus_width
operator|=
name|tip
operator|->
name|width
expr_stmt|;
name|cts__spi
operator|->
name|ppr_options
operator|=
name|tip
operator|->
name|options
expr_stmt|;
name|cts__spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_PPR_OPTIONS
expr_stmt|;
name|cts__spi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
if|if
condition|(
name|dflags
operator|&
name|SYM_DISC_ENABLED
condition|)
name|cts__spi
operator|->
name|flags
operator||=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
name|cts__spi
operator|->
name|valid
operator||=
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|cts__scsi
operator|->
name|flags
operator|&=
operator|~
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
if|if
condition|(
name|dflags
operator|&
name|SYM_TAGS_ENABLED
condition|)
name|cts__scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|cts__scsi
operator|->
name|valid
operator||=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
undef|#
directive|undef
name|cts__spi
undef|#
directive|undef
name|cts__scsi
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_CALC_GEOMETRY
case|:
block|{
name|cam_calc_geometry
argument_list|(
operator|&
name|ccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_MDP_ABLE
operator||
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
operator|!=
literal|0
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|usrflags
operator|&
name|SYM_SCAN_TARGETS_HILO
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_SCANHILO
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|usrflags
operator|&
name|SYM_AVOID_BUS_RESET
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
operator|(
name|np
operator|->
name|features
operator|&
name|FE_WIDE
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
comment|/* Semantic problem:)LUN number max = max number of LUNs - 1 */
name|cpi
operator|->
name|max_lun
operator|=
name|SYM_CONF_MAX_LUN
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|SYM_SETUP_MAX_LUN
operator|<
name|SYM_CONF_MAX_LUN
condition|)
name|cpi
operator|->
name|max_lun
operator|=
name|SYM_SETUP_MAX_LUN
operator|-
literal|1
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|np
operator|->
name|myaddr
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Symbios"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_ST
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_ULTRA3
condition|)
block|{
name|cpi
operator|->
name|transport_version
operator|=
literal|3
expr_stmt|;
name|cpi
operator|->
name|xport_specific
operator|.
name|spi
operator|.
name|ppr_options
operator|=
name|SID_SPI_CLOCK_DT_ST
expr_stmt|;
block|}
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ABORT
case|:
block|{
name|union
name|ccb
modifier|*
name|abort_ccb
init|=
name|ccb
operator|->
name|cab
operator|.
name|abort_ccb
decl_stmt|;
switch|switch
condition|(
name|abort_ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
name|sym_abort_scsiio
argument_list|(
name|np
argument_list|,
name|abort_ccb
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_UA_ABORT
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|XPT_RESET_DEV
case|:
block|{
name|sym_reset_dev
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
block|{
name|sym_reset_scsi_bus
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_verbose
condition|)
block|{
name|xpt_print_path
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI BUS reset delivered.\n"
argument_list|)
expr_stmt|;
block|}
name|sym_init
argument_list|(
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_CMP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
case|case
name|XPT_CONT_TARGET_IO
case|:
case|case
name|XPT_EN_LUN
case|:
case|case
name|XPT_NOTIFY_ACK
case|:
case|case
name|XPT_IMMED_NOTIFY
case|:
case|case
name|XPT_TERM_IO
case|:
default|default:
name|sym_xpt_done2
argument_list|(
name|np
argument_list|,
name|ccb
argument_list|,
name|CAM_REQ_INVALID
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*  *  Asynchronous notification handler.  */
specifier|static
name|void
name|sym_async
parameter_list|(
name|void
modifier|*
name|cb_arg
parameter_list|,
name|u32
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|hcb_p
name|np
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
decl_stmt|;
name|u_int
name|tn
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|sim
operator|=
operator|(
expr|struct
name|cam_sim
operator|*
operator|)
name|cb_arg
expr_stmt|;
name|np
operator|=
operator|(
name|hcb_p
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|AC_LOST_DEVICE
case|:
name|tn
operator|=
name|xpt_path_target_id
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|tn
operator|>=
name|SYM_CONF_MAX_TARGET
condition|)
break|break;
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|tn
index|]
expr_stmt|;
name|tp
operator|->
name|to_reset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|sval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|wval
operator|=
name|np
operator|->
name|rv_scntl3
expr_stmt|;
name|tp
operator|->
name|head
operator|.
name|uval
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|current
operator|.
name|options
operator|=
name|tp
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|options
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/*  *  Update transfer settings of a target.  */
specifier|static
name|void
name|sym_update_trans
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|tcb_p
name|tp
parameter_list|,
name|struct
name|sym_trans
modifier|*
name|tip
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 *  Update the infos. 	 */
define|#
directive|define
name|cts__spi
value|(&cts->xport_specific.spi)
if|if
condition|(
operator|(
name|cts__spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_BUS_WIDTH
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|width
operator|=
name|cts__spi
operator|->
name|bus_width
expr_stmt|;
if|if
condition|(
operator|(
name|cts__spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|offset
operator|=
name|cts__spi
operator|->
name|sync_offset
expr_stmt|;
if|if
condition|(
operator|(
name|cts__spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|period
operator|=
name|cts__spi
operator|->
name|sync_period
expr_stmt|;
if|if
condition|(
operator|(
name|cts__spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_PPR_OPTIONS
operator|)
operator|!=
literal|0
condition|)
name|tip
operator|->
name|options
operator|=
operator|(
name|cts__spi
operator|->
name|ppr_options
operator|&
name|PPR_OPT_DT
operator|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|protocol_version
operator|!=
name|PROTO_VERSION_UNSPECIFIED
operator|&&
name|cts
operator|->
name|protocol_version
operator|!=
name|PROTO_VERSION_UNKNOWN
condition|)
name|tip
operator|->
name|scsi_version
operator|=
name|cts
operator|->
name|protocol_version
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|transport_version
operator|!=
name|XPORT_VERSION_UNSPECIFIED
operator|&&
name|cts
operator|->
name|transport_version
operator|!=
name|XPORT_VERSION_UNKNOWN
condition|)
name|tip
operator|->
name|spi_version
operator|=
name|cts
operator|->
name|transport_version
expr_stmt|;
undef|#
directive|undef
name|cts__spi
comment|/* 	 *  Scale against driver configuration limits. 	 */
if|if
condition|(
name|tip
operator|->
name|width
operator|>
name|SYM_SETUP_MAX_WIDE
condition|)
name|tip
operator|->
name|width
operator|=
name|SYM_SETUP_MAX_WIDE
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|offset
operator|>
name|SYM_SETUP_MAX_OFFS
condition|)
name|tip
operator|->
name|offset
operator|=
name|SYM_SETUP_MAX_OFFS
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|period
operator|<
name|SYM_SETUP_MIN_SYNC
condition|)
name|tip
operator|->
name|period
operator|=
name|SYM_SETUP_MIN_SYNC
expr_stmt|;
comment|/* 	 *  Scale against actual controller BUS width. 	 */
if|if
condition|(
name|tip
operator|->
name|width
operator|>
name|np
operator|->
name|maxwide
condition|)
name|tip
operator|->
name|width
operator|=
name|np
operator|->
name|maxwide
expr_stmt|;
comment|/* 	 *  Only accept DT if controller supports and SYNC/WIDE asked. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_C10
operator||
name|FE_ULTRA3
operator|)
operator|)
operator|==
operator|(
name|FE_C10
operator||
name|FE_ULTRA3
operator|)
operator|)
operator|||
operator|!
operator|(
name|tip
operator|->
name|width
operator|==
name|BUS_16_BIT
operator|&&
name|tip
operator|->
name|offset
operator|)
condition|)
block|{
name|tip
operator|->
name|options
operator|&=
operator|~
name|PPR_OPT_DT
expr_stmt|;
block|}
comment|/* 	 *  Scale period factor and offset against controller limits. 	 */
if|if
condition|(
name|tip
operator|->
name|options
operator|&
name|PPR_OPT_DT
condition|)
block|{
if|if
condition|(
name|tip
operator|->
name|period
operator|<
name|np
operator|->
name|minsync_dt
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|minsync_dt
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|period
operator|>
name|np
operator|->
name|maxsync_dt
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|maxsync_dt
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|offset
operator|>
name|np
operator|->
name|maxoffs_dt
condition|)
name|tip
operator|->
name|offset
operator|=
name|np
operator|->
name|maxoffs_dt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tip
operator|->
name|period
operator|<
name|np
operator|->
name|minsync
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|minsync
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|period
operator|>
name|np
operator|->
name|maxsync
condition|)
name|tip
operator|->
name|period
operator|=
name|np
operator|->
name|maxsync
expr_stmt|;
if|if
condition|(
name|tip
operator|->
name|offset
operator|>
name|np
operator|->
name|maxoffs
condition|)
name|tip
operator|->
name|offset
operator|=
name|np
operator|->
name|maxoffs
expr_stmt|;
block|}
block|}
comment|/*  *  Update flags for a device (logical unit).  */
specifier|static
name|void
name|sym_update_dflags
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|flags
parameter_list|,
name|struct
name|ccb_trans_settings
modifier|*
name|cts
parameter_list|)
block|{
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
define|#
directive|define
name|cts__scsi
value|(&cts->proto_specific.scsi)
define|#
directive|define
name|cts__spi
value|(&cts->xport_specific.spi)
if|if
condition|(
operator|(
name|cts__spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts__spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|flags
operator||=
name|SYM_DISC_ENABLED
expr_stmt|;
else|else
operator|*
name|flags
operator|&=
operator|~
name|SYM_DISC_ENABLED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cts__scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cts__scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
operator|*
name|flags
operator||=
name|SYM_TAGS_ENABLED
expr_stmt|;
else|else
operator|*
name|flags
operator|&=
operator|~
name|SYM_TAGS_ENABLED
expr_stmt|;
block|}
undef|#
directive|undef
name|cts__spi
undef|#
directive|undef
name|cts__scsi
block|}
comment|/*============= DRIVER INITIALISATION ==================*/
specifier|static
name|device_method_t
name|sym_pci_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sym_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sym_pci_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|driver_t
name|sym_pci_driver
init|=
block|{
literal|"sym"
block|,
name|sym_pci_methods
block|,
literal|1
comment|/* no softc */
block|}
decl_stmt|;
specifier|static
name|devclass_t
name|sym_devclass
decl_stmt|;
name|DRIVER_MODULE
argument_list|(
name|sym
argument_list|,
name|pci
argument_list|,
name|sym_pci_driver
argument_list|,
name|sym_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|sym
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|sym
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|struct
name|sym_pci_chip
name|sym_pci_dev_table
index|[]
init|=
block|{
block|{
name|PCI_ID_SYM53C810
block|,
literal|0x0f
block|,
literal|"810"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
literal|64
block|,
name|FE_ERL
block|}
block|,
ifdef|#
directive|ifdef
name|SYM_DEBUG_GENERIC_SUPPORT
block|{
name|PCI_ID_SYM53C810
block|,
literal|0xff
block|,
literal|"810a"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|FE_BOF
block|}
block|,
else|#
directive|else
block|{
name|PCI_ID_SYM53C810
block|,
literal|0xff
block|,
literal|"810a"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|FE_CACHE_SET
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_BOF
block|}
block|,
endif|#
directive|endif
block|{
name|PCI_ID_SYM53C815
block|,
literal|0xff
block|,
literal|"815"
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|,
literal|64
block|,
name|FE_BOF
operator||
name|FE_ERL
block|}
block|,
block|{
name|PCI_ID_SYM53C825
block|,
literal|0x0f
block|,
literal|"825"
block|,
literal|6
block|,
literal|8
block|,
literal|4
block|,
literal|64
block|,
name|FE_WIDE
operator||
name|FE_BOF
operator||
name|FE_ERL
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C825
block|,
literal|0xff
block|,
literal|"825a"
block|,
literal|6
block|,
literal|8
block|,
literal|4
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C860
block|,
literal|0xff
block|,
literal|"860"
block|,
literal|4
block|,
literal|8
block|,
literal|5
block|,
literal|1
block|,
name|FE_ULTRA
operator||
name|FE_CLK80
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
block|}
block|,
block|{
name|PCI_ID_SYM53C875
block|,
literal|0x01
block|,
literal|"875"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_CLK80
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C875
block|,
literal|0xff
block|,
literal|"875"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C875_2
block|,
literal|0xff
block|,
literal|"875"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
block|{
name|PCI_ID_SYM53C885
block|,
literal|0xff
block|,
literal|"885"
block|,
literal|6
block|,
literal|16
block|,
literal|5
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_ULTRA
operator||
name|FE_DBLR
operator||
name|FE_CACHE0_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_DIFF
block|}
block|,
ifdef|#
directive|ifdef
name|SYM_DEBUG_GENERIC_SUPPORT
block|{
name|PCI_ID_SYM53C895
block|,
literal|0xff
block|,
literal|"895"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_RAM
operator||
name|FE_LCKFRQ
block|}
block|,
else|#
directive|else
block|{
name|PCI_ID_SYM53C895
block|,
literal|0xff
block|,
literal|"895"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|2
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_LCKFRQ
block|}
block|,
endif|#
directive|endif
block|{
name|PCI_ID_SYM53C896
block|,
literal|0xff
block|,
literal|"896"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_DAC
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_LCKFRQ
block|}
block|,
block|{
name|PCI_ID_SYM53C895A
block|,
literal|0xff
block|,
literal|"895a"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_DAC
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_LCKFRQ
block|}
block|,
block|{
name|PCI_ID_LSI53C1010
block|,
literal|0x00
block|,
literal|"1010-33"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|8
block|,
name|FE_WIDE
operator||
name|FE_ULTRA3
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFBC
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_DAC
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_CRC
operator||
name|FE_C10
block|}
block|,
block|{
name|PCI_ID_LSI53C1010
block|,
literal|0xff
block|,
literal|"1010-33"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|8
block|,
name|FE_WIDE
operator||
name|FE_ULTRA3
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFBC
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_DAC
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_CRC
operator||
name|FE_C10
operator||
name|FE_U3EN
block|}
block|,
block|{
name|PCI_ID_LSI53C1010_2
block|,
literal|0xff
block|,
literal|"1010-66"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|8
block|,
name|FE_WIDE
operator||
name|FE_ULTRA3
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFBC
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_RAM8K
operator||
name|FE_64BIT
operator||
name|FE_DAC
operator||
name|FE_IO256
operator||
name|FE_NOPM
operator||
name|FE_LEDC
operator||
name|FE_66MHZ
operator||
name|FE_CRC
operator||
name|FE_C10
operator||
name|FE_U3EN
block|}
block|,
block|{
name|PCI_ID_LSI53C1510D
block|,
literal|0xff
block|,
literal|"1510d"
block|,
literal|6
block|,
literal|31
block|,
literal|7
block|,
literal|4
block|,
name|FE_WIDE
operator||
name|FE_ULTRA2
operator||
name|FE_QUAD
operator||
name|FE_CACHE_SET
operator||
name|FE_BOF
operator||
name|FE_DFS
operator||
name|FE_LDSTR
operator||
name|FE_PFEN
operator||
name|FE_RAM
operator||
name|FE_IO256
operator||
name|FE_LEDC
block|}
block|}
decl_stmt|;
define|#
directive|define
name|sym_pci_num_devs
define|\
value|(sizeof(sym_pci_dev_table) / sizeof(sym_pci_dev_table[0]))
comment|/*  *  Look up the chip table.  *  *  Return a pointer to the chip entry if found,  *  zero otherwise.  */
specifier|static
specifier|const
name|struct
name|sym_pci_chip
modifier|*
name|sym_find_pci_chip
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_short
name|device_id
decl_stmt|;
name|u_char
name|revision
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCI_VENDOR_NCR
condition|)
return|return
name|NULL
return|;
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|revision
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_pci_num_devs
condition|;
name|i
operator|++
control|)
block|{
name|chip
operator|=
operator|&
name|sym_pci_dev_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|device_id
operator|!=
name|chip
operator|->
name|device_id
condition|)
continue|continue;
if|if
condition|(
name|revision
operator|>
name|chip
operator|->
name|revision_id
condition|)
continue|continue;
return|return
name|chip
return|;
block|}
return|return
name|NULL
return|;
block|}
comment|/*  *  Tell upper layer if the chip is supported.  */
specifier|static
name|int
name|sym_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|chip
operator|=
name|sym_find_pci_chip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip
operator|&&
name|sym_find_firmware
argument_list|(
name|chip
argument_list|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|chip
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|chip
operator|->
name|lp_probe_bit
operator|&
name|SYM_SETUP_LP_PROBE_MAP
operator|)
condition|?
name|BUS_PROBE_LOW_PRIORITY
else|:
name|BUS_PROBE_DEFAULT
return|;
block|}
return|return
name|ENXIO
return|;
block|}
comment|/*  *  Attach a sym53c8xx device.  */
specifier|static
name|int
name|sym_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|sym_pci_chip
modifier|*
name|chip
decl_stmt|;
name|u_short
name|command
decl_stmt|;
name|u_char
name|cachelnsz
decl_stmt|;
name|struct
name|sym_hcb
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
name|struct
name|sym_nvram
name|nvram
decl_stmt|;
specifier|const
name|struct
name|sym_fw
modifier|*
name|fw
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bus_dma_tag_t
name|bus_dmat
decl_stmt|;
name|bus_dmat
operator|=
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 *  Only probed devices should be attached. 	 *  We just enjoy being paranoid. :) 	 */
name|chip
operator|=
name|sym_find_pci_chip
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|chip
operator|==
name|NULL
operator|||
operator|(
name|fw
operator|=
name|sym_find_firmware
argument_list|(
name|chip
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 *  Allocate immediately the host control block, 	 *  since we are only expecting to succeed. :) 	 *  We keep track in the HCB of all the resources that 	 *  are to be released on error. 	 */
name|np
operator|=
name|__sym_calloc_dma
argument_list|(
name|bus_dmat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
literal|"HCB"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
name|np
operator|->
name|bus_dmat
operator|=
name|bus_dmat
expr_stmt|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_softc
argument_list|(
name|dev
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|SYM_LOCK_INIT
argument_list|()
expr_stmt|;
comment|/* 	 *  Copy some useful infos to the HCB. 	 */
name|np
operator|->
name|hcb_ba
operator|=
name|vtobus
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|verbose
operator|=
name|bootverbose
expr_stmt|;
name|np
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|np
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|np
operator|->
name|revision_id
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|np
operator|->
name|features
operator|=
name|chip
operator|->
name|features
expr_stmt|;
name|np
operator|->
name|clock_divn
operator|=
name|chip
operator|->
name|nr_divisor
expr_stmt|;
name|np
operator|->
name|maxoffs
operator|=
name|chip
operator|->
name|offset_max
expr_stmt|;
name|np
operator|->
name|maxburst
operator|=
name|chip
operator|->
name|burst_max
expr_stmt|;
name|np
operator|->
name|scripta_sz
operator|=
name|fw
operator|->
name|a_size
expr_stmt|;
name|np
operator|->
name|scriptb_sz
operator|=
name|fw
operator|->
name|b_size
expr_stmt|;
name|np
operator|->
name|fw_setup
operator|=
name|fw
operator|->
name|setup
expr_stmt|;
name|np
operator|->
name|fw_patch
operator|=
name|fw
operator|->
name|patch
expr_stmt|;
name|np
operator|->
name|fw_name
operator|=
name|fw
operator|->
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
name|np
operator|->
name|target
operator|=
name|sym_calloc_dma
argument_list|(
name|SYM_CONF_MAX_TARGET
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|np
operator|->
name|target
operator|)
argument_list|)
argument_list|,
literal|"TARGET"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|target
condition|)
goto|goto
name|attach_failed
goto|;
endif|#
directive|endif
comment|/* 	 *  Initialize the CCB free and busy queues. 	 */
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|busy_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|comp_ccbq
argument_list|)
expr_stmt|;
name|sym_que_init
argument_list|(
operator|&
name|np
operator|->
name|cam_ccbq
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate a tag for the DMA of user data. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|np
operator|->
name|bus_dmat
argument_list|,
literal|1
argument_list|,
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|SYM_CONF_MAX_SG
argument_list|,
operator|(
literal|1
operator|<<
literal|24
operator|)
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|np
operator|->
name|mtx
argument_list|,
operator|&
name|np
operator|->
name|data_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to create DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
comment|/* 	 *  Read and apply some fix-ups to the PCI COMMAND 	 *  register. We want the chip to be enabled for: 	 *  - BUS mastering 	 *  - PCI parity checking (reporting would also be fine) 	 *  - Write And Invalidate. 	 */
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_PERRESPEN
expr_stmt|;
name|command
operator||=
comment|/* PCIM_CMD_MWIEN */
literal|0x0010
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 *  Let the device know about the cache line size, 	 *  if it doesn't yet. 	 */
name|cachelnsz
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cachelnsz
condition|)
block|{
name|cachelnsz
operator|=
literal|8
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_CACHELNSZ
argument_list|,
name|cachelnsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Alloc/get/map/retrieve everything that deals with MMIO. 	 */
if|if
condition|(
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regs_id
init|=
name|SYM_PCI_MMIO
decl_stmt|;
name|np
operator|->
name|mmio_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|regs_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|mmio_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate MMIO resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|mmio_ba
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate the IRQ. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|i
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|irq_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate IRQ resource\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
ifdef|#
directive|ifdef
name|SYM_CONF_IOMAPPED
comment|/* 	 *  User want us to use normal IO with PCI. 	 *  Alloc/get/map/retrieve everything that deals with IO. 	 */
if|if
condition|(
operator|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regs_id
init|=
name|SYM_PCI_IO
decl_stmt|;
name|np
operator|->
name|io_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|regs_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|np
operator|->
name|io_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate IO resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
endif|#
directive|endif
comment|/* SYM_CONF_IOMAPPED */
comment|/* 	 *  If the chip has RAM. 	 *  Alloc/get/map/retrieve the corresponding resources. 	 */
if|if
condition|(
operator|(
name|np
operator|->
name|features
operator|&
operator|(
name|FE_RAM
operator||
name|FE_RAM8K
operator|)
operator|)
operator|&&
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|regs_id
init|=
name|SYM_PCI_RAM
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_64BIT
condition|)
name|regs_id
operator|=
name|SYM_PCI_RAM64
expr_stmt|;
name|np
operator|->
name|ram_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|regs_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|ram_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate RAM resources\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
name|np
operator|->
name|ram_id
operator|=
name|regs_id
expr_stmt|;
name|np
operator|->
name|ram_ba
operator|=
name|rman_get_start
argument_list|(
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Save setting of some IO registers, so we will 	 *  be able to probe specific implementations. 	 */
name|sym_save_initial_setting
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* 	 *  Reset the chip now, since it has been reported 	 *  that SCSI clock calibration may not work properly 	 *  if the chip is currently active. 	 */
name|sym_chip_reset
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* 	 *  Try to read the user set-up. 	 */
operator|(
name|void
operator|)
name|sym_read_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvram
argument_list|)
expr_stmt|;
comment|/* 	 *  Prepare controller and devices settings, according 	 *  to chip features, user set-up and driver set-up. 	 */
operator|(
name|void
operator|)
name|sym_prepare_setting
argument_list|(
name|np
argument_list|,
operator|&
name|nvram
argument_list|)
expr_stmt|;
comment|/* 	 *  Check the PCI clock frequency. 	 *  Must be performed after prepare_setting since it destroys 	 *  STEST1 that is used to probe for the clock doubler. 	 */
name|i
operator|=
name|sym_getpciclock
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|37000
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI BUS clock seems too high: %u KHz.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate the start queue. 	 */
name|np
operator|->
name|squeue
operator|=
operator|(
name|u32
operator|*
operator|)
name|sym_calloc_dma
argument_list|(
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"SQUEUE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|squeue
condition|)
goto|goto
name|attach_failed
goto|;
name|np
operator|->
name|squeue_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|squeue
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate the done queue. 	 */
name|np
operator|->
name|dqueue
operator|=
operator|(
name|u32
operator|*
operator|)
name|sym_calloc_dma
argument_list|(
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"DQUEUE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|dqueue
condition|)
goto|goto
name|attach_failed
goto|;
name|np
operator|->
name|dqueue_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|dqueue
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate the target bus address array. 	 */
name|np
operator|->
name|targtbl
operator|=
operator|(
name|u32
operator|*
operator|)
name|sym_calloc_dma
argument_list|(
literal|256
argument_list|,
literal|"TARGTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|targtbl
condition|)
goto|goto
name|attach_failed
goto|;
name|np
operator|->
name|targtbl_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|targtbl
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate SCRIPTS areas. 	 */
name|np
operator|->
name|scripta0
operator|=
name|sym_calloc_dma
argument_list|(
name|np
operator|->
name|scripta_sz
argument_list|,
literal|"SCRIPTA0"
argument_list|)
expr_stmt|;
name|np
operator|->
name|scriptb0
operator|=
name|sym_calloc_dma
argument_list|(
name|np
operator|->
name|scriptb_sz
argument_list|,
literal|"SCRIPTB0"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|scripta0
operator|||
operator|!
name|np
operator|->
name|scriptb0
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Allocate the CCBs. We need at least ONE. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sym_alloc_ccb
argument_list|(
name|np
argument_list|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Calculate BUS addresses where we are going 	 *  to load the SCRIPTS. 	 */
name|np
operator|->
name|scripta_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|scripta0
argument_list|)
expr_stmt|;
name|np
operator|->
name|scriptb_ba
operator|=
name|vtobus
argument_list|(
name|np
operator|->
name|scriptb0
argument_list|)
expr_stmt|;
name|np
operator|->
name|scriptb0_ba
operator|=
name|np
operator|->
name|scriptb_ba
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ram_ba
condition|)
block|{
name|np
operator|->
name|scripta_ba
operator|=
name|np
operator|->
name|ram_ba
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|features
operator|&
name|FE_RAM8K
condition|)
block|{
name|np
operator|->
name|ram_ws
operator|=
literal|8192
expr_stmt|;
name|np
operator|->
name|scriptb_ba
operator|=
name|np
operator|->
name|scripta_ba
operator|+
literal|4096
expr_stmt|;
ifdef|#
directive|ifdef
name|__LP64__
name|np
operator|->
name|scr_ram_seg
operator|=
name|cpu_to_scr
argument_list|(
name|np
operator|->
name|scripta_ba
operator|>>
literal|32
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|np
operator|->
name|ram_ws
operator|=
literal|4096
expr_stmt|;
block|}
comment|/* 	 *  Copy scripts to controller instance. 	 */
name|bcopy
argument_list|(
name|fw
operator|->
name|a_base
argument_list|,
name|np
operator|->
name|scripta0
argument_list|,
name|np
operator|->
name|scripta_sz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fw
operator|->
name|b_base
argument_list|,
name|np
operator|->
name|scriptb0
argument_list|,
name|np
operator|->
name|scriptb_sz
argument_list|)
expr_stmt|;
comment|/* 	 *  Setup variable parts in scripts and compute 	 *  scripts bus addresses used from the C code. 	 */
name|np
operator|->
name|fw_setup
argument_list|(
name|np
argument_list|,
name|fw
argument_list|)
expr_stmt|;
comment|/* 	 *  Bind SCRIPTS with physical addresses usable by the 	 *  SCRIPTS processor (as seen from the BUS = BUS addresses). 	 */
name|sym_fw_bind_script
argument_list|(
name|np
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|np
operator|->
name|scripta0
argument_list|,
name|np
operator|->
name|scripta_sz
argument_list|)
expr_stmt|;
name|sym_fw_bind_script
argument_list|(
name|np
argument_list|,
operator|(
name|u32
operator|*
operator|)
name|np
operator|->
name|scriptb0
argument_list|,
name|np
operator|->
name|scriptb_sz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_IARB_SUPPORT
comment|/* 	 *    If user wants IARB to be set when we win arbitration 	 *    and have other jobs, compute the max number of consecutive 	 *    settings of IARB hints before we leave devices a chance to 	 *    arbitrate for reselection. 	 */
ifdef|#
directive|ifdef
name|SYM_SETUP_IARB_MAX
name|np
operator|->
name|iarb_max
operator|=
name|SYM_SETUP_IARB_MAX
expr_stmt|;
else|#
directive|else
name|np
operator|->
name|iarb_max
operator|=
literal|4
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 *  Prepare the idle and invalid task actions. 	 */
name|np
operator|->
name|idletask
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|idletask
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|idletask_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|idletask
argument_list|)
expr_stmt|;
name|np
operator|->
name|notask
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|notask
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|notask_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|notask
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itl
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itl
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itl_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|bad_itl
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itlq
operator|.
name|start
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTA_BA
argument_list|(
name|np
argument_list|,
name|idle
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itlq
operator|.
name|restart
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|bad_i_t_l_q
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|bad_itlq_ba
operator|=
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|bad_itlq
argument_list|)
expr_stmt|;
comment|/* 	 *  Allocate and prepare the lun JUMP table that is used 	 *  for a target prior the probing of devices (bad lun table). 	 *  A private table will be allocated for the target on the 	 *  first INQUIRY response received. 	 */
name|np
operator|->
name|badluntbl
operator|=
name|sym_calloc_dma
argument_list|(
literal|256
argument_list|,
literal|"BADLUNTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
operator|->
name|badluntbl
condition|)
goto|goto
name|attach_failed
goto|;
name|np
operator|->
name|badlun_sa
operator|=
name|cpu_to_scr
argument_list|(
name|SCRIPTB_BA
argument_list|(
name|np
argument_list|,
name|resel_bad_lun
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
comment|/* 64 luns/target, no less */
name|np
operator|->
name|badluntbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|badlun_sa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 *  Prepare the bus address array that contains the bus 	 *  address of each target control block. 	 *  For now, assume all logical units are wrong. :) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SYM_CONF_MAX_TARGET
condition|;
name|i
operator|++
control|)
block|{
name|np
operator|->
name|targtbl
index|[
name|i
index|]
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|target
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|target
index|[
name|i
index|]
operator|.
name|head
operator|.
name|luntbl_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
name|np
operator|->
name|badluntbl
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|target
index|[
name|i
index|]
operator|.
name|head
operator|.
name|lun0_sa
operator|=
name|cpu_to_scr
argument_list|(
name|vtobus
argument_list|(
operator|&
name|np
operator|->
name|badlun_sa
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Now check the cache handling of the pci chipset. 	 */
if|if
condition|(
name|sym_snooptest
argument_list|(
name|np
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CACHE INCORRECTLY CONFIGURED.\n"
argument_list|)
expr_stmt|;
goto|goto
name|attach_failed
goto|;
block|}
empty_stmt|;
comment|/* 	 *  Now deal with CAM. 	 *  Hopefully, we will succeed with that one.:) 	 */
if|if
condition|(
operator|!
name|sym_cam_attach
argument_list|(
name|np
argument_list|)
condition|)
goto|goto
name|attach_failed
goto|;
comment|/* 	 *  Sigh! we are done. 	 */
return|return
literal|0
return|;
comment|/* 	 *  We have failed. 	 *  We will try to free all the resources we have 	 *  allocated, but if we are a boot device, this 	 *  will not help that much.;) 	 */
name|attach_failed
label|:
if|if
condition|(
name|np
condition|)
name|sym_pci_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/*  *  Free everything that have been allocated for this device.  */
specifier|static
name|void
name|sym_pci_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|SYM_QUEHEAD
modifier|*
name|qp
decl_stmt|;
name|ccb_p
name|cp
decl_stmt|;
name|tcb_p
name|tp
decl_stmt|;
name|lcb_p
name|lp
decl_stmt|;
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|;
comment|/* 	 *  First free CAM resources. 	 */
name|sym_cam_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* 	 *  Now every should be quiet for us to 	 *  free other resources. 	 */
if|if
condition|(
name|np
operator|->
name|ram_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|np
operator|->
name|ram_id
argument_list|,
name|np
operator|->
name|ram_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|mmio_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|SYM_PCI_MMIO
argument_list|,
name|np
operator|->
name|mmio_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|io_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|SYM_PCI_IO
argument_list|,
name|np
operator|->
name|io_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|np
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|scriptb0
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|scriptb0
argument_list|,
name|np
operator|->
name|scriptb_sz
argument_list|,
literal|"SCRIPTB0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|scripta0
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|scripta0
argument_list|,
name|np
operator|->
name|scripta_sz
argument_list|,
literal|"SCRIPTA0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|squeue
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|squeue
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"SQUEUE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|dqueue
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|dqueue
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
operator|*
operator|(
name|MAX_QUEUE
operator|*
literal|2
operator|)
argument_list|,
literal|"DQUEUE"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|qp
operator|=
name|sym_remque_head
argument_list|(
operator|&
name|np
operator|->
name|free_ccbq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|sym_que_entry
argument_list|(
name|qp
argument_list|,
expr|struct
name|sym_ccb
argument_list|,
name|link_ccbq
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|,
name|cp
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|sym_mfree_dma
argument_list|(
name|cp
operator|->
name|sns_bbuf
argument_list|,
name|SYM_SNS_BBUF_LEN
argument_list|,
literal|"SNS_BBUF"
argument_list|)
expr_stmt|;
name|sym_mfree_dma
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|,
literal|"CCB"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|badluntbl
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|badluntbl
argument_list|,
literal|256
argument_list|,
literal|"BADLUNTBL"
argument_list|)
expr_stmt|;
for|for
control|(
name|target
operator|=
literal|0
init|;
name|target
operator|<
name|SYM_CONF_MAX_TARGET
condition|;
name|target
operator|++
control|)
block|{
name|tp
operator|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
expr_stmt|;
for|for
control|(
name|lun
operator|=
literal|0
init|;
name|lun
operator|<
name|SYM_CONF_MAX_LUN
condition|;
name|lun
operator|++
control|)
block|{
name|lp
operator|=
name|sym_lp
argument_list|(
name|np
argument_list|,
name|tp
argument_list|,
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
continue|continue;
if|if
condition|(
name|lp
operator|->
name|itlq_tbl
condition|)
name|sym_mfree_dma
argument_list|(
name|lp
operator|->
name|itlq_tbl
argument_list|,
name|SYM_CONF_MAX_TASK
operator|*
literal|4
argument_list|,
literal|"ITLQ_TBL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|cb_tags
condition|)
name|sym_mfree
argument_list|(
name|lp
operator|->
name|cb_tags
argument_list|,
name|SYM_CONF_MAX_TASK
argument_list|,
literal|"CB_TAGS"
argument_list|)
expr_stmt|;
name|sym_mfree_dma
argument_list|(
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|,
literal|"LCB"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|SYM_CONF_MAX_LUN
operator|>
literal|1
if|if
condition|(
name|tp
operator|->
name|lunmp
condition|)
name|sym_mfree
argument_list|(
name|tp
operator|->
name|lunmp
argument_list|,
name|SYM_CONF_MAX_LUN
operator|*
sizeof|sizeof
argument_list|(
name|lcb_p
argument_list|)
argument_list|,
literal|"LUNMP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|np
operator|->
name|target
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|target
argument_list|,
name|SYM_CONF_MAX_TARGET
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|np
operator|->
name|target
operator|)
argument_list|)
argument_list|,
literal|"TARGET"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|np
operator|->
name|targtbl
condition|)
name|sym_mfree_dma
argument_list|(
name|np
operator|->
name|targtbl
argument_list|,
literal|256
argument_list|,
literal|"TARGTBL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|data_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|np
operator|->
name|data_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYM_LOCK_INITIALIZED
argument_list|()
operator|!=
literal|0
condition|)
name|SYM_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|device_set_softc
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sym_mfree_dma
argument_list|(
name|np
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
literal|"HCB"
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Allocate CAM resources and register a bus to CAM.  */
specifier|static
name|int
name|sym_cam_attach
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
init|=
name|NULL
decl_stmt|;
name|struct
name|cam_sim
modifier|*
name|sim
init|=
name|NULL
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 *  Establish our interrupt handler. 	 */
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|np
operator|->
name|irq_res
argument_list|,
name|INTR_ENTROPY
operator||
name|INTR_MPSAFE
operator||
name|INTR_TYPE_CAM
argument_list|,
name|NULL
argument_list|,
name|sym_intr
argument_list|,
name|np
argument_list|,
operator|&
name|np
operator|->
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|np
operator|->
name|device
argument_list|,
literal|"bus_setup_intr() failed: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 *  Create the device queue for our sym SIM. 	 */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|SYM_CONF_MAX_START
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devq
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 *  Construct our SIM entry. 	 */
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|sym_action
argument_list|,
name|sym_poll
argument_list|,
literal|"sym"
argument_list|,
name|np
argument_list|,
name|device_get_unit
argument_list|(
name|np
operator|->
name|device
argument_list|)
argument_list|,
operator|&
name|np
operator|->
name|mtx
argument_list|,
literal|1
argument_list|,
name|SYM_SETUP_MAX_TAG
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sim
condition|)
goto|goto
name|fail
goto|;
name|SYM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|sim
argument_list|,
name|np
operator|->
name|device
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
goto|goto
name|fail
goto|;
name|np
operator|->
name|sim
operator|=
name|sim
expr_stmt|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|path
argument_list|,
literal|0
argument_list|,
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|np
operator|->
name|path
operator|=
name|path
expr_stmt|;
comment|/* 	 *  Establish our async notification handler. 	 */
if|if
condition|(
name|xpt_register_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|sym_async
argument_list|,
name|sim
argument_list|,
name|path
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 *  Start the chip now, without resetting the BUS, since 	 *  it seems that this must stay under control of CAM. 	 *  With LVD/SE capable chips and BUS in SE mode, we may 	 *  get a spurious SMBC interrupt. 	 */
name|sym_init
argument_list|(
name|np
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SYM_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
name|fail
label|:
if|if
condition|(
name|sim
condition|)
name|cam_sim_free
argument_list|(
name|sim
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
condition|)
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|SYM_UNLOCK
argument_list|()
expr_stmt|;
name|sym_cam_free
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  *  Free everything that deals with CAM.  */
specifier|static
name|void
name|sym_cam_free
parameter_list|(
name|hcb_p
name|np
parameter_list|)
block|{
name|SYM_LOCK_ASSERT
argument_list|(
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|intr
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|np
operator|->
name|device
argument_list|,
name|np
operator|->
name|irq_res
argument_list|,
name|np
operator|->
name|intr
argument_list|)
expr_stmt|;
name|np
operator|->
name|intr
operator|=
name|NULL
expr_stmt|;
block|}
name|SYM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|sim
condition|)
block|{
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|np
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|np
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|np
operator|->
name|sim
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|path
condition|)
block|{
name|xpt_free_path
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
name|np
operator|->
name|path
operator|=
name|NULL
expr_stmt|;
block|}
name|SYM_UNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/*============ OPTIONNAL NVRAM SUPPORT =================*/
comment|/*  *  Get host setup from NVRAM.  */
specifier|static
name|void
name|sym_nvram_setup_host
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvram
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
comment|/* 	 *  Get parity checking, host ID, verbose mode 	 *  and miscellaneous host flags from NVRAM. 	 */
switch|switch
condition|(
name|nvram
operator|->
name|type
condition|)
block|{
case|case
name|SYM_SYMBIOS_NVRAM
case|:
if|if
condition|(
operator|!
operator|(
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|flags
operator|&
name|SYMBIOS_PARITY_ENABLE
operator|)
condition|)
name|np
operator|->
name|rv_scntl0
operator|&=
operator|~
literal|0x0a
expr_stmt|;
name|np
operator|->
name|myaddr
operator|=
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|host_id
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|flags
operator|&
name|SYMBIOS_VERBOSE_MSGS
condition|)
name|np
operator|->
name|verbose
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|flags1
operator|&
name|SYMBIOS_SCAN_HI_LO
condition|)
name|np
operator|->
name|usrflags
operator||=
name|SYM_SCAN_TARGETS_HILO
expr_stmt|;
if|if
condition|(
name|nvram
operator|->
name|data
operator|.
name|Symbios
operator|.
name|flags2
operator|&
name|SYMBIOS_AVOID_BUS_RESET
condition|)
name|np
operator|->
name|usrflags
operator||=
name|SYM_AVOID_BUS_RESET
expr_stmt|;
break|break;
case|case
name|SYM_TEKRAM_NVRAM
case|:
name|np
operator|->
name|myaddr
operator|=
name|nvram
operator|->
name|data
operator|.
name|Tekram
operator|.
name|host_id
operator|&
literal|0x0f
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
block|}
comment|/*  *  Get target setup from NVRAM.  */
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
specifier|static
name|void
name|sym_Symbios_setup_target
argument_list|(
name|hcb_p
name|np
argument_list|,
name|int
name|target
argument_list|,
name|Symbios_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
specifier|static
name|void
name|sym_Tekram_setup_target
argument_list|(
name|hcb_p
name|np
argument_list|,
name|int
name|target
argument_list|,
name|Tekram_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|static
name|void
name|sym_nvram_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
switch|switch
condition|(
name|nvp
operator|->
name|type
condition|)
block|{
case|case
name|SYM_SYMBIOS_NVRAM
case|:
name|sym_Symbios_setup_target
argument_list|(
name|np
argument_list|,
name|target
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Symbios
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYM_TEKRAM_NVRAM
case|:
name|sym_Tekram_setup_target
argument_list|(
name|np
argument_list|,
name|target
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Tekram
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
comment|/*  *  Get target set-up from Symbios format NVRAM.  */
specifier|static
name|void
name|sym_Symbios_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|Symbios_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|Symbios_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|tn
operator|->
name|sync_period
condition|?
operator|(
name|tn
operator|->
name|sync_period
operator|+
literal|3
operator|)
operator|/
literal|4
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|tn
operator|->
name|bus_width
operator|==
literal|0x10
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
name|tp
operator|->
name|usrtags
operator|=
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_QUEUE_TAGS_ENABLED
operator|)
condition|?
name|SYM_SETUP_MAX_TAG
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_DISCONNECT_ENABLE
operator|)
condition|)
name|tp
operator|->
name|usrflags
operator|&=
operator|~
name|SYM_DISC_ENABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_AT_BOOT_TIME
operator|)
condition|)
name|tp
operator|->
name|usrflags
operator||=
name|SYM_SCAN_BOOT_DISABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_LUNS
operator|)
condition|)
name|tp
operator|->
name|usrflags
operator||=
name|SYM_SCAN_LUNS_DISABLED
expr_stmt|;
block|}
comment|/*  *  Get target set-up from Tekram format NVRAM.  */
specifier|static
name|void
name|sym_Tekram_setup_target
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|target
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|tcb_p
name|tp
init|=
operator|&
name|np
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|struct
name|Tekram_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|target
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_SYNC_NEGO
condition|)
block|{
name|i
operator|=
name|tn
operator|->
name|sync_index
operator|&
literal|0xf
expr_stmt|;
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|Tekram_sync
index|[
name|i
index|]
expr_stmt|;
block|}
name|tp
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_WIDE_NEGO
operator|)
condition|?
name|BUS_16_BIT
else|:
name|BUS_8_BIT
expr_stmt|;
if|if
condition|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_TAGGED_COMMANDS
condition|)
block|{
name|tp
operator|->
name|usrtags
operator|=
literal|2
operator|<<
name|nvram
operator|->
name|max_tags_index
expr_stmt|;
block|}
if|if
condition|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_DISCONNECT_ENABLE
condition|)
name|tp
operator|->
name|usrflags
operator||=
name|SYM_DISC_ENABLED
expr_stmt|;
comment|/* If any device does not support parity, we will not use this option */
if|if
condition|(
operator|!
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_PARITY_CHECK
operator|)
condition|)
name|np
operator|->
name|rv_scntl0
operator|&=
operator|~
literal|0x0a
expr_stmt|;
comment|/* SCSI parity checking disabled */
block|}
ifdef|#
directive|ifdef
name|SYM_CONF_DEBUG_NVRAM
comment|/*  *  Dump Symbios format NVRAM for debugging purpose.  */
specifier|static
name|void
name|sym_display_Symbios_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Symbios_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* display Symbios nvram host data */
name|printf
argument_list|(
literal|"%s: HOST ID=%d%s%s%s%s%s%s\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|nvram
operator|->
name|host_id
operator|&
literal|0x0f
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_SCAM_ENABLE
operator|)
condition|?
literal|" SCAM"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_PARITY_ENABLE
operator|)
condition|?
literal|" PARITY"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_VERBOSE_MSGS
operator|)
condition|?
literal|" VERBOSE"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|SYMBIOS_CHS_MAPPING
operator|)
condition|?
literal|" CHS_ALT"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags2
operator|&
name|SYMBIOS_AVOID_BUS_RESET
operator|)
condition|?
literal|" NO_RESET"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags1
operator|&
name|SYMBIOS_SCAN_HI_LO
operator|)
condition|?
literal|" HI_LO"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* display Symbios nvram drive data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|Symbios_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"%s-%d:%s%s%s%s WIDTH=%d SYNC=%d TMO=%d\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_DISCONNECT_ENABLE
operator|)
condition|?
literal|" DISC"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_AT_BOOT_TIME
operator|)
condition|?
literal|" SCAN_BOOT"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_SCAN_LUNS
operator|)
condition|?
literal|" SCAN_LUNS"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|SYMBIOS_QUEUE_TAGS_ENABLED
operator|)
condition|?
literal|" TCQ"
else|:
literal|""
argument_list|,
name|tn
operator|->
name|bus_width
argument_list|,
name|tn
operator|->
name|sync_period
operator|/
literal|4
argument_list|,
name|tn
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *  Dump TEKRAM format NVRAM for debugging purpose.  */
specifier|static
specifier|const
name|u_char
name|Tekram_boot_delay
index|[
literal|7
index|]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|10
block|,
literal|20
block|,
literal|30
block|,
literal|60
block|,
literal|120
block|}
decl_stmt|;
specifier|static
name|void
name|sym_display_Tekram_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tags
decl_stmt|,
name|boot_delay
decl_stmt|;
name|char
modifier|*
name|rem
decl_stmt|;
comment|/* display Tekram nvram host data */
name|tags
operator|=
literal|2
operator|<<
name|nvram
operator|->
name|max_tags_index
expr_stmt|;
name|boot_delay
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvram
operator|->
name|boot_delay_index
operator|<
literal|6
condition|)
name|boot_delay
operator|=
name|Tekram_boot_delay
index|[
name|nvram
operator|->
name|boot_delay_index
index|]
expr_stmt|;
switch|switch
condition|(
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_REMOVABLE_FLAGS
operator|)
operator|>>
literal|6
condition|)
block|{
default|default:
case|case
literal|0
case|:
name|rem
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rem
operator|=
literal|" REMOVABLE=boot device"
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rem
operator|=
literal|" REMOVABLE=all"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s: HOST ID=%d%s%s%s%s%s%s%s%s%s BOOT DELAY=%d tags=%d\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|nvram
operator|->
name|host_id
operator|&
literal|0x0f
argument_list|,
operator|(
name|nvram
operator|->
name|flags1
operator|&
name|SYMBIOS_SCAM_ENABLE
operator|)
condition|?
literal|" SCAM"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_MORE_THAN_2_DRIVES
operator|)
condition|?
literal|">2DRIVES"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_DRIVES_SUP_1GB
operator|)
condition|?
literal|">1GB"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_RESET_ON_POWER_ON
operator|)
condition|?
literal|" RESET"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_ACTIVE_NEGATION
operator|)
condition|?
literal|" ACT_NEG"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_IMMEDIATE_SEEK
operator|)
condition|?
literal|" IMM_SEEK"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags
operator|&
name|TEKRAM_SCAN_LUNS
operator|)
condition|?
literal|" SCAN_LUNS"
else|:
literal|""
argument_list|,
operator|(
name|nvram
operator|->
name|flags1
operator|&
name|TEKRAM_F2_F6_ENABLED
operator|)
condition|?
literal|" F2_F6"
else|:
literal|""
argument_list|,
name|rem
argument_list|,
name|boot_delay
argument_list|,
name|tags
argument_list|)
expr_stmt|;
comment|/* display Tekram nvram drive data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|15
condition|;
name|i
operator|++
control|)
block|{
name|int
name|sync
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|Tekram_target
modifier|*
name|tn
init|=
operator|&
name|nvram
operator|->
name|target
index|[
name|i
index|]
decl_stmt|;
name|j
operator|=
name|tn
operator|->
name|sync_index
operator|&
literal|0xf
expr_stmt|;
name|sync
operator|=
name|Tekram_sync
index|[
name|j
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s-%d:%s%s%s%s%s%s PERIOD=%d\n"
argument_list|,
name|sym_name
argument_list|(
name|np
argument_list|)
argument_list|,
name|i
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_PARITY_CHECK
operator|)
condition|?
literal|" PARITY"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_SYNC_NEGO
operator|)
condition|?
literal|" SYNC"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_DISCONNECT_ENABLE
operator|)
condition|?
literal|" DISC"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_START_CMD
operator|)
condition|?
literal|" START"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_TAGGED_COMMANDS
operator|)
condition|?
literal|" TCQ"
else|:
literal|""
argument_list|,
operator|(
name|tn
operator|->
name|flags
operator|&
name|TEKRAM_WIDE_NEGO
operator|)
condition|?
literal|" WIDE"
else|:
literal|""
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SYM_CONF_DEBUG_NVRAM */
endif|#
directive|endif
comment|/* SYM_CONF_NVRAM_SUPPORT */
comment|/*  *  Try reading Symbios or Tekram NVRAM  */
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
specifier|static
name|int
name|sym_read_Symbios_nvram
argument_list|(
name|hcb_p
name|np
argument_list|,
name|Symbios_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
specifier|static
name|int
name|sym_read_Tekram_nvram
argument_list|(
name|hcb_p
name|np
argument_list|,
name|Tekram_nvram
operator|*
name|nvram
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|sym_read_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|struct
name|sym_nvram
modifier|*
name|nvp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
comment|/* 	 *  Try to read SYMBIOS nvram. 	 *  Try to read TEKRAM nvram if Symbios nvram not found. 	 */
if|if
condition|(
name|SYM_SETUP_SYMBIOS_NVRAM
operator|&&
operator|!
name|sym_read_Symbios_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Symbios
argument_list|)
condition|)
block|{
name|nvp
operator|->
name|type
operator|=
name|SYM_SYMBIOS_NVRAM
expr_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_DEBUG_NVRAM
name|sym_display_Symbios_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Symbios
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|SYM_SETUP_TEKRAM_NVRAM
operator|&&
operator|!
name|sym_read_Tekram_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Tekram
argument_list|)
condition|)
block|{
name|nvp
operator|->
name|type
operator|=
name|SYM_TEKRAM_NVRAM
expr_stmt|;
ifdef|#
directive|ifdef
name|SYM_CONF_DEBUG_NVRAM
name|sym_display_Tekram_nvram
argument_list|(
name|np
argument_list|,
operator|&
name|nvp
operator|->
name|data
operator|.
name|Tekram
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|nvp
operator|->
name|type
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|nvp
operator|->
name|type
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|nvp
operator|->
name|type
return|;
block|}
ifdef|#
directive|ifdef
name|SYM_CONF_NVRAM_SUPPORT
comment|/*  *  24C16 EEPROM reading.  *  *  GPOI0 - data in/data out  *  GPIO1 - clock  *  Symbios NVRAM wiring now also used by Tekram.  */
define|#
directive|define
name|SET_BIT
value|0
define|#
directive|define
name|CLR_BIT
value|1
define|#
directive|define
name|SET_CLK
value|2
define|#
directive|define
name|CLR_CLK
value|3
comment|/*  *  Set/clear data/clock bit in GPIO0  */
specifier|static
name|void
name|S24C16_set_bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|int
name|bit_mode
parameter_list|)
block|{
name|UDELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bit_mode
condition|)
block|{
case|case
name|SET_BIT
case|:
operator|*
name|gpreg
operator||=
name|write_bit
expr_stmt|;
break|break;
case|case
name|CLR_BIT
case|:
operator|*
name|gpreg
operator|&=
literal|0xfe
expr_stmt|;
break|break;
case|case
name|SET_CLK
case|:
operator|*
name|gpreg
operator||=
literal|0x02
expr_stmt|;
break|break;
case|case
name|CLR_CLK
case|:
operator|*
name|gpreg
operator|&=
literal|0xfd
expr_stmt|;
break|break;
block|}
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send START condition to NVRAM to wake it up.  */
specifier|static
name|void
name|S24C16_start
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|,
name|SET_BIT
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|SET_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_BIT
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_CLK
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZzzzz!!  */
specifier|static
name|void
name|S24C16_stop
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|SET_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|,
name|SET_BIT
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Read or write a bit to the NVRAM,  *  read if GPIO0 input else write if GPIO0 output  */
specifier|static
name|void
name|S24C16_do_bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
name|write_bit
argument_list|,
name|gpreg
argument_list|,
name|SET_BIT
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|SET_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bit
condition|)
operator|*
name|read_bit
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|gpreg
argument_list|,
name|CLR_BIT
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Output an ACK to the NVRAM after reading,  *  change GPIO0 to output and when done back to an input  */
specifier|static
name|void
name|S24C16_write_ack
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
operator|&
literal|0xfe
argument_list|)
expr_stmt|;
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|write_bit
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Input an ACK from NVRAM after writing,  *  change GPIO0 to input and when done back to an output  */
specifier|static
name|void
name|S24C16_read_ack
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
name|read_bit
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
operator|*
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  WRITE a byte to the NVRAM and then get an ACK to see it was accepted OK,  *  GPIO0 must already be set as an output  */
specifier|static
name|void
name|S24C16_write_byte
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|ack_data
parameter_list|,
name|u_char
name|write_data
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
name|x
operator|++
control|)
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|(
name|write_data
operator|>>
operator|(
literal|7
operator|-
name|x
operator|)
operator|)
operator|&
literal|0x01
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|S24C16_read_ack
argument_list|(
name|np
argument_list|,
name|ack_data
argument_list|,
name|gpreg
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  READ a byte from the NVRAM and then send an ACK to say we have got it,  *  GPIO0 must already be set as an input  */
specifier|static
name|void
name|S24C16_read_byte
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_data
parameter_list|,
name|u_char
name|ack_data
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|,
name|u_char
modifier|*
name|gpcntl
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_char
name|read_bit
decl_stmt|;
operator|*
name|read_data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|8
condition|;
name|x
operator|++
control|)
block|{
name|S24C16_do_bit
argument_list|(
name|np
argument_list|,
operator|&
name|read_bit
argument_list|,
literal|1
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
operator|*
name|read_data
operator||=
operator|(
operator|(
name|read_bit
operator|&
literal|0x01
operator|)
operator|<<
operator|(
literal|7
operator|-
name|x
operator|)
operator|)
expr_stmt|;
block|}
name|S24C16_write_ack
argument_list|(
name|np
argument_list|,
name|ack_data
argument_list|,
name|gpreg
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Read 'len' bytes starting at 'offset'.  */
specifier|static
name|int
name|sym_read_S24C16_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
name|gpcntl
decl_stmt|,
name|gpreg
decl_stmt|;
name|u_char
name|old_gpcntl
decl_stmt|,
name|old_gpreg
decl_stmt|;
name|u_char
name|ack_data
decl_stmt|;
name|int
name|retv
init|=
literal|1
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* save current state of GPCNTL and GPREG */
name|old_gpreg
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
name|old_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
name|gpcntl
operator|=
name|old_gpcntl
operator|&
literal|0x1c
expr_stmt|;
comment|/* set up GPREG& GPCNTL to set GPIO0 and GPIO1 in to known state */
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|old_gpreg
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* this is to set NVRAM into a known state with GPIO0/1 both low */
name|gpreg
operator|=
name|old_gpreg
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|&
name|gpreg
argument_list|,
name|CLR_CLK
argument_list|)
expr_stmt|;
name|S24C16_set_bit
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
operator|&
name|gpreg
argument_list|,
name|CLR_BIT
argument_list|)
expr_stmt|;
comment|/* now set NVRAM inactive with GPIO0/1 both high */
name|S24C16_stop
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* activate NVRAM */
name|S24C16_start
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* write device code and random address MSB */
name|S24C16_write_byte
argument_list|(
name|np
argument_list|,
operator|&
name|ack_data
argument_list|,
literal|0xa0
operator||
operator|(
operator|(
name|offset
operator|>>
literal|7
operator|)
operator|&
literal|0x0e
operator|)
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_data
operator|&
literal|0x01
condition|)
goto|goto
name|out
goto|;
comment|/* write random address LSB */
name|S24C16_write_byte
argument_list|(
name|np
argument_list|,
operator|&
name|ack_data
argument_list|,
name|offset
operator|&
literal|0xff
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_data
operator|&
literal|0x01
condition|)
goto|goto
name|out
goto|;
comment|/* regenerate START state to set up for reading */
name|S24C16_start
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* rewrite device code and address MSB with read bit set (lsb = 0x01) */
name|S24C16_write_byte
argument_list|(
name|np
argument_list|,
operator|&
name|ack_data
argument_list|,
literal|0xa1
operator||
operator|(
operator|(
name|offset
operator|>>
literal|7
operator|)
operator|&
literal|0x0e
operator|)
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_data
operator|&
literal|0x01
condition|)
goto|goto
name|out
goto|;
comment|/* now set up GPIO0 for inputting data */
name|gpcntl
operator||=
literal|0x01
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* input all requested data - only part of total NVRAM */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
name|S24C16_read_byte
argument_list|(
name|np
argument_list|,
operator|&
name|data
index|[
name|x
index|]
argument_list|,
operator|(
name|x
operator|==
operator|(
name|len
operator|-
literal|1
operator|)
operator|)
argument_list|,
operator|&
name|gpreg
argument_list|,
operator|&
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* finally put NVRAM back in inactive mode */
name|gpcntl
operator|&=
literal|0xfe
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
name|S24C16_stop
argument_list|(
name|np
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
name|retv
operator|=
literal|0
expr_stmt|;
name|out
label|:
comment|/* return GPIO0/1 to original states after having accessed NVRAM */
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|old_gpcntl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|old_gpreg
argument_list|)
expr_stmt|;
return|return
name|retv
return|;
block|}
undef|#
directive|undef
name|SET_BIT
comment|/* 0 */
undef|#
directive|undef
name|CLR_BIT
comment|/* 1 */
undef|#
directive|undef
name|SET_CLK
comment|/* 2 */
undef|#
directive|undef
name|CLR_CLK
comment|/* 3 */
comment|/*  *  Try reading Symbios NVRAM.  *  Return 0 if OK.  */
specifier|static
name|int
name|sym_read_Symbios_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Symbios_nvram
modifier|*
name|nvram
parameter_list|)
block|{
specifier|static
name|u_char
name|Symbios_trailer
index|[
literal|6
index|]
init|=
block|{
literal|0xfe
block|,
literal|0xfe
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|nvram
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|nvram
argument_list|)
decl_stmt|;
name|u_short
name|csum
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* probe the 24c16 and read the SYMBIOS 24c16 area */
if|if
condition|(
name|sym_read_S24C16_nvram
argument_list|(
name|np
argument_list|,
name|SYMBIOS_NVRAM_ADDRESS
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* check valid NVRAM signature, verify byte count and checksum */
if|if
condition|(
name|nvram
operator|->
name|type
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
name|nvram
operator|->
name|trailer
argument_list|,
name|Symbios_trailer
argument_list|,
literal|6
argument_list|)
operator|||
name|nvram
operator|->
name|byte_count
operator|!=
name|len
operator|-
literal|12
condition|)
return|return
literal|1
return|;
comment|/* verify checksum */
for|for
control|(
name|x
operator|=
literal|6
operator|,
name|csum
operator|=
literal|0
init|;
name|x
operator|<
name|len
operator|-
literal|6
condition|;
name|x
operator|++
control|)
name|csum
operator|+=
name|data
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|nvram
operator|->
name|checksum
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/*  *  93C46 EEPROM reading.  *  *  GPOI0 - data in  *  GPIO1 - data out  *  GPIO2 - clock  *  GPIO4 - chip select  *  *  Used by Tekram.  */
comment|/*  *  Pulse clock bit in GPIO0  */
specifier|static
name|void
name|T93C46_Clk
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
operator||
literal|0x04
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Read bit from NVRAM  */
specifier|static
name|void
name|T93C46_Read_Bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|T93C46_Clk
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
operator|*
name|read_bit
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Write bit to GPIO0  */
specifier|static
name|void
name|T93C46_Write_Bit
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
name|write_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
if|if
condition|(
name|write_bit
operator|&
literal|0x01
condition|)
operator|*
name|gpreg
operator||=
literal|0x02
expr_stmt|;
else|else
operator|*
name|gpreg
operator|&=
literal|0xfd
expr_stmt|;
operator|*
name|gpreg
operator||=
literal|0x10
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|T93C46_Clk
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send STOP condition to NVRAM - puts NVRAM to sleep... ZZZzzz!!  */
specifier|static
name|void
name|T93C46_Stop
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
operator|*
name|gpreg
operator|&=
literal|0xef
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
operator|*
name|gpreg
argument_list|)
expr_stmt|;
name|UDELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|T93C46_Clk
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  Send read command and address to NVRAM  */
specifier|static
name|void
name|T93C46_Send_Command
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
name|write_data
parameter_list|,
name|u_char
modifier|*
name|read_bit
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* send 9 bits, start bit (1), command (2), address (6)  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|9
condition|;
name|x
operator|++
control|)
name|T93C46_Write_Bit
argument_list|(
name|np
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|write_data
operator|>>
operator|(
literal|8
operator|-
name|x
operator|)
argument_list|)
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
operator|*
name|read_bit
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
block|}
comment|/*  *  READ 2 bytes from the NVRAM  */
specifier|static
name|void
name|T93C46_Read_Word
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
modifier|*
name|nvram_data
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_char
name|read_bit
decl_stmt|;
operator|*
name|nvram_data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|16
condition|;
name|x
operator|++
control|)
block|{
name|T93C46_Read_Bit
argument_list|(
name|np
argument_list|,
operator|&
name|read_bit
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bit
operator|&
literal|0x01
condition|)
operator|*
name|nvram_data
operator||=
operator|(
literal|0x01
operator|<<
operator|(
literal|15
operator|-
name|x
operator|)
operator|)
expr_stmt|;
else|else
operator|*
name|nvram_data
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
literal|15
operator|-
name|x
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/*  *  Read Tekram NvRAM data.  */
specifier|static
name|int
name|T93C46_Read_Data
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|u_short
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|u_char
modifier|*
name|gpreg
parameter_list|)
block|{
name|u_char
name|read_bit
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
block|{
comment|/* output read command and address */
name|T93C46_Send_Command
argument_list|(
name|np
argument_list|,
literal|0x180
operator||
name|x
argument_list|,
operator|&
name|read_bit
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_bit
operator|&
literal|0x01
condition|)
return|return
literal|1
return|;
comment|/* Bad */
name|T93C46_Read_Word
argument_list|(
name|np
argument_list|,
operator|&
name|data
index|[
name|x
index|]
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|T93C46_Stop
argument_list|(
name|np
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  *  Try reading 93C46 Tekram NVRAM.  */
specifier|static
name|int
name|sym_read_T93C46_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|u_char
name|gpcntl
decl_stmt|,
name|gpreg
decl_stmt|;
name|u_char
name|old_gpcntl
decl_stmt|,
name|old_gpreg
decl_stmt|;
name|int
name|retv
init|=
literal|1
decl_stmt|;
comment|/* save current state of GPCNTL and GPREG */
name|old_gpreg
operator|=
name|INB
argument_list|(
name|nc_gpreg
argument_list|)
expr_stmt|;
name|old_gpcntl
operator|=
name|INB
argument_list|(
name|nc_gpcntl
argument_list|)
expr_stmt|;
comment|/* set up GPREG& GPCNTL to set GPIO0/1/2/4 in to known state, 0 in, 	   1/2/4 out */
name|gpreg
operator|=
name|old_gpreg
operator|&
literal|0xe9
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
name|gpcntl
operator|=
operator|(
name|old_gpcntl
operator|&
literal|0xe9
operator|)
operator||
literal|0x09
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|gpcntl
argument_list|)
expr_stmt|;
comment|/* input all of NVRAM, 64 words */
name|retv
operator|=
name|T93C46_Read_Data
argument_list|(
name|np
argument_list|,
operator|(
name|u_short
operator|*
operator|)
name|nvram
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nvram
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
operator|&
name|gpreg
argument_list|)
expr_stmt|;
comment|/* return GPIO0/1/2/4 to original states after having accessed NVRAM */
name|OUTB
argument_list|(
name|nc_gpcntl
argument_list|,
name|old_gpcntl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|nc_gpreg
argument_list|,
name|old_gpreg
argument_list|)
expr_stmt|;
return|return
name|retv
return|;
block|}
comment|/*  *  Try reading Tekram NVRAM.  *  Return 0 if OK.  */
specifier|static
name|int
name|sym_read_Tekram_nvram
parameter_list|(
name|hcb_p
name|np
parameter_list|,
name|Tekram_nvram
modifier|*
name|nvram
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|nvram
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|nvram
argument_list|)
decl_stmt|;
name|u_short
name|csum
decl_stmt|;
name|int
name|x
decl_stmt|;
switch|switch
condition|(
name|np
operator|->
name|device_id
condition|)
block|{
case|case
name|PCI_ID_SYM53C885
case|:
case|case
name|PCI_ID_SYM53C895
case|:
case|case
name|PCI_ID_SYM53C896
case|:
name|x
operator|=
name|sym_read_S24C16_nvram
argument_list|(
name|np
argument_list|,
name|TEKRAM_24C16_NVRAM_ADDRESS
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI_ID_SYM53C875
case|:
name|x
operator|=
name|sym_read_S24C16_nvram
argument_list|(
name|np
argument_list|,
name|TEKRAM_24C16_NVRAM_ADDRESS
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
break|break;
default|default:
name|x
operator|=
name|sym_read_T93C46_nvram
argument_list|(
name|np
argument_list|,
name|nvram
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|x
condition|)
return|return
literal|1
return|;
comment|/* verify checksum */
for|for
control|(
name|x
operator|=
literal|0
operator|,
name|csum
operator|=
literal|0
init|;
name|x
operator|<
name|len
operator|-
literal|1
condition|;
name|x
operator|+=
literal|2
control|)
name|csum
operator|+=
name|data
index|[
name|x
index|]
operator|+
operator|(
name|data
index|[
name|x
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
literal|0x1234
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYM_CONF_NVRAM_SUPPORT */
end_comment

end_unit

