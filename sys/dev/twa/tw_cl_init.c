begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-05 Applied Micro Circuits Corporation.  * Copyright (c) 2004-05 Vinod Kashyap  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * AMCC'S 3ware driver for 9000 series storage controllers.  *  * Author: Vinod Kashyap  */
end_comment

begin_comment
comment|/*  * Common Layer initialization functions.  */
end_comment

begin_include
include|#
directive|include
file|"tw_osl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_fwif.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_externs.h"
end_include

begin_include
include|#
directive|include
file|"tw_osl_ioctl.h"
end_include

begin_comment
comment|/*  * Function name:	tw_cl_ctlr_supported  * Description:		Determines if a controller is supported.  *  * Input:		vendor_id -- vendor id of the controller  *			device_id -- device id of the controller  * Output:		None  * Return value:	TW_CL_TRUE-- controller supported  *			TW_CL_FALSE-- controller not supported  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_ctlr_supported
parameter_list|(
name|TW_INT32
name|vendor_id
parameter_list|,
name|TW_INT32
name|device_id
parameter_list|)
block|{
if|if
condition|(
operator|(
name|vendor_id
operator|==
name|TW_CL_VENDOR_ID
operator|)
operator|&&
operator|(
operator|(
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K
operator|)
operator|||
operator|(
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_X
operator|)
operator|)
condition|)
return|return
operator|(
name|TW_CL_TRUE
operator|)
return|;
return|return
operator|(
name|TW_CL_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_get_pci_bar_info  * Description:		Returns PCI BAR info.  *  * Input:		device_id -- device id of the controller  *			bar_type -- type of PCI BAR in question  * Output:		bar_num -- PCI BAR number corresponding to bar_type  *			bar0_offset -- byte offset from BAR 0 (0x10 in  *					PCI config space)  *			bar_size -- size, in bytes, of the BAR in question  * Return value:	0 -- success  *			non-zero -- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_get_pci_bar_info
parameter_list|(
name|TW_INT32
name|device_id
parameter_list|,
name|TW_INT32
name|bar_type
parameter_list|,
name|TW_INT32
modifier|*
name|bar_num
parameter_list|,
name|TW_INT32
modifier|*
name|bar0_offset
parameter_list|,
name|TW_INT32
modifier|*
name|bar_size
parameter_list|)
block|{
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
switch|switch
condition|(
name|device_id
condition|)
block|{
case|case
name|TW_CL_DEVICE_ID_9K
case|:
switch|switch
condition|(
name|bar_type
condition|)
block|{
case|case
name|TW_CL_BAR_TYPE_IO
case|:
operator|*
name|bar_num
operator|=
literal|0
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_MEM
case|:
operator|*
name|bar_num
operator|=
literal|1
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0x4
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_SBUF
case|:
operator|*
name|bar_num
operator|=
literal|2
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0xC
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TW_CL_DEVICE_ID_9K_X
case|:
switch|switch
condition|(
name|bar_type
condition|)
block|{
case|case
name|TW_CL_BAR_TYPE_IO
case|:
operator|*
name|bar_num
operator|=
literal|2
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0x10
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_MEM
case|:
operator|*
name|bar_num
operator|=
literal|1
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0x8
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_SBUF
case|:
operator|*
name|bar_num
operator|=
literal|0
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|TW_OSL_ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_get_mem_requirements  * Description:		Provides info about Common Layer requirements for a  *			controller, given the controller type (in 'flags').  * Input:		ctlr_handle -- controller handle  *			flags -- more info passed by the OS Layer  *			device_id -- device id of the controller  *			max_simult_reqs -- maximum # of simultaneous  *					requests that the OS Layer expects  *					the Common Layer to support  *			max_aens -- maximun # of AEN's needed to be supported  * Output:		alignment -- alignment needed for all DMA'able  *					buffers  *			sg_size_factor -- every SG element should have a size  *					that's a multiple of this number  *			non_dma_mem_size -- # of bytes of memory needed for  *					non-DMA purposes  *			dma_mem_size -- # of bytes of DMA'able memory needed  *			flash_dma_mem_size -- # of bytes of DMA'able memory  *					needed for firmware flash, if applicable  *			per_req_dma_mem_size -- # of bytes of DMA'able memory  *					needed per request, if applicable  *			per_req_non_dma_mem_size -- # of bytes of memory needed  *					per request for non-DMA purposes,  *					if applicable  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_get_mem_requirements
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_UINT32
name|flags
parameter_list|,
name|TW_INT32
name|device_id
parameter_list|,
name|TW_INT32
name|max_simult_reqs
parameter_list|,
name|TW_INT32
name|max_aens
parameter_list|,
name|TW_UINT32
modifier|*
name|alignment
parameter_list|,
name|TW_UINT32
modifier|*
name|sg_size_factor
parameter_list|,
name|TW_UINT32
modifier|*
name|non_dma_mem_size
parameter_list|,
name|TW_UINT32
modifier|*
name|dma_mem_size
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
parameter_list|,
name|TW_UINT32
modifier|*
name|flash_dma_mem_size
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
ifdef|#
directive|ifdef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
parameter_list|,
name|TW_UINT32
modifier|*
name|per_req_dma_mem_size
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
parameter_list|,
name|TW_UINT32
modifier|*
name|per_req_non_dma_mem_size
endif|#
directive|endif
comment|/* TW_OSL_N0N_DMA_MEM_ALLOC_PER_REQUEST */
parameter_list|)
block|{
if|if
condition|(
name|device_id
operator|==
literal|0
condition|)
name|device_id
operator|=
name|TW_CL_DEVICE_ID_9K
expr_stmt|;
if|if
condition|(
name|max_simult_reqs
operator|>
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1000
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Too many simultaneous requests to support!"
argument_list|,
literal|"requested = %d, supported = %d, error = %d\n"
argument_list|,
name|max_simult_reqs
argument_list|,
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
argument_list|,
name|TW_OSL_EBIG
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBIG
operator|)
return|;
block|}
operator|*
name|alignment
operator|=
name|TWA_ALIGNMENT
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
operator|*
name|sg_size_factor
operator|=
name|TWA_SG_ELEMENT_SIZE_FACTOR
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
comment|/* 	 * Total non-DMA memory needed is the sum total of memory needed for 	 * the controller context, request packets (including the 1 needed for 	 * CL internal requests), and event packets. 	 */
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
operator|*
name|non_dma_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
operator|*
name|max_aens
operator|)
expr_stmt|;
operator|*
name|per_req_non_dma_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
operator|*
name|non_dma_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
operator|*
name|max_aens
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
comment|/* 	 * Total DMA'able memory needed is the sum total of memory needed for 	 * all command packets (including the 1 needed for CL internal 	 * requests), and memory needed to hold the payload for internal 	 * requests. 	 */
ifdef|#
directive|ifdef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
operator|*
name|dma_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|+
name|TW_CLI_SECTOR_SIZE
expr_stmt|;
operator|*
name|per_req_dma_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
operator|*
name|dma_mem_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
name|TW_CLI_SECTOR_SIZE
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
comment|/* Memory needed to hold the firmware image while flashing. */
operator|*
name|flash_dma_mem_size
operator|=
operator|(
operator|(
name|tw_cli_fw_img_size
operator|/
name|TW_CLI_NUM_FW_IMAGE_CHUNKS
operator|)
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
comment|/*		(TWA_SG_ELEMENT_SIZE_FACTOR(device_id) - 1))& 		~(TWA_SG_ELEMENT_SIZE_FACTOR(device_id) - 1); */
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_init_ctlr  * Description:		Initializes driver data structures for the controller.  *  * Input:		ctlr_handle -- controller handle  *			flags -- more info passed by the OS Layer  *			device_id -- device id of the controller  *			max_simult_reqs -- maximum # of simultaneous requests  *					that the OS Layer expects the Common  *					Layer to support  *			max_aens -- maximun # of AEN's needed to be supported  *			non_dma_mem -- ptr to allocated non-DMA memory  *			dma_mem -- ptr to allocated DMA'able memory  *			dma_mem_phys -- physical address of dma_mem  *			flash_dma_mem -- ptr to allocated DMA'able memory  *				needed for firmware flash, if applicable  *			flash_dma_mem_phys -- physical address of flash_dma_mem  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_init_ctlr
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_UINT32
name|flags
parameter_list|,
name|TW_INT32
name|device_id
parameter_list|,
name|TW_INT32
name|max_simult_reqs
parameter_list|,
name|TW_INT32
name|max_aens
parameter_list|,
name|TW_VOID
modifier|*
name|non_dma_mem
parameter_list|,
name|TW_VOID
modifier|*
name|dma_mem
parameter_list|,
name|TW_UINT64
name|dma_mem_phys
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
parameter_list|,
name|TW_VOID
modifier|*
name|flash_dma_mem
parameter_list|,
name|TW_UINT64
name|flash_dma_mem_phys
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
decl_stmt|;
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|TW_UINT8
modifier|*
name|free_non_dma_mem
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
name|TW_INT32
name|i
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TW_CL_START_CTLR_ONLY
condition|)
block|{
name|ctlr
operator|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
expr_stmt|;
goto|goto
name|start_ctlr
goto|;
block|}
if|if
condition|(
name|max_simult_reqs
operator|>
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1000
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Too many simultaneous requests to support!"
argument_list|,
literal|"requested = %d, supported = %d, error = %d\n"
argument_list|,
name|max_simult_reqs
argument_list|,
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
argument_list|,
name|TW_OSL_EBIG
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBIG
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|non_dma_mem
operator|==
name|TW_CL_NULL
operator|)
operator|||
operator|(
name|dma_mem
operator|==
name|TW_CL_NULL
operator|)
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
operator|||
operator|(
operator|(
name|flags
operator|&
name|TW_CL_FLASH_FIRMWARE
operator|)
condition|?
operator|(
name|flash_dma_mem
operator|==
name|TW_CL_NULL
operator|)
else|:
name|TW_CL_FALSE
operator|)
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1001
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Insufficient memory for Common Layer's internal usage"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|TW_OSL_ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_ENOMEM
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
name|tw_osl_memzero
argument_list|(
name|non_dma_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
operator|*
name|max_aens
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
name|tw_osl_memzero
argument_list|(
name|non_dma_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
operator|*
name|max_aens
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
ifdef|#
directive|ifdef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|tw_osl_memzero
argument_list|(
name|dma_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|+
name|TW_CLI_SECTOR_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
name|tw_osl_memzero
argument_list|(
name|dma_mem
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
name|TW_CLI_SECTOR_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
name|free_non_dma_mem
operator|=
operator|(
name|TW_UINT8
operator|*
operator|)
name|non_dma_mem
expr_stmt|;
name|ctlr
operator|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
name|free_non_dma_mem
expr_stmt|;
name|free_non_dma_mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
expr_stmt|;
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|=
name|ctlr
expr_stmt|;
name|ctlr
operator|->
name|ctlr_handle
operator|=
name|ctlr_handle
expr_stmt|;
name|ctlr
operator|->
name|device_id
operator|=
operator|(
name|TW_UINT32
operator|)
name|device_id
expr_stmt|;
name|ctlr
operator|->
name|arch_id
operator|=
name|TWA_ARCH_ID
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ctlr
operator|->
name|sg_size_factor
operator|=
name|TWA_SG_ELEMENT_SIZE_FACTOR
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|max_simult_reqs
operator|=
name|max_simult_reqs
operator|+
literal|1
expr_stmt|;
name|ctlr
operator|->
name|max_aens_supported
operator|=
name|max_aens
expr_stmt|;
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
name|ctlr
operator|->
name|flash_dma_mem
operator|=
name|flash_dma_mem
expr_stmt|;
name|ctlr
operator|->
name|flash_dma_mem_phys
operator|=
name|flash_dma_mem_phys
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
comment|/* Initialize queues of CL internal request context packets. */
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_BUSY_Q
argument_list|)
expr_stmt|;
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_PENDING_Q
argument_list|)
expr_stmt|;
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_COMPLETE_Q
argument_list|)
expr_stmt|;
comment|/* Initialize all locks used by CL. */
name|ctlr
operator|->
name|gen_lock
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|gen_lock_handle
operator|)
expr_stmt|;
name|tw_osl_init_lock
argument_list|(
name|ctlr_handle
argument_list|,
literal|"tw_cl_gen_lock"
argument_list|,
name|ctlr
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|io_lock
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|io_lock_handle
operator|)
expr_stmt|;
name|tw_osl_init_lock
argument_list|(
name|ctlr_handle
argument_list|,
literal|"tw_cl_io_lock"
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If 64 bit cmd pkt addresses are used, we will need to serialize 	 * writes to the hardware (across registers), since existing (G66) 	 * hardware will get confused if, for example, we wrote the low 32 bits 	 * of the cmd pkt address, followed by a response interrupt mask to the 	 * control register, followed by the high 32 bits of the cmd pkt 	 * address.  It will then interpret the value written to the control 	 * register as the low cmd pkt address.  So, for this case, we will 	 * make a note that we will need to synchronize control register writes 	 * with command register writes. 	 */
if|if
condition|(
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
operator|)
operator|&&
operator|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K
operator|)
condition|)
block|{
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_G66_WORKAROUND_NEEDED
expr_stmt|;
name|ctlr
operator|->
name|intr_lock
operator|=
name|ctlr
operator|->
name|io_lock
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|intr_lock
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|intr_lock_handle
operator|)
expr_stmt|;
name|tw_osl_init_lock
argument_list|(
name|ctlr_handle
argument_list|,
literal|"tw_cl_intr_lock"
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize CL internal request context packets. */
name|ctlr
operator|->
name|req_ctxt_buf
operator|=
operator|(
expr|struct
name|tw_cli_req_context
operator|*
operator|)
name|free_non_dma_mem
expr_stmt|;
name|free_non_dma_mem
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|*
operator|(
ifndef|#
directive|ifndef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
name|max_simult_reqs
operator|+
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
literal|1
operator|)
operator|)
expr_stmt|;
name|ctlr
operator|->
name|cmd_pkt_buf
operator|=
operator|(
expr|struct
name|tw_cl_command_packet
operator|*
operator|)
name|dma_mem
expr_stmt|;
name|ctlr
operator|->
name|cmd_pkt_phys
operator|=
name|dma_mem_phys
expr_stmt|;
name|ctlr
operator|->
name|internal_req_data
operator|=
operator|(
name|TW_UINT8
operator|*
operator|)
operator|(
name|ctlr
operator|->
name|cmd_pkt_buf
operator|+
operator|(
ifndef|#
directive|ifndef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|max_simult_reqs
operator|+
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
literal|1
operator|)
operator|)
expr_stmt|;
name|ctlr
operator|->
name|internal_req_data_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|*
operator|(
ifndef|#
directive|ifndef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|max_simult_reqs
operator|+
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
ifndef|#
directive|ifndef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
name|max_simult_reqs
operator|+
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|req
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|req_ctxt_buf
index|[
name|i
index|]
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|req
operator|->
name|cmd_pkt
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|cmd_pkt_buf
index|[
name|i
index|]
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
name|req
operator|->
name|request_id
operator|=
name|i
expr_stmt|;
name|req
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
comment|/* Insert request into the free queue. */
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
name|ctlr
operator|->
name|free_req_head
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|ctlr
operator|->
name|free_req_tail
operator|=
name|i
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|ctlr
operator|->
name|free_req_ids
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|ctlr
operator|->
name|num_free_req_ids
operator|=
name|max_simult_reqs
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
comment|/* Initialize the AEN queue. */
name|ctlr
operator|->
name|aen_queue
operator|=
operator|(
expr|struct
name|tw_cl_event_packet
operator|*
operator|)
name|free_non_dma_mem
expr_stmt|;
name|start_ctlr
label|:
comment|/* 	 * Disable interrupts.  Interrupts will be enabled in tw_cli_start_ctlr 	 * (only) if initialization succeeded. 	 */
name|tw_cli_disable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Initialize the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_start_ctlr
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
comment|/* Soft reset the controller, and try one more time. */
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1002
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller initialization failed. Retrying..."
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_soft_reset
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1003
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller soft reset failed"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_start_ctlr
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1004
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller initialization retry failed"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Notify some info about the controller to the OSL. */
name|tw_cli_notify_ctlr_info
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Mark the controller as active. */
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_ACTIVE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
end_ifdef

begin_comment
comment|/*  * Function name:	tw_cli_flash_firmware  * Description:		Flashes bundled firmware image onto controller.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_flash_firmware
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|struct
name|tw_cl_command_header
modifier|*
name|cmd_hdr
decl_stmt|;
name|struct
name|tw_cl_command_download_firmware
modifier|*
name|cmd
decl_stmt|;
name|TW_UINT32
name|fw_img_chunk_size
decl_stmt|;
name|TW_UINT32
name|num_chunks
decl_stmt|;
name|TW_UINT32
name|this_chunk_size
init|=
literal|0
decl_stmt|;
name|TW_INT32
name|remaining_img_size
init|=
literal|0
decl_stmt|;
name|TW_INT32
name|hard_reset_needed
init|=
name|TW_CL_FALSE
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_EGENFAILURE
decl_stmt|;
name|TW_UINT32
name|i
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
argument_list|,
name|TW_CL_NULL
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
block|{
comment|/* No free request packets available.  Can't proceed. */
name|error
operator|=
name|TW_OSL_EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|req
operator|->
name|cmd_pkt
operator|=
name|ctlr
operator|->
name|cmd_pkt_buf
expr_stmt|;
name|req
operator|->
name|cmd_pkt_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|req
operator|->
name|cmd_pkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
operator|+
literal|28
comment|/* max bytes before sglist */
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
comment|/* 	 * Determine amount of memory needed to hold a chunk of the 	 * firmware image.  As yet, the Download_Firmware command does not 	 * support SG elements that are ctlr->sg_size_factor multiples.  It 	 * requires them to be 512-byte multiples. 	 */
name|fw_img_chunk_size
operator|=
operator|(
operator|(
name|tw_cli_fw_img_size
operator|/
name|TW_CLI_NUM_FW_IMAGE_CHUNKS
operator|)
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
comment|/*		(ctlr->sg_size_factor - 1))& 		~(ctlr->sg_size_factor - 1); */
comment|/* Calculate the actual number of chunks needed. */
name|num_chunks
operator|=
operator|(
name|tw_cli_fw_img_size
operator|/
name|fw_img_chunk_size
operator|)
operator|+
operator|(
operator|(
name|tw_cli_fw_img_size
operator|%
name|fw_img_chunk_size
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|req
operator|->
name|data
operator|=
name|ctlr
operator|->
name|flash_dma_mem
expr_stmt|;
name|req
operator|->
name|data_phys
operator|=
name|ctlr
operator|->
name|flash_dma_mem_phys
expr_stmt|;
name|remaining_img_size
operator|=
name|tw_cli_fw_img_size
expr_stmt|;
name|cmd_hdr
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
expr_stmt|;
name|cmd
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|download_fw
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
comment|/* Build a cmd pkt for downloading firmware. */
name|tw_osl_memzero
argument_list|(
name|req
operator|->
name|cmd_pkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_hdr
operator|->
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
comment|/* sgl_offset (offset in dwords, to sg list) is 2. */
name|cmd
operator|->
name|sgl_off__opcode
operator|=
name|BUILD_SGL_OFF__OPCODE
argument_list|(
literal|2
argument_list|,
name|TWA_FW_CMD_DOWNLOAD_FIRMWARE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|=
name|TW_CL_SWAP16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* prom image */
if|if
condition|(
name|i
operator|!=
operator|(
name|num_chunks
operator|-
literal|1
operator|)
condition|)
name|this_chunk_size
operator|=
name|fw_img_chunk_size
expr_stmt|;
else|else
comment|/* last chunk */
name|this_chunk_size
operator|=
name|remaining_img_size
expr_stmt|;
name|remaining_img_size
operator|-=
name|this_chunk_size
expr_stmt|;
name|tw_osl_memcpy
argument_list|(
name|req
operator|->
name|data
argument_list|,
name|tw_cli_fw_img
operator|+
operator|(
name|i
operator|*
name|fw_img_chunk_size
operator|)
argument_list|,
name|this_chunk_size
argument_list|)
expr_stmt|;
comment|/* 		 * The next line will effect only the last chunk. 		 */
name|req
operator|->
name|length
operator|=
operator|(
name|this_chunk_size
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
comment|/*			(ctlr->sg_size_factor - 1))& 			~(ctlr->sg_size_factor - 1); */
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd
operator|->
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP64
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd
operator|->
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|size
operator|=
literal|2
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd
operator|->
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd
operator|->
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|size
operator|=
literal|2
operator|+
literal|2
expr_stmt|;
block|}
name|error
operator|=
name|tw_cli_submit_and_poll_request
argument_list|(
name|req
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1005
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Firmware flash request could not be posted"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|TW_OSL_ETIMEDOUT
condition|)
comment|/* clean-up done by tw_cli_submit_and_poll_request */
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
name|error
operator|=
name|cmd
operator|->
name|status
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|==
operator|(
name|num_chunks
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|error
operator|)
operator|)
operator|||
operator|(
operator|(
name|i
operator|!=
operator|(
name|num_chunks
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|error
operator|=
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
operator|)
operator|!=
name|TWA_ERROR_MORE_DATA
operator|)
operator|)
condition|)
block|{
comment|/* 				 * It's either that download of the last chunk 				 * failed, or the download of one of the earlier 				 * chunks failed with an error other than 				 * TWA_ERROR_MORE_DATA.  Report the error. 				 */
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|cmd_hdr
argument_list|)
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1006
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Firmware flash failed"
argument_list|,
literal|"cmd = 0x%x, chunk # %d, cmd status = %d"
argument_list|,
name|GET_OPCODE
argument_list|(
name|cmd
operator|->
name|sgl_off__opcode
argument_list|)
argument_list|,
name|i
argument_list|,
name|cmd
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/* 				 * Make a note to hard reset the controller, 				 * so that it doesn't wait for the remaining 				 * chunks.  Don't call the hard reset function 				 * right here, since we have committed to having 				 * only 1 active internal request at a time, and 				 * this request has not yet been freed. 				 */
name|hard_reset_needed
operator|=
name|TW_CL_TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* for */
name|out
label|:
if|if
condition|(
name|req
condition|)
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_reset_needed
condition|)
name|tw_cli_hard_reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_hard_reset  * Description:		Hard resets the controller.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_hard_reset
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|struct
name|tw_cl_command_reset_firmware
modifier|*
name|cmd
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
argument_list|,
name|TW_CL_NULL
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
ifdef|#
directive|ifdef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|req
operator|->
name|cmd_pkt
operator|=
name|ctlr
operator|->
name|cmd_pkt_buf
expr_stmt|;
name|req
operator|->
name|cmd_pkt_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|req
operator|->
name|cmd_pkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
operator|+
literal|28
comment|/* max bytes before sglist */
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
comment|/* Build a cmd pkt for sending down the hard reset command. */
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|reset_fw
operator|)
expr_stmt|;
name|cmd
operator|->
name|res1__opcode
operator|=
name|BUILD_RES__OPCODE
argument_list|(
literal|0
argument_list|,
name|TWA_FW_CMD_HARD_RESET_FIRMWARE
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|size
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|=
literal|0
expr_stmt|;
comment|/* don't reload FPGA logic */
name|req
operator|->
name|data
operator|=
name|TW_CL_NULL
expr_stmt|;
name|req
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1017
argument_list|,
literal|0x3
argument_list|,
name|TW_CL_SEVERITY_INFO_STRING
argument_list|,
literal|"Issuing hard (commanded) reset to the controller..."
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|error
operator|=
name|tw_cli_submit_and_poll_request
argument_list|(
name|req
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1007
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Hard reset request could not be posted"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|TW_OSL_ETIMEDOUT
condition|)
comment|/* clean-up done by tw_cli_submit_and_poll_request */
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|status
operator|)
condition|)
block|{
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
argument_list|)
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1008
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Hard reset request failed"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_X
condition|)
block|{
comment|/* 		 * There's a hardware bug in the G133 ASIC, which can lead to 		 * PCI parity errors and hangs, if the host accesses any 		 * registers when the firmware is resetting the hardware, as 		 * part of a hard/soft reset.  The window of time when the 		 * problem can occur is about 10 ms.  Here, we will handshake 		 * with the firmware to find out when the firmware is pulling 		 * down the hardware reset pin, and wait for about 500 ms to 		 * make sure we don't access any hardware registers (for 		 * polling) during that window. 		 */
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_RESET_PHASE1_IN_PROGRESS
expr_stmt|;
while|while
condition|(
name|tw_cli_find_response
argument_list|(
name|ctlr
argument_list|,
name|TWA_RESET_PHASE1_NOTIFICATION_RESPONSE
argument_list|)
operator|!=
name|TW_OSL_ESUCCESS
condition|)
name|tw_osl_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tw_osl_delay
argument_list|(
name|TWA_RESET_PHASE1_WAIT_TIME_MS
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_RESET_PHASE1_IN_PROGRESS
expr_stmt|;
block|}
comment|/* Wait for the MC_RDY bit to get set. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_poll_status
argument_list|(
name|ctlr
argument_list|,
name|TWA_STATUS_MICROCONTROLLER_READY
argument_list|,
name|TW_CLI_RESET_TIMEOUT_PERIOD
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x1018
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Micro-ctlr not ready following hard reset"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|req
condition|)
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TW_OSL_FLASH_FIRMWARE */
end_comment

begin_comment
comment|/*  * Function name:	tw_cli_start_ctlr  * Description:		Establishes a logical connection with the controller.  *			If bundled with firmware, determines whether or not  *			to flash firmware, based on arch_id, fw SRL (Spec.  *			Revision Level), branch& build #'s.  Also determines  *			whether or not the driver is compatible with the  *			firmware on the controller, before proceeding to work  *			with it.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_start_ctlr
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|TW_UINT16
name|fw_on_ctlr_srl
init|=
literal|0
decl_stmt|;
name|TW_UINT16
name|fw_on_ctlr_arch_id
init|=
literal|0
decl_stmt|;
name|TW_UINT16
name|fw_on_ctlr_branch
init|=
literal|0
decl_stmt|;
name|TW_UINT16
name|fw_on_ctlr_build
init|=
literal|0
decl_stmt|;
name|TW_UINT32
name|init_connect_result
init|=
literal|0
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
name|TW_INT8
name|fw_flashed
init|=
name|TW_CL_FALSE
decl_stmt|;
name|TW_INT8
name|fw_flash_failed
init|=
name|TW_CL_FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Wait for the controller to become ready. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_poll_status
argument_list|(
name|ctlr
argument_list|,
name|TWA_STATUS_MICROCONTROLLER_READY
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1009
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Microcontroller not ready"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Drain the response queue. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_drain_response_queue
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100A
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't drain response queue"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Establish a logical connection with the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|max_simult_reqs
argument_list|)
argument_list|,
name|TWA_EXTENDED_INIT_CONNECT
argument_list|,
name|TWA_CURRENT_FW_SRL
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
name|TWA_CURRENT_FW_BRANCH
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
name|TWA_CURRENT_FW_BUILD
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
operator|&
name|fw_on_ctlr_srl
argument_list|,
operator|&
name|fw_on_ctlr_arch_id
argument_list|,
operator|&
name|fw_on_ctlr_branch
argument_list|,
operator|&
name|fw_on_ctlr_build
argument_list|,
operator|&
name|init_connect_result
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100B
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Can't initialize connection in current mode"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
if|if
condition|(
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_FLASH_FIRMWARE
operator|)
operator|&&
operator|(
name|init_connect_result
operator|&
name|TWA_BUNDLED_FW_SAFE_TO_FLASH
operator|)
operator|&&
operator|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_RECOMMENDS_FLASH
operator|)
condition|)
block|{
comment|/* 		 * The bundled firmware is safe to flash, and the firmware 		 * on the controller recommends a flash.  So, flash! 		 */
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100C
argument_list|,
literal|0x3
argument_list|,
name|TW_CL_SEVERITY_INFO_STRING
argument_list|,
literal|"Flashing bundled firmware..."
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_flash_firmware
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|fw_flash_failed
operator|=
name|TW_CL_TRUE
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100D
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Unable to flash bundled firmware. "
literal|"Attempting to work with fw on ctlr..."
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100E
argument_list|,
literal|0x3
argument_list|,
name|TW_CL_SEVERITY_INFO_STRING
argument_list|,
literal|"Successfully flashed bundled firmware"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fw_flashed
operator|=
name|TW_CL_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fw_flashed
condition|)
block|{
comment|/* The firmware was flashed.  Have the new image loaded */
name|error
operator|=
name|tw_cli_hard_reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100F
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Could not reset controller after flash!"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
comment|/* Go through initialization again. */
name|error
operator|=
name|tw_cli_start_ctlr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* 		 * If hard reset of controller failed, we need to return. 		 * Otherwise, the above recursive call to tw_cli_start_ctlr 		 * will have completed the rest of the initialization (starting 		 * from tw_cli_drain_aen_queue below).  Don't do it again. 		 * Just return. 		 */
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
block|{
comment|/* 		 * Either we are not bundled with a firmware image, or 		 * the bundled firmware is not safe to flash, 		 * or flash failed for some reason.  See if we can at 		 * least work with the firmware on the controller in the 		 * current mode. 		 */
if|if
condition|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_COMPATIBLE
condition|)
block|{
comment|/* Yes, we can.  Make note of the operating mode. */
if|if
condition|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_SAME_OR_NEWER
condition|)
block|{
name|ctlr
operator|->
name|working_srl
operator|=
name|TWA_CURRENT_FW_SRL
expr_stmt|;
name|ctlr
operator|->
name|working_branch
operator|=
name|TWA_CURRENT_FW_BRANCH
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|working_build
operator|=
name|TWA_CURRENT_FW_BUILD
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|working_srl
operator|=
name|fw_on_ctlr_srl
expr_stmt|;
name|ctlr
operator|->
name|working_branch
operator|=
name|fw_on_ctlr_branch
expr_stmt|;
name|ctlr
operator|->
name|working_build
operator|=
name|fw_on_ctlr_build
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * No, we can't.  See if we can at least work with 			 * it in the base mode.  We should never come here 			 * if firmware has just been flashed. 			 */
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1010
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Driver/Firmware mismatch. "
literal|"Negotiating for base level..."
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|max_simult_reqs
argument_list|)
argument_list|,
name|TWA_EXTENDED_INIT_CONNECT
argument_list|,
name|TWA_BASE_FW_SRL
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
name|TWA_BASE_FW_BRANCH
argument_list|,
name|TWA_BASE_FW_BUILD
argument_list|,
operator|&
name|fw_on_ctlr_srl
argument_list|,
operator|&
name|fw_on_ctlr_arch_id
argument_list|,
operator|&
name|fw_on_ctlr_branch
argument_list|,
operator|&
name|fw_on_ctlr_build
argument_list|,
operator|&
name|init_connect_result
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1011
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't initialize connection in "
literal|"base mode"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_COMPATIBLE
operator|)
condition|)
block|{
comment|/* 				 * The firmware on the controller is not even 				 * compatible with our base mode.  We cannot 				 * work with it.  Bail... 				 */
ifdef|#
directive|ifdef
name|TW_OSL_FLASH_FIRMWARE
if|if
condition|(
name|fw_flash_failed
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1012
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Incompatible firmware on controller"
literal|"...and could not flash bundled "
literal|"firmware"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|else
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1013
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Incompatible firmware on controller"
literal|"...and bundled firmware not safe to "
literal|"flash"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_FLASH_FIRMWARE */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * We can work with this firmware, but only in 			 * base mode. 			 */
name|ctlr
operator|->
name|working_srl
operator|=
name|TWA_BASE_FW_SRL
expr_stmt|;
name|ctlr
operator|->
name|working_branch
operator|=
name|TWA_BASE_FW_BRANCH
expr_stmt|;
name|ctlr
operator|->
name|working_build
operator|=
name|TWA_BASE_FW_BUILD
expr_stmt|;
name|ctlr
operator|->
name|operating_mode
operator|=
name|TWA_BASE_MODE
expr_stmt|;
block|}
name|ctlr
operator|->
name|fw_on_ctlr_srl
operator|=
name|fw_on_ctlr_srl
expr_stmt|;
name|ctlr
operator|->
name|fw_on_ctlr_branch
operator|=
name|fw_on_ctlr_branch
expr_stmt|;
name|ctlr
operator|->
name|fw_on_ctlr_build
operator|=
name|fw_on_ctlr_build
expr_stmt|;
block|}
comment|/* Drain the AEN queue */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_drain_aen_queue
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
comment|/*  		 * We will just print that we couldn't drain the AEN queue. 		 * There's no need to bail out. 		 */
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1014
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Can't drain AEN queue"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|tw_cli_enable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_ESUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_shutdown_ctlr  * Description:		Closes logical connection with the controller.  *  * Input:		ctlr	-- ptr to per ctlr structure  *			flags	-- more info passed by the OS Layer  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_shutdown_ctlr
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_UINT32
name|flags
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the controller as inactive, disable any further interrupts, 	 * and notify the controller that we are going down. 	 */
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_ACTIVE
expr_stmt|;
name|tw_cli_disable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Let the controller know that we are going down. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
name|TWA_SHUTDOWN_MESSAGE_CREDITS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|)
operator|)
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1015
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't close connection with controller"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TW_CL_STOP_CTLR_ONLY
condition|)
goto|goto
name|ret
goto|;
comment|/* Destroy all locks used by CL. */
name|tw_osl_destroy_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|tw_osl_destroy_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
operator|)
condition|)
name|tw_osl_destroy_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_init_connection  * Description:		Sends init_connection cmd to firmware  *  * Input:		ctlr		-- ptr to per ctlr structure  *			message_credits	-- max # of requests that we might send  *					 down simultaneously.  This will be  *					 typically set to 256 at init-time or  *					after a reset, and to 1 at shutdown-time  *			set_features	-- indicates if we intend to use 64-bit  *					sg, also indicates if we want to do a  *					basic or an extended init_connection;  *  * Note: The following input/output parameters are valid, only in case of an  *		extended init_connection:  *  *			current_fw_srl		-- srl of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_arch_id	-- arch_id of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_branch	-- branch # of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_build	-- build # of fw we are bundled  *						with, if any; 0 otherwise  * Output:		fw_on_ctlr_srl		-- srl of fw on ctlr  *			fw_on_ctlr_arch_id	-- arch_id of fw on ctlr  *			fw_on_ctlr_branch	-- branch # of fw on ctlr  *			fw_on_ctlr_build	-- build # of fw on ctlr  *			init_connect_result	-- result bitmap of fw response  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_init_connection
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|,
name|TW_UINT16
name|message_credits
parameter_list|,
name|TW_UINT32
name|set_features
parameter_list|,
name|TW_UINT16
name|current_fw_srl
parameter_list|,
name|TW_UINT16
name|current_fw_arch_id
parameter_list|,
name|TW_UINT16
name|current_fw_branch
parameter_list|,
name|TW_UINT16
name|current_fw_build
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_srl
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_arch_id
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_branch
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_build
parameter_list|,
name|TW_UINT32
modifier|*
name|init_connect_result
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|struct
name|tw_cl_command_init_connect
modifier|*
name|init_connect
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_EBUSY
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
ifdef|#
directive|ifdef
name|TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST
argument_list|,
name|TW_CL_NULL
endif|#
directive|endif
comment|/* TW_OSL_NON_DMA_MEM_ALLOC_PER_REQUEST */
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
goto|goto
name|out
goto|;
ifdef|#
directive|ifdef
name|TW_OSL_DMA_MEM_ALLOC_PER_REQUEST
name|req
operator|->
name|cmd_pkt
operator|=
name|ctlr
operator|->
name|cmd_pkt_buf
expr_stmt|;
name|req
operator|->
name|cmd_pkt_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|req
operator|->
name|cmd_pkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
operator|+
literal|28
comment|/* max bytes before sglist */
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DMA_MEM_ALLOC_PER_REQUEST */
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
comment|/* Build the cmd pkt. */
name|init_connect
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|init_connect
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|init_connect
operator|->
name|res1__opcode
operator|=
name|BUILD_RES__OPCODE
argument_list|(
literal|0
argument_list|,
name|TWA_FW_CMD_INIT_CONNECTION
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|message_credits
operator|=
name|TW_CL_SWAP16
argument_list|(
name|message_credits
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|features
operator|=
name|TW_CL_SWAP32
argument_list|(
name|set_features
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
name|init_connect
operator|->
name|features
operator||=
name|TWA_64BIT_SG_ADDRESSES
expr_stmt|;
if|if
condition|(
name|set_features
operator|&
name|TWA_EXTENDED_INIT_CONNECT
condition|)
block|{
comment|/* 		 * Fill in the extra fields needed for an extended 		 * init_connect. 		 */
name|init_connect
operator|->
name|size
operator|=
literal|6
expr_stmt|;
name|init_connect
operator|->
name|fw_srl
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_srl
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|fw_arch_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_arch_id
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|fw_branch
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_branch
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|fw_build
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_build
argument_list|)
expr_stmt|;
block|}
else|else
name|init_connect
operator|->
name|size
operator|=
literal|3
expr_stmt|;
comment|/* Submit the command, and wait for it to complete. */
name|error
operator|=
name|tw_cli_submit_and_poll_request
argument_list|(
name|req
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|TW_OSL_ETIMEDOUT
condition|)
comment|/* Clean-up done by tw_cli_submit_and_poll_request. */
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|init_connect
operator|->
name|status
operator|)
condition|)
block|{
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|set_features
operator|&
name|TWA_EXTENDED_INIT_CONNECT
condition|)
block|{
operator|*
name|fw_on_ctlr_srl
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_srl
argument_list|)
expr_stmt|;
operator|*
name|fw_on_ctlr_arch_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_arch_id
argument_list|)
expr_stmt|;
operator|*
name|fw_on_ctlr_branch
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_branch
argument_list|)
expr_stmt|;
operator|*
name|fw_on_ctlr_build
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_build
argument_list|)
expr_stmt|;
operator|*
name|init_connect_result
operator|=
name|TW_CL_SWAP32
argument_list|(
name|init_connect
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1016
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"init_connection failed"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

