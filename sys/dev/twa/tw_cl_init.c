begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-07 Applied Micro Circuits Corporation.  * Copyright (c) 2004-05 Vinod Kashyap  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * AMCC'S 3ware driver for 9000 series storage controllers.  *  * Author: Vinod Kashyap  * Modifications by: Adam Radford  */
end_comment

begin_comment
comment|/*  * Common Layer initialization functions.  */
end_comment

begin_include
include|#
directive|include
file|"tw_osl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_fwif.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_externs.h"
end_include

begin_include
include|#
directive|include
file|"tw_osl_ioctl.h"
end_include

begin_comment
comment|/*  * Function name:	tw_cl_ctlr_supported  * Description:		Determines if a controller is supported.  *  * Input:		vendor_id -- vendor id of the controller  *			device_id -- device id of the controller  * Output:		None  * Return value:	TW_CL_TRUE-- controller supported  *			TW_CL_FALSE-- controller not supported  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_ctlr_supported
parameter_list|(
name|TW_INT32
name|vendor_id
parameter_list|,
name|TW_INT32
name|device_id
parameter_list|)
block|{
if|if
condition|(
operator|(
name|vendor_id
operator|==
name|TW_CL_VENDOR_ID
operator|)
operator|&&
operator|(
operator|(
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K
operator|)
operator|||
operator|(
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_X
operator|)
operator|||
operator|(
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_E
operator|)
operator|)
condition|)
return|return
operator|(
name|TW_CL_TRUE
operator|)
return|;
return|return
operator|(
name|TW_CL_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_get_pci_bar_info  * Description:		Returns PCI BAR info.  *  * Input:		device_id -- device id of the controller  *			bar_type -- type of PCI BAR in question  * Output:		bar_num -- PCI BAR number corresponding to bar_type  *			bar0_offset -- byte offset from BAR 0 (0x10 in  *					PCI config space)  *			bar_size -- size, in bytes, of the BAR in question  * Return value:	0 -- success  *			non-zero -- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_get_pci_bar_info
parameter_list|(
name|TW_INT32
name|device_id
parameter_list|,
name|TW_INT32
name|bar_type
parameter_list|,
name|TW_INT32
modifier|*
name|bar_num
parameter_list|,
name|TW_INT32
modifier|*
name|bar0_offset
parameter_list|,
name|TW_INT32
modifier|*
name|bar_size
parameter_list|)
block|{
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
switch|switch
condition|(
name|device_id
condition|)
block|{
case|case
name|TW_CL_DEVICE_ID_9K
case|:
switch|switch
condition|(
name|bar_type
condition|)
block|{
case|case
name|TW_CL_BAR_TYPE_IO
case|:
operator|*
name|bar_num
operator|=
literal|0
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_MEM
case|:
operator|*
name|bar_num
operator|=
literal|1
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0x4
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_SBUF
case|:
operator|*
name|bar_num
operator|=
literal|2
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0xC
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TW_CL_DEVICE_ID_9K_X
case|:
case|case
name|TW_CL_DEVICE_ID_9K_E
case|:
switch|switch
condition|(
name|bar_type
condition|)
block|{
case|case
name|TW_CL_BAR_TYPE_IO
case|:
operator|*
name|bar_num
operator|=
literal|2
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0x10
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_MEM
case|:
operator|*
name|bar_num
operator|=
literal|1
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0x8
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|TW_CL_BAR_TYPE_SBUF
case|:
operator|*
name|bar_num
operator|=
literal|0
expr_stmt|;
operator|*
name|bar0_offset
operator|=
literal|0
expr_stmt|;
operator|*
name|bar_size
operator|=
literal|8
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|TW_OSL_ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_get_mem_requirements  * Description:		Provides info about Common Layer requirements for a  *			controller, given the controller type (in 'flags').  * Input:		ctlr_handle -- controller handle  *			flags -- more info passed by the OS Layer  *			device_id -- device id of the controller  *			max_simult_reqs -- maximum # of simultaneous  *					requests that the OS Layer expects  *					the Common Layer to support  *			max_aens -- maximun # of AEN's needed to be supported  * Output:		alignment -- alignment needed for all DMA'able  *					buffers  *			sg_size_factor -- every SG element should have a size  *					that's a multiple of this number  *			non_dma_mem_size -- # of bytes of memory needed for  *					non-DMA purposes  *			dma_mem_size -- # of bytes of DMA'able memory needed  *			per_req_dma_mem_size -- # of bytes of DMA'able memory  *					needed per request, if applicable  *			per_req_non_dma_mem_size -- # of bytes of memory needed  *					per request for non-DMA purposes,  *					if applicable  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_get_mem_requirements
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_UINT32
name|flags
parameter_list|,
name|TW_INT32
name|device_id
parameter_list|,
name|TW_INT32
name|max_simult_reqs
parameter_list|,
name|TW_INT32
name|max_aens
parameter_list|,
name|TW_UINT32
modifier|*
name|alignment
parameter_list|,
name|TW_UINT32
modifier|*
name|sg_size_factor
parameter_list|,
name|TW_UINT32
modifier|*
name|non_dma_mem_size
parameter_list|,
name|TW_UINT32
modifier|*
name|dma_mem_size
parameter_list|)
block|{
if|if
condition|(
name|device_id
operator|==
literal|0
condition|)
name|device_id
operator|=
name|TW_CL_DEVICE_ID_9K
expr_stmt|;
if|if
condition|(
name|max_simult_reqs
operator|>
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1000
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Too many simultaneous requests to support!"
argument_list|,
literal|"requested = %d, supported = %d, error = %d\n"
argument_list|,
name|max_simult_reqs
argument_list|,
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
argument_list|,
name|TW_OSL_EBIG
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBIG
operator|)
return|;
block|}
operator|*
name|alignment
operator|=
name|TWA_ALIGNMENT
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
operator|*
name|sg_size_factor
operator|=
name|TWA_SG_ELEMENT_SIZE_FACTOR
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
comment|/* 	 * Total non-DMA memory needed is the sum total of memory needed for 	 * the controller context, request packets (including the 1 needed for 	 * CL internal requests), and event packets. 	 */
operator|*
name|non_dma_mem_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
operator|*
name|max_aens
operator|)
expr_stmt|;
comment|/* 	 * Total DMA'able memory needed is the sum total of memory needed for 	 * all command packets (including the 1 needed for CL internal 	 * requests), and memory needed to hold the payload for internal 	 * requests. 	 */
operator|*
name|dma_mem_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
name|TW_CLI_SECTOR_SIZE
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_init_ctlr  * Description:		Initializes driver data structures for the controller.  *  * Input:		ctlr_handle -- controller handle  *			flags -- more info passed by the OS Layer  *			device_id -- device id of the controller  *			max_simult_reqs -- maximum # of simultaneous requests  *					that the OS Layer expects the Common  *					Layer to support  *			max_aens -- maximun # of AEN's needed to be supported  *			non_dma_mem -- ptr to allocated non-DMA memory  *			dma_mem -- ptr to allocated DMA'able memory  *			dma_mem_phys -- physical address of dma_mem  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_init_ctlr
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_UINT32
name|flags
parameter_list|,
name|TW_INT32
name|device_id
parameter_list|,
name|TW_INT32
name|max_simult_reqs
parameter_list|,
name|TW_INT32
name|max_aens
parameter_list|,
name|TW_VOID
modifier|*
name|non_dma_mem
parameter_list|,
name|TW_VOID
modifier|*
name|dma_mem
parameter_list|,
name|TW_UINT64
name|dma_mem_phys
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
decl_stmt|;
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|TW_UINT8
modifier|*
name|free_non_dma_mem
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
name|TW_INT32
name|i
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TW_CL_START_CTLR_ONLY
condition|)
block|{
name|ctlr
operator|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
expr_stmt|;
goto|goto
name|start_ctlr
goto|;
block|}
if|if
condition|(
name|max_simult_reqs
operator|>
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1000
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Too many simultaneous requests to support!"
argument_list|,
literal|"requested = %d, supported = %d, error = %d\n"
argument_list|,
name|max_simult_reqs
argument_list|,
name|TW_CL_MAX_SIMULTANEOUS_REQUESTS
argument_list|,
name|TW_OSL_EBIG
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBIG
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|non_dma_mem
operator|==
name|TW_CL_NULL
operator|)
operator|||
operator|(
name|dma_mem
operator|==
name|TW_CL_NULL
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1001
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Insufficient memory for Common Layer's internal usage"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|TW_OSL_ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_ENOMEM
operator|)
return|;
block|}
name|tw_osl_memzero
argument_list|(
name|non_dma_mem
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
operator|*
name|max_aens
operator|)
argument_list|)
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|dma_mem
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
operator|+
name|TW_CLI_SECTOR_SIZE
argument_list|)
expr_stmt|;
name|free_non_dma_mem
operator|=
operator|(
name|TW_UINT8
operator|*
operator|)
name|non_dma_mem
expr_stmt|;
name|ctlr
operator|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
name|free_non_dma_mem
expr_stmt|;
name|free_non_dma_mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_ctlr_context
argument_list|)
expr_stmt|;
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|=
name|ctlr
expr_stmt|;
name|ctlr
operator|->
name|ctlr_handle
operator|=
name|ctlr_handle
expr_stmt|;
name|ctlr
operator|->
name|device_id
operator|=
operator|(
name|TW_UINT32
operator|)
name|device_id
expr_stmt|;
name|ctlr
operator|->
name|arch_id
operator|=
name|TWA_ARCH_ID
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ctlr
operator|->
name|sg_size_factor
operator|=
name|TWA_SG_ELEMENT_SIZE_FACTOR
argument_list|(
name|device_id
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|max_simult_reqs
operator|=
name|max_simult_reqs
operator|+
literal|1
expr_stmt|;
name|ctlr
operator|->
name|max_aens_supported
operator|=
name|max_aens
expr_stmt|;
comment|/* Initialize queues of CL internal request context packets. */
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_BUSY_Q
argument_list|)
expr_stmt|;
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_PENDING_Q
argument_list|)
expr_stmt|;
name|tw_cli_req_q_init
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_COMPLETE_Q
argument_list|)
expr_stmt|;
comment|/* Initialize all locks used by CL. */
name|ctlr
operator|->
name|gen_lock
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|gen_lock_handle
operator|)
expr_stmt|;
name|tw_osl_init_lock
argument_list|(
name|ctlr_handle
argument_list|,
literal|"tw_cl_gen_lock"
argument_list|,
name|ctlr
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|io_lock
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|io_lock_handle
operator|)
expr_stmt|;
name|tw_osl_init_lock
argument_list|(
name|ctlr_handle
argument_list|,
literal|"tw_cl_io_lock"
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If 64 bit cmd pkt addresses are used, we will need to serialize 	 * writes to the hardware (across registers), since existing (G66) 	 * hardware will get confused if, for example, we wrote the low 32 bits 	 * of the cmd pkt address, followed by a response interrupt mask to the 	 * control register, followed by the high 32 bits of the cmd pkt 	 * address.  It will then interpret the value written to the control 	 * register as the low cmd pkt address.  So, for this case, we will 	 * make a note that we will need to synchronize control register writes 	 * with command register writes. 	 */
if|if
condition|(
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
operator|)
operator|&&
operator|(
operator|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K
operator|)
operator|||
operator|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_X
operator|)
operator|||
operator|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_E
operator|)
operator|)
condition|)
block|{
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_G66_WORKAROUND_NEEDED
expr_stmt|;
name|ctlr
operator|->
name|intr_lock
operator|=
name|ctlr
operator|->
name|io_lock
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|intr_lock
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|intr_lock_handle
operator|)
expr_stmt|;
name|tw_osl_init_lock
argument_list|(
name|ctlr_handle
argument_list|,
literal|"tw_cl_intr_lock"
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize CL internal request context packets. */
name|ctlr
operator|->
name|req_ctxt_buf
operator|=
operator|(
expr|struct
name|tw_cli_req_context
operator|*
operator|)
name|free_non_dma_mem
expr_stmt|;
name|free_non_dma_mem
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cli_req_context
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|ctlr
operator|->
name|cmd_pkt_buf
operator|=
operator|(
expr|struct
name|tw_cl_command_packet
operator|*
operator|)
name|dma_mem
expr_stmt|;
name|ctlr
operator|->
name|cmd_pkt_phys
operator|=
name|dma_mem_phys
expr_stmt|;
name|ctlr
operator|->
name|internal_req_data
operator|=
operator|(
name|TW_UINT8
operator|*
operator|)
operator|(
name|ctlr
operator|->
name|cmd_pkt_buf
operator|+
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|ctlr
operator|->
name|internal_req_data_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|*
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|max_simult_reqs
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|req
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|req_ctxt_buf
index|[
name|i
index|]
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|cmd_pkt_buf
index|[
name|i
index|]
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt_phys
operator|=
name|ctlr
operator|->
name|cmd_pkt_phys
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
operator|)
expr_stmt|;
name|req
operator|->
name|request_id
operator|=
name|i
expr_stmt|;
name|req
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
comment|/* Insert request into the free queue. */
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the AEN queue. */
name|ctlr
operator|->
name|aen_queue
operator|=
operator|(
expr|struct
name|tw_cl_event_packet
operator|*
operator|)
name|free_non_dma_mem
expr_stmt|;
name|start_ctlr
label|:
comment|/* 	 * Disable interrupts.  Interrupts will be enabled in tw_cli_start_ctlr 	 * (only) if initialization succeeded. 	 */
name|tw_cli_disable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Initialize the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_start_ctlr
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
comment|/* Soft reset the controller, and try one more time. */
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1002
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller initialization failed. Retrying..."
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_soft_reset
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1003
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller soft reset failed"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_start_ctlr
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1004
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller initialization retry failed"
argument_list|,
literal|"error = %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Notify some info about the controller to the OSL. */
name|tw_cli_notify_ctlr_info
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Mark the controller as active. */
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_ACTIVE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_start_ctlr  * Description:		Establishes a logical connection with the controller.  *			Determines whether or not the driver is compatible   *                      with the firmware on the controller, before proceeding  *                      to work with it.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_start_ctlr
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|TW_UINT16
name|fw_on_ctlr_srl
init|=
literal|0
decl_stmt|;
name|TW_UINT16
name|fw_on_ctlr_arch_id
init|=
literal|0
decl_stmt|;
name|TW_UINT16
name|fw_on_ctlr_branch
init|=
literal|0
decl_stmt|;
name|TW_UINT16
name|fw_on_ctlr_build
init|=
literal|0
decl_stmt|;
name|TW_UINT32
name|init_connect_result
init|=
literal|0
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Wait for the controller to become ready. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_poll_status
argument_list|(
name|ctlr
argument_list|,
name|TWA_STATUS_MICROCONTROLLER_READY
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1009
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Microcontroller not ready"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Drain the response queue. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_drain_response_queue
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100A
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't drain response queue"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Establish a logical connection with the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|max_simult_reqs
argument_list|)
argument_list|,
name|TWA_EXTENDED_INIT_CONNECT
argument_list|,
name|TWA_CURRENT_FW_SRL
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
name|TWA_CURRENT_FW_BRANCH
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
name|TWA_CURRENT_FW_BUILD
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
operator|&
name|fw_on_ctlr_srl
argument_list|,
operator|&
name|fw_on_ctlr_arch_id
argument_list|,
operator|&
name|fw_on_ctlr_branch
argument_list|,
operator|&
name|fw_on_ctlr_build
argument_list|,
operator|&
name|init_connect_result
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x100B
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Can't initialize connection in current mode"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|{
comment|/* See if we can at least work with the firmware on the                  * controller in the current mode. 		 */
if|if
condition|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_COMPATIBLE
condition|)
block|{
comment|/* Yes, we can.  Make note of the operating mode. */
if|if
condition|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_SAME_OR_NEWER
condition|)
block|{
name|ctlr
operator|->
name|working_srl
operator|=
name|TWA_CURRENT_FW_SRL
expr_stmt|;
name|ctlr
operator|->
name|working_branch
operator|=
name|TWA_CURRENT_FW_BRANCH
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|working_build
operator|=
name|TWA_CURRENT_FW_BUILD
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|working_srl
operator|=
name|fw_on_ctlr_srl
expr_stmt|;
name|ctlr
operator|->
name|working_branch
operator|=
name|fw_on_ctlr_branch
expr_stmt|;
name|ctlr
operator|->
name|working_build
operator|=
name|fw_on_ctlr_build
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * No, we can't.  See if we can at least work with 			 * it in the base mode. 			 */
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1010
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Driver/Firmware mismatch. "
literal|"Negotiating for base level..."
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|max_simult_reqs
argument_list|)
argument_list|,
name|TWA_EXTENDED_INIT_CONNECT
argument_list|,
name|TWA_BASE_FW_SRL
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
argument_list|,
name|TWA_BASE_FW_BRANCH
argument_list|,
name|TWA_BASE_FW_BUILD
argument_list|,
operator|&
name|fw_on_ctlr_srl
argument_list|,
operator|&
name|fw_on_ctlr_arch_id
argument_list|,
operator|&
name|fw_on_ctlr_branch
argument_list|,
operator|&
name|fw_on_ctlr_build
argument_list|,
operator|&
name|init_connect_result
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1011
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't initialize connection in "
literal|"base mode"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_COMPATIBLE
operator|)
condition|)
block|{
comment|/* 				 * The firmware on the controller is not even 				 * compatible with our base mode.  We cannot 				 * work with it.  Bail... 				 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * We can work with this firmware, but only in 			 * base mode. 			 */
name|ctlr
operator|->
name|working_srl
operator|=
name|TWA_BASE_FW_SRL
expr_stmt|;
name|ctlr
operator|->
name|working_branch
operator|=
name|TWA_BASE_FW_BRANCH
expr_stmt|;
name|ctlr
operator|->
name|working_build
operator|=
name|TWA_BASE_FW_BUILD
expr_stmt|;
name|ctlr
operator|->
name|operating_mode
operator|=
name|TWA_BASE_MODE
expr_stmt|;
block|}
name|ctlr
operator|->
name|fw_on_ctlr_srl
operator|=
name|fw_on_ctlr_srl
expr_stmt|;
name|ctlr
operator|->
name|fw_on_ctlr_branch
operator|=
name|fw_on_ctlr_branch
expr_stmt|;
name|ctlr
operator|->
name|fw_on_ctlr_build
operator|=
name|fw_on_ctlr_build
expr_stmt|;
block|}
comment|/* Drain the AEN queue */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_drain_aen_queue
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
comment|/*  		 * We will just print that we couldn't drain the AEN queue. 		 * There's no need to bail out. 		 */
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1014
argument_list|,
literal|0x2
argument_list|,
name|TW_CL_SEVERITY_WARNING_STRING
argument_list|,
literal|"Can't drain AEN queue"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|tw_cli_enable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_ESUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_shutdown_ctlr  * Description:		Closes logical connection with the controller.  *  * Input:		ctlr	-- ptr to per ctlr structure  *			flags	-- more info passed by the OS Layer  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_shutdown_ctlr
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_UINT32
name|flags
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the controller as inactive, disable any further interrupts, 	 * and notify the controller that we are going down. 	 */
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_ACTIVE
expr_stmt|;
name|tw_cli_disable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Let the controller know that we are going down. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
name|TWA_SHUTDOWN_MESSAGE_CREDITS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|)
operator|)
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1015
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't close connection with controller"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TW_CL_STOP_CTLR_ONLY
condition|)
goto|goto
name|ret
goto|;
comment|/* Destroy all locks used by CL. */
name|tw_osl_destroy_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|tw_osl_destroy_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
operator|)
condition|)
name|tw_osl_destroy_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
name|ret
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_init_connection  * Description:		Sends init_connection cmd to firmware  *  * Input:		ctlr		-- ptr to per ctlr structure  *			message_credits	-- max # of requests that we might send  *					 down simultaneously.  This will be  *					 typically set to 256 at init-time or  *					after a reset, and to 1 at shutdown-time  *			set_features	-- indicates if we intend to use 64-bit  *					sg, also indicates if we want to do a  *					basic or an extended init_connection;  *  * Note: The following input/output parameters are valid, only in case of an  *		extended init_connection:  *  *			current_fw_srl		-- srl of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_arch_id	-- arch_id of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_branch	-- branch # of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_build	-- build # of fw we are bundled  *						with, if any; 0 otherwise  * Output:		fw_on_ctlr_srl		-- srl of fw on ctlr  *			fw_on_ctlr_arch_id	-- arch_id of fw on ctlr  *			fw_on_ctlr_branch	-- branch # of fw on ctlr  *			fw_on_ctlr_build	-- build # of fw on ctlr  *			init_connect_result	-- result bitmap of fw response  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_init_connection
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|,
name|TW_UINT16
name|message_credits
parameter_list|,
name|TW_UINT32
name|set_features
parameter_list|,
name|TW_UINT16
name|current_fw_srl
parameter_list|,
name|TW_UINT16
name|current_fw_arch_id
parameter_list|,
name|TW_UINT16
name|current_fw_branch
parameter_list|,
name|TW_UINT16
name|current_fw_build
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_srl
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_arch_id
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_branch
parameter_list|,
name|TW_UINT16
modifier|*
name|fw_on_ctlr_build
parameter_list|,
name|TW_UINT32
modifier|*
name|init_connect_result
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|struct
name|tw_cl_command_init_connect
modifier|*
name|init_connect
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_EBUSY
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
goto|goto
name|out
goto|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
comment|/* Build the cmd pkt. */
name|init_connect
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|init_connect
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|init_connect
operator|->
name|res1__opcode
operator|=
name|BUILD_RES__OPCODE
argument_list|(
literal|0
argument_list|,
name|TWA_FW_CMD_INIT_CONNECTION
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|message_credits
operator|=
name|TW_CL_SWAP16
argument_list|(
name|message_credits
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|features
operator|=
name|TW_CL_SWAP32
argument_list|(
name|set_features
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
name|init_connect
operator|->
name|features
operator||=
name|TWA_64BIT_SG_ADDRESSES
expr_stmt|;
if|if
condition|(
name|set_features
operator|&
name|TWA_EXTENDED_INIT_CONNECT
condition|)
block|{
comment|/* 		 * Fill in the extra fields needed for an extended 		 * init_connect. 		 */
name|init_connect
operator|->
name|size
operator|=
literal|6
expr_stmt|;
name|init_connect
operator|->
name|fw_srl
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_srl
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|fw_arch_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_arch_id
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|fw_branch
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_branch
argument_list|)
expr_stmt|;
name|init_connect
operator|->
name|fw_build
operator|=
name|TW_CL_SWAP16
argument_list|(
name|current_fw_build
argument_list|)
expr_stmt|;
block|}
else|else
name|init_connect
operator|->
name|size
operator|=
literal|3
expr_stmt|;
comment|/* Submit the command, and wait for it to complete. */
name|error
operator|=
name|tw_cli_submit_and_poll_request
argument_list|(
name|req
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|TW_OSL_ETIMEDOUT
condition|)
comment|/* Clean-up done by tw_cli_submit_and_poll_request. */
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|init_connect
operator|->
name|status
operator|)
condition|)
block|{
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|set_features
operator|&
name|TWA_EXTENDED_INIT_CONNECT
condition|)
block|{
operator|*
name|fw_on_ctlr_srl
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_srl
argument_list|)
expr_stmt|;
operator|*
name|fw_on_ctlr_arch_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_arch_id
argument_list|)
expr_stmt|;
operator|*
name|fw_on_ctlr_branch
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_branch
argument_list|)
expr_stmt|;
operator|*
name|fw_on_ctlr_build
operator|=
name|TW_CL_SWAP16
argument_list|(
name|init_connect
operator|->
name|fw_build
argument_list|)
expr_stmt|;
operator|*
name|init_connect_result
operator|=
name|TW_CL_SWAP32
argument_list|(
name|init_connect
operator|->
name|result
argument_list|)
expr_stmt|;
block|}
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1016
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"init_connection failed"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

