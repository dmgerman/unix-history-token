begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-07 Applied Micro Circuits Corporation.  * Copyright (c) 2004-05 Vinod Kashyap  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * AMCC'S 3ware driver for 9000 series storage controllers.  *  * Author: Vinod Kashyap  * Modifications by: Adam Radford  */
end_comment

begin_comment
comment|/*  * Common Layer interrupt handling functions.  */
end_comment

begin_include
include|#
directive|include
file|"tw_osl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_fwif.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_externs.h"
end_include

begin_include
include|#
directive|include
file|"tw_osl_ioctl.h"
end_include

begin_comment
comment|/*  * Function name:	twa_interrupt  * Description:		Interrupt handler.  Determines the kind of interrupt,  *			and returns TW_CL_TRUE if it recognizes the interrupt.  *  * Input:		ctlr_handle	-- controller handle  * Output:		None  * Return value:	TW_CL_TRUE -- interrupt recognized  *			TW_CL_FALSE-- interrupt not recognized  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_interrupt
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
decl_stmt|;
name|TW_UINT32
name|status_reg
decl_stmt|;
name|TW_INT32
name|rc
init|=
name|TW_CL_FALSE
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* If we don't have controller context, bail */
if|if
condition|(
name|ctlr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Synchronize access between writes to command and control registers 	 * in 64-bit environments, on G66. 	 */
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_G66_WORKAROUND_NEEDED
condition|)
name|tw_osl_get_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* Read the status register to determine the type of interrupt. */
name|status_reg
operator|=
name|TW_CLI_READ_STATUS_REGISTER
argument_list|(
name|ctlr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|tw_cli_check_ctlr_state
argument_list|(
name|ctlr
argument_list|,
name|status_reg
argument_list|)
condition|)
goto|goto
name|out_unlock
goto|;
comment|/* Clear the interrupt. */
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_HOST_INTERRUPT
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Host interrupt"
argument_list|)
expr_stmt|;
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_CLEAR_HOST_INTERRUPT
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|host_intr_pending
operator|=
literal|0
expr_stmt|;
comment|/* we don't use this */
name|rc
operator||=
name|TW_CL_FALSE
expr_stmt|;
comment|/* don't request for a deferred isr call */
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_ATTENTION_INTERRUPT
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Attention interrupt"
argument_list|)
expr_stmt|;
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_CLEAR_ATTENTION_INTERRUPT
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|attn_intr_pending
operator|=
literal|1
expr_stmt|;
name|rc
operator||=
name|TW_CL_TRUE
expr_stmt|;
comment|/* request for a deferred isr call */
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_COMMAND_INTERRUPT
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Command interrupt"
argument_list|)
expr_stmt|;
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_MASK_COMMAND_INTERRUPT
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|cmd_intr_pending
operator|=
literal|1
expr_stmt|;
name|rc
operator||=
name|TW_CL_TRUE
expr_stmt|;
comment|/* request for a deferred isr call */
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_RESPONSE_INTERRUPT
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Response interrupt"
argument_list|)
expr_stmt|;
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_MASK_RESPONSE_INTERRUPT
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|resp_intr_pending
operator|=
literal|1
expr_stmt|;
name|rc
operator||=
name|TW_CL_TRUE
expr_stmt|;
comment|/* request for a deferred isr call */
block|}
name|out_unlock
label|:
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_G66_WORKAROUND_NEEDED
condition|)
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_deferred_interrupt  * Description:		Deferred interrupt handler.  Does most of the processing  *			related to an interrupt.  *  * Input:		ctlr_handle	-- controller handle  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cl_deferred_interrupt
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Dispatch based on the kind of interrupt. */
if|if
condition|(
name|ctlr
operator|->
name|host_intr_pending
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Processing Host interrupt"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|host_intr_pending
operator|=
literal|0
expr_stmt|;
name|tw_cli_process_host_intr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|attn_intr_pending
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Processing Attention interrupt"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|attn_intr_pending
operator|=
literal|0
expr_stmt|;
name|tw_cli_process_attn_intr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|cmd_intr_pending
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Processing Command interrupt"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|cmd_intr_pending
operator|=
literal|0
expr_stmt|;
name|tw_cli_process_cmd_intr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|resp_intr_pending
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Processing Response interrupt"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|resp_intr_pending
operator|=
literal|0
expr_stmt|;
name|tw_cli_process_resp_intr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_process_host_intr  * Description:		This function gets called if we triggered an interrupt.  *			We don't use it as of now.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_process_host_intr
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_process_attn_intr  * Description:		This function gets called if the fw posted an AEN  *			(Asynchronous Event Notification).  It fetches  *			all the AEN's that the fw might have posted.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_process_attn_intr
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_get_aen
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * If the driver is already in the process of retrieveing AEN's, 		 * we will be returned TW_OSL_EBUSY.  In this case, 		 * tw_cli_param_callback or tw_cli_aen_callback will eventually 		 * retrieve the AEN this attention interrupt is for.  So, we 		 * don't need to print the failure. 		 */
if|if
condition|(
name|error
operator|!=
name|TW_OSL_EBUSY
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1200
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Failed to fetch AEN"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_process_cmd_intr  * Description:		This function gets called if we hit a queue full  *			condition earlier, and the fw is now ready for  *			new cmds.  Submits any pending requests.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_process_cmd_intr
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|6
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * Let the OS Layer submit any requests in its pending queue, 	 * if it has one. 	 */
name|tw_osl_ctlr_ready
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
comment|/* Start any requests that might be in the pending queue. */
name|tw_cli_submit_pending_queue
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* 	 * If tw_cli_submit_pending_queue was unsuccessful due to a "cmd queue 	 * full" condition, cmd_intr will already have been unmasked by 	 * tw_cli_submit_cmd.  We don't need to do it again... simply return. 	 */
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_process_resp_intr  * Description:		Looks for cmd completions from fw; queues cmds completed  *			by fw into complete queue.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	0	-- no ctlr error  *			non-zero-- ctlr error  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_process_resp_intr
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|TW_UINT32
name|resp
decl_stmt|;
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|TW_UINT32
name|status_reg
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Serialize access to the controller response queue. */
name|tw_osl_get_lock
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status_reg
operator|=
name|TW_CLI_READ_STATUS_REGISTER
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_check_ctlr_state
argument_list|(
name|ctlr
argument_list|,
name|status_reg
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_RESPONSE_QUEUE_EMPTY
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|7
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Response queue empty"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Response queue is not empty. */
name|resp
operator|=
name|TW_CLI_READ_RESPONSE_QUEUE
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
block|{
name|req
operator|=
operator|&
operator|(
name|ctlr
operator|->
name|req_ctxt_buf
index|[
name|GET_RESP_ID
argument_list|(
name|resp
argument_list|)
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_BUSY
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1201
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Unposted command completed!!"
argument_list|,
literal|"request = %p, status = %d"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TW_OSL_DEBUG
name|tw_cl_print_ctlr_stats
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DEBUG */
name|tw_osl_free_lock
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
name|tw_cl_reset_ctlr
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EIO
operator|)
return|;
block|}
comment|/* 		 * Remove the request from the busy queue, mark it as complete, 		 * and enqueue it in the complete queue. 		 */
name|tw_cli_req_q_remove_item
argument_list|(
name|req
argument_list|,
name|TW_CLI_BUSY_Q
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|=
name|TW_CLI_REQ_STATE_COMPLETE
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_COMPLETE_Q
argument_list|)
expr_stmt|;
block|}
comment|/* Unmask the response interrupt. */
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_UNMASK_RESPONSE_INTERRUPT
argument_list|)
expr_stmt|;
name|tw_osl_free_lock
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|intr_lock
argument_list|)
expr_stmt|;
comment|/* Complete this, and other requests in the complete queue. */
name|tw_cli_process_complete_queue
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_submit_pending_queue  * Description:		Kick starts any requests in the pending queue.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	0	-- all pending requests submitted successfully  *			non-zero-- otherwise  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_submit_pending_queue
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * Pull requests off the pending queue, and submit them. 	 */
while|while
condition|(
operator|(
name|req
operator|=
name|tw_cli_req_q_remove_head
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_PENDING_Q
argument_list|)
operator|)
operator|!=
name|TW_CL_NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|TW_OSL_EBUSY
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Requeueing pending request"
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|=
name|TW_CLI_REQ_STATE_PENDING
expr_stmt|;
comment|/* 				 * Queue the request at the head of the pending 				 * queue, and break away, so we don't try to 				 * submit any more requests. 				 */
name|tw_cli_req_q_insert_head
argument_list|(
name|req
argument_list|,
name|TW_CLI_PENDING_Q
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1202
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Could not start request "
literal|"in pending queue"
argument_list|,
literal|"request = %p, opcode = 0x%x, "
literal|"error = %d"
argument_list|,
name|req
argument_list|,
name|GET_OPCODE
argument_list|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|.
name|res__opcode
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 				 * Set the appropriate error and call the CL 				 * internal callback if there's one.  If the 				 * request originator is polling for completion, 				 * he should be checking req->error to 				 * determine that the request did not go 				 * through.  The request originators are 				 * responsible for the clean-up. 				 */
name|req
operator|->
name|error_code
operator|=
name|error
expr_stmt|;
name|req
operator|->
name|state
operator|=
name|TW_CLI_REQ_STATE_COMPLETE
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|tw_cli_callback
condition|)
name|req
operator|->
name|tw_cli_callback
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|error
operator|=
name|TW_OSL_ESUCCESS
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_process_complete_queue  * Description:		Calls the CL internal callback routine, if any, for  *			each request in the complete queue.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_process_complete_queue
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * Pull commands off the completed list, dispatch them appropriately. 	 */
while|while
condition|(
operator|(
name|req
operator|=
name|tw_cli_req_q_remove_head
argument_list|(
name|ctlr
argument_list|,
name|TW_CLI_COMPLETE_Q
argument_list|)
operator|)
operator|!=
name|TW_CL_NULL
condition|)
block|{
comment|/* Call the CL internal callback, if there's one. */
if|if
condition|(
name|req
operator|->
name|tw_cli_callback
condition|)
name|req
operator|->
name|tw_cli_callback
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_complete_io  * Description:		CL internal callback for SCSI/fw passthru requests.  *  * Input:		req	-- ptr to CL internal request context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_complete_io
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
name|req
operator|->
name|ctlr
decl_stmt|;
name|struct
name|tw_cl_req_packet
modifier|*
name|req_pkt
init|=
operator|(
expr|struct
name|tw_cl_req_packet
operator|*
operator|)
operator|(
name|req
operator|->
name|orig_req
operator|)
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|8
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|req_pkt
operator|->
name|status
operator|=
name|TW_CL_ERR_REQ_SUCCESS
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|error_code
condition|)
block|{
name|req_pkt
operator|->
name|status
operator|=
name|TW_CL_ERR_REQ_UNABLE_TO_SUBMIT_COMMAND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_COMPLETE
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1203
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"I/O completion on incomplete command!!"
argument_list|,
literal|"request = %p, status = %d"
argument_list|,
name|req
argument_list|,
name|req
operator|->
name|state
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TW_OSL_DEBUG
name|tw_cl_print_ctlr_stats
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TW_OSL_DEBUG */
name|tw_cl_reset_ctlr
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
name|req_pkt
operator|->
name|status
operator|=
name|TW_CL_ERR_REQ_BUS_RESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|req
operator|->
name|flags
operator|&
name|TW_CLI_REQ_FLAGS_PASSTHRU
condition|)
block|{
comment|/* Copy the command packet back into OSL's space. */
name|tw_osl_memcpy
argument_list|(
name|req_pkt
operator|->
name|gen_req_pkt
operator|.
name|pt_req
operator|.
name|cmd_pkt
argument_list|,
name|req
operator|->
name|cmd_pkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_packet
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|tw_cli_scsi_complete
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|out
label|:
name|req_pkt
operator|->
name|tw_osl_callback
argument_list|(
name|req
operator|->
name|req_handle
argument_list|)
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_scsi_complete  * Description:		Completion routine for SCSI requests.  *  * Input:		req	-- ptr to CL internal request context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_scsi_complete
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tw_cl_req_packet
modifier|*
name|req_pkt
init|=
operator|(
expr|struct
name|tw_cl_req_packet
operator|*
operator|)
operator|(
name|req
operator|->
name|orig_req
operator|)
decl_stmt|;
name|struct
name|tw_cl_scsi_req_packet
modifier|*
name|scsi_req
init|=
operator|&
operator|(
name|req_pkt
operator|->
name|gen_req_pkt
operator|.
name|scsi_req
operator|)
decl_stmt|;
name|struct
name|tw_cl_command_9k
modifier|*
name|cmd
init|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|)
decl_stmt|;
name|struct
name|tw_cl_command_header
modifier|*
name|cmd_hdr
decl_stmt|;
name|TW_UINT16
name|error
decl_stmt|;
name|TW_UINT8
modifier|*
name|cdb
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|8
argument_list|,
name|req
operator|->
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|scsi_req
operator|->
name|scsi_status
operator|=
name|cmd
operator|->
name|status
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|->
name|status
condition|)
return|return;
name|tw_cli_dbg_printf
argument_list|(
literal|1
argument_list|,
name|req
operator|->
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"req_id = 0x%x, status = 0x%x"
argument_list|,
name|GET_REQ_ID
argument_list|(
name|cmd
operator|->
name|lun_l4__req_id
argument_list|)
argument_list|,
name|cmd
operator|->
name|status
argument_list|)
expr_stmt|;
name|cmd_hdr
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
expr_stmt|;
name|error
operator|=
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|TWA_ERROR_LOGICAL_UNIT_NOT_SUPPORTED
operator|)
operator|||
operator|(
name|error
operator|==
name|TWA_ERROR_UNIT_OFFLINE
operator|)
condition|)
block|{
if|if
condition|(
name|GET_LUN_L4
argument_list|(
name|cmd
operator|->
name|lun_l4__req_id
argument_list|)
condition|)
name|req_pkt
operator|->
name|status
operator||=
name|TW_CL_ERR_REQ_INVALID_LUN
expr_stmt|;
else|else
name|req_pkt
operator|->
name|status
operator||=
name|TW_CL_ERR_REQ_INVALID_TARGET
expr_stmt|;
block|}
else|else
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|req
operator|->
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"cmd = %x %x %x %x %x %x %x"
argument_list|,
name|GET_OPCODE
argument_list|(
name|cmd
operator|->
name|res__opcode
argument_list|)
argument_list|,
name|GET_SGL_OFF
argument_list|(
name|cmd
operator|->
name|res__opcode
argument_list|)
argument_list|,
name|cmd
operator|->
name|unit
argument_list|,
name|cmd
operator|->
name|lun_l4__req_id
argument_list|,
name|cmd
operator|->
name|status
argument_list|,
name|cmd
operator|->
name|sgl_offset
argument_list|,
name|cmd
operator|->
name|lun_h4__sgl_entries
argument_list|)
expr_stmt|;
name|cdb
operator|=
operator|(
name|TW_UINT8
operator|*
operator|)
operator|(
name|cmd
operator|->
name|cdb
operator|)
expr_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|req
operator|->
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"cdb = %x %x %x %x %x %x %x %x "
literal|"%x %x %x %x %x %x %x %x"
argument_list|,
name|cdb
index|[
literal|0
index|]
argument_list|,
name|cdb
index|[
literal|1
index|]
argument_list|,
name|cdb
index|[
literal|2
index|]
argument_list|,
name|cdb
index|[
literal|3
index|]
argument_list|,
name|cdb
index|[
literal|4
index|]
argument_list|,
name|cdb
index|[
literal|5
index|]
argument_list|,
name|cdb
index|[
literal|6
index|]
argument_list|,
name|cdb
index|[
literal|7
index|]
argument_list|,
name|cdb
index|[
literal|8
index|]
argument_list|,
name|cdb
index|[
literal|9
index|]
argument_list|,
name|cdb
index|[
literal|10
index|]
argument_list|,
name|cdb
index|[
literal|11
index|]
argument_list|,
name|cdb
index|[
literal|12
index|]
argument_list|,
name|cdb
index|[
literal|13
index|]
argument_list|,
name|cdb
index|[
literal|14
index|]
argument_list|,
name|cdb
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
comment|/*  		 * Print the error. Firmware doesn't yet support 		 * the 'Mode Sense' cmd.  Don't print if the cmd 		 * is 'Mode Sense', and the error is 'Invalid field 		 * in CDB'. 		 */
if|if
condition|(
operator|!
operator|(
operator|(
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x1A
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0x10D
operator|)
operator|)
condition|)
name|tw_cli_create_ctlr_event
argument_list|(
name|req
operator|->
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|cmd_hdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scsi_req
operator|->
name|sense_data
condition|)
block|{
name|tw_osl_memcpy
argument_list|(
name|scsi_req
operator|->
name|sense_data
argument_list|,
name|cmd_hdr
operator|->
name|sense_data
argument_list|,
name|TWA_SENSE_DATA_LENGTH
argument_list|)
expr_stmt|;
name|scsi_req
operator|->
name|sense_len
operator|=
name|TWA_SENSE_DATA_LENGTH
expr_stmt|;
name|req_pkt
operator|->
name|status
operator||=
name|TW_CL_ERR_REQ_AUTO_SENSE_VALID
expr_stmt|;
block|}
name|req_pkt
operator|->
name|status
operator||=
name|TW_CL_ERR_REQ_SCSI_ERROR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_param_callback  * Description:		Callback for get/set_param requests.  *  * Input:		req	-- ptr to completed request pkt  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_param_callback
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
name|req
operator|->
name|ctlr
decl_stmt|;
name|union
name|tw_cl_command_7k
modifier|*
name|cmd
init|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|)
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * If the request was never submitted to the controller, the function 	 * that sets req->error is responsible for calling tw_cl_create_event. 	 */
if|if
condition|(
operator|!
name|req
operator|->
name|error_code
condition|)
if|if
condition|(
name|cmd
operator|->
name|param
operator|.
name|status
condition|)
block|{
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
argument_list|)
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1204
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"get/set_param failed"
argument_list|,
literal|"status = %d"
argument_list|,
name|cmd
operator|->
name|param
operator|.
name|status
argument_list|)
expr_stmt|;
block|}
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_GET_MORE_AENS
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_RESET_IN_PROGRESS
operator|)
operator|)
condition|)
block|{
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_GET_MORE_AENS
expr_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Fetching more AEN's"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_get_aen
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1205
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Failed to fetch all AEN's from param_callback"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_aen_callback  * Description:		Callback for requests to fetch AEN's.  *  * Input:		req	-- ptr to completed request pkt  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_aen_callback
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
name|req
operator|->
name|ctlr
decl_stmt|;
name|struct
name|tw_cl_command_header
modifier|*
name|cmd_hdr
decl_stmt|;
name|struct
name|tw_cl_command_9k
modifier|*
name|cmd
init|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|)
decl_stmt|;
name|TW_UINT16
name|aen_code
init|=
name|TWA_AEN_QUEUE_EMPTY
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"req_id = 0x%x, req error = %d, status = 0x%x"
argument_list|,
name|GET_REQ_ID
argument_list|(
name|cmd
operator|->
name|lun_l4__req_id
argument_list|)
argument_list|,
name|req
operator|->
name|error_code
argument_list|,
name|cmd
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * If the request was never submitted to the controller, the function 	 * that sets error is responsible for calling tw_cl_create_event. 	 */
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|req
operator|->
name|error_code
operator|)
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|status
operator|)
condition|)
block|{
name|cmd_hdr
operator|=
operator|(
expr|struct
name|tw_cl_command_header
operator|*
operator|)
operator|(
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
operator|)
expr_stmt|;
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|cmd_hdr
argument_list|)
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1206
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Request Sense failed"
argument_list|,
literal|"opcode = 0x%x, status = %d"
argument_list|,
name|GET_OPCODE
argument_list|(
name|cmd
operator|->
name|res__opcode
argument_list|)
argument_list|,
name|cmd
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return;
block|}
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Request Sense command succeeded"
argument_list|)
expr_stmt|;
name|aen_code
operator|=
name|tw_cli_manage_aen
argument_list|(
name|ctlr
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|aen_code
operator|!=
name|TWA_AEN_SYNC_TIME_WITH_HOST
condition|)
block|{
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|aen_code
operator|!=
name|TWA_AEN_QUEUE_EMPTY
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_get_aen
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1207
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Failed to fetch all AEN's"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_manage_aen  * Description:		Handles AEN's.  *  * Input:		ctlr	-- ptr to CL internal ctlr context  *			req	-- ptr to CL internal request context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_UINT16
name|tw_cli_manage_aen
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|,
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tw_cl_command_header
modifier|*
name|cmd_hdr
decl_stmt|;
name|TW_UINT16
name|aen_code
decl_stmt|;
name|TW_TIME
name|local_time
decl_stmt|;
name|TW_TIME
name|sync_time
decl_stmt|;
name|TW_UINT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|cmd_hdr
operator|=
operator|(
expr|struct
name|tw_cl_command_header
operator|*
operator|)
operator|(
name|req
operator|->
name|data
operator|)
expr_stmt|;
name|aen_code
operator|=
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
expr_stmt|;
switch|switch
condition|(
name|aen_code
condition|)
block|{
case|case
name|TWA_AEN_SYNC_TIME_WITH_HOST
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Received AEN_SYNC_TIME"
argument_list|)
expr_stmt|;
comment|/* 		 * Free the internal req pkt right here, since 		 * tw_cli_set_param will need it. 		 */
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
comment|/* 		 * We will use a callback in tw_cli_set_param only when 		 * interrupts are enabled and we can expect our callback 		 * to get called.  Setting the TW_CLI_CTLR_STATE_GET_MORE_AENS 		 * flag will make the callback continue to try to retrieve 		 * more AEN's. 		 */
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_INTR_ENABLED
condition|)
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_GET_MORE_AENS
expr_stmt|;
comment|/* Calculate time (in seconds) since last Sunday 12.00 AM. */
name|local_time
operator|=
name|tw_osl_get_local_time
argument_list|()
expr_stmt|;
name|sync_time
operator|=
operator|(
name|local_time
operator|-
operator|(
literal|3
operator|*
literal|86400
operator|)
operator|)
operator|%
literal|604800
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_set_param
argument_list|(
name|ctlr
argument_list|,
name|TWA_PARAM_TIME_TABLE
argument_list|,
name|TWA_PARAM_TIME_SCHED_TIME
argument_list|,
literal|4
argument_list|,
operator|&
name|sync_time
argument_list|,
operator|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_INTR_ENABLED
operator|)
condition|?
name|tw_cli_param_callback
else|:
name|TW_CL_NULL
argument_list|)
operator|)
condition|)
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1208
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Unable to sync time with ctlr"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWA_AEN_QUEUE_EMPTY
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"AEN queue empty"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Queue the event. */
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Queueing AEN"
argument_list|)
expr_stmt|;
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_EVENT
argument_list|,
name|cmd_hdr
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
return|return
operator|(
name|aen_code
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_enable_interrupts  * Description:		Enables interrupts on the controller  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_enable_interrupts
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_INTR_ENABLED
expr_stmt|;
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_CLEAR_ATTENTION_INTERRUPT
operator||
name|TWA_CONTROL_UNMASK_RESPONSE_INTERRUPT
operator||
name|TWA_CONTROL_ENABLE_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_setup  * Description:		Disables interrupts on the controller  *  * Input:		ctlr	-- ptr to CL internal ctlr context  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_disable_interrupts
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_DISABLE_INTERRUPTS
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTR_ENABLED
expr_stmt|;
block|}
end_function

end_unit

