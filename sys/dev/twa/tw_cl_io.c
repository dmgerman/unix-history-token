begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-07 Applied Micro Circuits Corporation.  * Copyright (c) 2004-05 Vinod Kashyap  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * AMCC'S 3ware driver for 9000 series storage controllers.  *  * Author: Vinod Kashyap  * Modifications by: Adam Radford  */
end_comment

begin_comment
comment|/*  * Common Layer I/O functions.  */
end_comment

begin_include
include|#
directive|include
file|"tw_osl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_share.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_fwif.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl.h"
end_include

begin_include
include|#
directive|include
file|"tw_cl_externs.h"
end_include

begin_include
include|#
directive|include
file|"tw_osl_ioctl.h"
end_include

begin_comment
comment|/*  * Function name:	tw_cl_start_io  * Description:		Interface to OS Layer for accepting SCSI requests.  *  * Input:		ctlr_handle	-- controller handle  *			req_pkt		-- OSL built request packet  *			req_handle	-- request handle  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_start_io
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|struct
name|tw_cl_req_packet
modifier|*
name|req_pkt
parameter_list|,
name|struct
name|tw_cl_req_handle
modifier|*
name|req_handle
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
decl_stmt|;
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|struct
name|tw_cl_command_9k
modifier|*
name|cmd
decl_stmt|;
name|struct
name|tw_cl_scsi_req_packet
modifier|*
name|scsi_req
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|ctlr
operator|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_RESET_IN_PROGRESS
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"I/O during reset: returning busy. Ctlr state = 0x%x"
argument_list|,
name|ctlr
operator|->
name|state
argument_list|)
expr_stmt|;
name|tw_osl_ctlr_busy
argument_list|(
name|ctlr_handle
argument_list|,
name|req_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
block|}
comment|/* 	 * If working with a firmware version that does not support multiple 	 * luns, and this request is directed at a non-zero lun, error it 	 * back right away. 	 */
if|if
condition|(
operator|(
name|req_pkt
operator|->
name|gen_req_pkt
operator|.
name|scsi_req
operator|.
name|lun
operator|)
operator|&&
operator|(
name|ctlr
operator|->
name|working_srl
operator|<
name|TWA_MULTI_LUN_FW_SRL
operator|)
condition|)
block|{
name|req_pkt
operator|->
name|status
operator||=
operator|(
name|TW_CL_ERR_REQ_INVALID_LUN
operator||
name|TW_CL_ERR_REQ_SCSI_ERROR
operator|)
expr_stmt|;
name|req_pkt
operator|->
name|tw_osl_callback
argument_list|(
name|req_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_CL_ERR_REQ_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Out of request context packets: returning busy"
argument_list|)
expr_stmt|;
name|tw_osl_ctlr_busy
argument_list|(
name|ctlr_handle
argument_list|,
name|req_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
block|}
name|req_handle
operator|->
name|cl_req_ctxt
operator|=
name|req
expr_stmt|;
name|req
operator|->
name|req_handle
operator|=
name|req_handle
expr_stmt|;
name|req
operator|->
name|orig_req
operator|=
name|req_pkt
expr_stmt|;
name|req
operator|->
name|tw_cli_callback
operator|=
name|tw_cli_complete_io
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_EXTERNAL
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_9K
expr_stmt|;
name|scsi_req
operator|=
operator|&
operator|(
name|req_pkt
operator|->
name|gen_req_pkt
operator|.
name|scsi_req
operator|)
expr_stmt|;
comment|/* Build the cmd pkt. */
name|cmd
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|->
name|res__opcode
operator|=
name|BUILD_RES__OPCODE
argument_list|(
literal|0
argument_list|,
name|TWA_FW_CMD_EXECUTE_SCSI
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|unit
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|scsi_req
operator|->
name|unit
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|lun_l4__req_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|BUILD_LUN_L4__REQ_ID
argument_list|(
name|scsi_req
operator|->
name|lun
argument_list|,
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|sgl_offset
operator|=
literal|16
expr_stmt|;
comment|/* offset from end of hdr = max cdb len */
name|tw_osl_memcpy
argument_list|(
name|cmd
operator|->
name|cdb
argument_list|,
name|scsi_req
operator|->
name|cdb
argument_list|,
name|scsi_req
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_pkt
operator|->
name|flags
operator|&
name|TW_CL_REQ_CALLBACK_FOR_SGLIST
condition|)
block|{
name|TW_UINT32
name|num_sgl_entries
decl_stmt|;
name|req_pkt
operator|->
name|tw_osl_sgl_callback
argument_list|(
name|req_handle
argument_list|,
name|cmd
operator|->
name|sg_list
argument_list|,
operator|&
name|num_sgl_entries
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|lun_h4__sgl_entries
operator|=
name|TW_CL_SWAP16
argument_list|(
name|BUILD_LUN_H4__SGL_ENTRIES
argument_list|(
name|scsi_req
operator|->
name|lun
argument_list|,
name|num_sgl_entries
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|->
name|lun_h4__sgl_entries
operator|=
name|TW_CL_SWAP16
argument_list|(
name|BUILD_LUN_H4__SGL_ENTRIES
argument_list|(
name|scsi_req
operator|->
name|lun
argument_list|,
name|scsi_req
operator|->
name|sgl_entries
argument_list|)
argument_list|)
expr_stmt|;
name|tw_cli_fill_sg_list
argument_list|(
name|ctlr
argument_list|,
name|scsi_req
operator|->
name|sg_list
argument_list|,
name|cmd
operator|->
name|sg_list
argument_list|,
name|scsi_req
operator|->
name|sgl_entries
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Could not start request. request = %p, error = %d"
argument_list|,
name|req
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_submit_cmd  * Description:		Submits a cmd to firmware.  *  * Input:		req	-- ptr to CL internal request context  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_submit_cmd
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
name|req
operator|->
name|ctlr
decl_stmt|;
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
init|=
name|ctlr
operator|->
name|ctlr_handle
decl_stmt|;
name|TW_UINT32
name|status_reg
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|TW_UINT8
name|notify_osl_of_ctlr_busy
init|=
name|TW_CL_FALSE
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Serialize access to the controller cmd queue. */
name|tw_osl_get_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* For 9650SE first write low 4 bytes */
if|if
condition|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_E
condition|)
name|tw_osl_write_reg
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_COMMAND_QUEUE_OFFSET_LOW
argument_list|,
call|(
name|TW_UINT32
call|)
argument_list|(
name|req
operator|->
name|cmd_pkt_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Check to see if we can post a command. */
name|status_reg
operator|=
name|TW_CLI_READ_STATUS_REGISTER
argument_list|(
name|ctlr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_check_ctlr_state
argument_list|(
name|ctlr
argument_list|,
name|status_reg
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_COMMAND_QUEUE_FULL
condition|)
block|{
name|struct
name|tw_cl_req_packet
modifier|*
name|req_pkt
init|=
operator|(
expr|struct
name|tw_cl_req_packet
operator|*
operator|)
operator|(
name|req
operator|->
name|orig_req
operator|)
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|7
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Cmd queue full"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|flags
operator|&
name|TW_CLI_REQ_FLAGS_INTERNAL
operator|)
operator|||
operator|(
operator|(
name|req_pkt
operator|)
operator|&&
operator|(
name|req_pkt
operator|->
name|flags
operator|&
name|TW_CL_REQ_RETRY_ON_BUSY
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_PENDING
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"pending internal/ioctl request"
argument_list|)
expr_stmt|;
name|req
operator|->
name|state
operator|=
name|TW_CLI_REQ_STATE_PENDING
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_PENDING_Q
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|TW_OSL_EBUSY
expr_stmt|;
block|}
else|else
block|{
name|notify_osl_of_ctlr_busy
operator|=
name|TW_CL_TRUE
expr_stmt|;
name|error
operator|=
name|TW_OSL_EBUSY
expr_stmt|;
block|}
block|}
else|else
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Submitting command"
argument_list|)
expr_stmt|;
comment|/* Insert command into busy queue */
name|req
operator|->
name|state
operator|=
name|TW_CLI_REQ_STATE_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_BUSY_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_E
condition|)
block|{
comment|/* Now write the high 4 bytes */
name|tw_osl_write_reg
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_COMMAND_QUEUE_OFFSET_HIGH
argument_list|,
call|(
name|TW_UINT32
call|)
argument_list|(
operator|(
call|(
name|TW_UINT64
call|)
argument_list|(
name|req
operator|->
name|cmd_pkt_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
argument_list|)
operator|)
operator|>>
literal|32
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
block|{
comment|/* First write the low 4 bytes, then the high 4. */
name|tw_osl_write_reg
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_COMMAND_QUEUE_OFFSET_LOW
argument_list|,
call|(
name|TW_UINT32
call|)
argument_list|(
name|req
operator|->
name|cmd_pkt_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|tw_osl_write_reg
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_COMMAND_QUEUE_OFFSET_HIGH
argument_list|,
call|(
name|TW_UINT32
call|)
argument_list|(
operator|(
call|(
name|TW_UINT64
call|)
argument_list|(
name|req
operator|->
name|cmd_pkt_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
argument_list|)
operator|)
operator|>>
literal|32
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|tw_osl_write_reg
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_COMMAND_QUEUE_OFFSET
argument_list|,
call|(
name|TW_UINT32
call|)
argument_list|(
name|req
operator|->
name|cmd_pkt_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_COMMAND_QUEUE_FULL
condition|)
block|{
if|if
condition|(
name|notify_osl_of_ctlr_busy
condition|)
name|tw_osl_ctlr_busy
argument_list|(
name|ctlr_handle
argument_list|,
name|req
operator|->
name|req_handle
argument_list|)
expr_stmt|;
comment|/* 		 * Synchronize access between writes to command and control 		 * registers in 64-bit environments, on G66. 		 */
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_G66_WORKAROUND_NEEDED
condition|)
name|tw_osl_get_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* Unmask command interrupt. */
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_UNMASK_COMMAND_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_G66_WORKAROUND_NEEDED
condition|)
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_fw_passthru  * Description:		Interface to OS Layer for accepting firmware  *			passthru requests.  * Input:		ctlr_handle	-- controller handle  *			req_pkt		-- OSL built request packet  *			req_handle	-- request handle  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_fw_passthru
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|struct
name|tw_cl_req_packet
modifier|*
name|req_pkt
parameter_list|,
name|struct
name|tw_cl_req_handle
modifier|*
name|req_handle
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
decl_stmt|;
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|union
name|tw_cl_command_7k
modifier|*
name|cmd_7k
decl_stmt|;
name|struct
name|tw_cl_command_9k
modifier|*
name|cmd_9k
decl_stmt|;
name|struct
name|tw_cl_passthru_req_packet
modifier|*
name|pt_req
decl_stmt|;
name|TW_UINT8
name|opcode
decl_stmt|;
name|TW_UINT8
name|sgl_offset
decl_stmt|;
name|TW_VOID
modifier|*
name|sgl
init|=
name|TW_CL_NULL
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|5
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|ctlr
operator|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_RESET_IN_PROGRESS
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Passthru request during reset: returning busy. "
literal|"Ctlr state = 0x%x"
argument_list|,
name|ctlr
operator|->
name|state
argument_list|)
expr_stmt|;
name|tw_osl_ctlr_busy
argument_list|(
name|ctlr_handle
argument_list|,
name|req_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Out of request context packets: returning busy"
argument_list|)
expr_stmt|;
name|tw_osl_ctlr_busy
argument_list|(
name|ctlr_handle
argument_list|,
name|req_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
block|}
name|req_handle
operator|->
name|cl_req_ctxt
operator|=
name|req
expr_stmt|;
name|req
operator|->
name|req_handle
operator|=
name|req_handle
expr_stmt|;
name|req
operator|->
name|orig_req
operator|=
name|req_pkt
expr_stmt|;
name|req
operator|->
name|tw_cli_callback
operator|=
name|tw_cli_complete_io
expr_stmt|;
name|req
operator|->
name|flags
operator||=
operator|(
name|TW_CLI_REQ_FLAGS_EXTERNAL
operator||
name|TW_CLI_REQ_FLAGS_PASSTHRU
operator|)
expr_stmt|;
name|pt_req
operator|=
operator|&
operator|(
name|req_pkt
operator|->
name|gen_req_pkt
operator|.
name|pt_req
operator|)
expr_stmt|;
name|tw_osl_memcpy
argument_list|(
name|req
operator|->
name|cmd_pkt
argument_list|,
name|pt_req
operator|->
name|cmd_pkt
argument_list|,
name|pt_req
operator|->
name|cmd_pkt_length
argument_list|)
expr_stmt|;
comment|/* Build the cmd pkt. */
if|if
condition|(
operator|(
name|opcode
operator|=
name|GET_OPCODE
argument_list|(
operator|(
operator|(
name|TW_UINT8
operator|*
operator|)
operator|(
name|pt_req
operator|->
name|cmd_pkt
operator|)
operator|)
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_command_header
argument_list|)
index|]
argument_list|)
operator|)
operator|==
name|TWA_FW_CMD_EXECUTE_SCSI
condition|)
block|{
name|TW_UINT16
name|lun_l4
decl_stmt|,
name|lun_h4
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|5
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"passthru: 9k cmd pkt"
argument_list|)
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_9K
expr_stmt|;
name|cmd_9k
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|)
expr_stmt|;
name|lun_l4
operator|=
name|GET_LUN_L4
argument_list|(
name|cmd_9k
operator|->
name|lun_l4__req_id
argument_list|)
expr_stmt|;
name|lun_h4
operator|=
name|GET_LUN_H4
argument_list|(
name|cmd_9k
operator|->
name|lun_h4__sgl_entries
argument_list|)
expr_stmt|;
name|cmd_9k
operator|->
name|lun_l4__req_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|BUILD_LUN_L4__REQ_ID
argument_list|(
name|lun_l4
argument_list|,
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt_req
operator|->
name|sgl_entries
condition|)
block|{
name|cmd_9k
operator|->
name|lun_h4__sgl_entries
operator|=
name|TW_CL_SWAP16
argument_list|(
name|BUILD_LUN_H4__SGL_ENTRIES
argument_list|(
name|lun_h4
argument_list|,
name|pt_req
operator|->
name|sgl_entries
argument_list|)
argument_list|)
expr_stmt|;
name|sgl
operator|=
operator|(
name|TW_VOID
operator|*
operator|)
operator|(
name|cmd_9k
operator|->
name|sg_list
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|5
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"passthru: 7k cmd pkt"
argument_list|)
expr_stmt|;
name|cmd_7k
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|)
expr_stmt|;
name|cmd_7k
operator|->
name|generic
operator|.
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sgl_offset
operator|=
name|GET_SGL_OFF
argument_list|(
name|cmd_7k
operator|->
name|generic
operator|.
name|sgl_off__opcode
argument_list|)
operator|)
condition|)
block|{
name|sgl
operator|=
operator|(
operator|(
operator|(
name|TW_UINT32
operator|*
operator|)
name|cmd_7k
operator|)
operator|+
name|sgl_offset
operator|)
expr_stmt|;
name|cmd_7k
operator|->
name|generic
operator|.
name|size
operator|+=
name|pt_req
operator|->
name|sgl_entries
operator|*
operator|(
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
operator|)
condition|?
literal|3
else|:
literal|2
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sgl
condition|)
name|tw_cli_fill_sg_list
argument_list|(
name|ctlr
argument_list|,
name|pt_req
operator|->
name|sg_list
argument_list|,
name|sgl
argument_list|,
name|pt_req
operator|->
name|sgl_entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1100
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Failed to start passthru command"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_ioctl  * Description:		Handler of CL supported ioctl cmds.  *  * Input:		ctlr	-- ptr to per ctlr structure  *			cmd	-- ioctl cmd  *			buf	-- ptr to buffer in kernel memory, which is  *				   a copy of the input buffer in user-space  * Output:		buf	-- ptr to buffer in kernel memory, which will  *				   need to be copied to the output buffer in  *				   user-space  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_ioctl
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|,
name|TW_INT32
name|cmd
parameter_list|,
name|TW_VOID
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
decl_stmt|;
name|struct
name|tw_cl_ioctl_packet
modifier|*
name|user_buf
init|=
operator|(
expr|struct
name|tw_cl_ioctl_packet
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|tw_cl_event_packet
name|event_buf
decl_stmt|;
name|TW_INT32
name|event_index
decl_stmt|;
name|TW_INT32
name|start_index
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_ESUCCESS
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|5
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Serialize access to the AEN queue and the ioctl lock. */
name|tw_osl_get_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TW_CL_IOCTL_GET_FIRST_EVENT
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get First Event"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|aen_q_wrapped
condition|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_q_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_OVERFLOW
expr_stmt|;
name|ctlr
operator|->
name|aen_q_overflow
operator|=
name|TW_CL_FALSE
expr_stmt|;
block|}
else|else
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|event_index
operator|=
name|ctlr
operator|->
name|aen_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_head
operator|==
name|ctlr
operator|->
name|aen_tail
condition|)
block|{
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|event_index
operator|=
name|ctlr
operator|->
name|aen_tail
expr_stmt|;
comment|/* = 0 */
block|}
name|tw_osl_memcpy
argument_list|(
name|user_buf
operator|->
name|data_buf
argument_list|,
operator|&
operator|(
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|retrieved
operator|=
name|TW_CL_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TW_CL_IOCTL_GET_LAST_EVENT
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Last Event"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|aen_q_wrapped
condition|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_q_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_OVERFLOW
expr_stmt|;
name|ctlr
operator|->
name|aen_q_overflow
operator|=
name|TW_CL_FALSE
expr_stmt|;
block|}
else|else
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_head
operator|==
name|ctlr
operator|->
name|aen_tail
condition|)
block|{
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
name|event_index
operator|=
operator|(
name|ctlr
operator|->
name|aen_head
operator|-
literal|1
operator|+
name|ctlr
operator|->
name|max_aens_supported
operator|)
operator|%
name|ctlr
operator|->
name|max_aens_supported
expr_stmt|;
name|tw_osl_memcpy
argument_list|(
name|user_buf
operator|->
name|data_buf
argument_list|,
operator|&
operator|(
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|retrieved
operator|=
name|TW_CL_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TW_CL_IOCTL_GET_NEXT_EVENT
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Next Event"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|aen_q_wrapped
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Next Event: wrapped"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|aen_q_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Next Event: overflow"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_OVERFLOW
expr_stmt|;
name|ctlr
operator|->
name|aen_q_overflow
operator|=
name|TW_CL_FALSE
expr_stmt|;
block|}
name|start_index
operator|=
name|ctlr
operator|->
name|aen_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_head
operator|==
name|ctlr
operator|->
name|aen_tail
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Next Event: empty queue"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|start_index
operator|=
name|ctlr
operator|->
name|aen_tail
expr_stmt|;
comment|/* = 0 */
block|}
name|tw_osl_memcpy
argument_list|(
operator|&
name|event_buf
argument_list|,
name|user_buf
operator|->
name|data_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
argument_list|)
expr_stmt|;
name|event_index
operator|=
operator|(
name|start_index
operator|+
name|event_buf
operator|.
name|sequence_id
operator|-
name|ctlr
operator|->
name|aen_queue
index|[
name|start_index
index|]
operator|.
name|sequence_id
operator|+
literal|1
operator|)
operator|%
name|ctlr
operator|->
name|max_aens_supported
expr_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Next Event: si = %x, ei = %x, ebsi = %x, "
literal|"sisi = %x, eisi = %x"
argument_list|,
name|start_index
argument_list|,
name|event_index
argument_list|,
name|event_buf
operator|.
name|sequence_id
argument_list|,
name|ctlr
operator|->
name|aen_queue
index|[
name|start_index
index|]
operator|.
name|sequence_id
argument_list|,
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|sequence_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|sequence_id
operator|>
name|event_buf
operator|.
name|sequence_id
operator|)
condition|)
block|{
comment|/* 			 * We don't have any event matching the criterion.  So, 			 * we have to report TW_CL_ERROR_NO_EVENTS.  If we also 			 * encountered an overflow condition above, we cannot 			 * report both conditions during this call.  We choose 			 * to report NO_EVENTS this time, and an overflow the 			 * next time we are called. 			 */
if|if
condition|(
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|==
name|TW_CL_ERROR_AEN_OVERFLOW
condition|)
block|{
comment|/* 				 * Make a note so we report the overflow 				 * next time. 				 */
name|ctlr
operator|->
name|aen_q_overflow
operator|=
name|TW_CL_TRUE
expr_stmt|;
block|}
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
comment|/* Copy the event -- even if there has been an overflow. */
name|tw_osl_memcpy
argument_list|(
name|user_buf
operator|->
name|data_buf
argument_list|,
operator|&
operator|(
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|retrieved
operator|=
name|TW_CL_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TW_CL_IOCTL_GET_PREVIOUS_EVENT
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get Previous Event"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|aen_q_wrapped
condition|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_q_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_OVERFLOW
expr_stmt|;
name|ctlr
operator|->
name|aen_q_overflow
operator|=
name|TW_CL_FALSE
expr_stmt|;
block|}
name|start_index
operator|=
name|ctlr
operator|->
name|aen_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ctlr
operator|->
name|aen_head
operator|==
name|ctlr
operator|->
name|aen_tail
condition|)
block|{
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|start_index
operator|=
name|ctlr
operator|->
name|aen_tail
expr_stmt|;
comment|/* = 0 */
block|}
name|tw_osl_memcpy
argument_list|(
operator|&
name|event_buf
argument_list|,
name|user_buf
operator|->
name|data_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
argument_list|)
expr_stmt|;
name|event_index
operator|=
operator|(
name|start_index
operator|+
name|event_buf
operator|.
name|sequence_id
operator|-
name|ctlr
operator|->
name|aen_queue
index|[
name|start_index
index|]
operator|.
name|sequence_id
operator|-
literal|1
operator|)
operator|%
name|ctlr
operator|->
name|max_aens_supported
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|sequence_id
operator|<
name|event_buf
operator|.
name|sequence_id
operator|)
condition|)
block|{
comment|/* 			 * We don't have any event matching the criterion.  So, 			 * we have to report TW_CL_ERROR_NO_EVENTS.  If we also 			 * encountered an overflow condition above, we cannot 			 * report both conditions during this call.  We choose 			 * to report NO_EVENTS this time, and an overflow the 			 * next time we are called. 			 */
if|if
condition|(
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|==
name|TW_CL_ERROR_AEN_OVERFLOW
condition|)
block|{
comment|/* 				 * Make a note so we report the overflow 				 * next time. 				 */
name|ctlr
operator|->
name|aen_q_overflow
operator|=
name|TW_CL_TRUE
expr_stmt|;
block|}
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
comment|/* Copy the event -- even if there has been an overflow. */
name|tw_osl_memcpy
argument_list|(
name|user_buf
operator|->
name|data_buf
argument_list|,
operator|&
operator|(
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_event_packet
argument_list|)
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|aen_queue
index|[
name|event_index
index|]
operator|.
name|retrieved
operator|=
name|TW_CL_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TW_CL_IOCTL_GET_LOCK
case|:
block|{
name|struct
name|tw_cl_lock_packet
name|lock_pkt
decl_stmt|;
name|TW_TIME
name|cur_time
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get ioctl lock"
argument_list|)
expr_stmt|;
name|cur_time
operator|=
name|tw_osl_get_local_time
argument_list|()
expr_stmt|;
name|tw_osl_memcpy
argument_list|(
operator|&
name|lock_pkt
argument_list|,
name|user_buf
operator|->
name|data_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_lock_packet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|lock
operator|==
name|TW_CLI_LOCK_FREE
operator|)
operator|||
operator|(
name|lock_pkt
operator|.
name|force_flag
operator|)
operator|||
operator|(
name|cur_time
operator|>=
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|timeout
operator|)
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"GET_LOCK: Getting lock!"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|lock
operator|=
name|TW_CLI_LOCK_HELD
expr_stmt|;
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|timeout
operator|=
name|cur_time
operator|+
operator|(
name|lock_pkt
operator|.
name|timeout_msec
operator|/
literal|1000
operator|)
expr_stmt|;
name|lock_pkt
operator|.
name|time_remaining_msec
operator|=
name|lock_pkt
operator|.
name|timeout_msec
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"GET_LOCK: Lock already held!"
argument_list|)
expr_stmt|;
name|lock_pkt
operator|.
name|time_remaining_msec
operator|=
call|(
name|TW_UINT32
call|)
argument_list|(
operator|(
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|timeout
operator|-
name|cur_time
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_IOCTL_LOCK_ALREADY_HELD
expr_stmt|;
block|}
name|tw_osl_memcpy
argument_list|(
name|user_buf
operator|->
name|data_buf
argument_list|,
operator|&
name|lock_pkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_lock_packet
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TW_CL_IOCTL_RELEASE_LOCK
case|:
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Release ioctl lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|lock
operator|==
name|TW_CLI_LOCK_FREE
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"twa_ioctl: RELEASE_LOCK: Lock not held!"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
name|TW_CL_ERROR_IOCTL_LOCK_NOT_HELD
expr_stmt|;
block|}
else|else
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"RELEASE_LOCK: Releasing lock!"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|ioctl_lock
operator|.
name|lock
operator|=
name|TW_CLI_LOCK_FREE
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|TW_CL_IOCTL_GET_COMPATIBILITY_INFO
case|:
block|{
name|struct
name|tw_cl_compatibility_packet
name|comp_pkt
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Get compatibility info"
argument_list|)
expr_stmt|;
name|tw_osl_memcpy
argument_list|(
name|comp_pkt
operator|.
name|driver_version
argument_list|,
name|TW_OSL_DRIVER_VERSION_STRING
argument_list|,
sizeof|sizeof
argument_list|(
name|TW_OSL_DRIVER_VERSION_STRING
argument_list|)
argument_list|)
expr_stmt|;
name|comp_pkt
operator|.
name|working_srl
operator|=
name|ctlr
operator|->
name|working_srl
expr_stmt|;
name|comp_pkt
operator|.
name|working_branch
operator|=
name|ctlr
operator|->
name|working_branch
expr_stmt|;
name|comp_pkt
operator|.
name|working_build
operator|=
name|ctlr
operator|->
name|working_build
expr_stmt|;
name|comp_pkt
operator|.
name|driver_srl_high
operator|=
name|TWA_CURRENT_FW_SRL
expr_stmt|;
name|comp_pkt
operator|.
name|driver_branch_high
operator|=
name|TWA_CURRENT_FW_BRANCH
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
expr_stmt|;
name|comp_pkt
operator|.
name|driver_build_high
operator|=
name|TWA_CURRENT_FW_BUILD
argument_list|(
name|ctlr
operator|->
name|arch_id
argument_list|)
expr_stmt|;
name|comp_pkt
operator|.
name|driver_srl_low
operator|=
name|TWA_BASE_FW_SRL
expr_stmt|;
name|comp_pkt
operator|.
name|driver_branch_low
operator|=
name|TWA_BASE_FW_BRANCH
expr_stmt|;
name|comp_pkt
operator|.
name|driver_build_low
operator|=
name|TWA_BASE_FW_BUILD
expr_stmt|;
name|comp_pkt
operator|.
name|fw_on_ctlr_srl
operator|=
name|ctlr
operator|->
name|fw_on_ctlr_srl
expr_stmt|;
name|comp_pkt
operator|.
name|fw_on_ctlr_branch
operator|=
name|ctlr
operator|->
name|fw_on_ctlr_branch
expr_stmt|;
name|comp_pkt
operator|.
name|fw_on_ctlr_build
operator|=
name|ctlr
operator|->
name|fw_on_ctlr_build
expr_stmt|;
name|user_buf
operator|->
name|driver_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Copy compatibility information to user space. */
name|tw_osl_memcpy
argument_list|(
name|user_buf
operator|->
name|data_buf
argument_list|,
operator|&
name|comp_pkt
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_compatibility_packet
argument_list|)
operator|<
name|user_buf
operator|->
name|driver_pkt
operator|.
name|buffer_length
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_compatibility_packet
argument_list|)
else|:
name|user_buf
operator|->
name|driver_pkt
operator|.
name|buffer_length
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown opcode. */
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Unknown ioctl cmd 0x%x"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|error
operator|=
name|TW_OSL_ENOTTY
expr_stmt|;
block|}
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_get_param  * Description:		Get a firmware parameter.  *  * Input:		ctlr		-- ptr to per ctlr structure  *			table_id	-- parameter table #  *			param_id	-- index of the parameter in the table  *			param_size	-- size of the parameter in bytes  *			callback	-- ptr to function, if any, to be called  *					back on completion; TW_CL_NULL if no callback.  * Output:		param_data	-- param value  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_get_param
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|,
name|TW_INT32
name|table_id
parameter_list|,
name|TW_INT32
name|param_id
parameter_list|,
name|TW_VOID
modifier|*
name|param_data
parameter_list|,
name|TW_INT32
name|param_size
parameter_list|,
name|TW_VOID
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|union
name|tw_cl_command_7k
modifier|*
name|cmd
decl_stmt|;
name|struct
name|tw_cl_param_9k
modifier|*
name|param
init|=
name|TW_CL_NULL
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_EBUSY
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
goto|goto
name|out
goto|;
comment|/* Make sure this is the only CL internal request at this time. */
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
condition|)
block|{
name|error
operator|=
name|TW_OSL_EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|req
operator|->
name|data
operator|=
name|ctlr
operator|->
name|internal_req_data
expr_stmt|;
name|req
operator|->
name|data_phys
operator|=
name|ctlr
operator|->
name|internal_req_data_phys
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|TW_CLI_SECTOR_SIZE
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
comment|/* Initialize memory to read data into. */
name|param
operator|=
operator|(
expr|struct
name|tw_cl_param_9k
operator|*
operator|)
operator|(
name|req
operator|->
name|data
operator|)
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|param
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_param_9k
argument_list|)
operator|-
literal|1
operator|+
name|param_size
argument_list|)
expr_stmt|;
comment|/* Build the cmd pkt. */
name|cmd
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|sgl_off__opcode
operator|=
name|BUILD_SGL_OFF__OPCODE
argument_list|(
literal|2
argument_list|,
name|TWA_FW_CMD_GET_PARAM
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|host_id__unit
operator|=
name|BUILD_HOST_ID__UNIT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|param_count
operator|=
name|TW_CL_SWAP16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP64
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
operator|+
literal|2
expr_stmt|;
block|}
comment|/* Specify which parameter we need. */
name|param
operator|->
name|table_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|table_id
operator||
name|TWA_9K_PARAM_DESCRIPTOR
argument_list|)
expr_stmt|;
name|param
operator|->
name|parameter_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|param_id
argument_list|)
expr_stmt|;
name|param
operator|->
name|parameter_size_bytes
operator|=
name|TW_CL_SWAP16
argument_list|(
name|param_size
argument_list|)
expr_stmt|;
comment|/* Submit the command. */
if|if
condition|(
name|callback
operator|==
name|TW_CL_NULL
condition|)
block|{
comment|/* There's no call back; wait till the command completes. */
name|error
operator|=
name|tw_cli_submit_and_poll_request
argument_list|(
name|req
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|TW_OSL_ETIMEDOUT
condition|)
comment|/* Clean-up done by tw_cli_submit_and_poll_request. */
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|param
operator|.
name|status
operator|)
condition|)
block|{
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tw_osl_memcpy
argument_list|(
name|param_data
argument_list|,
name|param
operator|->
name|data
argument_list|,
name|param_size
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There's a call back.  Simply submit the command. */
name|req
operator|->
name|tw_cli_callback
operator|=
name|callback
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1101
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"get_param failed"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
condition|)
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_set_param  * Description:		Set a firmware parameter.  *  * Input:		ctlr		-- ptr to per ctlr structure  *			table_id	-- parameter table #  *			param_id	-- index of the parameter in the table  *			param_size	-- size of the parameter in bytes  *			callback	-- ptr to function, if any, to be called  *					back on completion; TW_CL_NULL if no callback.  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_set_param
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|,
name|TW_INT32
name|table_id
parameter_list|,
name|TW_INT32
name|param_id
parameter_list|,
name|TW_INT32
name|param_size
parameter_list|,
name|TW_VOID
modifier|*
name|data
parameter_list|,
name|TW_VOID
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|)
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|union
name|tw_cl_command_7k
modifier|*
name|cmd
decl_stmt|;
name|struct
name|tw_cl_param_9k
modifier|*
name|param
init|=
name|TW_CL_NULL
decl_stmt|;
name|TW_INT32
name|error
init|=
name|TW_OSL_EBUSY
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
goto|goto
name|out
goto|;
comment|/* Make sure this is the only CL internal request at this time. */
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
condition|)
block|{
name|error
operator|=
name|TW_OSL_EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|req
operator|->
name|data
operator|=
name|ctlr
operator|->
name|internal_req_data
expr_stmt|;
name|req
operator|->
name|data_phys
operator|=
name|ctlr
operator|->
name|internal_req_data_phys
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|TW_CLI_SECTOR_SIZE
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
comment|/* Initialize memory to send data using. */
name|param
operator|=
operator|(
expr|struct
name|tw_cl_param_9k
operator|*
operator|)
operator|(
name|req
operator|->
name|data
operator|)
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|param
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tw_cl_param_9k
argument_list|)
operator|-
literal|1
operator|+
name|param_size
argument_list|)
expr_stmt|;
comment|/* Build the cmd pkt. */
name|cmd
operator|=
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|)
expr_stmt|;
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|sgl_off__opcode
operator|=
name|BUILD_SGL_OFF__OPCODE
argument_list|(
literal|2
argument_list|,
name|TWA_FW_CMD_SET_PARAM
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|request_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|host_id__unit
operator|=
name|BUILD_HOST_ID__UNIT
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|param_count
operator|=
name|TW_CL_SWAP16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP64
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
operator|+
literal|3
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd
operator|->
name|param
operator|.
name|sgl
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
operator|+
literal|2
expr_stmt|;
block|}
comment|/* Specify which parameter we want to set. */
name|param
operator|->
name|table_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|table_id
operator||
name|TWA_9K_PARAM_DESCRIPTOR
argument_list|)
expr_stmt|;
name|param
operator|->
name|parameter_id
operator|=
call|(
name|TW_UINT8
call|)
argument_list|(
name|param_id
argument_list|)
expr_stmt|;
name|param
operator|->
name|parameter_size_bytes
operator|=
name|TW_CL_SWAP16
argument_list|(
name|param_size
argument_list|)
expr_stmt|;
name|tw_osl_memcpy
argument_list|(
name|param
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|param_size
argument_list|)
expr_stmt|;
comment|/* Submit the command. */
if|if
condition|(
name|callback
operator|==
name|TW_CL_NULL
condition|)
block|{
comment|/* There's no call back;  wait till the command completes. */
name|error
operator|=
name|tw_cli_submit_and_poll_request
argument_list|(
name|req
argument_list|,
name|TW_CLI_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|TW_OSL_ETIMEDOUT
condition|)
comment|/* Clean-up done by tw_cli_submit_and_poll_request. */
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|param
operator|.
name|status
operator|)
condition|)
block|{
name|tw_cli_create_ctlr_event
argument_list|(
name|ctlr
argument_list|,
name|TW_CL_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
operator|&
operator|(
name|req
operator|->
name|cmd_pkt
operator|->
name|cmd_hdr
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There's a call back.  Simply submit the command. */
name|req
operator|->
name|tw_cli_callback
operator|=
name|callback
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1102
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"set_param failed"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
condition|)
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_submit_and_poll_request  * Description:		Sends down a firmware cmd, and waits for the completion  *			in a tight loop.  *  * Input:		req	-- ptr to request pkt  *			timeout -- max # of seconds to wait before giving up  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_submit_and_poll_request
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|,
name|TW_UINT32
name|timeout
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
name|req
operator|->
name|ctlr
decl_stmt|;
name|TW_TIME
name|end_time
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* 	 * If the cmd queue is full, tw_cli_submit_cmd will queue this 	 * request in the pending queue, since this is an internal request. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1103
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Failed to start internal request"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Poll for the response until the command gets completed, or there's 	 * a timeout. 	 */
name|end_time
operator|=
name|tw_osl_get_local_time
argument_list|()
operator|+
name|timeout
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|req
operator|->
name|error_code
operator|)
condition|)
comment|/* 			 * This will take care of completion due to a reset, 			 * or a failure in tw_cli_submit_pending_queue. 			 * The caller should do the clean-up. 			 */
return|return
operator|(
name|error
operator|)
return|;
comment|/* See if the command completed. */
name|tw_cli_process_resp_intr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_BUSY
operator|)
operator|&&
operator|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_PENDING
operator|)
condition|)
return|return
operator|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_COMPLETE
operator|)
return|;
block|}
do|while
condition|(
name|tw_osl_get_local_time
argument_list|()
operator|<=
name|end_time
condition|)
do|;
comment|/* Time out! */
name|tw_cl_create_event
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x1104
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Internal request timed out"
argument_list|,
literal|"request = %p"
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * We will reset the controller only if the request has already been 	 * submitted, so as to not lose the request packet.  If a busy request 	 * timed out, the reset will take care of freeing resources.  If a 	 * pending request timed out, we will free resources for that request, 	 * right here, thereby avoiding a reset.  So, the caller is expected 	 * to NOT cleanup when TW_OSL_ETIMEDOUT is returned. 	 */
comment|/* 	 * We have to make sure that this timed out request, if it were in the 	 * pending queue, doesn't get submitted while we are here, from 	 * tw_cli_submit_pending_queue.  There could be a race in that case. 	 * Need to revisit. 	 */
if|if
condition|(
name|req
operator|->
name|state
operator|!=
name|TW_CLI_REQ_STATE_PENDING
condition|)
name|tw_cl_reset_ctlr
argument_list|(
name|ctlr
operator|->
name|ctlr_handle
argument_list|)
expr_stmt|;
else|else
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|3
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Removing request from pending queue"
argument_list|)
expr_stmt|;
comment|/* 		 * Request was never submitted.  Clean up.  Note that we did 		 * not do a reset.  So, we have to remove the request ourselves 		 * from the pending queue (as against tw_cli_drain_pendinq_queue 		 * taking care of it). 		 */
name|tw_cli_req_q_remove_item
argument_list|(
name|req
argument_list|,
name|TW_CLI_PENDING_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|data
condition|)
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TW_OSL_ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cl_reset_ctlr  * Description:		Soft resets and then initializes the controller;  *			drains any incomplete requests.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cl_reset_ctlr
parameter_list|(
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
parameter_list|)
block|{
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|tw_cli_ctlr_context
operator|*
operator|)
operator|(
name|ctlr_handle
operator|->
name|cl_ctlr_ctxt
operator|)
decl_stmt|;
name|TW_INT32
name|reset_attempt
init|=
literal|1
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_RESET_IN_PROGRESS
expr_stmt|;
comment|/* 	 * Error back all requests in the complete, busy, and pending queues. 	 * If any request is already on its way to getting submitted, it's in 	 * none of these queues and so, will not be completed.  That request 	 * will continue its course and get submitted to the controller after 	 * the reset is done (and io_lock is released). 	 */
name|tw_cli_dbg_printf
argument_list|(
literal|2
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Draining all queues following reset"
argument_list|)
expr_stmt|;
name|tw_cli_drain_complete_queue
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|tw_cli_drain_busy_queue
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|tw_cli_drain_pending_queue
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|tw_cli_disable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Soft reset the controller. */
name|try_reset
label|:
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_soft_reset
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x1105
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller reset failed"
argument_list|,
literal|"error = %d; attempt %d"
argument_list|,
name|error
argument_list|,
name|reset_attempt
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset_attempt
operator|<=
name|TW_CLI_MAX_RESET_ATTEMPTS
condition|)
goto|goto
name|try_reset
goto|;
else|else
goto|goto
name|out
goto|;
block|}
comment|/* Re-establish logical connection with the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_init_connection
argument_list|(
name|ctlr
argument_list|,
call|(
name|TW_UINT16
call|)
argument_list|(
name|ctlr
operator|->
name|max_simult_reqs
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|,
name|TW_CL_NULL
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x1106
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't initialize connection after reset"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x1107
argument_list|,
literal|0x3
argument_list|,
name|TW_CL_SEVERITY_INFO_STRING
argument_list|,
literal|"Controller reset done!"
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|out
label|:
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_RESET_IN_PROGRESS
expr_stmt|;
comment|/* 	 * Enable interrupts, and also clear attention and response interrupts. 	 */
name|tw_cli_enable_interrupts
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Request for a bus re-scan. */
if|if
condition|(
operator|!
name|error
condition|)
name|tw_osl_scan_bus
argument_list|(
name|ctlr_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_soft_reset  * Description:		Does the actual soft reset.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_soft_reset
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|tw_cl_ctlr_handle
modifier|*
name|ctlr_handle
init|=
name|ctlr
operator|->
name|ctlr_handle
decl_stmt|;
name|TW_UINT32
name|status_reg
decl_stmt|;
name|TW_UINT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|1
argument_list|,
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x1108
argument_list|,
literal|0x3
argument_list|,
name|TW_CL_SEVERITY_INFO_STRING
argument_list|,
literal|"Resetting controller..."
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* Don't let any new commands get submitted to the controller. */
name|tw_osl_get_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|TW_CLI_SOFT_RESET
argument_list|(
name|ctlr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_X
operator|)
operator|||
operator|(
name|ctlr
operator|->
name|device_id
operator|==
name|TW_CL_DEVICE_ID_9K_E
operator|)
condition|)
block|{
comment|/* 		 * There's a hardware bug in the G133 ASIC, which can lead to 		 * PCI parity errors and hangs, if the host accesses any 		 * registers when the firmware is resetting the hardware, as 		 * part of a hard/soft reset.  The window of time when the 		 * problem can occur is about 10 ms.  Here, we will handshake 		 * with the firmware to find out when the firmware is pulling 		 * down the hardware reset pin, and wait for about 500 ms to 		 * make sure we don't access any hardware registers (for 		 * polling) during that window. 		 */
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_RESET_PHASE1_IN_PROGRESS
expr_stmt|;
while|while
condition|(
name|tw_cli_find_response
argument_list|(
name|ctlr
argument_list|,
name|TWA_RESET_PHASE1_NOTIFICATION_RESPONSE
argument_list|)
operator|!=
name|TW_OSL_ESUCCESS
condition|)
name|tw_osl_delay
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tw_osl_delay
argument_list|(
name|TWA_RESET_PHASE1_WAIT_TIME_MS
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_RESET_PHASE1_IN_PROGRESS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_poll_status
argument_list|(
name|ctlr
argument_list|,
name|TWA_STATUS_MICROCONTROLLER_READY
operator||
name|TWA_STATUS_ATTENTION_INTERRUPT
argument_list|,
name|TW_CLI_RESET_TIMEOUT_PERIOD
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x1109
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Micro-ctlr not ready/No attn intr after reset"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|TW_CLI_WRITE_CONTROL_REGISTER
argument_list|(
name|ctlr_handle
argument_list|,
name|TWA_CONTROL_CLEAR_ATTENTION_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_drain_response_queue
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x110A
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't drain response queue after reset"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tw_osl_free_lock
argument_list|(
name|ctlr_handle
argument_list|,
name|ctlr
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_drain_aen_queue
argument_list|(
name|ctlr
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_FALSE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_ERROR
argument_list|,
literal|0x110B
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Can't drain AEN queue after reset"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_find_aen
argument_list|(
name|ctlr
argument_list|,
name|TWA_AEN_SOFT_RESET
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x110C
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Reset not reported by controller"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|status_reg
operator|=
name|TW_CLI_READ_STATUS_REGISTER
argument_list|(
name|ctlr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|TW_CLI_STATUS_ERRORS
argument_list|(
name|status_reg
argument_list|)
operator|)
operator|||
operator|(
name|error
operator|=
name|tw_cli_check_ctlr_state
argument_list|(
name|ctlr
argument_list|,
name|status_reg
argument_list|)
operator|)
condition|)
block|{
name|tw_cl_create_event
argument_list|(
name|ctlr_handle
argument_list|,
name|TW_CL_TRUE
argument_list|,
name|TW_CL_MESSAGE_SOURCE_COMMON_LAYER_EVENT
argument_list|,
literal|0x110D
argument_list|,
literal|0x1
argument_list|,
name|TW_CL_SEVERITY_ERROR_STRING
argument_list|,
literal|"Controller errors detected after reset"
argument_list|,
literal|"error = %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|TW_OSL_ESUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_send_scsi_cmd  * Description:		Sends down a scsi cmd to fw.  *  * Input:		req	-- ptr to request pkt  *			cmd	-- opcode of scsi cmd to send  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_send_scsi_cmd
parameter_list|(
name|struct
name|tw_cli_req_context
modifier|*
name|req
parameter_list|,
name|TW_INT32
name|cmd
parameter_list|)
block|{
name|struct
name|tw_cl_command_packet
modifier|*
name|cmdpkt
decl_stmt|;
name|struct
name|tw_cl_command_9k
modifier|*
name|cmd9k
decl_stmt|;
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|ctlr
operator|=
name|req
operator|->
name|ctlr
expr_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
comment|/* Make sure this is the only CL internal request at this time. */
if|if
condition|(
name|ctlr
operator|->
name|state
operator|&
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
condition|)
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
name|ctlr
operator|->
name|state
operator||=
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|req
operator|->
name|data
operator|=
name|ctlr
operator|->
name|internal_req_data
expr_stmt|;
name|req
operator|->
name|data_phys
operator|=
name|ctlr
operator|->
name|internal_req_data_phys
expr_stmt|;
name|tw_osl_memzero
argument_list|(
name|req
operator|->
name|data
argument_list|,
name|TW_CLI_SECTOR_SIZE
argument_list|)
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|TW_CLI_SECTOR_SIZE
expr_stmt|;
comment|/* Build the cmd pkt. */
name|cmdpkt
operator|=
name|req
operator|->
name|cmd_pkt
expr_stmt|;
name|cmdpkt
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd9k
operator|=
operator|&
operator|(
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|)
expr_stmt|;
name|cmd9k
operator|->
name|res__opcode
operator|=
name|BUILD_RES__OPCODE
argument_list|(
literal|0
argument_list|,
name|TWA_FW_CMD_EXECUTE_SCSI
argument_list|)
expr_stmt|;
name|cmd9k
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd9k
operator|->
name|lun_l4__req_id
operator|=
name|TW_CL_SWAP16
argument_list|(
name|req
operator|->
name|request_id
argument_list|)
expr_stmt|;
name|cmd9k
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cmd9k
operator|->
name|sgl_offset
operator|=
literal|16
expr_stmt|;
comment|/* offset from end of hdr = max cdb len */
name|cmd9k
operator|->
name|lun_h4__sgl_entries
operator|=
name|TW_CL_SWAP16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd9k
operator|->
name|sg_list
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP64
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
name|cmd9k
operator|->
name|sg_list
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd9k
operator|->
name|sg_list
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|data_phys
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
operator|(
name|cmd9k
operator|->
name|sg_list
operator|)
operator|)
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|req
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|cmd9k
operator|->
name|cdb
index|[
literal|0
index|]
operator|=
operator|(
name|TW_UINT8
operator|)
name|cmd
expr_stmt|;
name|cmd9k
operator|->
name|cdb
index|[
literal|4
index|]
operator|=
literal|128
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_submit_cmd
argument_list|(
name|req
argument_list|)
operator|)
condition|)
if|if
condition|(
name|error
operator|!=
name|TW_OSL_EBUSY
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|1
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Failed to start SCSI command"
argument_list|,
literal|"request = %p, error = %d"
argument_list|,
name|req
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|TW_OSL_EIO
operator|)
return|;
block|}
return|return
operator|(
name|TW_OSL_ESUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_get_aen  * Description:		Sends down a Request Sense cmd to fw to fetch an AEN.  *  * Input:		ctlr	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|TW_INT32
name|tw_cli_get_aen
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|tw_cli_req_context
modifier|*
name|req
decl_stmt|;
name|TW_INT32
name|error
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|4
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|req
operator|=
name|tw_cli_get_request
argument_list|(
name|ctlr
argument_list|)
operator|)
operator|==
name|TW_CL_NULL
condition|)
return|return
operator|(
name|TW_OSL_EBUSY
operator|)
return|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_INTERNAL
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|TW_CLI_REQ_FLAGS_9K
expr_stmt|;
name|req
operator|->
name|tw_cli_callback
operator|=
name|tw_cli_aen_callback
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tw_cli_send_scsi_cmd
argument_list|(
name|req
argument_list|,
literal|0x03
comment|/* REQUEST_SENSE */
argument_list|)
operator|)
condition|)
block|{
name|tw_cli_dbg_printf
argument_list|(
literal|1
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"Could not send SCSI command"
argument_list|,
literal|"request = %p, error = %d"
argument_list|,
name|req
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|data
condition|)
name|ctlr
operator|->
name|state
operator|&=
operator|~
name|TW_CLI_CTLR_STATE_INTERNAL_REQ_BUSY
expr_stmt|;
name|tw_cli_req_q_insert_tail
argument_list|(
name|req
argument_list|,
name|TW_CLI_FREE_Q
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	tw_cli_fill_sg_list  * Description:		Fills in the scatter/gather list.  *  * Input:		ctlr	-- ptr to per ctlr structure  *			sgl_src	-- ptr to fill the sg list from  *			sgl_dest-- ptr to sg list  *			nsegments--# of segments  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|TW_VOID
name|tw_cli_fill_sg_list
parameter_list|(
name|struct
name|tw_cli_ctlr_context
modifier|*
name|ctlr
parameter_list|,
name|TW_VOID
modifier|*
name|sgl_src
parameter_list|,
name|TW_VOID
modifier|*
name|sgl_dest
parameter_list|,
name|TW_INT32
name|num_sgl_entries
parameter_list|)
block|{
name|TW_INT32
name|i
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"entered"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_ADDRESSES
condition|)
block|{
name|struct
name|tw_cl_sg_desc64
modifier|*
name|sgl_s
init|=
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
name|sgl_src
decl_stmt|;
name|struct
name|tw_cl_sg_desc64
modifier|*
name|sgl_d
init|=
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
name|sgl_dest
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"64 bit addresses"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sgl_entries
condition|;
name|i
operator|++
control|)
block|{
name|sgl_d
index|[
name|i
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP64
argument_list|(
name|sgl_s
operator|->
name|address
argument_list|)
expr_stmt|;
name|sgl_d
index|[
name|i
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|sgl_s
operator|->
name|length
argument_list|)
expr_stmt|;
name|sgl_s
operator|++
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|flags
operator|&
name|TW_CL_64BIT_SG_LENGTH
condition|)
name|sgl_s
operator|=
operator|(
expr|struct
name|tw_cl_sg_desc64
operator|*
operator|)
operator|(
operator|(
operator|(
name|TW_INT8
operator|*
operator|)
operator|(
name|sgl_s
operator|)
operator|)
operator|+
literal|4
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|tw_cl_sg_desc32
modifier|*
name|sgl_s
init|=
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
name|sgl_src
decl_stmt|;
name|struct
name|tw_cl_sg_desc32
modifier|*
name|sgl_d
init|=
operator|(
expr|struct
name|tw_cl_sg_desc32
operator|*
operator|)
name|sgl_dest
decl_stmt|;
name|tw_cli_dbg_printf
argument_list|(
literal|10
argument_list|,
name|ctlr
operator|->
name|ctlr_handle
argument_list|,
name|tw_osl_cur_func
argument_list|()
argument_list|,
literal|"32 bit addresses"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sgl_entries
condition|;
name|i
operator|++
control|)
block|{
name|sgl_d
index|[
name|i
index|]
operator|.
name|address
operator|=
name|TW_CL_SWAP32
argument_list|(
name|sgl_s
index|[
name|i
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
name|sgl_d
index|[
name|i
index|]
operator|.
name|length
operator|=
name|TW_CL_SWAP32
argument_list|(
name|sgl_s
index|[
name|i
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

