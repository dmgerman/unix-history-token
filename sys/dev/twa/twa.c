begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-04 3ware, Inc.  * Copyright (c) 2000 Michael Smith  * Copyright (c) 2000 BSDi  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_comment
comment|/*  * 3ware driver for 9000 series storage controllers.  *  * Author: Vinod Kashyap  */
end_comment

begin_include
include|#
directive|include
file|<dev/twa/twa_includes.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TWA_FLASH_FIRMWARE
end_ifdef

begin_function_decl
specifier|static
name|int
name|twa_flash_firmware
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_hard_reset
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TWA_FLASH_FIRMWARE */
end_comment

begin_function_decl
specifier|static
name|int
name|twa_init_ctlr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|twa_get_param
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|parameter_id
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_set_param
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|int
name|param_size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_init_connection
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|message_credits
parameter_list|,
name|u_int32_t
name|set_features
parameter_list|,
name|u_int16_t
name|current_fw_srl
parameter_list|,
name|u_int16_t
name|current_fw_arch_id
parameter_list|,
name|u_int16_t
name|current_fw_branch
parameter_list|,
name|u_int16_t
name|current_fw_build
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_srl
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_arch_id
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_branch
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_build
parameter_list|,
name|u_int32_t
modifier|*
name|init_connect_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_wait_request
parameter_list|(
name|struct
name|twa_request
modifier|*
name|req
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_immediate_request
parameter_list|(
name|struct
name|twa_request
modifier|*
name|req
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_done
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_drain_pending_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_drain_complete_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_wait_status
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_drain_response_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_check_ctlr_state
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status_reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_soft_reset
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_host_intr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_attention_intr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_command_intr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_fetch_aen
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_aen_callback
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_enqueue_aen
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twa_command_header
modifier|*
name|cmd_hdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_drain_aen_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twa_find_aen
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twa_panic
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int8_t
modifier|*
name|reason
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Function name:	twa_setup  * Description:		Initializes driver data structures for the controller.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|int
name|twa_setup
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_event_packet
modifier|*
name|aen_queue
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize request queues. */
name|twa_initq_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twa_initq_busy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twa_initq_pending
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twa_initq_complete
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twa_alloc_req_pkts
argument_list|(
name|sc
argument_list|,
name|TWA_Q_LENGTH
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Failed to allocate request packets.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Allocate memory for the AEN queue. */
if|if
condition|(
operator|(
name|aen_queue
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
operator|*
name|TWA_Q_LENGTH
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*  		 * This should not cause us to return error.  We will only be 		 * unable to support AEN's.  But then, we will have to check 		 * time and again to see if we can support AEN's, if we 		 * continue.  So, we will just return error. 		 */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not allocate memory for AEN queue.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* any unfreed memory will be freed by twa_free */
block|}
comment|/* Initialize the aen queue. */
name|bzero
argument_list|(
name|aen_queue
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
operator|*
name|TWA_Q_LENGTH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TWA_Q_LENGTH
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|twa_aen_queue
index|[
name|i
index|]
operator|=
operator|&
operator|(
name|aen_queue
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* 	 * Disable interrupts from the card. 	 * Interrupts will be enabled back in twa_intrhook. 	 */
name|twa_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|twa_init_ctlr
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
comment|/* Soft reset the controller, and try one more time. */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller initialization failed. Retrying...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_soft_reset
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller soft reset failed.\n"
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|twa_init_ctlr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TWA_FLASH_FIRMWARE
end_ifdef

begin_comment
comment|/*  * Function name:	twa_flash_firmware  * Description:		Flashes bundled firmware image onto controller.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_flash_firmware
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|struct
name|twa_command_download_firmware
modifier|*
name|cmd
decl_stmt|;
name|u_int32_t
name|fw_img_chunk_size
decl_stmt|;
name|u_int32_t
name|this_chunk_size
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|remaining_img_size
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* No free request packets available.  Can't proceed. */
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
comment|/* Allocate sufficient memory to hold a chunk of the firmware image. */
name|fw_img_chunk_size
operator|=
operator|(
operator|(
name|twa_fw_img_size
operator|/
name|NUM_FW_IMAGE_CHUNKS
operator|)
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_data
operator|=
name|malloc
argument_list|(
name|fw_img_chunk_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not allocate memory for firmware image.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|remaining_img_size
operator|=
name|twa_fw_img_size
expr_stmt|;
name|cmd
operator|=
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|download_fw
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_FW_IMAGE_CHUNKS
condition|;
name|i
operator|++
control|)
block|{
comment|/* Build a cmd pkt for downloading firmware. */
name|bzero
argument_list|(
name|tr
operator|->
name|tr_command
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_command_packet
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|->
name|opcode
operator|=
name|TWA_OP_DOWNLOAD_FIRMWARE
expr_stmt|;
name|cmd
operator|->
name|sgl_offset
operator|=
literal|2
expr_stmt|;
comment|/* offset in dwords, to the beginning of sg list */
name|cmd
operator|->
name|size
operator|=
literal|2
expr_stmt|;
comment|/* this field will be updated at data map time */
name|cmd
operator|->
name|request_id
operator|=
name|tr
operator|->
name|tr_request_id
expr_stmt|;
name|cmd
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|=
literal|8
expr_stmt|;
comment|/* prom image */
if|if
condition|(
name|i
operator|!=
operator|(
name|NUM_FW_IMAGE_CHUNKS
operator|-
literal|1
operator|)
condition|)
name|this_chunk_size
operator|=
name|fw_img_chunk_size
expr_stmt|;
else|else
comment|/* last chunk */
name|this_chunk_size
operator|=
name|remaining_img_size
expr_stmt|;
name|remaining_img_size
operator|-=
name|this_chunk_size
expr_stmt|;
name|bcopy
argument_list|(
name|twa_fw_img
operator|+
operator|(
name|i
operator|*
name|fw_img_chunk_size
operator|)
argument_list|,
name|tr
operator|->
name|tr_data
argument_list|,
name|this_chunk_size
argument_list|)
expr_stmt|;
comment|/* 		 * The next line will effect only the last chunk. 		 */
name|tr
operator|->
name|tr_length
operator|=
operator|(
name|this_chunk_size
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator||=
name|TWA_CMD_DATA_OUT
expr_stmt|;
name|error
operator|=
name|twa_immediate_request
argument_list|(
name|tr
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Firmware flash request could not be posted. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* clean-up done by twa_immediate_request */
break|break;
block|}
name|error
operator|=
name|cmd
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|(
name|NUM_FW_IMAGE_CHUNKS
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
operator|)
operator|!=
name|TWA_ERROR_MORE_DATA
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|error
argument_list|)
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|err_specific_desc
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Firmware flash request failed. Intermediate error = 0x%x, i = %x\n"
argument_list|,
name|cmd
operator|->
name|status
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Hard reset the controller, so that it doesn't wait for the remaining chunks. */
name|twa_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
comment|/* last chunk */
if|if
condition|(
name|error
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|)
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|err_specific_desc
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Firmware flash request failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Hard reset the controller, so that it doesn't wait for more chunks. */
name|twa_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for */
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|tr
condition|)
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_hard_reset  * Description:		Hard reset the controller.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_hard_reset
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|struct
name|twa_command_reset_firmware
modifier|*
name|cmd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
comment|/* Build a cmd pkt for sending down the hard reset command. */
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|=
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|reset_fw
operator|)
expr_stmt|;
name|cmd
operator|->
name|opcode
operator|=
name|TWA_OP_RESET_FIRMWARE
expr_stmt|;
name|cmd
operator|->
name|size
operator|=
literal|2
expr_stmt|;
comment|/* this field will be updated at data map time */
name|cmd
operator|->
name|request_id
operator|=
name|tr
operator|->
name|tr_request_id
expr_stmt|;
name|cmd
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|=
literal|0
expr_stmt|;
comment|/* don't reload FPGA logic */
name|tr
operator|->
name|tr_data
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|twa_immediate_request
argument_list|(
name|tr
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Hard reset request could not be posted. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* clean-up done by twa_immediate_request */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|status
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|cmd
operator|->
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|)
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|err_specific_desc
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Hard reset request failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tr
condition|)
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TWA_FLASH_FIRMWARE */
end_comment

begin_comment
comment|/*  * Function name:	twa_init_ctlr  * Description:		Establishes a logical connection with the controller.  *			If bundled with firmware, determines whether or not  *			to flash firmware, based on arch_id, fw SRL (Spec.  *			Revision Level), branch& build #'s.  Also determines  *			whether or not the driver is compatible with the  *			firmware on the controller, before proceeding to work  *			with it.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_init_ctlr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int16_t
name|fw_on_ctlr_srl
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|fw_on_ctlr_arch_id
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|fw_on_ctlr_branch
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|fw_on_ctlr_build
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|init_connect_result
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|TWA_FLASH_FIRMWARE
name|int8_t
name|fw_flashed
init|=
name|FALSE
decl_stmt|;
name|int8_t
name|fw_flash_failed
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
comment|/* TWA_FLASH_FIRMWARE */
name|twa_dbg_dprint_enter
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Wait for the controller to become ready. */
if|if
condition|(
name|twa_wait_status
argument_list|(
name|sc
argument_list|,
name|TWA_STATUS_MICROCONTROLLER_READY
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Microcontroller not ready.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Drain the response queue. */
if|if
condition|(
name|twa_drain_response_queue
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't drain response queue.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Establish a logical connection with the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|twa_init_connection
argument_list|(
name|sc
argument_list|,
name|TWA_INIT_MESSAGE_CREDITS
argument_list|,
name|TWA_EXTENDED_INIT_CONNECT
argument_list|,
name|TWA_CURRENT_FW_SRL
argument_list|,
name|TWA_9000_ARCH_ID
argument_list|,
name|TWA_CURRENT_FW_BRANCH
argument_list|,
name|TWA_CURRENT_FW_BUILD
argument_list|,
operator|&
name|fw_on_ctlr_srl
argument_list|,
operator|&
name|fw_on_ctlr_arch_id
argument_list|,
operator|&
name|fw_on_ctlr_branch
argument_list|,
operator|&
name|fw_on_ctlr_build
argument_list|,
operator|&
name|init_connect_result
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't initialize connection in current mode.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TWA_FLASH_FIRMWARE
if|if
condition|(
operator|(
name|init_connect_result
operator|&
name|TWA_BUNDLED_FW_SAFE_TO_FLASH
operator|)
operator|&&
operator|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_RECOMMENDS_FLASH
operator|)
condition|)
block|{
comment|/* 		 * The bundled firmware is safe to flash, and the firmware 		 * on the controller recommends a flash.  So, flash! 		 */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Flashing bundled firmware...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_flash_firmware
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|fw_flash_failed
operator|=
name|TRUE
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Unable to flash bundled firmware.\n"
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Will see if possible to work with firmware on controller...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Successfully flashed bundled firmware.\n"
argument_list|)
expr_stmt|;
name|fw_flashed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fw_flashed
condition|)
block|{
comment|/* The firmware was flashed.  Have the new image loaded */
name|error
operator|=
name|twa_hard_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not reset controller after flash!\n"
argument_list|)
expr_stmt|;
else|else
comment|/* Go through initialization again. */
name|error
operator|=
name|twa_init_ctlr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * If hard reset of controller failed, we need to return. 		 * Otherwise, the above recursive call to twa_init_ctlr will 		 * have completed the rest of the initialization (starting 		 * from twa_drain_aen_queue below).  Don't do it again. 		 * Just return. 		 */
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
endif|#
directive|endif
comment|/* TWA_FLASH_FIRMWARE */
block|{
comment|/* 		 * Either we are not bundled with a firmware image, or 		 * the bundled firmware is not safe to flash, 		 * or flash failed for some reason.  See if we can at 		 * least work with the firmware on the controller in the 		 * current mode. 		 */
if|if
condition|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_COMPATIBLE
condition|)
block|{
comment|/* Yes, we can.  Make note of the operating mode. */
name|sc
operator|->
name|working_srl
operator|=
name|TWA_CURRENT_FW_SRL
expr_stmt|;
name|sc
operator|->
name|working_branch
operator|=
name|TWA_CURRENT_FW_BRANCH
expr_stmt|;
name|sc
operator|->
name|working_build
operator|=
name|TWA_CURRENT_FW_BUILD
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No, we can't.  See if we can at least work with 			 * it in the base mode.  We should never come here 			 * if firmware has just been flashed. 			 */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Driver/Firmware mismatch.  Negotiating for base level...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_init_connection
argument_list|(
name|sc
argument_list|,
name|TWA_INIT_MESSAGE_CREDITS
argument_list|,
name|TWA_EXTENDED_INIT_CONNECT
argument_list|,
name|TWA_BASE_FW_SRL
argument_list|,
name|TWA_9000_ARCH_ID
argument_list|,
name|TWA_BASE_FW_BRANCH
argument_list|,
name|TWA_BASE_FW_BUILD
argument_list|,
operator|&
name|fw_on_ctlr_srl
argument_list|,
operator|&
name|fw_on_ctlr_arch_id
argument_list|,
operator|&
name|fw_on_ctlr_branch
argument_list|,
operator|&
name|fw_on_ctlr_build
argument_list|,
operator|&
name|init_connect_result
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't initialize connection in base mode.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|init_connect_result
operator|&
name|TWA_CTLR_FW_COMPATIBLE
operator|)
condition|)
block|{
comment|/* 				 * The firmware on the controller is not even 				 * compatible with our base mode.  We cannot 				 * work with it.  Bail... 				 */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Incompatible firmware on controller\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWA_FLASH_FIRMWARE
if|if
condition|(
name|fw_flash_failed
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"...and could not flash bundled firmware.\n"
argument_list|)
expr_stmt|;
else|else
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"...and bundled firmware not safe to flash.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TWA_FLASH_FIRMWARE */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We can work with this firmware, but only in base mode. */
name|sc
operator|->
name|working_srl
operator|=
name|TWA_BASE_FW_SRL
expr_stmt|;
name|sc
operator|->
name|working_branch
operator|=
name|TWA_BASE_FW_BRANCH
expr_stmt|;
name|sc
operator|->
name|working_build
operator|=
name|TWA_BASE_FW_BUILD
expr_stmt|;
name|sc
operator|->
name|twa_operating_mode
operator|=
name|TWA_BASE_MODE
expr_stmt|;
block|}
block|}
comment|/* Drain the AEN queue */
if|if
condition|(
name|twa_drain_aen_queue
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/*  		 * We will just print that we couldn't drain the AEN queue. 		 * There's no need to bail out. 		 */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't drain AEN queue.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Set controller state to initialized. */
name|sc
operator|->
name|twa_state
operator|&=
operator|~
name|TWA_STATE_SHUTDOWN
expr_stmt|;
name|twa_dbg_dprint_exit
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_deinit_ctlr  * Description:		Close logical connection with the controller.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|int
name|twa_deinit_ctlr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Mark the controller as shutting down, 	 * and disable any further interrupts. 	 */
name|sc
operator|->
name|twa_state
operator||=
name|TWA_STATE_SHUTDOWN
expr_stmt|;
name|twa_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Let the controller know that we are going down. */
return|return
operator|(
name|twa_init_connection
argument_list|(
name|sc
argument_list|,
name|TWA_SHUTDOWN_MESSAGE_CREDITS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_interrupt  * Description:		Interrupt handler.  Determines the kind of interrupt,  *			and calls the appropriate handler.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_interrupt
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status_reg
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|5
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Collect current interrupt status. */
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twa_check_ctlr_state
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
condition|)
return|return;
comment|/* Dispatch based on the kind of interrupt. */
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_HOST_INTERRUPT
condition|)
name|twa_host_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_ATTENTION_INTERRUPT
condition|)
name|twa_attention_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_COMMAND_INTERRUPT
condition|)
name|twa_command_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_RESPONSE_INTERRUPT
condition|)
name|twa_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_ioctl  * Description:		ioctl handler.  *  * Input:		sc	-- ptr to per ctlr structure  *			cmd	-- ioctl cmd  *			buf	-- ptr to buffer in kernel memory, which is  *				   a copy of the input buffer in user-space  * Output:		buf	-- ptr to buffer in kernel memory, which will  *				   be copied of the output buffer in user-space  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|int
name|twa_ioctl
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|twa_ioctl_9k
modifier|*
name|user_buf
init|=
operator|(
expr|struct
name|twa_ioctl_9k
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|twa_event_packet
name|event_buf
decl_stmt|;
name|int32_t
name|event_index
decl_stmt|;
name|int32_t
name|start_index
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TWA_IOCTL_FIRMWARE_PASS_THROUGH
case|:
block|{
name|struct
name|twa_command_packet
modifier|*
name|cmdpkt
decl_stmt|;
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|u_int32_t
name|data_buf_size_adjusted
decl_stmt|;
name|twa_dbg_dprint
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Firmware PassThru"
argument_list|)
expr_stmt|;
comment|/* Get a request packet */
while|while
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* 			 * No free request packets available.  Sleep until 			 * one becomes available. 			 */
name|tsleep
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|twa_wait_timeout
operator|)
argument_list|,
name|PPAUSE
argument_list|,
literal|"twioctl"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure that the data buffer sent to firmware is a  		 * 512 byte multiple in size. 		 */
name|data_buf_size_adjusted
operator|=
operator|(
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|buffer_length
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_length
operator|=
name|data_buf_size_adjusted
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_data
operator|=
name|malloc
argument_list|(
name|data_buf_size_adjusted
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not alloc mem for fw_passthru data_buf.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fw_passthru_done
goto|;
block|}
comment|/* Copy the payload. */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|user_buf
operator|->
name|pdata
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|tr
operator|->
name|tr_data
operator|)
argument_list|,
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|buffer_length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Could not copyin fw_passthru data_buf.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fw_passthru_done
goto|;
block|}
name|tr
operator|->
name|tr_flags
operator||=
name|TWA_CMD_DATA_IN
operator||
name|TWA_CMD_DATA_OUT
expr_stmt|;
block|}
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_IOCTL
expr_stmt|;
name|cmdpkt
operator|=
name|tr
operator|->
name|tr_command
expr_stmt|;
comment|/* Copy the command packet. */
name|bcopy
argument_list|(
operator|&
operator|(
name|user_buf
operator|->
name|twa_cmd_pkt
operator|)
argument_list|,
name|cmdpkt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_command_packet
argument_list|)
argument_list|)
expr_stmt|;
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|request_id
operator|=
name|tr
operator|->
name|tr_request_id
expr_stmt|;
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"cmd_pkt_7k = %x %x %x %x %x %x %x"
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|opcode
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|sgl_offset
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|size
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|request_id
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|unit
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|status
argument_list|,
name|cmdpkt
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* Send down the request, and wait for it to complete. */
if|if
condition|(
operator|(
name|error
operator|=
name|twa_wait_request
argument_list|(
name|tr
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"fw_passthru request failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
break|break;
comment|/* clean-up done by twa_wait_request */
goto|goto
name|fw_passthru_done
goto|;
block|}
comment|/* Copy the command packet back into user space. */
name|bcopy
argument_list|(
name|cmdpkt
argument_list|,
operator|&
operator|(
name|user_buf
operator|->
name|twa_cmd_pkt
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_command_packet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there was a payload, copy it back too. */
if|if
condition|(
name|tr
operator|->
name|tr_length
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|buffer_length
argument_list|)
expr_stmt|;
name|fw_passthru_done
label|:
comment|/* Free resources. */
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TWA_IOCTL_SCAN_BUS
case|:
comment|/* Request CAM for a bus scan. */
name|twa_request_bus_scan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWA_IOCTL_GET_FIRST_EVENT
case|:
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get First Event"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_wrapped
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_OVERFLOW
expr_stmt|;
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|event_index
operator|=
name|sc
operator|->
name|twa_aen_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_head
operator|==
name|sc
operator|->
name|twa_aen_tail
condition|)
block|{
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|event_index
operator|=
name|sc
operator|->
name|twa_aen_tail
expr_stmt|;
comment|/* = 0 */
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_first: Could not copyout to event_buf. error = %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|retrieved
operator|=
name|TWA_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TWA_IOCTL_GET_LAST_EVENT
case|:
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get Last Event"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_wrapped
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_OVERFLOW
expr_stmt|;
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_head
operator|==
name|sc
operator|->
name|twa_aen_tail
condition|)
block|{
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
name|event_index
operator|=
operator|(
name|sc
operator|->
name|twa_aen_head
operator|-
literal|1
operator|+
name|TWA_Q_LENGTH
operator|)
operator|%
name|TWA_Q_LENGTH
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_last: Could not copyout to event_buf. error = %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|retrieved
operator|=
name|TWA_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TWA_IOCTL_GET_NEXT_EVENT
case|:
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get Next Event"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_wrapped
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get Next Event: wrapped"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|twa_dbg_dprint
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Get Next Event: overflow"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_OVERFLOW
expr_stmt|;
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|FALSE
expr_stmt|;
block|}
name|start_index
operator|=
name|sc
operator|->
name|twa_aen_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_head
operator|==
name|sc
operator|->
name|twa_aen_tail
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get Next Event: empty queue"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|start_index
operator|=
name|sc
operator|->
name|twa_aen_tail
expr_stmt|;
comment|/* = 0 */
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|user_buf
operator|->
name|pdata
argument_list|,
operator|&
name|event_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_next: Could not copyin event_buf.\n"
argument_list|)
expr_stmt|;
name|event_index
operator|=
operator|(
name|start_index
operator|+
name|event_buf
operator|.
name|sequence_id
operator|-
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|start_index
index|]
operator|)
operator|->
name|sequence_id
operator|+
literal|1
operator|)
operator|%
name|TWA_Q_LENGTH
expr_stmt|;
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get Next Event: si = %x, ei = %x, ebsi = %x, sisi = %x, eisi = %x"
argument_list|,
name|start_index
argument_list|,
name|event_index
argument_list|,
name|event_buf
operator|.
name|sequence_id
argument_list|,
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|start_index
index|]
operator|)
operator|->
name|sequence_id
argument_list|,
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|sequence_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|sequence_id
operator|>
name|event_buf
operator|.
name|sequence_id
operator|)
condition|)
block|{
if|if
condition|(
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|==
name|TWA_ERROR_AEN_OVERFLOW
condition|)
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|TRUE
expr_stmt|;
comment|/* so we report the overflow next time */
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_next: Could not copyout to event_buf. error = %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|retrieved
operator|=
name|TWA_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TWA_IOCTL_GET_PREVIOUS_EVENT
case|:
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"Get Previous Event"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_wrapped
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_overflow
condition|)
block|{
comment|/* 				 * The aen queue has wrapped, even before some 				 * events have been retrieved.  Let the caller 				 * know that he missed out on some AEN's. 				 */
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_OVERFLOW
expr_stmt|;
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|FALSE
expr_stmt|;
block|}
name|start_index
operator|=
name|sc
operator|->
name|twa_aen_head
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|twa_aen_head
operator|==
name|sc
operator|->
name|twa_aen_tail
condition|)
block|{
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
name|start_index
operator|=
name|sc
operator|->
name|twa_aen_tail
expr_stmt|;
comment|/* = 0 */
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|user_buf
operator|->
name|pdata
argument_list|,
operator|&
name|event_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_previous: Could not copyin event_buf.\n"
argument_list|)
expr_stmt|;
name|event_index
operator|=
operator|(
name|start_index
operator|+
name|event_buf
operator|.
name|sequence_id
operator|-
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|start_index
index|]
operator|)
operator|->
name|sequence_id
operator|-
literal|1
operator|)
operator|%
name|TWA_Q_LENGTH
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|sequence_id
operator|<
name|event_buf
operator|.
name|sequence_id
operator|)
condition|)
block|{
if|if
condition|(
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|==
name|TWA_ERROR_AEN_OVERFLOW
condition|)
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|TRUE
expr_stmt|;
comment|/* so we report the overflow next time */
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_AEN_NO_EVENTS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_event_packet
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_previous: Could not copyout to event_buf. error = %x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|event_index
index|]
operator|)
operator|->
name|retrieved
operator|=
name|TWA_AEN_RETRIEVED
expr_stmt|;
break|break;
case|case
name|TWA_IOCTL_GET_LOCK
case|:
block|{
name|struct
name|twa_lock_packet
name|twa_lock
decl_stmt|;
name|u_int32_t
name|cur_time
decl_stmt|;
name|cur_time
operator|=
name|time_second
operator|-
operator|(
name|tz
operator|.
name|tz_minuteswest
operator|*
literal|60
operator|)
operator|-
operator|(
name|wall_cmos_clock
condition|?
name|adjkerntz
else|:
literal|0
operator|)
expr_stmt|;
name|copyin
argument_list|(
name|user_buf
operator|->
name|pdata
argument_list|,
operator|&
name|twa_lock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_lock_packet
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|lock
operator|==
name|TWA_LOCK_FREE
operator|)
operator|||
operator|(
name|twa_lock
operator|.
name|force_flag
operator|)
operator|||
operator|(
name|cur_time
operator|>=
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|timeout
operator|)
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"GET_LOCK: Getting lock!"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|lock
operator|=
name|TWA_LOCK_HELD
expr_stmt|;
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|timeout
operator|=
name|cur_time
operator|+
operator|(
name|twa_lock
operator|.
name|timeout_msec
operator|/
literal|1000
operator|)
expr_stmt|;
name|twa_lock
operator|.
name|time_remaining_msec
operator|=
name|twa_lock
operator|.
name|timeout_msec
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|twa_dbg_dprint
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"GET_LOCK: Lock already held!"
argument_list|)
expr_stmt|;
name|twa_lock
operator|.
name|time_remaining_msec
operator|=
operator|(
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|timeout
operator|-
name|cur_time
operator|)
operator|*
literal|1000
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_IOCTL_LOCK_ALREADY_HELD
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|twa_lock
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_lock_packet
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TWA_IOCTL_RELEASE_LOCK
case|:
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|lock
operator|==
name|TWA_LOCK_FREE
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"twa_ioctl: RELEASE_LOCK: Lock not held!"
argument_list|)
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
name|TWA_ERROR_IOCTL_LOCK_NOT_HELD
expr_stmt|;
block|}
else|else
block|{
name|twa_dbg_dprint
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|,
literal|"RELEASE_LOCK: Releasing lock!"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|twa_ioctl_lock
operator|.
name|lock
operator|=
name|TWA_LOCK_FREE
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWA_IOCTL_GET_COMPATIBILITY_INFO
case|:
block|{
name|struct
name|twa_compatibility_packet
name|comp_pkt
decl_stmt|;
name|bcopy
argument_list|(
name|TWA_DRIVER_VERSION_STRING
argument_list|,
name|comp_pkt
operator|.
name|driver_version
argument_list|,
sizeof|sizeof
argument_list|(
name|TWA_DRIVER_VERSION_STRING
argument_list|)
argument_list|)
expr_stmt|;
name|comp_pkt
operator|.
name|working_srl
operator|=
name|sc
operator|->
name|working_srl
expr_stmt|;
name|comp_pkt
operator|.
name|working_branch
operator|=
name|sc
operator|->
name|working_branch
expr_stmt|;
name|comp_pkt
operator|.
name|working_build
operator|=
name|sc
operator|->
name|working_build
expr_stmt|;
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Copy compatibility information to user space. */
name|copyout
argument_list|(
operator|&
name|comp_pkt
argument_list|,
name|user_buf
operator|->
name|pdata
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|twa_compatibility_packet
argument_list|)
argument_list|,
name|user_buf
operator|->
name|twa_drvr_pkt
operator|.
name|buffer_length
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown opcode. */
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_enable_interrupts  * Description:		Enables interrupts on the controller  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_enable_interrupts
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|twa_state
operator||=
name|TWA_STATE_INTR_ENABLED
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_ATTENTION_INTERRUPT
operator||
name|TWA_CONTROL_UNMASK_RESPONSE_INTERRUPT
operator||
name|TWA_CONTROL_ENABLE_INTERRUPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_setup  * Description:		Disables interrupts on the controller  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_disable_interrupts
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_DISABLE_INTERRUPTS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|twa_state
operator|&=
operator|~
name|TWA_STATE_INTR_ENABLED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_get_param  * Description:		Get a firmware parameter.  *  * Input:		sc		-- ptr to per ctlr structure  *			table_id	-- parameter table #  *			param_id	-- index of the parameter in the table  *			param_size	-- size of the parameter in bytes  *			callback	-- ptr to function, if any, to be called  *					back on completion; NULL if no callback.  * Output:		None  * Return value:	ptr to param structure	-- success  *			NULL			-- failure  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|twa_get_param
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|size_t
name|param_size
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|union
name|twa_command_7k
modifier|*
name|cmd
decl_stmt|;
name|struct
name|twa_param_9k
modifier|*
name|param
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
name|ENOMEM
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
comment|/* Allocate memory to read data into. */
if|if
condition|(
operator|(
name|param
operator|=
operator|(
expr|struct
name|twa_param_9k
operator|*
operator|)
name|malloc
argument_list|(
name|TWA_SECTOR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|bzero
argument_list|(
name|param
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_param_9k
argument_list|)
operator|-
literal|1
operator|+
name|param_size
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_data
operator|=
name|param
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
name|TWA_SECTOR_SIZE
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator|=
name|TWA_CMD_DATA_IN
operator||
name|TWA_CMD_DATA_OUT
expr_stmt|;
comment|/* Build the cmd pkt. */
name|cmd
operator|=
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|)
expr_stmt|;
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|opcode
operator|=
name|TWA_OP_GET_PARAM
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|sgl_offset
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|request_id
operator|=
name|tr
operator|->
name|tr_request_id
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|param_count
operator|=
literal|1
expr_stmt|;
comment|/* Specify which parameter we need. */
name|param
operator|->
name|table_id
operator|=
name|table_id
operator||
name|TWA_9K_PARAM_DESCRIPTOR
expr_stmt|;
name|param
operator|->
name|parameter_id
operator|=
name|param_id
expr_stmt|;
name|param
operator|->
name|parameter_size_bytes
operator|=
name|param_size
expr_stmt|;
comment|/* Submit the command. */
if|if
condition|(
name|callback
operator|==
name|NULL
condition|)
block|{
comment|/* There's no call back; wait till the command completes. */
name|error
operator|=
name|twa_immediate_request
argument_list|(
name|tr
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* clean-up done by twa_immediate_request */
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|param
operator|.
name|status
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|cmd
operator|->
name|param
operator|.
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|)
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|err_specific_desc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* twa_drain_complete_queue will have done the unmapping */
block|}
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|param
operator|)
return|;
block|}
else|else
block|{
comment|/* There's a call back.  Simply submit the command. */
name|tr
operator|->
name|tr_callback
operator|=
name|callback
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_map_request
argument_list|(
name|tr
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"%s: twa_map_request returned 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
return|return
operator|(
name|callback
operator|)
return|;
block|}
name|out
label|:
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"get_param failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
condition|)
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_set_param  * Description:		Set a firmware parameter.  *  * Input:		sc		-- ptr to per ctlr structure  *			table_id	-- parameter table #  *			param_id	-- index of the parameter in the table  *			param_size	-- size of the parameter in bytes  *			callback	-- ptr to function, if any, to be called  *					back on completion; NULL if no callback.  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_set_param
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int
name|table_id
parameter_list|,
name|int
name|param_id
parameter_list|,
name|int
name|param_size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|union
name|twa_command_7k
modifier|*
name|cmd
decl_stmt|;
name|struct
name|twa_param_9k
modifier|*
name|param
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
name|ENOMEM
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
comment|/* Allocate memory to send data using. */
if|if
condition|(
operator|(
name|param
operator|=
operator|(
expr|struct
name|twa_param_9k
operator|*
operator|)
name|malloc
argument_list|(
name|TWA_SECTOR_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|bzero
argument_list|(
name|param
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_param_9k
argument_list|)
operator|-
literal|1
operator|+
name|param_size
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_data
operator|=
name|param
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
name|TWA_SECTOR_SIZE
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator|=
name|TWA_CMD_DATA_IN
operator||
name|TWA_CMD_DATA_OUT
expr_stmt|;
comment|/* Build the cmd pkt. */
name|cmd
operator|=
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|)
expr_stmt|;
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|opcode
operator|=
name|TWA_OP_SET_PARAM
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|sgl_offset
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|size
operator|=
literal|2
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|request_id
operator|=
name|tr
operator|->
name|tr_request_id
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|param
operator|.
name|param_count
operator|=
literal|1
expr_stmt|;
comment|/* Specify which parameter we want to set. */
name|param
operator|->
name|table_id
operator|=
name|table_id
operator||
name|TWA_9K_PARAM_DESCRIPTOR
expr_stmt|;
name|param
operator|->
name|parameter_id
operator|=
name|param_id
expr_stmt|;
name|param
operator|->
name|parameter_size_bytes
operator|=
name|param_size
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|param
operator|->
name|data
argument_list|,
name|param_size
argument_list|)
expr_stmt|;
comment|/* Submit the command. */
if|if
condition|(
name|callback
operator|==
name|NULL
condition|)
block|{
comment|/* There's no call back;  wait till the command completes. */
name|error
operator|=
name|twa_immediate_request
argument_list|(
name|tr
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* clean-up done by twa_immediate_request */
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|cmd
operator|->
name|param
operator|.
name|status
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|cmd
operator|->
name|param
operator|.
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|)
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|err_specific_desc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* twa_drain_complete_queue will have done the unmapping */
block|}
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* There's a call back.  Simply submit the command. */
name|tr
operator|->
name|tr_callback
operator|=
name|callback
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_map_request
argument_list|(
name|tr
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"%s: twa_map_request returned 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|out
label|:
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"set_param failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
condition|)
name|free
argument_list|(
name|param
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_init_connection  * Description:		Send init_connection cmd to firmware  *  * Input:		sc		-- ptr to per ctlr structure  *			message_credits	-- max # of requests that we might send  *					 down simultaneously.  This will be  *					 typically set to 256 at init-time or  *					after a reset, and to 1 at shutdown-time  *			set_features	-- indicates if we intend to use 64-bit  *					sg, also indicates if we want to do a  *					basic or an extended init_connection;  *  * Note: The following input/output parameters are valid, only in case of an  *		extended init_connection:  *  *			current_fw_srl		-- srl of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_arch_id	-- arch_id of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_branch	-- branch # of fw we are bundled  *						with, if any; 0 otherwise  *			current_fw_build	-- build # of fw we are bundled  *						with, if any; 0 otherwise  * Output:		fw_on_ctlr_srl		-- srl of fw on ctlr  *			fw_on_ctlr_arch_id	-- arch_id of fw on ctlr  *			fw_on_ctlr_branch	-- branch # of fw on ctlr  *			fw_on_ctlr_build	-- build # of fw on ctlr  *			init_connect_result	-- result bitmap of fw response  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_init_connection
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|message_credits
parameter_list|,
name|u_int32_t
name|set_features
parameter_list|,
name|u_int16_t
name|current_fw_srl
parameter_list|,
name|u_int16_t
name|current_fw_arch_id
parameter_list|,
name|u_int16_t
name|current_fw_branch
parameter_list|,
name|u_int16_t
name|current_fw_build
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_srl
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_arch_id
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_branch
parameter_list|,
name|u_int16_t
modifier|*
name|fw_on_ctlr_build
parameter_list|,
name|u_int32_t
modifier|*
name|init_connect_result
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|struct
name|twa_command_init_connect
modifier|*
name|init_connect
decl_stmt|;
name|int
name|error
init|=
literal|1
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|3
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Get a request packet. */
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
comment|/* Build the cmd pkt. */
name|init_connect
operator|=
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|init_connect
operator|)
expr_stmt|;
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|init_connect
operator|->
name|opcode
operator|=
name|TWA_OP_INIT_CONNECTION
expr_stmt|;
name|init_connect
operator|->
name|request_id
operator|=
name|tr
operator|->
name|tr_request_id
expr_stmt|;
name|init_connect
operator|->
name|message_credits
operator|=
name|message_credits
expr_stmt|;
name|init_connect
operator|->
name|features
operator|=
name|set_features
expr_stmt|;
if|if
condition|(
name|TWA_64BIT_ADDRESSES
condition|)
name|init_connect
operator|->
name|features
operator||=
name|TWA_64BIT_SG_ADDRESSES
expr_stmt|;
if|if
condition|(
name|set_features
operator|&
name|TWA_EXTENDED_INIT_CONNECT
condition|)
block|{
comment|/* Fill in the extra fields needed for an extended init_connect. */
name|init_connect
operator|->
name|size
operator|=
literal|6
expr_stmt|;
name|init_connect
operator|->
name|fw_srl
operator|=
name|current_fw_srl
expr_stmt|;
name|init_connect
operator|->
name|fw_arch_id
operator|=
name|current_fw_arch_id
expr_stmt|;
name|init_connect
operator|->
name|fw_branch
operator|=
name|current_fw_branch
expr_stmt|;
name|init_connect
operator|->
name|fw_build
operator|=
name|current_fw_build
expr_stmt|;
block|}
else|else
name|init_connect
operator|->
name|size
operator|=
literal|3
expr_stmt|;
comment|/* Submit the command, and wait for it to complete. */
name|error
operator|=
name|twa_immediate_request
argument_list|(
name|tr
argument_list|,
name|TWA_REQUEST_TIMEOUT_PERIOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* clean-up done by twa_immediate_request */
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|init_connect
operator|->
name|status
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|init_connect
operator|->
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|status_block
operator|.
name|error
argument_list|)
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|err_specific_desc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* twa_drain_complete_queue will have done the unmapping */
block|}
if|if
condition|(
name|set_features
operator|&
name|TWA_EXTENDED_INIT_CONNECT
condition|)
block|{
operator|*
name|fw_on_ctlr_srl
operator|=
name|init_connect
operator|->
name|fw_srl
expr_stmt|;
operator|*
name|fw_on_ctlr_arch_id
operator|=
name|init_connect
operator|->
name|fw_arch_id
expr_stmt|;
operator|*
name|fw_on_ctlr_branch
operator|=
name|init_connect
operator|->
name|fw_branch
expr_stmt|;
operator|*
name|fw_on_ctlr_build
operator|=
name|init_connect
operator|->
name|fw_build
expr_stmt|;
operator|*
name|init_connect_result
operator|=
name|init_connect
operator|->
name|result
expr_stmt|;
block|}
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"init_connection failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
condition|)
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_wait_request  * Description:		Sends down a firmware cmd, and waits for the completion,  *			but NOT in a tight loop.  *  * Input:		tr	-- ptr to request pkt  *			timeout -- max # of seconds to wait before giving up  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_wait_request
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|time_t
name|end_time
decl_stmt|;
name|int
name|error
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_flags
operator||=
name|TWA_CMD_SLEEP_ON_REQUEST
expr_stmt|;
name|tr
operator|->
name|tr_status
operator|=
name|TWA_CMD_BUSY
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_map_request
argument_list|(
name|tr
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"%s: twa_map_request returned 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|end_time
operator|=
name|time_second
operator|+
name|timeout
expr_stmt|;
while|while
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_COMPLETE
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|tr
operator|->
name|tr_error
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
name|tr
argument_list|,
name|PRIBIO
argument_list|,
literal|"twawait"
argument_list|,
name|timeout
operator|*
name|hz
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
operator|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_COMPLETE
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* Time out! */
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"%s: Request %p timed out.\n"
argument_list|,
name|__func__
argument_list|,
name|tr
argument_list|)
expr_stmt|;
comment|/* 			 * We will reset the controller only if the request has 			 * already been submitted, so as to not lose the 			 * request packet.  If a busy request timed out, the 			 * reset will take care of freeing resources.  If a 			 * pending request timed out, we will free resources 			 * for that request, right here.  So, the caller is 			 * expected to NOT cleanup when ETIMEDOUT is returned. 			 */
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_PENDING
condition|)
name|twa_reset
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Request was never submitted.  Clean up. */
name|twa_remove_pending
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twa_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/*  		 * Either the request got completed, or we were woken up by a 		 * signal.  Calculate the new timeout, in case it was the latter. 		 */
name|timeout
operator|=
operator|(
name|end_time
operator|-
name|time_second
operator|)
expr_stmt|;
block|}
name|twa_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_immediate_request  * Description:		Sends down a firmware cmd, and waits for the completion  *			in a tight loop.  *  * Input:		tr	-- ptr to request pkt  *			timeout -- max # of seconds to wait before giving up  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_immediate_request
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|time_t
name|end_time
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_map_request
argument_list|(
name|tr
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"%s: twa_map_request returned 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|end_time
operator|=
name|time_second
operator|+
name|timeout
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|tr
operator|->
name|tr_error
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|twa_done
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_BUSY
operator|)
operator|&&
operator|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_PENDING
operator|)
condition|)
block|{
name|twa_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_COMPLETE
operator|)
return|;
block|}
block|}
do|while
condition|(
name|time_second
operator|<=
name|end_time
condition|)
do|;
comment|/* Time out! */
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"%s: Request %p timed out.\n"
argument_list|,
name|__func__
argument_list|,
name|tr
argument_list|)
expr_stmt|;
comment|/* 	 * We will reset the controller only if the request has 	 * already been submitted, so as to not lose the 	 * request packet.  If a busy request timed out, the 	 * reset will take care of freeing resources.  If a 	 * pending request timed out, we will free resources 	 * for that request, right here.  So, the caller is 	 * expected to NOT cleanup when ETIMEDOUT is returned. 	 */
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_PENDING
condition|)
name|twa_reset
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Request was never submitted.  Clean up. */
name|twa_remove_pending
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twa_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_complete_io  * Description:		Callback on scsi requests to fw.  *  * Input:		tr	-- ptr to request pkt  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_complete_io
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|twa_softc
modifier|*
name|sc
init|=
name|tr
operator|->
name|tr_sc
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|8
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_COMPLETE
condition|)
name|twa_panic
argument_list|(
name|sc
argument_list|,
literal|"twa_complete_io on incomplete command"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_private
condition|)
comment|/* This is a scsi cmd.  Complete it. */
name|twa_scsi_complete
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_reset  * Description:		Soft resets and then initializes the controller;  *			drains any incomplete requests.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|int
name|twa_reset
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable interrupts from the controller, and mask any 	 * accidental entry into our interrupt handler. 	 */
name|twa_disable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* Soft reset the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|twa_soft_reset
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller reset failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Re-establish logical connection with the controller. */
if|if
condition|(
operator|(
name|error
operator|=
name|twa_init_connection
argument_list|(
name|sc
argument_list|,
name|TWA_INIT_MESSAGE_CREDITS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't initialize connection after reset.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller reset done!\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Complete all requests in the complete queue; error back all requests 	 * in the busy queue.  Any internal requests will be simply freed. 	 * Re-submit any requests in the pending queue. 	 */
name|twa_drain_complete_queue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twa_drain_busy_queue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Enable interrupts, and also clear attention and response interrupts. 	 */
name|twa_enable_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_soft_reset  * Description:		Does the actual soft reset.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_soft_reset
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status_reg
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Resetting controller...\n"
argument_list|)
expr_stmt|;
name|TWA_SOFT_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twa_wait_status
argument_list|(
name|sc
argument_list|,
name|TWA_STATUS_MICROCONTROLLER_READY
operator||
name|TWA_STATUS_ATTENTION_INTERRUPT
argument_list|,
literal|30
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Micro-ctlr not ready/No attn intr after reset.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_ATTENTION_INTERRUPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|twa_drain_response_queue
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't drain response queue.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|twa_drain_aen_queue
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Can't drain AEN queue.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|twa_find_aen
argument_list|(
name|sc
argument_list|,
name|TWA_AEN_SOFT_RESET
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Reset not reported by controller.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TWA_STATUS_ERRORS
argument_list|(
name|status_reg
argument_list|)
operator|||
name|twa_check_ctlr_state
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller errors detected.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_submit_io  * Description:		Wrapper to twa_start.  *  * Input:		tr	-- ptr to request pkt  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|int
name|twa_submit_io
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_start
argument_list|(
name|tr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_cmd_pkt_type
operator|&
name|TWA_CMD_PKT_TYPE_EXTERNAL
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
comment|/* 				 * Cmd queue is full.  Freeze the simq to 				 * maintain ccb ordering.  The next ccb that 				 * gets completed will unfreeze the simq. 				 */
name|twa_disallow_new_requests
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
else|else
comment|/* It's a controller error. */
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"SCSI cmd = 0x%x: ERROR: (0x%02X: 0x%04X)\n"
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|.
name|cdb
index|[
literal|0
index|]
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_error
operator|=
name|error
expr_stmt|;
name|twa_scsi_complete
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
name|error
operator|=
literal|0
expr_stmt|;
comment|/* the request will be in the pending queue */
else|else
block|{
name|twa_printf
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|,
literal|"cmd = 0x%x: ERROR: (0x%02X: 0x%04X)\n"
argument_list|,
operator|(
name|tr
operator|->
name|tr_cmd_pkt_type
operator|==
name|TWA_CMD_PKT_TYPE_9K
operator|)
condition|?
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|.
name|command
operator|.
name|opcode
operator|)
else|:
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_7k
operator|.
name|generic
operator|.
name|opcode
operator|)
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|tr
operator|->
name|tr_error
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_error
operator|=
name|error
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_start  * Description:		Posts a cmd to firmware.  *  * Input:		tr	-- ptr to request pkt  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
name|int
name|twa_start
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|twa_softc
modifier|*
name|sc
init|=
name|tr
operator|->
name|tr_sc
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|10
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* Check to see if we can post a command. */
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_check_ctlr_state
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_COMMAND_QUEUE_FULL
condition|)
block|{
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_cmd_pkt_type
operator|&
name|TWA_CMD_PKT_TYPE_INTERNAL
operator|)
operator|||
operator|(
name|tr
operator|->
name|tr_cmd_pkt_type
operator|&
name|TWA_CMD_PKT_TYPE_IOCTL
operator|)
condition|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_PENDING
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"pending internal/ioctl request"
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_status
operator|=
name|TWA_CMD_PENDING
expr_stmt|;
name|twa_enqueue_pending
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_UNMASK_COMMAND_INTERRUPT
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
comment|/* Cmd queue is not full.  Post the command. */
name|TWA_WRITE_COMMAND_QUEUE
argument_list|(
name|sc
argument_list|,
name|tr
operator|->
name|tr_cmd_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|twa_command_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the request as currently being processed. */
name|tr
operator|->
name|tr_status
operator|=
name|TWA_CMD_BUSY
expr_stmt|;
comment|/* Move the request into the busy queue. */
name|twa_enqueue_busy
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_done  * Description:		Looks for cmd completions from fw; queues cmds completed  *			by fw into complete queue.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- no ctlr error  *			non-zero-- ctlr error  */
end_comment

begin_function
specifier|static
name|int
name|twa_done
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|twa_response_queue
name|rq
decl_stmt|;
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|10
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_check_ctlr_state
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_RESPONSE_QUEUE_EMPTY
condition|)
break|break;
comment|/* Response queue is not empty. */
name|rq
operator|=
name|TWA_READ_RESPONSE_QUEUE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tr
operator|=
name|sc
operator|->
name|twa_lookup
index|[
name|rq
operator|.
name|u
operator|.
name|response_id
index|]
expr_stmt|;
comment|/* lookup the request */
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_BUSY
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"ERROR: Unposted command completed!! req = %p; status = %d\n"
argument_list|,
name|tr
argument_list|,
name|tr
operator|->
name|tr_status
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_status
operator|=
name|TWA_CMD_COMPLETE
expr_stmt|;
comment|/* Enqueue request in the complete queue. */
name|twa_remove_busy
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|twa_enqueue_complete
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Complete this, and other requests in the complete queue. */
name|twa_drain_complete_queue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_drain_pending_queue  * Description:		Kick starts any requests in the pending queue.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- all pending requests drained  *			non-zero-- otherwise  */
end_comment

begin_function
specifier|static
name|int
name|twa_drain_pending_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|10
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Pull requests off the pending queue, and submit them. 	 */
while|while
condition|(
operator|(
name|tr
operator|=
name|twa_dequeue_pending
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|twa_start
argument_list|(
name|tr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Requeueing pending request"
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_status
operator|=
name|TWA_CMD_PENDING
expr_stmt|;
name|twa_requeue_pending
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* queue at the head */
break|break;
block|}
else|else
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: twa_start returned 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_flags
operator|&
name|TWA_CMD_SLEEP_ON_REQUEST
condition|)
name|wakeup_one
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* let the caller know it failed */
name|tr
operator|->
name|tr_error
operator|=
name|error
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_drain_complete_queue  * Description:		Does unmapping for each request completed by fw,  *			and lets the request originators know of the completion.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_drain_complete_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|10
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Pull commands off the completed list, dispatch them appropriately. 	 */
while|while
condition|(
operator|(
name|tr
operator|=
name|twa_dequeue_complete
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Unmap the command packet, and any associated data buffer. */
name|twa_unmap_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Call the callback, if there's one. */
if|if
condition|(
name|tr
operator|->
name|tr_callback
condition|)
name|tr
operator|->
name|tr_callback
argument_list|(
name|tr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tr
operator|->
name|tr_flags
operator|&
name|TWA_CMD_SLEEP_ON_REQUEST
condition|)
block|{
comment|/* Wake up the sleeping command originator. */
name|twa_dbg_dprint
argument_list|(
literal|7
argument_list|,
name|sc
argument_list|,
literal|"Waking up originator of request %p"
argument_list|,
name|tr
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_wait_status  * Description:		Wait for a given status to show up in the fw status register.  *  * Input:		sc	-- ptr to per ctlr structure  *			status	-- status to look for  *			timeout -- max # of seconds to wait before giving up  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_wait_status
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status
parameter_list|,
name|u_int32_t
name|timeout
parameter_list|)
block|{
name|time_t
name|end_time
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|end_time
operator|=
name|time_second
operator|+
name|timeout
expr_stmt|;
do|do
block|{
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status_reg
operator|&
name|status
operator|)
operator|==
name|status
condition|)
comment|/* got the required bit(s)? */
return|return
operator|(
literal|0
operator|)
return|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|time_second
operator|<=
name|end_time
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_drain_response_queue  * Description:		Drain the response queue.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_drain_response_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|union
name|twa_response_queue
name|rq
decl_stmt|;
name|u_int32_t
name|status_reg
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twa_check_ctlr_state
argument_list|(
name|sc
argument_list|,
name|status_reg
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_RESPONSE_QUEUE_EMPTY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no more response queue entries */
name|rq
operator|=
name|TWA_READ_RESPONSE_QUEUE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_host_intr  * Description:		This function gets called if we triggered an interrupt.  *			We don't use it as of now.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_host_intr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|twa_dbg_dprint_enter
argument_list|(
literal|6
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_HOST_INTERRUPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_attention_intr  * Description:		This function gets called if the fw posted an AEN  *			(Asynchronous Event Notification).  It fetches  *			all the AEN's that the fw might have posted.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_attention_intr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|6
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_fetch_aen
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Fetch AEN failed. error = 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_ATTENTION_INTERRUPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_command_intr  * Description:		This function gets called if we hit a queue full  *			condition earlier, and the fw is now ready for  *			new cmds.  Submits any pending requests.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_command_intr
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|twa_dbg_dprint_enter
argument_list|(
literal|6
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Start any requests that might be in the pending queue. */
if|if
condition|(
operator|!
name|twa_drain_pending_queue
argument_list|(
name|sc
argument_list|)
condition|)
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_MASK_COMMAND_INTERRUPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_fetch_aen  * Description:		Send down a Request Sense cmd to fw to fetch an AEN.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_fetch_aen
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
name|tr
operator|->
name|tr_callback
operator|=
name|twa_aen_callback
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_send_scsi_cmd
argument_list|(
name|tr
argument_list|,
literal|0x03
comment|/* REQUEST_SENSE */
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_aen_callback  * Description:		Callback for requests to fetch AEN's.  *  * Input:		tr	-- ptr to completed request pkt  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_aen_callback
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|twa_softc
modifier|*
name|sc
init|=
name|tr
operator|->
name|tr_sc
decl_stmt|;
name|struct
name|twa_command_header
modifier|*
name|cmd_hdr
init|=
operator|(
expr|struct
name|twa_command_header
operator|*
operator|)
operator|(
name|tr
operator|->
name|tr_data
operator|)
decl_stmt|;
name|struct
name|twa_command_9k
modifier|*
name|cmd
init|=
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|twa_dbg_dprint
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"req_id = 0x%x, status = 0x%x"
argument_list|,
name|cmd
operator|->
name|request_id
argument_list|,
name|cmd
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|->
name|status
condition|)
block|{
if|if
condition|(
operator|(
name|tr
operator|->
name|tr_cmd_pkt_type
operator|&
name|TWA_CMD_PKT_TYPE_9K
operator|)
operator|&&
operator|(
name|cmd
operator|->
name|cdb
index|[
literal|0
index|]
operator|==
literal|0x3
comment|/* REQUEST_SENSE */
operator|)
condition|)
name|twa_enqueue_aen
argument_list|(
name|sc
argument_list|,
name|cmd_hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd_hdr
operator|->
name|err_specific_desc
index|[
sizeof|sizeof
argument_list|(
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: cmd = 0x%x: ERROR: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|command
operator|.
name|opcode
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_ERROR
argument_list|,
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_error_table
argument_list|,
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
argument_list|)
argument_list|,
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|)
expr_stmt|;
name|twa_dbg_print
argument_list|(
literal|2
argument_list|,
literal|"sense info: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|twa_dbg_print
argument_list|(
literal|2
argument_list|,
literal|"%x\t"
argument_list|,
name|tr
operator|->
name|tr_command
operator|->
name|cmd_hdr
operator|.
name|sense_data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|twa_dbg_print
argument_list|(
literal|2
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* print new line */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|twa_dbg_print
argument_list|(
literal|7
argument_list|,
literal|"%x\t"
argument_list|,
operator|(
operator|(
name|int8_t
operator|*
operator|)
operator|(
name|tr
operator|->
name|tr_data
operator|)
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_drain_aen_queue  * Description:		Fetches all un-retrieved AEN's posted by fw.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_drain_aen_queue
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|struct
name|twa_command_header
modifier|*
name|cmd_hdr
decl_stmt|;
name|time_t
name|end_time
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|tr
operator|=
name|twa_get_request
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|tr
operator|->
name|tr_cmd_pkt_type
operator||=
name|TWA_CMD_PKT_TYPE_INTERNAL
expr_stmt|;
name|tr
operator|->
name|tr_callback
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twa_send_scsi_cmd
argument_list|(
name|tr
argument_list|,
literal|0x03
comment|/* REQUEST_SENSE */
argument_list|)
operator|)
condition|)
block|{
name|twa_dbg_dprint
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Cannot send command to fetch aen"
argument_list|)
expr_stmt|;
break|break;
block|}
name|end_time
operator|=
name|time_second
operator|+
name|TWA_REQUEST_TIMEOUT_PERIOD
expr_stmt|;
do|do
block|{
name|twa_done
argument_list|(
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_BUSY
condition|)
break|break;
block|}
do|while
condition|(
name|time_second
operator|<=
name|end_time
condition|)
do|;
if|if
condition|(
name|tr
operator|->
name|tr_status
operator|!=
name|TWA_CMD_COMPLETE
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|.
name|status
operator|)
condition|)
break|break;
name|cmd_hdr
operator|=
operator|(
expr|struct
name|twa_command_header
operator|*
operator|)
operator|(
name|tr
operator|->
name|tr_data
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
operator|)
comment|/* aen_code */
operator|==
name|TWA_AEN_QUEUE_EMPTY
condition|)
break|break;
name|twa_enqueue_aen
argument_list|(
name|sc
argument_list|,
name|cmd_hdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tr
condition|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_data
condition|)
name|free
argument_list|(
name|tr
operator|->
name|tr_data
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|twa_release_request
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_enqueue_aen  * Description:		Queues AEN's to be supplied to user-space tools on request.  *  * Input:		sc	-- ptr to per ctlr structure  *			cmd_hdr	-- ptr to hdr of fw cmd pkt, from where the AEN  *				   details can be retrieved.  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_enqueue_aen
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twa_command_header
modifier|*
name|cmd_hdr
parameter_list|)
block|{
name|struct
name|twa_event_packet
modifier|*
name|event
decl_stmt|;
name|unsigned
name|short
name|aen_code
decl_stmt|;
name|unsigned
name|long
name|local_time
decl_stmt|;
name|unsigned
name|long
name|sync_time
decl_stmt|;
name|int
name|s
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|aen_code
operator|=
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
expr_stmt|;
switch|switch
condition|(
name|aen_code
condition|)
block|{
case|case
name|TWA_AEN_SYNC_TIME_WITH_HOST
case|:
name|twa_dbg_dprint
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Received AEN_SYNC_TIME"
argument_list|)
expr_stmt|;
comment|/* Calculate time (in seconds) since last Sunday 12.00 AM. */
name|local_time
operator|=
name|time_second
operator|-
operator|(
name|tz
operator|.
name|tz_minuteswest
operator|*
literal|60
operator|)
operator|-
operator|(
name|wall_cmos_clock
condition|?
name|adjkerntz
else|:
literal|0
operator|)
expr_stmt|;
name|sync_time
operator|=
operator|(
name|local_time
operator|-
operator|(
literal|3
operator|*
literal|86400
operator|)
operator|)
operator|%
literal|604800
expr_stmt|;
if|if
condition|(
name|twa_set_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_TIME_TABLE
argument_list|,
name|TWA_PARAM_TIME_SchedulerTime
argument_list|,
literal|4
argument_list|,
operator|&
name|sync_time
argument_list|,
name|twa_aen_callback
argument_list|)
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Unable to sync time with ctlr!\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWA_AEN_QUEUE_EMPTY
case|:
name|twa_dbg_dprint
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"AEN queue empty"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Queue the event. */
name|event
operator|=
name|sc
operator|->
name|twa_aen_queue
index|[
name|sc
operator|->
name|twa_aen_head
index|]
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|retrieved
operator|==
name|TWA_AEN_NOT_RETRIEVED
condition|)
name|sc
operator|->
name|twa_aen_queue_overflow
operator|=
name|TRUE
expr_stmt|;
name|event
operator|->
name|severity
operator|=
name|cmd_hdr
operator|->
name|status_block
operator|.
name|substatus_block
operator|.
name|severity
expr_stmt|;
name|local_time
operator|=
name|time_second
operator|-
operator|(
name|tz
operator|.
name|tz_minuteswest
operator|*
literal|60
operator|)
operator|-
operator|(
name|wall_cmos_clock
condition|?
name|adjkerntz
else|:
literal|0
operator|)
expr_stmt|;
name|event
operator|->
name|time_stamp_sec
operator|=
name|local_time
expr_stmt|;
name|event
operator|->
name|aen_code
operator|=
name|aen_code
expr_stmt|;
name|event
operator|->
name|retrieved
operator|=
name|TWA_AEN_NOT_RETRIEVED
expr_stmt|;
name|event
operator|->
name|sequence_id
operator|=
operator|++
operator|(
name|sc
operator|->
name|twa_current_sequence_id
operator|)
expr_stmt|;
name|cmd_hdr
operator|->
name|err_specific_desc
index|[
sizeof|sizeof
argument_list|(
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|event
operator|->
name|parameter_len
operator|=
name|strlen
argument_list|(
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|,
name|event
operator|->
name|parameter_data
argument_list|,
name|event
operator|->
name|parameter_len
argument_list|)
expr_stmt|;
name|twa_dbg_dprint
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"event = %x %x %x %x %x %x %x\n %s"
argument_list|,
name|event
operator|->
name|sequence_id
argument_list|,
name|event
operator|->
name|time_stamp_sec
argument_list|,
name|event
operator|->
name|aen_code
argument_list|,
name|event
operator|->
name|severity
argument_list|,
name|event
operator|->
name|retrieved
argument_list|,
name|event
operator|->
name|repeat_count
argument_list|,
name|event
operator|->
name|parameter_len
argument_list|,
name|event
operator|->
name|parameter_data
argument_list|)
expr_stmt|;
name|twa_dbg_dprint
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"cmd_hdr = %x %lx %x %x %x %x %x\n %s"
argument_list|,
name|sc
operator|->
name|twa_current_sequence_id
argument_list|,
name|local_time
argument_list|,
name|cmd_hdr
operator|->
name|status_block
operator|.
name|error
argument_list|,
name|cmd_hdr
operator|->
name|status_block
operator|.
name|substatus_block
operator|.
name|severity
argument_list|,
name|TWA_AEN_NOT_RETRIEVED
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|)
argument_list|,
name|cmd_hdr
operator|->
name|err_specific_desc
argument_list|)
expr_stmt|;
comment|/* Print the event. */
if|if
condition|(
name|event
operator|->
name|severity
operator|<
name|TWA_AEN_SEVERITY_DEBUG
condition|)
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: (0x%02X: 0x%04X): %s: %s\n"
argument_list|,
name|twa_aen_severity_table
index|[
name|event
operator|->
name|severity
index|]
argument_list|,
name|TWA_MESSAGE_SOURCE_CONTROLLER_EVENT
argument_list|,
name|aen_code
argument_list|,
name|twa_find_msg_string
argument_list|(
name|twa_aen_table
argument_list|,
name|aen_code
argument_list|)
argument_list|,
name|event
operator|->
name|parameter_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|twa_aen_head
operator|+
literal|1
operator|)
operator|==
name|TWA_Q_LENGTH
condition|)
name|sc
operator|->
name|twa_aen_queue_wrapped
operator|=
name|TRUE
expr_stmt|;
name|sc
operator|->
name|twa_aen_head
operator|=
operator|(
name|sc
operator|->
name|twa_aen_head
operator|+
literal|1
operator|)
operator|%
name|TWA_Q_LENGTH
expr_stmt|;
break|break;
block|}
comment|/* switch */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_find_aen  * Description:		Reports whether a given AEN ever occurred.  *  * Input:		sc	-- ptr to per ctlr structure  *			aen_code-- AEN to look for  * Output:		None  * Return value:	0	-- success  *			non-zero-- failure  */
end_comment

begin_function
specifier|static
name|int
name|twa_find_aen
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|aen_code
parameter_list|)
block|{
name|u_int32_t
name|last_index
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|twa_aen_queue_wrapped
condition|)
name|last_index
operator|=
name|sc
operator|->
name|twa_aen_head
expr_stmt|;
else|else
name|last_index
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|twa_aen_head
expr_stmt|;
do|do
block|{
name|i
operator|=
operator|(
name|i
operator|+
name|TWA_Q_LENGTH
operator|-
literal|1
operator|)
operator|%
name|TWA_Q_LENGTH
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|twa_aen_queue
index|[
name|i
index|]
operator|)
operator|->
name|aen_code
operator|==
name|aen_code
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|last_index
condition|)
do|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_find_msg_string  * Description:		Looks up a given table, and returns the message string  *			corresponding to a given code (error code or AEN code).  *  * Input:		sc	-- ptr to per ctlr structure  *			code	-- code, the message string corresponding to  *				   which is to be returned.  * Output:		None  * Return value:	ptr to corresponding msg string	-- success  *			NULL				-- failure  */
end_comment

begin_function
name|char
modifier|*
name|twa_find_msg_string
parameter_list|(
name|struct
name|twa_message
modifier|*
name|table
parameter_list|,
name|u_int16_t
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|message
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|table
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|message
operator|)
return|;
return|return
operator|(
name|table
index|[
name|i
index|]
operator|.
name|message
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_get_request  * Description:		Gets a request pkt from the free queue.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	ptr to request pkt	-- success  *			NULL			-- failure  */
end_comment

begin_function
name|struct
name|twa_request
modifier|*
name|twa_get_request
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_request
modifier|*
name|tr
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Get a free request packet. */
name|tr
operator|=
name|twa_dequeue_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize some fields to their defaults. */
if|if
condition|(
name|tr
condition|)
block|{
name|tr
operator|->
name|tr_data
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_real_data
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_length
operator|=
literal|0
expr_stmt|;
name|tr
operator|->
name|tr_real_length
operator|=
literal|0
expr_stmt|;
name|tr
operator|->
name|tr_status
operator|=
name|TWA_CMD_SETUP
expr_stmt|;
comment|/* command is in setup phase */
name|tr
operator|->
name|tr_flags
operator|=
literal|0
expr_stmt|;
name|tr
operator|->
name|tr_error
operator|=
literal|0
expr_stmt|;
name|tr
operator|->
name|tr_private
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_callback
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_cmd_pkt_type
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Look at the status field in the command packet to see how 		 * it completed the last time it was used, and zero out only 		 * the portions that might have changed.  Note that we don't 		 * care to zero out the sglist. 		 */
if|if
condition|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|.
name|cmd_pkt_9k
operator|.
name|status
condition|)
name|bzero
argument_list|(
name|tr
operator|->
name|tr_command
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|twa_command_header
argument_list|)
operator|+
literal|28
comment|/* max bytes before sglist */
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
operator|&
operator|(
name|tr
operator|->
name|tr_command
operator|->
name|command
operator|)
argument_list|,
literal|28
comment|/* max bytes before sglist */
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_release_request  * Description:		Puts a request pkt into the free queue.  *  * Input:		tr	-- ptr to request pkt to be freed  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_release_request
parameter_list|(
name|struct
name|twa_request
modifier|*
name|tr
parameter_list|)
block|{
name|twa_dbg_dprint_enter
argument_list|(
literal|4
argument_list|,
name|tr
operator|->
name|tr_sc
argument_list|)
expr_stmt|;
name|twa_enqueue_free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_describe_controller  * Description:		Describes the controller, in terms of its fw version,  *			BIOS version etc.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_describe_controller
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|twa_param_9k
modifier|*
name|p
index|[
literal|6
index|]
decl_stmt|;
name|u_int8_t
name|num_ports
init|=
literal|0
decl_stmt|;
name|twa_dbg_dprint_enter
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Get the port count. */
name|p
index|[
literal|0
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_CONTROLLER_TABLE
argument_list|,
name|TWA_PARAM_CONTROLLER_PORT_COUNT
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
name|num_ports
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|p
index|[
literal|0
index|]
operator|->
name|data
operator|)
expr_stmt|;
name|free
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* Get the firmware and BIOS versions. */
name|p
index|[
literal|0
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_VERSION_TABLE
argument_list|,
name|TWA_PARAM_VERSION_FW
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_VERSION_TABLE
argument_list|,
name|TWA_PARAM_VERSION_BIOS
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"%d ports, Firmware %.16s, BIOS %.16s\n"
argument_list|,
name|num_ports
argument_list|,
name|p
index|[
literal|0
index|]
condition|?
operator|(
name|p
index|[
literal|0
index|]
operator|->
name|data
operator|)
else|:
name|NULL
argument_list|,
name|p
index|[
literal|1
index|]
condition|?
operator|(
name|p
index|[
literal|1
index|]
operator|->
name|data
operator|)
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
comment|/* Get more versions. */
name|p
index|[
literal|2
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_VERSION_TABLE
argument_list|,
name|TWA_PARAM_VERSION_MONITOR
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_VERSION_TABLE
argument_list|,
name|TWA_PARAM_VERSION_PCBA
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_VERSION_TABLE
argument_list|,
name|TWA_PARAM_VERSION_ATA
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|twa_get_param
argument_list|(
name|sc
argument_list|,
name|TWA_PARAM_VERSION_TABLE
argument_list|,
name|TWA_PARAM_VERSION_PCI
argument_list|,
literal|8
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Monitor %.16s, PCB %.8s, Achip %.8s, Pchip %.8s\n"
argument_list|,
name|p
index|[
literal|2
index|]
condition|?
operator|(
name|p
index|[
literal|2
index|]
operator|->
name|data
operator|)
else|:
name|NULL
argument_list|,
name|p
index|[
literal|3
index|]
condition|?
operator|(
name|p
index|[
literal|3
index|]
operator|->
name|data
operator|)
else|:
name|NULL
argument_list|,
name|p
index|[
literal|4
index|]
condition|?
operator|(
name|p
index|[
literal|4
index|]
operator|->
name|data
operator|)
else|:
name|NULL
argument_list|,
name|p
index|[
literal|5
index|]
condition|?
operator|(
name|p
index|[
literal|5
index|]
operator|->
name|data
operator|)
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
condition|)
name|free
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|3
index|]
condition|)
name|free
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|4
index|]
condition|)
name|free
argument_list|(
name|p
index|[
literal|4
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|5
index|]
condition|)
name|free
argument_list|(
name|p
index|[
literal|5
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
condition|)
name|free
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
condition|)
name|free
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_check_ctlr_state  * Description:		Makes sure that the fw status register reports a  *			proper status.  *  * Input:		sc		-- ptr to per ctlr structure  *			status_reg	-- value in the status register  * Output:		None  * Return value:	0	-- no errors  *			non-zero-- errors  */
end_comment

begin_function
specifier|static
name|int
name|twa_check_ctlr_state
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|status_reg
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|last_warning
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Check if the 'micro-controller ready' bit is not set. */
if|if
condition|(
operator|(
name|status_reg
operator|&
name|TWA_STATUS_EXPECTED_BITS
operator|)
operator|!=
name|TWA_STATUS_EXPECTED_BITS
condition|)
block|{
if|if
condition|(
name|time_second
operator|>
operator|(
name|last_warning
index|[
literal|0
index|]
operator|+
literal|5
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Missing expected status bit(s) %b\n"
argument_list|,
operator|~
name|status_reg
operator|&
name|TWA_STATUS_EXPECTED_BITS
argument_list|,
name|TWA_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
name|last_warning
index|[
literal|0
index|]
operator|=
name|time_second
expr_stmt|;
block|}
name|result
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check if any error bits are set. */
if|if
condition|(
operator|(
name|status_reg
operator|&
name|TWA_STATUS_UNEXPECTED_BITS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|time_second
operator|>
operator|(
name|last_warning
index|[
literal|1
index|]
operator|+
literal|5
operator|)
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Unexpected status bit(s) %b\n"
argument_list|,
name|status_reg
operator|&
name|TWA_STATUS_UNEXPECTED_BITS
argument_list|,
name|TWA_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
name|last_warning
index|[
literal|1
index|]
operator|=
name|time_second
expr_stmt|;
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_PCI_PARITY_ERROR_INTERRUPT
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"PCI parity error: clearing... Re-seat/move/replace card.\n"
argument_list|)
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_PARITY_ERROR
argument_list|)
expr_stmt|;
name|twa_write_pci_config
argument_list|(
name|sc
argument_list|,
name|TWA_PCI_CONFIG_CLEAR_PARITY_ERROR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_PCI_ABORT_INTERRUPT
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"PCI abort: clearing...\n"
argument_list|)
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_PCI_ABORT
argument_list|)
expr_stmt|;
name|twa_write_pci_config
argument_list|(
name|sc
argument_list|,
name|TWA_PCI_CONFIG_CLEAR_PCI_ABORT
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_QUEUE_ERROR_INTERRUPT
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Controller queue error: clearing...\n"
argument_list|)
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_PCI_ABORT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_SBUF_WRITE_ERROR
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"SBUF write error: clearing...\n"
argument_list|)
expr_stmt|;
name|TWA_WRITE_CONTROL_REGISTER
argument_list|(
name|sc
argument_list|,
name|TWA_CONTROL_CLEAR_SBUF_WRITE_ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status_reg
operator|&
name|TWA_STATUS_MICROCONTROLLER_ERROR
condition|)
block|{
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"Micro-controller error!\n"
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_print_controller  * Description:		Prints the current status of the controller.  *  * Input:		sc	-- ptr to per ctlr structure  * Output:		None  * Return value:	None  */
end_comment

begin_function
name|void
name|twa_print_controller
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|status_reg
decl_stmt|;
comment|/* Print current controller details. */
name|status_reg
operator|=
name|TWA_READ_STATUS_REGISTER
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"status   %b\n"
argument_list|,
name|status_reg
argument_list|,
name|TWA_STATUS_BITS_DESCRIPTION
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWA_DEBUG
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"q type    current  max\n"
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"free      %04d     %04d\n"
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_FREE
index|]
operator|.
name|q_length
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_FREE
index|]
operator|.
name|q_max
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"busy      %04d     %04d\n"
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_BUSY
index|]
operator|.
name|q_length
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_BUSY
index|]
operator|.
name|q_max
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"pending   %04d     %04d\n"
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_PENDING
index|]
operator|.
name|q_length
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_PENDING
index|]
operator|.
name|q_max
argument_list|)
expr_stmt|;
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"complete  %04d     %04d\n"
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_COMPLETE
index|]
operator|.
name|q_length
argument_list|,
name|sc
operator|->
name|twa_qstats
index|[
name|TWAQ_COMPLETE
index|]
operator|.
name|q_max
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TWA_DEBUG */
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"AEN queue head %d  tail %d\n"
argument_list|,
name|sc
operator|->
name|twa_aen_head
argument_list|,
name|sc
operator|->
name|twa_aen_tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function name:	twa_panic  * Description:		Called when something is seriously wrong with the ctlr.  *			Hits the debugger if the debugger is turned on, else  *			resets the ctlr.  *  * Input:		sc	-- ptr to per ctlr structure  *			reason	-- string describing what went wrong  * Output:		None  * Return value:	None  */
end_comment

begin_function
specifier|static
name|void
name|twa_panic
parameter_list|(
name|struct
name|twa_softc
modifier|*
name|sc
parameter_list|,
name|int8_t
modifier|*
name|reason
parameter_list|)
block|{
name|twa_print_controller
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TWA_DEBUG
name|panic
argument_list|(
name|reason
argument_list|)
expr_stmt|;
else|#
directive|else
name|twa_printf
argument_list|(
name|sc
argument_list|,
literal|"twa_panic: RESETTING CONTROLLER...\n"
argument_list|)
expr_stmt|;
name|twa_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

