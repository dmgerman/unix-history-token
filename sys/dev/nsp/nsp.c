begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$NecBSD: nsp.c,v 1.21 1999/07/23 21:00:05 honda Exp $	*/
end_comment

begin_comment
comment|/*	$NetBSD$	*/
end_comment

begin_define
define|#
directive|define
name|NSP_DEBUG
end_define

begin_define
define|#
directive|define
name|NSP_STATICS
end_define

begin_comment
comment|/*  *  Copyright (c) 1998  *	NetBSD/pc98 porting staff. All rights reserved.  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>
literal|500001
end_if

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/device_port.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsipi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<machine/dvcfg.h>
end_include

begin_include
include|#
directive|include
file|<machine/physio_proc.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/scsi_low.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/nspreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/nspvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|delay
parameter_list|(
name|time
parameter_list|)
value|DELAY(time)
end_define

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/dvcfg.h>
end_include

begin_include
include|#
directive|include
file|<machine/physio_proc.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_low.h>
end_include

begin_include
include|#
directive|include
file|<dev/nsp/nspreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/nsp/nspvar.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|400001
end_if

begin_include
include|#
directive|include
file|"nsp.h"
end_include

begin_decl_stmt
name|struct
name|nsp_softc
modifier|*
name|nspdata
index|[
name|NNSP
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/***************************************************  * USER SETTINGS  ***************************************************/
end_comment

begin_comment
comment|/* DEVICE CONFIGURATION FLAGS (MINOR)  *  * 0x01   DISCONECT OFF  * 0x02   PARITY LINE OFF  * 0x04   IDENTIFY MSG OFF ( = single lun)  * 0x08   SYNC TRANSFER OFF  */
end_comment

begin_comment
comment|/***************************************************  * PARAMS  ***************************************************/
end_comment

begin_define
define|#
directive|define
name|NSP_NTARGETS
value|8
end_define

begin_define
define|#
directive|define
name|NSP_NLUNS
value|8
end_define

begin_define
define|#
directive|define
name|NSP_SELTIMEOUT
value|200
end_define

begin_comment
comment|/***************************************************  * DEBUG  ***************************************************/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DDB
end_ifndef

begin_define
define|#
directive|define
name|Debugger
parameter_list|()
value|panic("should call debugger here (nsp.c)")
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! DDB */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|Debugger
parameter_list|()
value|Debugger("nsp")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NSP_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|nsp_debug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSP_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NSP_STATICS
end_ifdef

begin_struct
struct|struct
name|nsp_statics
block|{
name|int
name|disconnect
decl_stmt|;
name|int
name|reselect
decl_stmt|;
name|int
name|data_phase_bypass
decl_stmt|;
block|}
name|nsp_statics
index|[
name|NSP_NTARGETS
index|]
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSP_STATICS */
end_comment

begin_comment
comment|/***************************************************  * ISA DEVICE STRUCTURE  ***************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cfdriver
name|nsp_cd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************  * DECLARE  **************************************************************/
end_comment

begin_comment
comment|/* static */
end_comment

begin_decl_stmt
specifier|static
name|void
name|nsp_pio_read
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nsp_pio_write
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_xfer
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|u_int8_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_msg
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_reselected
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|int
name|nsp_disconnected
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|nsp_pdma_end
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nsphw_init
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_nexus
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_world_start
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsphw_start_selection
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
name|sc
operator|,
expr|struct
name|slccb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nsphw_bus_reset
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nsphw_attention
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|nsp_fifo_count
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_negate_signal
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|u_int8_t
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_expect_signal
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|nsp_start_timer
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_dataphase_bypass
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nsp_setup_fifo
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nsp_lun_init
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
expr|struct
name|targ_info
operator|*
operator|,
expr|struct
name|lun_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|settimeout
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_low_funcs
name|nspfuncs
init|=
block|{
name|SC_LOW_INIT_T
name|nsp_world_start
block|,
name|SC_LOW_BUSRST_T
name|nsphw_bus_reset
block|,
name|SC_LOW_LUN_INIT_T
name|nsp_lun_init
block|,
name|SC_LOW_SELECT_T
name|nsphw_start_selection
block|,
name|SC_LOW_NEXUS_T
name|nsp_nexus
block|,
name|SC_LOW_ATTEN_T
name|nsphw_attention
block|,
name|SC_LOW_MSG_T
name|nsp_msg
block|,
name|SC_LOW_POLL_T
name|nspintr
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************  * hwfuncs  ****************************************************/
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|u_int8_t
name|nsp_cr_read_1
name|__P
argument_list|(
operator|(
name|bus_space_tag_t
name|bst
operator|,
name|bus_space_handle_t
name|bsh
operator|,
name|bus_addr_t
name|ofs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|nsp_cr_write_1
name|__P
argument_list|(
operator|(
name|bus_space_tag_t
name|bst
operator|,
name|bus_space_handle_t
name|bsh
operator|,
name|bus_addr_t
name|ofs
operator|,
name|u_int8_t
name|va
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|u_int8_t
name|nsp_cr_read_1
parameter_list|(
name|bst
parameter_list|,
name|bsh
parameter_list|,
name|ofs
parameter_list|)
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bus_addr_t
name|ofs
decl_stmt|;
block|{
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_idxr
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_datar
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|nsp_cr_write_1
parameter_list|(
name|bst
parameter_list|,
name|bsh
parameter_list|,
name|ofs
parameter_list|,
name|va
parameter_list|)
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bus_addr_t
name|ofs
decl_stmt|;
name|u_int8_t
name|va
decl_stmt|;
block|{
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_idxr
argument_list|,
name|ofs
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_datar
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_expect_signal
parameter_list|(
name|sc
parameter_list|,
name|curphase
parameter_list|,
name|mask
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|curphase
decl_stmt|,
name|mask
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|int
name|rv
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tout
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|callout_handle
name|ch
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
name|ph
decl_stmt|,
name|isrc
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ch
operator|=
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|ph
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|==
literal|0xff
condition|)
block|{
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|isrc
operator|=
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|&
name|IRQSR_SCSI
condition|)
block|{
name|rv
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ph
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ph
operator|&
name|SCBUSMON_PHMASK
operator|)
operator|==
name|curphase
condition|)
block|{
name|rv
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|tout
operator|==
literal|0
condition|)
do|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tout
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: nsp_expect_signal timeout\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nsphw_init
parameter_list|(
name|sc
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
comment|/* block all interrupts */
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQCR_ALLMASK
argument_list|)
expr_stmt|;
comment|/* setup SCSI interface */
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_ifselr
argument_list|,
name|IFSELR_IFSEL
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCIENR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_XFERMR
argument_list|,
name|XFERMR_IO8
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_CLKDIVR
argument_list|,
name|sc
operator|->
name|sc_iclkdiv
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCIENR
argument_list|,
name|sc
operator|->
name|sc_icr
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_PARITYR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_PTCLRR
argument_list|,
name|PTCLRR_ACK
operator||
name|PTCLRR_REQ
operator||
name|PTCLRR_HOST
operator||
name|PTCLRR_RSS
argument_list|)
expr_stmt|;
comment|/* setup fifo asic */
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_ifselr
argument_list|,
name|IFSELR_REGSEL
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TERMPWRC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_OCR
argument_list|)
operator|&
name|OCR_TERMPWRS
operator|)
operator|==
literal|0
condition|)
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TERMPWRC
argument_list|,
name|TERMPWRC_POWON
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_XFERMR
argument_list|,
name|XFERMR_IO8
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_CLKDIVR
argument_list|,
name|sc
operator|->
name|sc_clkdiv
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TIMERCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TIMERCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SYNCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_ACKWIDTH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* enable interrupts and ack them */
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCIENR
argument_list|,
name|SCIENR_SCCHG
operator||
name|SCIENR_RESEL
operator||
name|SCIENR_RST
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQSR_MASK
argument_list|)
expr_stmt|;
name|nsp_setup_fifo
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************  * scsi low interface  ****************************************************/
end_comment

begin_function
specifier|static
name|void
name|nsphw_attention
parameter_list|(
name|sc
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|u_int8_t
name|cr
decl_stmt|;
name|cr
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|)
comment|/*& ~SCBUSCR_ACK */
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|cr
operator||
name|SCBUSCR_ATN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nsphw_bus_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQCR_ALLMASK
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|SCBUSCR_RST
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 100ms */
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_IRQPHS
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQSR_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsphw_start_selection
parameter_list|(
name|sc
parameter_list|,
name|cb
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|slccb
modifier|*
name|cb
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
init|=
name|cb
operator|->
name|ti
decl_stmt|;
specifier|register
name|u_int8_t
name|arbs
decl_stmt|,
name|ph
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tout
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|callout_handle
name|ch
decl_stmt|;
endif|#
directive|endif
comment|/* check bus free */
if|if
condition|(
name|slp
operator|->
name|sl_disc
operator|>
literal|0
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ph
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|!=
name|SCBUSMON_FREE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|SCSI_LOW_START_FAIL
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* start arbitration */
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_ARBSTART
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_ARBITS
argument_list|,
name|ARBITS_EXEC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ch
operator|=
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
comment|/* XXX: what a stupid chip! */
name|arbs
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_ARBITS
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|arbs
operator|&
operator|(
name|ARBITS_WIN
operator||
name|ARBITS_FAIL
operator|)
operator|)
operator|==
literal|0
operator|&&
name|tout
operator|==
literal|0
condition|)
do|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tout
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arbs
operator|&
name|ARBITS_WIN
operator|)
operator|==
literal|0
condition|)
block|{
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_ARBITS
argument_list|,
name|ARBITS_CLR
argument_list|)
expr_stmt|;
return|return
name|SCSI_LOW_START_FAIL
return|;
block|}
comment|/* assert select line */
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_SELSTART
argument_list|)
expr_stmt|;
name|scsi_low_arbit_win
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_DATA
argument_list|,
name|sc
operator|->
name|sc_idbit
operator||
operator|(
literal|1
operator|<<
name|ti
operator|->
name|ti_id
operator|)
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|SCBUSCR_SEL
operator||
name|SCBUSCR_BSY
operator||
name|sc
operator|->
name|sc_busc
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|SCBUSCR_SEL
operator||
name|SCBUSCR_BSY
operator||
name|SCBUSCR_DOUT
operator||
name|sc
operator|->
name|sc_busc
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_ARBITS
argument_list|,
name|ARBITS_CLR
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|SCBUSCR_SEL
operator||
name|SCBUSCR_DOUT
operator||
name|sc
operator|->
name|sc_busc
argument_list|)
expr_stmt|;
comment|/* check selection timeout */
name|nsp_start_timer
argument_list|(
name|sc
argument_list|,
literal|1000
operator|/
literal|51
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_seltout
operator|=
literal|1
expr_stmt|;
return|return
name|SCSI_LOW_START_OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_world_start
parameter_list|(
name|sc
parameter_list|,
name|fdone
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|fdone
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|intrmask_t
name|s
decl_stmt|;
name|s
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_cnt
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_seltout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|sl_cfgflags
operator|&
name|CFG_NOATTEN
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_busc
operator|=
name|SCBUSCR_ATN
expr_stmt|;
else|else
name|sc
operator|->
name|sc_busc
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_icr
operator|=
operator|(
name|SCIENR_SCCHG
operator||
name|SCIENR_RESEL
operator||
name|SCIENR_RST
operator|)
expr_stmt|;
name|nsphw_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|scsi_low_bus_reset
argument_list|(
name|slp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SOFT_INTR_REQUIRED
argument_list|(
name|slp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|ncp_synch_data
block|{
name|u_int
name|min_period
decl_stmt|;
name|u_int
name|max_period
decl_stmt|;
name|u_int
name|chip_period
decl_stmt|;
name|u_int
name|ack_width
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ncp_synch_data
name|ncp_sync_data_40M
index|[]
init|=
block|{
block|{
literal|0x0c
block|,
literal|0x0c
block|,
literal|0x1
block|,
literal|0
block|}
block|,
comment|/* 20MB  50ns*/
block|{
literal|0x19
block|,
literal|0x19
block|,
literal|0x3
block|,
literal|1
block|}
block|,
comment|/* 10MB  100ns*/
block|{
literal|0x1a
block|,
literal|0x25
block|,
literal|0x5
block|,
literal|2
block|}
block|,
comment|/* 7.5MB 150ns*/
block|{
literal|0x26
block|,
literal|0x32
block|,
literal|0x7
block|,
literal|3
block|}
block|,
comment|/* 5MB   200ns*/
block|{
literal|0x0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ncp_synch_data
name|ncp_sync_data_20M
index|[]
init|=
block|{
block|{
literal|0x19
block|,
literal|0x19
block|,
literal|0x1
block|,
literal|0
block|}
block|,
comment|/* 10MB  100ns*/
block|{
literal|0x1a
block|,
literal|0x25
block|,
literal|0x2
block|,
literal|0
block|}
block|,
comment|/* 7.5MB 150ns*/
block|{
literal|0x26
block|,
literal|0x32
block|,
literal|0x3
block|,
literal|1
block|}
block|,
comment|/* 5MB   200ns*/
block|{
literal|0x0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nsp_msg
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|,
name|msg
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|msg
decl_stmt|;
block|{
name|struct
name|ncp_synch_data
modifier|*
name|sdp
decl_stmt|;
name|struct
name|lun_info
modifier|*
name|li
init|=
name|ti
operator|->
name|ti_li
decl_stmt|;
name|struct
name|nsp_lun_info
modifier|*
name|nli
init|=
operator|(
name|void
operator|*
operator|)
name|li
decl_stmt|;
name|u_int
name|period
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|msg
operator|&
name|SCSI_LOW_MSG_SYNCH
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|period
operator|=
name|li
operator|->
name|li_maxsynch
operator|.
name|period
expr_stmt|;
name|offset
operator|=
name|li
operator|->
name|li_maxsynch
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_iclkdiv
operator|==
name|CLKDIVR_20M
condition|)
name|sdp
operator|=
operator|&
name|ncp_sync_data_20M
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sdp
operator|=
operator|&
name|ncp_sync_data_40M
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sdp
operator|->
name|max_period
operator|!=
literal|0
condition|;
name|i
operator|++
operator|,
name|sdp
operator|++
control|)
block|{
if|if
condition|(
name|period
operator|>=
name|sdp
operator|->
name|min_period
operator|&&
name|period
operator|<=
name|sdp
operator|->
name|max_period
condition|)
break|break;
block|}
if|if
condition|(
name|period
operator|!=
literal|0
operator|&&
name|sdp
operator|->
name|max_period
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NO proper period/offset found, 		 * Retry neg with the target. 		 */
name|li
operator|->
name|li_maxsynch
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|li
operator|->
name|li_maxsynch
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|nli
operator|->
name|nli_reg_syncr
operator|=
literal|0
expr_stmt|;
name|nli
operator|->
name|nli_reg_ackwidth
operator|=
literal|0
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|nli
operator|->
name|nli_reg_syncr
operator|=
operator|(
name|sdp
operator|->
name|chip_period
operator|<<
name|SYNCR_PERS
operator|)
operator||
operator|(
name|offset
operator|&
name|SYNCR_OFFM
operator|)
expr_stmt|;
name|nli
operator|->
name|nli_reg_ackwidth
operator|=
name|sdp
operator|->
name|ack_width
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_lun_init
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|,
name|li
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|lun_info
modifier|*
name|li
decl_stmt|;
block|{
name|struct
name|nsp_lun_info
modifier|*
name|nli
init|=
operator|(
name|void
operator|*
operator|)
name|li
decl_stmt|;
name|li
operator|->
name|li_maxsynch
operator|.
name|period
operator|=
literal|200
operator|/
literal|4
expr_stmt|;
name|li
operator|->
name|li_maxsynch
operator|.
name|offset
operator|=
literal|15
expr_stmt|;
name|nli
operator|->
name|nli_reg_syncr
operator|=
literal|0
expr_stmt|;
name|nli
operator|->
name|nli_reg_ackwidth
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|nsp_start_timer
parameter_list|(
name|sc
parameter_list|,
name|time
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|time
decl_stmt|;
block|{
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|sc
operator|->
name|sc_timer
operator|=
name|time
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TIMERCNT
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************  * General probe attach  **************************************************************/
end_comment

begin_function
name|int
name|nspprobesubr
parameter_list|(
name|iot
parameter_list|,
name|ioh
parameter_list|,
name|dvcfg
parameter_list|)
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|u_int
name|dvcfg
decl_stmt|;
block|{
name|u_int8_t
name|regv
decl_stmt|;
name|regv
operator|=
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
name|nsp_fifosr
argument_list|)
expr_stmt|;
if|if
condition|(
name|regv
operator|<
literal|0x11
operator|||
name|regv
operator|>=
literal|0x20
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|nspprint
parameter_list|(
name|aux
parameter_list|,
name|name
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: scsibus "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|UNCONF
return|;
block|}
end_function

begin_function
name|void
name|nspattachsubr
parameter_list|(
name|sc
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_idbit
operator|=
operator|(
literal|1
operator|<<
name|slp
operator|->
name|sl_hostid
operator|)
expr_stmt|;
name|slp
operator|->
name|sl_funcs
operator|=
operator|&
name|nspfuncs
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_memh
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_xmode
operator|=
name|NSP_MID_SMIT
expr_stmt|;
else|else
name|sc
operator|->
name|sc_xmode
operator|=
name|NSP_PIO
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_low_attach
argument_list|(
name|slp
argument_list|,
literal|2
argument_list|,
name|NSP_NTARGETS
argument_list|,
name|NSP_NLUNS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nsp_lun_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************  * PDMA functions  **************************************************************/
end_comment

begin_function
specifier|static
name|u_int
name|nsp_fifo_count
parameter_list|(
name|sc
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_PTCLRR
argument_list|,
name|PTCLRR_PT
argument_list|)
expr_stmt|;
name|count
operator|=
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_datar
argument_list|)
expr_stmt|;
name|count
operator|+=
operator|(
operator|(
operator|(
name|u_int
operator|)
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_datar
argument_list|)
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|count
operator|+=
operator|(
operator|(
operator|(
name|u_int
operator|)
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_datar
argument_list|)
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nsp_setup_fifo
parameter_list|(
name|sc
parameter_list|,
name|on
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|on
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|u_int8_t
name|xfermode
decl_stmt|;
if|if
condition|(
name|on
operator|!=
literal|0
condition|)
name|xfermode
operator|=
name|XFERMR_XEN
operator||
name|XFERMR_FIFOEN
expr_stmt|;
else|else
name|xfermode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mask
operator|=
literal|0
expr_stmt|;
name|xfermode
operator||=
name|XFERMR_IO8
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_mask
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xmode
operator|==
name|NSP_MID_SMIT
condition|)
name|xfermode
operator||=
name|XFERMR_MEM32
expr_stmt|;
else|else
name|xfermode
operator||=
name|XFERMR_IO32
expr_stmt|;
block|}
name|sc
operator|->
name|sc_xfermr
operator|=
name|xfermode
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_XFERMR
argument_list|,
name|sc
operator|->
name|sc_xfermr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|nsp_pdma_end
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|slccb
modifier|*
name|cb
init|=
name|ti
operator|->
name|ti_nexus
decl_stmt|;
name|u_int
name|len
init|=
literal|0
decl_stmt|,
name|cnt
decl_stmt|;
name|slp
operator|->
name|sl_flags
operator|&=
operator|~
name|HW_PDMASTART
expr_stmt|;
name|nsp_setup_fifo
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_phase
operator|==
name|PH_DATA
condition|)
block|{
name|cnt
operator|=
name|nsp_fifo_count
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_direction
operator|==
name|SCSI_LOW_WRITE
condition|)
block|{
name|len
operator|=
name|sc
operator|->
name|sc_cnt
operator|-
name|cnt
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|+
name|len
operator|<=
name|cb
operator|->
name|ccb_scp
operator|.
name|scp_datalen
condition|)
block|{
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
operator|-=
name|len
expr_stmt|;
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
name|printf
argument_list|(
literal|"%s len %x>= datalen %x\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
name|len
argument_list|,
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_direction
operator|==
name|SCSI_LOW_READ
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_cnt
operator|!=
name|cnt
condition|)
block|{
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
name|printf
argument_list|(
literal|"%s: data read count error %x != %x\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
name|sc
operator|->
name|sc_cnt
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_cnt
operator|=
name|cnt
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s data phase miss\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|RFIFO_CRIT
value|64
end_define

begin_define
define|#
directive|define
name|WFIFO_CRIT
value|64
end_define

begin_function
specifier|static
name|void
name|nsp_pio_read
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tout
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|callout_handle
name|ch
decl_stmt|;
endif|#
directive|endif
name|u_int
name|res
decl_stmt|,
name|ocount
decl_stmt|,
name|mask
init|=
name|sc
operator|->
name|sc_mask
decl_stmt|;
name|u_int8_t
name|stat
decl_stmt|,
name|fstat
decl_stmt|;
name|slp
operator|->
name|sl_flags
operator||=
name|HW_PDMASTART
expr_stmt|;
name|ocount
operator|=
name|sc
operator|->
name|sc_cnt
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ch
operator|=
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|>
literal|0
operator|&&
name|tout
operator|==
literal|0
condition|)
block|{
name|stat
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSMON
argument_list|)
expr_stmt|;
name|stat
operator|&=
name|SCBUSMON_PHMASK
expr_stmt|;
name|res
operator|=
name|nsp_fifo_count
argument_list|(
name|sc
argument_list|)
operator|-
name|ocount
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
operator|==
name|PHASE_DATAIN
condition|)
continue|continue;
break|break;
block|}
name|fstat
operator|=
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_fifosr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstat
operator|&
name|FIFOSR_FULLEMP
operator|)
operator|==
literal|0
operator|&&
name|stat
operator|==
name|PHASE_DATAIN
condition|)
continue|continue;
if|if
condition|(
name|res
operator|>
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
condition|)
break|break;
if|if
condition|(
name|res
operator|>=
name|NSP_BUFFER_SIZE
condition|)
name|res
operator|=
name|NSP_BUFFER_SIZE
expr_stmt|;
else|else
name|res
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfermr
operator|&
name|XFERMR_MEM32
condition|)
block|{
name|bus_space_read_region_4
argument_list|(
name|sc
operator|->
name|sc_memt
argument_list|,
name|sc
operator|->
name|sc_memh
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
argument_list|,
name|res
operator|>>
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|bus_space_read_multi_4
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_fifodr
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
argument_list|,
name|res
operator|>>
literal|2
argument_list|)
expr_stmt|;
else|else
name|bus_space_read_multi_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_fifodr
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
operator|+=
name|res
expr_stmt|;
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|-=
name|res
expr_stmt|;
name|ocount
operator|+=
name|res
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cnt
operator|=
name|ocount
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tout
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s pio read timeout\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nsp_pio_write
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|u_int
name|res
decl_stmt|,
name|ocount
decl_stmt|,
name|mask
init|=
name|sc
operator|->
name|sc_mask
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tout
init|=
literal|0
decl_stmt|;
specifier|register
name|u_int8_t
name|stat
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|callout_handle
name|ch
decl_stmt|;
endif|#
directive|endif
name|ocount
operator|=
name|sc
operator|->
name|sc_cnt
expr_stmt|;
name|slp
operator|->
name|sl_flags
operator||=
name|HW_PDMASTART
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ch
operator|=
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|>
literal|0
operator|&&
name|tout
operator|==
literal|0
condition|)
block|{
name|stat
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSMON
argument_list|)
expr_stmt|;
name|stat
operator|&=
name|SCBUSMON_PHMASK
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|PHASE_DATAOUT
condition|)
break|break;
name|res
operator|=
name|ocount
operator|-
name|nsp_fifo_count
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
continue|continue;
name|res
operator|=
operator|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|>
name|WFIFO_CRIT
operator|)
condition|?
name|WFIFO_CRIT
else|:
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xfermr
operator|&
name|XFERMR_MEM32
condition|)
block|{
name|bus_space_write_region_4
argument_list|(
name|sc
operator|->
name|sc_memt
argument_list|,
name|sc
operator|->
name|sc_memh
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
argument_list|,
name|res
operator|>>
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|bus_space_write_multi_4
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_fifodr
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
argument_list|,
name|res
operator|>>
literal|2
argument_list|)
expr_stmt|;
else|else
name|bus_space_write_multi_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_fifodr
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|-=
name|res
expr_stmt|;
name|slp
operator|->
name|sl_scp
operator|.
name|scp_data
operator|+=
name|res
expr_stmt|;
name|ocount
operator|+=
name|res
expr_stmt|;
block|}
name|sc
operator|->
name|sc_cnt
operator|=
name|ocount
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tout
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s pio write timeout\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|settimeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
modifier|*
name|tout
init|=
name|arg
decl_stmt|;
operator|*
name|tout
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_negate_signal
parameter_list|(
name|sc
parameter_list|,
name|mask
parameter_list|,
name|s
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|mask
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|int
name|tout
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|callout_handle
name|ch
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
name|regv
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ch
operator|=
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|timeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|regv
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|regv
operator|==
literal|0xff
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|regv
operator|&
name|mask
operator|)
operator|!=
literal|0
operator|&&
name|tout
operator|==
literal|0
condition|)
do|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|tout
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|settimeout
argument_list|,
operator|&
name|tout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s singla off timeout \n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_xfer
parameter_list|(
name|sc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|phase
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|phase
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|rv
decl_stmt|,
name|atn
decl_stmt|;
name|atn
operator|=
operator|(
name|scsi_low_is_msgout_continue
argument_list|(
name|slp
operator|->
name|sl_nexus
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|ptr
operator|++
control|)
block|{
name|rv
operator|=
name|nsp_expect_signal
argument_list|(
name|sc
argument_list|,
name|phase
argument_list|,
name|SCBUSMON_REQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|atn
operator|==
literal|0
condition|)
block|{
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|SCBUSCR_ADIR
operator||
name|SCBUSCR_ACKEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phase
operator|&
name|SCBUSMON_IO
condition|)
block|{
name|buf
index|[
name|ptr
index|]
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_DATAACK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_DATAACK
argument_list|,
name|buf
index|[
name|ptr
index|]
argument_list|)
expr_stmt|;
block|}
name|nsp_negate_signal
argument_list|(
name|sc
argument_list|,
name|SCBUSMON_ACK
argument_list|,
literal|"xfer<ACK>"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_dataphase_bypass
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|slccb
modifier|*
name|cb
init|=
name|ti
operator|->
name|ti_nexus
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
if|if
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_direction
operator|!=
name|SCSI_LOW_READ
operator|||
operator|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|%
name|DEV_BSIZE
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|cnt
operator|=
name|nsp_fifo_count
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cnt
operator|==
name|cnt
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cnt
operator|>=
name|DEV_BSIZE
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	 * XXX: NSP_QUIRK 	 * Data phase skip only occures in case of SCSI_LOW_READ. 	 */
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_DATA
argument_list|)
expr_stmt|;
name|nsp_pio_read
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|nsp_pdma_end
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NSP_STATICS
name|nsp_statics
index|[
name|ti
operator|->
name|ti_id
index|]
operator|.
name|data_phase_bypass
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* NSP_STATICS */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * disconnect& reselect (HW low)  **************************************************************/
end_comment

begin_function
specifier|static
name|int
name|nsp_reselected
parameter_list|(
name|sc
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|sid
decl_stmt|;
name|u_int8_t
name|cr
decl_stmt|;
name|sid
operator|=
operator|(
name|u_int
operator|)
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_RESELR
argument_list|)
expr_stmt|;
name|sid
operator|&=
operator|~
name|sc
operator|->
name|sc_idbit
expr_stmt|;
name|sid
operator|=
name|ffs
argument_list|(
name|sid
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|=
name|scsi_low_reselected
argument_list|(
name|slp
argument_list|,
name|sid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EJUSTRETURN
return|;
name|nsp_negate_signal
argument_list|(
name|sc
argument_list|,
name|SCBUSMON_SEL
argument_list|,
literal|"reselect<SEL>"
argument_list|)
expr_stmt|;
name|cr
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|)
operator|&
operator|~
operator|(
name|SCBUSCR_BSY
operator||
name|SCBUSCR_ATN
operator|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|cr
operator||
name|SCBUSCR_ADIR
operator||
name|SCBUSCR_ACKEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NSP_STATICS
name|nsp_statics
index|[
name|sid
index|]
operator|.
name|reselect
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* NSP_STATCIS */
return|return
name|EJUSTRETURN
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nsp_disconnected
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
ifdef|#
directive|ifdef
name|NSP_STATICS
if|if
condition|(
name|slp
operator|->
name|sl_msgphase
operator|==
name|MSGPH_DISC
condition|)
name|nsp_statics
index|[
name|ti
operator|->
name|ti_id
index|]
operator|.
name|disconnect
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* NSP_STATICS */
name|scsi_low_disconnected
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**************************************************************  * SEQUENCER  **************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|void
name|nspmsg
name|__P
argument_list|(
operator|(
expr|struct
name|nsp_softc
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int8_t
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nspmsg
parameter_list|(
name|sc
parameter_list|,
name|s
parameter_list|,
name|isrc
parameter_list|,
name|ph
parameter_list|,
name|irqphs
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|;
name|u_int8_t
name|isrc
decl_stmt|,
name|ph
decl_stmt|,
name|irqphs
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: isrc 0x%x scmon 0x%x irqphs 0x%x\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
operator|(
name|u_int
operator|)
name|isrc
argument_list|,
operator|(
name|u_int
operator|)
name|ph
argument_list|,
operator|(
name|u_int
operator|)
name|irqphs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nsp_nexus
parameter_list|(
name|sc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|nsp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|struct
name|nsp_lun_info
modifier|*
name|nli
init|=
operator|(
name|void
operator|*
operator|)
name|ti
operator|->
name|ti_li
decl_stmt|;
comment|/* setup synch transfer registers */
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SYNCR
argument_list|,
name|nli
operator|->
name|nli_reg_syncr
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_ACKWIDTH
argument_list|,
name|nli
operator|->
name|nli_reg_ackwidth
argument_list|)
expr_stmt|;
comment|/* setup pdma fifo */
name|nsp_setup_fifo
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* clear ack counter */
name|sc
operator|->
name|sc_cnt
operator|=
literal|0
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_PTCLRR
argument_list|,
name|PTCLRR_PT
operator||
name|PTCLRR_ACK
operator||
name|PTCLRR_REQ
operator||
name|PTCLRR_HOST
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nspintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|nsp_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|sc
operator|->
name|sc_sclow
decl_stmt|;
name|bus_space_tag_t
name|bst
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|bsh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|physio_proc
modifier|*
name|pp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rv
decl_stmt|;
name|u_int8_t
name|isrc
decl_stmt|,
name|ph
decl_stmt|,
name|irqphs
decl_stmt|,
name|cr
decl_stmt|,
name|regv
decl_stmt|;
comment|/******************************************* 	 * interrupt check 	 *******************************************/
if|if
condition|(
name|slp
operator|->
name|sl_flags
operator|&
name|HW_INACTIVE
condition|)
return|return
literal|0
return|;
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQCR_IRQDIS
argument_list|)
expr_stmt|;
name|isrc
operator|=
name|bus_space_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|==
literal|0xff
operator|||
operator|(
name|isrc
operator|&
name|IRQSR_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXX: IMPORTANT  	 * Do not read an irqphs register if no scsi phase interrupt. 	 * Unless, you should lose a scsi phase interrupt. 	 */
name|ph
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSMON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isrc
operator|&
name|IRQSR_SCSI
operator|)
operator|!=
literal|0
condition|)
block|{
name|irqphs
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_IRQPHS
argument_list|)
expr_stmt|;
block|}
else|else
name|irqphs
operator|=
literal|0
expr_stmt|;
comment|/*  	 * timer interrupt handler (scsi vs timer interrupts) 	 */
if|if
condition|(
name|sc
operator|->
name|sc_timer
operator|!=
literal|0
condition|)
block|{
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TIMERCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_TIMERCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_timer
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|isrc
operator|&
name|IRQSR_MASK
operator|)
operator|==
name|IRQSR_TIMER
operator|&&
name|sc
operator|->
name|sc_seltout
operator|==
literal|0
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQCR_TIMERCL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQCR_TIMERCL
operator||
name|IRQCR_FIFOCL
argument_list|)
expr_stmt|;
comment|/******************************************* 	 * debug section 	 *******************************************/
ifdef|#
directive|ifdef
name|NSP_DEBUG
if|if
condition|(
name|nsp_debug
condition|)
block|{
name|nspmsg
argument_list|(
name|sc
argument_list|,
literal|"current status"
argument_list|,
name|isrc
argument_list|,
name|ph
argument_list|,
name|irqphs
argument_list|)
expr_stmt|;
name|scsi_low_print
argument_list|(
name|slp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp_debug
operator|>
literal|1
condition|)
name|Debugger
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NSP_DEBUG */
comment|/******************************************* 	 * Parse hardware SCSI irq reasons register 	 *******************************************/
if|if
condition|(
operator|(
name|isrc
operator|&
name|IRQSR_SCSI
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|irqphs
operator|&
name|IRQPHS_RST
operator|)
operator|!=
literal|0
condition|)
block|{
name|scsi_low_restart
argument_list|(
name|slp
argument_list|,
name|SCSI_LOW_RESTART_SOFT
argument_list|,
literal|"bus reset (power off?)"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|irqphs
operator|&
name|IRQPHS_RSEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|nsp_irqcr
argument_list|,
name|IRQCR_RESCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp_reselected
argument_list|(
name|sc
argument_list|)
operator|==
name|EJUSTRETURN
condition|)
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|irqphs
operator|&
operator|(
name|IRQPHS_PCHG
operator||
name|IRQPHS_LBF
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/******************************************* 	 * nexus check 	 *******************************************/
if|if
condition|(
operator|(
name|ti
operator|=
name|slp
operator|->
name|sl_nexus
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* unknown scsi phase changes */
name|nspmsg
argument_list|(
name|sc
argument_list|,
literal|"unknown scsi phase changes"
argument_list|,
name|isrc
argument_list|,
name|ph
argument_list|,
name|irqphs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/******************************************* 	 * aribitration& selection 	 *******************************************/
switch|switch
condition|(
name|ti
operator|->
name|ti_phase
condition|)
block|{
case|case
name|PH_SELSTART
case|:
if|if
condition|(
operator|(
name|ph
operator|&
name|SCBUSMON_BSY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_seltout
operator|>=
name|NSP_SELTIMEOUT
condition|)
block|{
name|sc
operator|->
name|sc_seltout
operator|=
literal|0
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|nsp_disconnected
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
return|;
block|}
name|sc
operator|->
name|sc_seltout
operator|++
expr_stmt|;
name|nsp_start_timer
argument_list|(
name|sc
argument_list|,
literal|1000
operator|/
literal|51
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* attention assert */
name|sc
operator|->
name|sc_seltout
operator|=
literal|0
expr_stmt|;
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_SELECTED
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|sc
operator|->
name|sc_busc
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|sc
operator|->
name|sc_busc
operator||
name|SCBUSCR_ADIR
operator||
name|SCBUSCR_ACKEN
argument_list|)
expr_stmt|;
name|SCSI_LOW_TARGET_ASSERT_ATN
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|scsi_low_assert_msg
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|,
name|SCSI_LOW_MSG_IDENTIFY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PH_RESEL
case|:
if|if
condition|(
operator|(
name|ph
operator|&
name|SCBUSMON_PHMASK
operator|)
operator|!=
name|PHASE_MSGIN
condition|)
block|{
name|scsi_low_assert_msg
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|,
name|SCSI_LOW_MSG_ABORT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fall */
default|default:
if|if
condition|(
operator|(
name|isrc
operator|&
operator|(
name|IRQSR_SCSI
operator||
name|IRQSR_FIFO
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
comment|/******************************************* 	 * scsi seq 	 *******************************************/
if|if
condition|(
name|slp
operator|->
name|sl_flags
operator|&
name|HW_PDMASTART
condition|)
name|nsp_pdma_end
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
comment|/* normal disconnect */
if|if
condition|(
name|slp
operator|->
name|sl_msgphase
operator|!=
literal|0
operator|&&
operator|(
name|irqphs
operator|&
name|IRQPHS_LBF
operator|)
operator|!=
literal|0
condition|)
return|return
name|nsp_disconnected
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
return|;
comment|/* check unexpected bus free state */
if|if
condition|(
name|ph
operator|==
literal|0
condition|)
block|{
name|nspmsg
argument_list|(
name|sc
argument_list|,
literal|"unexpected bus free"
argument_list|,
name|isrc
argument_list|,
name|ph
argument_list|,
name|irqphs
argument_list|)
expr_stmt|;
return|return
name|nsp_disconnected
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
return|;
block|}
comment|/* check normal scsi phase */
switch|switch
condition|(
name|ph
operator|&
name|SCBUSMON_PHMASK
condition|)
block|{
case|case
name|PHASE_CMD
case|:
if|if
condition|(
operator|(
name|ph
operator|&
name|SCBUSMON_REQ
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_low_cmd
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_CMDCR
argument_list|,
name|CMDCR_PTCLR
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|slp
operator|->
name|sl_scp
operator|.
name|scp_cmdlen
condition|;
name|len
operator|++
control|)
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_CMDDR
argument_list|,
name|slp
operator|->
name|sl_scp
operator|.
name|scp_cmd
index|[
name|len
index|]
argument_list|)
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_CMDCR
argument_list|,
name|CMDCR_PTCLR
operator||
name|CMDCR_EXEC
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_DATAOUT
case|:
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_low_data
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|,
operator|&
name|bp
argument_list|,
name|SCSI_LOW_WRITE
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|pp
operator|=
name|physio_proc_enter
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nsp_pio_write
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|physio_proc_leave
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_DATAIN
case|:
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_low_data
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|,
operator|&
name|bp
argument_list|,
name|SCSI_LOW_READ
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|pp
operator|=
name|physio_proc_enter
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nsp_pio_read
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
name|physio_proc_leave
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_STATUS
case|:
name|nsp_dataphase_bypass
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|&
name|SCBUSMON_REQ
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_STAT
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_status
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_DATAACK
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_MSGOUT
case|:
if|if
condition|(
operator|(
name|ph
operator|&
name|SCBUSMON_REQ
operator|)
operator|==
literal|0
condition|)
goto|goto
name|timerout
goto|;
comment|/* 		 * XXX: NSP QUIRK 		 * NSP invoke interrupts only in the case of scsi phase changes, 		 * therefore we should poll the scsi phase here to catch  		 * the next "msg out" if exists (no scsi phase changes). 		 */
name|rv
operator|=
name|len
operator|=
literal|16
expr_stmt|;
do|do
block|{
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_MSGOUT
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsi_low_msgout
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp_xfer
argument_list|(
name|sc
argument_list|,
name|ti
operator|->
name|ti_msgoutstr
argument_list|,
name|len
argument_list|,
name|PHASE_MSGOUT
argument_list|)
condition|)
block|{
name|scsi_low_assert_msg
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|,
name|SCSI_LOW_MSG_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nspmsg
argument_list|(
name|sc
argument_list|,
literal|"MSGOUT: xfer short"
argument_list|,
name|isrc
argument_list|,
name|ph
argument_list|,
name|irqphs
argument_list|)
expr_stmt|;
block|}
comment|/* catch a next signal */
name|rv
operator|=
name|nsp_expect_signal
argument_list|(
name|sc
argument_list|,
name|PHASE_MSGOUT
argument_list|,
name|SCBUSMON_REQ
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>
literal|0
operator|&&
name|len
operator|--
operator|>
literal|0
condition|)
do|;
break|break;
case|case
name|PHASE_MSGIN
case|:
name|nsp_dataphase_bypass
argument_list|(
name|sc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ph
operator|&
name|SCBUSMON_REQ
operator|)
operator|==
literal|0
condition|)
goto|goto
name|timerout
goto|;
name|SCSI_LOW_SETUP_PHASE
argument_list|(
name|ti
argument_list|,
name|PH_MSGIN
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: NSP QUIRK 		 * NSP invoke interrupts only in the case of scsi phase changes, 		 * therefore we should poll the scsi phase here to catch  		 * the next "msg in" if exists (no scsi phase changes). 		 */
name|rv
operator|=
name|len
operator|=
literal|16
expr_stmt|;
do|do
block|{
comment|/* read a data */
name|regv
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_DATA
argument_list|)
expr_stmt|;
comment|/* assert ack */
name|cr
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|)
expr_stmt|;
name|cr
operator||=
name|SCBUSCR_ACK
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|nsp_negate_signal
argument_list|(
name|sc
argument_list|,
name|SCBUSMON_REQ
argument_list|,
literal|"msgin<REQ>"
argument_list|)
expr_stmt|;
name|scsi_low_msgin
argument_list|(
name|slp
argument_list|,
name|ti
argument_list|,
name|regv
argument_list|)
expr_stmt|;
comment|/* deassert ack */
name|cr
operator|=
name|nsp_cr_read_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|)
expr_stmt|;
name|cr
operator|&=
operator|~
name|SCBUSCR_ACK
expr_stmt|;
name|nsp_cr_write_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|NSPR_SCBUSCR
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* catch a next signal */
name|rv
operator|=
name|nsp_expect_signal
argument_list|(
name|sc
argument_list|,
name|PHASE_MSGIN
argument_list|,
name|SCBUSMON_REQ
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|>
literal|0
operator|&&
name|len
operator|--
operator|>
literal|0
condition|)
do|;
break|break;
case|case
name|PHASE_SEL
case|:
default|default:
name|nspmsg
argument_list|(
name|sc
argument_list|,
literal|"unknown scsi phase"
argument_list|,
name|isrc
argument_list|,
name|ph
argument_list|,
name|irqphs
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|1
return|;
name|timerout
label|:
name|nsp_start_timer
argument_list|(
name|sc
argument_list|,
literal|1000
operator|/
literal|102
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

