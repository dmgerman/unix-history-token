begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2010, LSI Corp.  * All rights reserved.  * Author : Manjunath Ranganathaiah  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of the<ORGANIZATION> nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/tws/tws.h>
end_include

begin_include
include|#
directive|include
file|<dev/tws/tws_hdm.h>
end_include

begin_include
include|#
directive|include
file|<dev/tws/tws_services.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_function_decl
name|void
name|tws_q_insert_tail
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tws_request
modifier|*
name|tws_q_remove_request
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tws_request
modifier|*
name|tws_q_remove_head
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tws_q_insert_head
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tws_request
modifier|*
name|tws_q_remove_tail
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tws_print_stats
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tws_sense
modifier|*
name|tws_find_sense_from_mfa
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int64_t
name|mfa
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|error_desc
name|array
index|[]
init|=
block|{
block|{
literal|"Cannot add sysctl tree node"
block|,
literal|0x2000
block|,
name|ERROR
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Register window not available"
block|,
literal|0x2001
block|,
name|ERROR
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Can't allocate register window"
block|,
literal|0x2002
block|,
name|ERROR
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Can't allocate interrupt"
block|,
literal|0x2003
block|,
name|ERROR
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Can't set up interrupt"
block|,
literal|0x2004
block|,
name|ERROR
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Couldn't intialize CAM"
block|,
literal|0x2007
block|,
name|ERROR
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Couldn't create SIM device queue"
block|,
literal|0x2100
block|,
name|ENOMEM
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Unable to  create SIM entry"
block|,
literal|0x2101
block|,
name|ENOMEM
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Unable to  register the bus"
block|,
literal|0x2102
block|,
name|ENXIO
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Unable to  create the path"
block|,
literal|0x2103
block|,
name|ENXIO
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Bus scan request to CAM failed"
block|,
literal|0x2104
block|,
name|ENXIO
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Unable to intialize the driver"
block|,
literal|0x2008
block|,
name|ENXIO
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|,
block|{
literal|"Unable to intialize the controller"
block|,
literal|0x2009
block|,
name|ENXIO
block|,
literal|"%s: (0x%02X: 0x%04X): %s:\n"
block|,
literal|"ERROR"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|tws_trace
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|fun
parameter_list|,
name|int
name|linenum
parameter_list|,
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|desc
parameter_list|,
name|u_int64_t
name|val1
parameter_list|,
name|u_int64_t
name|val2
parameter_list|)
block|{
name|struct
name|tws_trace_rec
modifier|*
name|rec
init|=
operator|(
expr|struct
name|tws_trace_rec
operator|*
operator|)
name|sc
operator|->
name|trace_q
operator|.
name|q
decl_stmt|;
specifier|volatile
name|u_int16_t
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|char
name|fmt
index|[
literal|256
index|]
decl_stmt|;
name|head
operator|=
name|sc
operator|->
name|trace_q
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|trace_q
operator|.
name|tail
expr_stmt|;
comment|/*     getnanotime(&rec[tail].ts); */
name|strncpy
argument_list|(
name|rec
index|[
name|tail
index|]
operator|.
name|fname
argument_list|,
name|file
argument_list|,
name|TWS_TRACE_FNAME_LEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|rec
index|[
name|tail
index|]
operator|.
name|func
argument_list|,
name|fun
argument_list|,
name|TWS_TRACE_FUNC_LEN
argument_list|)
expr_stmt|;
name|rec
index|[
name|tail
index|]
operator|.
name|linenum
operator|=
name|linenum
expr_stmt|;
name|strncpy
argument_list|(
name|rec
index|[
name|tail
index|]
operator|.
name|desc
argument_list|,
name|desc
argument_list|,
name|TWS_TRACE_DESC_LEN
argument_list|)
expr_stmt|;
name|rec
index|[
name|tail
index|]
operator|.
name|val1
operator|=
name|val1
expr_stmt|;
name|rec
index|[
name|tail
index|]
operator|.
name|val2
operator|=
name|val2
expr_stmt|;
name|tail
operator|=
operator|(
name|tail
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|trace_q
operator|.
name|depth
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|tail
condition|)
block|{
name|sc
operator|->
name|trace_q
operator|.
name|overflow
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|trace_q
operator|.
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|trace_q
operator|.
name|depth
expr_stmt|;
block|}
name|sc
operator|->
name|trace_q
operator|.
name|tail
operator|=
name|tail
expr_stmt|;
comment|/*     tws_circular_q_insert(sc,&sc->trace_q,&rec, sizeof(struct tws_trace_rec)); */
if|if
condition|(
name|sc
operator|->
name|is64bit
condition|)
name|strcpy
argument_list|(
name|fmt
argument_list|,
literal|"%05d:%s::%s :%s: 0x%016lx : 0x%016lx \n"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|fmt
argument_list|,
literal|"%05d:%s::%s :%s: 0x%016llx : 0x%016llx \n"
argument_list|)
expr_stmt|;
comment|/*       printf("%05d:%s::%s :%s: 0x%016llx : 0x%016llx \n",              linenum, file, fun, desc, val1, val2); */
name|printf
argument_list|(
name|fmt
argument_list|,
name|linenum
argument_list|,
name|file
argument_list|,
name|fun
argument_list|,
name|desc
argument_list|,
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tws_log
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|device_printf
argument_list|(
operator|(
name|sc
operator|)
operator|->
name|tws_dev
argument_list|,
name|array
index|[
name|index
index|]
operator|.
name|fmt
argument_list|,
name|array
index|[
name|index
index|]
operator|.
name|error_str
argument_list|,
name|array
index|[
name|index
index|]
operator|.
name|error_code
argument_list|,
name|array
index|[
name|index
index|]
operator|.
name|severity_level
argument_list|,
name|array
index|[
name|index
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ----------- swap functions ----------- */
end_comment

begin_function
name|u_int16_t
name|tws_swap16
parameter_list|(
name|u_int16_t
name|val
parameter_list|)
block|{
return|return
operator|(
operator|(
name|val
operator|<<
literal|8
operator|)
operator||
operator|(
name|val
operator|>>
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|tws_swap32
parameter_list|(
name|u_int32_t
name|val
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|val
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|val
operator|<<
literal|8
operator|)
operator|&
operator|(
literal|0xFF0000
operator|)
operator|)
operator||
operator|(
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
operator|(
literal|0xFF00
operator|)
operator|)
operator||
operator|(
name|val
operator|>>
literal|24
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int64_t
name|tws_swap64
parameter_list|(
name|u_int64_t
name|val
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|tws_swap32
argument_list|(
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|val
operator|)
operator|)
operator|)
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|tws_swap32
argument_list|(
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|val
operator|)
operator|)
operator|)
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ----------- reg access ----------- */
end_comment

begin_function
name|void
name|tws_write_reg
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_int32_t
name|value
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|bus_tag
init|=
name|sc
operator|->
name|bus_tag
decl_stmt|;
name|bus_space_handle_t
name|bus_handle
init|=
name|sc
operator|->
name|bus_handle
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
name|bus_space_write_4
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
name|bus_space_write_2
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|,
operator|(
name|u_int16_t
operator|)
name|value
argument_list|)
expr_stmt|;
else|else
name|bus_space_write_1
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|,
operator|(
name|u_int8_t
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|tws_read_reg
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|bus_space_tag_t
name|bus_tag
init|=
name|sc
operator|->
name|bus_tag
decl_stmt|;
name|bus_space_handle_t
name|bus_handle
init|=
name|sc
operator|->
name|bus_handle
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|4
condition|)
return|return
operator|(
operator|(
name|u_int32_t
operator|)
name|bus_space_read_4
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|2
condition|)
return|return
operator|(
operator|(
name|u_int32_t
operator|)
name|bus_space_read_2
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|u_int32_t
operator|)
name|bus_space_read_1
argument_list|(
name|bus_tag
argument_list|,
name|bus_handle
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------- Q service --------------------- */
end_comment

begin_comment
comment|/*   * intialize q  pointers with null.  */
end_comment

begin_function
name|void
name|tws_init_qs
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TWS_MAX_QS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|q_head
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|q_tail
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called with lock held */
end_comment

begin_function
specifier|static
name|void
name|tws_insert2_empty_q
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|req
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|=
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|=
name|req
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called with lock held */
end_comment

begin_function
name|void
name|tws_q_insert_head
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|==
name|NULL
condition|)
block|{
name|tws_insert2_empty_q
argument_list|(
name|sc
argument_list|,
name|req
argument_list|,
name|q_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|req
operator|->
name|next
operator|=
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
expr_stmt|;
name|req
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|->
name|prev
operator|=
name|req
expr_stmt|;
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|=
name|req
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* called with lock held */
end_comment

begin_function
name|void
name|tws_q_insert_tail
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|==
name|NULL
condition|)
block|{
name|tws_insert2_empty_q
argument_list|(
name|sc
argument_list|,
name|req
argument_list|,
name|q_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|req
operator|->
name|prev
operator|=
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|->
name|next
operator|=
name|req
expr_stmt|;
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|=
name|req
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* called with lock held */
end_comment

begin_function
name|struct
name|tws_request
modifier|*
name|tws_q_remove_head
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
block|{
name|struct
name|tws_request
modifier|*
name|r
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|r
operator|=
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r
operator|->
name|next
operator|==
name|NULL
operator|&&
name|r
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* last element  */
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|=
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* called with lock held */
end_comment

begin_function
name|struct
name|tws_request
modifier|*
name|tws_q_remove_tail
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
block|{
name|struct
name|tws_request
modifier|*
name|r
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|r
operator|=
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|r
operator|->
name|next
operator|==
name|NULL
operator|&&
name|r
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* last element  */
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
operator|=
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
operator|=
name|r
operator|->
name|prev
expr_stmt|;
name|r
operator|->
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/* returns removed request if successful. return NULL otherwise */
end_comment

begin_comment
comment|/* called with lock held */
end_comment

begin_function
name|struct
name|tws_request
modifier|*
name|tws_q_remove_request
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
block|{
name|struct
name|tws_request
modifier|*
name|r
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"null req"
argument_list|,
literal|0
argument_list|,
name|q_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|==
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
condition|)
return|return
operator|(
name|tws_q_remove_head
argument_list|(
name|sc
argument_list|,
name|q_type
argument_list|)
operator|)
return|;
if|if
condition|(
name|req
operator|==
name|sc
operator|->
name|q_tail
index|[
name|q_type
index|]
condition|)
return|return
operator|(
name|tws_q_remove_tail
argument_list|(
name|sc
argument_list|,
name|q_type
argument_list|)
operator|)
return|;
comment|/* The given node is not at head or tail.      * It's in the middle and there are more than      * 2 elements on the q.      */
if|if
condition|(
name|req
operator|->
name|next
operator|==
name|NULL
operator|||
name|req
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"invalid req"
argument_list|,
literal|0
argument_list|,
name|q_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* debug only */
name|r
operator|=
name|sc
operator|->
name|q_head
index|[
name|q_type
index|]
expr_stmt|;
while|while
condition|(
name|r
condition|)
block|{
if|if
condition|(
name|req
operator|==
name|r
condition|)
break|break;
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"req not in q"
argument_list|,
literal|0
argument_list|,
name|req
operator|->
name|request_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* debug end */
name|req
operator|->
name|prev
operator|->
name|next
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|req
operator|->
name|next
operator|->
name|prev
operator|=
name|r
operator|->
name|prev
expr_stmt|;
name|req
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|req
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|tws_sense
modifier|*
name|tws_find_sense_from_mfa
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int64_t
name|mfa
parameter_list|)
block|{
name|struct
name|tws_sense
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
name|sc
argument_list|,
name|mfa
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|mfa
operator|-
name|sc
operator|->
name|dma_mem_phys
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|tws_command_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|tws_queue_depth
condition|)
block|{
name|s
operator|=
operator|&
name|sc
operator|->
name|sense_bufs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mfa
operator|==
name|s
operator|->
name|hdr_pkt_phy
condition|)
return|return
operator|(
name|s
operator|)
return|;
block|}
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"return null"
argument_list|,
literal|0
argument_list|,
name|mfa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------- Q service end --------------------- */
end_comment

begin_comment
comment|/* --------------------- misc service start --------------------- */
end_comment

begin_function
name|void
name|tws_print_stats
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|tws_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"reqs(in, out)"
argument_list|,
name|sc
operator|->
name|stats
operator|.
name|reqs_in
argument_list|,
name|sc
operator|->
name|stats
operator|.
name|reqs_out
argument_list|)
expr_stmt|;
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"reqs(err, intrs)"
argument_list|,
name|sc
operator|->
name|stats
operator|.
name|reqs_errored
argument_list|,
name|sc
operator|->
name|stats
operator|.
name|num_intrs
argument_list|)
expr_stmt|;
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"reqs(ioctls, scsi)"
argument_list|,
name|sc
operator|->
name|stats
operator|.
name|ioctls
argument_list|,
name|sc
operator|->
name|stats
operator|.
name|scsi_ios
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stats_timer
argument_list|,
literal|300
operator|*
name|hz
argument_list|,
name|tws_print_stats
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --------------------- misc service end --------------------- */
end_comment

end_unit

