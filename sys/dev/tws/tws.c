begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2010, LSI Corp.  * All rights reserved.  * Author : Manjunath Ranganathaiah  * Support: freebsdraid@lsi.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  * 3. Neither the name of the<ORGANIZATION> nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<dev/tws/tws.h>
end_include

begin_include
include|#
directive|include
file|<dev/tws/tws_services.h>
end_include

begin_include
include|#
directive|include
file|<dev/tws/tws_hdm.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TWS
argument_list|,
literal|"twsbuf"
argument_list|,
literal|"buffers used by tws driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tws_queue_depth
init|=
name|TWS_MAX_REQS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tws_enable_msi
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tws_enable_msix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* externs */
end_comment

begin_function_decl
specifier|extern
name|int
name|tws_cam_attach
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tws_cam_detach
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|tws_init_ctlr
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|tws_ctlr_ready
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tws_turn_off_interrupts
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tws_q_insert_tail
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|tws_request
modifier|*
name|tws_q_remove_request
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tws_request
modifier|*
name|req
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|tws_request
modifier|*
name|tws_q_remove_head
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|q_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|tws_get_response
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
modifier|*
name|req_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|boolean
name|tws_ctlr_reset
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|tws_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|tws_use_32bit_sgls
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|tws_request
modifier|*
name|tws_get_request
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tws_init_connect
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|mc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tws_send_event
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint8_t
name|tws_get_state
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tws_release_request
parameter_list|(
name|struct
name|tws_request
modifier|*
name|req
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|tws_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|tws_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|tws_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|tws_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|d_ioctl_t
name|tws_ioctl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|tws_init
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tws_dmamap_cmds_load_cbfn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tws_init_reqs
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|dma_mem_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tws_init_aen_q
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tws_init_trace_q
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tws_setup_irq
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tws_setup_intr
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irqs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tws_teardown_intr
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Character device entry points */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|tws_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|tws_open
block|,
operator|.
name|d_close
operator|=
name|tws_close
block|,
operator|.
name|d_read
operator|=
name|tws_read
block|,
operator|.
name|d_write
operator|=
name|tws_write
block|,
operator|.
name|d_ioctl
operator|=
name|tws_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"tws"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * In the cdevsw routines, we find our softc by using the si_drv1 member  * of struct cdev.  We set this variable to point to our softc in our  * attach routine when we create the /dev entry.  */
end_comment

begin_function
name|int
name|tws_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|sc
condition|)
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
name|dev
argument_list|,
name|oflags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tws_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|d_thread_t
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|sc
condition|)
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
name|dev
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tws_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|sc
condition|)
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
name|dev
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tws_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
if|if
condition|(
name|sc
condition|)
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
name|dev
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* PCI Support Functions */
end_comment

begin_comment
comment|/*  * Compare the device ID of this device against the IDs that this driver  * supports.  If there is a match, set the description and return success.  */
end_comment

begin_function
specifier|static
name|int
name|tws_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|static
name|u_int8_t
name|first_ctlr
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|TWS_VENDOR_ID
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|TWS_DEVICE_ID
operator|)
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"LSI 3ware SAS/SATA Storage Controller"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_ctlr
condition|)
block|{
name|printf
argument_list|(
literal|"LSI 3ware device driver for SAS/SATA storage "
literal|"controllers, version: %s\n"
argument_list|,
name|TWS_DRIVER_VERSION_STRING
argument_list|)
expr_stmt|;
name|first_ctlr
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attach function is only called if the probe is successful. */
end_comment

begin_function
specifier|static
name|int
name|tws_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|bar
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
comment|/* no tracing yet */
comment|/* Look up our softc and initialize its fields. */
name|sc
operator|->
name|tws_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Intialize mutexes */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|,
literal|"tws_q_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|,
literal|"tws_sim_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|,
literal|"tws_gen_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
literal|"tws_io_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tws_init_trace_q
argument_list|(
name|sc
argument_list|)
operator|==
name|FAILURE
condition|)
name|printf
argument_list|(
literal|"trace init failure\n"
argument_list|)
expr_stmt|;
comment|/* send init event */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|tws_send_event
argument_list|(
name|sc
argument_list|,
name|TWS_INIT_START
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"BIG endian"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sysctl context setup */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|tws_clist
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tws_oidp
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|tws_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tws_oidp
operator|==
name|NULL
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|SYSCTL_TREE_NODE_ADD
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_1
goto|;
block|}
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|sc
operator|->
name|tws_clist
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|tws_oidp
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|TWS_DRIVER_VERSION_STRING
argument_list|,
literal|0
argument_list|,
literal|"TWS driver version"
argument_list|)
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bar
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|TWS_PCI_BAR0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"bar0 "
argument_list|,
name|bar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bar
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|TWS_PCI_BAR1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bar
operator|=
name|bar
operator|&
operator|~
name|TWS_BIT2
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"bar1 "
argument_list|,
name|bar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* MFA base address is BAR2 register used for       * push mode. Firmware will evatualy move to       * pull mode during witch this needs to change      */
ifndef|#
directive|ifndef
name|TWS_PULL_MODE_ENABLE
name|sc
operator|->
name|mfa_base
operator|=
operator|(
name|u_int64_t
operator|)
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|TWS_PCI_BAR2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mfa_base
operator|=
name|sc
operator|->
name|mfa_base
operator|&
operator|~
name|TWS_BIT2
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"bar2 "
argument_list|,
name|sc
operator|->
name|mfa_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* allocate MMIO register space */
name|sc
operator|->
name|reg_res_id
operator|=
name|TWS_PCI_BAR1
expr_stmt|;
comment|/* BAR1 offset */
if|if
condition|(
operator|(
name|sc
operator|->
name|reg_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|reg_res_id
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|ALLOC_MEMORY_RES
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_1
goto|;
block|}
name|sc
operator|->
name|bus_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|reg_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|reg_res
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TWS_PULL_MODE_ENABLE
comment|/* Allocate bus space for inbound mfa */
name|sc
operator|->
name|mfa_res_id
operator|=
name|TWS_PCI_BAR2
expr_stmt|;
comment|/* BAR2 offset */
if|if
condition|(
operator|(
name|sc
operator|->
name|mfa_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
operator|(
name|sc
operator|->
name|mfa_res_id
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|0x100000
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|ALLOC_MEMORY_RES
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_2
goto|;
block|}
name|sc
operator|->
name|bus_mfa_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mfa_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus_mfa_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mfa_res
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate and register our interrupt. */
name|sc
operator|->
name|intr_type
operator|=
name|TWS_INTx
expr_stmt|;
comment|/* default */
if|if
condition|(
name|tws_enable_msi
condition|)
name|sc
operator|->
name|intr_type
operator|=
name|TWS_MSI
expr_stmt|;
if|if
condition|(
name|tws_setup_irq
argument_list|(
name|sc
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|ALLOC_MEMORY_RES
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_3
goto|;
block|}
comment|/*      * Create a /dev entry for this device.  The kernel will assign us      * a major number automatically.  We use the unit number of this      * device as the minor number and name the character device      * "tws<unit>".      */
name|sc
operator|->
name|tws_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|tws_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|,
literal|"tws%u"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tws_cdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|tws_init
argument_list|(
name|sc
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|TWS_INIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_4
goto|;
block|}
if|if
condition|(
name|tws_init_ctlr
argument_list|(
name|sc
argument_list|)
operator|==
name|FAILURE
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|TWS_CTLR_INIT_FAILURE
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_4
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tws_cam_attach
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|TWS_CAM_ATTACH
argument_list|)
expr_stmt|;
goto|goto
name|attach_fail_4
goto|;
block|}
comment|/* send init complete event */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|tws_send_event
argument_list|(
name|sc
argument_list|,
name|TWS_INIT_COMPLETE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"attached successfully"
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|device_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|attach_fail_4
label|:
name|tws_teardown_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|tws_cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dma_mem_phys
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|,
name|sc
operator|->
name|cmd_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dma_mem
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|,
name|sc
operator|->
name|dma_mem
argument_list|,
name|sc
operator|->
name|cmd_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cmd_tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|)
expr_stmt|;
name|attach_fail_3
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|irqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|irq_res
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_res_id
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|irq_res
index|[
name|i
index|]
argument_list|)
condition|)
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"bus irq res"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|TWS_PULL_MODE_ENABLE
name|attach_fail_2
label|:
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|mfa_res
condition|)
block|{
if|if
condition|(
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mfa_res_id
argument_list|,
name|sc
operator|->
name|mfa_res
argument_list|)
condition|)
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"bus release "
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|mfa_res_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|reg_res
condition|)
block|{
if|if
condition|(
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|reg_res_id
argument_list|,
name|sc
operator|->
name|reg_res
argument_list|)
condition|)
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"bus release2 "
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_res_id
argument_list|)
expr_stmt|;
block|}
name|attach_fail_1
label|:
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|tws_clist
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Detach device. */
end_comment

begin_function
specifier|static
name|int
name|tws_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|tws_send_event
argument_list|(
name|sc
argument_list|,
name|TWS_UNINIT_START
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
comment|/* needs to disable interrupt before detaching from cam */
name|tws_turn_off_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* clear door bell */
name|tws_write_reg
argument_list|(
name|sc
argument_list|,
name|TWS_I2O0_HOBDBC
argument_list|,
operator|~
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|reg
operator|=
name|tws_read_reg
argument_list|(
name|sc
argument_list|,
name|TWS_I2O0_HIMASK
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"turn-off-intr"
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|obfl_q_overrun
operator|=
name|false
expr_stmt|;
name|tws_init_connect
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Teardown the state in our softc created in our attach routine. */
comment|/* Disconnect the interrupt handler. */
name|tws_teardown_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Release irq resource */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|irqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|irq_res
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_res_id
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|irq_res
index|[
name|i
index|]
argument_list|)
condition|)
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"bus release irq resource"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|irq_res_id
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|intr_type
operator|==
name|TWS_MSI
condition|)
block|{
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|)
expr_stmt|;
block|}
name|tws_cam_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dma_mem_phys
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|,
name|sc
operator|->
name|cmd_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dma_mem
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|,
name|sc
operator|->
name|dma_mem
argument_list|,
name|sc
operator|->
name|cmd_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cmd_tag
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|)
expr_stmt|;
comment|/* Release memory resource */
if|if
condition|(
name|sc
operator|->
name|mfa_res
condition|)
block|{
if|if
condition|(
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mfa_res_id
argument_list|,
name|sc
operator|->
name|mfa_res
argument_list|)
condition|)
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"bus release mem resource"
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|mfa_res_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|reg_res
condition|)
block|{
if|if
condition|(
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|reg_res_id
argument_list|,
name|sc
operator|->
name|reg_res
argument_list|)
condition|)
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"bus release mem resource"
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|reg_res_id
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|reqs
argument_list|,
name|M_TWS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sense_bufs
argument_list|,
name|M_TWS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|scan_ccb
argument_list|,
name|M_TWS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ioctl_data_mem
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
name|sc
operator|->
name|ioctl_data_mem
argument_list|,
name|sc
operator|->
name|ioctl_data_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|aen_q
operator|.
name|q
argument_list|,
name|M_TWS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|trace_q
operator|.
name|q
argument_list|,
name|M_TWS
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sim_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|sc
operator|->
name|tws_cdev
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|tws_clist
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tws_setup_intr
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irqs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|irqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|intr_handle
index|[
name|i
index|]
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|sc
operator|->
name|irq_res
index|[
name|i
index|]
argument_list|,
name|INTR_TYPE_CAM
operator||
name|INTR_MPSAFE
argument_list|,
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|700000
operator|)
name|NULL
argument_list|,
endif|#
directive|endif
name|tws_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_handle
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
block|{
name|tws_log
argument_list|(
name|sc
argument_list|,
name|SETUP_INTR_RES
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tws_teardown_intr
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|irqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|intr_handle
index|[
name|i
index|]
condition|)
block|{
name|error
operator|=
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|sc
operator|->
name|irq_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|intr_handle
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_handle
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tws_setup_irq
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|messages
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|intr_type
condition|)
block|{
case|case
name|TWS_INTx
case|:
name|sc
operator|->
name|irqs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|irq_res_id
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_res_id
index|[
literal|0
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
if|if
condition|(
name|tws_setup_intr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|irqs
argument_list|)
operator|==
name|FAILURE
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"Using legacy INTx\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TWS_MSI
case|:
name|sc
operator|->
name|irqs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|irq_res_id
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|messages
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
operator|&
name|messages
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|TWS_TRACE
argument_list|(
name|sc
argument_list|,
literal|"pci alloc msi fail"
argument_list|,
literal|0
argument_list|,
name|messages
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|sc
operator|->
name|irq_res
index|[
literal|0
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_res_id
index|[
literal|0
index|]
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
if|if
condition|(
name|tws_setup_intr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|irqs
argument_list|)
operator|==
name|FAILURE
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"Using MSI\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tws_init
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|max_sg_elements
decl_stmt|;
name|u_int32_t
name|dma_mem_size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int32_t
name|reg
decl_stmt|;
name|sc
operator|->
name|seq_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tws_queue_depth
operator|>
name|TWS_MAX_REQS
condition|)
name|tws_queue_depth
operator|=
name|TWS_MAX_REQS
expr_stmt|;
if|if
condition|(
name|tws_queue_depth
operator|<
name|TWS_RESERVED_REQS
operator|+
literal|1
condition|)
name|tws_queue_depth
operator|=
name|TWS_RESERVED_REQS
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|is64bit
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|bus_addr_t
argument_list|)
operator|==
literal|8
operator|)
condition|?
name|true
else|:
name|false
expr_stmt|;
name|max_sg_elements
operator|=
operator|(
name|sc
operator|->
name|is64bit
operator|&&
operator|!
name|tws_use_32bit_sgls
operator|)
condition|?
name|TWS_MAX_64BIT_SG_ELEMENTS
else|:
name|TWS_MAX_32BIT_SG_ELEMENTS
expr_stmt|;
name|dma_mem_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tws_command_packet
argument_list|)
operator|*
name|tws_queue_depth
operator|)
operator|+
operator|(
name|TWS_SECTOR_SIZE
operator|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|)
argument_list|,
comment|/* PCI parent */
name|TWS_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE
argument_list|,
comment|/* maxsize */
name|max_sg_elements
argument_list|,
comment|/* numsegs */
name|BUS_SPACE_MAXSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|parent_tag
comment|/* tag */
argument_list|)
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"DMA parent tag Create fail"
argument_list|,
name|max_sg_elements
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* In bound message frame requires 16byte alignment.      * Outbound MF's can live with 4byte alignment - for now just       * use 16 for both.      */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent */
name|TWS_IN_MF_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|dma_mem_size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* numsegs */
name|BUS_SPACE_MAXSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|cmd_tag
comment|/* tag */
argument_list|)
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"DMA cmd tag Create fail"
argument_list|,
name|max_sg_elements
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|,
operator|&
name|sc
operator|->
name|dma_mem
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|cmd_map
argument_list|)
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"DMA mem alloc fail"
argument_list|,
name|max_sg_elements
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* if bus_dmamem_alloc succeeds then bus_dmamap_load will succeed */
name|sc
operator|->
name|dma_mem_phys
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|cmd_tag
argument_list|,
name|sc
operator|->
name|cmd_map
argument_list|,
name|sc
operator|->
name|dma_mem
argument_list|,
name|dma_mem_size
argument_list|,
name|tws_dmamap_cmds_load_cbfn
argument_list|,
operator|&
name|sc
operator|->
name|dma_mem_phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*     * Create a dma tag for data buffers; size will be the maximum     * possible I/O size (128kB).     */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_tag
argument_list|,
comment|/* parent */
name|TWS_ALIGNMENT
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|TWS_MAX_IO_SIZE
argument_list|,
comment|/* maxsize */
name|max_sg_elements
argument_list|,
comment|/* nsegments */
name|TWS_MAX_IO_SIZE
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|sc
operator|->
name|io_lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|sc
operator|->
name|data_tag
comment|/* tag */
argument_list|)
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"DMA cmd tag Create fail"
argument_list|,
name|max_sg_elements
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|reqs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tws_request
argument_list|)
operator|*
name|tws_queue_depth
argument_list|,
name|M_TWS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|reqs
operator|==
name|NULL
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"malloc failed"
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|sense_bufs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tws_sense
argument_list|)
operator|*
name|tws_queue_depth
argument_list|,
name|M_TWS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sense_bufs
operator|==
name|NULL
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"sense malloc failed"
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sc
operator|->
name|scan_ccb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|,
name|M_TWS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|scan_ccb
operator|==
name|NULL
condition|)
block|{
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"ccb malloc failed"
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|is64bit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|ioctl_data_mem
argument_list|,
operator|(
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
operator|&
name|sc
operator|->
name|ioctl_data_map
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"Cannot allocate ioctl data mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|tws_ctlr_ready
argument_list|(
name|sc
argument_list|)
condition|)
if|if
condition|(
operator|!
name|tws_ctlr_reset
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tws_stats
argument_list|)
argument_list|)
expr_stmt|;
name|tws_init_qs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tws_turn_off_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*       * enable pull mode by setting bit1 .      * setting bit0 to 1 will enable interrupt coalesing       * will revisit.       */
ifdef|#
directive|ifdef
name|TWS_PULL_MODE_ENABLE
name|reg
operator|=
name|tws_read_reg
argument_list|(
name|sc
argument_list|,
name|TWS_I2O0_CTL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"i20 ctl"
argument_list|,
name|reg
argument_list|,
name|TWS_I2O0_CTL
argument_list|)
expr_stmt|;
name|tws_write_reg
argument_list|(
name|sc
argument_list|,
name|TWS_I2O0_CTL
argument_list|,
name|reg
operator||
name|TWS_BIT1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"dma_mem_phys"
argument_list|,
name|sc
operator|->
name|dma_mem_phys
argument_list|,
name|TWS_I2O0_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tws_init_reqs
argument_list|(
name|sc
argument_list|,
name|dma_mem_size
argument_list|)
operator|==
name|FAILURE
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
if|if
condition|(
name|tws_init_aen_q
argument_list|(
name|sc
argument_list|)
operator|==
name|FAILURE
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tws_init_aen_q
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|aen_q
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aen_q
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aen_q
operator|.
name|depth
operator|=
literal|256
expr_stmt|;
name|sc
operator|->
name|aen_q
operator|.
name|overflow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|aen_q
operator|.
name|q
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tws_event_packet
argument_list|)
operator|*
name|sc
operator|->
name|aen_q
operator|.
name|depth
argument_list|,
name|M_TWS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|aen_q
operator|.
name|q
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tws_init_trace_q
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|trace_q
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|trace_q
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|trace_q
operator|.
name|depth
operator|=
literal|256
expr_stmt|;
name|sc
operator|->
name|trace_q
operator|.
name|overflow
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|trace_q
operator|.
name|q
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tws_trace_rec
argument_list|)
operator|*
name|sc
operator|->
name|trace_q
operator|.
name|depth
argument_list|,
name|M_TWS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|trace_q
operator|.
name|q
condition|)
return|return
operator|(
name|FAILURE
operator|)
return|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tws_init_reqs
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int32_t
name|dma_mem_size
parameter_list|)
block|{
name|struct
name|tws_command_packet
modifier|*
name|cmd_buf
decl_stmt|;
name|cmd_buf
operator|=
operator|(
expr|struct
name|tws_command_packet
operator|*
operator|)
name|sc
operator|->
name|dma_mem
expr_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|cmd_buf
argument_list|,
name|dma_mem_size
argument_list|)
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"phy cmd"
argument_list|,
name|sc
operator|->
name|dma_mem_phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tws_queue_depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|dma_map
argument_list|)
condition|)
block|{
comment|/* log a ENOMEM failure msg here */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FAILURE
operator|)
return|;
block|}
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|cmd_pkt
operator|=
operator|&
name|cmd_buf
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|sense_bufs
index|[
name|i
index|]
operator|.
name|hdr
operator|=
operator|&
name|cmd_buf
index|[
name|i
index|]
operator|.
name|hdr
expr_stmt|;
name|sc
operator|->
name|sense_bufs
index|[
name|i
index|]
operator|.
name|hdr_pkt_phy
operator|=
name|sc
operator|->
name|dma_mem_phys
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tws_command_packet
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|cmd_pkt_phy
operator|=
name|sc
operator|->
name|dma_mem_phys
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tws_command_header
argument_list|)
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|tws_command_packet
argument_list|)
operator|)
expr_stmt|;
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|request_id
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|cmd_pkt
operator|->
name|hdr
operator|.
name|header_desc
operator|.
name|size_header
operator|=
literal|128
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|thandle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|reqs
index|[
name|i
index|]
operator|.
name|state
operator|=
name|TWS_REQ_STATE_FREE
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|TWS_RESERVED_REQS
condition|)
name|tws_q_insert_tail
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|reqs
index|[
name|i
index|]
argument_list|,
name|TWS_FREE_Q
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tws_dmamap_cmds_load_cbfn
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
comment|/* printf("command load done \n"); */
operator|*
operator|(
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|)
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tws_send_event
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int8_t
name|event
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|gen_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"received event "
argument_list|,
literal|0
argument_list|,
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|TWS_INIT_START
case|:
name|sc
operator|->
name|tws_state
operator|=
name|TWS_INIT
expr_stmt|;
break|break;
case|case
name|TWS_INIT_COMPLETE
case|:
if|if
condition|(
name|sc
operator|->
name|tws_state
operator|!=
name|TWS_INIT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"invalid state transition %d => TWS_ONLINE\n"
argument_list|,
name|sc
operator|->
name|tws_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tws_state
operator|=
name|TWS_ONLINE
expr_stmt|;
block|}
break|break;
case|case
name|TWS_RESET_START
case|:
comment|/* We can transition to reset state from any state except reset*/
if|if
condition|(
name|sc
operator|->
name|tws_state
operator|!=
name|TWS_RESET
condition|)
block|{
name|sc
operator|->
name|tws_prev_state
operator|=
name|sc
operator|->
name|tws_state
expr_stmt|;
name|sc
operator|->
name|tws_state
operator|=
name|TWS_RESET
expr_stmt|;
block|}
break|break;
case|case
name|TWS_RESET_COMPLETE
case|:
if|if
condition|(
name|sc
operator|->
name|tws_state
operator|!=
name|TWS_RESET
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"invalid state transition %d => %d (previous state)\n"
argument_list|,
name|sc
operator|->
name|tws_state
argument_list|,
name|sc
operator|->
name|tws_prev_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tws_state
operator|=
name|sc
operator|->
name|tws_prev_state
expr_stmt|;
block|}
break|break;
case|case
name|TWS_SCAN_FAILURE
case|:
if|if
condition|(
name|sc
operator|->
name|tws_state
operator|!=
name|TWS_ONLINE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"invalid state transition %d => TWS_OFFLINE\n"
argument_list|,
name|sc
operator|->
name|tws_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tws_state
operator|=
name|TWS_OFFLINE
expr_stmt|;
block|}
break|break;
case|case
name|TWS_UNINIT_START
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|tws_state
operator|!=
name|TWS_ONLINE
operator|)
operator|&&
operator|(
name|sc
operator|->
name|tws_state
operator|!=
name|TWS_OFFLINE
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|tws_dev
argument_list|,
literal|"invalid state transition %d => TWS_UNINIT\n"
argument_list|,
name|sc
operator|->
name|tws_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tws_state
operator|=
name|TWS_UNINIT
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|uint8_t
name|tws_get_state
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u_int8_t
operator|)
name|sc
operator|->
name|tws_state
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called during system shutdown after sync. */
end_comment

begin_function
specifier|static
name|int
name|tws_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tws_turn_off_interrupts
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tws_init_connect
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device suspend routine.  */
end_comment

begin_function
specifier|static
name|int
name|tws_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
condition|)
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device resume routine.  */
end_comment

begin_function
specifier|static
name|int
name|tws_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
condition|)
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|tws_request
modifier|*
name|tws_get_request
parameter_list|(
name|struct
name|tws_softc
modifier|*
name|sc
parameter_list|,
name|u_int16_t
name|type
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|my_mutex
init|=
operator|(
operator|(
name|type
operator|==
name|TWS_REQ_TYPE_SCSI_IO
operator|)
condition|?
operator|&
name|sc
operator|->
name|q_lock
else|:
operator|&
name|sc
operator|->
name|gen_lock
operator|)
decl_stmt|;
name|struct
name|tws_request
modifier|*
name|r
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
name|my_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TWS_REQ_TYPE_SCSI_IO
condition|)
block|{
name|r
operator|=
name|tws_q_remove_head
argument_list|(
name|sc
argument_list|,
name|TWS_FREE_Q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|reqs
index|[
name|type
index|]
operator|.
name|state
operator|==
name|TWS_REQ_STATE_FREE
condition|)
block|{
name|r
operator|=
operator|&
name|sc
operator|->
name|reqs
index|[
name|type
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|r
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|r
operator|->
name|cmd_pkt
operator|->
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tws_command_apache
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|r
operator|->
name|flags
operator|=
name|TWS_DIR_UNKNOWN
expr_stmt|;
name|r
operator|->
name|error_code
operator|=
name|TWS_REQ_RET_INVALID
expr_stmt|;
name|r
operator|->
name|cb
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|ccb_ptr
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|thandle
operator|.
name|callout
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|r
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|state
operator|=
operator|(
operator|(
name|type
operator|==
name|TWS_REQ_TYPE_SCSI_IO
operator|)
condition|?
name|TWS_REQ_STATE_TRAN
else|:
name|TWS_REQ_STATE_BUSY
operator|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|my_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tws_release_request
parameter_list|(
name|struct
name|tws_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|tws_softc
modifier|*
name|sc
init|=
name|req
operator|->
name|sc
decl_stmt|;
name|TWS_TRACE_DEBUG
argument_list|(
name|sc
argument_list|,
literal|"entry"
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
name|tws_q_insert_tail
argument_list|(
name|sc
argument_list|,
name|req
argument_list|,
name|TWS_FREE_Q
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|q_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|tws_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tws_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|tws_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|tws_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|tws_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|tws_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|tws_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|tws_driver
init|=
block|{
literal|"tws"
block|,
name|tws_methods
block|,
expr|sizeof
operator|(
expr|struct
name|tws_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|tws_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEFINE_CLASS_0(tws, tws_driver, tws_methods, sizeof(struct tws_softc)); */
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tws
argument_list|,
name|pci
argument_list|,
name|tws_driver
argument_list|,
name|tws_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|tws
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|tws
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.tws.queue_depth"
argument_list|,
operator|&
name|tws_queue_depth
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.tws.enable_msi"
argument_list|,
operator|&
name|tws_enable_msi
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

