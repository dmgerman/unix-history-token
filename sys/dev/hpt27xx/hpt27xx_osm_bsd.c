begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 HighPoint Technologies, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<dev/hpt27xx/hpt27xx_config.h>
end_include

begin_include
include|#
directive|include
file|<dev/hpt27xx/os_bsd.h>
end_include

begin_include
include|#
directive|include
file|<dev/hpt27xx/hptintf.h>
end_include

begin_function
specifier|static
name|HIM
modifier|*
name|hpt_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PCI_ID
name|pci_id
decl_stmt|;
name|HIM
modifier|*
name|him
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|him
operator|=
name|him_list
init|;
name|him
condition|;
name|him
operator|=
name|him
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|him
operator|->
name|get_supported_device_id
argument_list|(
name|i
argument_list|,
operator|&
name|pci_id
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|him
operator|->
name|get_controller_count
condition|)
name|him
operator|->
name|get_controller_count
argument_list|(
operator|&
name|pci_id
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|pci_id
operator|.
name|vid
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|pci_id
operator|.
name|did
operator|)
condition|)
block|{
return|return
operator|(
name|him
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|HIM
modifier|*
name|him
decl_stmt|;
name|him
operator|=
name|hpt_match
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|him
operator|!=
name|NULL
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"hpt_probe: adapter at PCI %d:%d:%d, IRQ %d"
operator|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_irq
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|him
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PHBA
name|hba
init|=
operator|(
name|PHBA
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|HIM
modifier|*
name|him
decl_stmt|;
name|PCI_ID
name|pci_id
decl_stmt|;
name|HPT_UINT
name|size
decl_stmt|;
name|PVBUS
name|vbus
decl_stmt|;
name|PVBUS_EXT
name|vbus_ext
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"hpt_attach(%d/%d/%d)"
operator|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|him
operator|=
name|hpt_match
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hba
operator|->
name|ext_type
operator|=
name|EXT_TYPE_HBA
expr_stmt|;
name|hba
operator|->
name|ldm_adapter
operator|.
name|him
operator|=
name|him
expr_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_id
operator|.
name|vid
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_id
operator|.
name|did
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_id
operator|.
name|rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_id
operator|.
name|subsys
operator|=
call|(
name|HPT_U32
call|)
argument_list|(
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|<<
literal|16
operator||
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|size
operator|=
name|him
operator|->
name|get_adapter_size
argument_list|(
operator|&
name|pci_id
argument_list|)
expr_stmt|;
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
condition|)
return|return
name|ENXIO
return|;
name|hba
operator|->
name|pcidev
operator|=
name|dev
expr_stmt|;
name|hba
operator|->
name|pciaddr
operator|.
name|tree
operator|=
literal|0
expr_stmt|;
name|hba
operator|->
name|pciaddr
operator|.
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hba
operator|->
name|pciaddr
operator|.
name|device
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|hba
operator|->
name|pciaddr
operator|.
name|function
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|him
operator|->
name|create_adapter
argument_list|(
operator|&
name|pci_id
argument_list|,
name|hba
operator|->
name|pciaddr
argument_list|,
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
argument_list|,
name|hba
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|os_printk
argument_list|(
literal|"adapter at PCI %d:%d:%d, IRQ %d"
argument_list|,
name|hba
operator|->
name|pciaddr
operator|.
name|bus
argument_list|,
name|hba
operator|->
name|pciaddr
operator|.
name|device
argument_list|,
name|hba
operator|->
name|pciaddr
operator|.
name|function
argument_list|,
name|pci_get_irq
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ldm_register_adapter
argument_list|(
operator|&
name|hba
operator|->
name|ldm_adapter
argument_list|)
condition|)
block|{
name|size
operator|=
name|ldm_get_vbus_size
argument_list|()
expr_stmt|;
name|vbus_ext
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|VBUS_EXT
argument_list|)
operator|+
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vbus_ext
condition|)
block|{
name|free
argument_list|(
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|memset
argument_list|(
name|vbus_ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|VBUS_EXT
argument_list|)
argument_list|)
expr_stmt|;
name|vbus_ext
operator|->
name|ext_type
operator|=
name|EXT_TYPE_VBUS
expr_stmt|;
name|ldm_create_vbus
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_register_adapter
argument_list|(
operator|&
name|hba
operator|->
name|ldm_adapter
argument_list|)
expr_stmt|;
block|}
name|ldm_for_each_vbus
argument_list|(
argument|vbus
argument_list|,
argument|vbus_ext
argument_list|)
block|{
if|if
condition|(
name|hba
operator|->
name|ldm_adapter
operator|.
name|vbus
operator|==
name|vbus
condition|)
block|{
name|hba
operator|->
name|vbus_ext
operator|=
name|vbus_ext
expr_stmt|;
name|hba
operator|->
name|next
operator|=
name|vbus_ext
operator|->
name|hba_list
expr_stmt|;
name|vbus_ext
operator|->
name|hba_list
operator|=
name|hba
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Maybe we'd better to use the bus_dmamem_alloc to alloc DMA memory,  * but there are some problems currently (alignment, etc).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|__get_free_pages
parameter_list|(
name|int
name|order
parameter_list|)
block|{
comment|/* don't use low memory - other devices may get starved */
return|return
name|contigmalloc
argument_list|(
name|PAGE_SIZE
operator|<<
name|order
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|free_pages
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|contigfree
argument_list|(
name|p
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_alloc_mem
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
block|{
name|PHBA
name|hba
decl_stmt|;
name|struct
name|freelist
modifier|*
name|f
decl_stmt|;
name|HPT_UINT
name|i
decl_stmt|;
name|void
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|hba
operator|=
name|vbus_ext
operator|->
name|hba_list
init|;
name|hba
condition|;
name|hba
operator|=
name|hba
operator|->
name|next
control|)
name|hba
operator|->
name|ldm_adapter
operator|.
name|him
operator|->
name|get_meminfo
argument_list|(
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
argument_list|)
expr_stmt|;
name|ldm_get_mem_info
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|vbus_ext
operator|->
name|freelist_head
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"%s: %d*%d=%d bytes"
operator|,
name|f
operator|->
name|tag
operator|,
name|f
operator|->
name|count
operator|,
name|f
operator|->
name|size
operator|,
name|f
operator|->
name|count
operator|*
name|f
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|f
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|*
name|p
operator|=
name|f
operator|->
name|head
expr_stmt|;
name|f
operator|->
name|head
operator|=
name|p
expr_stmt|;
block|}
block|}
for|for
control|(
name|f
operator|=
name|vbus_ext
operator|->
name|freelist_dma_head
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|int
name|order
decl_stmt|,
name|size
decl_stmt|,
name|j
decl_stmt|;
name|HPT_ASSERT
argument_list|(
operator|(
name|f
operator|->
name|size
operator|&
operator|(
name|f
operator|->
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|order
operator|=
literal|0
operator|,
name|size
operator|=
name|PAGE_SIZE
init|;
name|size
operator|<
name|f
operator|->
name|size
condition|;
name|order
operator|++
operator|,
name|size
operator|<<=
literal|1
control|)
empty_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"%s: %d*%d=%d bytes, order %d"
operator|,
name|f
operator|->
name|tag
operator|,
name|f
operator|->
name|count
operator|,
name|f
operator|->
name|size
operator|,
name|f
operator|->
name|count
operator|*
name|f
operator|->
name|size
operator|,
name|order
operator|)
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|f
operator|->
name|alignment
operator|<=
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|count
condition|;
control|)
block|{
name|p
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|__get_free_pages
argument_list|(
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|j
operator|=
name|size
operator|/
name|f
operator|->
name|size
init|;
name|j
operator|&&
name|i
operator|<
name|f
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
operator|*
name|p
operator|=
name|f
operator|->
name|head
expr_stmt|;
operator|*
operator|(
name|BUS_ADDRESS
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
operator|(
name|BUS_ADDRESS
operator|)
name|vtophys
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|f
operator|->
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|unsigned
name|long
operator|)
name|p
operator|+
name|f
operator|->
name|size
operator|)
expr_stmt|;
block|}
block|}
block|}
name|HPT_ASSERT
argument_list|(
name|PAGE_SIZE
operator|==
name|DMAPOOL_PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|os_max_cache_pages
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|__get_free_pages
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
literal|1
return|;
name|HPT_ASSERT
argument_list|(
operator|(
operator|(
name|HPT_UPTR
operator|)
name|p
operator|&
operator|(
name|DMAPOOL_PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dmapool_put_page
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
name|p
argument_list|,
operator|(
name|BUS_ADDRESS
operator|)
name|vtophys
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_free_mem
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
block|{
name|struct
name|freelist
modifier|*
name|f
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|BUS_ADDRESS
name|bus
decl_stmt|;
for|for
control|(
name|f
operator|=
name|vbus_ext
operator|->
name|freelist_head
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|#
directive|if
name|DBG
if|if
condition|(
name|f
operator|->
name|count
operator|!=
name|f
operator|->
name|reserved_count
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"memory leak for freelist %s (%d/%d)"
operator|,
name|f
operator|->
name|tag
operator|,
name|f
operator|->
name|count
operator|,
name|f
operator|->
name|reserved_count
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|p
operator|=
name|freelist_get
argument_list|(
name|f
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|os_max_cache_pages
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|dmapool_get_page
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free_pages
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|f
operator|=
name|vbus_ext
operator|->
name|freelist_dma_head
init|;
name|f
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
name|int
name|order
decl_stmt|,
name|size
decl_stmt|;
if|#
directive|if
name|DBG
if|if
condition|(
name|f
operator|->
name|count
operator|!=
name|f
operator|->
name|reserved_count
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"memory leak for dma freelist %s (%d/%d)"
operator|,
name|f
operator|->
name|tag
operator|,
name|f
operator|->
name|count
operator|,
name|f
operator|->
name|reserved_count
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|order
operator|=
literal|0
operator|,
name|size
operator|=
name|PAGE_SIZE
init|;
name|size
operator|<
name|f
operator|->
name|size
condition|;
name|order
operator|++
operator|,
name|size
operator|<<=
literal|1
control|)
empty_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|freelist_get_dma
argument_list|(
name|f
argument_list|,
operator|&
name|bus
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|order
condition|)
name|free_pages
argument_list|(
name|p
argument_list|,
name|order
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* can't free immediately since other blocks in this page may still be in the list */
if|if
condition|(
operator|(
operator|(
name|HPT_UPTR
operator|)
name|p
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|dmapool_put_page
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
name|p
argument_list|,
name|bus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|(
name|p
operator|=
name|dmapool_get_page
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
operator|&
name|bus
argument_list|)
operator|)
condition|)
name|free_pages
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_init_vbus
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
block|{
name|PHBA
name|hba
decl_stmt|;
for|for
control|(
name|hba
operator|=
name|vbus_ext
operator|->
name|hba_list
init|;
name|hba
condition|;
name|hba
operator|=
name|hba
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|hba
operator|->
name|ldm_adapter
operator|.
name|him
operator|->
name|initialize
argument_list|(
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
argument_list|)
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"fail to initialize %p"
operator|,
name|hba
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ldm_initialize_vbus
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
operator|&
name|vbus_ext
operator|->
name|hba_list
operator|->
name|ldm_adapter
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_flush_done
parameter_list|(
name|PCOMMAND
name|pCmd
parameter_list|)
block|{
name|PVDEV
name|vd
init|=
name|pCmd
operator|->
name|target
decl_stmt|;
if|if
condition|(
name|mIsArray
argument_list|(
name|vd
operator|->
name|type
argument_list|)
operator|&&
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|transform
operator|&&
name|vd
operator|!=
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|transform
operator|->
name|target
condition|)
block|{
name|vd
operator|=
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|transform
operator|->
name|target
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|pCmd
operator|->
name|target
operator|=
name|vd
expr_stmt|;
name|pCmd
operator|->
name|Result
operator|=
name|RETURN_PENDING
expr_stmt|;
name|vdev_queue_cmd
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|pCmd
operator|->
name|priv
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * flush a vdev (without retry).  */
end_comment

begin_function
specifier|static
name|int
name|hpt_flush_vdev
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|,
name|PVDEV
name|vd
parameter_list|)
block|{
name|PCOMMAND
name|pCmd
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|,
name|done
decl_stmt|;
name|HPT_UINT
name|count
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"flusing dev %p"
operator|,
name|vd
operator|)
argument_list|)
expr_stmt|;
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|mIsArray
argument_list|(
name|vd
operator|->
name|type
argument_list|)
operator|&&
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|transform
condition|)
name|count
operator|=
name|max
argument_list|(
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|transform
operator|->
name|source
operator|->
name|cmds_per_request
argument_list|,
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|transform
operator|->
name|target
operator|->
name|cmds_per_request
argument_list|)
expr_stmt|;
else|else
name|count
operator|=
name|vd
operator|->
name|cmds_per_request
expr_stmt|;
name|pCmd
operator|=
name|ldm_alloc_cmds
argument_list|(
name|vd
operator|->
name|vbus
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pCmd
condition|)
block|{
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pCmd
operator|->
name|type
operator|=
name|CMD_TYPE_FLUSH
expr_stmt|;
name|pCmd
operator|->
name|flags
operator|.
name|hard_flush
operator|=
literal|1
expr_stmt|;
name|pCmd
operator|->
name|target
operator|=
name|vd
expr_stmt|;
name|pCmd
operator|->
name|done
operator|=
name|hpt_flush_done
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|pCmd
operator|->
name|priv
operator|=
operator|&
name|done
expr_stmt|;
name|ldm_queue_cmd
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
while|while
condition|(
name|hpt_sleep
argument_list|(
name|vbus_ext
argument_list|,
name|pCmd
argument_list|,
name|PPAUSE
argument_list|,
literal|"hptfls"
argument_list|,
name|HPT_OSM_TIMEOUT
argument_list|)
condition|)
block|{
name|ldm_reset_vbus
argument_list|(
name|vd
operator|->
name|vbus
argument_list|)
expr_stmt|;
block|}
block|}
name|KdPrint
argument_list|(
operator|(
literal|"flush result %d"
operator|,
name|pCmd
operator|->
name|Result
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|Result
operator|!=
name|RETURN_SUCCESS
condition|)
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|ldm_free_cmds
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|hpt_stop_tasks
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|hpt_shutdown_vbus
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|PVBUS
name|vbus
init|=
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
decl_stmt|;
name|PHBA
name|hba
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"hpt_shutdown_vbus"
operator|)
argument_list|)
expr_stmt|;
comment|/* stop all ctl tasks and disable the worker taskqueue */
name|hpt_stop_tasks
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|vbus_ext
operator|->
name|worker
operator|.
name|ta_context
operator|=
literal|0
expr_stmt|;
comment|/* flush devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osm_max_targets
condition|;
name|i
operator|++
control|)
block|{
name|PVDEV
name|vd
init|=
name|ldm_find_target
argument_list|(
name|vbus
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|vd
condition|)
block|{
comment|/* retry once */
if|if
condition|(
name|hpt_flush_vdev
argument_list|(
name|vbus_ext
argument_list|,
name|vd
argument_list|)
condition|)
name|hpt_flush_vdev
argument_list|(
name|vbus_ext
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_shutdown
argument_list|(
name|vbus
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_release_vbus
argument_list|(
name|vbus
argument_list|)
expr_stmt|;
for|for
control|(
name|hba
operator|=
name|vbus_ext
operator|->
name|hba_list
init|;
name|hba
condition|;
name|hba
operator|=
name|hba
operator|->
name|next
control|)
name|bus_teardown_intr
argument_list|(
name|hba
operator|->
name|pcidev
argument_list|,
name|hba
operator|->
name|irq_res
argument_list|,
name|hba
operator|->
name|irq_handle
argument_list|)
expr_stmt|;
name|hpt_free_mem
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hba
operator|=
name|vbus_ext
operator|->
name|hba_list
operator|)
condition|)
block|{
name|vbus_ext
operator|->
name|hba_list
operator|=
name|hba
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hba
operator|->
name|ldm_adapter
operator|.
name|him_handle
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|callout_drain
argument_list|(
operator|&
name|vbus_ext
operator|->
name|timer
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|vbus_ext
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|vbus_ext
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"hpt_shutdown_vbus done"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__hpt_do_tasks
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
block|{
name|OSM_TASK
modifier|*
name|tasks
decl_stmt|;
name|tasks
operator|=
name|vbus_ext
operator|->
name|tasks
expr_stmt|;
name|vbus_ext
operator|->
name|tasks
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tasks
condition|)
block|{
name|OSM_TASK
modifier|*
name|t
init|=
name|tasks
decl_stmt|;
name|tasks
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|func
argument_list|(
name|vbus_ext
operator|->
name|vbus
argument_list|,
name|t
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_do_tasks
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
if|if
condition|(
name|vbus_ext
condition|)
block|{
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|__hpt_do_tasks
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|hpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hpt_pci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|POS_CMDEXT
name|cmdext_get
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
block|{
name|POS_CMDEXT
name|p
init|=
name|vbus_ext
operator|->
name|cmdext_list
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|vbus_ext
operator|->
name|cmdext_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmdext_put
parameter_list|(
name|POS_CMDEXT
name|p
parameter_list|)
block|{
name|p
operator|->
name|next
operator|=
name|p
operator|->
name|vbus_ext
operator|->
name|cmdext_list
expr_stmt|;
name|p
operator|->
name|vbus_ext
operator|->
name|cmdext_list
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|PCOMMAND
name|pCmd
init|=
operator|(
name|PCOMMAND
operator|)
name|arg
decl_stmt|;
name|POS_CMDEXT
name|ext
init|=
operator|(
name|POS_CMDEXT
operator|)
name|pCmd
operator|->
name|priv
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"pCmd %p timeout"
operator|,
name|pCmd
operator|)
argument_list|)
expr_stmt|;
name|ldm_reset_vbus
argument_list|(
operator|(
name|PVBUS
operator|)
name|ext
operator|->
name|vbus_ext
operator|->
name|vbus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|os_cmddone
parameter_list|(
name|PCOMMAND
name|pCmd
parameter_list|)
block|{
name|POS_CMDEXT
name|ext
init|=
operator|(
name|POS_CMDEXT
operator|)
name|pCmd
operator|->
name|priv
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|ext
operator|->
name|ccb
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"<8>os_cmddone(%p, %d)"
operator|,
name|pCmd
operator|,
name|pCmd
operator|->
name|Result
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|callout_stop
argument_list|(
operator|&
name|ext
operator|->
name|timeout
argument_list|)
expr_stmt|;
else|#
directive|else
name|untimeout
argument_list|(
name|hpt_timeout
argument_list|,
name|pCmd
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|pCmd
operator|->
name|Result
condition|)
block|{
case|case
name|RETURN_SUCCESS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|RETURN_BAD_DEVICE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DEV_NOT_THERE
expr_stmt|;
break|break;
case|case
name|RETURN_DEVICE_BUSY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
case|case
name|RETURN_INVALID_REQUEST
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|RETURN_SELECTION_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
case|case
name|RETURN_RETRY
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pCmd
operator|->
name|flags
operator|.
name|data_in
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ext
operator|->
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCmd
operator|->
name|flags
operator|.
name|data_out
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ext
operator|->
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|ext
operator|->
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|cmdext_put
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ldm_free_cmds
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|os_buildsgl
parameter_list|(
name|PCOMMAND
name|pCmd
parameter_list|,
name|PSG
name|pSg
parameter_list|,
name|int
name|logical
parameter_list|)
block|{
name|POS_CMDEXT
name|ext
init|=
operator|(
name|POS_CMDEXT
operator|)
name|pCmd
operator|->
name|priv
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|ext
operator|->
name|ccb
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
if|if
condition|(
name|logical
condition|)
block|{
name|os_set_sgptr
argument_list|(
name|pSg
argument_list|,
operator|(
name|HPT_U8
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
name|pSg
operator|->
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|pSg
operator|->
name|eot
operator|=
literal|1
expr_stmt|;
return|return
name|TRUE
return|;
block|}
else|#
directive|else
name|bus_dma_segment_t
modifier|*
name|sgList
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|logical
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
condition|)
name|panic
argument_list|(
literal|"physical address unsupported"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
condition|)
name|panic
argument_list|(
literal|"physical address unsupported"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|os_set_sgptr
argument_list|(
operator|&
name|pSg
index|[
name|idx
index|]
argument_list|,
operator|(
name|HPT_U8
operator|*
operator|)
operator|(
name|HPT_UPTR
operator|)
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|pSg
index|[
name|idx
index|]
operator|.
name|size
operator|=
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|pSg
index|[
name|idx
index|]
operator|.
name|eot
operator|=
operator|(
name|idx
operator|==
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|os_set_sgptr
argument_list|(
name|pSg
argument_list|,
operator|(
name|HPT_U8
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|)
expr_stmt|;
name|pSg
operator|->
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|pSg
operator|->
name|eot
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
comment|/* since we have provided physical sg, nobody will ask us to build physical sg */
name|HPT_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_io_dmamap_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|PCOMMAND
name|pCmd
init|=
operator|(
name|PCOMMAND
operator|)
name|arg
decl_stmt|;
name|POS_CMDEXT
name|ext
init|=
operator|(
name|POS_CMDEXT
operator|)
name|pCmd
operator|->
name|priv
decl_stmt|;
name|PSG
name|psg
init|=
name|pCmd
operator|->
name|psg
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|HPT_ASSERT
argument_list|(
name|pCmd
operator|->
name|flags
operator|.
name|physical_sg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"busdma error"
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|nsegs
operator|<=
name|os_max_sg_descriptors
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nsegs
condition|;
name|idx
operator|++
operator|,
name|psg
operator|++
control|)
block|{
name|psg
operator|->
name|addr
operator|.
name|bus
operator|=
name|segs
index|[
name|idx
index|]
operator|.
name|ds_addr
expr_stmt|;
name|psg
operator|->
name|size
operator|=
name|segs
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|psg
operator|->
name|eot
operator|=
literal|0
expr_stmt|;
block|}
name|psg
index|[
operator|-
literal|1
index|]
operator|.
name|eot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pCmd
operator|->
name|flags
operator|.
name|data_in
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ext
operator|->
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pCmd
operator|->
name|flags
operator|.
name|data_out
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ext
operator|->
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|callout_reset
argument_list|(
operator|&
name|ext
operator|->
name|timeout
argument_list|,
name|HPT_OSM_TIMEOUT
argument_list|,
name|hpt_timeout
argument_list|,
name|pCmd
argument_list|)
expr_stmt|;
else|#
directive|else
name|ext
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|hpt_timeout
argument_list|,
name|pCmd
argument_list|,
name|HPT_OSM_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ldm_queue_cmd
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_scsi_io
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|PVBUS
name|vbus
init|=
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
decl_stmt|;
name|PVDEV
name|vd
decl_stmt|;
name|PCOMMAND
name|pCmd
decl_stmt|;
name|POS_CMDEXT
name|ext
decl_stmt|;
name|HPT_U8
modifier|*
name|cdb
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
condition|)
name|cdb
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
expr_stmt|;
else|else
name|cdb
operator|=
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
expr_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"<8>hpt_scsi_io: ccb %x id %d lun %d cdb %x-%x-%x"
operator|,
name|ccb
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|,
operator|*
operator|(
name|HPT_U32
operator|*
operator|)
operator|&
name|cdb
index|[
literal|0
index|]
operator|,
operator|*
operator|(
name|HPT_U32
operator|*
operator|)
operator|&
name|cdb
index|[
literal|4
index|]
operator|,
operator|*
operator|(
name|HPT_U32
operator|*
operator|)
operator|&
name|cdb
index|[
literal|8
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* ccb->ccb_h.path_id is not our bus id - don't check it */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
literal|0
operator|||
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>=
name|osm_max_targets
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|vd
operator|=
name|ldm_find_target
argument_list|(
name|vbus
argument_list|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vd
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|TEST_UNIT_READY
case|:
case|case
name|START_STOP_UNIT
case|:
case|case
name|SYNCHRONIZE_CACHE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|INQUIRY
case|:
block|{
name|PINQUIRYDATA
name|inquiryData
decl_stmt|;
name|memset
argument_list|(
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
literal|0
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|)
expr_stmt|;
name|inquiryData
operator|=
operator|(
name|PINQUIRYDATA
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|inquiryData
operator|->
name|AdditionalLength
operator|=
literal|31
expr_stmt|;
name|inquiryData
operator|->
name|CommandQueue
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|VendorId
argument_list|,
literal|"HPT     "
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductId
argument_list|,
literal|"DISK 0_0        "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|target_id
operator|/
literal|10
condition|)
block|{
name|inquiryData
operator|->
name|ProductId
index|[
literal|7
index|]
operator|=
operator|(
name|vd
operator|->
name|target_id
operator|%
literal|100
operator|)
operator|/
literal|10
operator|+
literal|'0'
expr_stmt|;
name|inquiryData
operator|->
name|ProductId
index|[
literal|8
index|]
operator|=
operator|(
name|vd
operator|->
name|target_id
operator|%
literal|100
operator|)
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
else|else
name|inquiryData
operator|->
name|ProductId
index|[
literal|7
index|]
operator|=
operator|(
name|vd
operator|->
name|target_id
operator|%
literal|100
operator|)
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inquiryData
operator|->
name|ProductRevisionLevel
argument_list|,
literal|"4.00"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
block|}
break|break;
case|case
name|READ_CAPACITY
case|:
block|{
name|HPT_U8
modifier|*
name|rbuf
init|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|HPT_U32
name|cap
decl_stmt|;
name|HPT_U8
name|sector_size_shift
init|=
literal|0
decl_stmt|;
name|HPT_U64
name|new_cap
decl_stmt|;
name|HPT_U32
name|sector_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mIsArray
argument_list|(
name|vd
operator|->
name|type
argument_list|)
condition|)
name|sector_size_shift
operator|=
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|sector_size_shift
expr_stmt|;
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|type
operator|==
name|VD_RAW
condition|)
block|{
name|sector_size
operator|=
name|vd
operator|->
name|u
operator|.
name|raw
operator|.
name|logical_sector_size
expr_stmt|;
block|}
switch|switch
condition|(
name|sector_size
condition|)
block|{
case|case
literal|0x1000
case|:
name|KdPrint
argument_list|(
operator|(
literal|"set 4k setctor size in READ_CAPACITY"
operator|)
argument_list|)
expr_stmt|;
name|sector_size_shift
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|new_cap
operator|=
name|vd
operator|->
name|capacity
operator|>>
name|sector_size_shift
expr_stmt|;
if|if
condition|(
name|new_cap
operator|>
literal|0xfffffffful
condition|)
name|cap
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|cap
operator|=
name|new_cap
operator|-
literal|1
expr_stmt|;
name|rbuf
index|[
literal|0
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|1
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|2
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|3
index|]
operator|=
operator|(
name|HPT_U8
operator|)
name|cap
expr_stmt|;
name|rbuf
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|6
index|]
operator|=
literal|2
operator|<<
name|sector_size_shift
expr_stmt|;
name|rbuf
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|REPORT_LUNS
case|:
block|{
name|HPT_U8
modifier|*
name|rbuf
init|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|memset
argument_list|(
name|rbuf
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|3
index|]
operator|=
literal|8
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|SERVICE_ACTION_IN
case|:
block|{
name|HPT_U8
modifier|*
name|rbuf
init|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
name|HPT_U64
name|cap
init|=
literal|0
decl_stmt|;
name|HPT_U8
name|sector_size_shift
init|=
literal|0
decl_stmt|;
name|HPT_U32
name|sector_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mIsArray
argument_list|(
name|vd
operator|->
name|type
argument_list|)
condition|)
name|sector_size_shift
operator|=
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|sector_size_shift
expr_stmt|;
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|type
operator|==
name|VD_RAW
condition|)
block|{
name|sector_size
operator|=
name|vd
operator|->
name|u
operator|.
name|raw
operator|.
name|logical_sector_size
expr_stmt|;
block|}
switch|switch
condition|(
name|sector_size
condition|)
block|{
case|case
literal|0x1000
case|:
name|KdPrint
argument_list|(
operator|(
literal|"set 4k setctor size in SERVICE_ACTION_IN"
operator|)
argument_list|)
expr_stmt|;
name|sector_size_shift
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|cap
operator|=
operator|(
name|vd
operator|->
name|capacity
operator|>>
name|sector_size_shift
operator|)
operator|-
literal|1
expr_stmt|;
name|rbuf
index|[
literal|0
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|56
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|1
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|2
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|40
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|3
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|4
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|5
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|6
index|]
operator|=
call|(
name|HPT_U8
call|)
argument_list|(
name|cap
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|rbuf
index|[
literal|7
index|]
operator|=
operator|(
name|HPT_U8
operator|)
name|cap
expr_stmt|;
name|rbuf
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|rbuf
index|[
literal|10
index|]
operator|=
literal|2
operator|<<
name|sector_size_shift
expr_stmt|;
name|rbuf
index|[
literal|11
index|]
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|READ_6
case|:
case|case
name|READ_10
case|:
case|case
name|READ_16
case|:
case|case
name|WRITE_6
case|:
case|case
name|WRITE_10
case|:
case|case
name|WRITE_16
case|:
case|case
literal|0x13
case|:
case|case
literal|0x2f
case|:
case|case
literal|0x8f
case|:
comment|/* VERIFY_16 */
block|{
name|HPT_U8
name|sector_size_shift
init|=
literal|0
decl_stmt|;
name|HPT_U32
name|sector_size
init|=
literal|0
decl_stmt|;
name|pCmd
operator|=
name|ldm_alloc_cmds
argument_list|(
name|vbus
argument_list|,
name|vd
operator|->
name|cmds_per_request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pCmd
condition|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"Failed to allocate command!"
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_BUSY
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|WRITE_6
case|:
case|case
literal|0x13
case|:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|3
index|]
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|HPT_U16
operator|)
name|cdb
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|READ_16
case|:
case|case
name|WRITE_16
case|:
case|case
literal|0x8f
case|:
comment|/* VERIFY_16 */
block|{
name|HPT_U64
name|block
init|=
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|2
index|]
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|3
index|]
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|4
index|]
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|5
index|]
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|7
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|HPT_U64
operator|)
name|cdb
index|[
literal|9
index|]
operator|)
decl_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
name|block
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|HPT_U16
operator|)
name|cdb
index|[
literal|13
index|]
operator||
operator|(
operator|(
name|HPT_U16
operator|)
name|cdb
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
block|}
default|default:
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|=
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|5
index|]
operator||
operator|(
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|HPT_U32
operator|)
name|cdb
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|=
operator|(
name|HPT_U16
operator|)
name|cdb
index|[
literal|8
index|]
operator||
operator|(
operator|(
name|HPT_U16
operator|)
name|cdb
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mIsArray
argument_list|(
name|vd
operator|->
name|type
argument_list|)
condition|)
block|{
name|sector_size_shift
operator|=
name|vd
operator|->
name|u
operator|.
name|array
operator|.
name|sector_size_shift
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|type
operator|==
name|VD_RAW
condition|)
block|{
name|sector_size
operator|=
name|vd
operator|->
name|u
operator|.
name|raw
operator|.
name|logical_sector_size
expr_stmt|;
block|}
switch|switch
condition|(
name|sector_size
condition|)
block|{
case|case
literal|0x1000
case|:
name|KdPrint
argument_list|(
operator|(
literal|"<8>resize sector size from 4k to 512"
operator|)
argument_list|)
expr_stmt|;
name|sector_size_shift
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|Lba
operator|<<=
name|sector_size_shift
expr_stmt|;
name|pCmd
operator|->
name|uCmd
operator|.
name|Ide
operator|.
name|nSectors
operator|<<=
name|sector_size_shift
expr_stmt|;
switch|switch
condition|(
name|cdb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|READ_6
case|:
case|case
name|READ_10
case|:
case|case
name|READ_16
case|:
name|pCmd
operator|->
name|flags
operator|.
name|data_in
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|WRITE_6
case|:
case|case
name|WRITE_10
case|:
case|case
name|WRITE_16
case|:
name|pCmd
operator|->
name|flags
operator|.
name|data_out
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|pCmd
operator|->
name|priv
operator|=
name|ext
operator|=
name|cmdext_get
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|HPT_ASSERT
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ext
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
name|pCmd
operator|->
name|target
operator|=
name|vd
expr_stmt|;
name|pCmd
operator|->
name|done
operator|=
name|os_cmddone
expr_stmt|;
name|pCmd
operator|->
name|buildsgl
operator|=
name|os_buildsgl
expr_stmt|;
name|pCmd
operator|->
name|psg
operator|=
name|ext
operator|->
name|psg
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
condition|)
block|{
name|int
name|idx
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|sgList
init|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
decl_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
condition|)
name|pCmd
operator|->
name|flags
operator|.
name|physical_sg
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
condition|;
name|idx
operator|++
control|)
block|{
name|pCmd
operator|->
name|psg
index|[
name|idx
index|]
operator|.
name|addr
operator|.
name|bus
operator|=
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pCmd
operator|->
name|psg
index|[
name|idx
index|]
operator|.
name|size
operator|=
name|sgList
index|[
name|idx
index|]
operator|.
name|ds_len
expr_stmt|;
name|pCmd
operator|->
name|psg
index|[
name|idx
index|]
operator|.
name|eot
operator|=
operator|(
name|idx
operator|==
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|hpt_timeout
argument_list|,
name|pCmd
argument_list|,
name|HPT_OSM_TIMEOUT
argument_list|)
expr_stmt|;
name|ldm_queue_cmd
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|int
name|error
decl_stmt|;
name|pCmd
operator|->
name|flags
operator|.
name|physical_sg
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|error
operator|=
name|bus_dmamap_load_ccb
argument_list|(
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|,
name|ccb
argument_list|,
name|hpt_io_dmamap_callback
argument_list|,
name|pCmd
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
name|ext
operator|->
name|dma_map
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
argument_list|,
name|hpt_io_dmamap_callback
argument_list|,
name|pCmd
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KdPrint
argument_list|(
operator|(
literal|"<8>bus_dmamap_load return %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EINPROGRESS
condition|)
block|{
name|os_printk
argument_list|(
literal|"bus_dmamap_load error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cmdext_put
argument_list|(
name|ext
argument_list|)
expr_stmt|;
name|ldm_free_cmds
argument_list|(
name|pCmd
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP_ERR
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|PVBUS_EXT
name|vbus_ext
init|=
operator|(
name|PVBUS_EXT
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|KdPrint
argument_list|(
operator|(
literal|"<8>hpt_action(fn=%d, id=%d)"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|hpt_assert_vbus_locked
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
case|case
name|XPT_SCSI_IO
case|:
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|hpt_scsi_io
argument_list|(
name|vbus_ext
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_RESET_BUS
case|:
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_reset_vbus
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|XPT_SCSI_IO
case|:
name|hpt_scsi_io
argument_list|(
name|vbus_ext
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_RESET_BUS
case|:
name|ldm_reset_vbus
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_FUNC_NOTAVAIL
expr_stmt|;
break|break;
case|case
name|XPT_CALC_GEOMETRY
case|:
name|ccb
operator|->
name|ccg
operator|.
name|heads
operator|=
literal|255
expr_stmt|;
name|ccb
operator|->
name|ccg
operator|.
name|secs_per_track
operator|=
literal|63
expr_stmt|;
name|ccb
operator|->
name|ccg
operator|.
name|cylinders
operator|=
name|ccb
operator|->
name|ccg
operator|.
name|volume_size
operator|/
operator|(
name|ccb
operator|->
name|ccg
operator|.
name|heads
operator|*
name|ccb
operator|->
name|ccg
operator|.
name|secs_per_track
operator|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_NOBUSRESET
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
name|osm_max_targets
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
name|osm_max_targets
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"HPT   "
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_pci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|PVBUS_EXT
name|vbus_ext
init|=
operator|(
name|PVBUS_EXT
operator|)
name|arg
decl_stmt|;
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_intr
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
name|hpt_pci_intr
argument_list|(
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|PVBUS_EXT
name|vbus_ext
init|=
operator|(
name|PVBUS_EXT
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|hpt_assert_vbus_locked
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_intr
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_async
parameter_list|(
name|void
modifier|*
name|callback_arg
parameter_list|,
name|u_int32_t
name|code
parameter_list|,
name|struct
name|cam_path
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"<8>hpt_async"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|KdPrint
argument_list|(
operator|(
literal|"hpt_shutdown(dev=%p)"
operator|,
name|dev
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* we don't allow the driver to be unloaded. */
return|return
name|EBUSY
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_ioctl_done
parameter_list|(
name|struct
name|_IOCTL_ARG
modifier|*
name|arg
parameter_list|)
block|{
name|arg
operator|->
name|ioctl_cmnd
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__hpt_do_ioctl
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|,
name|IOCTL_ARG
modifier|*
name|ioctl_args
parameter_list|)
block|{
name|ioctl_args
operator|->
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|ioctl_args
operator|->
name|done
operator|=
name|hpt_ioctl_done
expr_stmt|;
name|ioctl_args
operator|->
name|ioctl_cmnd
operator|=
operator|(
name|void
operator|*
operator|)
literal|1
expr_stmt|;
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|ldm_ioctl
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|,
name|ioctl_args
argument_list|)
expr_stmt|;
while|while
condition|(
name|ioctl_args
operator|->
name|ioctl_cmnd
condition|)
block|{
if|if
condition|(
name|hpt_sleep
argument_list|(
name|vbus_ext
argument_list|,
name|ioctl_args
argument_list|,
name|PPAUSE
argument_list|,
literal|"hptctl"
argument_list|,
name|HPT_OSM_TIMEOUT
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ldm_reset_vbus
argument_list|(
operator|(
name|PVBUS
operator|)
name|vbus_ext
operator|->
name|vbus
argument_list|)
expr_stmt|;
name|__hpt_do_tasks
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
block|}
comment|/* KdPrint(("ioctl %x result %d", ioctl_args->dwIoControlCode, ioctl_args->result)); */
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_do_ioctl
parameter_list|(
name|IOCTL_ARG
modifier|*
name|ioctl_args
parameter_list|)
block|{
name|PVBUS
name|vbus
decl_stmt|;
name|PVBUS_EXT
name|vbus_ext
decl_stmt|;
name|ldm_for_each_vbus
argument_list|(
argument|vbus
argument_list|,
argument|vbus_ext
argument_list|)
block|{
name|__hpt_do_ioctl
argument_list|(
name|vbus_ext
argument_list|,
name|ioctl_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl_args
operator|->
name|result
operator|!=
name|HPT_IOCTL_RESULT_WRONG_VBUS
condition|)
return|return;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|HPT_DO_IOCTL
parameter_list|(
name|code
parameter_list|,
name|inbuf
parameter_list|,
name|insize
parameter_list|,
name|outbuf
parameter_list|,
name|outsize
parameter_list|)
value|({\ 	IOCTL_ARG arg;\ 	arg.dwIoControlCode = code;\ 	arg.lpInBuffer = inbuf;\ 	arg.lpOutBuffer = outbuf;\ 	arg.nInBufferSize = insize;\ 	arg.nOutBufferSize = outsize;\ 	arg.lpBytesReturned = 0;\ 	hpt_do_ioctl(&arg);\ 	arg.result;\ })
end_define

begin_define
define|#
directive|define
name|DEVICEID_VALID
parameter_list|(
name|id
parameter_list|)
value|((id)&& ((HPT_U32)(id)!=0xffffffff))
end_define

begin_function
specifier|static
name|int
name|hpt_get_logical_devices
parameter_list|(
name|DEVICEID
modifier|*
name|pIds
parameter_list|,
name|int
name|nMaxCount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HPT_U32
name|count
init|=
name|nMaxCount
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|HPT_DO_IOCTL
argument_list|(
name|HPT_IOCTL_GET_LOGICAL_DEVICES
argument_list|,
operator|&
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|HPT_U32
argument_list|)
argument_list|,
name|pIds
argument_list|,
sizeof|sizeof
argument_list|(
name|DEVICEID
argument_list|)
operator|*
name|nMaxCount
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|nMaxCount
operator|=
operator|(
name|int
operator|)
name|pIds
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nMaxCount
condition|;
name|i
operator|++
control|)
name|pIds
index|[
name|i
index|]
operator|=
name|pIds
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
return|return
name|nMaxCount
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpt_get_device_info_v3
parameter_list|(
name|DEVICEID
name|id
parameter_list|,
name|PLOGICAL_DEVICE_INFO_V3
name|pInfo
parameter_list|)
block|{
return|return
name|HPT_DO_IOCTL
argument_list|(
name|HPT_IOCTL_GET_DEVICE_INFO_V3
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|DEVICEID
argument_list|)
argument_list|,
name|pInfo
argument_list|,
sizeof|sizeof
argument_list|(
name|LOGICAL_DEVICE_INFO_V3
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* not belong to this file logically, but we want to use ioctl interface */
end_comment

begin_function
specifier|static
name|int
name|__hpt_stop_tasks
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|,
name|DEVICEID
name|id
parameter_list|)
block|{
name|LOGICAL_DEVICE_INFO_V3
name|devinfo
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
decl_stmt|;
name|DEVICEID
name|param
index|[
literal|2
index|]
init|=
block|{
name|id
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|hpt_get_device_info_v3
argument_list|(
name|id
argument_list|,
operator|&
name|devinfo
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|devinfo
operator|.
name|Type
operator|!=
name|LDT_ARRAY
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|Flags
operator|&
name|ARRAY_FLAG_REBUILDING
condition|)
name|param
index|[
literal|1
index|]
operator|=
name|AS_REBUILD_ABORT
expr_stmt|;
elseif|else
if|if
condition|(
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|Flags
operator|&
name|ARRAY_FLAG_VERIFYING
condition|)
name|param
index|[
literal|1
index|]
operator|=
name|AS_VERIFY_ABORT
expr_stmt|;
elseif|else
if|if
condition|(
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|Flags
operator|&
name|ARRAY_FLAG_INITIALIZING
condition|)
name|param
index|[
literal|1
index|]
operator|=
name|AS_INITIALIZE_ABORT
expr_stmt|;
elseif|else
if|if
condition|(
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|Flags
operator|&
name|ARRAY_FLAG_TRANSFORMING
condition|)
name|param
index|[
literal|1
index|]
operator|=
name|AS_TRANSFORM_ABORT
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
name|KdPrint
argument_list|(
operator|(
literal|"SET_ARRAY_STATE(%x, %d)"
operator|,
name|param
index|[
literal|0
index|]
operator|,
name|param
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|HPT_DO_IOCTL
argument_list|(
name|HPT_IOCTL_SET_ARRAY_STATE
argument_list|,
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|nDisk
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DEVICEID_VALID
argument_list|(
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|Members
index|[
name|i
index|]
argument_list|)
condition|)
name|__hpt_stop_tasks
argument_list|(
name|vbus_ext
argument_list|,
name|devinfo
operator|.
name|u
operator|.
name|array
operator|.
name|Members
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpt_stop_tasks
parameter_list|(
name|PVBUS_EXT
name|vbus_ext
parameter_list|)
block|{
name|DEVICEID
name|ids
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
name|hpt_get_logical_devices
argument_list|(
operator|(
name|DEVICEID
operator|*
operator|)
operator|&
name|ids
argument_list|,
sizeof|sizeof
argument_list|(
name|ids
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ids
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|__hpt_stop_tasks
argument_list|(
name|vbus_ext
argument_list|,
name|ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|d_open_t
name|hpt_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|hpt_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|hpt_ioctl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|hpt_rescan_bus
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|hpt_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|hpt_open
block|,
operator|.
name|d_close
operator|=
name|hpt_close
block|,
operator|.
name|d_ioctl
operator|=
name|hpt_ioctl
block|,
operator|.
name|d_name
operator|=
name|driver_name
block|,
operator|.
name|d_version
operator|=
name|D_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|intr_config_hook
name|hpt_ich
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hpt_final_init will be called after all hpt_attach.  */
end_comment

begin_function
specifier|static
name|void
name|hpt_final_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|unit_number
init|=
literal|0
decl_stmt|;
name|PVBUS_EXT
name|vbus_ext
decl_stmt|;
name|PVBUS
name|vbus
decl_stmt|;
name|PHBA
name|hba
decl_stmt|;
comment|/* Clear the config hook */
name|config_intrhook_disestablish
argument_list|(
operator|&
name|hpt_ich
argument_list|)
expr_stmt|;
comment|/* allocate memory */
name|i
operator|=
literal|0
expr_stmt|;
name|ldm_for_each_vbus
argument_list|(
argument|vbus
argument_list|,
argument|vbus_ext
argument_list|)
block|{
if|if
condition|(
name|hpt_alloc_mem
argument_list|(
name|vbus_ext
argument_list|)
condition|)
block|{
name|os_printk
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|os_printk
argument_list|(
literal|"no controller detected."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* initializing hardware */
name|ldm_for_each_vbus
argument_list|(
argument|vbus
argument_list|,
argument|vbus_ext
argument_list|)
block|{
comment|/* make timer available here */
name|mtx_init
argument_list|(
operator|&
name|vbus_ext
operator|->
name|lock
argument_list|,
literal|"hptsleeplock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
name|callout_handle_init
argument_list|(
operator|&
name|vbus_ext
operator|->
name|timer
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_init_mtx
argument_list|(
operator|&
name|vbus_ext
operator|->
name|timer
argument_list|,
operator|&
name|vbus_ext
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hpt_init_vbus
argument_list|(
name|vbus_ext
argument_list|)
condition|)
block|{
name|os_printk
argument_list|(
literal|"fail to initialize hardware"
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME */
block|}
block|}
comment|/* register CAM interface */
name|ldm_for_each_vbus
argument_list|(
argument|vbus
argument_list|,
argument|vbus_ext
argument_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|struct
name|ccb_setasync
name|ccb
decl_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|4
argument_list|,
comment|/* alignment */
name|BUS_SPACE_MAXADDR_32BIT
operator|+
literal|1
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|PAGE_SIZE
operator|*
operator|(
name|os_max_sg_descriptors
operator|-
literal|1
operator|)
argument_list|,
comment|/* maxsize */
name|os_max_sg_descriptors
argument_list|,
comment|/* nsegments */
literal|0x10000
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_WAITOK
argument_list|,
comment|/* flags */
name|busdma_lock_mutex
argument_list|,
comment|/* lockfunc */
operator|&
name|vbus_ext
operator|->
name|lock
argument_list|,
comment|/* lockfuncarg */
operator|&
name|vbus_ext
operator|->
name|io_dmat
comment|/* tag */
argument_list|)
condition|)
block|{
return|return ;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|os_max_queue_comm
condition|;
name|i
operator|++
control|)
block|{
name|POS_CMDEXT
name|ext
init|=
operator|(
name|POS_CMDEXT
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|OS_CMDEXT
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ext
condition|)
block|{
name|os_printk
argument_list|(
literal|"Can't alloc cmdext(%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return ;
block|}
name|ext
operator|->
name|vbus_ext
operator|=
name|vbus_ext
expr_stmt|;
name|ext
operator|->
name|next
operator|=
name|vbus_ext
operator|->
name|cmdext_list
expr_stmt|;
name|vbus_ext
operator|->
name|cmdext_list
operator|=
name|ext
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|vbus_ext
operator|->
name|io_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ext
operator|->
name|dma_map
argument_list|)
condition|)
block|{
name|os_printk
argument_list|(
literal|"Can't create dma map(%d)"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return ;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|callout_init_mtx
argument_list|(
operator|&
name|ext
operator|->
name|timeout
argument_list|,
operator|&
name|vbus_ext
operator|->
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|os_max_queue_comm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|os_printk
argument_list|(
literal|"cam_simq_alloc failed"
argument_list|)
expr_stmt|;
return|return ;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
name|vbus_ext
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|hpt_action
argument_list|,
name|hpt_poll
argument_list|,
name|driver_name
argument_list|,
name|vbus_ext
argument_list|,
name|unit_number
argument_list|,
operator|&
name|vbus_ext
operator|->
name|lock
argument_list|,
name|os_max_queue_comm
argument_list|,
comment|/*tagged*/
literal|8
argument_list|,
name|devq
argument_list|)
expr_stmt|;
else|#
directive|else
name|vbus_ext
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|hpt_action
argument_list|,
name|hpt_poll
argument_list|,
name|driver_name
argument_list|,
name|vbus_ext
argument_list|,
name|unit_number
argument_list|,
operator|&
name|Giant
argument_list|,
name|os_max_queue_comm
argument_list|,
comment|/*tagged*/
literal|8
argument_list|,
name|devq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unit_number
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|vbus_ext
operator|->
name|sim
condition|)
block|{
name|os_printk
argument_list|(
literal|"cam_sim_alloc failed"
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
return|return ;
block|}
name|hpt_lock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|vbus_ext
operator|->
name|sim
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|os_printk
argument_list|(
literal|"xpt_bus_register failed"
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|vbus_ext
operator|->
name|sim
argument_list|,
comment|/*free devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|vbus_ext
operator|->
name|sim
operator|=
name|NULL
expr_stmt|;
return|return ;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|vbus_ext
operator|->
name|path
argument_list|,
comment|/*periph */
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|vbus_ext
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
name|os_printk
argument_list|(
literal|"xpt_create_path failed"
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|vbus_ext
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|vbus_ext
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|vbus_ext
operator|->
name|sim
operator|=
name|NULL
expr_stmt|;
return|return ;
block|}
name|xpt_setup_ccb
argument_list|(
operator|&
name|ccb
operator|.
name|ccb_h
argument_list|,
name|vbus_ext
operator|->
name|path
argument_list|,
comment|/*priority*/
literal|5
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SASYNC_CB
expr_stmt|;
name|ccb
operator|.
name|event_enable
operator|=
name|AC_LOST_DEVICE
expr_stmt|;
name|ccb
operator|.
name|callback
operator|=
name|hpt_async
expr_stmt|;
name|ccb
operator|.
name|callback_arg
operator|=
name|vbus_ext
expr_stmt|;
name|xpt_action
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
operator|&
name|ccb
argument_list|)
expr_stmt|;
name|hpt_unlock_vbus
argument_list|(
name|vbus_ext
argument_list|)
expr_stmt|;
for|for
control|(
name|hba
operator|=
name|vbus_ext
operator|->
name|hba_list
init|;
name|hba
condition|;
name|hba
operator|=
name|hba
operator|->
name|next
control|)
block|{
name|int
name|rid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|hba
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|hba
operator|->
name|pcidev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|os_printk
argument_list|(
literal|"can't allocate interrupt"
argument_list|)
expr_stmt|;
return|return ;
block|}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>=
literal|1000510
operator|)
if|if
condition|(
name|bus_setup_intr
argument_list|(
argument|hba->pcidev
argument_list|,
argument|hba->irq_res
argument_list|,
argument|INTR_TYPE_CAM | INTR_MPSAFE
argument_list|,
else|#
directive|else
argument|if (bus_setup_intr(hba->pcidev, hba->irq_res, INTR_TYPE_CAM,
endif|#
directive|endif
argument|NULL, hpt_pci_intr, vbus_ext,&hba->irq_handle))  			{ 				os_printk(
literal|"can't set up interrupt"
argument|); 				return ; 			} 			hba->ldm_adapter.him->intr_control(hba->ldm_adapter.him_handle, HPT_TRUE);  		}  		vbus_ext->shutdown_eh = EVENTHANDLER_REGISTER(shutdown_final,  									hpt_shutdown_vbus, vbus_ext, SHUTDOWN_PRI_DEFAULT); 		if (!vbus_ext->shutdown_eh) 			os_printk(
literal|"Shutdown event registration failed"
argument|); 	} 	 	ldm_for_each_vbus(vbus, vbus_ext) { 		TASK_INIT(&vbus_ext->worker,
literal|0
argument|, (task_fn_t *)hpt_do_tasks, vbus_ext); 		if (vbus_ext->tasks) 			TASK_ENQUEUE(&vbus_ext->worker); 	}	  	make_dev(&hpt_cdevsw, DRIVER_MINOR, UID_ROOT, GID_OPERATOR, 	    S_IRUSR | S_IWUSR,
literal|"%s"
argument|, driver_name); }
if|#
directive|if
name|defined
argument_list|(
name|KLD_MODULE
argument_list|)
argument|typedef struct driverlink *driverlink_t; struct driverlink { 	kobj_class_t	driver; 	TAILQ_ENTRY(driverlink) link;
comment|/* list of drivers in devclass */
argument|};  typedef TAILQ_HEAD(driver_list, driverlink) driver_list_t;  struct devclass { 	TAILQ_ENTRY(devclass) link; 	devclass_t	parent;
comment|/* parent in devclass hierarchy */
argument|driver_list_t	drivers;
comment|/* bus devclasses store drivers for bus */
argument|char		*name; 	device_t	*devices;
comment|/* array of devices indexed by unit */
argument|int		maxunit;
comment|/* size of devices array */
argument|};  static void override_kernel_driver(void) { 	driverlink_t dl
argument_list|,
argument|dlfirst; 	driver_t *tmpdriver; 	devclass_t dc = devclass_find(
literal|"pci"
argument|); 	 	if (dc){ 		dlfirst = TAILQ_FIRST(&dc->drivers); 		for (dl = dlfirst; dl; dl = TAILQ_NEXT(dl, link)) { 			if(strcmp(dl->driver->name, driver_name) ==
literal|0
argument|) { 				tmpdriver=dl->driver; 				dl->driver=dlfirst->driver; 				dlfirst->driver=tmpdriver; 				break; 			} 		} 	} }
else|#
directive|else
define|#
directive|define
name|override_kernel_driver
parameter_list|()
endif|#
directive|endif
argument|static void hpt_init(void *dummy) { 	if (bootverbose) 		os_printk(
literal|"%s %s"
argument|, driver_name_long, driver_ver);  	override_kernel_driver(); 	init_config();  	hpt_ich.ich_func = hpt_final_init; 	hpt_ich.ich_arg = NULL; 	if (config_intrhook_establish(&hpt_ich) !=
literal|0
argument|) { 		printf(
literal|"%s: cannot establish configuration hook\n"
argument|, 		    driver_name_long); 	}  } SYSINIT(hptinit, SI_SUB_CONFIGURE, SI_ORDER_FIRST, hpt_init, NULL);
comment|/*  * CAM driver interface  */
argument|static device_method_t driver_methods[] = {
comment|/* Device interface */
argument|DEVMETHOD(device_probe,		hpt_probe)
argument_list|,
argument|DEVMETHOD(device_attach,	hpt_attach)
argument_list|,
argument|DEVMETHOD(device_detach,	hpt_detach)
argument_list|,
argument|DEVMETHOD(device_shutdown,	hpt_shutdown)
argument_list|,
argument|{
literal|0
argument_list|,
literal|0
argument|} };  static driver_t hpt_pci_driver = { 	driver_name
argument_list|,
argument|driver_methods
argument_list|,
argument|sizeof(HBA) };  static devclass_t	hpt_devclass;
ifndef|#
directive|ifndef
name|TARGETNAME
error|#
directive|error
literal|"no TARGETNAME found"
endif|#
directive|endif
comment|/* use this to make TARGETNAME be expanded */
define|#
directive|define
name|__DRIVER_MODULE
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|,
name|p6
parameter_list|)
value|DRIVER_MODULE(p1, p2, p3, p4, p5, p6)
define|#
directive|define
name|__MODULE_VERSION
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
value|MODULE_VERSION(p1, p2)
define|#
directive|define
name|__MODULE_DEPEND
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|p3
parameter_list|,
name|p4
parameter_list|,
name|p5
parameter_list|)
value|MODULE_DEPEND(p1, p2, p3, p4, p5)
argument|__DRIVER_MODULE(TARGETNAME, pci, hpt_pci_driver, hpt_devclass,
literal|0
argument|,
literal|0
argument|); __MODULE_VERSION(TARGETNAME,
literal|1
argument|); __MODULE_DEPEND(TARGETNAME, cam,
literal|1
argument|,
literal|1
argument|,
literal|1
argument|);  static int hpt_open(struct cdev *dev, int flags, int devtype, struct thread *td) { 	return
literal|0
argument|; }  static int hpt_close(struct cdev *dev, int flags, int devtype, struct thread *td) { 	return
literal|0
argument|; }  static int hpt_ioctl(struct cdev *dev, u_long cmd, caddr_t data, int fflag, struct thread *td) { 	PHPT_IOCTL_PARAM piop=(PHPT_IOCTL_PARAM)data; 	IOCTL_ARG ioctl_args; 	HPT_U32 bytesReturned;  	switch (cmd){ 	case HPT_DO_IOCONTROL: 	{	 		if (piop->Magic == HPT_IOCTL_MAGIC || piop->Magic == HPT_IOCTL_MAGIC32) { 			KdPrint((
literal|"<8>ioctl=%x in=%p len=%d out=%p len=%d\n"
argument|, 				piop->dwIoControlCode, 				piop->lpInBuffer, 				piop->nInBufferSize, 				piop->lpOutBuffer, 				piop->nOutBufferSize)); 			 		memset(&ioctl_args,
literal|0
argument|, sizeof(ioctl_args)); 		 		ioctl_args.dwIoControlCode = piop->dwIoControlCode; 		ioctl_args.nInBufferSize = piop->nInBufferSize; 		ioctl_args.nOutBufferSize = piop->nOutBufferSize; 		ioctl_args.lpBytesReturned =&bytesReturned;  		if (ioctl_args.nInBufferSize) { 			ioctl_args.lpInBuffer = malloc(ioctl_args.nInBufferSize, M_DEVBUF, M_WAITOK); 			if (!ioctl_args.lpInBuffer) 				goto invalid; 			if (copyin((void*)piop->lpInBuffer, 					ioctl_args.lpInBuffer, piop->nInBufferSize)) 				goto invalid; 		} 	 		if (ioctl_args.nOutBufferSize) { 			ioctl_args.lpOutBuffer = malloc(ioctl_args.nOutBufferSize, M_DEVBUF, M_WAITOK); 			if (!ioctl_args.lpOutBuffer) 				goto invalid; 		}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1000510
argument|mtx_lock(&Giant);
endif|#
directive|endif
argument|hpt_do_ioctl(&ioctl_args);
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|1000510
argument|mtx_unlock(&Giant);
endif|#
directive|endif
argument|if (ioctl_args.result==HPT_IOCTL_RESULT_OK) { 			if (piop->nOutBufferSize) { 				if (copyout(ioctl_args.lpOutBuffer, 					(void*)piop->lpOutBuffer, piop->nOutBufferSize)) 					goto invalid; 			} 			if (piop->lpBytesReturned) { 				if (copyout(&bytesReturned, 					(void*)piop->lpBytesReturned, sizeof(HPT_U32))) 					goto invalid; 			} 			if (ioctl_args.lpInBuffer) free(ioctl_args.lpInBuffer, M_DEVBUF); 			if (ioctl_args.lpOutBuffer) free(ioctl_args.lpOutBuffer, M_DEVBUF); 			return
literal|0
argument|; 		} invalid: 		if (ioctl_args.lpInBuffer) free(ioctl_args.lpInBuffer, M_DEVBUF); 		if (ioctl_args.lpOutBuffer) free(ioctl_args.lpOutBuffer, M_DEVBUF); 		return EFAULT; 	} 	return EFAULT; 	}  	case HPT_SCAN_BUS: 	{ 		return hpt_rescan_bus(); 	} 	default: 		KdPrint((
literal|"invalid command!"
argument|)); 		return EFAULT; 	}	  }  static int	hpt_rescan_bus(void) { 	union ccb			*ccb; 	PVBUS 				vbus; 	PVBUS_EXT			vbus_ext;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
argument|mtx_lock(&Giant);
endif|#
directive|endif
argument|ldm_for_each_vbus(vbus, vbus_ext) { 		if ((ccb = xpt_alloc_ccb()) == NULL) 		{ 			return(ENOMEM); 		}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
argument|if (xpt_create_path(&ccb->ccb_h.path, xpt_periph, cam_sim_path(vbus_ext->sim),
else|#
directive|else
argument|if (xpt_create_path(&ccb->ccb_h.path, NULL, cam_sim_path(vbus_ext->sim),
endif|#
directive|endif
argument|CAM_TARGET_WILDCARD, CAM_LUN_WILDCARD) != CAM_REQ_CMP)	 		{ 			xpt_free_ccb(ccb); 			return(EIO); 		} 		xpt_rescan(ccb); 	}
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|<
literal|1000510
operator|)
argument|mtx_unlock(&Giant);
endif|#
directive|endif
argument|return(
literal|0
argument|);	 }
end_function

end_unit

