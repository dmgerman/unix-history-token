begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Sam Leffler, Errno Consulting  * Copyright (c) 2003 Global Technology Associates, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SafeNet SafeXcel-1141 hardware crypto accelerator  */
end_comment

begin_include
include|#
directive|include
file|"opt_safe.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha1.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptosoft.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SAFE_RNDTEST
end_ifdef

begin_include
include|#
directive|include
file|<dev/rndtest/rndtest.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/safe/safereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/safe/safevar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|bswap32
end_ifndef

begin_define
define|#
directive|define
name|bswap32
value|NTOHL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes and count for the pci_device structure  */
end_comment

begin_function_decl
specifier|static
name|int
name|safe_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|safe_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|safe_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|safe_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|safe_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|safe_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|safe_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|safe_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|safe_driver
init|=
block|{
literal|"safe"
block|,
name|safe_methods
block|,
expr|sizeof
operator|(
expr|struct
name|safe_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|safe_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|safe
argument_list|,
name|pci
argument_list|,
name|safe_driver
argument_list|,
name|safe_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|safe
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SAFE_RNDTEST
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|safe
argument_list|,
name|rndtest
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|safe_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_newsession
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|,
name|struct
name|cryptoini
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_freesession
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_process
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|cryptop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_callback
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_feed
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_mcopy
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|SAFE_NO_RNG
end_ifndef

begin_function_decl
specifier|static
name|void
name|safe_rng_init
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_rng
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAFE_NO_RNG */
end_comment

begin_function_decl
specifier|static
name|int
name|safe_dma_malloc
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|struct
name|safe_dma_alloc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|safe_dma_sync
parameter_list|(
name|_dma
parameter_list|,
name|_flags
parameter_list|)
define|\
value|bus_dmamap_sync((_dma)->dma_tag, (_dma)->dma_map, (_flags))
end_define

begin_function_decl
specifier|static
name|void
name|safe_dma_free
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
name|struct
name|safe_dma_alloc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_dmamap_aligned
parameter_list|(
specifier|const
name|struct
name|safe_operand
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_dmamap_uniform
parameter_list|(
specifier|const
name|struct
name|safe_operand
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_reset_board
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_init_board
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_init_pciregs
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_cleanchip
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_totalreset
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|safe_free_entry
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|safe
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"SafeNet driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SAFE_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|safe_dump_dmastatus
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_dump_ringstate
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_dump_intrstate
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|safe_dump_request
parameter_list|(
name|struct
name|safe_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|safe_softc
modifier|*
name|safec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use by hw.safe.dump */
end_comment

begin_decl_stmt
specifier|static
name|int
name|safe_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_safe
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|safe_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging msgs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|_x
parameter_list|)
value|if (safe_debug) printf _x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|_x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|READ_REG
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_4((sc)->sc_st, (sc)->sc_sh, (r))
end_define

begin_define
define|#
directive|define
name|WRITE_REG
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4((sc)->sc_st, (sc)->sc_sh, reg, val)
end_define

begin_decl_stmt
name|struct
name|safe_stats
name|safestats
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_hw_safe
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|safestats
argument_list|,
name|safe_stats
argument_list|,
literal|"driver statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SAFE_NO_RNG
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|safe_rnginterval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll once a second */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_safe
argument_list|,
name|OID_AUTO
argument_list|,
name|rnginterval
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|safe_rnginterval
argument_list|,
literal|0
argument_list|,
literal|"RNG polling interval (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|safe_rngbufsize
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 64 bytes each poll  */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_safe
argument_list|,
name|OID_AUTO
argument_list|,
name|rngbufsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|safe_rngbufsize
argument_list|,
literal|0
argument_list|,
literal|"RNG polling buffer size (32-bit words)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|safe_rngmaxalarm
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max alarms before reset */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_safe
argument_list|,
name|OID_AUTO
argument_list|,
name|rngmaxalarm
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|safe_rngmaxalarm
argument_list|,
literal|0
argument_list|,
literal|"RNG max alarms before reset"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAFE_NO_RNG */
end_comment

begin_function
specifier|static
name|int
name|safe_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_SAFENET
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_SAFEXCEL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|safe_partname
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX sprintf numbers when not decoded */
switch|switch
condition|(
name|pci_get_vendor
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_VENDOR_SAFENET
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_SAFEXCEL
case|:
return|return
literal|"SafeNet SafeXcel-1141"
return|;
block|}
return|return
literal|"SafeNet unknown-part"
return|;
block|}
return|return
literal|"Unknown-vendor unknown-part"
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SAFE_NO_RNG
end_ifndef

begin_function
specifier|static
name|void
name|default_harvest
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|random_harvest
argument_list|(
name|buf
argument_list|,
name|count
argument_list|,
name|count
operator|*
name|NBBY
argument_list|,
literal|0
argument_list|,
name|RANDOM_PURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAFE_NO_RNG */
end_comment

begin_function
specifier|static
name|int
name|safe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|raddr
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|,
name|i
decl_stmt|,
name|devinfo
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* XXX handle power management */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable memory mapping\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|cmd
operator|&
name|PCIM_CMD_BUSMASTEREN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable bus mastering\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*  	 * Setup memory-mapping of PCI registers. 	 */
name|rid
operator|=
name|BS_BAR
expr_stmt|;
name|sc
operator|->
name|sc_sr
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map register space\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
comment|/* 	 * Arrange interrupt line. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad1
goto|;
block|}
comment|/* 	 * NB: Network code assumes we are blocked with splimp() 	 *     so make sure the IRQ is mapped appropriately. 	 */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|safe_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not establish interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|sc
operator|->
name|sc_cid
operator|=
name|crypto_get_driverid
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cid
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get crypto driver id\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad3
goto|;
block|}
name|sc
operator|->
name|sc_chiprev
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DEVINFO
argument_list|)
operator|&
operator|(
name|SAFE_DEVINFO_REV_MAJ
operator||
name|SAFE_DEVINFO_REV_MIN
operator|)
expr_stmt|;
comment|/* 	 * Setup DMA descriptor area. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
name|SAFE_DMA_BOUNDARY
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|SAFE_MAX_DMA
argument_list|,
comment|/* maxsize */
name|SAFE_MAX_PART
argument_list|,
comment|/* nsegments */
name|SAFE_MAX_SSIZE
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* locking */
operator|&
name|sc
operator|->
name|sc_srcdmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
comment|/* alignment */
name|SAFE_MAX_DSIZE
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|SAFE_MAX_DMA
argument_list|,
comment|/* maxsize */
name|SAFE_MAX_PART
argument_list|,
comment|/* nsegments */
name|SAFE_MAX_DSIZE
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* locking */
operator|&
name|sc
operator|->
name|sc_dstdmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
comment|/* 	 * Allocate packet engine descriptors. 	 */
if|if
condition|(
name|safe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|SAFE_MAX_NQUEUE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_ringalloc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate PE descriptor ring\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|)
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
comment|/* 	 * Hookup the static portion of all our data structures. 	 */
name|sc
operator|->
name|sc_ring
operator|=
operator|(
expr|struct
name|safe_ringentry
operator|*
operator|)
name|sc
operator|->
name|sc_ringalloc
operator|.
name|dma_vaddr
expr_stmt|;
name|sc
operator|->
name|sc_ringtop
operator|=
name|sc
operator|->
name|sc_ring
operator|+
name|SAFE_MAX_NQUEUE
expr_stmt|;
name|sc
operator|->
name|sc_front
operator|=
name|sc
operator|->
name|sc_ring
expr_stmt|;
name|sc
operator|->
name|sc_back
operator|=
name|sc
operator|->
name|sc_ring
expr_stmt|;
name|raddr
operator|=
name|sc
operator|->
name|sc_ringalloc
operator|.
name|dma_paddr
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ring
argument_list|,
name|SAFE_MAX_NQUEUE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SAFE_MAX_NQUEUE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|safe_ringentry
modifier|*
name|re
init|=
operator|&
name|sc
operator|->
name|sc_ring
index|[
name|i
index|]
decl_stmt|;
name|re
operator|->
name|re_desc
operator|.
name|d_sa
operator|=
name|raddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|,
name|re_sa
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_sa
operator|.
name|sa_staterec
operator|=
name|raddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|,
name|re_sastate
argument_list|)
expr_stmt|;
name|raddr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|)
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"packet engine ring"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate scatter and gather particle descriptors. 	 */
if|if
condition|(
name|safe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|SAFE_TOTAL_SPART
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_pdesc
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_spalloc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate source particle "
literal|"descriptor ring\n"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
name|safe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ringalloc
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|)
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
name|sc
operator|->
name|sc_spring
operator|=
operator|(
expr|struct
name|safe_pdesc
operator|*
operator|)
name|sc
operator|->
name|sc_spalloc
operator|.
name|dma_vaddr
expr_stmt|;
name|sc
operator|->
name|sc_springtop
operator|=
name|sc
operator|->
name|sc_spring
operator|+
name|SAFE_TOTAL_SPART
expr_stmt|;
name|sc
operator|->
name|sc_spfree
operator|=
name|sc
operator|->
name|sc_spring
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_spring
argument_list|,
name|SAFE_TOTAL_SPART
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_pdesc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_dma_malloc
argument_list|(
name|sc
argument_list|,
name|SAFE_TOTAL_DPART
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_pdesc
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_dpalloc
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate destination particle "
literal|"descriptor ring\n"
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
name|safe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_spalloc
argument_list|)
expr_stmt|;
name|safe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ringalloc
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|)
expr_stmt|;
goto|goto
name|bad4
goto|;
block|}
name|sc
operator|->
name|sc_dpring
operator|=
operator|(
expr|struct
name|safe_pdesc
operator|*
operator|)
name|sc
operator|->
name|sc_dpalloc
operator|.
name|dma_vaddr
expr_stmt|;
name|sc
operator|->
name|sc_dpringtop
operator|=
name|sc
operator|->
name|sc_dpring
operator|+
name|SAFE_TOTAL_DPART
expr_stmt|;
name|sc
operator|->
name|sc_dpfree
operator|=
name|sc
operator|->
name|sc_dpring
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_dpring
argument_list|,
name|SAFE_TOTAL_DPART
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_pdesc
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s"
argument_list|,
name|safe_partname
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|devinfo
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DEVINFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|devinfo
operator|&
name|SAFE_DEVINFO_RNG
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SAFE_FLAGS_RNG
expr_stmt|;
name|printf
argument_list|(
literal|" rng"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|&
name|SAFE_DEVINFO_PKEY
condition|)
block|{
if|#
directive|if
literal|0
block|printf(" key"); 		sc->sc_flags |= SAFE_FLAGS_KEY; 		crypto_kregister(sc->sc_cid, CRK_MOD_EXP, 0, 			safe_kprocess, sc); 		crypto_kregister(sc->sc_cid, CRK_MOD_EXP_CRT, 0, 			safe_kprocess, sc);
endif|#
directive|endif
block|}
if|if
condition|(
name|devinfo
operator|&
name|SAFE_DEVINFO_DES
condition|)
block|{
name|printf
argument_list|(
literal|" des/3des"
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_3DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|&
name|SAFE_DEVINFO_AES
condition|)
block|{
name|printf
argument_list|(
literal|" aes"
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_AES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|&
name|SAFE_DEVINFO_MD5
condition|)
block|{
name|printf
argument_list|(
literal|" md5"
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devinfo
operator|&
name|SAFE_DEVINFO_SHA1
condition|)
block|{
name|printf
argument_list|(
literal|" sha1"
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" null"
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_NULL_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_NULL_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|safe_newsession
argument_list|,
name|safe_freesession
argument_list|,
name|safe_process
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX other supported algorithms */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|safe_reset_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset h/w */
name|safe_init_pciregs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* init pci settings */
name|safe_init_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* init h/w */
ifndef|#
directive|ifndef
name|SAFE_NO_RNG
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SAFE_FLAGS_RNG
condition|)
block|{
ifdef|#
directive|ifdef
name|SAFE_RNDTEST
name|sc
operator|->
name|sc_rndtest
operator|=
name|rndtest_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rndtest
condition|)
name|sc
operator|->
name|sc_harvest
operator|=
name|rndtest_harvest
expr_stmt|;
else|else
name|sc
operator|->
name|sc_harvest
operator|=
name|default_harvest
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_harvest
operator|=
name|default_harvest
expr_stmt|;
endif|#
directive|endif
name|safe_rng_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|hz
operator|*
name|safe_rnginterval
argument_list|,
name|safe_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SAFE_NO_RNG */
ifdef|#
directive|ifdef
name|SAFE_DEBUG
name|safec
operator|=
name|sc
expr_stmt|;
comment|/* for use by hw.safe.dump */
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|bad4
label|:
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
name|bad3
label|:
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bad2
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|bad1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|BS_BAR
argument_list|,
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
name|bad
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a device that successfully probed.  */
end_comment

begin_function
specifier|static
name|int
name|safe_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* XXX wait/abort active ops */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|)
expr_stmt|;
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAFE_RNDTEST
if|if
condition|(
name|sc
operator|->
name|sc_rndtest
condition|)
name|rndtest_detach
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|safe_cleanchip
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|safe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_dpalloc
argument_list|)
expr_stmt|;
name|safe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_spalloc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
name|safe_dma_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ringalloc
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|BS_BAR
argument_list|,
name|sc
operator|->
name|sc_sr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop all chip i/o so that the kernel's probe routines don't  * get confused by errant DMAs when rebooting.  */
end_comment

begin_function
specifier|static
name|void
name|safe_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|safe_stop
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Device suspend routine.  */
end_comment

begin_function
specifier|static
name|int
name|safe_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX stop the device and save PCI settings */
endif|#
directive|endif
name|sc
operator|->
name|sc_suspended
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|safe_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX retore PCI settings and start the device */
endif|#
directive|endif
name|sc
operator|->
name|sc_suspended
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SafeXcel Interrupt routine  */
end_comment

begin_function
specifier|static
name|void
name|safe_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
specifier|volatile
name|u_int32_t
name|stat
decl_stmt|;
name|stat
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HM_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
comment|/* shared irq, not for us */
return|return;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_CLR
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* IACK */
if|if
condition|(
operator|(
name|stat
operator|&
name|SAFE_INT_PE_DDONE
operator|)
condition|)
block|{
comment|/* 		 * Descriptor(s) done; scan the ring and 		 * process completed operations. 		 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_back
operator|!=
name|sc
operator|->
name|sc_front
condition|)
block|{
name|struct
name|safe_ringentry
modifier|*
name|re
init|=
name|sc
operator|->
name|sc_back
decl_stmt|;
ifdef|#
directive|ifdef
name|SAFE_DEBUG
if|if
condition|(
name|safe_debug
condition|)
block|{
name|safe_dump_ringstate
argument_list|(
name|sc
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|safe_dump_request
argument_list|(
name|sc
argument_list|,
name|__func__
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 			 * safe_process marks ring entries that were allocated 			 * but not used with a csr of zero.  This insures the 			 * ring front pointer never needs to be set backwards 			 * in the event that an entry is allocated but not used 			 * because of a setup error. 			 */
if|if
condition|(
name|re
operator|->
name|re_desc
operator|.
name|d_csr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|SAFE_PE_CSR_IS_DONE
argument_list|(
name|re
operator|->
name|re_desc
operator|.
name|d_csr
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|SAFE_PE_LEN_IS_DONE
argument_list|(
name|re
operator|->
name|re_desc
operator|.
name|d_len
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|sc_nqchip
operator|--
expr_stmt|;
name|safe_callback
argument_list|(
name|sc
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
operator|(
name|sc
operator|->
name|sc_back
operator|)
operator|==
name|sc
operator|->
name|sc_ringtop
condition|)
name|sc
operator|->
name|sc_back
operator|=
name|sc
operator|->
name|sc_ring
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check to see if we got any DMA Error 	 */
if|if
condition|(
name|stat
operator|&
name|SAFE_INT_PE_ERROR
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"dmaerr dmastat %08x\n"
operator|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMASTAT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_dmaerr
operator|++
expr_stmt|;
name|safe_totalreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|safe_feed(sc);
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|sc_needwakeup
condition|)
block|{
comment|/* XXX check high watermark */
name|int
name|wakeup
init|=
name|sc
operator|->
name|sc_needwakeup
operator|&
operator|(
name|CRYPTO_SYMQ
operator||
name|CRYPTO_ASYMQ
operator|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: wakeup crypto %x\n"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_needwakeup
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_needwakeup
operator|&=
operator|~
name|wakeup
expr_stmt|;
name|crypto_unblock
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|wakeup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * safe_feed() - post a request to chip  */
end_comment

begin_function
specifier|static
name|void
name|safe_feed
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
name|re
parameter_list|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|re_dst_map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* XXX have no smaller granularity */
name|safe_dma_sync
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringalloc
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|safe_dma_sync
argument_list|(
operator|&
name|sc
operator|->
name|sc_spalloc
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|safe_dma_sync
argument_list|(
operator|&
name|sc
operator|->
name|sc_dpalloc
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SAFE_DEBUG
if|if
condition|(
name|safe_debug
condition|)
block|{
name|safe_dump_ringstate
argument_list|(
name|sc
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|safe_dump_request
argument_list|(
name|sc
argument_list|,
name|__func__
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_nqchip
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nqchip
operator|>
name|safestats
operator|.
name|st_maxqchip
condition|)
name|safestats
operator|.
name|st_maxqchip
operator|=
name|sc
operator|->
name|sc_nqchip
expr_stmt|;
comment|/* poke h/w to check descriptor ring, any value can be written */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_RD_DESCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new 'session' and return an encoded session id.  'sidp'  * contains our registration id, and should contain an encoded session  * id on successful allocation.  */
end_comment

begin_function
specifier|static
name|int
name|safe_newsession
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|u_int32_t
modifier|*
name|sidp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof (a[0]))
name|struct
name|cryptoini
modifier|*
name|c
decl_stmt|,
modifier|*
name|encini
init|=
name|NULL
decl_stmt|,
modifier|*
name|macini
init|=
name|NULL
decl_stmt|;
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|safe_session
modifier|*
name|ses
init|=
name|NULL
decl_stmt|;
name|MD5_CTX
name|md5ctx
decl_stmt|;
name|SHA1_CTX
name|sha1ctx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sesn
decl_stmt|;
if|if
condition|(
name|sidp
operator|==
name|NULL
operator|||
name|cri
operator|==
name|NULL
operator|||
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|c
operator|=
name|cri
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|cri_next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_NULL_HMAC
condition|)
block|{
if|if
condition|(
name|macini
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|macini
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_AES_CBC
operator|||
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_NULL_CBC
condition|)
block|{
if|if
condition|(
name|encini
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|encini
operator|=
name|c
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|encini
operator|==
name|NULL
operator|&&
name|macini
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|encini
condition|)
block|{
comment|/* validate key length */
switch|switch
condition|(
name|encini
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_DES_CBC
case|:
if|if
condition|(
name|encini
operator|->
name|cri_klen
operator|!=
literal|64
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|CRYPTO_3DES_CBC
case|:
if|if
condition|(
name|encini
operator|->
name|cri_klen
operator|!=
literal|192
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|CRYPTO_AES_CBC
case|:
if|if
condition|(
name|encini
operator|->
name|cri_klen
operator|!=
literal|128
operator|&&
name|encini
operator|->
name|cri_klen
operator|!=
literal|192
operator|&&
name|encini
operator|->
name|cri_klen
operator|!=
literal|256
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_sessions
operator|==
name|NULL
condition|)
block|{
name|ses
operator|=
name|sc
operator|->
name|sc_sessions
operator|=
operator|(
expr|struct
name|safe_session
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|safe_session
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sesn
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_nsessions
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|sesn
operator|=
literal|0
init|;
name|sesn
operator|<
name|sc
operator|->
name|sc_nsessions
condition|;
name|sesn
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
operator|.
name|ses_used
operator|==
literal|0
condition|)
block|{
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|sesn
operator|=
name|sc
operator|->
name|sc_nsessions
expr_stmt|;
name|ses
operator|=
operator|(
expr|struct
name|safe_session
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|sesn
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_session
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|sesn
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_session
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|sesn
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|safe_session
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sessions
operator|=
name|ses
expr_stmt|;
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
expr_stmt|;
name|sc
operator|->
name|sc_nsessions
operator|++
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
name|ses
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|safe_session
argument_list|)
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_used
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|encini
condition|)
block|{
comment|/* get an IV */
comment|/* XXX may read fewer than requested */
name|read_random
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|ses
operator|->
name|ses_iv
argument_list|)
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_klen
operator|=
name|encini
operator|->
name|cri_klen
expr_stmt|;
name|bcopy
argument_list|(
name|encini
operator|->
name|cri_key
argument_list|,
name|ses
operator|->
name|ses_key
argument_list|,
name|ses
operator|->
name|ses_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* PE is little-endian, insure proper byte order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ses
operator|->
name|ses_key
argument_list|)
condition|;
name|i
operator|++
control|)
name|ses
operator|->
name|ses_key
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|ses
operator|->
name|ses_key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|macini
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macini
operator|->
name|cri_klen
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|macini
operator|->
name|cri_key
index|[
name|i
index|]
operator|^=
name|HMAC_IPAD_VAL
expr_stmt|;
if|if
condition|(
name|macini
operator|->
name|cri_alg
operator|==
name|CRYPTO_MD5_HMAC
condition|)
block|{
name|MD5Init
argument_list|(
operator|&
name|md5ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|macini
operator|->
name|cri_key
argument_list|,
name|macini
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|hmac_ipad_buffer
argument_list|,
name|HMAC_BLOCK_LEN
operator|-
operator|(
name|macini
operator|->
name|cri_klen
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|,
name|ses
operator|->
name|ses_hminner
argument_list|,
sizeof|sizeof
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|macini
operator|->
name|cri_key
argument_list|,
name|macini
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|hmac_ipad_buffer
argument_list|,
name|HMAC_BLOCK_LEN
operator|-
operator|(
name|macini
operator|->
name|cri_klen
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|,
name|ses
operator|->
name|ses_hminner
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macini
operator|->
name|cri_klen
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|macini
operator|->
name|cri_key
index|[
name|i
index|]
operator|^=
operator|(
name|HMAC_IPAD_VAL
operator|^
name|HMAC_OPAD_VAL
operator|)
expr_stmt|;
if|if
condition|(
name|macini
operator|->
name|cri_alg
operator|==
name|CRYPTO_MD5_HMAC
condition|)
block|{
name|MD5Init
argument_list|(
operator|&
name|md5ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|macini
operator|->
name|cri_key
argument_list|,
name|macini
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5ctx
argument_list|,
name|hmac_opad_buffer
argument_list|,
name|HMAC_BLOCK_LEN
operator|-
operator|(
name|macini
operator|->
name|cri_klen
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|,
name|ses
operator|->
name|ses_hmouter
argument_list|,
sizeof|sizeof
argument_list|(
name|md5ctx
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|macini
operator|->
name|cri_key
argument_list|,
name|macini
operator|->
name|cri_klen
operator|/
literal|8
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|hmac_opad_buffer
argument_list|,
name|HMAC_BLOCK_LEN
operator|-
operator|(
name|macini
operator|->
name|cri_klen
operator|/
literal|8
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|,
name|ses
operator|->
name|ses_hmouter
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
operator|.
name|h
operator|.
name|b32
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macini
operator|->
name|cri_klen
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|macini
operator|->
name|cri_key
index|[
name|i
index|]
operator|^=
name|HMAC_OPAD_VAL
expr_stmt|;
comment|/* PE is little-endian, insure proper byte order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ses
operator|->
name|ses_hminner
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ses
operator|->
name|ses_hminner
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|ses
operator|->
name|ses_hminner
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ses
operator|->
name|ses_hmouter
index|[
name|i
index|]
operator|=
name|htole32
argument_list|(
name|ses
operator|->
name|ses_hmouter
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sidp
operator|=
name|SAFE_SID
argument_list|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sesn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Deallocate a session.  */
end_comment

begin_function
specifier|static
name|int
name|safe_freesession
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|session
decl_stmt|,
name|ret
decl_stmt|;
name|u_int32_t
name|sid
init|=
operator|(
operator|(
name|u_int32_t
operator|)
name|tid
operator|)
operator|&
literal|0xffffffff
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|session
operator|=
name|SAFE_SESSION
argument_list|(
name|sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|<
name|sc
operator|->
name|sc_nsessions
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|session
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_sessions
index|[
name|session
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_op_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|safe_operand
modifier|*
name|op
init|=
name|arg
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: mapsize %u nsegs %d error %d\n"
operator|,
name|__func__
operator|,
operator|(
name|u_int
operator|)
name|mapsize
operator|,
name|nsegs
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|op
operator|->
name|mapsize
operator|=
name|mapsize
expr_stmt|;
name|op
operator|->
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|bcopy
argument_list|(
name|seg
argument_list|,
name|op
operator|->
name|segs
argument_list|,
name|nsegs
operator|*
sizeof|sizeof
argument_list|(
name|seg
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|safe_process
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|nicealign
decl_stmt|,
name|uniform
decl_stmt|;
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd1
decl_stmt|,
modifier|*
name|crd2
decl_stmt|,
modifier|*
name|maccrd
decl_stmt|,
modifier|*
name|enccrd
decl_stmt|;
name|int
name|bypass
decl_stmt|,
name|oplen
decl_stmt|,
name|ivsize
decl_stmt|;
name|caddr_t
name|iv
decl_stmt|;
name|int16_t
name|coffset
decl_stmt|;
name|struct
name|safe_session
modifier|*
name|ses
decl_stmt|;
name|struct
name|safe_ringentry
modifier|*
name|re
decl_stmt|;
name|struct
name|safe_sarec
modifier|*
name|sa
decl_stmt|;
name|struct
name|safe_pdesc
modifier|*
name|pd
decl_stmt|;
name|u_int32_t
name|cmd0
decl_stmt|,
name|cmd1
decl_stmt|,
name|staterec
decl_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
operator|||
name|crp
operator|->
name|crp_callback
operator|==
name|NULL
operator|||
name|sc
operator|==
name|NULL
condition|)
block|{
name|safestats
operator|.
name|st_invalid
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|SAFE_SESSION
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
operator|>=
name|sc
operator|->
name|sc_nsessions
condition|)
block|{
name|safestats
operator|.
name|st_badsession
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_front
operator|==
name|sc
operator|->
name|sc_back
operator|&&
name|sc
operator|->
name|sc_nqchip
operator|!=
literal|0
condition|)
block|{
name|safestats
operator|.
name|st_ringfull
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_needwakeup
operator||=
name|CRYPTO_SYMQ
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|re
operator|=
name|sc
operator|->
name|sc_front
expr_stmt|;
name|staterec
operator|=
name|re
operator|->
name|re_sa
operator|.
name|sa_staterec
expr_stmt|;
comment|/* save */
comment|/* NB: zero everything but the PE descriptor */
name|bzero
argument_list|(
operator|&
name|re
operator|->
name|re_sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|re
operator|->
name|re_desc
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_sa
operator|.
name|sa_staterec
operator|=
name|staterec
expr_stmt|;
comment|/* restore */
name|re
operator|->
name|re_crp
operator|=
name|crp
expr_stmt|;
name|re
operator|->
name|re_sesn
operator|=
name|SAFE_SESSION
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|re
operator|->
name|re_src_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|re
operator|->
name|re_dst_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
name|re
operator|->
name|re_src_io
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|re
operator|->
name|re_dst_io
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
block|}
else|else
block|{
name|safestats
operator|.
name|st_badflags
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
comment|/* XXX we don't handle contiguous blocks! */
block|}
name|sa
operator|=
operator|&
name|re
operator|->
name|re_sa
expr_stmt|;
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|re
operator|->
name|re_sesn
index|]
expr_stmt|;
name|crd1
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|crd1
operator|==
name|NULL
condition|)
block|{
name|safestats
operator|.
name|st_nodesc
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|crd2
operator|=
name|crd1
operator|->
name|crd_next
expr_stmt|;
name|cmd0
operator|=
name|SAFE_SA_CMD0_BASIC
expr_stmt|;
comment|/* basic group operation */
name|cmd1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crd2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_HMAC
condition|)
block|{
name|maccrd
operator|=
name|crd1
expr_stmt|;
name|enccrd
operator|=
name|NULL
expr_stmt|;
name|cmd0
operator||=
name|SAFE_SA_CMD0_OP_HASH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_CBC
condition|)
block|{
name|maccrd
operator|=
name|NULL
expr_stmt|;
name|enccrd
operator|=
name|crd1
expr_stmt|;
name|cmd0
operator||=
name|SAFE_SA_CMD0_OP_CRYPT
expr_stmt|;
block|}
else|else
block|{
name|safestats
operator|.
name|st_badalg
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_HMAC
operator|)
operator|&&
operator|(
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_CBC
operator|)
operator|&&
operator|(
operator|(
name|crd2
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|maccrd
operator|=
name|crd1
expr_stmt|;
name|enccrd
operator|=
name|crd2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_CBC
operator|)
operator|&&
operator|(
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_HMAC
operator|)
operator|&&
operator|(
name|crd1
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|enccrd
operator|=
name|crd1
expr_stmt|;
name|maccrd
operator|=
name|crd2
expr_stmt|;
block|}
else|else
block|{
name|safestats
operator|.
name|st_badalg
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|cmd0
operator||=
name|SAFE_SA_CMD0_OP_BOTH
expr_stmt|;
block|}
if|if
condition|(
name|enccrd
condition|)
block|{
if|if
condition|(
name|enccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
condition|)
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_DES
expr_stmt|;
name|cmd1
operator||=
name|SAFE_SA_CMD1_CBC
expr_stmt|;
name|ivsize
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
condition|)
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_3DES
expr_stmt|;
name|cmd1
operator||=
name|SAFE_SA_CMD1_CBC
expr_stmt|;
name|ivsize
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
condition|)
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_AES
expr_stmt|;
name|cmd1
operator||=
name|SAFE_SA_CMD1_CBC
expr_stmt|;
if|if
condition|(
name|ses
operator|->
name|ses_klen
operator|==
literal|128
condition|)
name|cmd1
operator||=
name|SAFE_SA_CMD1_AES128
expr_stmt|;
elseif|else
if|if
condition|(
name|ses
operator|->
name|ses_klen
operator|==
literal|192
condition|)
name|cmd1
operator||=
name|SAFE_SA_CMD1_AES192
expr_stmt|;
else|else
name|cmd1
operator||=
name|SAFE_SA_CMD1_AES256
expr_stmt|;
name|ivsize
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_CRYPT_NULL
expr_stmt|;
name|ivsize
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Setup encrypt/decrypt state.  When using basic ops 		 * we can't use an inline IV because hash/crypt offset 		 * must be from the end of the IV to the start of the 		 * crypt data and this leaves out the preceding header 		 * from the hash calculation.  Instead we place the IV 		 * in the state record and set the hash/crypt offset to 		 * copy both the header+IV. 		 */
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_OUTBOUND
expr_stmt|;
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|iv
operator|=
name|enccrd
operator|->
name|crd_iv
expr_stmt|;
else|else
name|iv
operator|=
operator|(
name|caddr_t
operator|)
name|ses
operator|->
name|ses_iv
expr_stmt|;
if|if
condition|(
operator|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
name|m_copyback
argument_list|(
name|re
operator|->
name|re_src_m
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
name|ivsize
argument_list|,
name|iv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
name|cuio_copyback
argument_list|(
name|re
operator|->
name|re_src_io
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
name|ivsize
argument_list|,
name|iv
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|iv
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
argument_list|,
name|ivsize
argument_list|)
expr_stmt|;
name|cmd0
operator||=
name|SAFE_SA_CMD0_IVLD_STATE
operator||
name|SAFE_SA_CMD0_SAVEIV
expr_stmt|;
name|re
operator|->
name|re_flags
operator||=
name|SAFE_QFLAGS_COPYOUTIV
expr_stmt|;
block|}
else|else
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_INBOUND
expr_stmt|;
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|enccrd
operator|->
name|crd_iv
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
argument_list|,
name|ivsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
name|m_copydata
argument_list|(
name|re
operator|->
name|re_src_m
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
name|ivsize
argument_list|,
operator|(
name|caddr_t
operator|)
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
name|cuio_copydata
argument_list|(
name|re
operator|->
name|re_src_io
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
name|ivsize
argument_list|,
operator|(
name|caddr_t
operator|)
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
argument_list|)
expr_stmt|;
name|cmd0
operator||=
name|SAFE_SA_CMD0_IVLD_STATE
expr_stmt|;
block|}
comment|/* 		 * For basic encryption use the zero pad algorithm. 		 * This pads results to an 8-byte boundary and 		 * suppresses padding verification for inbound (i.e. 		 * decrypt) operations. 		 * 		 * NB: Not sure if the 8-byte pad boundary is a problem. 		 */
name|cmd0
operator||=
name|SAFE_SA_CMD0_PAD_ZERO
expr_stmt|;
comment|/* XXX assert key bufs have the same size */
name|bcopy
argument_list|(
name|ses
operator|->
name|ses_key
argument_list|,
name|sa
operator|->
name|sa_key
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maccrd
condition|)
block|{
if|if
condition|(
name|maccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
condition|)
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_MD5
expr_stmt|;
name|cmd1
operator||=
name|SAFE_SA_CMD1_HMAC
expr_stmt|;
comment|/* NB: enable HMAC */
block|}
elseif|else
if|if
condition|(
name|maccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
condition|)
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_SHA1
expr_stmt|;
name|cmd1
operator||=
name|SAFE_SA_CMD1_HMAC
expr_stmt|;
comment|/* NB: enable HMAC */
block|}
else|else
block|{
name|cmd0
operator||=
name|SAFE_SA_CMD0_HASH_NULL
expr_stmt|;
block|}
comment|/* 		 * Digest data is loaded from the SA and the hash 		 * result is saved to the state block where we 		 * retrieve it for return to the caller. 		 */
comment|/* XXX assert digest bufs have the same size */
name|bcopy
argument_list|(
name|ses
operator|->
name|ses_hminner
argument_list|,
name|sa
operator|->
name|sa_indigest
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_indigest
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ses
operator|->
name|ses_hmouter
argument_list|,
name|sa
operator|->
name|sa_outdigest
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_outdigest
argument_list|)
argument_list|)
expr_stmt|;
name|cmd0
operator||=
name|SAFE_SA_CMD0_HSLD_SA
operator||
name|SAFE_SA_CMD0_SAVEHASH
expr_stmt|;
name|re
operator|->
name|re_flags
operator||=
name|SAFE_QFLAGS_COPYOUTICV
expr_stmt|;
block|}
if|if
condition|(
name|enccrd
operator|&&
name|maccrd
condition|)
block|{
comment|/* 		 * The offset from hash data to the start of 		 * crypt data is the difference in the skips. 		 */
name|bypass
operator|=
name|maccrd
operator|->
name|crd_skip
expr_stmt|;
name|coffset
operator|=
name|enccrd
operator|->
name|crd_skip
operator|-
name|maccrd
operator|->
name|crd_skip
expr_stmt|;
if|if
condition|(
name|coffset
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: hash does not precede crypt; "
literal|"mac skip %u enc skip %u\n"
operator|,
name|__func__
operator|,
name|maccrd
operator|->
name|crd_skip
operator|,
name|enccrd
operator|->
name|crd_skip
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_skipmismatch
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|oplen
operator|=
name|enccrd
operator|->
name|crd_skip
operator|+
name|enccrd
operator|->
name|crd_len
expr_stmt|;
if|if
condition|(
name|maccrd
operator|->
name|crd_skip
operator|+
name|maccrd
operator|->
name|crd_len
operator|!=
name|oplen
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s: hash amount %u != crypt amount %u\n"
operator|,
name|__func__
operator|,
name|maccrd
operator|->
name|crd_skip
operator|+
name|maccrd
operator|->
name|crd_len
operator|,
name|oplen
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_lenmismatch
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
ifdef|#
directive|ifdef
name|SAFE_DEBUG
if|if
condition|(
name|safe_debug
condition|)
block|{
name|printf
argument_list|(
literal|"mac: skip %d, len %d, inject %d\n"
argument_list|,
name|maccrd
operator|->
name|crd_skip
argument_list|,
name|maccrd
operator|->
name|crd_len
argument_list|,
name|maccrd
operator|->
name|crd_inject
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enc: skip %d, len %d, inject %d\n"
argument_list|,
name|enccrd
operator|->
name|crd_skip
argument_list|,
name|enccrd
operator|->
name|crd_len
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bypass %d coffset %d oplen %d\n"
argument_list|,
name|bypass
argument_list|,
name|coffset
argument_list|,
name|oplen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|coffset
operator|&
literal|3
condition|)
block|{
comment|/* offset must be 32-bit aligned */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: coffset %u misaligned\n"
operator|,
name|__func__
operator|,
name|coffset
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_coffmisaligned
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|coffset
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
name|coffset
operator|>
literal|255
condition|)
block|{
comment|/* offset must be<256 dwords */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: coffset %u too big\n"
operator|,
name|__func__
operator|,
name|coffset
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_cofftoobig
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
comment|/* 		 * Tell the hardware to copy the header to the output. 		 * The header is defined as the data from the end of 		 * the bypass to the start of data to be encrypted.  		 * Typically this is the inline IV.  Note that you need 		 * to do this even if src+dst are the same; it appears 		 * that w/o this bit the crypted data is written 		 * immediately after the bypass data. 		 */
name|cmd1
operator||=
name|SAFE_SA_CMD1_HDRCOPY
expr_stmt|;
comment|/* 		 * Disable IP header mutable bit handling.  This is 		 * needed to get correct HMAC calculations. 		 */
name|cmd1
operator||=
name|SAFE_SA_CMD1_MUTABLE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|enccrd
condition|)
block|{
name|bypass
operator|=
name|enccrd
operator|->
name|crd_skip
expr_stmt|;
name|oplen
operator|=
name|bypass
operator|+
name|enccrd
operator|->
name|crd_len
expr_stmt|;
block|}
else|else
block|{
name|bypass
operator|=
name|maccrd
operator|->
name|crd_skip
expr_stmt|;
name|oplen
operator|=
name|bypass
operator|+
name|maccrd
operator|->
name|crd_len
expr_stmt|;
block|}
name|coffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX verify multiple of 4 when using s/g */
if|if
condition|(
name|bypass
operator|>
literal|96
condition|)
block|{
comment|/* bypass offset must be<= 96 bytes */
name|DPRINTF
argument_list|(
operator|(
literal|"%s: bypass %u too big\n"
operator|,
name|__func__
operator|,
name|bypass
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_bypasstoobig
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|re
operator|->
name|re_src_map
argument_list|)
condition|)
block|{
name|safestats
operator|.
name|st_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|,
name|re
operator|->
name|re_src_m
argument_list|,
name|safe_op_cb
argument_list|,
operator|&
name|re
operator|->
name|re_src
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_src_map
operator|=
name|NULL
expr_stmt|;
name|safestats
operator|.
name|st_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|,
name|re
operator|->
name|re_src_io
argument_list|,
name|safe_op_cb
argument_list|,
operator|&
name|re
operator|->
name|re_src
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_src_map
operator|=
name|NULL
expr_stmt|;
name|safestats
operator|.
name|st_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
name|nicealign
operator|=
name|safe_dmamap_aligned
argument_list|(
operator|&
name|re
operator|->
name|re_src
argument_list|)
expr_stmt|;
name|uniform
operator|=
name|safe_dmamap_uniform
argument_list|(
operator|&
name|re
operator|->
name|re_src
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"src nicealign %u uniform %u nsegs %u\n"
operator|,
name|nicealign
operator|,
name|uniform
operator|,
name|re
operator|->
name|re_src
operator|.
name|nsegs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|re_src
operator|.
name|nsegs
operator|>
literal|1
condition|)
block|{
name|re
operator|->
name|re_desc
operator|.
name|d_src
operator|=
name|sc
operator|->
name|sc_spalloc
operator|.
name|dma_paddr
operator|+
operator|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_spfree
operator|-
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_spring
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|re
operator|->
name|re_src_nsegs
condition|;
name|i
operator|++
control|)
block|{
comment|/* NB: no need to check if there's space */
name|pd
operator|=
name|sc
operator|->
name|sc_spfree
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|sc
operator|->
name|sc_spfree
operator|)
operator|==
name|sc
operator|->
name|sc_springtop
condition|)
name|sc
operator|->
name|sc_spfree
operator|=
name|sc
operator|->
name|sc_spring
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pd
operator|->
name|pd_flags
operator|&
literal|3
operator|)
operator|==
literal|0
operator|||
operator|(
name|pd
operator|->
name|pd_flags
operator|&
literal|3
operator|)
operator|==
name|SAFE_PD_DONE
argument_list|,
operator|(
literal|"bogus source particle descriptor; flags %x"
operator|,
name|pd
operator|->
name|pd_flags
operator|)
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_addr
operator|=
name|re
operator|->
name|re_src_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pd
operator|->
name|pd_size
operator|=
name|re
operator|->
name|re_src_segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
name|pd
operator|->
name|pd_flags
operator|=
name|SAFE_PD_READY
expr_stmt|;
block|}
name|cmd0
operator||=
name|SAFE_SA_CMD0_IGATHER
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No need for gather, reference the operand directly. 		 */
name|re
operator|->
name|re_desc
operator|.
name|d_src
operator|=
name|re
operator|->
name|re_src_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
if|if
condition|(
name|enccrd
operator|==
name|NULL
operator|&&
name|maccrd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Hash op; no destination needed. 		 */
block|}
else|else
block|{
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
if|if
condition|(
operator|!
name|nicealign
condition|)
block|{
name|safestats
operator|.
name|st_iovmisaligned
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|uniform
operator|!=
literal|1
condition|)
block|{
comment|/* 				 * Source is not suitable for direct use as 				 * the destination.  Create a new scatter/gather 				 * list based on the destination requirements 				 * and check if that's ok. 				 */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|re
operator|->
name|re_dst_map
argument_list|)
condition|)
block|{
name|safestats
operator|.
name|st_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|,
name|re
operator|->
name|re_dst_io
argument_list|,
name|safe_op_cb
argument_list|,
operator|&
name|re
operator|->
name|re_dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_dst_map
operator|=
name|NULL
expr_stmt|;
name|safestats
operator|.
name|st_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|uniform
operator|=
name|safe_dmamap_uniform
argument_list|(
operator|&
name|re
operator|->
name|re_dst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uniform
condition|)
block|{
comment|/* 					 * There's no way to handle the DMA 					 * requirements with this uio.  We 					 * could create a separate DMA area for 					 * the result and then copy it back, 					 * but for now we just bail and return 					 * an error.  Note that uio requests 					 *> SAFE_MAX_DSIZE are handled because 					 * the DMA map and segment list for the 					 * destination wil result in a 					 * destination particle list that does 					 * the necessary scatter DMA. 					 */
name|safestats
operator|.
name|st_iovnotuniform
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
else|else
name|re
operator|->
name|re_dst
operator|=
name|re
operator|->
name|re_src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|nicealign
operator|&&
name|uniform
operator|==
literal|1
condition|)
block|{
comment|/* 				 * Source layout is suitable for direct 				 * sharing of the DMA map and segment list. 				 */
name|re
operator|->
name|re_dst
operator|=
name|re
operator|->
name|re_src
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nicealign
operator|&&
name|uniform
operator|==
literal|2
condition|)
block|{
comment|/* 				 * The source is properly aligned but requires a 				 * different particle list to handle DMA of the 				 * result.  Create a new map and do the load to 				 * create the segment list.  The particle 				 * descriptor setup code below will handle the 				 * rest. 				 */
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|re
operator|->
name|re_dst_map
argument_list|)
condition|)
block|{
name|safestats
operator|.
name|st_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|,
name|re
operator|->
name|re_dst_m
argument_list|,
name|safe_op_cb
argument_list|,
operator|&
name|re
operator|->
name|re_dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_dst_map
operator|=
name|NULL
expr_stmt|;
name|safestats
operator|.
name|st_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
else|else
block|{
comment|/* !(aligned and/or uniform) */
name|int
name|totlen
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
comment|/* 				 * DMA constraints require that we allocate a 				 * new mbuf chain for the destination.  We 				 * allocate an entire new set of mbufs of 				 * optimal/required size and then tell the 				 * hardware to copy any bits that are not 				 * created as a byproduct of the operation. 				 */
if|if
condition|(
operator|!
name|nicealign
condition|)
name|safestats
operator|.
name|st_unaligned
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|uniform
condition|)
name|safestats
operator|.
name|st_notuniform
operator|++
expr_stmt|;
name|totlen
operator|=
name|re
operator|->
name|re_src_mapsize
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|re_src_m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|len
operator|=
name|MHLEN
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|!
name|m_dup_pkthdr
argument_list|(
name|m
argument_list|,
name|re
operator|->
name|re_src_m
argument_list|,
name|M_DONTWAIT
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
name|MLEN
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|safestats
operator|.
name|st_nombuf
operator|++
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|sc_nqchip
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_nomcl
operator|++
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|sc_nqchip
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_nombuf
operator|++
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|sc_nqchip
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|&&
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_nomcl
operator|++
expr_stmt|;
name|err
operator|=
name|sc
operator|->
name|sc_nqchip
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|re
operator|->
name|re_dst_m
operator|=
name|top
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|re
operator|->
name|re_dst_map
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|safestats
operator|.
name|st_nomap
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|,
name|re
operator|->
name|re_dst_m
argument_list|,
name|safe_op_cb
argument_list|,
operator|&
name|re
operator|->
name|re_dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
name|re
operator|->
name|re_dst_map
operator|=
name|NULL
expr_stmt|;
name|safestats
operator|.
name|st_noload
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|re
operator|->
name|re_src
operator|.
name|mapsize
operator|>
name|oplen
condition|)
block|{
comment|/* 					 * There's data following what the 					 * hardware will copy for us.  If this 					 * isn't just the ICV (that's going to 					 * be written on completion), copy it 					 * to the new mbufs 					 */
if|if
condition|(
operator|!
operator|(
name|maccrd
operator|&&
operator|(
name|re
operator|->
name|re_src
operator|.
name|mapsize
operator|-
name|oplen
operator|)
operator|==
literal|12
operator|&&
name|maccrd
operator|->
name|crd_inject
operator|==
name|oplen
operator|)
condition|)
name|safe_mcopy
argument_list|(
name|re
operator|->
name|re_src_m
argument_list|,
name|re
operator|->
name|re_dst_m
argument_list|,
name|oplen
argument_list|)
expr_stmt|;
else|else
name|safestats
operator|.
name|st_noicvcopy
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|safestats
operator|.
name|st_badflags
operator|++
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|re
operator|->
name|re_dst
operator|.
name|nsegs
operator|>
literal|1
condition|)
block|{
name|re
operator|->
name|re_desc
operator|.
name|d_dst
operator|=
name|sc
operator|->
name|sc_dpalloc
operator|.
name|dma_paddr
operator|+
operator|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_dpfree
operator|-
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_dpring
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|re
operator|->
name|re_dst_nsegs
condition|;
name|i
operator|++
control|)
block|{
name|pd
operator|=
name|sc
operator|->
name|sc_dpfree
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pd
operator|->
name|pd_flags
operator|&
literal|3
operator|)
operator|==
literal|0
operator|||
operator|(
name|pd
operator|->
name|pd_flags
operator|&
literal|3
operator|)
operator|==
name|SAFE_PD_DONE
argument_list|,
operator|(
literal|"bogus dest particle descriptor; flags %x"
operator|,
name|pd
operator|->
name|pd_flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|sc
operator|->
name|sc_dpfree
operator|)
operator|==
name|sc
operator|->
name|sc_dpringtop
condition|)
name|sc
operator|->
name|sc_dpfree
operator|=
name|sc
operator|->
name|sc_dpring
expr_stmt|;
name|pd
operator|->
name|pd_addr
operator|=
name|re
operator|->
name|re_dst_segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|pd
operator|->
name|pd_flags
operator|=
name|SAFE_PD_READY
expr_stmt|;
block|}
name|cmd0
operator||=
name|SAFE_SA_CMD0_OSCATTER
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No need for scatter, reference the operand directly. 			 */
name|re
operator|->
name|re_desc
operator|.
name|d_dst
operator|=
name|re
operator|->
name|re_dst_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
block|}
comment|/* 	 * All done with setup; fillin the SA command words 	 * and the packet engine descriptor.  The operation 	 * is now ready for submission to the hardware. 	 */
name|sa
operator|->
name|sa_cmd0
operator|=
name|cmd0
operator||
name|SAFE_SA_CMD0_IPCI
operator||
name|SAFE_SA_CMD0_OPCI
expr_stmt|;
name|sa
operator|->
name|sa_cmd1
operator|=
name|cmd1
operator||
operator|(
name|coffset
operator|<<
name|SAFE_SA_CMD1_OFFSET_S
operator|)
operator||
name|SAFE_SA_CMD1_SAREV1
comment|/* Rev 1 SA data structure */
operator||
name|SAFE_SA_CMD1_SRPCI
expr_stmt|;
comment|/* 	 * NB: the order of writes is important here.  In case the 	 * chip is scanning the ring because of an outstanding request 	 * it might nab this one too.  In that case we need to make 	 * sure the setup is complete before we write the length 	 * field of the descriptor as it signals the descriptor is 	 * ready for processing. 	 */
name|re
operator|->
name|re_desc
operator|.
name|d_csr
operator|=
name|SAFE_PE_CSR_READY
operator||
name|SAFE_PE_CSR_SAPCI
expr_stmt|;
if|if
condition|(
name|maccrd
condition|)
name|re
operator|->
name|re_desc
operator|.
name|d_csr
operator||=
name|SAFE_PE_CSR_LOADSA
operator||
name|SAFE_PE_CSR_HASHFINAL
expr_stmt|;
name|re
operator|->
name|re_desc
operator|.
name|d_len
operator|=
name|oplen
operator||
name|SAFE_PE_LEN_READY
operator||
operator|(
name|bypass
operator|<<
name|SAFE_PE_LEN_BYPASS_S
operator|)
expr_stmt|;
name|safestats
operator|.
name|st_ipackets
operator|++
expr_stmt|;
name|safestats
operator|.
name|st_ibytes
operator|+=
name|oplen
expr_stmt|;
if|if
condition|(
operator|++
operator|(
name|sc
operator|->
name|sc_front
operator|)
operator|==
name|sc
operator|->
name|sc_ringtop
condition|)
name|sc
operator|->
name|sc_front
operator|=
name|sc
operator|->
name|sc_ring
expr_stmt|;
comment|/* XXX honor batching */
name|safe_feed
argument_list|(
name|sc
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errout
label|:
if|if
condition|(
operator|(
name|re
operator|->
name|re_dst_m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|re
operator|->
name|re_src_m
operator|!=
name|re
operator|->
name|re_dst_m
operator|)
condition|)
name|m_freem
argument_list|(
name|re
operator|->
name|re_dst_m
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|re_dst_map
operator|!=
name|NULL
operator|&&
name|re
operator|->
name|re_dst_map
operator|!=
name|re
operator|->
name|re_src_map
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|re_src_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ERESTART
condition|)
block|{
name|crp
operator|->
name|crp_etype
operator|=
name|err
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_needwakeup
operator||=
name|CRYPTO_SYMQ
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_callback
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|cryptop
modifier|*
name|crp
init|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
name|re
operator|->
name|re_crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|safestats
operator|.
name|st_opackets
operator|++
expr_stmt|;
name|safestats
operator|.
name|st_obytes
operator|+=
name|re
operator|->
name|re_dst
operator|.
name|mapsize
expr_stmt|;
name|safe_dma_sync
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringalloc
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|re_desc
operator|.
name|d_csr
operator|&
name|SAFE_PE_CSR_STATUS
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"csr 0x%x cmd0 0x%x cmd1 0x%x\n"
argument_list|,
name|re
operator|->
name|re_desc
operator|.
name|d_csr
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_cmd0
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_cmd1
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_peoperr
operator|++
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|EIO
expr_stmt|;
comment|/* something more meaningful? */
block|}
if|if
condition|(
name|re
operator|->
name|re_dst_map
operator|!=
name|NULL
operator|&&
name|re
operator|->
name|re_dst_map
operator|!=
name|re
operator|->
name|re_src_map
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dstdmat
argument_list|,
name|re
operator|->
name|re_dst_map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_srcdmat
argument_list|,
name|re
operator|->
name|re_src_map
argument_list|)
expr_stmt|;
comment|/*  	 * If result was written to a differet mbuf chain, swap 	 * it in as the return value and reclaim the original. 	 */
if|if
condition|(
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
operator|)
operator|&&
name|re
operator|->
name|re_src_m
operator|!=
name|re
operator|->
name|re_dst_m
condition|)
block|{
name|m_freem
argument_list|(
name|re
operator|->
name|re_src_m
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|re
operator|->
name|re_dst_m
expr_stmt|;
block|}
if|if
condition|(
name|re
operator|->
name|re_flags
operator|&
name|SAFE_QFLAGS_COPYOUTIV
condition|)
block|{
comment|/* copy out IV for future use */
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
name|int
name|ivsize
decl_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
condition|)
block|{
name|ivsize
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
condition|)
block|{
name|ivsize
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|m_copydata
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
operator|+
name|crd
operator|->
name|crd_len
operator|-
name|ivsize
argument_list|,
name|ivsize
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_sessions
index|[
name|re
operator|->
name|re_sesn
index|]
operator|.
name|ses_iv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
name|cuio_copydata
argument_list|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
operator|+
name|crd
operator|->
name|crd_len
operator|-
name|ivsize
argument_list|,
name|ivsize
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_sessions
index|[
name|re
operator|->
name|re_sesn
index|]
operator|.
name|ses_iv
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|re
operator|->
name|re_flags
operator|&
name|SAFE_QFLAGS_COPYOUTICV
condition|)
block|{
comment|/* copy out ICV result */
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_NULL_HMAC
operator|)
condition|)
continue|continue;
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
condition|)
block|{
comment|/* 				 * SHA-1 ICV's are byte-swapped; fix 'em up 				 * before copy them to their destination. 				 */
name|bswap32
argument_list|(
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bswap32
argument_list|(
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bswap32
argument_list|(
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|m_copyback
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
literal|12
argument_list|,
operator|(
name|caddr_t
operator|)
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
operator|&&
name|crp
operator|->
name|crp_mac
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
argument_list|,
name|crp
operator|->
name|crp_mac
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy all data past offset from srcm to dstm.  */
end_comment

begin_function
specifier|static
name|void
name|safe_mcopy
parameter_list|(
name|struct
name|mbuf
modifier|*
name|srcm
parameter_list|,
name|struct
name|mbuf
modifier|*
name|dstm
parameter_list|,
name|u_int
name|offset
parameter_list|)
block|{
name|u_int
name|j
decl_stmt|,
name|dlen
decl_stmt|,
name|slen
decl_stmt|;
name|caddr_t
name|dptr
decl_stmt|,
name|sptr
decl_stmt|;
comment|/* 	 * Advance src and dst to offset. 	 */
name|j
operator|=
name|offset
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|srcm
operator|->
name|m_len
operator|>
name|j
condition|)
break|break;
name|j
operator|-=
name|srcm
operator|->
name|m_len
expr_stmt|;
name|srcm
operator|=
name|srcm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|srcm
operator|==
name|NULL
condition|)
return|return;
block|}
name|sptr
operator|=
name|mtod
argument_list|(
name|srcm
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|j
expr_stmt|;
name|slen
operator|=
name|srcm
operator|->
name|m_len
operator|-
name|j
expr_stmt|;
name|j
operator|=
name|offset
expr_stmt|;
while|while
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|dstm
operator|->
name|m_len
operator|>
name|j
condition|)
break|break;
name|j
operator|-=
name|dstm
operator|->
name|m_len
expr_stmt|;
name|dstm
operator|=
name|dstm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|dstm
operator|==
name|NULL
condition|)
return|return;
block|}
name|dptr
operator|=
name|mtod
argument_list|(
name|dstm
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|j
expr_stmt|;
name|dlen
operator|=
name|dstm
operator|->
name|m_len
operator|-
name|j
expr_stmt|;
comment|/* 	 * Copy everything that remains. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|j
operator|=
name|min
argument_list|(
name|slen
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sptr
argument_list|,
name|dptr
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|==
name|j
condition|)
block|{
name|srcm
operator|=
name|srcm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|srcm
operator|==
name|NULL
condition|)
return|return;
name|sptr
operator|=
name|srcm
operator|->
name|m_data
expr_stmt|;
name|slen
operator|=
name|srcm
operator|->
name|m_len
expr_stmt|;
block|}
else|else
name|sptr
operator|+=
name|j
operator|,
name|slen
operator|-=
name|j
expr_stmt|;
if|if
condition|(
name|dlen
operator|==
name|j
condition|)
block|{
name|dstm
operator|=
name|dstm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|dstm
operator|==
name|NULL
condition|)
return|return;
name|dptr
operator|=
name|dstm
operator|->
name|m_data
expr_stmt|;
name|dlen
operator|=
name|dstm
operator|->
name|m_len
expr_stmt|;
block|}
else|else
name|dptr
operator|+=
name|j
operator|,
name|dlen
operator|-=
name|j
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SAFE_NO_RNG
end_ifndef

begin_define
define|#
directive|define
name|SAFE_RNG_MAXWAIT
value|1000
end_define

begin_function
specifier|static
name|void
name|safe_rng_init
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|w
decl_stmt|,
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* use default value according to the manual */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CNFG
argument_list|,
literal|0x834
argument_list|)
expr_stmt|;
comment|/* magic from SafeNet */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_ALM_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * There is a bug in rev 1.0 of the 1140 that when the RNG 	 * is brought out of reset the ready status flag does not 	 * work until the RNG has finished its internal initialization. 	 * 	 * So in order to determine the device is through its 	 * initialization we must read the data register, using the 	 * status reg in the read in case it is initialized.  Then read 	 * the data register until it changes from the first read. 	 * Once it changes read the data register until it changes 	 * again.  At this time the RNG is considered initialized.  	 * This could take between 750ms - 1000ms in time. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_OUT
argument_list|)
expr_stmt|;
do|do
block|{
name|v
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_OUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|w
condition|)
block|{
name|w
operator|=
name|v
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|SAFE_RNG_MAXWAIT
condition|)
do|;
comment|/* Wait Until data changes again */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|v
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_OUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|w
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|SAFE_RNG_MAXWAIT
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|safe_rng_disable_short_cycle
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CTRL
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CTRL
argument_list|)
operator|&
operator|~
name|SAFE_RNG_CTRL_SHORTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|safe_rng_enable_short_cycle
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CTRL
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CTRL
argument_list|)
operator||
name|SAFE_RNG_CTRL_SHORTEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int32_t
name|safe_rng_read
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_STAT
argument_list|)
operator|!=
literal|0
operator|&&
operator|++
name|i
operator|<
name|SAFE_RNG_MAXWAIT
condition|)
empty_stmt|;
return|return
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_OUT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_rng
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|u_int32_t
name|buf
index|[
name|SAFE_RNG_MAXBUFSIZ
index|]
decl_stmt|;
comment|/* NB: maybe move to softc */
name|u_int
name|maxwords
decl_stmt|;
name|int
name|i
decl_stmt|;
name|safestats
operator|.
name|st_rng
operator|++
expr_stmt|;
comment|/* 	 * Fetch the next block of data. 	 */
name|maxwords
operator|=
name|safe_rngbufsize
expr_stmt|;
if|if
condition|(
name|maxwords
operator|>
name|SAFE_RNG_MAXBUFSIZ
condition|)
name|maxwords
operator|=
name|SAFE_RNG_MAXBUFSIZ
expr_stmt|;
name|retry
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxwords
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|safe_rng_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Check the comparator alarm count and reset the h/w if 	 * it exceeds our threshold.  This guards against the 	 * hardware oscillators resonating with external signals. 	 */
if|if
condition|(
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_ALM_CNT
argument_list|)
operator|>
name|safe_rngmaxalarm
condition|)
block|{
name|u_int32_t
name|freq_inc
decl_stmt|,
name|w
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s: alarm count %u exceeds threshold %u\n"
operator|,
name|__func__
operator|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_ALM_CNT
argument_list|)
operator|,
name|safe_rngmaxalarm
operator|)
argument_list|)
expr_stmt|;
name|safestats
operator|.
name|st_rngalarm
operator|++
expr_stmt|;
name|safe_rng_enable_short_cycle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|freq_inc
operator|=
literal|18
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CNFG
argument_list|)
expr_stmt|;
name|freq_inc
operator|=
operator|(
operator|(
name|w
operator|+
name|freq_inc
operator|)
operator|&
literal|0x3fL
operator|)
expr_stmt|;
name|w
operator|=
operator|(
operator|(
name|w
operator|&
operator|~
literal|0x3fL
operator|)
operator||
name|freq_inc
operator|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_CNFG
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_ALM_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|safe_rng_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
if|if
condition|(
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_ALM_CNT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|safe_rng_disable_short_cycle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|freq_inc
operator|=
literal|1
expr_stmt|;
block|}
name|safe_rng_disable_short_cycle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_RNG_ALM_CNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_harvest
call|)
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|,
name|buf
argument_list|,
name|maxwords
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|hz
operator|*
operator|(
name|safe_rnginterval
condition|?
name|safe_rnginterval
else|:
literal|1
operator|)
argument_list|,
name|safe_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAFE_NO_RNG */
end_comment

begin_function
specifier|static
name|void
name|safe_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|safe_dma_malloc
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|safe_dma_alloc
modifier|*
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* locking */
operator|&
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"safe_dma_malloc: "
literal|"bus_dma_tag_create failed; error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|r
operator|=
name|bus_dmamap_create
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"safe_dma_malloc: "
literal|"bus_dmamap_create failed; error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|r
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"safe_dma_malloc: "
literal|"bus_dmammem_alloc failed; size %zu, error %u\n"
argument_list|,
name|size
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|r
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|size
argument_list|,
name|safe_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|dma_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"safe_dma_malloc: "
literal|"bus_dmamap_load failed; error %u\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|fail_3
goto|;
block|}
name|dma
operator|->
name|dma_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_3
label|:
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dmamap_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|dma_map
operator|=
name|NULL
expr_stmt|;
name|dma
operator|->
name|dma_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_dma_free
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|safe_dma_alloc
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_vaddr
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|,
name|dma
operator|->
name|dma_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resets the board.  Values in the regesters are left as is  * from the reset (i.e. initial values are assigned elsewhere).  */
end_comment

begin_function
specifier|static
name|void
name|safe_reset_board
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|;
comment|/* 	 * Reset the device.  The manual says no delay 	 * is needed between marking and clearing reset. 	 */
name|v
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMACFG
argument_list|)
operator|&
operator|~
operator|(
name|SAFE_PE_DMACFG_PERESET
operator||
name|SAFE_PE_DMACFG_PDRRESET
operator||
name|SAFE_PE_DMACFG_SGRESET
operator|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMACFG
argument_list|,
name|v
operator||
name|SAFE_PE_DMACFG_PERESET
operator||
name|SAFE_PE_DMACFG_PDRRESET
operator||
name|SAFE_PE_DMACFG_SGRESET
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMACFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize registers we need to touch only once.  */
end_comment

begin_function
specifier|static
name|void
name|safe_init_board
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|v
decl_stmt|,
name|dwords
decl_stmt|;
name|v
operator|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMACFG
argument_list|)
expr_stmt|;
empty_stmt|;
name|v
operator|&=
operator|~
name|SAFE_PE_DMACFG_PEMODE
expr_stmt|;
name|v
operator||=
name|SAFE_PE_DMACFG_FSENA
comment|/* failsafe enable */
operator||
name|SAFE_PE_DMACFG_GPRPCI
comment|/* gather ring on PCI */
operator||
name|SAFE_PE_DMACFG_SPRPCI
comment|/* scatter ring on PCI */
operator||
name|SAFE_PE_DMACFG_ESDESC
comment|/* endian-swap descriptors */
operator||
name|SAFE_PE_DMACFG_ESSA
comment|/* endian-swap SA's */
operator||
name|SAFE_PE_DMACFG_ESPDESC
comment|/* endian-swap part. desc's */
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMACFG
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX select byte swap based on host byte order */
block|WRITE_REG(sc, SAFE_ENDIAN, 0x1b);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_chiprev
operator|==
name|SAFE_REV
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Avoid large PCI DMA transfers.  Rev 1.0 has a bug where 		 * "target mode transfers" done while the chip is DMA'ing 		 *>1020 bytes cause the hardware to lockup.  To avoid this 		 * we reduce the max PCI transfer size and use small source 		 * particle descriptors (<= 256 bytes). 		 */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DMA_CFG
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Reduce max DMA size to %u words for rev %u.%u WAR\n"
argument_list|,
operator|(
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DMA_CFG
argument_list|)
operator|>>
literal|2
operator|)
operator|&
literal|0xff
argument_list|,
name|SAFE_REV_MAJ
argument_list|(
name|sc
operator|->
name|sc_chiprev
argument_list|)
argument_list|,
name|SAFE_REV_MIN
argument_list|(
name|sc
operator|->
name|sc_chiprev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* NB: operands+results are overlaid */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_PDRBASE
argument_list|,
name|sc
operator|->
name|sc_ringalloc
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_RDRBASE
argument_list|,
name|sc
operator|->
name|sc_ringalloc
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
comment|/* 	 * Configure ring entry size and number of items in the ring. 	 */
name|KASSERT
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"PE ring entry not 32-bit aligned!"
operator|)
argument_list|)
expr_stmt|;
name|dwords
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|safe_ringentry
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_RINGCFG
argument_list|,
operator|(
name|dwords
operator|<<
name|SAFE_PE_RINGCFG_OFFSET_S
operator|)
operator||
name|SAFE_MAX_NQUEUE
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_RINGPOLL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable polling */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_GRNGBASE
argument_list|,
name|sc
operator|->
name|sc_spalloc
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_SRNGBASE
argument_list|,
name|sc
operator|->
name|sc_dpalloc
operator|.
name|dma_paddr
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_PARTSIZE
argument_list|,
operator|(
name|SAFE_TOTAL_DPART
operator|<<
literal|16
operator|)
operator||
name|SAFE_TOTAL_SPART
argument_list|)
expr_stmt|;
comment|/* 	 * NB: destination particles are fixed size.  We use 	 *     an mbuf cluster and require all results go to 	 *     clusters or smaller. 	 */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_PARTCFG
argument_list|,
name|SAFE_MAX_DSIZE
argument_list|)
expr_stmt|;
comment|/* it's now safe to enable PE mode, do it */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_DMACFG
argument_list|,
name|v
operator||
name|SAFE_PE_DMACFG_PEMODE
argument_list|)
expr_stmt|;
comment|/* 	 * Configure hardware to use level-triggered interrupts and 	 * to interrupt after each descriptor is processed. 	 */
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_CFG
argument_list|,
name|SAFE_HI_CFG_LEVEL
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_DESC_CNT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|WRITE_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_MASK
argument_list|,
name|SAFE_INT_PE_DDONE
operator||
name|SAFE_INT_PE_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Init PCI registers  */
end_comment

begin_function
specifier|static
name|void
name|safe_init_pciregs
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Clean up after a chip crash.  * It is assumed that the caller in splimp()  */
end_comment

begin_function
specifier|static
name|void
name|safe_cleanchip
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_nqchip
operator|!=
literal|0
condition|)
block|{
name|struct
name|safe_ringentry
modifier|*
name|re
init|=
name|sc
operator|->
name|sc_back
decl_stmt|;
while|while
condition|(
name|re
operator|!=
name|sc
operator|->
name|sc_front
condition|)
block|{
if|if
condition|(
name|re
operator|->
name|re_desc
operator|.
name|d_csr
operator|!=
literal|0
condition|)
name|safe_free_entry
argument_list|(
name|sc
argument_list|,
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|re
operator|==
name|sc
operator|->
name|sc_ringtop
condition|)
name|re
operator|=
name|sc
operator|->
name|sc_ring
expr_stmt|;
block|}
name|sc
operator|->
name|sc_back
operator|=
name|re
expr_stmt|;
name|sc
operator|->
name|sc_nqchip
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * free a safe_q  * It is assumed that the caller is within splimp().  */
end_comment

begin_function
specifier|static
name|int
name|safe_free_entry
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
name|re
parameter_list|)
block|{
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
comment|/* 	 * Free header MCR 	 */
if|if
condition|(
operator|(
name|re
operator|->
name|re_dst_m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|re
operator|->
name|re_src_m
operator|!=
name|re
operator|->
name|re_dst_m
operator|)
condition|)
name|m_freem
argument_list|(
name|re
operator|->
name|re_dst_m
argument_list|)
expr_stmt|;
name|crp
operator|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
name|re
operator|->
name|re_crp
expr_stmt|;
name|re
operator|->
name|re_desc
operator|.
name|d_csr
operator|=
literal|0
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|EFAULT
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine to reset the chip and clean up.  * It is assumed that the caller is in splimp()  */
end_comment

begin_function
specifier|static
name|void
name|safe_totalreset
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|safe_reset_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|safe_init_board
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|safe_cleanchip
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Is the operand suitable aligned for direct DMA.  Each  * segment must be aligned on a 32-bit boundary and all  * but the last segment must be a multiple of 4 bytes.  */
end_comment

begin_function
specifier|static
name|int
name|safe_dmamap_aligned
parameter_list|(
specifier|const
name|struct
name|safe_operand
modifier|*
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op
operator|->
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|i
operator|!=
operator|(
name|op
operator|->
name|nsegs
operator|-
literal|1
operator|)
operator|&&
operator|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|&
literal|3
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is the operand suitable for direct DMA as the destination  * of an operation.  The hardware requires that each ``particle''  * but the last in an operation result have the same size.  We  * fix that size at SAFE_MAX_DSIZE bytes.  This routine returns  * 0 if some segment is not a multiple of of this size, 1 if all  * segments are exactly this size, or 2 if segments are at worst  * a multple of this size.  */
end_comment

begin_function
specifier|static
name|int
name|safe_dmamap_uniform
parameter_list|(
specifier|const
name|struct
name|safe_operand
modifier|*
name|op
parameter_list|)
block|{
name|int
name|result
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|nsegs
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op
operator|->
name|nsegs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|%
name|SAFE_MAX_DSIZE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|!=
name|SAFE_MAX_DSIZE
condition|)
name|result
operator|=
literal|2
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SAFE_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|safe_dump_dmastatus
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: ENDIAN 0x%x SRC 0x%x DST 0x%x STAT 0x%x\n"
argument_list|,
name|tag
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DMA_ENDIAN
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DMA_SRCADDR
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DMA_DSTADDR
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_DMA_STAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_dump_intrstate
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: HI_CFG 0x%x HI_MASK 0x%x HI_DESC_CNT 0x%x HU_STAT 0x%x HM_STAT 0x%x\n"
argument_list|,
name|tag
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_CFG
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_MASK
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HI_DESC_CNT
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HU_STAT
argument_list|)
argument_list|,
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_HM_STAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_dump_ringstate
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|u_int32_t
name|estat
init|=
name|READ_REG
argument_list|(
name|sc
argument_list|,
name|SAFE_PE_ERNGSTAT
argument_list|)
decl_stmt|;
comment|/* NB: assume caller has lock on ring */
name|printf
argument_list|(
literal|"%s: ERNGSTAT %x (next %u) back %u front %u\n"
argument_list|,
name|tag
argument_list|,
name|estat
argument_list|,
operator|(
name|estat
operator|>>
name|SAFE_PE_ERNGSTAT_NEXT_S
operator|)
argument_list|,
name|sc
operator|->
name|sc_back
operator|-
name|sc
operator|->
name|sc_ring
argument_list|,
name|sc
operator|->
name|sc_front
operator|-
name|sc
operator|->
name|sc_ring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_dump_request
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|struct
name|safe_ringentry
modifier|*
name|re
parameter_list|)
block|{
name|int
name|ix
decl_stmt|,
name|nsegs
decl_stmt|;
name|ix
operator|=
name|re
operator|-
name|sc
operator|->
name|sc_ring
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %p (%u): csr %x src %x dst %x sa %x len %x\n"
argument_list|,
name|tag
argument_list|,
name|re
argument_list|,
name|ix
argument_list|,
name|re
operator|->
name|re_desc
operator|.
name|d_csr
argument_list|,
name|re
operator|->
name|re_desc
operator|.
name|d_src
argument_list|,
name|re
operator|->
name|re_desc
operator|.
name|d_dst
argument_list|,
name|re
operator|->
name|re_desc
operator|.
name|d_sa
argument_list|,
name|re
operator|->
name|re_desc
operator|.
name|d_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|re_src
operator|.
name|nsegs
operator|>
literal|1
condition|)
block|{
name|ix
operator|=
operator|(
name|re
operator|->
name|re_desc
operator|.
name|d_src
operator|-
name|sc
operator|->
name|sc_spalloc
operator|.
name|dma_paddr
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|safe_pdesc
argument_list|)
expr_stmt|;
for|for
control|(
name|nsegs
operator|=
name|re
operator|->
name|re_src
operator|.
name|nsegs
init|;
name|nsegs
condition|;
name|nsegs
operator|--
control|)
block|{
name|printf
argument_list|(
literal|" spd[%u] %p: %p size %u flags %x"
argument_list|,
name|ix
argument_list|,
operator|&
name|sc
operator|->
name|sc_spring
index|[
name|ix
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_spring
index|[
name|ix
index|]
operator|.
name|pd_addr
argument_list|,
name|sc
operator|->
name|sc_spring
index|[
name|ix
index|]
operator|.
name|pd_size
argument_list|,
name|sc
operator|->
name|sc_spring
index|[
name|ix
index|]
operator|.
name|pd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_spring
index|[
name|ix
index|]
operator|.
name|pd_size
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" (zero!)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ix
operator|==
name|SAFE_TOTAL_SPART
condition|)
name|ix
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|re
operator|->
name|re_dst
operator|.
name|nsegs
operator|>
literal|1
condition|)
block|{
name|ix
operator|=
operator|(
name|re
operator|->
name|re_desc
operator|.
name|d_dst
operator|-
name|sc
operator|->
name|sc_dpalloc
operator|.
name|dma_paddr
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|safe_pdesc
argument_list|)
expr_stmt|;
for|for
control|(
name|nsegs
operator|=
name|re
operator|->
name|re_dst
operator|.
name|nsegs
init|;
name|nsegs
condition|;
name|nsegs
operator|--
control|)
block|{
name|printf
argument_list|(
literal|" dpd[%u] %p: %p flags %x\n"
argument_list|,
name|ix
argument_list|,
operator|&
name|sc
operator|->
name|sc_dpring
index|[
name|ix
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_dpring
index|[
name|ix
index|]
operator|.
name|pd_addr
argument_list|,
name|sc
operator|->
name|sc_dpring
index|[
name|ix
index|]
operator|.
name|pd_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ix
operator|==
name|SAFE_TOTAL_DPART
condition|)
name|ix
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"sa: cmd0 %08x cmd1 %08x staterec %x\n"
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_cmd0
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_cmd1
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_staterec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sa: key %x %x %x %x %x %x %x %x\n"
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|0
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|1
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|2
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|3
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|4
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|5
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|6
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_key
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sa: indigest %x %x %x %x %x\n"
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_indigest
index|[
literal|0
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_indigest
index|[
literal|1
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_indigest
index|[
literal|2
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_indigest
index|[
literal|3
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_indigest
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sa: outdigest %x %x %x %x %x\n"
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_outdigest
index|[
literal|0
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_outdigest
index|[
literal|1
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_outdigest
index|[
literal|2
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_outdigest
index|[
literal|3
index|]
argument_list|,
name|re
operator|->
name|re_sa
operator|.
name|sa_outdigest
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sr: iv %x %x %x %x\n"
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
index|[
literal|0
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
index|[
literal|1
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
index|[
literal|2
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_iv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sr: hashbc %u indigest %x %x %x %x %x\n"
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_hashbc
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|0
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|1
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|2
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|3
index|]
argument_list|,
name|re
operator|->
name|re_sastate
operator|.
name|sa_saved_indigest
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|safe_dump_ring
parameter_list|(
name|struct
name|safe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nSafeNet Ring State:\n"
argument_list|)
expr_stmt|;
name|safe_dump_intrstate
argument_list|(
name|sc
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|safe_dump_dmastatus
argument_list|(
name|sc
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|safe_dump_ringstate
argument_list|(
name|sc
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nqchip
condition|)
block|{
name|struct
name|safe_ringentry
modifier|*
name|re
init|=
name|sc
operator|->
name|sc_back
decl_stmt|;
do|do
block|{
name|safe_dump_request
argument_list|(
name|sc
argument_list|,
name|tag
argument_list|,
name|re
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|re
operator|==
name|sc
operator|->
name|sc_ringtop
condition|)
name|re
operator|=
name|sc
operator|->
name|sc_ring
expr_stmt|;
block|}
do|while
condition|(
name|re
operator|!=
name|sc
operator|->
name|sc_front
condition|)
do|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_ringmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_safe_dump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|dmode
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|strncpy
argument_list|(
name|dmode
argument_list|,
literal|""
argument_list|,
sizeof|sizeof
argument_list|(
name|dmode
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dmode
index|[
sizeof|sizeof
argument_list|(
name|dmode
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
operator|&
name|dmode
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dmode
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|safe_softc
modifier|*
name|sc
init|=
name|safec
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|dmode
argument_list|,
literal|"dma"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|safe_dump_dmastatus
argument_list|(
name|sc
argument_list|,
literal|"safe0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|dmode
argument_list|,
literal|"int"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|safe_dump_intrstate
argument_list|(
name|sc
argument_list|,
literal|"safe0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|dmode
argument_list|,
literal|"ring"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|safe_dump_ring
argument_list|(
name|sc
argument_list|,
literal|"safe0"
argument_list|)
expr_stmt|;
else|else
return|return
name|EINVAL
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw_safe
argument_list|,
name|OID_AUTO
argument_list|,
name|dump
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_safe_dump
argument_list|,
literal|"A"
argument_list|,
literal|"Dump driver state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SAFE_DEBUG */
end_comment

end_unit

