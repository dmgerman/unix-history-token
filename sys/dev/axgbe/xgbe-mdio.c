begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * AMD 10Gb Ethernet driver  *  * This file is available to you under your choice of the following two  * licenses:  *  * License 1: GPLv2  *  * Copyright (c) 2014-2016 Advanced Micro Devices, Inc.  *  * This file is free software; you may copy, redistribute and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation, either version 2 of the License, or (at  * your option) any later version.  *  * This file is distributed in the hope that it will be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU  * General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program.  If not, see<http://www.gnu.org/licenses/>.  *  * This file incorporates work covered by the following copyright and  * permission notice:  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,  *     Inc. unless otherwise expressly agreed to in writing between Synopsys  *     and you.  *  *     The Software IS NOT an item of Licensed Software or Licensed Product  *     under any End User Software License Agreement or Agreement for Licensed  *     Product with Synopsys or any supplement thereto.  Permission is hereby  *     granted, free of charge, to any person obtaining a copy of this software  *     annotated with this license and the Software, to deal in the Software  *     without restriction, including without limitation the rights to use,  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies  *     of the Software, and to permit persons to whom the Software is furnished  *     to do so, subject to the following conditions:  *  *     The above copyright notice and this permission notice shall be included  *     in all copies or substantial portions of the Software.  *  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  *     THE POSSIBILITY OF SUCH DAMAGE.  *  *  * License 2: Modified BSD  *  * Copyright (c) 2014-2016 Advanced Micro Devices, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright  *       notice, this list of conditions and the following disclaimer in the  *       documentation and/or other materials provided with the distribution.  *     * Neither the name of Advanced Micro Devices, Inc. nor the  *       names of its contributors may be used to endorse or promote products  *       derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL<COPYRIGHT HOLDER> BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * This file incorporates work covered by the following copyright and  * permission notice:  *     The Synopsys DWC ETHER XGMAC Software Driver and documentation  *     (hereinafter "Software") is an unsupported proprietary work of Synopsys,  *     Inc. unless otherwise expressly agreed to in writing between Synopsys  *     and you.  *  *     The Software IS NOT an item of Licensed Software or Licensed Product  *     under any End User Software License Agreement or Agreement for Licensed  *     Product with Synopsys or any supplement thereto.  Permission is hereby  *     granted, free of charge, to any person obtaining a copy of this software  *     annotated with this license and the Software, to deal in the Software  *     without restriction, including without limitation the rights to use,  *     copy, modify, merge, publish, distribute, sublicense, and/or sell copies  *     of the Software, and to permit persons to whom the Software is furnished  *     to do so, subject to the following conditions:  *  *     The above copyright notice and this permission notice shall be included  *     in all copies or substantial portions of the Software.  *  *     THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS"  *     BASIS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  *     TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  *     PARTICULAR PURPOSE ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS  *     BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  *     CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  *     SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *     INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  *     ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  *     THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/kmod.h>
end_include

begin_include
include|#
directive|include
file|<linux/mdio.h>
end_include

begin_include
include|#
directive|include
file|<linux/phy.h>
end_include

begin_include
include|#
directive|include
file|<linux/of.h>
end_include

begin_include
include|#
directive|include
file|<linux/bitops.h>
end_include

begin_include
include|#
directive|include
file|<linux/jiffies.h>
end_include

begin_include
include|#
directive|include
file|"xgbe.h"
end_include

begin_include
include|#
directive|include
file|"xgbe-common.h"
end_include

begin_function
specifier|static
name|void
name|xgbe_an_enable_kr_training
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_PMD_CTRL
argument_list|)
expr_stmt|;
name|reg
operator||=
name|XGBE_KR_TRAINING_ENABLE
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_PMD_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_an_disable_kr_training
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_PMD_CTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|XGBE_KR_TRAINING_ENABLE
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_PMD_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_pcs_power_cycle
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MDIO_CTRL1_LPOWER
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|usleep_range
argument_list|(
literal|75
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_CTRL1_LPOWER
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_serdes_start_ratechange
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
comment|/* Assert Rx and Tx ratechange */
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|RATECHANGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_serdes_complete_ratechange
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|wait
decl_stmt|;
name|u16
name|status
decl_stmt|;
comment|/* Release Rx and Tx ratechange */
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|RATECHANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for Rx and Tx ready */
name|wait
operator|=
name|XGBE_RATECHANGE_COUNT
expr_stmt|;
while|while
condition|(
name|wait
operator|--
condition|)
block|{
name|usleep_range
argument_list|(
literal|50
argument_list|,
literal|75
argument_list|)
expr_stmt|;
name|status
operator|=
name|XSIR0_IOREAD
argument_list|(
name|pdata
argument_list|,
name|SIR0_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|XSIR_GET_BITS
argument_list|(
name|status
argument_list|,
name|SIR0_STATUS
argument_list|,
name|RX_READY
argument_list|)
operator|&&
name|XSIR_GET_BITS
argument_list|(
name|status
argument_list|,
name|SIR0_STATUS
argument_list|,
name|TX_READY
argument_list|)
condition|)
goto|goto
name|rx_reset
goto|;
block|}
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"SerDes rx/tx not ready (%#hx)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|rx_reset
label|:
comment|/* Perform Rx reset for the DFE changes */
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG6
argument_list|,
name|RESETB_RXD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG6
argument_list|,
name|RESETB_RXD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_xgmii_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Enable KR training */
name|xgbe_an_enable_kr_training
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set MAC to 10G speed */
name|pdata
operator|->
name|hw_if
operator|.
name|set_xgmii_speed
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set PCS to KR/10G speed */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_PCS_CTRL2_TYPE
expr_stmt|;
name|reg
operator||=
name|MDIO_PCS_CTRL2_10GBR
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_CTRL1_SPEEDSEL
expr_stmt|;
name|reg
operator||=
name|MDIO_CTRL1_SPEED10G
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|xgbe_pcs_power_cycle
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set SerDes to 10G speed */
name|xgbe_serdes_start_ratechange
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|DATARATE
argument_list|,
name|XGBE_SPEED_10000_RATE
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|WORDMODE
argument_list|,
name|XGBE_SPEED_10000_WORD
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|PLLSEL
argument_list|,
name|XGBE_SPEED_10000_PLL
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|CDR_RATE
argument_list|,
name|pdata
operator|->
name|serdes_cdr_rate
index|[
name|XGBE_SPEED_10000
index|]
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|TXAMP
argument_list|,
name|pdata
operator|->
name|serdes_tx_amp
index|[
name|XGBE_SPEED_10000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG20
argument_list|,
name|BLWC_ENA
argument_list|,
name|pdata
operator|->
name|serdes_blwc
index|[
name|XGBE_SPEED_10000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG114
argument_list|,
name|PQ_REG
argument_list|,
name|pdata
operator|->
name|serdes_pq_skew
index|[
name|XGBE_SPEED_10000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG129
argument_list|,
name|RXDFE_CONFIG
argument_list|,
name|pdata
operator|->
name|serdes_dfe_tap_cfg
index|[
name|XGBE_SPEED_10000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG22
argument_list|,
name|pdata
operator|->
name|serdes_dfe_tap_ena
index|[
name|XGBE_SPEED_10000
index|]
argument_list|)
expr_stmt|;
name|xgbe_serdes_complete_ratechange
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"10GbE KR mode set\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_gmii_2500_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Disable KR training */
name|xgbe_an_disable_kr_training
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set MAC to 2.5G speed */
name|pdata
operator|->
name|hw_if
operator|.
name|set_gmii_2500_speed
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set PCS to KX/1G speed */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_PCS_CTRL2_TYPE
expr_stmt|;
name|reg
operator||=
name|MDIO_PCS_CTRL2_10GBX
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_CTRL1_SPEEDSEL
expr_stmt|;
name|reg
operator||=
name|MDIO_CTRL1_SPEED1G
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|xgbe_pcs_power_cycle
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set SerDes to 2.5G speed */
name|xgbe_serdes_start_ratechange
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|DATARATE
argument_list|,
name|XGBE_SPEED_2500_RATE
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|WORDMODE
argument_list|,
name|XGBE_SPEED_2500_WORD
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|PLLSEL
argument_list|,
name|XGBE_SPEED_2500_PLL
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|CDR_RATE
argument_list|,
name|pdata
operator|->
name|serdes_cdr_rate
index|[
name|XGBE_SPEED_2500
index|]
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|TXAMP
argument_list|,
name|pdata
operator|->
name|serdes_tx_amp
index|[
name|XGBE_SPEED_2500
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG20
argument_list|,
name|BLWC_ENA
argument_list|,
name|pdata
operator|->
name|serdes_blwc
index|[
name|XGBE_SPEED_2500
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG114
argument_list|,
name|PQ_REG
argument_list|,
name|pdata
operator|->
name|serdes_pq_skew
index|[
name|XGBE_SPEED_2500
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG129
argument_list|,
name|RXDFE_CONFIG
argument_list|,
name|pdata
operator|->
name|serdes_dfe_tap_cfg
index|[
name|XGBE_SPEED_2500
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG22
argument_list|,
name|pdata
operator|->
name|serdes_dfe_tap_ena
index|[
name|XGBE_SPEED_2500
index|]
argument_list|)
expr_stmt|;
name|xgbe_serdes_complete_ratechange
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"2.5GbE KX mode set\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_gmii_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Disable KR training */
name|xgbe_an_disable_kr_training
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set MAC to 1G speed */
name|pdata
operator|->
name|hw_if
operator|.
name|set_gmii_speed
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set PCS to KX/1G speed */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_PCS_CTRL2_TYPE
expr_stmt|;
name|reg
operator||=
name|MDIO_PCS_CTRL2_10GBX
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_CTRL1_SPEEDSEL
expr_stmt|;
name|reg
operator||=
name|MDIO_CTRL1_SPEED1G
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|xgbe_pcs_power_cycle
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Set SerDes to 1G speed */
name|xgbe_serdes_start_ratechange
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|DATARATE
argument_list|,
name|XGBE_SPEED_1000_RATE
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|WORDMODE
argument_list|,
name|XGBE_SPEED_1000_WORD
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|PLLSEL
argument_list|,
name|XGBE_SPEED_1000_PLL
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|CDR_RATE
argument_list|,
name|pdata
operator|->
name|serdes_cdr_rate
index|[
name|XGBE_SPEED_1000
index|]
argument_list|)
expr_stmt|;
name|XSIR1_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR1_SPEED
argument_list|,
name|TXAMP
argument_list|,
name|pdata
operator|->
name|serdes_tx_amp
index|[
name|XGBE_SPEED_1000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG20
argument_list|,
name|BLWC_ENA
argument_list|,
name|pdata
operator|->
name|serdes_blwc
index|[
name|XGBE_SPEED_1000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG114
argument_list|,
name|PQ_REG
argument_list|,
name|pdata
operator|->
name|serdes_pq_skew
index|[
name|XGBE_SPEED_1000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG129
argument_list|,
name|RXDFE_CONFIG
argument_list|,
name|pdata
operator|->
name|serdes_dfe_tap_cfg
index|[
name|XGBE_SPEED_1000
index|]
argument_list|)
expr_stmt|;
name|XRXTX_IOWRITE
argument_list|(
name|pdata
argument_list|,
name|RXTX_REG22
argument_list|,
name|pdata
operator|->
name|serdes_dfe_tap_ena
index|[
name|XGBE_SPEED_1000
index|]
argument_list|)
expr_stmt|;
name|xgbe_serdes_complete_ratechange
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"1GbE KX mode set\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_cur_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|enum
name|xgbe_mode
modifier|*
name|mode
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|MDIO_PCS_CTRL2_TYPE
operator|)
operator|==
name|MDIO_PCS_CTRL2_10GBR
condition|)
operator|*
name|mode
operator|=
name|XGBE_MODE_KR
expr_stmt|;
else|else
operator|*
name|mode
operator|=
name|XGBE_MODE_KX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|xgbe_in_kr_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|enum
name|xgbe_mode
name|mode
decl_stmt|;
name|xgbe_cur_mode
argument_list|(
name|pdata
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|mode
operator|==
name|XGBE_MODE_KR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_switch_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
comment|/* If we are in KR switch to KX, and vice-versa */
if|if
condition|(
name|xgbe_in_kr_mode
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
if|if
condition|(
name|pdata
operator|->
name|speed_set
operator|==
name|XGBE_SPEEDSET_1000_10000
condition|)
name|xgbe_gmii_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
else|else
name|xgbe_gmii_2500_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xgbe_xgmii_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_set_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|enum
name|xgbe_mode
name|mode
parameter_list|)
block|{
name|enum
name|xgbe_mode
name|cur_mode
decl_stmt|;
name|xgbe_cur_mode
argument_list|(
name|pdata
argument_list|,
operator|&
name|cur_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|cur_mode
condition|)
name|xgbe_switch_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|xgbe_use_xgmii_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|==
name|AUTONEG_ENABLE
condition|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_10000baseKR_Full
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|==
name|SPEED_10000
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|xgbe_use_gmii_2500_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|==
name|AUTONEG_ENABLE
condition|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_2500baseX_Full
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|==
name|SPEED_2500
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|xgbe_use_gmii_mode
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|==
name|AUTONEG_ENABLE
condition|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_1000baseKX_Full
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|==
name|SPEED_1000
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_set_an
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|bool
name|enable
parameter_list|,
name|bool
name|restart
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|MDIO_AN_CTRL1_ENABLE
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|reg
operator||=
name|MDIO_AN_CTRL1_ENABLE
expr_stmt|;
if|if
condition|(
name|restart
condition|)
name|reg
operator||=
name|MDIO_AN_CTRL1_RESTART
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_restart_an
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|xgbe_set_an
argument_list|(
name|pdata
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN enabled/restarted\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_disable_an
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|xgbe_set_an
argument_list|(
name|pdata
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xgbe_an
name|xgbe_an_tx_training
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|enum
name|xgbe_rx
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|int
name|ad_reg
decl_stmt|,
name|lp_reg
decl_stmt|,
name|reg
decl_stmt|;
operator|*
name|state
operator|=
name|XGBE_RX_COMPLETE
expr_stmt|;
comment|/* If we're not in KR mode then we're done */
if|if
condition|(
operator|!
name|xgbe_in_kr_mode
argument_list|(
name|pdata
argument_list|)
condition|)
return|return
name|XGBE_AN_PAGE_RECEIVED
return|;
comment|/* Enable/Disable FEC */
name|ad_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|2
argument_list|)
expr_stmt|;
name|lp_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPA
operator|+
literal|2
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_FECCTRL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|MDIO_PMA_10GBR_FECABLE_ABLE
operator||
name|MDIO_PMA_10GBR_FECABLE_ERRABLE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ad_reg
operator|&
literal|0xc000
operator|)
operator|&&
operator|(
name|lp_reg
operator|&
literal|0xc000
operator|)
condition|)
name|reg
operator||=
name|pdata
operator|->
name|fec_ability
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_FECCTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Start KR training */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_PMD_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|XGBE_KR_TRAINING_ENABLE
condition|)
block|{
name|XSIR0_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR0_KR_RT_1
argument_list|,
name|RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|XGBE_KR_TRAINING_START
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_PMD_CTRL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|XSIR0_IOWRITE_BITS
argument_list|(
name|pdata
argument_list|,
name|SIR0_KR_RT_1
argument_list|,
name|RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"KR training initiated\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|XGBE_AN_PAGE_RECEIVED
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xgbe_an
name|xgbe_an_tx_xnp
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|enum
name|xgbe_rx
modifier|*
name|state
parameter_list|)
block|{
name|u16
name|msg
decl_stmt|;
operator|*
name|state
operator|=
name|XGBE_RX_XNP
expr_stmt|;
name|msg
operator|=
name|XGBE_XNP_MCF_NULL_MESSAGE
expr_stmt|;
name|msg
operator||=
name|XGBE_XNP_MP_FORMATTED
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_XNP
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_XNP
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_XNP
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
name|XGBE_AN_PAGE_RECEIVED
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xgbe_an
name|xgbe_an_rx_bpa
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|enum
name|xgbe_rx
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|int
name|link_support
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|,
name|ad_reg
decl_stmt|,
name|lp_reg
decl_stmt|;
comment|/* Read Base Ability register 2 first */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPA
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Check for a supported mode, otherwise restart in a different one */
name|link_support
operator|=
name|xgbe_in_kr_mode
argument_list|(
name|pdata
argument_list|)
condition|?
literal|0x80
else|:
literal|0x20
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|link_support
operator|)
condition|)
return|return
name|XGBE_AN_INCOMPAT_LINK
return|;
comment|/* Check Extended Next Page support */
name|ad_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
argument_list|)
expr_stmt|;
name|lp_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPA
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ad_reg
operator|&
name|XGBE_XNP_NP_EXCHANGE
operator|)
operator|||
operator|(
name|lp_reg
operator|&
name|XGBE_XNP_NP_EXCHANGE
operator|)
operator|)
condition|?
name|xgbe_an_tx_xnp
argument_list|(
name|pdata
argument_list|,
name|state
argument_list|)
else|:
name|xgbe_an_tx_training
argument_list|(
name|pdata
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xgbe_an
name|xgbe_an_rx_xnp
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|,
name|enum
name|xgbe_rx
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|int
name|ad_reg
decl_stmt|,
name|lp_reg
decl_stmt|;
comment|/* Check Extended Next Page support */
name|ad_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_XNP
argument_list|)
expr_stmt|;
name|lp_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPX
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|ad_reg
operator|&
name|XGBE_XNP_NP_EXCHANGE
operator|)
operator|||
operator|(
name|lp_reg
operator|&
name|XGBE_XNP_NP_EXCHANGE
operator|)
operator|)
condition|?
name|xgbe_an_tx_xnp
argument_list|(
name|pdata
argument_list|,
name|state
argument_list|)
else|:
name|xgbe_an_tx_training
argument_list|(
name|pdata
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xgbe_an
name|xgbe_an_page_received
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|enum
name|xgbe_rx
modifier|*
name|state
decl_stmt|;
name|unsigned
name|long
name|an_timeout
decl_stmt|;
name|enum
name|xgbe_an
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|pdata
operator|->
name|an_start
condition|)
block|{
name|pdata
operator|->
name|an_start
operator|=
name|jiffies
expr_stmt|;
block|}
else|else
block|{
name|an_timeout
operator|=
name|pdata
operator|->
name|an_start
operator|+
name|msecs_to_jiffies
argument_list|(
name|XGBE_AN_MS_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|an_timeout
argument_list|)
condition|)
block|{
comment|/* Auto-negotiation timed out, reset state */
name|pdata
operator|->
name|kr_state
operator|=
name|XGBE_RX_BPA
expr_stmt|;
name|pdata
operator|->
name|kx_state
operator|=
name|XGBE_RX_BPA
expr_stmt|;
name|pdata
operator|->
name|an_start
operator|=
name|jiffies
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN timed out, resetting state\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|state
operator|=
name|xgbe_in_kr_mode
argument_list|(
name|pdata
argument_list|)
condition|?
operator|&
name|pdata
operator|->
name|kr_state
else|:
operator|&
name|pdata
operator|->
name|kx_state
expr_stmt|;
switch|switch
condition|(
operator|*
name|state
condition|)
block|{
case|case
name|XGBE_RX_BPA
case|:
name|ret
operator|=
name|xgbe_an_rx_bpa
argument_list|(
name|pdata
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGBE_RX_XNP
case|:
name|ret
operator|=
name|xgbe_an_rx_xnp
argument_list|(
name|pdata
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|XGBE_AN_ERROR
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|xgbe_an
name|xgbe_an_incompat_link
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
comment|/* Be sure we aren't looping trying to negotiate */
if|if
condition|(
name|xgbe_in_kr_mode
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
name|pdata
operator|->
name|kr_state
operator|=
name|XGBE_RX_ERROR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_1000baseKX_Full
operator|)
operator|&&
operator|!
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_2500baseX_Full
operator|)
condition|)
return|return
name|XGBE_AN_NO_LINK
return|;
if|if
condition|(
name|pdata
operator|->
name|kx_state
operator|!=
name|XGBE_RX_BPA
condition|)
return|return
name|XGBE_AN_NO_LINK
return|;
block|}
else|else
block|{
name|pdata
operator|->
name|kx_state
operator|=
name|XGBE_RX_ERROR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_10000baseKR_Full
operator|)
condition|)
return|return
name|XGBE_AN_NO_LINK
return|;
if|if
condition|(
name|pdata
operator|->
name|kr_state
operator|!=
name|XGBE_RX_BPA
condition|)
return|return
name|XGBE_AN_NO_LINK
return|;
block|}
name|xgbe_disable_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|xgbe_switch_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|xgbe_restart_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
return|return
name|XGBE_AN_INCOMPAT_LINK
return|;
block|}
end_function

begin_function
specifier|static
name|irqreturn_t
name|xgbe_an_isr
parameter_list|(
name|int
name|irq
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
init|=
operator|(
expr|struct
name|xgbe_prv_data
operator|*
operator|)
name|data
decl_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|intr
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN interrupt received\n"
argument_list|)
expr_stmt|;
comment|/* Disable AN interrupts */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Save the interrupt(s) that fired */
name|pdata
operator|->
name|an_int
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|an_int
condition|)
block|{
comment|/* Clear the interrupt(s) that fired and process them */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INT
argument_list|,
operator|~
name|pdata
operator|->
name|an_int
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|pdata
operator|->
name|an_workqueue
argument_list|,
operator|&
name|pdata
operator|->
name|an_irq_work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Enable AN interrupts */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INTMASK
argument_list|,
name|XGBE_AN_INT_MASK
argument_list|)
expr_stmt|;
block|}
return|return
name|IRQ_HANDLED
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_an_irq_work
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|xgbe_prv_data
argument_list|,
name|an_irq_work
argument_list|)
decl_stmt|;
comment|/* Avoid a race between enabling the IRQ and exiting the work by 	 * waiting for the work to finish and then queueing it 	 */
name|flush_work
argument_list|(
operator|&
name|pdata
operator|->
name|an_work
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|pdata
operator|->
name|an_workqueue
argument_list|,
operator|&
name|pdata
operator|->
name|an_work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xgbe_state_as_string
parameter_list|(
name|enum
name|xgbe_an
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|XGBE_AN_READY
case|:
return|return
literal|"Ready"
return|;
case|case
name|XGBE_AN_PAGE_RECEIVED
case|:
return|return
literal|"Page-Received"
return|;
case|case
name|XGBE_AN_INCOMPAT_LINK
case|:
return|return
literal|"Incompatible-Link"
return|;
case|case
name|XGBE_AN_COMPLETE
case|:
return|return
literal|"Complete"
return|;
case|case
name|XGBE_AN_NO_LINK
case|:
return|return
literal|"No-Link"
return|;
case|case
name|XGBE_AN_ERROR
case|:
return|return
literal|"Error"
return|;
default|default:
return|return
literal|"Undefined"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_an_state_machine
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|xgbe_prv_data
argument_list|,
name|an_work
argument_list|)
decl_stmt|;
name|enum
name|xgbe_an
name|cur_state
init|=
name|pdata
operator|->
name|an_state
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|pdata
operator|->
name|an_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pdata
operator|->
name|an_int
condition|)
goto|goto
name|out
goto|;
name|next_int
label|:
if|if
condition|(
name|pdata
operator|->
name|an_int
operator|&
name|XGBE_AN_PG_RCV
condition|)
block|{
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_PAGE_RECEIVED
expr_stmt|;
name|pdata
operator|->
name|an_int
operator|&=
operator|~
name|XGBE_AN_PG_RCV
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdata
operator|->
name|an_int
operator|&
name|XGBE_AN_INC_LINK
condition|)
block|{
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_INCOMPAT_LINK
expr_stmt|;
name|pdata
operator|->
name|an_int
operator|&=
operator|~
name|XGBE_AN_INC_LINK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdata
operator|->
name|an_int
operator|&
name|XGBE_AN_INT_CMPLT
condition|)
block|{
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_COMPLETE
expr_stmt|;
name|pdata
operator|->
name|an_int
operator|&=
operator|~
name|XGBE_AN_INT_CMPLT
expr_stmt|;
block|}
else|else
block|{
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_ERROR
expr_stmt|;
block|}
name|pdata
operator|->
name|an_result
operator|=
name|pdata
operator|->
name|an_state
expr_stmt|;
name|again
label|:
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN %s\n"
argument_list|,
name|xgbe_state_as_string
argument_list|(
name|pdata
operator|->
name|an_state
argument_list|)
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|pdata
operator|->
name|an_state
expr_stmt|;
switch|switch
condition|(
name|pdata
operator|->
name|an_state
condition|)
block|{
case|case
name|XGBE_AN_READY
case|:
name|pdata
operator|->
name|an_supported
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XGBE_AN_PAGE_RECEIVED
case|:
name|pdata
operator|->
name|an_state
operator|=
name|xgbe_an_page_received
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|an_supported
operator|++
expr_stmt|;
break|break;
case|case
name|XGBE_AN_INCOMPAT_LINK
case|:
name|pdata
operator|->
name|an_supported
operator|=
literal|0
expr_stmt|;
name|pdata
operator|->
name|parallel_detect
operator|=
literal|0
expr_stmt|;
name|pdata
operator|->
name|an_state
operator|=
name|xgbe_an_incompat_link
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGBE_AN_COMPLETE
case|:
name|pdata
operator|->
name|parallel_detect
operator|=
name|pdata
operator|->
name|an_supported
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"%s successful\n"
argument_list|,
name|pdata
operator|->
name|an_supported
condition|?
literal|"Auto negotiation"
else|:
literal|"Parallel detection"
argument_list|)
expr_stmt|;
break|break;
case|case
name|XGBE_AN_NO_LINK
case|:
break|break;
default|default:
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|an_state
operator|==
name|XGBE_AN_NO_LINK
condition|)
block|{
name|pdata
operator|->
name|an_int
operator|=
literal|0
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdata
operator|->
name|an_state
operator|==
name|XGBE_AN_ERROR
condition|)
block|{
name|netdev_err
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|,
literal|"error during auto-negotiation, state=%u\n"
argument_list|,
name|cur_state
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|an_int
operator|=
literal|0
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|an_state
operator|>=
name|XGBE_AN_COMPLETE
condition|)
block|{
name|pdata
operator|->
name|an_result
operator|=
name|pdata
operator|->
name|an_state
expr_stmt|;
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_READY
expr_stmt|;
name|pdata
operator|->
name|kr_state
operator|=
name|XGBE_RX_BPA
expr_stmt|;
name|pdata
operator|->
name|kx_state
operator|=
name|XGBE_RX_BPA
expr_stmt|;
name|pdata
operator|->
name|an_start
operator|=
literal|0
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN result: %s\n"
argument_list|,
name|xgbe_state_as_string
argument_list|(
name|pdata
operator|->
name|an_result
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_state
operator|!=
name|pdata
operator|->
name|an_state
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|pdata
operator|->
name|an_int
condition|)
goto|goto
name|next_int
goto|;
name|out
label|:
comment|/* Enable AN interrupts on the way out */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INTMASK
argument_list|,
name|XGBE_AN_INT_MASK
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|pdata
operator|->
name|an_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_an_init
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Set up Advertisement register 3 first */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_10000baseR_FEC
condition|)
name|reg
operator||=
literal|0xc000
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
literal|0xc000
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set up Advertisement register 2 next */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_10000baseKR_Full
condition|)
name|reg
operator||=
literal|0x80
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
literal|0x80
expr_stmt|;
if|if
condition|(
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_1000baseKX_Full
operator|)
operator|||
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_2500baseX_Full
operator|)
condition|)
name|reg
operator||=
literal|0x20
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
literal|0x20
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set up Advertisement register 1 last */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_Pause
condition|)
name|reg
operator||=
literal|0x400
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
literal|0x400
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_Asym_Pause
condition|)
name|reg
operator||=
literal|0x800
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
literal|0x800
expr_stmt|;
comment|/* We don't intend to perform XNP */
name|reg
operator|&=
operator|~
name|XGBE_XNP_NP_EXCHANGE
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN initialized\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xgbe_phy_fc_string
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
if|if
condition|(
name|pdata
operator|->
name|tx_pause
operator|&&
name|pdata
operator|->
name|rx_pause
condition|)
return|return
literal|"rx/tx"
return|;
elseif|else
if|if
condition|(
name|pdata
operator|->
name|rx_pause
condition|)
return|return
literal|"rx"
return|;
elseif|else
if|if
condition|(
name|pdata
operator|->
name|tx_pause
condition|)
return|return
literal|"tx"
return|;
else|else
return|return
literal|"off"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xgbe_phy_speed_string
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|SPEED_1000
case|:
return|return
literal|"1Gbps"
return|;
case|case
name|SPEED_2500
case|:
return|return
literal|"2.5Gbps"
return|;
case|case
name|SPEED_10000
case|:
return|return
literal|"10Gbps"
return|;
case|case
name|SPEED_UNKNOWN
case|:
return|return
literal|"Unknown"
return|;
default|default:
return|return
literal|"Unsupported"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_print_status
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|link
condition|)
name|netdev_info
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|,
literal|"Link is Up - %s/%s - flow control %s\n"
argument_list|,
name|xgbe_phy_speed_string
argument_list|(
name|pdata
operator|->
name|phy
operator|.
name|speed
argument_list|)
argument_list|,
name|pdata
operator|->
name|phy
operator|.
name|duplex
operator|==
name|DUPLEX_FULL
condition|?
literal|"Full"
else|:
literal|"Half"
argument_list|,
name|xgbe_phy_fc_string
argument_list|(
name|pdata
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|netdev_info
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|,
literal|"Link is Down\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_adjust_link
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|int
name|new_state
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|link
condition|)
block|{
comment|/* Flow control support */
name|pdata
operator|->
name|pause_autoneg
operator|=
name|pdata
operator|->
name|phy
operator|.
name|pause_autoneg
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|tx_pause
operator|!=
name|pdata
operator|->
name|phy
operator|.
name|tx_pause
condition|)
block|{
name|new_state
operator|=
literal|1
expr_stmt|;
name|pdata
operator|->
name|hw_if
operator|.
name|config_tx_flow_control
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|tx_pause
operator|=
name|pdata
operator|->
name|phy
operator|.
name|tx_pause
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|rx_pause
operator|!=
name|pdata
operator|->
name|phy
operator|.
name|rx_pause
condition|)
block|{
name|new_state
operator|=
literal|1
expr_stmt|;
name|pdata
operator|->
name|hw_if
operator|.
name|config_rx_flow_control
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|rx_pause
operator|=
name|pdata
operator|->
name|phy
operator|.
name|rx_pause
expr_stmt|;
block|}
comment|/* Speed support */
if|if
condition|(
name|pdata
operator|->
name|phy_speed
operator|!=
name|pdata
operator|->
name|phy
operator|.
name|speed
condition|)
block|{
name|new_state
operator|=
literal|1
expr_stmt|;
name|pdata
operator|->
name|phy_speed
operator|=
name|pdata
operator|->
name|phy
operator|.
name|speed
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|phy_link
operator|!=
name|pdata
operator|->
name|phy
operator|.
name|link
condition|)
block|{
name|new_state
operator|=
literal|1
expr_stmt|;
name|pdata
operator|->
name|phy_link
operator|=
name|pdata
operator|->
name|phy
operator|.
name|link
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pdata
operator|->
name|phy_link
condition|)
block|{
name|new_state
operator|=
literal|1
expr_stmt|;
name|pdata
operator|->
name|phy_link
operator|=
literal|0
expr_stmt|;
name|pdata
operator|->
name|phy_speed
operator|=
name|SPEED_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|new_state
operator|&&
name|netif_msg_link
argument_list|(
name|pdata
argument_list|)
condition|)
name|xgbe_phy_print_status
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xgbe_phy_config_fixed
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"fixed PHY configuration\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation */
name|xgbe_disable_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Validate/Set specified speed */
switch|switch
condition|(
name|pdata
operator|->
name|phy
operator|.
name|speed
condition|)
block|{
case|case
name|SPEED_10000
case|:
name|xgbe_set_mode
argument_list|(
name|pdata
argument_list|,
name|XGBE_MODE_KR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPEED_2500
case|:
case|case
name|SPEED_1000
case|:
name|xgbe_set_mode
argument_list|(
name|pdata
argument_list|,
name|XGBE_MODE_KX
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Validate duplex mode */
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|duplex
operator|!=
name|DUPLEX_FULL
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__xgbe_phy_config_aneg
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|set_bit
argument_list|(
name|XGBE_LINK_INIT
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|link_check
operator|=
name|jiffies
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|!=
name|AUTONEG_ENABLE
condition|)
return|return
name|xgbe_phy_config_fixed
argument_list|(
name|pdata
argument_list|)
return|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN PHY configuration\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation interrupt */
name|disable_irq
argument_list|(
name|pdata
operator|->
name|an_irq
argument_list|)
expr_stmt|;
comment|/* Start auto-negotiation in a supported mode */
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_10000baseKR_Full
condition|)
block|{
name|xgbe_set_mode
argument_list|(
name|pdata
argument_list|,
name|XGBE_MODE_KR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_1000baseKX_Full
operator|)
operator|||
operator|(
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&
name|ADVERTISED_2500baseX_Full
operator|)
condition|)
block|{
name|xgbe_set_mode
argument_list|(
name|pdata
argument_list|,
name|XGBE_MODE_KX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|enable_irq
argument_list|(
name|pdata
operator|->
name|an_irq
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Disable and stop any in progress auto-negotiation */
name|xgbe_disable_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Clear any auto-negotitation interrupts */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|an_result
operator|=
name|XGBE_AN_READY
expr_stmt|;
name|pdata
operator|->
name|an_state
operator|=
name|XGBE_AN_READY
expr_stmt|;
name|pdata
operator|->
name|kr_state
operator|=
name|XGBE_RX_BPA
expr_stmt|;
name|pdata
operator|->
name|kx_state
operator|=
name|XGBE_RX_BPA
expr_stmt|;
comment|/* Re-enable auto-negotiation interrupt */
name|enable_irq
argument_list|(
name|pdata
operator|->
name|an_irq
argument_list|)
expr_stmt|;
comment|/* Set up advertisement registers based on current settings */
name|xgbe_an_init
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Enable and start auto-negotiation */
name|xgbe_restart_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xgbe_phy_config_aneg
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|pdata
operator|->
name|an_mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__xgbe_phy_config_aneg
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|set_bit
argument_list|(
name|XGBE_LINK_ERR
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
expr_stmt|;
else|else
name|clear_bit
argument_list|(
name|XGBE_LINK_ERR
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|pdata
operator|->
name|an_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|xgbe_phy_aneg_done
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
return|return
operator|(
name|pdata
operator|->
name|an_result
operator|==
name|XGBE_AN_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_check_link_timeout
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|long
name|link_timeout
decl_stmt|;
name|link_timeout
operator|=
name|pdata
operator|->
name|link_check
operator|+
operator|(
name|XGBE_LINK_TIMEOUT
operator|*
name|HZ
operator|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|jiffies
argument_list|,
name|link_timeout
argument_list|)
condition|)
block|{
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"AN link timeout\n"
argument_list|)
expr_stmt|;
name|xgbe_phy_config_aneg
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_status_force
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
if|if
condition|(
name|xgbe_in_kr_mode
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_10000
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|pdata
operator|->
name|speed_set
condition|)
block|{
case|case
name|XGBE_SPEEDSET_1000_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
break|break;
case|case
name|XGBE_SPEEDSET_2500_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_2500
expr_stmt|;
break|break;
block|}
block|}
name|pdata
operator|->
name|phy
operator|.
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_status_aneg
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|ad_reg
decl_stmt|,
name|lp_reg
decl_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|!=
name|AUTONEG_ENABLE
operator|)
operator|||
name|pdata
operator|->
name|parallel_detect
condition|)
return|return
name|xgbe_phy_status_force
argument_list|(
name|pdata
argument_list|)
return|;
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_Autoneg
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_Backplane
expr_stmt|;
comment|/* Compare Advertisement and Link Partner register 1 */
name|ad_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
argument_list|)
expr_stmt|;
name|lp_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPA
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_reg
operator|&
literal|0x400
condition|)
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_Pause
expr_stmt|;
if|if
condition|(
name|lp_reg
operator|&
literal|0x800
condition|)
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_Asym_Pause
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|pause_autoneg
condition|)
block|{
comment|/* Set flow control based on auto-negotiation result */
name|pdata
operator|->
name|phy
operator|.
name|tx_pause
operator|=
literal|0
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|rx_pause
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ad_reg
operator|&
name|lp_reg
operator|&
literal|0x400
condition|)
block|{
name|pdata
operator|->
name|phy
operator|.
name|tx_pause
operator|=
literal|1
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|rx_pause
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ad_reg
operator|&
name|lp_reg
operator|&
literal|0x800
condition|)
block|{
if|if
condition|(
name|ad_reg
operator|&
literal|0x400
condition|)
name|pdata
operator|->
name|phy
operator|.
name|rx_pause
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|lp_reg
operator|&
literal|0x400
condition|)
name|pdata
operator|->
name|phy
operator|.
name|tx_pause
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Compare Advertisement and Link Partner register 2 */
name|ad_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lp_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPA
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_reg
operator|&
literal|0x80
condition|)
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_10000baseKR_Full
expr_stmt|;
if|if
condition|(
name|lp_reg
operator|&
literal|0x20
condition|)
block|{
switch|switch
condition|(
name|pdata
operator|->
name|speed_set
condition|)
block|{
case|case
name|XGBE_SPEEDSET_1000_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_1000baseKX_Full
expr_stmt|;
break|break;
case|case
name|XGBE_SPEEDSET_2500_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_2500baseX_Full
expr_stmt|;
break|break;
block|}
block|}
name|ad_reg
operator|&=
name|lp_reg
expr_stmt|;
if|if
condition|(
name|ad_reg
operator|&
literal|0x80
condition|)
block|{
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_10000
expr_stmt|;
name|xgbe_set_mode
argument_list|(
name|pdata
argument_list|,
name|XGBE_MODE_KR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ad_reg
operator|&
literal|0x20
condition|)
block|{
switch|switch
condition|(
name|pdata
operator|->
name|speed_set
condition|)
block|{
case|case
name|XGBE_SPEEDSET_1000_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_1000
expr_stmt|;
break|break;
case|case
name|XGBE_SPEEDSET_2500_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_2500
expr_stmt|;
break|break;
block|}
name|xgbe_set_mode
argument_list|(
name|pdata
argument_list|,
name|XGBE_MODE_KX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_UNKNOWN
expr_stmt|;
block|}
comment|/* Compare Advertisement and Link Partner register 3 */
name|ad_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|2
argument_list|)
expr_stmt|;
name|lp_reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_LPA
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp_reg
operator|&
literal|0xc000
condition|)
name|pdata
operator|->
name|phy
operator|.
name|lp_advertising
operator||=
name|ADVERTISED_10000baseR_FEC
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|duplex
operator|=
name|DUPLEX_FULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_status
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|,
name|link_aneg
decl_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|XGBE_LINK_ERR
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
condition|)
block|{
name|netif_carrier_off
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|link
operator|=
literal|0
expr_stmt|;
goto|goto
name|adjust_link
goto|;
block|}
name|link_aneg
operator|=
operator|(
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|==
name|AUTONEG_ENABLE
operator|)
expr_stmt|;
comment|/* Get the link status. Link status is latched low, so read 	 * once to clear and then read again to get current state 	 */
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_STAT1
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_STAT1
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|link
operator|=
operator|(
name|reg
operator|&
name|MDIO_STAT1_LSTATUS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|phy
operator|.
name|link
condition|)
block|{
if|if
condition|(
name|link_aneg
operator|&&
operator|!
name|xgbe_phy_aneg_done
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
name|xgbe_check_link_timeout
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
return|return;
block|}
name|xgbe_phy_status_aneg
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_bit
argument_list|(
name|XGBE_LINK_INIT
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
condition|)
name|clear_bit
argument_list|(
name|XGBE_LINK_INIT
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
expr_stmt|;
name|netif_carrier_on
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|test_bit
argument_list|(
name|XGBE_LINK_INIT
argument_list|,
operator|&
name|pdata
operator|->
name|dev_state
argument_list|)
condition|)
block|{
name|xgbe_check_link_timeout
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_aneg
condition|)
return|return;
block|}
name|xgbe_phy_status_aneg
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|netif_carrier_off
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|)
expr_stmt|;
block|}
name|adjust_link
label|:
name|xgbe_phy_adjust_link
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_stop
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"stopping PHY\n"
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation */
name|xgbe_disable_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Disable auto-negotiation interrupts */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|devm_free_irq
argument_list|(
name|pdata
operator|->
name|dev
argument_list|,
name|pdata
operator|->
name|an_irq
argument_list|,
name|pdata
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|link
operator|=
literal|0
expr_stmt|;
name|netif_carrier_off
argument_list|(
name|pdata
operator|->
name|netdev
argument_list|)
expr_stmt|;
name|xgbe_phy_adjust_link
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|xgbe_phy_start
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|netdev
init|=
name|pdata
operator|->
name|netdev
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|netif_dbg
argument_list|(
name|pdata
argument_list|,
name|link
argument_list|,
name|pdata
operator|->
name|netdev
argument_list|,
literal|"starting PHY\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|devm_request_irq
argument_list|(
name|pdata
operator|->
name|dev
argument_list|,
name|pdata
operator|->
name|an_irq
argument_list|,
name|xgbe_an_isr
argument_list|,
literal|0
argument_list|,
name|pdata
operator|->
name|an_name
argument_list|,
name|pdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|netdev_err
argument_list|(
name|netdev
argument_list|,
literal|"phy irq request failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Set initial mode - call the mode setting routines 	 * directly to insure we are properly configured 	 */
if|if
condition|(
name|xgbe_use_xgmii_mode
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
name|xgbe_xgmii_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xgbe_use_gmii_mode
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
name|xgbe_gmii_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xgbe_use_gmii_2500_mode
argument_list|(
name|pdata
argument_list|)
condition|)
block|{
name|xgbe_gmii_2500_mode
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_irq
goto|;
block|}
comment|/* Set up advertisement registers based on current settings */
name|xgbe_an_init
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Enable auto-negotiation interrupts */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INTMASK
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
return|return
name|xgbe_phy_config_aneg
argument_list|(
name|pdata
argument_list|)
return|;
name|err_irq
label|:
name|devm_free_irq
argument_list|(
name|pdata
operator|->
name|dev
argument_list|,
name|pdata
operator|->
name|an_irq
argument_list|,
name|pdata
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xgbe_phy_reset
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|reg
decl_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|MDIO_CTRL1_RESET
expr_stmt|;
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|count
operator|=
literal|50
expr_stmt|;
do|do
block|{
name|msleep
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|reg
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|reg
operator|&
name|MDIO_CTRL1_RESET
operator|)
operator|&&
operator|--
name|count
condition|)
do|;
if|if
condition|(
name|reg
operator|&
name|MDIO_CTRL1_RESET
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
comment|/* Disable auto-negotiation for now */
name|xgbe_disable_an
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
comment|/* Clear auto-negotiation interrupts */
name|XMDIO_WRITE
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_dump_phy_registers
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|dev
init|=
name|pdata
operator|->
name|dev
decl_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"\n************* PHY Reg dump **********************\n"
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"PCS Control Reg (%#04x) = %#04x\n"
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_CTRL1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"PCS Status Reg (%#04x) = %#04x\n"
argument_list|,
name|MDIO_STAT1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_STAT1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Phy Id (PHYS ID 1 %#04x)= %#04x\n"
argument_list|,
name|MDIO_DEVID1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_DEVID1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Phy Id (PHYS ID 2 %#04x)= %#04x\n"
argument_list|,
name|MDIO_DEVID2
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_DEVID2
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Devices in Package (%#04x)= %#04x\n"
argument_list|,
name|MDIO_DEVS1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_DEVS1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Devices in Package (%#04x)= %#04x\n"
argument_list|,
name|MDIO_DEVS2
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PCS
argument_list|,
name|MDIO_DEVS2
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Auto-Neg Control Reg (%#04x) = %#04x\n"
argument_list|,
name|MDIO_CTRL1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_CTRL1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Auto-Neg Status Reg (%#04x) = %#04x\n"
argument_list|,
name|MDIO_STAT1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_STAT1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Auto-Neg Ad Reg 1 (%#04x) = %#04x\n"
argument_list|,
name|MDIO_AN_ADVERTISE
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Auto-Neg Ad Reg 2 (%#04x) = %#04x\n"
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|1
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Auto-Neg Ad Reg 3 (%#04x) = %#04x\n"
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|2
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_ADVERTISE
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"Auto-Neg Completion Reg (%#04x) = %#04x\n"
argument_list|,
name|MDIO_AN_COMP_STAT
argument_list|,
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_AN
argument_list|,
name|MDIO_AN_COMP_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|dev_dbg
argument_list|(
name|dev
argument_list|,
literal|"\n*************************************************\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xgbe_phy_init
parameter_list|(
name|struct
name|xgbe_prv_data
modifier|*
name|pdata
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|pdata
operator|->
name|an_mutex
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|pdata
operator|->
name|an_irq_work
argument_list|,
name|xgbe_an_irq_work
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|pdata
operator|->
name|an_work
argument_list|,
name|xgbe_an_state_machine
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|mdio_mmd
operator|=
name|MDIO_MMD_PCS
expr_stmt|;
comment|/* Initialize supported features */
name|pdata
operator|->
name|phy
operator|.
name|supported
operator|=
name|SUPPORTED_Autoneg
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|supported
operator||=
name|SUPPORTED_Pause
operator||
name|SUPPORTED_Asym_Pause
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|supported
operator||=
name|SUPPORTED_Backplane
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|supported
operator||=
name|SUPPORTED_10000baseKR_Full
expr_stmt|;
switch|switch
condition|(
name|pdata
operator|->
name|speed_set
condition|)
block|{
case|case
name|XGBE_SPEEDSET_1000_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|supported
operator||=
name|SUPPORTED_1000baseKX_Full
expr_stmt|;
break|break;
case|case
name|XGBE_SPEEDSET_2500_10000
case|:
name|pdata
operator|->
name|phy
operator|.
name|supported
operator||=
name|SUPPORTED_2500baseX_Full
expr_stmt|;
break|break;
block|}
name|pdata
operator|->
name|fec_ability
operator|=
name|XMDIO_READ
argument_list|(
name|pdata
argument_list|,
name|MDIO_MMD_PMAPMD
argument_list|,
name|MDIO_PMA_10GBR_FECABLE
argument_list|)
expr_stmt|;
name|pdata
operator|->
name|fec_ability
operator|&=
operator|(
name|MDIO_PMA_10GBR_FECABLE_ABLE
operator||
name|MDIO_PMA_10GBR_FECABLE_ERRABLE
operator|)
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|fec_ability
operator|&
name|MDIO_PMA_10GBR_FECABLE_ABLE
condition|)
name|pdata
operator|->
name|phy
operator|.
name|supported
operator||=
name|SUPPORTED_10000baseR_FEC
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|=
name|pdata
operator|->
name|phy
operator|.
name|supported
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|address
operator|=
literal|0
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|autoneg
operator|=
name|AUTONEG_ENABLE
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|speed
operator|=
name|SPEED_UNKNOWN
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|duplex
operator|=
name|DUPLEX_UNKNOWN
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|link
operator|=
literal|0
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|pause_autoneg
operator|=
name|pdata
operator|->
name|pause_autoneg
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|tx_pause
operator|=
name|pdata
operator|->
name|tx_pause
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|rx_pause
operator|=
name|pdata
operator|->
name|rx_pause
expr_stmt|;
comment|/* Fix up Flow Control advertising */
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&=
operator|~
name|ADVERTISED_Pause
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|&=
operator|~
name|ADVERTISED_Asym_Pause
expr_stmt|;
if|if
condition|(
name|pdata
operator|->
name|rx_pause
condition|)
block|{
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator||=
name|ADVERTISED_Pause
expr_stmt|;
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator||=
name|ADVERTISED_Asym_Pause
expr_stmt|;
block|}
if|if
condition|(
name|pdata
operator|->
name|tx_pause
condition|)
name|pdata
operator|->
name|phy
operator|.
name|advertising
operator|^=
name|ADVERTISED_Asym_Pause
expr_stmt|;
if|if
condition|(
name|netif_msg_drv
argument_list|(
name|pdata
argument_list|)
condition|)
name|xgbe_dump_phy_registers
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xgbe_init_function_ptrs_phy
parameter_list|(
name|struct
name|xgbe_phy_if
modifier|*
name|phy_if
parameter_list|)
block|{
name|phy_if
operator|->
name|phy_init
operator|=
name|xgbe_phy_init
expr_stmt|;
name|phy_if
operator|->
name|phy_reset
operator|=
name|xgbe_phy_reset
expr_stmt|;
name|phy_if
operator|->
name|phy_start
operator|=
name|xgbe_phy_start
expr_stmt|;
name|phy_if
operator|->
name|phy_stop
operator|=
name|xgbe_phy_stop
expr_stmt|;
name|phy_if
operator|->
name|phy_status
operator|=
name|xgbe_phy_status
expr_stmt|;
name|phy_if
operator|->
name|phy_config_aneg
operator|=
name|xgbe_phy_config_aneg
expr_stmt|;
block|}
end_function

end_unit

