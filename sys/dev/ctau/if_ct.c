begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Cronyx-Tau adapter driver for FreeBSD.  * Supports PPP/HDLC and Cisco/HDLC protocol in synchronous mode,  * and asyncronous channels with full modem control.  * Keepalive protocol implemented in both Cisco and PPP modes.  *  * Copyright (C) 1994-2002 Cronyx Engineering.  * Author: Serge Vakulenko,<vak@cronyx.ru>  *  * Copyright (C) 1999-2004 Cronyx Engineering.  * Author: Roman Kurakin,<rik@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations a permission to use,  * modify and redistribute this software in source and binary forms,  * as long as this message is kept with the software, all derivative  * works or modified versions.  *  * Cronyx Id: if_ct.c,v 1.1.2.31 2004/06/23 17:09:13 rik Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cserial.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/cx/machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/ctau/ctddk.h>
end_include

begin_include
include|#
directive|include
file|<dev/cx/cronyxfw.h>
end_include

begin_include
include|#
directive|include
file|"opt_ng_cronyx.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_CRONYX
end_ifdef

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<dev/ctau/ng_ct.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_define
define|#
directive|define
name|PP_CISCO
value|IFF_LINK2
end_define

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NCTAU
value|1
end_define

begin_comment
comment|/* If we don't have Cronyx's sppp version, we don't have fr support via sppp */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PP_FR
end_ifndef

begin_define
define|#
directive|define
name|PP_FR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CT_DEBUG
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|CT_DEBUG2
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|({if (d->chan->debug>1) {\ 				printf ("%s: ", d->name); printf s;}})
end_define

begin_define
define|#
directive|define
name|CT_LOCK_NAME
value|"ctX"
end_define

begin_decl_stmt
specifier|static
name|int
name|ct_mpsafenet
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.ctau.mpsafenet"
argument_list|,
operator|&
name|ct_mpsafenet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ctau
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Cronyx Tau-ISA Adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ctau
argument_list|,
name|OID_AUTO
argument_list|,
name|mpsafenet
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ct_mpsafenet
argument_list|,
literal|0
argument_list|,
literal|"Enable/disable MPSAFE network support for Cronyx Tau-ISA Adapters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CT_LOCK
parameter_list|(
name|_bd
parameter_list|)
value|do { \ 				    if (ct_mpsafenet) \ 					mtx_lock (&(_bd)->ct_mtx); \ 				} while (0)
end_define

begin_define
define|#
directive|define
name|CT_UNLOCK
parameter_list|(
name|_bd
parameter_list|)
value|do { \ 				    if (ct_mpsafenet) \ 					mtx_unlock (&(_bd)->ct_mtx); \ 				} while (0)
end_define

begin_define
define|#
directive|define
name|CT_LOCK_ASSERT
parameter_list|(
name|_bd
parameter_list|)
value|do { \ 				    if (ct_mpsafenet) \ 					mtx_assert (&(_bd)->ct_mtx, MA_OWNED); \ 				} while (0)
end_define

begin_decl_stmt
specifier|static
name|void
name|ct_identify
name|__P
argument_list|(
operator|(
name|driver_t
operator|*
operator|,
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ct_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ct_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ct_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ct_isa_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|ct_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ct_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ct_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ct_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_ct_dma_mem_t
block|{
name|unsigned
name|long
name|phys
decl_stmt|;
name|void
modifier|*
name|virt
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|bus_dma_tag_t
name|dmat
decl_stmt|;
name|bus_dmamap_t
name|mapp
decl_stmt|;
block|}
name|ct_dma_mem_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_drv_t
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|ct_chan_t
modifier|*
name|chan
decl_stmt|;
name|ct_board_t
modifier|*
name|board
decl_stmt|;
name|struct
name|_bdrv_t
modifier|*
name|bd
decl_stmt|;
name|ct_dma_mem_t
name|dmamem
decl_stmt|;
name|int
name|running
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|char
name|nodename
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|struct
name|ifqueue
name|queue
decl_stmt|;
name|struct
name|ifqueue
name|hi_queue
decl_stmt|;
name|short
name|timeout
decl_stmt|;
name|struct
name|callout
name|timeout_handle
decl_stmt|;
else|#
directive|else
name|struct
name|ifqueue
name|queue
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
endif|#
directive|endif
name|struct
name|cdev
modifier|*
name|devt
decl_stmt|;
block|}
name|drv_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_bdrv_t
block|{
name|ct_board_t
modifier|*
name|board
decl_stmt|;
name|struct
name|resource
modifier|*
name|base_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|drq_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|int
name|base_rid
decl_stmt|;
name|int
name|drq_rid
decl_stmt|;
name|int
name|irq_rid
decl_stmt|;
name|void
modifier|*
name|intrhand
decl_stmt|;
name|drv_t
name|channel
index|[
name|NCHAN
index|]
decl_stmt|;
name|struct
name|mtx
name|ct_mtx
decl_stmt|;
block|}
name|bdrv_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|driver_t
name|ct_isa_driver
init|=
block|{
literal|"ct"
block|,
name|ct_isa_methods
block|,
sizeof|sizeof
argument_list|(
name|bdrv_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ct_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ct_receive
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_transmit
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_error
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|ng_type
name|typestruct
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|ct_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ct_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ct_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ct_board_t
modifier|*
name|adapter
index|[
name|NCTAU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|drv_t
modifier|*
name|channel
index|[
name|NCTAU
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|led_timo
index|[
name|NCTAU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|timeout_handle
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ct_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ct_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ct_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ct_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|ct_open
block|,
operator|.
name|d_close
operator|=
name|ct_close
block|,
operator|.
name|d_ioctl
operator|=
name|ct_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ct"
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the mbuf chain, for debug purposes only.  */
end_comment

begin_function
specifier|static
name|void
name|printmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mbuf:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|" HDR %d:"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|" EXT:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an mbuf from data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|makembuf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCTAU
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|adapter
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NCHAN
condition|;
name|k
operator|++
control|)
block|{
name|d
operator|=
name|channel
index|[
name|i
operator|*
name|NCHAN
operator|+
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|mode
operator|!=
name|M_G703
condition|)
continue|continue;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
operator|(
name|bdrv_t
operator|*
operator|)
name|d
operator|->
name|bd
argument_list|)
expr_stmt|;
name|ct_g703_timer
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
operator|(
name|bdrv_t
operator|*
operator|)
name|d
operator|->
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_reset
argument_list|(
operator|&
name|timeout_handle
argument_list|,
name|hz
argument_list|,
name|ct_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_led_off
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ct_board_t
modifier|*
name|b
init|=
name|arg
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
operator|(
operator|(
name|drv_t
operator|*
operator|)
name|b
operator|->
name|chan
operator|->
name|sys
operator|)
operator|->
name|bd
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_led
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activate interupt handler from DDK.  */
end_comment

begin_function
specifier|static
name|void
name|ct_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|arg
decl_stmt|;
name|ct_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
comment|/* Turn LED on. */
name|ct_led
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ct_int_handler
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Turn LED off 50 msec later. */
name|callout_reset
argument_list|(
operator|&
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|,
name|hz
operator|/
literal|20
argument_list|,
name|ct_led_off
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
comment|/* Pass packets in a lock-free state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
operator|&&
name|b
operator|->
name|chan
index|[
name|i
index|]
operator|.
name|type
condition|;
name|i
operator|++
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|b
operator|->
name|chan
index|[
name|i
index|]
operator|.
name|sys
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|running
condition|)
continue|continue;
while|while
condition|(
name|_IF_QLEN
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
continue|continue;
name|sppp_input
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|probe_irq
parameter_list|(
name|ct_board_t
modifier|*
name|b
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|busy
decl_stmt|,
name|cnt
decl_stmt|;
comment|/* Clear pending irq, if any. */
name|ct_probe_irq
argument_list|(
name|b
argument_list|,
operator|-
name|irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|5
condition|;
operator|++
name|cnt
control|)
block|{
comment|/* Get the mask of pending irqs, assuming they are busy. 		 * Activate the adapter on given irq. */
name|busy
operator|=
name|ct_probe_irq
argument_list|(
name|b
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Get the mask of active irqs. 		 * Deactivate our irq. */
name|mask
operator|=
name|ct_probe_irq
argument_list|(
name|b
argument_list|,
operator|-
name|irq
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|~
name|busy
operator|)
operator|==
literal|1
operator|<<
name|irq
condition|)
block|{
name|ct_probe_irq
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* printf ("ct%d: irq %d ok, mask=0x%04x, busy=0x%04x\n", 				b->num, irq, mask, busy); */
return|return
literal|1
return|;
block|}
block|}
comment|/* printf ("ct%d: irq %d not functional, mask=0x%04x, busy=0x%04x\n", 		b->num, irq, mask, busy); */
name|ct_probe_irq
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|short
name|porttab
index|[]
init|=
block|{
literal|0x200
block|,
literal|0x220
block|,
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2a0
block|,
literal|0x2c0
block|,
literal|0x2e0
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x340
block|,
literal|0x360
block|,
literal|0x380
block|,
literal|0x3a0
block|,
literal|0x3c0
block|,
literal|0x3e0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dmatab
index|[]
init|=
block|{
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|irqtab
index|[]
init|=
block|{
literal|5
block|,
literal|10
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|15
block|,
literal|12
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ct_is_free_res
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|rid
parameter_list|,
name|int
name|type
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|RF_ALLOCATED
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|u_long
name|iobase
decl_stmt|,
name|rescount
decl_stmt|;
name|int
name|devcount
decl_stmt|;
name|device_t
modifier|*
name|devices
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|devclass_t
name|my_devclass
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|my_devclass
operator|=
name|devclass_find
argument_list|(
literal|"ct"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|devclass_get_devices
argument_list|(
name|my_devclass
argument_list|,
operator|&
name|devices
argument_list|,
operator|&
name|devcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|devcount
operator|==
literal|0
condition|)
block|{
comment|/* We should find all devices by our self. We could alter other 		 * devices, but we don't have a choise 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|iobase
operator|=
name|porttab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ct_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ct_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|devcount
operator|++
expr_stmt|;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|dev
argument_list|,
name|ISA_ORDER_SPECULATIVE
argument_list|,
literal|"ct"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return;
name|device_set_desc_copy
argument_list|(
name|child
argument_list|,
literal|"Cronyx Tau-ISA"
argument_list|)
expr_stmt|;
name|device_set_driver
argument_list|(
name|child
argument_list|,
name|driver
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|iobase
argument_list|,
name|NPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|devcount
operator|>=
name|NCTAU
condition|)
break|break;
block|}
block|}
else|else
block|{
specifier|static
name|short
name|porttab
index|[]
init|=
block|{
literal|0x200
block|,
literal|0x220
block|,
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2a0
block|,
literal|0x2c0
block|,
literal|0x2e0
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x340
block|,
literal|0x360
block|,
literal|0x380
block|,
literal|0x3a0
block|,
literal|0x3c0
block|,
literal|0x3e0
block|,
literal|0
block|}
decl_stmt|;
comment|/* Lets check user choise. 		 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|devcount
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|bus_get_resource
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|porttab
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|!=
name|iobase
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ct_is_free_res
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ct_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|porttab
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|"Cronyx Tau-ISA"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|)
argument_list|,
name|devices
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|devices
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|devcount
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|devices
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bus_get_resource
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|iobase
operator|=
name|porttab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ct_is_free_res
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ct_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|bus_set_resource
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|iobase
argument_list|,
name|NPORT
argument_list|)
expr_stmt|;
name|porttab
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|,
literal|"Cronyx Tau-ISA"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|porttab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|device_delete_child
argument_list|(
name|device_get_parent
argument_list|(
name|devices
index|[
name|k
index|]
argument_list|)
argument_list|,
name|devices
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devices
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ct_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|rescount
decl_stmt|;
if|if
condition|(
operator|!
name|device_get_desc
argument_list|(
name|dev
argument_list|)
operator|||
name|strcmp
argument_list|(
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"Cronyx Tau-ISA"
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/*	KASSERT ((bd != NULL), ("ct%d: NULL device softc\n", unit));*/
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: Couldn't get IOPORT\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|ct_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: Resource IOPORT isn't free\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|ct_probe_board
argument_list|(
name|iobase
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: probing for Tau-ISA at %lx faild\n"
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_bus_dmamap_addr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nseg
operator|==
literal|1
argument_list|,
operator|(
literal|"too many DMA segments, %d should be 1"
operator|,
name|nseg
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ct_bus_dma_mem_alloc
parameter_list|(
name|int
name|bnum
parameter_list|,
name|int
name|cnum
parameter_list|,
name|ct_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_24BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
literal|1
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ct%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ct%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate tag for dma memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dmem
operator|->
name|virt
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ct%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ct%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't allocate mem for dma memory\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|size
argument_list|,
name|ct_bus_dmamap_addr
argument_list|,
operator|&
name|dmem
operator|->
name|phys
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|cnum
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"ct%d-%d: "
argument_list|,
name|bnum
argument_list|,
name|cnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ct%d: "
argument_list|,
name|bnum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"couldn't load mem map for dma memory\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_bus_dma_mem_free
parameter_list|(
name|ct_dma_mem_t
modifier|*
name|dmem
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|,
name|dmem
operator|->
name|virt
argument_list|,
name|dmem
operator|->
name|mapp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|dmem
operator|->
name|dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The adapter is present, initialize the driver structures.  */
end_comment

begin_function
specifier|static
name|int
name|ct_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|drq
decl_stmt|,
name|irq
decl_stmt|,
name|rescount
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ct_ln
init|=
name|CT_LOCK_NAME
decl_stmt|;
name|ct_board_t
modifier|*
name|b
decl_stmt|;
name|ct_chan_t
modifier|*
name|c
decl_stmt|;
name|drv_t
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bd
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"ct%d: NULL device softc\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|rescount
argument_list|)
expr_stmt|;
name|bd
operator|->
name|base_rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|base_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|bd
operator|->
name|base_rid
argument_list|,
name|iobase
argument_list|,
name|iobase
operator|+
name|NPORT
argument_list|,
name|NPORT
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|base_res
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: cannot alloc base address\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|drq
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|drq
operator|=
name|dmatab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ct_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|drq
argument_list|,
name|drq
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
literal|0
argument_list|,
name|drq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dmatab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ct%d: Couldn't get DRQ\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
name|bd
operator|->
name|drq_rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|drq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
operator|&
name|bd
operator|->
name|drq_rid
argument_list|,
name|drq
argument_list|,
name|drq
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|drq_res
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: cannot allocate drq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|rescount
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|irq
operator|=
name|irqtab
index|[
name|i
index|]
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ct_is_free_res
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
argument_list|,
name|irq
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|irqtab
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ct%d: Couldn't get IRQ\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
name|bd
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|bd
operator|->
name|irq_rid
argument_list|,
name|irq
argument_list|,
name|irq
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bd
operator|->
name|irq_res
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: Couldn't allocate irq\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|b
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ct_board_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
block|{
name|printf
argument_list|(
literal|"ct:%d: Couldn't allocate memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|adapter
index|[
name|unit
index|]
operator|=
name|b
expr_stmt|;
name|bzero
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|ct_board_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct_open_board
argument_list|(
name|b
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|,
name|irq
argument_list|,
name|drq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: error loading firmware\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|bd
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|ct_ln
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
name|unit
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|bd
operator|->
name|ct_mtx
argument_list|,
name|ct_ln
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|probe_irq
argument_list|(
name|b
argument_list|,
name|irq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: irq %ld not functional\n"
argument_list|,
name|unit
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|bd
operator|->
name|board
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bd
operator|->
name|ct_mtx
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|callout_init
argument_list|(
operator|&
name|led_timo
index|[
name|unit
index|]
argument_list|,
name|ct_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
operator|(
name|ct_mpsafenet
condition|?
name|INTR_MPSAFE
else|:
literal|0
operator|)
argument_list|,
name|NULL
argument_list|,
name|ct_intr
argument_list|,
name|bd
argument_list|,
operator|&
name|bd
operator|->
name|intrhand
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ct%d: Can't setup irq %ld\n"
argument_list|,
name|unit
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|bd
operator|->
name|board
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bd
operator|->
name|ct_mtx
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_init_board
argument_list|(
name|b
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|b
operator|->
name|port
argument_list|,
name|irq
argument_list|,
name|drq
argument_list|,
name|b
operator|->
name|type
argument_list|,
name|b
operator|->
name|osc
argument_list|)
expr_stmt|;
name|ct_setup_board
argument_list|(
name|b
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ct%d:<Cronyx-%s>, clock %s MHz\n"
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|b
operator|->
name|name
argument_list|,
name|b
operator|->
name|osc
operator|==
literal|20000000
condition|?
literal|"20"
else|:
literal|"16.384"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|d
operator|=
operator|&
name|bd
operator|->
name|channel
index|[
name|c
operator|->
name|num
index|]
expr_stmt|;
name|d
operator|->
name|dmamem
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
name|ct_buf_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct_bus_dma_mem_alloc
argument_list|(
name|unit
argument_list|,
name|c
operator|->
name|num
argument_list|,
operator|&
name|d
operator|->
name|dmamem
argument_list|)
condition|)
continue|continue;
name|d
operator|->
name|board
operator|=
name|b
expr_stmt|;
name|d
operator|->
name|chan
operator|=
name|c
expr_stmt|;
name|d
operator|->
name|bd
operator|=
name|bd
expr_stmt|;
name|c
operator|->
name|sys
operator|=
name|d
expr_stmt|;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
name|d
expr_stmt|;
name|sprintf
argument_list|(
name|d
operator|->
name|name
argument_list|,
literal|"ct%d.%d"
argument_list|,
name|b
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|d
operator|->
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot make common node\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|sys
operator|=
literal|0
expr_stmt|;
name|ct_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|d
operator|->
name|nodename
argument_list|,
literal|"%s%d"
argument_list|,
name|NG_CT_NODE_TYPE
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|d
operator|->
name|node
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot name node\n"
argument_list|,
name|d
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|sys
operator|=
literal|0
expr_stmt|;
name|ct_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|d
operator|->
name|queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|d
operator|->
name|hi_queue
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|,
literal|"ct_queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|,
literal|"ct_queue_hi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|,
name|ct_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/*NETGRAPH*/
name|d
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_PPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot if_alloc common interface\n"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|channel
index|[
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|sys
operator|=
literal|0
expr_stmt|;
name|ct_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|d
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|d
expr_stmt|;
name|if_initname
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
literal|"ct"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_mtu
operator|=
name|PP_MTU
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
if|if
condition|(
operator|!
name|ct_mpsafenet
condition|)
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_NEEDSGIANT
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|ct_sioctl
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_start
operator|=
name|ct_ifstart
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
name|ct_ifwatchdog
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_init
operator|=
name|ct_initialize
expr_stmt|;
name|d
operator|->
name|queue
operator|.
name|ifq_maxlen
operator|=
name|NBUF
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|,
literal|"ct_queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sppp_attach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_tlf
operator|=
name|ct_tlf
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_tls
operator|=
name|ct_tls
expr_stmt|;
comment|/* If BPF is in the kernel, call the attach for it. 		 * Header size is 4 bytes. */
name|bpfattach
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|DLT_PPP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*NETGRAPH*/
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_start_chan
argument_list|(
name|c
argument_list|,
name|d
operator|->
name|dmamem
operator|.
name|virt
argument_list|,
name|d
operator|->
name|dmamem
operator|.
name|phys
argument_list|)
expr_stmt|;
name|ct_register_receive
argument_list|(
name|c
argument_list|,
operator|&
name|ct_receive
argument_list|)
expr_stmt|;
name|ct_register_transmit
argument_list|(
name|c
argument_list|,
operator|&
name|ct_transmit
argument_list|)
expr_stmt|;
name|ct_register_error
argument_list|(
name|c
argument_list|,
operator|&
name|ct_error
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|d
operator|->
name|devt
operator|=
name|make_dev
argument_list|(
operator|&
name|ct_cdevsw
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ct%d"
argument_list|,
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ct_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ct_board_t
modifier|*
name|b
init|=
name|bd
operator|->
name|board
decl_stmt|;
name|ct_chan_t
modifier|*
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|bd
operator|->
name|ct_mtx
argument_list|)
argument_list|,
operator|(
literal|"ct mutex not initialized"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
comment|/* Check if the device is busy (open). */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
comment|/* Deactivate the timeout routine. */
name|callout_stop
argument_list|(
operator|&
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|,
name|bd
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|bd
operator|->
name|irq_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_DRQ
argument_list|,
name|bd
operator|->
name|drq_rid
argument_list|,
name|bd
operator|->
name|drq_res
argument_list|)
expr_stmt|;
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bd
operator|->
name|base_rid
argument_list|,
name|bd
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_close_board
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
comment|/* Detach the interfaces, free buffer memory. */
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|node
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|d
operator|->
name|node
argument_list|)
expr_stmt|;
name|d
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Detach from the packet filter list of interfaces. */
name|bpfdetach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* Detach from the sync PPP list. */
name|sppp_detach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|queue
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|destroy_dev
argument_list|(
name|d
operator|->
name|devt
argument_list|)
expr_stmt|;
block|}
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_led_off
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|led_timo
index|[
name|b
operator|->
name|num
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|drv_t
modifier|*
name|d
init|=
operator|(
name|drv_t
operator|*
operator|)
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
operator|->
name|type
condition|)
continue|continue;
comment|/* Deallocate buffers. */
name|ct_bus_dma_mem_free
argument_list|(
operator|&
name|d
operator|->
name|dmamem
argument_list|)
expr_stmt|;
block|}
name|bd
operator|->
name|board
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|b
operator|->
name|num
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bd
operator|->
name|ct_mtx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NETGRAPH
end_ifndef

begin_function
specifier|static
name|void
name|ct_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|bd
decl_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_ifwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|ct_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_tlf
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|SP2IFP
argument_list|(
name|sp
argument_list|)
operator|->
name|if_softc
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_tlf\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*	ct_set_dtr (d->chan, 0);*/
comment|/*	ct_set_rts (d->chan, 0);*/
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
name|sp
operator|->
name|pp_down
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ct_tls
parameter_list|(
name|struct
name|sppp
modifier|*
name|sp
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|SP2IFP
argument_list|(
name|sp
argument_list|)
operator|->
name|if_softc
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_tls\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|&&
operator|!
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
name|sp
operator|->
name|pp_up
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface.  * Ii seems to be never called by upper level.  */
end_comment

begin_function
specifier|static
name|void
name|ct_initialize
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|softc
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_initialize\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|ct_sioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|bd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|was_up
decl_stmt|,
name|should_be_up
decl_stmt|;
name|was_up
operator|=
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
operator|)
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|chan
operator|->
name|debug
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl 0x%lx\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCADDMULTI
case|:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCADDMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCDELMULTI
case|:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCDELMULTI\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SIOCSIFFLAGS
case|:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCSIFFLAGS\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"SIOCSIFADDR\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We get here only in case of SIFFLAGS or SIFADDR. */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|should_be_up
operator|=
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|was_up
operator|&&
name|should_be_up
condition|)
block|{
comment|/* Interface goes up -- start it. */
name|ct_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ct_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_up
operator|&&
operator|!
name|should_be_up
condition|)
block|{
comment|/* Interface is going down -- stop it. */
comment|/* if ((IFP2SP(d->ifp)->pp_flags& PP_FR) || (ifp->if_flags& PP_CISCO))*/
name|ct_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NETGRAPH*/
end_comment

begin_comment
comment|/*  * Stop the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ct_down
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_down\n"
operator|)
argument_list|)
expr_stmt|;
name|ct_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ct_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ct_up
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_up\n"
operator|)
argument_list|)
expr_stmt|;
name|ct_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ct_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on the (slave) interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_function
specifier|static
name|void
name|ct_send
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_send, tn=%d\n"
operator|,
name|d
operator|->
name|chan
operator|->
name|tn
operator|)
argument_list|)
expr_stmt|;
comment|/* No output if the interface is down. */
if|if
condition|(
operator|!
name|d
operator|->
name|running
condition|)
return|return;
comment|/* No output if the modem is off. */
if|if
condition|(
operator|!
name|ct_get_dsr
argument_list|(
name|d
operator|->
name|chan
argument_list|)
operator|&&
operator|!
name|ct_get_loop
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
return|return;
while|while
condition|(
name|ct_buf_free
argument_list|(
name|d
operator|->
name|chan
argument_list|)
condition|)
block|{
comment|/* Get the packet to send. */
ifdef|#
directive|ifdef
name|NETGRAPH
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|hi_queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
ifndef|#
directive|ifndef
name|NETGRAPH
name|BPF_MTAP
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|m_next
condition|)
name|ct_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|d
operator|->
name|chan
operator|->
name|tbuf
index|[
name|d
operator|->
name|chan
operator|->
name|te
index|]
argument_list|)
expr_stmt|;
name|ct_send_packet
argument_list|(
name|d
operator|->
name|chan
argument_list|,
name|d
operator|->
name|chan
operator|->
name|tbuf
index|[
name|d
operator|->
name|chan
operator|->
name|te
index|]
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Set up transmit timeout, if the transmit ring is not empty. 		 * Transmit timeout is 10 seconds. */
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|10
expr_stmt|;
else|#
directive|else
name|d
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|10
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|NETGRAPH
name|d
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Start output on the interface.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ct_start
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|dtr
condition|)
name|ct_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|chan
operator|->
name|rts
condition|)
name|ct_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ct_send
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle transmit timeouts.  * Recover after lost transmit interrupts.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|ct_watchdog
parameter_list|(
name|drv_t
modifier|*
name|d
parameter_list|)
block|{
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|bd
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"device timeout\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|running
condition|)
block|{
name|ct_setup_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|ct_start_chan
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ct_set_dtr
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ct_set_rts
argument_list|(
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ct_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit callback function.  */
end_comment

begin_function
specifier|static
name|void
name|ct_transmit
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|attachment
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ct_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the received packet.  */
end_comment

begin_function
specifier|static
name|void
name|ct_receive
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|int
name|error
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|running
condition|)
return|return;
name|m
operator|=
name|makembuf
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"no memory for packet\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_iqdrops
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|c
operator|->
name|debug
operator|>
literal|1
condition|)
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
literal|0
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|d
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|d
operator|->
name|ifp
expr_stmt|;
comment|/* Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf. */
name|BPF_TAP
argument_list|(
name|d
operator|->
name|ifp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|d
operator|->
name|queue
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Error callback function.  */
end_comment

begin_function
specifier|static
name|void
name|ct_error
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
switch|switch
condition|(
name|data
condition|)
block|{
case|case
name|CT_FRAME
case|:
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"frame error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CT_CRC
case|:
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"crc error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CT_OVERRUN
case|:
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_collisions
expr_stmt|;
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CT_OVERFLOW
case|:
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"overflow error\n"
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CT_UNDERRUN
case|:
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"underrun error\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|d
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|++
name|d
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ct_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"error #%d\n"
operator|,
name|data
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ct_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NCTAU
operator|*
name|NCHAN
operator|||
operator|!
operator|(
name|d
operator|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|)
condition|)
return|return
name|ENXIO
return|;
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_open\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ct_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ct_close\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ct_modem_status
parameter_list|(
name|ct_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
decl_stmt|;
name|int
name|status
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|bd
operator|=
name|d
operator|->
name|bd
expr_stmt|;
name|status
operator|=
name|d
operator|->
name|running
condition|?
name|TIOCM_LE
else|:
literal|0
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct_get_cd
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|ct_get_cts
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|ct_get_dsr
argument_list|(
name|c
argument_list|)
condition|)
name|status
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|dtr
condition|)
name|status
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rts
condition|)
name|status
operator||=
name|TIOCM_RTS
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request on /dev/cronyx/ctauN.  */
end_comment

begin_function
specifier|static
name|int
name|ct_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|channel
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
decl_stmt|;
name|ct_chan_t
modifier|*
name|c
decl_stmt|;
name|struct
name|serial_statistics
modifier|*
name|st
decl_stmt|;
name|struct
name|e1_statistics
modifier|*
name|opte1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|char
name|mask
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|d
operator|->
name|chan
condition|)
return|return
literal|0
return|;
name|bd
operator|=
name|d
operator|->
name|bd
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|chan
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SERIAL_GETREGISTERED
case|:
name|bzero
argument_list|(
name|mask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|NCTAU
operator|*
name|NCHAN
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|channel
index|[
name|s
index|]
condition|)
name|mask
index|[
name|s
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|s
operator|&
literal|7
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|mask
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|NETGRAPH
case|case
name|SERIAL_GETPROTO
case|:
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
condition|?
literal|"fr"
else|:
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|?
literal|"cisco"
else|:
literal|"ppp"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPROTO
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|d
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"cisco"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
operator|(
name|PP_FR
operator|)
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|PP_CISCO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"fr"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator||=
name|PP_FR
operator||
name|PP_KEEPALIVE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"ppp"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
operator|(
name|PP_FR
operator||
name|PP_KEEPALIVE
operator|)
expr_stmt|;
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|PP_CISCO
operator|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETKEEPALIVE
case|:
if|if
condition|(
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_KEEPALIVE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETKEEPALIVE
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&
name|PP_FR
operator|)
operator|||
operator|(
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|PP_CISCO
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
else|else
name|IFP2SP
argument_list|(
name|d
operator|->
name|ifp
argument_list|)
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/*NETGRAPH*/
case|case
name|SERIAL_GETMODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|SERIAL_HDLC
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCFG
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_HDLC
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|ct_get_config
argument_list|(
name|c
operator|->
name|board
argument_list|)
condition|)
block|{
default|default:
operator|*
operator|(
name|char
operator|*
operator|)
name|data
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|CFG_B
case|:
operator|*
operator|(
name|char
operator|*
operator|)
name|data
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|CFG_C
case|:
operator|*
operator|(
name|char
operator|*
operator|)
name|data
operator|=
literal|'c'
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_SETCFG
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_HDLC
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|char
operator|*
operator|)
name|data
condition|)
block|{
case|case
literal|'a'
case|:
name|ct_set_config
argument_list|(
name|c
operator|->
name|board
argument_list|,
name|CFG_A
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ct_set_config
argument_list|(
name|c
operator|->
name|board
argument_list|,
name|CFG_B
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|ct_set_config
argument_list|(
name|c
operator|->
name|board
argument_list|,
name|CFG_C
argument_list|)
expr_stmt|;
break|break;
block|}
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSTAT
case|:
name|st
operator|=
operator|(
expr|struct
name|serial_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|st
operator|->
name|rintr
operator|=
name|c
operator|->
name|rintr
expr_stmt|;
name|st
operator|->
name|tintr
operator|=
name|c
operator|->
name|tintr
expr_stmt|;
name|st
operator|->
name|mintr
operator|=
name|c
operator|->
name|mintr
expr_stmt|;
name|st
operator|->
name|ibytes
operator|=
name|c
operator|->
name|ibytes
expr_stmt|;
name|st
operator|->
name|ipkts
operator|=
name|c
operator|->
name|ipkts
expr_stmt|;
name|st
operator|->
name|ierrs
operator|=
name|c
operator|->
name|ierrs
expr_stmt|;
name|st
operator|->
name|obytes
operator|=
name|c
operator|->
name|obytes
expr_stmt|;
name|st
operator|->
name|opkts
operator|=
name|c
operator|->
name|opkts
expr_stmt|;
name|st
operator|->
name|oerrs
operator|=
name|c
operator|->
name|oerrs
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETESTAT
case|:
name|opte1
operator|=
operator|(
expr|struct
name|e1_statistics
operator|*
operator|)
name|data
expr_stmt|;
name|opte1
operator|->
name|status
operator|=
name|c
operator|->
name|status
expr_stmt|;
name|opte1
operator|->
name|cursec
operator|=
name|c
operator|->
name|cursec
expr_stmt|;
name|opte1
operator|->
name|totsec
operator|=
name|c
operator|->
name|totsec
operator|+
name|c
operator|->
name|cursec
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|bpv
operator|=
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|fse
operator|=
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|crce
operator|=
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|rcrce
operator|=
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|uas
operator|=
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|les
operator|=
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|es
operator|=
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|bes
operator|=
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|ses
operator|=
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|oofs
operator|=
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|css
operator|=
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|currnt
operator|.
name|dm
operator|=
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|bpv
operator|=
name|c
operator|->
name|total
operator|.
name|bpv
operator|+
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|fse
operator|=
name|c
operator|->
name|total
operator|.
name|fse
operator|+
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|crce
operator|=
name|c
operator|->
name|total
operator|.
name|crce
operator|+
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|rcrce
operator|=
name|c
operator|->
name|total
operator|.
name|rcrce
operator|+
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|uas
operator|=
name|c
operator|->
name|total
operator|.
name|uas
operator|+
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|les
operator|=
name|c
operator|->
name|total
operator|.
name|les
operator|+
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|es
operator|=
name|c
operator|->
name|total
operator|.
name|es
operator|+
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|bes
operator|=
name|c
operator|->
name|total
operator|.
name|bes
operator|+
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|ses
operator|=
name|c
operator|->
name|total
operator|.
name|ses
operator|+
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|oofs
operator|=
name|c
operator|->
name|total
operator|.
name|oofs
operator|+
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|css
operator|=
name|c
operator|->
name|total
operator|.
name|css
operator|+
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|total
operator|.
name|dm
operator|=
name|c
operator|->
name|total
operator|.
name|dm
operator|+
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|48
condition|;
operator|++
name|s
control|)
block|{
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bpv
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bpv
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|fse
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|fse
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|crce
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|crce
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|rcrce
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|rcrce
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|uas
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|uas
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|les
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|les
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|es
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|es
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bes
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|bes
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|ses
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|ses
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|oofs
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|oofs
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|css
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|css
expr_stmt|;
name|opte1
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|dm
operator|=
name|c
operator|->
name|interval
index|[
name|s
index|]
operator|.
name|dm
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_CLRSTAT
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|c
operator|->
name|rintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|tintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|mintr
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ibytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ipkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|ierrs
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|obytes
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|opkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|oerrs
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
operator|->
name|currnt
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|currnt
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|c
operator|->
name|total
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|total
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|c
operator|->
name|interval
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|interval
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETBAUD
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|ct_get_baud
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETBAUD
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_baud
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETLOOP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_loop
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETLOOP
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_loop
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDPLL
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_dpll
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDPLL
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_dpll
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETNRZI
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_nrzi
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETNRZI
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_nrzi
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETDEBUG
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|debug
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETDEBUG
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|c
operator|->
name|debug
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
ifndef|#
directive|ifndef
name|NETGRAPH
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_DEBUG
expr_stmt|;
else|else
name|d
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|(
operator|~
name|IFF_DEBUG
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|SERIAL_GETHIGAIN
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_higain
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETHIGAIN
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_higain
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETPHONY
case|:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: getphony\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|gopt
operator|.
name|phony
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETPHONY
case|:
name|CT_DEBUG2
argument_list|(
name|d
argument_list|,
operator|(
literal|"ioctl: setphony\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_E1
condition|)
return|return
name|EINVAL
return|;
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_phony
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETCLK
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_E1
operator|&&
name|c
operator|->
name|mode
operator|!=
name|M_G703
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|ct_get_clk
argument_list|(
name|c
argument_list|)
condition|)
block|{
default|default:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_INTERNAL
expr_stmt|;
break|break;
case|case
name|GCLK_RCV
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|E1CLK_RECEIVE
expr_stmt|;
break|break;
case|case
name|GCLK_RCLKO
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|c
operator|->
name|num
condition|?
name|E1CLK_RECEIVE_CHAN0
else|:
name|E1CLK_RECEIVE_CHAN1
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
case|case
name|SERIAL_SETCLK
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
default|default:
name|ct_set_clk
argument_list|(
name|c
argument_list|,
name|GCLK_INT
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE
case|:
name|ct_set_clk
argument_list|(
name|c
argument_list|,
name|GCLK_RCV
argument_list|)
expr_stmt|;
break|break;
case|case
name|E1CLK_RECEIVE_CHAN0
case|:
case|case
name|E1CLK_RECEIVE_CHAN1
case|:
name|ct_set_clk
argument_list|(
name|c
argument_list|,
name|GCLK_RCLKO
argument_list|)
expr_stmt|;
break|break;
block|}
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETTIMESLOTS
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|ct_get_ts
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETTIMESLOTS
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_ts
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETSUBCHAN
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_E1
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|ct_get_subchan
argument_list|(
name|c
operator|->
name|board
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETSUBCHAN
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_subchan
argument_list|(
name|c
operator|->
name|board
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETINVCLK
case|:
case|case
name|SERIAL_GETINVTCLK
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_invtxc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETINVRCLK
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_invrxc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETINVCLK
case|:
case|case
name|SERIAL_SETINVTCLK
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_invtxc
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_SETINVRCLK
case|:
comment|/* Only for superuser! */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_invrxc
argument_list|(
name|c
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SERIAL_GETLEVEL
case|:
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_G703
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_get_lq
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCSDTR
case|:
comment|/* Set DTR */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCCDTR
case|:
comment|/* Clear DTR */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMSET
case|:
comment|/* Set DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_set_dtr
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|ct_set_rts
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIS
case|:
comment|/* Add DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|ct_set_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|ct_set_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMBIC
case|:
comment|/* Clear DTR/RTS */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|ct_set_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|ct_set_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCMGET
case|:
comment|/* Get modem status */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ct_modem_status
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOTTY
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_function
specifier|static
name|int
name|ng_ct_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Constructor\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ct_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|EINVAL
return|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|bd
decl_stmt|;
comment|/* Attach debug hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CT_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|d
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for raw hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CT_HOOK_RAW
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_up
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_timeslots
parameter_list|(
name|u_long
name|s
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|s
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
block|{
name|int
name|prev
init|=
operator|(
name|i
operator|>
literal|1
operator|)
operator|&
operator|(
name|s
operator|>>
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|int
name|next
init|=
operator|(
name|i
operator|<
literal|31
operator|)
operator|&
operator|(
name|s
operator|>>
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
if|if
condition|(
name|next
condition|)
continue|continue;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|>
name|buf
condition|)
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|10
condition|)
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|i
operator|/
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'0'
operator|+
name|i
operator|%
literal|10
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_modems
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|int
name|status
init|=
name|ct_modem_status
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  LE   DTR  DSR  RTS  CTS  CD\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%4s %4s %4s %4s %4s %4s\n"
argument_list|,
name|status
operator|&
name|TIOCM_LE
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DTR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_DSR
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_RTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CTS
condition|?
literal|"On"
else|:
literal|"-"
argument_list|,
name|status
operator|&
name|TIOCM_CD
condition|?
literal|"On"
else|:
literal|"-"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ct_chan_t
modifier|*
name|c
parameter_list|,
name|int
name|need_header
parameter_list|)
block|{
name|struct
name|serial_statistics
name|st
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|st
operator|.
name|rintr
operator|=
name|c
operator|->
name|rintr
expr_stmt|;
name|st
operator|.
name|tintr
operator|=
name|c
operator|->
name|tintr
expr_stmt|;
name|st
operator|.
name|mintr
operator|=
name|c
operator|->
name|mintr
expr_stmt|;
name|st
operator|.
name|ibytes
operator|=
name|c
operator|->
name|ibytes
expr_stmt|;
name|st
operator|.
name|ipkts
operator|=
name|c
operator|->
name|ipkts
expr_stmt|;
name|st
operator|.
name|ierrs
operator|=
name|c
operator|->
name|ierrs
expr_stmt|;
name|st
operator|.
name|obytes
operator|=
name|c
operator|->
name|obytes
expr_stmt|;
name|st
operator|.
name|opkts
operator|=
name|c
operator|->
name|opkts
expr_stmt|;
name|st
operator|.
name|oerrs
operator|=
name|c
operator|->
name|oerrs
expr_stmt|;
if|if
condition|(
name|need_header
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"  Rintr   Tintr   Mintr   Ibytes   Ipkts   Ierrs   Obytes   Opkts   Oerrs\n"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%7ld %7ld %7ld %8ld %7ld %7ld %8ld %7ld %7ld\n"
argument_list|,
name|st
operator|.
name|rintr
argument_list|,
name|st
operator|.
name|tintr
argument_list|,
name|st
operator|.
name|mintr
argument_list|,
name|st
operator|.
name|ibytes
argument_list|,
name|st
operator|.
name|ipkts
argument_list|,
name|st
operator|.
name|ierrs
argument_list|,
name|st
operator|.
name|obytes
argument_list|,
name|st
operator|.
name|opkts
argument_list|,
name|st
operator|.
name|oerrs
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_e1_status
parameter_list|(
name|u_char
name|status
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_NOALARM
condition|)
return|return
literal|"Ok"
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_AIS
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",AIS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_LOMF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",LOMF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_FARLOF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",FARLOF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_AIS16
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",AIS16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_FARLOMF
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",FARLOMF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_TSTREQ
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",TSTREQ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|E1_TSTERR
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|",TSTERR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|','
condition|)
return|return
name|buf
operator|+
literal|1
return|;
return|return
literal|"Unknown"
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_frac
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|leftalign
parameter_list|,
name|u_long
name|numerator
parameter_list|,
name|u_long
name|divider
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|numerator
operator|<
literal|1
operator|||
name|divider
operator|<
literal|1
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
name|leftalign
condition|?
literal|"/-   "
else|:
literal|"    -"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
name|n
operator|=
call|(
name|int
call|)
argument_list|(
literal|0.5
operator|+
literal|1000.0
operator|*
name|numerator
operator|/
name|divider
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1000
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
name|leftalign
condition|?
literal|"/.%-3d"
else|:
literal|" .%03d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
operator|*
operator|(
name|s
operator|+
name|length
operator|)
operator|=
name|leftalign
condition|?
literal|'/'
else|:
literal|' '
expr_stmt|;
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1000000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|500
operator|)
operator|/
literal|1000
operator|*
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|100000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|50
operator|)
operator|/
literal|100
operator|*
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|>=
literal|10000
condition|)
name|n
operator|=
operator|(
name|n
operator|+
literal|5
operator|)
operator|/
literal|10
operator|*
literal|10
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1000
case|:
name|length
operator|+=
name|printf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|".999"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
case|case
literal|10000
case|:
name|n
operator|=
literal|9990
expr_stmt|;
break|break;
case|case
literal|100000
case|:
name|n
operator|=
literal|99900
expr_stmt|;
break|break;
case|case
literal|1000000
case|:
name|n
operator|=
literal|999000
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|<
literal|10000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d.%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|,
name|n
operator|/
literal|10
operator|%
literal|100
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|100000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d.%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|,
name|n
operator|/
literal|100
operator|%
literal|10
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|<
literal|1000000
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d."
argument_list|,
name|n
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_e1_stats
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ct_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|e1_counters
name|total
decl_stmt|;
name|u_long
name|totsec
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|totsec
operator|=
name|c
operator|->
name|totsec
operator|+
name|c
operator|->
name|cursec
expr_stmt|;
name|total
operator|.
name|bpv
operator|=
name|c
operator|->
name|total
operator|.
name|bpv
operator|+
name|c
operator|->
name|currnt
operator|.
name|bpv
expr_stmt|;
name|total
operator|.
name|fse
operator|=
name|c
operator|->
name|total
operator|.
name|fse
operator|+
name|c
operator|->
name|currnt
operator|.
name|fse
expr_stmt|;
name|total
operator|.
name|crce
operator|=
name|c
operator|->
name|total
operator|.
name|crce
operator|+
name|c
operator|->
name|currnt
operator|.
name|crce
expr_stmt|;
name|total
operator|.
name|rcrce
operator|=
name|c
operator|->
name|total
operator|.
name|rcrce
operator|+
name|c
operator|->
name|currnt
operator|.
name|rcrce
expr_stmt|;
name|total
operator|.
name|uas
operator|=
name|c
operator|->
name|total
operator|.
name|uas
operator|+
name|c
operator|->
name|currnt
operator|.
name|uas
expr_stmt|;
name|total
operator|.
name|les
operator|=
name|c
operator|->
name|total
operator|.
name|les
operator|+
name|c
operator|->
name|currnt
operator|.
name|les
expr_stmt|;
name|total
operator|.
name|es
operator|=
name|c
operator|->
name|total
operator|.
name|es
operator|+
name|c
operator|->
name|currnt
operator|.
name|es
expr_stmt|;
name|total
operator|.
name|bes
operator|=
name|c
operator|->
name|total
operator|.
name|bes
operator|+
name|c
operator|->
name|currnt
operator|.
name|bes
expr_stmt|;
name|total
operator|.
name|ses
operator|=
name|c
operator|->
name|total
operator|.
name|ses
operator|+
name|c
operator|->
name|currnt
operator|.
name|ses
expr_stmt|;
name|total
operator|.
name|oofs
operator|=
name|c
operator|->
name|total
operator|.
name|oofs
operator|+
name|c
operator|->
name|currnt
operator|.
name|oofs
expr_stmt|;
name|total
operator|.
name|css
operator|=
name|c
operator|->
name|total
operator|.
name|css
operator|+
name|c
operator|->
name|currnt
operator|.
name|css
expr_stmt|;
name|total
operator|.
name|dm
operator|=
name|c
operator|->
name|total
operator|.
name|dm
operator|+
name|c
operator|->
name|currnt
operator|.
name|dm
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" Unav/Degr  Bpv/Fsyn  CRC/RCRC  Err/Lerr  Sev/Bur   Oof/Slp  Status\n"
argument_list|)
expr_stmt|;
comment|/* Unavailable seconds, degraded minutes */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|uas
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
literal|60
operator|*
name|c
operator|->
name|currnt
operator|.
name|dm
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Bipolar violations, frame sync errors */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|bpv
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|fse
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* CRC errors, remote CRC errors (E-bit) */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|crce
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|rcrce
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Errored seconds, line errored seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|es
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|les
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Severely errored seconds, burst errored seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|ses
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|bes
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
comment|/* Out of frame seconds, controlled slip seconds */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|oofs
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|currnt
operator|.
name|css
argument_list|,
name|c
operator|->
name|cursec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %s\n"
argument_list|,
name|format_e1_status
argument_list|(
name|c
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print total statistics. */
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|uas
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
literal|60
operator|*
name|total
operator|.
name|dm
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|bpv
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|fse
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|crce
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|rcrce
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|es
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|les
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|ses
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|bes
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|total
operator|.
name|oofs
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|print_frac
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|1
argument_list|,
name|total
operator|.
name|css
argument_list|,
name|totsec
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" -- Total\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_chan
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|ct_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|c
operator|->
name|sys
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
init|=
name|d
operator|->
name|bd
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"ct%d"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|chan
operator|->
name|debug
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" debug=%d"
argument_list|,
name|d
operator|->
name|chan
operator|->
name|debug
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ct_get_config
argument_list|(
name|c
operator|->
name|board
argument_list|)
condition|)
block|{
case|case
name|CFG_A
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_B
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=B"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CFG_C
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=C"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" cfg=unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ct_get_baud
argument_list|(
name|c
argument_list|)
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" %ld"
argument_list|,
name|ct_get_baud
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" extclock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|||
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
switch|switch
condition|(
name|ct_get_clk
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|GCLK_INT
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GCLK_RCV
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=rcv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GCLK_RCLKO
case|:
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" syn=xrcv"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_HDLC
condition|)
block|{
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" dpll=%s"
argument_list|,
name|ct_get_dpll
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" nrzi=%s"
argument_list|,
name|ct_get_nrzi
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" invtclk=%s"
argument_list|,
name|ct_get_invtxc
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" invrclk=%s"
argument_list|,
name|ct_get_invrxc
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" higain=%s"
argument_list|,
name|ct_get_higain
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" loop=%s"
argument_list|,
name|ct_get_loop
argument_list|(
name|c
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" ts=%s"
argument_list|,
name|format_timeslots
argument_list|(
name|ct_get_ts
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_E1
operator|&&
name|ct_get_config
argument_list|(
name|c
operator|->
name|board
argument_list|)
operator|!=
name|CFG_A
condition|)
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" pass=%s"
argument_list|,
name|format_timeslots
argument_list|(
name|ct_get_subchan
argument_list|(
name|c
operator|->
name|board
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_G703
condition|)
block|{
name|int
name|lq
decl_stmt|,
name|x
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|lq
operator|=
name|ct_get_lq
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|" (level=-%.1fdB)"
argument_list|,
name|lq
operator|/
literal|10.0
argument_list|)
expr_stmt|;
block|}
name|length
operator|+=
name|sprintf
argument_list|(
name|s
operator|+
name|length
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ct_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|EINVAL
return|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rcvmsg\n"
operator|)
argument_list|)
expr_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_CT_COOKIE
case|:
name|printf
argument_list|(
literal|"Don't forget to implement\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|dl
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
literal|730
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|dl
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|s
operator|=
operator|(
name|resp
operator|)
operator|->
name|data
expr_stmt|;
name|l
operator|+=
name|print_chan
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_modems
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|l
operator|+=
name|print_e1_stats
argument_list|(
name|s
operator|+
name|l
argument_list|,
name|d
operator|->
name|chan
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|resp
operator|)
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
literal|"status"
argument_list|,
name|NG_CMDSTRLEN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ct_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ng_tag_prio
modifier|*
name|ptag
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
name|ENETDOWN
return|;
name|bd
operator|=
name|d
operator|->
name|bd
expr_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|||
operator|!
name|d
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
comment|/* Check for high priority data */
if|if
condition|(
operator|(
name|ptag
operator|=
operator|(
expr|struct
name|ng_tag_prio
operator|*
operator|)
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NG_TAG_PRIO
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ptag
operator|->
name|priority
operator|>
name|NG_PRIO_CUTOFF
operator|)
condition|)
name|q
operator|=
operator|&
name|d
operator|->
name|hi_queue
expr_stmt|;
else|else
name|q
operator|=
operator|&
name|d
operator|->
name|queue
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|IF_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ct_start
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ct_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
decl_stmt|;
name|CT_DEBUG
argument_list|(
name|d
argument_list|,
operator|(
literal|"Rmnode\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|running
condition|)
block|{
name|bd
operator|=
name|d
operator|->
name|bd
expr_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|ct_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KLD_MODULE
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NGF_REALLY_DIE
condition|)
block|{
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|NG_NODE_REVIVE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Persistant node */
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_ct_watchdog
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|timeout
operator|==
literal|1
condition|)
name|ct_watchdog
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|timeout
condition|)
name|d
operator|->
name|timeout
operator|--
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|,
name|hz
argument_list|,
name|ng_ct_watchdog
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ct_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|callout_reset
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|,
name|hz
argument_list|,
name|ng_ct_watchdog
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ct_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|drv_t
modifier|*
name|d
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|bdrv_t
modifier|*
name|bd
decl_stmt|;
if|if
condition|(
operator|!
name|d
condition|)
return|return
literal|0
return|;
name|bd
operator|=
name|d
operator|->
name|bd
expr_stmt|;
name|CT_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
name|ct_down
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CT_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
comment|/* If we were wait it than it reasserted now, just stop it. */
if|if
condition|(
operator|!
name|callout_drain
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|d
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ct_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
specifier|static
name|int
name|load_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|debug_mpsafenet
operator|&&
name|ct_mpsafenet
condition|)
block|{
name|printf
argument_list|(
literal|"WORNING! Network stack is not MPSAFE. "
literal|"Turning off debug.ct.mpsafenet.\n"
argument_list|)
expr_stmt|;
name|ct_mpsafenet
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ct_mpsafenet
condition|)
name|ct_cdevsw
operator|.
name|d_flags
operator|&=
operator|~
name|D_NEEDGIANT
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
ifdef|#
directive|ifdef
name|NETGRAPH
if|if
condition|(
name|ng_newtype
argument_list|(
operator|&
name|typestruct
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Failed to register ng_ct\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|load_count
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|timeout_handle
argument_list|,
name|ct_mpsafenet
condition|?
name|CALLOUT_MPSAFE
else|:
literal|0
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|timeout_handle
argument_list|,
name|hz
operator|*
literal|5
argument_list|,
name|ct_timeout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|load_count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Removing device entry for Tau-ISA\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH
name|ng_rmtype
argument_list|(
operator|&
name|typestruct
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If we were wait it than it reasserted now, just stop it. */
if|if
condition|(
operator|!
name|callout_drain
argument_list|(
operator|&
name|timeout_handle
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|timeout_handle
argument_list|)
expr_stmt|;
operator|--
name|load_count
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_CT_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_ct_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_ct_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_ct_rmnode
block|,
operator|.
name|newhook
operator|=
name|ng_ct_newhook
block|,
operator|.
name|connect
operator|=
name|ng_ct_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_ct_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_ct_disconnect
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NETGRAPH*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ng_ct
argument_list|,
name|netgraph
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|,
name|NG_ABI_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ct
argument_list|,
name|sppp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ct
argument_list|,
name|isa
argument_list|,
name|ct_isa_driver
argument_list|,
name|ct_devclass
argument_list|,
name|ct_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

