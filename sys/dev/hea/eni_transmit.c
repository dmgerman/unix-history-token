begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Efficient ENI Adapter Support  * -----------------------------  *   * Transmit queue management and PDU output processing  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Make a variable which controls printing of PDUs  * as they travel through the driver.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_decl_stmt
name|int
name|eni_pdu_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some PCI chipsets do not handle one or more of the 8WORD or  * 4WORD DMA transfer sizes. Default to using only 1WORD transfer  * sizes unless the user wishes to experiment.  *  * Make sure that these have to be changed here in this module.  */
end_comment

begin_define
define|#
directive|define
name|DMA_USE_8WORD
end_define

begin_define
define|#
directive|define
name|DMA_USE_4WORD
end_define

begin_comment
comment|/*  * Create a DMA list entry  *  * DMA entries consist of a control word and a physical address.  * Control words are comprised of a DMA type, a count of type transfers  * to occur, and a variable which for TX requests is the TX channel  * number and for RX requests is the VCC number.  *  * Arguments:  *	eup		pointer to unit structure  *	rx		set if receiving  *	dma_list	pointer to DMA list structure  *	list_size	length of DMA list structure  *	idx		pointer to current list entry  *	val		TX channel or RX vcc  *	addr		virtual DMA address of data buffer  *	size		size in bytes of DMA request to be built  *  * Returns:  *	dma_list	updated with new entries  *	idx		points to next list entry  *	-1		no room in DMA list structure or DMA_GET_ADDR failed  */
end_comment

begin_function
name|int
name|eni_set_dma
parameter_list|(
name|eup
parameter_list|,
name|rx
parameter_list|,
name|dma_list
parameter_list|,
name|list_size
parameter_list|,
name|idx
parameter_list|,
name|val
parameter_list|,
name|addr
parameter_list|,
name|size
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
name|u_long
modifier|*
name|dma_list
decl_stmt|;
name|int
name|list_size
decl_stmt|;
name|long
modifier|*
name|idx
decl_stmt|;
name|int
name|val
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|dsize
decl_stmt|;
comment|/* Size of current DMA request */
comment|/* 	 * Round up to multiple of word and convert to number 	 * of words rather then number of bytes. 	 */
name|size
operator|=
operator|(
name|size
operator|+
literal|3
operator|)
operator|>>
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DMA_USE_8WORD
comment|/* 	 * Check for room in DMA list - we need two entires 	 */
if|if
condition|(
operator|*
name|idx
operator|+
literal|2
operator|>=
name|list_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Here is the big win. Move as much data possible with 	 * n 8WORD DMAs. 	 */
comment|/* 	 * Check if we can do one or more 8WORD DMAs 	 */
name|dsize
operator|=
name|size
operator|&
operator|~
literal|7
expr_stmt|;
if|if
condition|(
name|dsize
condition|)
block|{
name|dma_list
index|[
operator|(
operator|*
name|idx
operator|)
operator|++
index|]
operator|=
operator|(
name|dsize
operator|>>
literal|3
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator||
name|val
operator|<<
name|DMA_VCC_SHIFT
operator||
name|DMA_8WORD
expr_stmt|;
name|dma_list
index|[
operator|*
name|idx
index|]
operator|=
operator|(
name|u_long
operator|)
name|DMA_GET_ADDR
argument_list|(
name|addr
argument_list|,
name|dsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_list
index|[
operator|*
name|idx
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rx
condition|)
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_segdma
operator|++
expr_stmt|;
else|else
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_segdma
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* DMA_GET_ADDR failed */
block|}
else|else
operator|(
operator|*
name|idx
operator|)
operator|++
expr_stmt|;
comment|/* increment index */
comment|/* 		 * Adjust addr and size 		 */
name|addr
operator|+=
name|dsize
operator|<<
literal|2
expr_stmt|;
name|size
operator|&=
literal|7
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DMA_USE_8WORD */
ifdef|#
directive|ifdef
name|DMA_USE_4WORD
comment|/* 	 * Check for room in DMA list - we need two entries 	 */
if|if
condition|(
operator|*
name|idx
operator|+
literal|2
operator|>=
name|list_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Kindof a tossup from this point on. Since we hacked as many  	 * 8WORD DMAs off as possible, we are left with 0-7 words 	 * of remaining data. We could do upto one 4WORD with 0-3 	 * words left, or upto three 2WORDS with 0-1 words left, 	 * or upto seven WORDS with nothing left. Someday we should 	 * experiment with performance and see if any particular 	 * combination is a better win then some other... 	 */
comment|/* 	 * Check if we can do one or more 4WORD DMAs 	 */
name|dsize
operator|=
name|size
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|dsize
condition|)
block|{
name|dma_list
index|[
operator|(
operator|*
name|idx
operator|)
operator|++
index|]
operator|=
operator|(
name|dsize
operator|>>
literal|2
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator||
name|val
operator|<<
name|DMA_VCC_SHIFT
operator||
name|DMA_4WORD
expr_stmt|;
name|dma_list
index|[
operator|*
name|idx
index|]
operator|=
operator|(
name|u_long
operator|)
name|DMA_GET_ADDR
argument_list|(
name|addr
argument_list|,
name|dsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_list
index|[
operator|*
name|idx
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rx
condition|)
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_segdma
operator|++
expr_stmt|;
else|else
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_segdma
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* DMA_GET_ADDR failed */
block|}
else|else
operator|(
operator|*
name|idx
operator|)
operator|++
expr_stmt|;
comment|/* increment index */
comment|/* 		 * Adjust addr and size 		 */
name|addr
operator|+=
name|dsize
operator|<<
literal|2
expr_stmt|;
name|size
operator|&=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DMA_USE_4WORD */
comment|/* 	 * Check for room in DMA list - we need two entries 	 */
if|if
condition|(
operator|*
name|idx
operator|+
literal|2
operator|>=
name|list_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Hard to know if one 2WORD and 0/1 WORD DMA would be better 	 * then 2/3 WORD DMAs. For now, skip 2WORD DMAs in favor of 	 * WORD DMAs. 	 */
comment|/* 	 * Finish remaining size a 1WORD DMAs 	 */
if|if
condition|(
name|size
condition|)
block|{
name|dma_list
index|[
operator|(
operator|*
name|idx
operator|)
operator|++
index|]
operator|=
operator|(
name|size
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator||
name|val
operator|<<
name|DMA_VCC_SHIFT
operator||
name|DMA_WORD
expr_stmt|;
name|dma_list
index|[
operator|*
name|idx
index|]
operator|=
operator|(
name|u_long
operator|)
name|DMA_GET_ADDR
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_list
index|[
operator|*
name|idx
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rx
condition|)
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_segdma
operator|++
expr_stmt|;
else|else
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_segdma
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* DMA_GET_ADDR failed */
block|}
else|else
operator|(
operator|*
name|idx
operator|)
operator|++
expr_stmt|;
comment|/* increment index */
block|}
comment|/* 	 * Inserted descriptor okay 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Drain Transmit queue  *  * As PDUs are given to the adapter to be transmitted, we  * place them into a private ifqueue so that we can free  * any resources AFTER we know they've been successfully DMAed.  * As part of the output processing, we record the PDUs start  * and stop entries in the DMA list, and prevent wrapping. When  * we pull the top element off, we simply check that the current  * DMA location is outside this PDU and if so, it's okay to free  * things.  *  * PDUs are always in ascending order in the queue.  *  * Arguments:  *	eup		pointer to device unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|eni_xmit_drain
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|Eni_vcc
modifier|*
name|evp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|u_long
name|pdulen
decl_stmt|;
name|u_long
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|u_long
name|dmap
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
comment|/* 	 * Pull the top element (PDU) off 	 */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|eup
operator|->
name|eu_txqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * As long as there are valid elements 	 */
while|while
condition|(
name|m
condition|)
block|{
name|u_long
modifier|*
name|up
decl_stmt|;
comment|/* 		 * Find start of buffer 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|up
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * First word is the VCC for this PDU 		 */
comment|/* 		 * NOTE: There is a potential problem here in that 		 * if the VCC is closed after this buffer was transmitted 		 * but before we get here, that while evp is non-null, 		 * it will not reference a valid vccb. We need to either 		 * delay closing the VCC until all references are removed 		 * from the drain stacks, actually go through the drain 		 * stacks and remove any references, or find someway of 		 * indicating that this vccb is nolonger usable. 		 */
name|evp
operator|=
operator|(
name|Eni_vcc
operator|*
operator|)
operator|*
name|up
operator|++
expr_stmt|;
comment|/* 		 * Second word is the start and stop DMA pointers 		 */
name|start
operator|=
operator|*
name|up
operator|>>
literal|16
expr_stmt|;
name|stop
operator|=
operator|*
name|up
operator|++
operator|&
literal|0xffff
expr_stmt|;
comment|/* 		 * Find out where the TX engine is at 		 */
name|dmap
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_TX_RD
index|]
expr_stmt|;
comment|/* 		 * Check to see if TX engine has processed this 		 * PDU yet. Remember that everything is circular 		 * and that stop might be less than start numerically. 		 */
if|if
condition|(
name|start
operator|>
name|stop
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dmap
operator|>=
name|stop
operator|&&
name|dmap
operator|<
name|start
operator|)
condition|)
block|{
comment|/* 			 * Haven't finished this PDU yet - replace 			 * it as the head of list. 			 */
name|_IF_PREPEND
argument_list|(
operator|&
name|eup
operator|->
name|eu_txqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * If this one isn't done, none of the others 			 * are either. 			 */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dmap
operator|<
name|stop
operator|&&
name|dmap
operator|>=
name|start
condition|)
block|{
comment|/* 			 * Haven't finished this PDU yet - replace 			 * it as the head of list. 			 */
name|_IF_PREPEND
argument_list|(
operator|&
name|eup
operator|->
name|eu_txqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * If this one isn't done, none of the others 			 * are either. 			 */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 		 * Count the PDU stats for this interface 		 */
name|eup
operator|->
name|eu_pif
operator|.
name|pif_opdus
operator|++
expr_stmt|;
comment|/* 		 * Third word is PDU length from eni_output(). 		 */
name|pdulen
operator|=
operator|*
name|up
operator|++
expr_stmt|;
name|eup
operator|->
name|eu_txfirst
operator|=
operator|(
name|eup
operator|->
name|eu_txfirst
operator|+
operator|*
name|up
operator|)
operator|&
operator|(
name|eup
operator|->
name|eu_txsize
operator|-
literal|1
operator|)
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_obytes
operator|+=
name|pdulen
expr_stmt|;
comment|/* 		 * Now lookup the VCC entry and counts the stats for 		 * this VC. 		 */
if|if
condition|(
name|evp
condition|)
block|{
name|vcp
operator|=
name|evp
operator|->
name|ev_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
name|vcp
condition|)
block|{
name|vcp
operator|->
name|vc_opdus
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_obytes
operator|+=
name|pdulen
expr_stmt|;
comment|/* 			 * If we also have a network interface, count the PDU 			 * there also. 			 */
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
block|{
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_obytes
operator|+=
name|pdulen
expr_stmt|;
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_obytes
operator|+=
name|pdulen
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 		 * Free the buffer chain 		 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Advance DMA write okay pointer 		 */
name|eup
operator|->
name|eu_txdmawr
operator|=
name|stop
expr_stmt|;
comment|/* 		 * Look for next completed transmit PDU 		 */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|eup
operator|->
name|eu_txqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We've drained the queue... 	 */
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Output a PDU  *  * This function is called via the common driver code after receiving a  * stack *_DATA* command. The common code has already validated most of  * the request so we just need to check a few more ENI-specific details.  * Then we just build a segmentation structure for the PDU and place the  * address into the DMA_Transmit_queue.  *  * Arguments:  *	cup		pointer to device common unit  *	cvp		pointer to common VCC entry  *	m		pointer to output PDU buffer chain head  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|eni_output
parameter_list|(
name|cup
parameter_list|,
name|cvp
parameter_list|,
name|m
parameter_list|)
name|Cmn_unit
modifier|*
name|cup
decl_stmt|;
name|Cmn_vcc
modifier|*
name|cvp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|Eni_unit
modifier|*
name|eup
init|=
operator|(
name|Eni_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Eni_vcc
modifier|*
name|evp
init|=
operator|(
name|Eni_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|s2
decl_stmt|;
name|int
name|pdulen
init|=
literal|0
decl_stmt|;
name|u_long
name|size
decl_stmt|;
name|u_long
name|buf_avail
decl_stmt|;
name|u_long
name|dma_rd
decl_stmt|,
name|dma_wr
decl_stmt|;
name|u_long
name|dma
index|[
name|TEMP_DMA_SIZE
index|]
decl_stmt|;
name|int
name|aal5
decl_stmt|,
name|i
decl_stmt|;
name|long
name|j
decl_stmt|;
name|u_long
name|dma_avail
decl_stmt|;
name|u_long
name|dma_start
decl_stmt|;
name|Eni_mem
name|tx_send
decl_stmt|;
name|u_long
modifier|*
name|up
decl_stmt|;
name|KBuffer
modifier|*
name|m0
init|=
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|,
modifier|*
name|mprev
init|=
name|NULL
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|,
name|bfr
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|align
decl_stmt|;
name|int
name|compressed
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|eni_pdu_print
condition|)
name|atm_dev_pdu_print
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|,
name|m
argument_list|,
literal|"eni output"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Re-entry point for after buffer compression (if needed) 	 */
name|retry
label|:
comment|/* 	 * We can avoid traversing the buffer list twice by building 	 * the middle (minus header and trailer) dma list at the 	 * same time we massage address and size alignments. Since 	 * this list remains local until we determine we've enough 	 * room, we're not going to trash anything by not checking 	 * sizes, etc. yet. Skip first entry to be used later to skip 	 * descriptor word. 	 */
name|j
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Do data positioning for address and length alignment 	 */
while|while
condition|(
name|m
condition|)
block|{
name|u_long
name|buf_addr
decl_stmt|;
comment|/* For passing addr to eni_set_dma() */
comment|/* 		 * Get rid of any zero length buffers 		 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mprev
condition|)
block|{
name|KB_UNLINK
argument_list|(
name|m
argument_list|,
name|mprev
argument_list|,
name|m1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KB_UNLINKHEAD
argument_list|(
name|m
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m1
expr_stmt|;
block|}
name|m
operator|=
name|m1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Get start of data onto full-word alignment 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|align
operator|=
operator|(
operator|(
name|u_int
operator|)
name|cp
operator|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Gotta slide the data up 			 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_segnoal
operator|++
expr_stmt|;
name|bfr
operator|=
name|cp
operator|-
name|align
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|bfr
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|KB_HEADMOVE
argument_list|(
name|m
argument_list|,
operator|-
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Data already aligned 			 */
name|bfr
operator|=
name|cp
expr_stmt|;
block|}
comment|/* 		 * Now work on getting the data length correct 		 */
name|len
operator|=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|align
operator|=
operator|(
name|len
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&&
operator|(
name|m1
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Have to move some data from following buffer(s) 			 * to word-fill this buffer 			 */
name|u_int
name|ncopy
init|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|-
name|align
argument_list|,
name|KB_LEN
argument_list|(
name|m1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ncopy
condition|)
block|{
comment|/* 				 * Move data to current buffer 				 */
name|caddr_t
name|dest
decl_stmt|;
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_seglen
operator|++
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m1
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|dest
operator|=
name|bfr
operator|+
name|len
expr_stmt|;
name|KB_HEADADJ
argument_list|(
name|m1
argument_list|,
operator|-
name|ncopy
argument_list|)
expr_stmt|;
name|KB_TAILADJ
argument_list|(
name|m
argument_list|,
name|ncopy
argument_list|)
expr_stmt|;
name|len
operator|+=
name|ncopy
expr_stmt|;
while|while
condition|(
name|ncopy
operator|--
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 			 * If we've drained the buffer, free it 			 */
if|if
condition|(
name|KB_LEN
argument_list|(
name|m1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KBuffer
modifier|*
name|m2
decl_stmt|;
name|KB_UNLINK
argument_list|(
name|m1
argument_list|,
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Address and size are now aligned. Build dma list 		 * using TX channel 0. Also, round length up to a word 		 * size which should only effect the last buffer in the 		 * chain. This works because the PDU length is maintained 		 * separately and we're not really adjusting the buffer's 		 * idea of its length. 		 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|buf_addr
argument_list|,
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
name|eni_set_dma
argument_list|(
name|eup
argument_list|,
literal|0
argument_list|,
name|dma
argument_list|,
name|TEMP_DMA_SIZE
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|,
name|buf_addr
argument_list|,
name|KB_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Failed to build DMA list. First, we'll try to 			 * compress the buffer chain into a smaller number 			 * of buffers. After compressing, we'll try to send 			 * the new buffer chain. If we still fail, then 			 * we'll drop the pdu. 			 */
if|if
condition|(
name|compressed
condition|)
block|{
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_output: eni_set_dma failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eup
operator|->
name|eu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_maxpdu
operator|++
expr_stmt|;
name|m
operator|=
name|atm_dev_compress
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_output: atm_dev_compress() failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eup
operator|->
name|eu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 			 * Reset to new head of buffer chain 			 */
name|m0
operator|=
name|m
expr_stmt|;
comment|/* 			 * Indicate we've been through here 			 */
name|compressed
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Retry to build the DMA descriptors for the newly 			 *  compressed buffer chain 			 */
goto|goto
name|retry
goto|;
block|}
comment|/* 		 * Now count the length 		 */
name|pdulen
operator|+=
name|KB_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Bump counters and get ready for next buffer 		 */
name|mprev
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|KB_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get a buffer to use in a private queue so that we can 	 * reclaim resources after the DMA has finished. 	 */
name|KB_ALLOC
argument_list|(
name|m
argument_list|,
name|ENI_SMALL_BSIZE
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* 		 * Link the PDU onto our new head 		 */
name|KB_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|m0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Drop this PDU and let the sender try again. 		 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_norsc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_output: Unable to allocate drain buffer.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eup
operator|->
name|eu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * Calculate size of buffer necessary to store PDU. If this 	 * is an AAL5 PDU, we'll need to know where to stuff the length 	 * value in the trailer. 	 */
comment|/* 	 * AAL5 PDUs need an extra two words for control/length and 	 * CRC. Check for AAL5 and add requirements here. 	 */
if|if
condition|(
operator|(
name|aal5
operator|=
operator|(
name|evp
operator|->
name|ev_connvc
operator|->
name|cvc_attr
operator|.
name|aal
operator|.
name|type
operator|==
name|ATM_AAL5
operator|)
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
name|pdulen
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
else|else
name|size
operator|=
name|pdulen
expr_stmt|;
comment|/* 	 * Pad to next complete cell boundary 	 */
name|size
operator|+=
operator|(
name|BYTES_PER_CELL
operator|-
literal|1
operator|)
expr_stmt|;
name|size
operator|-=
name|size
operator|%
name|BYTES_PER_CELL
expr_stmt|;
comment|/* 	 * Convert size to words and add 2 words overhead for every 	 * PDU (descriptor and cell header). 	 */
name|size
operator|=
operator|(
name|size
operator|>>
literal|2
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* 	 * First, check to see if there's enough buffer space to 	 * store the PDU. We do this by checking to see if the size 	 * required crosses the eu_txfirst pointer.  However, we don't 	 * want to exactly fill the buffer, because we won't be able to 	 * distinguish between a full and empty buffer. 	 */
if|if
condition|(
name|eup
operator|->
name|eu_txpos
operator|==
name|eup
operator|->
name|eu_txfirst
condition|)
name|buf_avail
operator|=
name|eup
operator|->
name|eu_txsize
expr_stmt|;
elseif|else
if|if
condition|(
name|eup
operator|->
name|eu_txpos
operator|>
name|eup
operator|->
name|eu_txfirst
condition|)
name|buf_avail
operator|=
name|eup
operator|->
name|eu_txsize
operator|-
operator|(
name|eup
operator|->
name|eu_txpos
operator|-
name|eup
operator|->
name|eu_txfirst
operator|)
expr_stmt|;
else|else
name|buf_avail
operator|=
name|eup
operator|->
name|eu_txfirst
operator|-
name|eup
operator|->
name|eu_txpos
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|buf_avail
condition|)
block|{
comment|/* 		 * No buffer space in the adapter to store this PDU. 		 * Drop PDU and return. 		 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_nobuf
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_output: not enough room in buffer\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eup
operator|->
name|eu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Find out where current DMA pointers are at 	 */
name|dma_start
operator|=
name|dma_wr
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_TX_WR
index|]
expr_stmt|;
name|dma_rd
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_TX_RD
index|]
expr_stmt|;
comment|/* 	 * Figure out how much DMA room we have available 	 */
if|if
condition|(
name|dma_rd
operator|==
name|dma_wr
condition|)
block|{
comment|/* Queue is empty */
name|dma_avail
operator|=
name|DMA_LIST_SIZE
expr_stmt|;
block|}
else|else
block|{
name|dma_avail
operator|=
operator|(
name|dma_rd
operator|+
name|DMA_LIST_SIZE
operator|-
name|dma_wr
operator|)
operator|&
operator|(
name|DMA_LIST_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 	 * Check to see if we can describe this PDU or if we're: 	 * out of room, will wrap past recovered resources. 	 */
if|if
condition|(
name|dma_avail
operator|<
operator|(
name|j
operator|/
literal|2
operator|+
literal|4
operator|)
operator|||
operator|(
name|dma_wr
operator|+
operator|(
name|j
operator|/
literal|2
operator|+
literal|4
operator|)
operator|>
name|eup
operator|->
name|eu_txdmawr
operator|+
name|DMA_LIST_SIZE
operator|)
condition|)
block|{
comment|/* 		 * No space to insert DMA list into queue. Drop this PDU. 		 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_xm_nodma
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_output: not enough room in DMA queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eup
operator|->
name|eu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Create DMA descriptor for header. There is a descriptor word 	 * and also a cell header word which we'll set manually. 	 */
name|dma
index|[
literal|0
index|]
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|eup
operator|->
name|eu_txpos
operator|+
literal|2
argument_list|)
operator|&
operator|(
name|eup
operator|->
name|eu_txsize
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator|)
operator||
name|DMA_JK
expr_stmt|;
name|dma
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * JK for AAL5 trailer. Set END bit as well. 	 */
if|if
condition|(
name|aal5
condition|)
block|{
name|dma
index|[
name|j
operator|++
index|]
operator|=
operator|(
operator|(
call|(
name|int
call|)
argument_list|(
name|eup
operator|->
name|eu_txpos
operator|+
name|size
argument_list|)
operator|&
operator|(
name|eup
operator|->
name|eu_txsize
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator|)
operator||
name|DMA_END_BIT
operator||
name|DMA_JK
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dma
index|[
name|j
operator|-
literal|2
index|]
operator||=
name|DMA_END_BIT
expr_stmt|;
comment|/* Backup and set END bit */
block|}
comment|/* 	 * Find out where in adapter memory this TX buffer starts. 	 */
name|tx_send
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
operator|(
operator|(
operator|(
name|int
operator|)
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_TXPLACE
index|]
operator|&
literal|0x7ff
operator|)
operator|<<
name|ENI_LOC_PREDIV
operator|)
operator|+
operator|(
name|int
operator|)
name|eup
operator|->
name|eu_ram
argument_list|)
expr_stmt|;
comment|/* 	 * Set descriptor word 	 */
name|tx_send
index|[
name|eup
operator|->
name|eu_txpos
index|]
operator|=
operator|(
name|MIDWAY_UNQ_ID
operator|<<
literal|28
operator|)
operator||
operator|(
name|aal5
condition|?
literal|1
operator|<<
literal|27
else|:
literal|0
operator|)
operator||
operator|(
name|size
operator|/
name|WORDS_PER_CELL
operator|)
expr_stmt|;
comment|/* 	 * Set cell header 	 */
name|tx_send
index|[
operator|(
name|eup
operator|->
name|eu_txpos
operator|+
literal|1
operator|)
operator|&
operator|(
name|eup
operator|->
name|eu_txsize
operator|-
literal|1
operator|)
index|]
operator|=
name|evp
operator|->
name|ev_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_vci
operator|<<
literal|4
expr_stmt|;
comment|/* 	 * We've got all our resources, count the stats 	 */
if|if
condition|(
name|aal5
condition|)
block|{
comment|/* 		 * If this is an AAL5 PDU, we need to set the length 		 */
name|tx_send
index|[
operator|(
name|eup
operator|->
name|eu_txpos
operator|+
name|size
operator|-
literal|2
operator|)
operator|&
operator|(
name|eup
operator|->
name|eu_txsize
operator|-
literal|1
operator|)
index|]
operator|=
name|pdulen
expr_stmt|;
comment|/* 		 * Increment AAL5 stats 		 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_pdu_xmit
operator|++
expr_stmt|;
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_xmit
operator|+=
operator|(
name|size
operator|-
literal|2
operator|)
operator|/
name|WORDS_PER_CELL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Increment AAL0 stats 		 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal0
operator|.
name|aal0_xmit
operator|+=
operator|(
name|size
operator|-
literal|2
operator|)
operator|/
name|WORDS_PER_CELL
expr_stmt|;
block|}
comment|/* 	 * Increment ATM stats 	 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_atm
operator|.
name|atm_xmit
operator|+=
operator|(
name|size
operator|-
literal|2
operator|)
operator|/
name|WORDS_PER_CELL
expr_stmt|;
comment|/* 	 * Store the DMA list 	 */
name|j
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|eup
operator|->
name|eu_txdma
index|[
name|dma_wr
operator|*
literal|2
index|]
operator|=
name|dma
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|eup
operator|->
name|eu_txdma
index|[
name|dma_wr
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|dma
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|dma_wr
operator|=
operator|(
name|dma_wr
operator|+
literal|1
operator|)
operator|&
operator|(
name|DMA_LIST_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 	 * Build drain buffer 	 * 	 * We toss four words in to help keep track of this 	 * PDU. The first is a pointer to the VC control block 	 * so we can find which VCI this went out on, the second 	 * is the start and stop pointers for the DMA list which 	 * describes this PDU, the third is the PDU length 	 * since we'll want to know that for stats gathering, 	 * and the fourth is the number of DMA words. 	 */
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|up
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
operator|*
name|up
operator|++
operator|=
operator|(
name|u_long
operator|)
name|cvp
expr_stmt|;
operator|*
name|up
operator|++
operator|=
name|dma_start
operator|<<
literal|16
operator||
name|dma_wr
expr_stmt|;
operator|*
name|up
operator|++
operator|=
name|pdulen
expr_stmt|;
operator|*
name|up
operator|=
name|size
expr_stmt|;
comment|/* 	 * Set length of our buffer 	 */
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* 	 * Place buffers onto transmit queue for draining 	 */
name|s2
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|eup
operator|->
name|eu_txqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s2
argument_list|)
expr_stmt|;
comment|/* 	 * Update next word to be stored 	 */
name|eup
operator|->
name|eu_txpos
operator|=
operator|(
operator|(
name|eup
operator|->
name|eu_txpos
operator|+
name|size
operator|)
operator|&
operator|(
name|eup
operator|->
name|eu_txsize
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Update MIDWAY_TX_WR pointer 	 */
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_TX_WR
index|]
operator|=
name|dma_wr
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

