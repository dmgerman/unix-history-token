begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Efficient ENI adapter support  * -----------------------------  *  * Module supports PCI interface to ENI adapter  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILING_LINT
end_ifdef

begin_warning
warning|#
directive|warning
literal|"The eni driver is broken and is not compiled with LINT"
end_warning

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDPCI
end_ifndef

begin_error
error|#
directive|error
literal|"The eni device requires the old pci compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Typedef local functions  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|eni_pci_probe
parameter_list|(
name|pcici_t
parameter_list|,
name|pcidi_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eni_pci_attach
parameter_list|(
name|pcici_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eni_get_ack
parameter_list|(
name|Eni_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eni_get_sebyte
parameter_list|(
name|Eni_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eni_read_seeprom
parameter_list|(
name|Eni_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199506
end_if

begin_function_decl
specifier|static
name|int
name|eni_pci_shutdown
parameter_list|(
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|eni_pci_shutdown
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|eni_pci_reset
parameter_list|(
name|Eni_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Used by kernel to return number of claimed devices  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|eni_nunits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|eni_pci_device
init|=
block|{
name|ENI_DEV_NAME
block|,
name|eni_pci_probe
block|,
name|eni_pci_attach
block|,
operator|&
name|eni_nunits
block|,
if|#
directive|if
name|BSD
operator|<
literal|199506
name|eni_pci_shutdown
else|#
directive|else
name|NULL
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_PCI_DRIVER
argument_list|(
name|eni_pci
argument_list|,
name|eni_pci_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Called by kernel with PCI device_id which was read from the PCI  * register set. If the identified vendor is Efficient, see if we  * recognize the particular device. If so, return an identifying string,  * if not, return null.  *  * Arguments:  *	config_id	PCI config token  *	device_id	contents of PCI device ID register  *  * Returns:  *	string		Identifying string if we will handle this device  *	NULL		unrecognized vendor/device  *  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|eni_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
if|if
condition|(
operator|(
name|device_id
operator|&
literal|0xFFFF
operator|)
operator|==
name|EFF_VENDOR_ID
condition|)
block|{
switch|switch
condition|(
operator|(
name|device_id
operator|>>
literal|16
operator|)
condition|)
block|{
case|case
name|EFF_DEV_ID
case|:
return|return
operator|(
literal|"Efficient ENI ATM Adapter"
operator|)
return|;
comment|/* NOTREACHED */
break|break;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ENI-155p adapter uses an ATMEL AT24C01 serial EEPROM to store  * configuration information. The SEEPROM is accessed via two wires,  * CLOCK and DATA, which are accessible via the PCI configuration  * registers. The following macros manipulate the lines to access the  * SEEPROM. See http://www.atmel.com/atmel/products/prod162.htm for  * a description of the AT24C01 part. Value to be read/written is  * part of the per unit structure.  */
end_comment

begin_comment
comment|/*  * Write bits to SEEPROM  */
end_comment

begin_define
define|#
directive|define
name|WRITE_SEEPROM
parameter_list|()
value|(						\     {									\ 	(void) pci_conf_write ( eup->eu_pcitag, SEEPROM,		\ 		eup->eu_sevar );					\ 	DELAY(SEPROM_DELAY);						\     }									\ )
end_define

begin_comment
comment|/*  * Stobe first the DATA, then the CLK lines high  */
end_comment

begin_define
define|#
directive|define
name|STROBE_HIGH
parameter_list|()
value|(						\     {									\ 	eup->eu_sevar |= SEPROM_DATA; WRITE_SEEPROM();			\ 	eup->eu_sevar |= SEPROM_CLK;  WRITE_SEEPROM();			\     }									\ )
end_define

begin_comment
comment|/*  * Strobe first the CLK, then the DATA lines high  */
end_comment

begin_define
define|#
directive|define
name|INV_STROBE_HIGH
parameter_list|()
value|(					\     {									\ 	eup->eu_sevar |= SEPROM_CLK;  WRITE_SEEPROM();			\ 	eup->eu_sevar |= SEPROM_DATA; WRITE_SEEPROM();			\     }									\ )
end_define

begin_comment
comment|/*  * Strobe first the CLK, then the DATA lines low - companion to  * STROBE_HIGH()  */
end_comment

begin_define
define|#
directive|define
name|STROBE_LOW
parameter_list|()
value|(						\     {									\ 	eup->eu_sevar&= ~SEPROM_CLK;  WRITE_SEEPROM();			\ 	eup->eu_sevar&= ~SEPROM_DATA; WRITE_SEEPROM();			\     }									\ )
end_define

begin_comment
comment|/*  * Strobe first the DATA, then the CLK lines low - companion to  * INV_STROBE_HIGH()  */
end_comment

begin_define
define|#
directive|define
name|INV_STROBE_LOW
parameter_list|()
value|(					\     {									\ 	eup->eu_sevar&= ~SEPROM_DATA; WRITE_SEEPROM();			\ 	eup->eu_sevar&= ~SEPROM_CLK;  WRITE_SEEPROM();			\     }									\ )
end_define

begin_comment
comment|/*  * Strobe the CLK line high, then low  */
end_comment

begin_define
define|#
directive|define
name|STROBE_CLK
parameter_list|()
value|(						\     {									\ 	eup->eu_sevar |= SEPROM_CLK;   WRITE_SEEPROM();			\ 	eup->eu_sevar&= ~SEPROM_CLK;  WRITE_SEEPROM();			\     }									\ )
end_define

begin_comment
comment|/*  * Look for a positive ACK from the SEEPROM. Cycle begins by asserting  * the DATA line, then the CLK line. The DATA line is then read to  * retrieve the ACK status, and then the cycle is finished by deasserting  * the CLK line, and asserting the DATA line.  *  * Arguments:  *	eup		pointer to per unit structure  *  * Returns:  *	0/1		value of ACK  *  */
end_comment

begin_function
specifier|static
name|int
name|eni_get_ack
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|int
name|ack
decl_stmt|;
name|STROBE_HIGH
argument_list|()
expr_stmt|;
comment|/* 	 * Read DATA line from SEPROM 	 */
name|eup
operator|->
name|eu_sevar
operator|=
name|pci_conf_read
argument_list|(
name|eup
operator|->
name|eu_pcitag
argument_list|,
name|SEEPROM
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEPROM_DELAY
argument_list|)
expr_stmt|;
name|ack
operator|=
name|eup
operator|->
name|eu_sevar
operator|&
name|SEPROM_DATA
expr_stmt|;
name|eup
operator|->
name|eu_sevar
operator|&=
operator|~
name|SEPROM_CLK
expr_stmt|;
name|WRITE_SEEPROM
argument_list|()
expr_stmt|;
name|eup
operator|->
name|eu_sevar
operator||=
name|SEPROM_DATA
expr_stmt|;
name|WRITE_SEEPROM
argument_list|()
expr_stmt|;
return|return
operator|(
name|ack
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a byte from the SEEPROM. Data is read as 8 bits. There are two types  * of read operations. The first is a single byte read, the second is  * multiple sequential bytes read. Both cycles begin with a 'START' operation,  * followed by a memory address word. Following the memory address, the  * SEEPROM will send a data byte, followed by an ACK. If the host responds  * with a 'STOP' operation, then a single byte cycle is performed. If the  * host responds with an 'ACK', then the memory address is incremented, and  * the next sequential memory byte is serialized.  *  * Arguments:  *	eup		pointer to per unit structure  *  * Returns:  *	val		value of byte read from SEEPROM  *  */
end_comment

begin_function
specifier|static
name|int
name|eni_get_sebyte
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|data
decl_stmt|;
name|int
name|rval
decl_stmt|;
comment|/* Initial value */
name|rval
operator|=
literal|0
expr_stmt|;
comment|/* Read 8 bits */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/* Shift bits to left so the next bit goes to position 0 */
name|rval
operator|<<=
literal|1
expr_stmt|;
comment|/* Indicate we're ready to read bit */
name|STROBE_HIGH
argument_list|()
expr_stmt|;
comment|/* 		 * Read DATA line from SEPROM 		 */
name|data
operator|=
name|pci_conf_read
argument_list|(
name|eup
operator|->
name|eu_pcitag
argument_list|,
name|SEEPROM
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|SEPROM_DELAY
argument_list|)
expr_stmt|;
comment|/* (Possibly) mask bit into accumulating value */
if|if
condition|(
name|data
operator|&
name|SEPROM_DATA
condition|)
name|rval
operator||=
literal|1
expr_stmt|;
comment|/* If DATA bit '1' */
comment|/* Indicate we're done reading this bit */
name|STROBE_LOW
argument_list|()
expr_stmt|;
block|}
comment|/* Return acquired byte */
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The AT24C01 is a 1024 bit part organized as 128 words by 8 bits.  * We will read the entire contents into the per unit structure. Later,  * we'll retrieve the MAC address and serial number from the data read.  *  * Arguments:  *	eup		pointer to per unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|eni_read_seeprom
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|int
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Set initial state 	 */
name|eup
operator|->
name|eu_sevar
operator|=
name|SEPROM_DATA
operator||
name|SEPROM_CLK
expr_stmt|;
name|WRITE_SEEPROM
argument_list|()
expr_stmt|;
comment|/* Loop for all bytes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SEPROM_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* Send START operation */
name|STROBE_HIGH
argument_list|()
expr_stmt|;
name|INV_STROBE_LOW
argument_list|()
expr_stmt|;
comment|/* 		 * Send address. Addresses are sent as 7 bits plus 		 * last bit high. 		 */
name|addr
operator|=
operator|(
operator|(
name|i
operator|)
operator|<<
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Start with high order bit first working toward low 		 * order bit. 		 */
for|for
control|(
name|j
operator|=
literal|7
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
comment|/* Set current bit value */
name|eup
operator|->
name|eu_sevar
operator|=
operator|(
name|addr
operator|>>
name|j
operator|)
operator|&
literal|1
condition|?
name|eup
operator|->
name|eu_sevar
operator||
name|SEPROM_DATA
else|:
name|eup
operator|->
name|eu_sevar
operator|&
operator|~
name|SEPROM_DATA
expr_stmt|;
name|WRITE_SEEPROM
argument_list|()
expr_stmt|;
comment|/* Indicate we've sent it */
name|STROBE_CLK
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * We expect a zero ACK after sending the address 		 */
if|if
condition|(
operator|!
name|eni_get_ack
argument_list|(
name|eup
argument_list|)
condition|)
block|{
comment|/* Address okay - read data byte */
name|eup
operator|->
name|eu_seeprom
index|[
name|i
index|]
operator|=
name|eni_get_sebyte
argument_list|(
name|eup
argument_list|)
expr_stmt|;
comment|/* Grab but ignore the ACK op */
operator|(
name|void
operator|)
name|eni_get_ack
argument_list|(
name|eup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Address ACK was bad - can't retrieve data byte */
name|eup
operator|->
name|eu_seeprom
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * The kernel has found a device which we are willing to support.  * We are now being called to do any necessary work to make the  * device initially usable. In our case, this means allocating  * structure memory, configuring registers, mapping device  * memory, setting pointers, registering with the core services,  * and doing the initial PDU processing configuration.  *  * Arguments:  *	config_id		PCI device token  *	unit			instance of the unit  *  * Returns:  *	none		  *  */
end_comment

begin_function
specifier|static
name|void
name|eni_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
name|long
name|val
decl_stmt|;
comment|/* 	 * Just checking... 	 */
if|if
condition|(
name|unit
operator|>=
name|ENI_MAX_UNITS
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: too many devices\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure this isn't a duplicate unit 	 */
if|if
condition|(
name|eni_units
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * Allocate a new unit structure 	 */
name|eup
operator|=
operator|(
name|Eni_unit
operator|*
operator|)
name|atm_dev_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Eni_unit
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|eup
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Start initializing it 	 */
name|eup
operator|->
name|eu_unit
operator|=
name|unit
expr_stmt|;
name|eup
operator|->
name|eu_mtu
operator|=
name|ENI_IFF_MTU
expr_stmt|;
name|eup
operator|->
name|eu_pcitag
operator|=
name|config_id
expr_stmt|;
name|eup
operator|->
name|eu_ioctl
operator|=
name|eni_atm_ioctl
expr_stmt|;
name|eup
operator|->
name|eu_instvcc
operator|=
name|eni_instvcc
expr_stmt|;
name|eup
operator|->
name|eu_openvcc
operator|=
name|eni_openvcc
expr_stmt|;
name|eup
operator|->
name|eu_closevcc
operator|=
name|eni_closevcc
expr_stmt|;
name|eup
operator|->
name|eu_output
operator|=
name|eni_output
expr_stmt|;
name|eup
operator|->
name|eu_vcc_pool
operator|=
operator|&
name|eni_vcc_pool
expr_stmt|;
name|eup
operator|->
name|eu_nif_pool
operator|=
operator|&
name|eni_nif_pool
expr_stmt|;
comment|/* 	 * Enable Memory Mapping / Bus Mastering  	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|val
operator||=
operator|(
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Map in adapter RAM 	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: memory mapping not enabled\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
operator|(
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_MAP_REG_START
argument_list|,
operator|&
name|va
argument_list|,
operator|&
name|pa
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to map memory\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Map okay - retain address assigned 	 */
name|eup
operator|->
name|eu_base
operator|=
operator|(
name|Eni_mem
operator|)
name|va
expr_stmt|;
name|eup
operator|->
name|eu_ram
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
name|eup
operator|->
name|eu_base
operator|+
name|RAM_OFFSET
argument_list|)
expr_stmt|;
comment|/* 	 * Map memory structures into adapter space 	 */
name|eup
operator|->
name|eu_suni
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
name|eup
operator|->
name|eu_base
operator|+
name|SUNI_OFFSET
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_midway
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
name|eup
operator|->
name|eu_base
operator|+
name|MIDWAY_OFFSET
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_vcitbl
operator|=
operator|(
name|VCI_Table
operator|*
operator|)
operator|(
name|eup
operator|->
name|eu_base
operator|+
name|VCITBL_OFFSET
operator|)
expr_stmt|;
name|eup
operator|->
name|eu_rxdma
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
name|eup
operator|->
name|eu_base
operator|+
name|RXQUEUE_OFFSET
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_txdma
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
name|eup
operator|->
name|eu_base
operator|+
name|TXQUEUE_OFFSET
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_svclist
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
name|eup
operator|->
name|eu_base
operator|+
name|SVCLIST_OFFSET
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_servread
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Reset the midway chip 	 */
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_ID
index|]
operator|=
name|MIDWAY_RESET
expr_stmt|;
comment|/* 	 * Size and test adapter memory. Initialize our adapter memory 	 * allocater. 	 */
if|if
condition|(
name|eni_init_memory
argument_list|(
name|eup
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Adapter memory test failed. Clean up and 		 * return. 		 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: memory test failed\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Read the contents of the SEEPROM 	 */
name|eni_read_seeprom
argument_list|(
name|eup
argument_list|)
expr_stmt|;
comment|/* 	 * Copy MAC address to PIF and config structures 	 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|eup
operator|->
name|eu_seeprom
index|[
name|SEPROM_MAC_OFF
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|eup
operator|->
name|eu_pif
operator|.
name|pif_macaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_macaddr
operator|=
name|eup
operator|->
name|eu_pif
operator|.
name|pif_macaddr
expr_stmt|;
comment|/* 	 * Copy serial number into config space 	 */
name|eup
operator|->
name|eu_config
operator|.
name|ac_serial
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|&
name|eup
operator|->
name|eu_seeprom
index|[
name|SEPROM_SN_OFF
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Convert Endianess on DMA 	 */
name|val
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_CONTROL_REG
argument_list|)
expr_stmt|;
name|val
operator||=
name|ENDIAN_SWAP_DMA
expr_stmt|;
name|pci_conf_write
argument_list|(
name|config_id
argument_list|,
name|PCI_CONTROL_REG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Map interrupt in 	 */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|eni_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eup
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unable to map interrupt\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Setup some of the adapter configuration 	 */
comment|/* 	 * Get MIDWAY ID 	 */
name|val
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_ID
index|]
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_vendor
operator|=
name|VENDOR_ENI
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_vendapi
operator|=
name|VENDAPI_ENI_1
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_device
operator|=
name|DEV_ENI_155P
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_media
operator|=
name|val
operator|&
name|MEDIA_MASK
condition|?
name|MEDIA_UTP155
else|:
name|MEDIA_OC3C
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_bustype
operator|=
name|BUS_PCI
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_busslot
operator|=
name|config_id
operator|->
name|bus
operator|<<
literal|8
operator||
name|config_id
operator|->
name|slot
expr_stmt|;
comment|/* 	 * Make a hw version number from the ID register values. 	 * Format: {Midway ID}.{Mother board ID}.{Daughter board ID} 	 */
name|snprintf
argument_list|(
name|eup
operator|->
name|eu_config
operator|.
name|ac_hard_vers
argument_list|,
sizeof|sizeof
argument_list|(
name|eup
operator|->
name|eu_config
operator|.
name|ac_hard_vers
argument_list|)
argument_list|,
literal|"%ld/%ld/%ld"
argument_list|,
operator|(
name|val
operator|>>
name|ID_SHIFT
operator|)
operator|&
name|ID_MASK
argument_list|,
operator|(
name|val
operator|>>
name|MID_SHIFT
operator|)
operator|&
name|MID_MASK
argument_list|,
operator|(
name|val
operator|>>
name|DID_SHIFT
operator|)
operator|&
name|DID_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * There is no software version number 	 */
name|eup
operator|->
name|eu_config
operator|.
name|ac_firm_vers
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Save device ram info for user-level programs 	 * NOTE: This really points to start of EEPROM 	 * and includes all the device registers in the 	 * lower 2 Megabytes. 	 */
name|eup
operator|->
name|eu_config
operator|.
name|ac_ram
operator|=
operator|(
name|long
operator|)
name|eup
operator|->
name|eu_base
expr_stmt|;
name|eup
operator|->
name|eu_config
operator|.
name|ac_ramsize
operator|=
name|eup
operator|->
name|eu_ramsize
operator|+
name|ENI_REG_SIZE
expr_stmt|;
comment|/* 	 * Setup max VPI/VCI values 	 */
name|eup
operator|->
name|eu_pif
operator|.
name|pif_maxvpi
operator|=
name|ENI_MAX_VPI
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_maxvci
operator|=
name|ENI_MAX_VCI
expr_stmt|;
comment|/* 	 * Register this interface with ATM core services 	 */
if|if
condition|(
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|eup
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|eni_services
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Registration failed - back everything out 		 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: atm_physif_register failed\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|eni_units
index|[
name|unit
index|]
operator|=
name|eup
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199506
comment|/* 	 * Add hook to out shutdown function 	 */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|eni_pci_shutdown
argument_list|,
name|eup
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize driver processing 	 */
if|if
condition|(
name|eni_init
argument_list|(
name|eup
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: adapter init failed\n"
argument_list|,
name|ENI_DEV_NAME
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
return|return;
name|failed
label|:
comment|/* 	 * Attach failed - clean up 	 */
name|eni_pci_reset
argument_list|(
name|eup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pci_unmap_int
argument_list|(
name|config_id
argument_list|)
expr_stmt|;
name|atm_dev_free
argument_list|(
name|eup
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Device reset routine  *  * Arguments:  *	eup			pointer to per unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|eni_pci_reset
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
comment|/* 	 * We should really close down any open VCI's and 	 * release all memory (TX and RX) buffers. For now, 	 * we assume we're shutting the card down for good. 	 */
if|if
condition|(
name|eup
operator|->
name|eu_midway
condition|)
block|{
comment|/* 		 * Issue RESET command to Midway chip 		 */
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_ID
index|]
operator|=
name|MIDWAY_RESET
expr_stmt|;
comment|/* 		 * Delay to allow everything to terminate 		 */
name|DELAY
argument_list|(
name|MIDWAY_DELAY
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199506
end_if

begin_comment
comment|/*  * Device shutdown routine  *  * Arguments:  *	kdc		pointer to device's configuration table  *	force		forced shutdown flag  *  * Returns:  * 	none  *  */
end_comment

begin_function
specifier|static
name|int
name|eni_pci_shutdown
parameter_list|(
name|kdc
parameter_list|,
name|force
parameter_list|)
name|struct
name|kern_devconf
modifier|*
name|kdc
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|Eni_unit
modifier|*
name|eup
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|kdc
operator|->
name|kdc_unit
operator|<
name|eni_nunits
condition|)
block|{
name|eup
operator|=
name|eni_units
index|[
name|kdc
operator|->
name|kdc_unit
index|]
expr_stmt|;
if|if
condition|(
name|eup
operator|!=
name|NULL
condition|)
block|{
comment|/* Do device reset */
name|eni_pci_reset
argument_list|(
name|eup
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Device shutdown routine  *  * Arguments:  *	howto		type of shutdown  *	eup		pointer to device unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
specifier|static
name|void
name|eni_pci_shutdown
parameter_list|(
name|eup
parameter_list|,
name|howto
parameter_list|)
name|void
modifier|*
name|eup
decl_stmt|;
name|int
name|howto
decl_stmt|;
block|{
comment|/* Do device reset */
name|eni_pci_reset
argument_list|(
name|eup
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD< 199506 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

