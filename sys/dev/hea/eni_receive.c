begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Efficient ENI Adapter Support  * -----------------------------  *  * Receive management  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|eni_recv_stack
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|KBuffer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|eni_pdu_print
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Procedure to remove VCs from the Service List and generate DMA  * requests to move the associated PDUs into host memory. As PDUs  * are completed in adapter memory, the adapter examines the IN_SERVICE  * bit for the VC in the VC table. If this bit is not set, the adapter  * will place the VC number at the end of the service list queue, set  * the IN_SERVICE bit in the VC table, and interrupt the host. The host  * will remove VCs from the service list, clear the IN_SERVICE bit in  * the VC table, and create a DMA list to move the PDU into host buffers.  *  * Arguments:  *	eup		pointer to per unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|eni_do_service
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|int
name|vcc
decl_stmt|;
name|Eni_vcc
modifier|*
name|evp
decl_stmt|;
name|u_long
name|servwrite
decl_stmt|;
name|VCI_Table
modifier|*
name|vct
decl_stmt|;
name|u_long
name|rdptr
decl_stmt|;
name|u_long
modifier|*
name|rxp
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|u_long
name|dma
index|[
name|TEMP_DMA_SIZE
index|]
decl_stmt|;
name|u_long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_long
name|dma_rd
decl_stmt|,
name|dma_wr
decl_stmt|;
name|u_long
name|dma_avail
decl_stmt|;
name|int
name|pdulen
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|u_long
modifier|*
name|upp
decl_stmt|;
comment|/* 	 * Where is the adapter currently inserting entries? 	 */
name|servwrite
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_SVCWR
index|]
operator|&
name|SVC_SIZE_MASK
expr_stmt|;
comment|/* 	 * As long as we're not caught up with the adapter, keep 	 * removing VCs from the service list. 	 */
while|while
condition|(
name|servwrite
operator|!=
name|eup
operator|->
name|eu_servread
condition|)
block|{
name|int
name|vci_hdr
decl_stmt|;
name|u_long
name|descr
decl_stmt|;
comment|/* 		 * Get VC number and find VC table entry. 		 */
name|vcc
operator|=
name|eup
operator|->
name|eu_svclist
index|[
name|eup
operator|->
name|eu_servread
index|]
expr_stmt|;
name|vct
operator|=
operator|&
name|eup
operator|->
name|eu_vcitbl
index|[
name|vcc
index|]
expr_stmt|;
name|vci_hdr
operator|=
name|vct
operator|->
name|vci_control
expr_stmt|;
comment|/* Current status */
comment|/* 		 * Check that this VCC still needs servicing. We 		 * might have closed this VCC down in between 		 * the adapter setting the flag and our checking 		 * the flag. Also check that we haven't placed the 		 * VCC into TRASH mode. 		 */
if|if
condition|(
operator|(
name|vci_hdr
operator|&
name|VCI_IN_SERVICE
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|vci_hdr
operator|&
operator|~
name|VCI_MODE_MASK
operator|)
operator|==
operator|(
name|VCI_MODE_TRASH
operator|<<
name|VCI_MODE_SHIFT
operator|)
operator|)
condition|)
goto|goto
name|next_vcc
goto|;
comment|/* 		 * Find the size of this VCs buffer 		 */
name|mask
operator|=
operator|(
name|vci_hdr
operator|>>
name|VCI_SIZE_SHIFT
operator|)
operator|&
name|VCI_SIZE_MASK
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|ENI_LOC_PREDIV
operator|+
name|mask
operator|)
expr_stmt|;
comment|/* Turn byte count into word count */
name|mask
operator|>>=
literal|2
expr_stmt|;
comment|/* 		 * Find the start of the adapter buffer for this VC. 		 */
name|rxp
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|vci_hdr
operator|>>
name|VCI_LOC_SHIFT
operator|)
operator|&
name|VCI_LOC_MASK
operator|)
operator|<<
name|ENI_LOC_PREDIV
argument_list|)
operator|+
operator|(
name|int
operator|)
name|eup
operator|->
name|eu_ram
operator|)
expr_stmt|;
comment|/* 		 * Locate incoming VCC for this PDU and find where we 		 * should next read from. 		 */
name|evp
operator|=
operator|(
name|Eni_vcc
operator|*
operator|)
name|atm_dev_vcc_find
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|eup
argument_list|,
literal|0
argument_list|,
name|vcc
argument_list|,
name|VCC_IN
argument_list|)
expr_stmt|;
if|if
condition|(
name|evp
operator|==
operator|(
name|Eni_vcc
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|next_vcc
goto|;
comment|/* VCI no longer active */
name|rdptr
operator|=
name|evp
operator|->
name|ev_rxpos
expr_stmt|;
comment|/* 		 * Find out where the adapter is currently reassembling. 		 * The PDU which starts at descr is not yet complete so we 		 * must stop there. 		 */
name|descr
operator|=
operator|(
name|vct
operator|->
name|vci_descr
operator|>>
literal|16
operator|)
operator|&
literal|0x7FFF
expr_stmt|;
comment|/* 		 * As long as we haven't processed all the completed PDUs on 		 * this VC, keep going... 		 */
while|while
condition|(
name|rdptr
operator|!=
name|descr
condition|)
block|{
name|int
name|n_cells
decl_stmt|;
name|int
name|pdu_descr
decl_stmt|;
name|int
name|aal5
decl_stmt|;
comment|/* 		     * Ensure that the following are reset for every new 		     * PDU. 		     */
name|upp
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* 		     * Fisrt build a DMA with JK to skip the descriptor word. 		     * We must always skip the descriptor even if it turns out 		     * that there isn't any PDU here. 		     */
name|j
operator|=
literal|0
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
name|rdptr
operator|+
literal|1
operator|)
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator|)
operator||
operator|(
name|vcc
operator|<<
name|DMA_VCC_SHIFT
operator|)
operator||
name|DMA_JK
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		     * We'll use some of the values below for skipping 		     * bad PDUs or counting statistics so compute them 		     * now. 		     */
comment|/* 		     * Grab a copy of the descriptor word 		     */
name|pdu_descr
operator|=
name|rxp
index|[
name|rdptr
index|]
expr_stmt|;
comment|/* 		     * Strip out cell count from descriptor word. 		     * At this point, we still don't know if there 		     * is any real data until after we check for 		     * TRASH mode. 		     */
name|n_cells
operator|=
name|pdu_descr
operator|&
name|DESCR_CELL_COUNT
expr_stmt|;
comment|/* 		     * Is this an AAL5 PDU? Check MODE in vci_hdr. 		     */
name|aal5
operator|=
operator|(
operator|(
name|vci_hdr
operator|&
operator|~
name|VCI_MODE_MASK
operator|)
operator|==
name|VCI_MODE_AAL5
operator|<<
name|VCI_MODE_SHIFT
operator|)
expr_stmt|;
comment|/* 		     * Now check to see if we're trashing on this vcc. 		     * If so, there is no data with this VC and the 		     * next word after the current descriptor is the 		     * descriptor for the next PDU. 		     */
if|if
condition|(
operator|(
name|pdu_descr
operator|&
name|DESCR_TRASH_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|aal5
condition|)
comment|/* 				 * Count as number of AAL5 cells dropped 				 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_drops
operator|+=
name|n_cells
expr_stmt|;
else|else
comment|/* 				 * Count as number of AAL0 cells dropped 				 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal0
operator|.
name|aal0_drops
operator|+=
name|n_cells
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
comment|/* 			 * When cells have been trashed, all we have in the 			 * buffer is a descriptor word. There are no data 			 * words. Set the number of cells to zero so that 			 * we correctly skip to the next word which will 			 * be the descriptor for the next PDU. 			 */
name|n_cells
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Go issue the DMA to skip this descriptor word. 			 */
goto|goto
name|send_dma
goto|;
block|}
comment|/* 		     * Data length: number of cells * cell size 		     */
name|pdulen
operator|=
name|n_cells
operator|*
name|BYTES_PER_CELL
expr_stmt|;
comment|/* 		     * If this is an AAL5 PDU, then we need to check 		     * for the presence of any CRC errors. If there 		     * is one or more CRC errors, then we are going to 		     * drop this PDU. 		     */
if|if
condition|(
name|aal5
operator|&&
operator|(
name|pdu_descr
operator|&
name|DESCR_CRC_ERR
operator|)
condition|)
block|{
comment|/* 			 * Count the stat 			 */
name|eup
operator|->
name|eu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_pdu_crc
operator|++
expr_stmt|;
if|if
condition|(
name|evp
operator|->
name|ev_connvc
operator|->
name|cvc_vcc
condition|)
name|evp
operator|->
name|ev_connvc
operator|->
name|cvc_vcc
operator|->
name|vc_ierrors
operator|++
expr_stmt|;
comment|/* 			 * Build a DMA entry to skip the rest of this 			 * PDU. 			 */
name|dma
index|[
name|j
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
name|rdptr
operator|+
name|n_cells
operator|*
name|WORDS_PER_CELL
operator|+
literal|1
operator|)
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator|)
operator||
operator|(
name|vcc
operator|<<
name|DMA_VCC_SHIFT
operator|)
operator||
name|DMA_JK
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 			 * All done with this PDU. Get a buffer to save some 			 * data for reclamation services. 			 */
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
name|ENI_SMALL_BSIZE
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|u_long
modifier|*
name|up
decl_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|up
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
comment|/* 				 * Indicate no PDU 				 */
name|KB_PLENSET
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * Set buffer length - only driver overhead 				 */
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
comment|/* 				 * Insert vcc, space for DMA pointers, 				 * and pdulen 				 */
operator|*
name|up
operator|++
operator|=
name|vcc
expr_stmt|;
name|upp
operator|=
name|up
expr_stmt|;
comment|/* Remember location */
name|up
operator|++
expr_stmt|;
comment|/* And skip it */
comment|/* - to be filled later */
operator|*
name|up
operator|=
name|pdulen
expr_stmt|;
comment|/* Actual PDU length if it */
comment|/* were valid */
block|}
else|else
block|{
comment|/* 				 * We've a real problem here as now we can't 				 * reclaim/advance resources/safety pointers. 				 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_norsc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_do_service: No drain buffers available. Receiver about to lock.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|send_dma
goto|;
block|}
comment|/* 		     * Do we need to strip the AAL layer? Yes if this 		     * is an AAL5 PDU. 		     */
if|if
condition|(
name|aal5
condition|)
block|{
comment|/* 			 * Grab the CS-PDU length. Find the address of the 			 * last word, back up one word to skip CRC, and 			 * then mask the whole thing to handle circular wraps. 			 */
name|pdulen
operator|=
name|rxp
index|[
operator|(
name|rdptr
operator|+
name|n_cells
operator|*
name|WORDS_PER_CELL
operator|-
literal|1
operator|)
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
index|]
operator|&
literal|0xFFFF
expr_stmt|;
block|}
comment|/* 		     * We now have a valid PDU of some length. Build 		     * the necessary DMA list to move it into host 		     * memory. 		     */
comment|/* 		     * Get an initial buffer. 		     */
name|KB_ALLOCPKT
argument_list|(
name|m
argument_list|,
name|ENI_SMALL_BSIZE
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
comment|/* 		     * Do we have a valid buffer? 		     */
if|if
condition|(
name|m
operator|!=
operator|(
name|KBuffer
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|u_long
modifier|*
name|up
decl_stmt|;
name|KBuffer
modifier|*
name|m0
decl_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|up
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
comment|/* 			 * Fill in pdulen in PKTHDR structure (for IP). 			 */
name|KB_PLENSET
argument_list|(
name|m
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
comment|/* 			 * We're going to save the VCI nuber, the start 			 * and stop DMA pointers, and the PDU length at 			 * the head of the buffer. We'll pull this out 			 * later after the DMA has completed. 			 * 			 * Insert VCI number as first word in first buffer, 			 * remeber where we want to store the start/stop 			 * pointers, and store the PDU length. 			 */
operator|*
name|up
operator|++
operator|=
name|vcc
expr_stmt|;
comment|/* PDU's VCC */
name|upp
operator|=
name|up
expr_stmt|;
comment|/* Remember where we are */
name|up
operator|++
expr_stmt|;
comment|/* To stuff start/stop pointers in */
operator|*
name|up
operator|++
operator|=
name|pdulen
expr_stmt|;
comment|/* PDU's length */
comment|/* 			 * Leave some extra room in case a higher protocol 			 * (IP) wants to do a pullup. Maybe we can keep 			 * someone from having to allocate another buffer 			 * a do a larger memory copy. 			 */
name|len
operator|=
name|MIN
argument_list|(
name|ENI_SMALL_BSIZE
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|eni_set_dma
argument_list|(
name|eup
argument_list|,
literal|1
argument_list|,
name|dma
argument_list|,
name|TEMP_DMA_SIZE
argument_list|,
operator|&
name|j
argument_list|,
name|vcc
argument_list|,
operator|(
name|u_long
operator|)
name|up
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 			 * Adjust length of remaining data in PDU 			 */
name|pdulen
operator|-=
name|len
expr_stmt|;
comment|/* 			 * Set buffer length, including our overhead 			 */
name|KB_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|len
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
comment|/* 			 * Finish by moving anything which won't fit in 			 * first buffer 			 */
name|m0
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|pdulen
condition|)
block|{
name|KBuffer
modifier|*
name|m1
decl_stmt|;
name|u_long
name|data_addr
decl_stmt|;
comment|/* 				 * Get another buffer 				 */
name|KB_ALLOCEXT
argument_list|(
name|m1
argument_list|,
name|ENI_LARGE_BSIZE
argument_list|,
name|KB_F_NOWAIT
argument_list|,
name|KB_T_DATA
argument_list|)
expr_stmt|;
comment|/* 				 * If we succeeded... 				 */
if|if
condition|(
name|m1
condition|)
block|{
comment|/* 				     * Figure out how much we can move into 				     * this buffer. 				     */
name|len
operator|=
name|MIN
argument_list|(
name|ENI_LARGE_BSIZE
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
comment|/* 				     * Setup DMA list for this buffer 				     */
name|KB_DATASTART
argument_list|(
name|m1
argument_list|,
name|data_addr
argument_list|,
name|u_long
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|eni_set_dma
argument_list|(
name|eup
argument_list|,
literal|1
argument_list|,
name|dma
argument_list|,
name|TEMP_DMA_SIZE
argument_list|,
operator|&
name|j
argument_list|,
name|vcc
argument_list|,
name|data_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 				     * Adjust remaining length 				     */
name|pdulen
operator|-=
name|len
expr_stmt|;
comment|/* 				     * Set buffer length 				     */
name|KB_LEN
argument_list|(
name|m1
argument_list|)
operator|=
name|len
expr_stmt|;
comment|/* 				     * Link new buffer onto end and advance 				     * pointer 				     */
name|KB_NEXT
argument_list|(
name|m0
argument_list|)
operator|=
name|m1
expr_stmt|;
name|m0
operator|=
name|m1
expr_stmt|;
block|}
else|else
block|{
comment|/* 				     * Either we were unable to grab another 				     * buffer or there are no large buffers 				     * available. We know that the first 				     * buffer is valid, so drop everything 				     * else, build a JK DMA to skip/drop this 				     * PDU, set the pointers to reclaim 				     * resources/advance pointers, and 				     * finish this PDU now. 				     */
if|if
condition|(
name|KB_NEXT
argument_list|(
name|m
argument_list|)
condition|)
name|KB_FREEALL
argument_list|(
name|KB_NEXT
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
name|j
operator|=
literal|2
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
name|rdptr
operator|+
name|n_cells
operator|*
name|WORDS_PER_CELL
operator|+
literal|1
operator|)
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator|)
operator||
operator|(
name|vcc
operator|<<
name|DMA_VCC_SHIFT
operator|)
operator||
name|DMA_JK
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 				     * Reset PDU length to zero 				     */
name|KB_PLENSET
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				     * Count some statistics 				     */
comment|/* 				     * Count this as dropped cells 				     */
if|if
condition|(
name|aal5
condition|)
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_drops
operator|+=
name|n_cells
expr_stmt|;
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_pdu_drops
operator|++
expr_stmt|;
block|}
else|else
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal0
operator|.
name|aal0_drops
operator|+=
name|n_cells
expr_stmt|;
comment|/* 				     * Drop it 				     */
goto|goto
name|send_dma
goto|;
block|}
block|}
comment|/* 			 * If necessary, skip AAL layer 			 */
if|if
condition|(
name|aal5
condition|)
block|{
name|dma
index|[
name|j
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
name|rdptr
operator|+
name|n_cells
operator|*
name|WORDS_PER_CELL
operator|+
literal|1
operator|)
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
operator|)
operator|<<
name|DMA_COUNT_SHIFT
operator|)
operator||
operator|(
name|vcc
operator|<<
name|DMA_VCC_SHIFT
operator|)
operator||
name|DMA_JK
expr_stmt|;
name|dma
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * We failed to get an initial buffer. Since we 			 * haven't changed anything for this PDU yet and the 			 * PDU is still valid, exit now and try to service it 			 * next time around. We're not very likely to get 			 * another buffer right now anyways. 			 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_nobufs
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_do_service: No buffers available. Exiting without servicing service list.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Clear the IN_SERVICE indicator for this VCC 			 */
name|vct
operator|->
name|vci_control
operator|&=
operator|~
name|VCI_IN_SERVICE
expr_stmt|;
return|return;
block|}
name|send_dma
label|:
comment|/* 		     * Set the end bit on the last DMA for this PDU 		     */
name|dma
index|[
name|j
operator|-
literal|2
index|]
operator||=
name|DMA_END_BIT
expr_stmt|;
comment|/* 		     * Where are the current DMA pointers 		     */
name|dma_rd
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_RX_RD
index|]
expr_stmt|;
name|dma_wr
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_RX_WR
index|]
expr_stmt|;
comment|/* 		     * Check how much space is available 		     */
if|if
condition|(
name|dma_rd
operator|==
name|dma_wr
condition|)
name|dma_avail
operator|=
name|DMA_LIST_SIZE
expr_stmt|;
else|else
name|dma_avail
operator|=
operator|(
name|dma_rd
operator|+
name|DMA_LIST_SIZE
operator|-
name|dma_wr
operator|)
operator|&
operator|(
name|DMA_LIST_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 		     * Check for queue full or wrap past write okay pointer 		     */
if|if
condition|(
name|dma_avail
operator|<
name|j
operator|||
operator|(
name|dma_wr
operator|+
name|j
operator|>
name|eup
operator|->
name|eu_rxdmawr
operator|+
name|DMA_LIST_SIZE
operator|)
condition|)
block|{
comment|/* 			 * There's no room in the DMA list to insert 			 * this request. Since we haven't changed anything 			 * yet and the PDU is good, exit now and service 			 * it next time around. What we really need to do 			 * is wait for the RX list to drain and that won't 			 * happen if we keep trying to process PDUs here. 			 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_nodma
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_do_service: No room in receive DMA list. Postponing service request.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Free the local buffer chain 			 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * Clear the IN_SERVICE indicator for this VCC. 			 */
name|vct
operator|->
name|vci_control
operator|&=
operator|~
name|VCI_IN_SERVICE
expr_stmt|;
return|return;
block|}
comment|/* 		     * If we have a buffer chain, save the starting 		     * dma_list location. 		     */
if|if
condition|(
name|upp
condition|)
block|{
operator|*
name|upp
operator|=
name|dma_wr
operator|<<
literal|16
expr_stmt|;
block|}
comment|/* 		     * Stuff the DMA list 		     */
name|j
operator|>>=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
block|{
name|eup
operator|->
name|eu_rxdma
index|[
name|dma_wr
operator|*
literal|2
index|]
operator|=
name|dma
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|eup
operator|->
name|eu_rxdma
index|[
name|dma_wr
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|dma
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|dma_wr
operator|=
operator|(
name|dma_wr
operator|+
literal|1
operator|)
operator|&
operator|(
name|DMA_LIST_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 		     * If we have a buffer chain, save the location of 		     * the ending dma_list location and queue the chain 		     * so that we can recover the resources later. 		     */
if|if
condition|(
name|upp
condition|)
block|{
operator|*
name|upp
operator||=
name|dma_wr
expr_stmt|;
comment|/* 		         * Place buffer on receive queue waiting for RX_DMA 		         */
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|eup
operator|->
name|eu_rxqueue
argument_list|)
condition|)
block|{
comment|/* 			     * We haven't done anything we can't back out 			     * of. Drop request and service it next time. 			     * We've inserted the DMA list but it's not 			     * valid until we advance the RX_WR pointer, 			     * thus it's okay to bail here... 			     */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_rxq
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_do_service: RX drain queue full. Postponing servicing.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			     * Clear the IN_SERVICE indicator for this VCC. 			     */
name|vct
operator|->
name|vci_control
operator|&=
operator|~
name|VCI_IN_SERVICE
expr_stmt|;
return|return;
block|}
else|else
block|{
name|_IF_ENQUEUE
argument_list|(
operator|&
name|eup
operator|->
name|eu_rxqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 			     * Advance the RX_WR pointer to cause 			     * the adapter to work on this DMA list. 			     */
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_RX_WR
index|]
operator|=
name|dma_wr
expr_stmt|;
block|}
block|}
comment|/* 		     * Advance our notion of where the next PDU 		     * should start. 		     */
name|rdptr
operator|=
operator|(
name|rdptr
operator|+
name|n_cells
operator|*
name|WORDS_PER_CELL
operator|+
literal|1
operator|)
operator|&
operator|(
name|mask
operator|-
literal|1
operator|)
expr_stmt|;
name|evp
operator|->
name|ev_rxpos
operator|=
name|rdptr
expr_stmt|;
comment|/* 		     * Increment cells/pdu received stats. 		     */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_atm
operator|.
name|atm_rcvd
operator|+=
name|n_cells
expr_stmt|;
if|if
condition|(
name|aal5
condition|)
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_rcvd
operator|+=
name|n_cells
expr_stmt|;
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal5
operator|.
name|aal5_pdu_rcvd
operator|++
expr_stmt|;
block|}
else|else
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_aal0
operator|.
name|aal0_rcvd
operator|+=
name|n_cells
expr_stmt|;
block|}
comment|/* 		     * Continue processing PDUs on this same VCI 		     */
block|}
name|next_vcc
label|:
comment|/* 		 * Advance to next entry in the service_list. 		 */
name|eup
operator|->
name|eu_servread
operator|=
operator|(
name|eup
operator|->
name|eu_servread
operator|+
literal|1
operator|)
operator|&
name|SVC_SIZE_MASK
expr_stmt|;
comment|/* 		 * And clear the IN_SERVICE indicator for this VCC. 		 */
name|vct
operator|->
name|vci_control
operator|&=
operator|~
name|VCI_IN_SERVICE
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Drain Receive queue  *  * As we build DMA lists to move PDUs from adapter buffers into host  * buffers, we place the request on a private ifqueue so that we can  * free any resources AFTER we know they've been successfully DMAed.  * As part of the service processing, we record the PDUs start and stop  * entries in the DMA list, and prevent wrapping. When we pull the top  * entry off, we simply check that the current DMA location is outside  * this PDU and if so, it's okay to free things.  *  * Arguments:  *	eup		pointer to device unit structure  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|eni_recv_drain
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|KBuffer
modifier|*
name|m
decl_stmt|;
name|Eni_vcc
modifier|*
name|evp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|u_long
name|vcc
decl_stmt|;
name|u_long
name|DMA_Rdptr
decl_stmt|;
name|u_long
name|dma_wrp
decl_stmt|;
name|u_long
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|int
name|que
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Pop first buffer */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|eup
operator|->
name|eu_rxqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|u_long
modifier|*
name|up
decl_stmt|;
name|u_long
name|pdulen
decl_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|up
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * Grab the VCI number 		 */
name|vcc
operator|=
operator|*
name|up
operator|++
expr_stmt|;
comment|/* 		 * Check to see if we can process this buffer yet. 		 */
comment|/* Get current DMA_Rdptr */
name|DMA_Rdptr
operator|=
name|eup
operator|->
name|eu_midway
index|[
name|MIDWAY_RX_RD
index|]
expr_stmt|;
comment|/* Boundaries for first buffer */
name|dma_wrp
operator|=
operator|*
name|up
operator|++
expr_stmt|;
name|start
operator|=
name|dma_wrp
operator|>>
literal|16
expr_stmt|;
name|stop
operator|=
name|dma_wrp
operator|&
literal|0xffff
expr_stmt|;
comment|/* 		 * Start should not equal stop because that would 		 * mean we tried inserting a NULL DMA list. 		 */
if|if
condition|(
name|start
operator|>
name|stop
condition|)
block|{
comment|/* We wrapped */
if|if
condition|(
operator|!
operator|(
name|DMA_Rdptr
operator|>=
name|stop
operator|&&
name|DMA_Rdptr
operator|<
name|start
operator|)
condition|)
block|{
name|_IF_PREPEND
argument_list|(
operator|&
name|eup
operator|->
name|eu_rxqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|DMA_Rdptr
operator|<
name|stop
operator|&&
name|DMA_Rdptr
operator|>=
name|start
condition|)
block|{
name|_IF_PREPEND
argument_list|(
operator|&
name|eup
operator|->
name|eu_rxqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
block|}
comment|/* 		 * Adapter is finished with this buffer, we can 		 * continue processing it now. 		 */
comment|/* 		 * Locate incoming VCC for this PDU 		 */
name|evp
operator|=
operator|(
name|Eni_vcc
operator|*
operator|)
name|atm_dev_vcc_find
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|eup
argument_list|,
literal|0
argument_list|,
name|vcc
argument_list|,
name|VCC_IN
argument_list|)
expr_stmt|;
if|if
condition|(
name|evp
operator|==
name|NULL
condition|)
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_novcc
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|next_buffer
goto|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|eni_pdu_print
condition|)
name|atm_dev_pdu_print
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|eup
argument_list|,
operator|(
name|Cmn_vcc
operator|*
operator|)
name|evp
argument_list|,
name|m
argument_list|,
literal|"eni_stack_drain"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Grab theoretical PDU length 		 */
name|pdulen
operator|=
operator|*
name|up
operator|++
expr_stmt|;
comment|/* 		 * Quick, count the PDU 		 */
name|eup
operator|->
name|eu_pif
operator|.
name|pif_ipdus
operator|++
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_ibytes
operator|+=
name|pdulen
expr_stmt|;
if|if
condition|(
name|evp
condition|)
block|{
name|vcp
operator|=
name|evp
operator|->
name|ev_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
name|vcp
condition|)
block|{
name|vcp
operator|->
name|vc_ipdus
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_ibytes
operator|+=
name|pdulen
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
block|{
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_ibytes
operator|+=
name|pdulen
expr_stmt|;
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_if
operator|.
name|if_ibytes
operator|+=
name|pdulen
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 		 * Advance DMA write allowable pointer 		 */
name|eup
operator|->
name|eu_rxdmawr
operator|=
name|stop
expr_stmt|;
comment|/* 		 * Get packet PDU length 		 */
name|KB_PLENGET
argument_list|(
name|m
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
comment|/* 		 * Only try queueing this if there is data 		 * to be handed up to the next layer. Errors 		 * such as CRC and VC trashing will get us this 		 * far to advance pointers, etc., but the PDU 		 * length will be zero. 		 */
if|if
condition|(
name|pdulen
condition|)
block|{
comment|/* 			 * We saved three words back in eni_do_service() 			 * to use for callback. Since the core only 			 * expects two words, skip over the first one. 			 * Then, reset up pointer to start of buffer data 			 * area and write the callback info. 			 */
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|up
argument_list|,
name|u_long
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|up
operator|)
operator|=
operator|(
name|int
operator|)
name|eni_recv_stack
expr_stmt|;
name|up
operator|++
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|up
operator|)
operator|=
operator|(
name|int
operator|)
name|evp
expr_stmt|;
comment|/* 			 * Schedule callback 			 */
if|if
condition|(
name|IF_HANDOFF
argument_list|(
operator|&
name|atm_intrq
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|que
operator|++
expr_stmt|;
block|}
else|else
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_rv_intrq
operator|++
expr_stmt|;
name|eup
operator|->
name|eu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_receive_drain: ATM_INTRQ is full. Unable to pass up stack.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* 			 * Free zero-length buffer 			 */
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|next_buffer
label|:
comment|/* 		 * Look for next buffer 		 */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|eup
operator|->
name|eu_rxqueue
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|finish
label|:
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * If we found any completed buffers, schedule a call into 	 * the kernel to process the atm_intrq. 	 */
if|if
condition|(
name|que
condition|)
name|SCHED_ATM
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Pass incoming PDU up Stack  *  * This function is called via the core ATM interrupt queue callback  * set in eni_recv_drain(). It will pass the supplied incoming  * PDU up the incoming VCC's stack.  *  * Arguments:  *	tok		token to identify stack instantiation  *	m		pointer to incoming PDU buffer chain  *  * Returns:  *	none  */
end_comment

begin_function
specifier|static
name|void
name|eni_recv_stack
parameter_list|(
name|tok
parameter_list|,
name|m
parameter_list|)
name|void
modifier|*
name|tok
decl_stmt|;
name|KBuffer
modifier|*
name|m
decl_stmt|;
block|{
name|Eni_vcc
modifier|*
name|evp
init|=
operator|(
name|Eni_vcc
operator|*
operator|)
name|tok
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * This should never happen now but if it does and we don't stop it, 	 * we end up panic'ing in netatm when trying to pull a function 	 * pointer and token value out of a buffer with address zero. 	 */
if|if
condition|(
operator|!
name|m
condition|)
block|{
ifdef|#
directive|ifdef
name|DO_LOG
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eni_recv_stack: NULL buffer, tok = %p\n"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * Send the data up the stack 	 */
name|STACK_CALL
argument_list|(
name|CPCS_UNITDATA_SIG
argument_list|,
name|evp
operator|->
name|ev_upper
argument_list|,
operator|(
name|void
operator|*
operator|)
name|evp
operator|->
name|ev_toku
argument_list|,
name|evp
operator|->
name|ev_connvc
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

