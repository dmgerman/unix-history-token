begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $Id: eni_buffer.c,v 1.3 1999/04/11 02:55:51 eivind Exp $  *  */
end_comment

begin_comment
comment|/*  * Efficient ENI Adapter Support  * -----------------------------  *  * Handle adapter memory buffers for ENI adapters  *  */
end_comment

begin_include
include|#
directive|include
file|<netatm/kern_include.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_stats.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni.h>
end_include

begin_include
include|#
directive|include
file|<dev/hea/eni_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $Id: eni_buffer.c,v 1.3 1999/04/11 02:55:51 eivind Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|eni_test_memory
name|__P
argument_list|(
operator|(
name|Eni_unit
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The host is going to manage (that is, allocate and free) buffers  * in the adapters RAM space. We are going to implement this as a  * linked list describing FREE and INUSE memory segments. Initially,  * the list contains one element with all memory marked free. As requests  * are made, we search the list until we find the first free element  * which can satisfy the request. If necessary, we will break the free  * element into an INUSE element, and a new FREE element. When freeing  * memory, we look at adjacent elements and if one or more are free,  * we will combine into a single larger FREE element.  */
end_comment

begin_comment
comment|/*  * This is for testing purposes. Since there are two versions of  * the Efficient adapter with different memory sizes, this allows  * us to fool an adapter with more memory into thinking it has less.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|eni_mem_max
init|=
name|MAX_ENI_MEM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default to all available memory */
end_comment

begin_comment
comment|/*  * Size and test adapter RAM  *  * Walk through adapter RAM writing known patterns and reading back  * for comparison. We write more than one pattern on the off chance  * that we "get lucky" and read what we expected.  *  * Arguments:  *	eup		pointer to device unit structure  *  * Returns  *	size		memory size in bytes  */
end_comment

begin_function
specifier|static
name|int
name|eni_test_memory
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
name|int
name|ram_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Eni_mem
name|mp
decl_stmt|;
comment|/* 	 * Walk through to maximum looking for RAM 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ENI_MEM
condition|;
name|i
operator|+=
name|TEST_STEP
control|)
block|{
name|mp
operator|=
call|(
name|Eni_mem
call|)
argument_list|(
operator|(
name|int
operator|)
name|eup
operator|->
name|eu_ram
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* write pattern */
operator|*
name|mp
operator|=
operator|(
name|u_long
operator|)
name|TEST_PAT
expr_stmt|;
comment|/* read pattern, match? */
if|if
condition|(
operator|*
name|mp
operator|==
operator|(
name|u_long
operator|)
name|TEST_PAT
condition|)
block|{
comment|/* yes - write inverse pattern */
operator|*
name|mp
operator|=
operator|(
name|u_long
operator|)
operator|~
name|TEST_PAT
expr_stmt|;
comment|/* read pattern, match? */
if|if
condition|(
operator|*
name|mp
operator|==
operator|(
name|u_long
operator|)
operator|~
name|TEST_PAT
condition|)
block|{
comment|/* yes - assume another 1K available */
name|ram_size
operator|=
name|i
operator|+
name|TEST_STEP
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
comment|/* 	 * Clear all RAM to initial value of zero. 	 * This makes sure we don't leave anything funny in the 	 * queues. 	 */
name|KM_ZERO
argument_list|(
name|eup
operator|->
name|eu_ram
argument_list|,
name|ram_size
argument_list|)
expr_stmt|;
comment|/* 	 * If we'd like to claim to have less memory, here's where 	 * we do so. We take the minimum of what we'd like and what 	 * we really found on the adapter. 	 */
name|ram_size
operator|=
name|MIN
argument_list|(
name|ram_size
argument_list|,
name|eni_mem_max
argument_list|)
expr_stmt|;
return|return
operator|(
name|ram_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize our memory allocator.  *  * Arguments:  *	eup		Pointer to per unit structure  *  * Returns:  *	size		Physical RAM size  *	-1		failed to initialize memory  *  */
end_comment

begin_function
name|int
name|eni_init_memory
parameter_list|(
name|eup
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
block|{
comment|/* 	 * Have we (somehow) been called before? 	 */
if|if
condition|(
name|eup
operator|->
name|eu_memmap
operator|!=
name|NULL
condition|)
block|{
comment|/* Oops  - it's already been initialized */
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Allocate initial element which will hold all of memory 	 */
if|if
condition|(
operator|(
name|eup
operator|->
name|eu_memmap
operator|=
operator|(
name|Mbd
operator|*
operator|)
name|KM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Mbd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Memory allocation error */
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * Test and size memory 	 */
name|eup
operator|->
name|eu_ramsize
operator|=
name|eni_test_memory
argument_list|(
name|eup
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize a one element list which contains 	 * all buffer memory 	 */
name|eup
operator|->
name|eu_memmap
operator|->
name|prev
operator|=
name|eup
operator|->
name|eu_memmap
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|eup
operator|->
name|eu_memmap
operator|->
name|base
operator|=
operator|(
name|caddr_t
operator|)
name|SEGBUF_BASE
expr_stmt|;
name|eup
operator|->
name|eu_memmap
operator|->
name|size
operator|=
name|eup
operator|->
name|eu_ramsize
operator|-
name|SEGBUF_BASE
expr_stmt|;
name|eup
operator|->
name|eu_memmap
operator|->
name|state
operator|=
name|MEM_FREE
expr_stmt|;
return|return
operator|(
name|eup
operator|->
name|eu_ramsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a buffer from adapter RAM. Due to constraints on the card,  * we may roundup the size request to the next largest chunksize. Note  * also that we must pay attention to address alignment within adapter  * memory as well.  *  * Arguments:  *	eup		pointer to per unit structure  *	size		pointer to requested size - in bytes  *  * Returns:  *	addr		address relative to adapter of allocated memory  *	size		modified to reflect actual size of buffer  *  */
end_comment

begin_function
name|caddr_t
name|eni_allocate_buffer
parameter_list|(
name|eup
parameter_list|,
name|size
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
name|u_long
modifier|*
name|size
decl_stmt|;
block|{
name|int
name|nsize
decl_stmt|;
name|int
name|nclicks
decl_stmt|;
name|Mbd
modifier|*
name|eptr
init|=
name|eup
operator|->
name|eu_memmap
decl_stmt|;
comment|/* 	 * Initial size requested 	 */
name|nsize
operator|=
operator|*
name|size
expr_stmt|;
comment|/* 	 * Find the buffer size which will hold this request. There 	 * are 8 possible sizes, each a power of two up, starting at 	 * 256 words or 1024 bytes. 	 */
for|for
control|(
name|nclicks
operator|=
literal|0
init|;
name|nclicks
operator|<
name|ENI_BUF_NBIT
condition|;
name|nclicks
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|nclicks
operator|)
operator|*
name|ENI_BUF_PGSZ
operator|>=
name|nsize
condition|)
break|break;
comment|/* 	 * Request was for larger then the card supports 	 */
if|if
condition|(
name|nclicks
operator|>=
name|ENI_BUF_NBIT
condition|)
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_mm_toobig
operator|++
expr_stmt|;
comment|/* Indicate 0 bytes allocated */
operator|*
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Return NULL buffer */
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* 	 * New size will be buffer size 	 */
name|nsize
operator|=
operator|(
literal|1
operator|<<
name|nclicks
operator|)
operator|*
name|ENI_BUF_PGSZ
expr_stmt|;
comment|/* 	 * Look through memory for a segment large enough to 	 * hold request 	 */
while|while
condition|(
name|eptr
condition|)
block|{
comment|/* 	     * State must be FREE and size must hold request 	     */
if|if
condition|(
name|eptr
operator|->
name|state
operator|==
name|MEM_FREE
operator|&&
name|eptr
operator|->
name|size
operator|>=
name|nsize
condition|)
block|{
comment|/* 		 * Request will fit - now check if the 		 * alignment needs fixing 		 */
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|eptr
operator|->
name|base
operator|&
operator|(
name|nsize
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|caddr_t
name|nbase
decl_stmt|;
comment|/* 		     * Calculate where the buffer would have to 		     * fall to be aligned. 		     */
name|nbase
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|eptr
operator|->
name|base
operator|+
name|nsize
argument_list|)
operator|&
operator|~
operator|(
name|nsize
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 		     * If we use this alignment, will it still fit? 		     */
if|if
condition|(
operator|(
name|eptr
operator|->
name|size
operator|-
operator|(
name|nbase
operator|-
name|eptr
operator|->
name|base
operator|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|Mbd
modifier|*
name|etmp
decl_stmt|;
comment|/* Yep - create a new segment */
name|etmp
operator|=
operator|(
name|Mbd
operator|*
operator|)
name|KM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Mbd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|etmp
operator|==
operator|(
name|Mbd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 				 * Couldn't allocate a new descriptor. Indicate  				 * failure and exit now or we'll start losing 				 * memory. 				 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_mm_nodesc
operator|++
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Place it in the list */
name|etmp
operator|->
name|next
operator|=
name|eptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|etmp
operator|->
name|next
condition|)
name|etmp
operator|->
name|next
operator|->
name|prev
operator|=
name|etmp
expr_stmt|;
name|etmp
operator|->
name|prev
operator|=
name|eptr
expr_stmt|;
name|eptr
operator|->
name|next
operator|=
name|etmp
expr_stmt|;
comment|/* Fill in new base and size */
name|etmp
operator|->
name|base
operator|=
name|nbase
expr_stmt|;
name|etmp
operator|->
name|size
operator|=
name|eptr
operator|->
name|size
operator|-
operator|(
name|nbase
operator|-
name|eptr
operator|->
name|base
operator|)
expr_stmt|;
comment|/* Adjust old size */
name|eptr
operator|->
name|size
operator|-=
name|etmp
operator|->
name|size
expr_stmt|;
comment|/* Mark its state */
name|etmp
operator|->
name|state
operator|=
name|MEM_FREE
expr_stmt|;
name|eptr
operator|=
name|etmp
expr_stmt|;
comment|/* Done - outa here */
break|break;
block|}
block|}
else|else
break|break;
comment|/* Alignment is okay  - we're done */
block|}
comment|/* Haven't found anything yet - keep looking */
name|eptr
operator|=
name|eptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|eptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a usable segment - grab what we need */
comment|/* Exact fit? */
if|if
condition|(
name|eptr
operator|->
name|size
operator|==
name|nsize
condition|)
comment|/* Mark it as INUSE */
name|eptr
operator|->
name|state
operator|=
name|MEM_INUSE
expr_stmt|;
else|else
block|{
name|Mbd
modifier|*
name|etmp
decl_stmt|;
comment|/* larger then we need - split it */
name|etmp
operator|=
operator|(
name|Mbd
operator|*
operator|)
name|KM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Mbd
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|etmp
operator|==
operator|(
name|Mbd
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 			 * Couldn't allocate new descriptor. Indicate 			 * failure and exit now or we'll start losing 			 * memory. 			 */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_mm_nodesc
operator|++
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Place new element in list */
name|etmp
operator|->
name|next
operator|=
name|eptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|etmp
operator|->
name|next
condition|)
name|etmp
operator|->
name|next
operator|->
name|prev
operator|=
name|etmp
expr_stmt|;
name|etmp
operator|->
name|prev
operator|=
name|eptr
expr_stmt|;
name|eptr
operator|->
name|next
operator|=
name|etmp
expr_stmt|;
comment|/* Set new base, size and state */
name|etmp
operator|->
name|base
operator|=
name|eptr
operator|->
name|base
operator|+
name|nsize
expr_stmt|;
name|etmp
operator|->
name|size
operator|=
name|eptr
operator|->
name|size
operator|-
name|nsize
expr_stmt|;
name|etmp
operator|->
name|state
operator|=
name|MEM_FREE
expr_stmt|;
comment|/* Adjust size and state of element we intend to use */
name|eptr
operator|->
name|size
operator|=
name|nsize
expr_stmt|;
name|eptr
operator|->
name|state
operator|=
name|MEM_INUSE
expr_stmt|;
block|}
block|}
comment|/* After all that, did we find a usable buffer? */
if|if
condition|(
name|eptr
condition|)
block|{
comment|/* Record another inuse buffer of this size */
if|if
condition|(
name|eptr
operator|->
name|base
condition|)
name|eup
operator|->
name|eu_memclicks
index|[
name|nclicks
index|]
operator|++
expr_stmt|;
comment|/* 		 * Return true size of allocated buffer 		 */
operator|*
name|size
operator|=
name|eptr
operator|->
name|size
expr_stmt|;
comment|/* 		 * Make address relative to start of RAM since 		 * its (the address) for use by the adapter, not 		 * the host. 		 */
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|eptr
operator|->
name|base
operator|)
return|;
block|}
else|else
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_mm_nobuf
operator|++
expr_stmt|;
comment|/* No buffer to return - indicate zero length */
operator|*
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Return NULL buffer */
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Procedure to release a buffer previously allocated from adapter  * RAM. When possible, we'll compact memory.  *  * Arguments:  *	eup		pointer to per unit structure  *	base		base adapter address of buffer to be freed  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|eni_free_buffer
parameter_list|(
name|eup
parameter_list|,
name|base
parameter_list|)
name|Eni_unit
modifier|*
name|eup
decl_stmt|;
name|caddr_t
name|base
decl_stmt|;
block|{
name|Mbd
modifier|*
name|eptr
init|=
name|eup
operator|->
name|eu_memmap
decl_stmt|;
name|int
name|nclicks
decl_stmt|;
comment|/* Look through entire list */
while|while
condition|(
name|eptr
condition|)
block|{
comment|/* Is this the buffer to be freed? */
if|if
condition|(
name|eptr
operator|->
name|base
operator|==
name|base
condition|)
block|{
comment|/* 			 * We're probably asking for trouble but, 			 * assume this is it. 			 */
if|if
condition|(
name|eptr
operator|->
name|state
operator|!=
name|MEM_INUSE
condition|)
block|{
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_mm_notuse
operator|++
expr_stmt|;
comment|/* Huh? Something's wrong */
return|return;
block|}
comment|/* Reset state to FREE */
name|eptr
operator|->
name|state
operator|=
name|MEM_FREE
expr_stmt|;
comment|/* Determine size for stats info */
for|for
control|(
name|nclicks
operator|=
literal|0
init|;
name|nclicks
operator|<
name|ENI_BUF_NBIT
condition|;
name|nclicks
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|nclicks
operator|)
operator|*
name|ENI_BUF_PGSZ
operator|==
name|eptr
operator|->
name|size
condition|)
break|break;
comment|/* Valid size? Yes - decrement inuse count */
if|if
condition|(
name|nclicks
operator|<
name|ENI_BUF_NBIT
condition|)
name|eup
operator|->
name|eu_memclicks
index|[
name|nclicks
index|]
operator|--
expr_stmt|;
comment|/* Try to compact neighbors */
comment|/* with previous */
if|if
condition|(
name|eptr
operator|->
name|prev
condition|)
if|if
condition|(
name|eptr
operator|->
name|prev
operator|->
name|state
operator|==
name|MEM_FREE
condition|)
block|{
name|Mbd
modifier|*
name|etmp
init|=
name|eptr
decl_stmt|;
comment|/* Add to previous block */
name|eptr
operator|->
name|prev
operator|->
name|size
operator|+=
name|eptr
operator|->
name|size
expr_stmt|;
comment|/* Set prev block to skip this one */
name|eptr
operator|->
name|prev
operator|->
name|next
operator|=
name|eptr
operator|->
name|next
expr_stmt|;
comment|/* Set next block to skip this one */
if|if
condition|(
name|eptr
operator|->
name|next
condition|)
name|eptr
operator|->
name|next
operator|->
name|prev
operator|=
name|eptr
operator|->
name|prev
expr_stmt|;
comment|/* Reset to where we want to be */
name|eptr
operator|=
name|eptr
operator|->
name|prev
expr_stmt|;
comment|/* and free this element */
operator|(
name|void
operator|)
name|KM_FREE
argument_list|(
name|etmp
argument_list|,
name|etmp
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* with next */
if|if
condition|(
name|eptr
operator|->
name|next
condition|)
if|if
condition|(
name|eptr
operator|->
name|next
operator|->
name|state
operator|==
name|MEM_FREE
condition|)
block|{
name|Mbd
modifier|*
name|etmp
init|=
name|eptr
operator|->
name|next
decl_stmt|;
comment|/* add following block in */
name|eptr
operator|->
name|size
operator|+=
name|etmp
operator|->
name|size
expr_stmt|;
comment|/* set next next block to skip next block */
if|if
condition|(
name|etmp
operator|->
name|next
condition|)
name|etmp
operator|->
name|next
operator|->
name|prev
operator|=
name|eptr
expr_stmt|;
comment|/* skip next block */
name|eptr
operator|->
name|next
operator|=
name|etmp
operator|->
name|next
expr_stmt|;
comment|/* and free next element */
operator|(
name|void
operator|)
name|KM_FREE
argument_list|(
name|etmp
argument_list|,
name|etmp
operator|->
name|size
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We've freed the buffer and done any compaction, 			 * we needn't look any further... 			 */
return|return;
block|}
name|eptr
operator|=
name|eptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|eptr
operator|==
name|NULL
condition|)
block|{
comment|/* Oops - failed to find the buffer. This is BAD */
name|eup
operator|->
name|eu_stats
operator|.
name|eni_st_drv
operator|.
name|drv_mm_notfnd
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

