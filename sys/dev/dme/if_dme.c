begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2015 Alexander Kabaev  * Copyright (C) 2010 Andrew Turner  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* A driver for the Davicom DM9000 MAC. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/dme/if_dmereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/dme/if_dmevar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/regulator/regulator.h>
end_include

begin_include
include|#
directive|include
file|<dev/gpio/gpiobusvar.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_struct
struct|struct
name|dme_softc
block|{
name|struct
name|ifnet
modifier|*
name|dme_ifp
decl_stmt|;
name|device_t
name|dme_dev
decl_stmt|;
name|device_t
name|dme_miibus
decl_stmt|;
name|bus_space_handle_t
name|dme_handle
decl_stmt|;
name|bus_space_tag_t
name|dme_tag
decl_stmt|;
name|int
name|dme_rev
decl_stmt|;
name|int
name|dme_bits
decl_stmt|;
name|struct
name|resource
modifier|*
name|dme_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|dme_irq
decl_stmt|;
name|void
modifier|*
name|dme_intrhand
decl_stmt|;
name|struct
name|mtx
name|dme_mtx
decl_stmt|;
name|struct
name|callout
name|dme_tick_ch
decl_stmt|;
name|struct
name|gpiobus_pin
modifier|*
name|gpio_rset
decl_stmt|;
name|uint32_t
name|dme_ticks
decl_stmt|;
name|uint8_t
name|dme_macaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|regulator_t
name|dme_vcc_regulator
decl_stmt|;
name|uint8_t
name|dme_txbusy
range|:
literal|1
decl_stmt|;
name|uint8_t
name|dme_txready
range|:
literal|1
decl_stmt|;
name|uint16_t
name|dme_txlen
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DME_CHIP_DM9000
value|0x00
end_define

begin_define
define|#
directive|define
name|DME_CHIP_DM9000A
value|0x19
end_define

begin_define
define|#
directive|define
name|DME_CHIP_DM9000B
value|0x1a
end_define

begin_define
define|#
directive|define
name|DME_INT_PHY
value|1
end_define

begin_function_decl
specifier|static
name|int
name|dme_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dme_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dme_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dme_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dme_init_locked
parameter_list|(
name|struct
name|dme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dme_prepare
parameter_list|(
name|struct
name|dme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dme_transmit
parameter_list|(
name|struct
name|dme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dme_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dme_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The bit on the address bus attached to the CMD pin */
end_comment

begin_define
define|#
directive|define
name|BASE_ADDR
value|0x000
end_define

begin_define
define|#
directive|define
name|CMD_ADDR
value|BASE_ADDR
end_define

begin_define
define|#
directive|define
name|DATA_BIT
value|1
end_define

begin_define
define|#
directive|define
name|DATA_ADDR
value|0x002
end_define

begin_undef
undef|#
directive|undef
name|DME_TRACE
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|DME_TRACE
end_ifdef

begin_define
define|#
directive|define
name|DTR3
value|TR3
end_define

begin_define
define|#
directive|define
name|DTR4
value|TR4
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NOTR
parameter_list|(
name|args
modifier|...
parameter_list|)
value|(void)0
end_define

begin_define
define|#
directive|define
name|DTR3
value|NOTR
end_define

begin_define
define|#
directive|define
name|DTR4
value|NOTR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint8_t
name|dme_read_reg
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|)
block|{
comment|/* Send the register to read from */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|CMD_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|CMD_ADDR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
comment|/* Get the value of the register */
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_write_reg
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|value
parameter_list|)
block|{
comment|/* Send the register to write to */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|CMD_ADDR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|CMD_ADDR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
comment|/* Write the value to the register */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_reset
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|ncr
decl_stmt|;
comment|/* Send a soft reset #1 */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_NCR
argument_list|,
name|NCR_RST
operator||
name|NCR_LBK_MAC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Wait for the MAC to reset */
name|ncr
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_NCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncr
operator|&
name|NCR_RST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dme_dev
argument_list|,
literal|"device did not complete first reset\n"
argument_list|)
expr_stmt|;
comment|/* Send a soft reset #2 per Application Notes v1.22 */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_NCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_NCR
argument_list|,
name|NCR_RST
operator||
name|NCR_LBK_MAC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Wait for the MAC to reset */
name|ncr
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_NCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncr
operator|&
name|NCR_RST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dme_dev
argument_list|,
literal|"device did not complete second reset\n"
argument_list|)
expr_stmt|;
comment|/* Reset trasmit state */
name|sc
operator|->
name|dme_txbusy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dme_txready
operator|=
literal|0
expr_stmt|;
name|DTR3
argument_list|(
literal|"dme_reset, flags %#x busy %d ready %d"
argument_list|,
name|sc
operator|->
name|dme_ifp
condition|?
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
else|:
literal|0
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse string MAC address into usable form  */
end_comment

begin_function
specifier|static
name|int
name|dme_parse_macaddr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint8_t
modifier|*
name|mac
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|int
name|amac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* Aligned version */
name|count
operator|=
name|sscanf
argument_list|(
name|str
argument_list|,
literal|"%x%*c%x%*c%x%*c%x%*c%x%*c%x"
argument_list|,
operator|&
name|amac
index|[
literal|0
index|]
argument_list|,
operator|&
name|amac
index|[
literal|1
index|]
argument_list|,
operator|&
name|amac
index|[
literal|2
index|]
argument_list|,
operator|&
name|amac
index|[
literal|3
index|]
argument_list|,
operator|&
name|amac
index|[
literal|4
index|]
argument_list|,
operator|&
name|amac
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|ETHER_ADDR_LEN
condition|)
block|{
name|memset
argument_list|(
name|mac
argument_list|,
literal|0
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Copy aligned to result */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|mac
index|[
name|i
index|]
operator|=
operator|(
name|amac
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to determine our own MAC address  */
end_comment

begin_function
specifier|static
name|void
name|dme_get_macaddr
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|char
name|devid_str
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Cannot use resource_string_value with static hints mode */
name|snprintf
argument_list|(
name|devid_str
argument_list|,
literal|32
argument_list|,
literal|"hint.%s.%d.macaddr"
argument_list|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|dme_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dme_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try resource hints */
if|if
condition|(
operator|(
name|var
operator|=
name|kern_getenv
argument_list|(
name|devid_str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dme_parse_macaddr
argument_list|(
name|var
argument_list|,
name|sc
operator|->
name|dme_macaddr
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dme_dev
argument_list|,
literal|"MAC address: %s (hints)\n"
argument_list|,
name|var
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Try to read MAC address from the device, in case U-Boot has 	 * pre-programmed one for us. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|dme_macaddr
index|[
name|i
index|]
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_PAR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dme_dev
argument_list|,
literal|"MAC address %6D (existing)\n"
argument_list|,
name|sc
operator|->
name|dme_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_config
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Mask all interrupts and reset receive pointer */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_IMR
argument_list|,
name|IMR_PAR
argument_list|)
expr_stmt|;
comment|/* Disable GPIO0 to enable the internal PHY */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_GPCR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_GPR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Supposedly requires special initialization for DSP PHYs 	 * used by DM9000B. Maybe belongs in dedicated PHY driver? 	 */
block|if (sc->dme_rev == DME_CHIP_DM9000B) { 		dme_miibus_writereg(sc->dme_dev, DME_INT_PHY, MII_BMCR, 		    BMCR_RESET); 		dme_miibus_writereg(sc->dme_dev, DME_INT_PHY, MII_DME_DSPCR, 		    DSPCR_INIT);
comment|/* Wait 100ms for it to complete. */
block|for (i = 0; i< 100; i++) { 			int reg;  			reg = dme_miibus_readreg(sc->dme_dev, DME_INT_PHY, MII_BMCR); 			if ((reg& BMCR_RESET) == 0) 				break; 			DELAY(1000); 		} 	}
endif|#
directive|endif
comment|/* Select the internal PHY and normal loopback */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_NCR
argument_list|,
name|NCR_LBK_NORMAL
argument_list|)
expr_stmt|;
comment|/* Clear any TX requests */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup backpressure thresholds to 4k and 600us */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_BPTR
argument_list|,
name|BPTR_BPHW
argument_list|(
literal|3
argument_list|)
operator||
name|BPTR_JPT
argument_list|(
literal|0x0f
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup flow control */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_FCTR
argument_list|,
name|FCTR_HWOT
argument_list|(
literal|0x3
argument_list|)
operator||
name|FCTR_LWOT
argument_list|(
literal|0x08
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable flow control */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_FCR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Clear special modes */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_SMCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear TX status */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_NSR
argument_list|,
name|NSR_WAKEST
operator||
name|NSR_TX2END
operator||
name|NSR_TX1END
argument_list|)
expr_stmt|;
comment|/* Clear interrrupts */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set multicast address filter */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_MAR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set the MAC address */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_PAR
argument_list|(
name|i
argument_list|)
argument_list|,
name|sc
operator|->
name|dme_macaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Enable the RX buffer */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_RCR
argument_list|,
name|RCR_DIS_LONG
operator||
name|RCR_DIS_CRC
operator||
name|RCR_RXEN
argument_list|)
expr_stmt|;
comment|/* Enable interrupts we care about */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_IMR
argument_list|,
name|IMR_PAR
operator||
name|IMR_PRI
operator||
name|IMR_PTI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dme_prepare
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|uint16_t
name|total_len
decl_stmt|,
name|len
decl_stmt|;
name|DME_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|dme_txready
operator|==
literal|0
argument_list|,
operator|(
literal|"dme_prepare: called with txready set\n"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|dme_ifp
expr_stmt|;
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|DTR3
argument_list|(
literal|"dme_prepare none, flags %#x busy %d ready %d"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|)
expr_stmt|;
return|return;
comment|/* Nothing to transmit */
block|}
comment|/* Element has now been removed from the queue, so we better send it */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Setup the controller to accept the writes */
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|CMD_ADDR
argument_list|,
name|DME_MWCMD
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: Fix the case where an mbuf is 	 * not a multiple of the write size. 	 */
name|total_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
comment|/* Ignore empty parts */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
name|total_len
operator|+=
name|len
expr_stmt|;
if|#
directive|if
literal|0
block|bus_space_write_multi_2(sc->dme_tag, sc->dme_handle, 		    DATA_ADDR, mtod(mp, uint16_t *), (len + 1) / 2);
else|#
directive|else
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|total_len
operator|%
operator|(
name|sc
operator|->
name|dme_bits
operator|>>
literal|3
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"dme_prepare: length is not compatible with IO_MODE"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dme_txlen
operator|=
name|total_len
expr_stmt|;
name|sc
operator|->
name|dme_txready
operator|=
literal|1
expr_stmt|;
name|DTR3
argument_list|(
literal|"dme_prepare done, flags %#x busy %d ready %d"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dme_transmit
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DME_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|dme_txready
argument_list|,
operator|(
literal|"transmit without txready"
operator|)
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_TXPLL
argument_list|,
name|sc
operator|->
name|dme_txlen
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_TXPLH
argument_list|,
operator|(
name|sc
operator|->
name|dme_txlen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Request to send the packet */
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_ISR
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_TCR
argument_list|,
name|TCR_TXREQ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dme_txready
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dme_txbusy
operator|=
literal|1
expr_stmt|;
name|DTR3
argument_list|(
literal|"dme_transmit done, flags %#x busy %d ready %d"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DME_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
name|DTR3
argument_list|(
literal|"dme_start, flags %#x busy %d ready %d"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|dme_txbusy
operator|==
literal|0
operator|||
name|sc
operator|->
name|dme_txready
operator|==
literal|0
argument_list|,
operator|(
literal|"dme: send without empty queue\n"
operator|)
argument_list|)
expr_stmt|;
name|dme_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_txbusy
operator|==
literal|0
condition|)
block|{
comment|/* We are ready to transmit right away */
name|dme_transmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dme_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare next one */
block|}
comment|/* 	 * We need to wait until the current packet has 	 * been transmitted. 	 */
if|if
condition|(
name|sc
operator|->
name|dme_txready
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dme_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_stop
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|DME_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable receiver */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_RCR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Mask interrupts */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_IMR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Stop poll */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|dme_tick_ch
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|dme_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|DTR3
argument_list|(
literal|"dme_stop, flags %#x busy %d ready %d"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dme_txbusy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dme_txready
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dme_rxeof
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|DME_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|dme_ifp
expr_stmt|;
comment|/* Read the first byte to check it correct */
operator|(
name|void
operator|)
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_MRCMDX
argument_list|)
expr_stmt|;
name|i
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* Correct value */
break|break;
case|case
literal|0
case|:
return|return
literal|1
return|;
default|default:
comment|/* Error */
return|return
operator|-
literal|1
return|;
block|}
name|i
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_MRRL
argument_list|)
expr_stmt|;
name|i
operator||=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_MRRH
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|len
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_ROCR
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|CMD_ADDR
argument_list|,
name|DME_MRCMD
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|dme_bits
condition|)
block|{
case|case
literal|8
case|:
name|i
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
name|i
operator|<<=
literal|8
expr_stmt|;
name|i
operator||=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
name|len
operator|=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
name|len
operator||=
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
name|len
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|)
expr_stmt|;
name|len
operator|=
name|reg
operator|&
literal|0xFFFF
expr_stmt|;
break|break;
block|}
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|len
operator|>
name|MHLEN
operator|-
name|ETHER_ALIGN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
comment|/* Read the data */
if|#
directive|if
literal|0
block|bus_space_read_multi_2(sc->dme_tag, sc->dme_handle, DATA_ADDR, 	    mtod(m, uint16_t *), (len + 1) / 2);
else|#
directive|else
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|dme_tag
argument_list|,
name|sc
operator|->
name|dme_handle
argument_list|,
name|DATA_ADDR
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|dme_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Probably too frequent? */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|dme_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|dme_tick_ch
argument_list|,
name|hz
argument_list|,
name|dme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|intr_status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|dme_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|intr_status
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_ISR
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_ISR
argument_list|,
name|intr_status
argument_list|)
expr_stmt|;
name|DTR4
argument_list|(
literal|"dme_intr flags %#x busy %d ready %d intr %#x"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|,
name|intr_status
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_status
operator|&
name|ISR_PT
condition|)
block|{
name|uint8_t
name|nsr
decl_stmt|,
name|tx_status
decl_stmt|;
name|sc
operator|->
name|dme_txbusy
operator|=
literal|0
expr_stmt|;
name|nsr
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_NSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsr
operator|&
name|NSR_TX1END
condition|)
name|tx_status
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_TSR1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nsr
operator|&
name|NSR_TX2END
condition|)
name|tx_status
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_TSR2
argument_list|)
expr_stmt|;
else|else
name|tx_status
operator|=
literal|1
expr_stmt|;
name|DTR4
argument_list|(
literal|"dme_intr flags %#x busy %d ready %d nsr %#x"
argument_list|,
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
argument_list|,
name|sc
operator|->
name|dme_txbusy
argument_list|,
name|sc
operator|->
name|dme_txready
argument_list|,
name|nsr
argument_list|)
expr_stmt|;
comment|/* Prepare packet to send if none is currently pending */
if|if
condition|(
name|sc
operator|->
name|dme_txready
operator|==
literal|0
condition|)
name|dme_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Send the packet out of one is waiting for transmit */
if|if
condition|(
name|sc
operator|->
name|dme_txready
operator|!=
literal|0
condition|)
block|{
comment|/* Initiate transmission of the prepared packet */
name|dme_transmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Prepare next packet to send */
name|dme_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * We need to wait until the current packet has 			 * been transmitted. 			 */
if|if
condition|(
name|sc
operator|->
name|dme_txready
operator|!=
literal|0
condition|)
name|sc
operator|->
name|dme_ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intr_status
operator|&
name|ISR_PR
condition|)
block|{
comment|/* Read the packets off the device */
while|while
condition|(
name|dme_rxeof
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_setmode
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|dme_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * Switch interface state between "running" and 		 * "stopped", reflecting the UP flag. 		 */
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|dme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|dme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|dme_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|dme_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_init_locked
parameter_list|(
name|struct
name|dme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|dme_ifp
decl_stmt|;
name|DME_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
name|dme_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dme_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|dme_tick_ch
argument_list|,
name|hz
argument_list|,
name|dme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_init
parameter_list|(
name|void
modifier|*
name|xcs
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
init|=
name|xcs
decl_stmt|;
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dme_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|dme_miibus
argument_list|)
expr_stmt|;
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dme_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|dme_miibus
argument_list|)
expr_stmt|;
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"davicom,dm9000"
block|,
name|true
block|}
block|,
block|{
name|NULL
block|,
name|false
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dme_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Davicom DM9000"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dme_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|uint32_t
name|data
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dme_dev
operator|=
name|dev
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|dme_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|dme_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|dme_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dme_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|dme_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Power the chip up, if necessary 	 */
name|error
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"vcc-supply"
argument_list|,
operator|&
name|sc
operator|->
name|dme_vcc_regulator
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|dme_vcc_regulator
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to enable power supply\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Delay a little.  This seems required on rev-1 boards (green.) 	 */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Bring controller out of reset */
name|error
operator|=
name|ofw_gpiobus_parse_gpios
argument_list|(
name|dev
argument_list|,
literal|"reset-gpios"
argument_list|,
operator|&
name|sc
operator|->
name|gpio_rset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"too many reset gpios\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gpio_rset
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|gpio_rset
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|GPIO_PIN_SET
argument_list|(
name|sc
operator|->
name|gpio_rset
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|gpio_rset
operator|->
name|pin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot configure GPIO pin %d on %s\n"
argument_list|,
name|sc
operator|->
name|gpio_rset
operator|->
name|pin
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|gpio_rset
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|GPIO_PIN_SETFLAGS
argument_list|(
name|sc
operator|->
name|gpio_rset
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|gpio_rset
operator|->
name|pin
argument_list|,
name|GPIO_PIN_OUTPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot configure GPIO pin %d on %s\n"
argument_list|,
name|sc
operator|->
name|gpio_rset
operator|->
name|pin
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|gpio_rset
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
name|error
operator|=
name|GPIO_PIN_SET
argument_list|(
name|sc
operator|->
name|gpio_rset
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|gpio_rset
operator|->
name|pin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot configure GPIO pin %d on %s\n"
argument_list|,
name|sc
operator|->
name|gpio_rset
operator|->
name|pin
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|gpio_rset
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DELAY
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to find reset GPIO\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dme_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|dme_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dme_handle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|dme_res
argument_list|)
expr_stmt|;
comment|/* Reset the chip as soon as possible */
name|dme_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Figure IO mode */
switch|switch
condition|(
operator|(
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_ISR
argument_list|)
operator|>>
literal|6
operator|)
operator|&
literal|0x03
condition|)
block|{
case|case
literal|0
case|:
comment|/* 16 bit */
name|sc
operator|->
name|dme_bits
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 32 bit */
name|sc
operator|->
name|dme_bits
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 8 bit */
name|sc
operator|->
name|dme_bits
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
comment|/* reserved */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to determine device mode\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
comment|/* Read vendor and device id's */
name|data
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_VIDH
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|data
operator||=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_VIDL
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vendor ID: 0x%04x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Read vendor and device id's */
name|data
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_PIDH
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|data
operator||=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_PIDL
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Product ID: 0x%04x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Chip revision */
name|data
operator|=
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_CHIPR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Revision: 0x%04x\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|DME_CHIP_DM9000A
operator|&&
name|data
operator|!=
name|DME_CHIP_DM9000B
condition|)
name|data
operator|=
name|DME_CHIP_DM9000
expr_stmt|;
name|sc
operator|->
name|dme_rev
operator|=
name|data
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %d-bit IO mode\n"
argument_list|,
name|sc
operator|->
name|dme_bits
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|dme_bits
operator|==
literal|8
argument_list|,
operator|(
literal|"wrong io mode"
operator|)
argument_list|)
expr_stmt|;
comment|/* Try to figure our mac address */
name|dme_get_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure chip after reset */
name|dme_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|dme_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate ifp\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
comment|/* Setup MII */
name|error
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|dme_miibus
argument_list|,
name|ifp
argument_list|,
name|dme_ifmedia_upd
argument_list|,
name|dme_ifmedia_sts
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This should never happen as the DM9000 contains it's own PHY */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY probe failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|dme_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|dme_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|dme_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|dme_macaddr
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dme_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|dme_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|dme_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't set up irq\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|dme_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dme_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|dme_mtx
argument_list|)
argument_list|,
operator|(
literal|"dme mutex not initialized"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|dme_ifp
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|DME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|dme_tick_ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|dme_miibus
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dme_miibus
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_vcc_regulator
operator|!=
literal|0
condition|)
name|regulator_release
argument_list|(
name|sc
operator|->
name|dme_vcc_regulator
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|dme_irq
argument_list|,
name|sc
operator|->
name|dme_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|dme_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dme_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|dme_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|dme_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The MII bus interface  */
end_comment

begin_function
specifier|static
name|int
name|dme_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|;
comment|/* We have up to 4 PHY's */
if|if
condition|(
name|phy
operator|>=
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Send the register to read to the phy and start the read */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPAR
argument_list|,
operator|(
name|phy
operator|<<
literal|6
operator|)
operator||
name|reg
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPCR
argument_list|,
name|EPCR_EPOS
operator||
name|EPCR_ERPRR
argument_list|)
expr_stmt|;
comment|/* Wait for the data to be read */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DME_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPCR
argument_list|)
operator|&
name|EPCR_ERRE
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the comand */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DME_TIMEOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rval
operator|=
operator|(
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPDRH
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPDRL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dme_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|struct
name|dme_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We have up to 4 PHY's */
if|if
condition|(
name|phy
operator|>
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Send the register and data to write to the phy */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPAR
argument_list|,
operator|(
name|phy
operator|<<
literal|6
operator|)
operator||
name|reg
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPDRL
argument_list|,
name|data
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPDRH
argument_list|,
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Start the write */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPCR
argument_list|,
name|EPCR_EPOS
operator||
name|EPCR_ERPRW
argument_list|)
expr_stmt|;
comment|/* Wait for the data to be written */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DME_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dme_read_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPCR
argument_list|)
operator|&
name|EPCR_ERRE
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the comand */
name|dme_write_reg
argument_list|(
name|sc
argument_list|,
name|DME_EPCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|dme_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|dme_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|dme_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|dme_detach
argument_list|)
block|,
comment|/* bus interface, for miibus */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|dme_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|dme_miibus_writereg
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|dme_driver
init|=
block|{
literal|"dme"
block|,
name|dme_methods
block|,
expr|sizeof
operator|(
expr|struct
name|dme_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|dme_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|dme
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|dme
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|dme
argument_list|,
name|simplebus
argument_list|,
name|dme_driver
argument_list|,
name|dme_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|dme
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

