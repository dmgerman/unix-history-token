begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Jonathan Lemon  * Copyright (c) 1999 by Matthew N. Dodd<winter@jurai.net>  * All Rights Reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/ida/idavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ida/idareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/eisa/eisaconf.h>
end_include

begin_define
define|#
directive|define
name|IDA_EISA_IOPORT_START
value|0x0c88
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IOPORT_LEN
value|0x0017
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IRQ_REG
value|0x0cc0
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IRQ_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IRQ_15
value|0x80
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IRQ_14
value|0x40
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IRQ_11
value|0x10
end_define

begin_define
define|#
directive|define
name|IDA_EISA_IRQ_10
value|0x20
end_define

begin_function
specifier|static
name|int
name|ida_v1_fifo_full
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|)
block|{
name|u_int8_t
name|status
decl_stmt|;
name|status
operator|=
name|ida_inb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_DOORBELL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|status
operator|&
name|EISA_CHANNEL_CLEAR
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ida_v1_submit
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|,
name|struct
name|ida_qcb
modifier|*
name|qcb
parameter_list|)
block|{
name|u_int16_t
name|size
decl_stmt|;
comment|/* 	 * On these cards, this location is actually for control flags. 	 * Set them to zero and pass in structure size via an I/O port. 	 */
name|size
operator|=
name|qcb
operator|->
name|hwqcb
operator|->
name|hdr
operator|.
name|size
operator|<<
literal|2
expr_stmt|;
name|qcb
operator|->
name|hwqcb
operator|->
name|hdr
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_DOORBELL
argument_list|,
name|EISA_CHANNEL_CLEAR
argument_list|)
expr_stmt|;
name|ida_outl
argument_list|(
name|ida
argument_list|,
name|R_EISA_LIST_ADDR
argument_list|,
name|qcb
operator|->
name|hwqcb_busaddr
argument_list|)
expr_stmt|;
name|ida_outw
argument_list|(
name|ida
argument_list|,
name|R_EISA_LIST_LEN
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_LOCAL_DOORBELL
argument_list|,
name|EISA_CHANNEL_BUSY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bus_addr_t
name|ida_v1_done
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|)
block|{
name|struct
name|ida_hardware_qcb
modifier|*
name|hwqcb
decl_stmt|;
name|bus_addr_t
name|completed
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|ida_inb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_DOORBELL
argument_list|)
operator|&
name|EISA_CHANNEL_BUSY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_DOORBELL
argument_list|,
name|EISA_CHANNEL_BUSY
argument_list|)
expr_stmt|;
name|completed
operator|=
name|ida_inl
argument_list|(
name|ida
argument_list|,
name|R_EISA_COMPLETE_ADDR
argument_list|)
expr_stmt|;
name|status
operator|=
name|ida_inb
argument_list|(
name|ida
argument_list|,
name|R_EISA_LIST_STATUS
argument_list|)
expr_stmt|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_LOCAL_DOORBELL
argument_list|,
name|EISA_CHANNEL_CLEAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|completed
operator|!=
literal|0
condition|)
block|{
name|hwqcb
operator|=
operator|(
expr|struct
name|ida_hardware_qcb
operator|*
operator|)
operator|(
operator|(
name|bus_addr_t
operator|)
name|ida
operator|->
name|hwqcbs
operator|+
operator|(
operator|(
name|completed
operator|&
operator|~
literal|3
operator|)
operator|-
name|ida
operator|->
name|hwqcb_busaddr
operator|)
operator|)
expr_stmt|;
name|hwqcb
operator|->
name|req
operator|.
name|error
operator|=
name|status
expr_stmt|;
block|}
return|return
operator|(
name|completed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ida_v1_int_pending
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|)
block|{
return|return
operator|(
name|ida_inb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_DOORBELL
argument_list|)
operator|&
name|EISA_CHANNEL_BUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ida_v1_int_enable
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
if|if
condition|(
name|enable
condition|)
block|{
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_DOORBELL
argument_list|,
operator|~
name|EISA_CHANNEL_CLEAR
argument_list|)
expr_stmt|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_LOCAL_DOORBELL
argument_list|,
name|EISA_CHANNEL_BUSY
argument_list|)
expr_stmt|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_INT_MASK
argument_list|,
name|INT_ENABLE
argument_list|)
expr_stmt|;
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_MASK
argument_list|,
name|INT_ENABLE
argument_list|)
expr_stmt|;
name|ida
operator|->
name|flags
operator||=
name|IDA_INTERRUPTS
expr_stmt|;
block|}
else|else
block|{
name|ida_outb
argument_list|(
name|ida
argument_list|,
name|R_EISA_SYSTEM_MASK
argument_list|,
name|INT_DISABLE
argument_list|)
expr_stmt|;
name|ida
operator|->
name|flags
operator|&=
operator|~
name|IDA_INTERRUPTS
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ida_v2_fifo_full
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|)
block|{
return|return
operator|(
name|ida_inl
argument_list|(
name|ida
argument_list|,
name|R_CMD_FIFO
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ida_v2_submit
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|,
name|struct
name|ida_qcb
modifier|*
name|qcb
parameter_list|)
block|{
name|ida_outl
argument_list|(
name|ida
argument_list|,
name|R_CMD_FIFO
argument_list|,
name|qcb
operator|->
name|hwqcb_busaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bus_addr_t
name|ida_v2_done
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|)
block|{
return|return
operator|(
name|ida_inl
argument_list|(
name|ida
argument_list|,
name|R_DONE_FIFO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ida_v2_int_pending
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|)
block|{
return|return
operator|(
name|ida_inl
argument_list|(
name|ida
argument_list|,
name|R_INT_PENDING
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ida_v2_int_enable
parameter_list|(
name|struct
name|ida_softc
modifier|*
name|ida
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
if|if
condition|(
name|enable
condition|)
name|ida
operator|->
name|flags
operator||=
name|IDA_INTERRUPTS
expr_stmt|;
else|else
name|ida
operator|->
name|flags
operator|&=
operator|~
name|IDA_INTERRUPTS
expr_stmt|;
name|ida_outl
argument_list|(
name|ida
argument_list|,
name|R_INT_MASK
argument_list|,
name|enable
condition|?
name|INT_ENABLE
else|:
name|INT_DISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ida_access
name|ida_v1_access
init|=
block|{
name|ida_v1_fifo_full
block|,
name|ida_v1_submit
block|,
name|ida_v1_done
block|,
name|ida_v1_int_pending
block|,
name|ida_v1_int_enable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ida_access
name|ida_v2_access
init|=
block|{
name|ida_v2_fifo_full
block|,
name|ida_v2_submit
block|,
name|ida_v2_done
block|,
name|ida_v2_int_pending
block|,
name|ida_v2_int_enable
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ida_board
name|board_id
index|[]
init|=
block|{
block|{
literal|0x0e114001
block|,
literal|"Compaq IDA controller"
block|,
operator|&
name|ida_v1_access
block|,
literal|0
block|}
block|,
block|{
literal|0x0e114002
block|,
literal|"Compaq IDA-2 controller"
block|,
operator|&
name|ida_v1_access
block|,
literal|0
block|}
block|,
block|{
literal|0x0e114010
block|,
literal|"Compaq IAES controller"
block|,
operator|&
name|ida_v1_access
block|,
literal|0
block|}
block|,
block|{
literal|0x0e114020
block|,
literal|"Compaq SMART array controller"
block|,
operator|&
name|ida_v1_access
block|,
literal|0
block|}
block|,
block|{
literal|0x0e114030
block|,
literal|"Compaq SMART-2/E array controller"
block|,
operator|&
name|ida_v2_access
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|""
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|ida_board
modifier|*
name|ida_eisa_match
parameter_list|(
name|eisa_id_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ida_eisa_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ida_eisa_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|ida_eisa_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ida_eisa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ida_eisa_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ida_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ida_eisa_driver
init|=
block|{
literal|"ida"
block|,
name|ida_eisa_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ida_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ida_devclass
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|ida_board
modifier|*
name|ida_eisa_match
parameter_list|(
name|eisa_id_t
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|board_id
index|[
name|i
index|]
operator|.
name|board
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|board_id
index|[
name|i
index|]
operator|.
name|board
operator|==
name|id
condition|)
return|return
operator|(
operator|&
name|board_id
index|[
name|i
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ida_eisa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ida_board
modifier|*
name|board
decl_stmt|;
name|u_int32_t
name|io_base
decl_stmt|;
name|u_int
name|irq
init|=
literal|0
decl_stmt|;
name|board
operator|=
name|ida_eisa_match
argument_list|(
name|eisa_get_id
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|board
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|board
operator|->
name|desc
argument_list|)
expr_stmt|;
name|io_base
operator|=
operator|(
name|eisa_get_slot
argument_list|(
name|dev
argument_list|)
operator|*
name|EISA_SLOT_SIZE
operator|)
expr_stmt|;
switch|switch
condition|(
name|IDA_EISA_IRQ_MASK
operator|&
operator|(
name|inb
argument_list|(
name|IDA_EISA_IRQ_REG
operator|+
name|io_base
argument_list|)
operator|)
condition|)
block|{
case|case
name|IDA_EISA_IRQ_15
case|:
name|irq
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|IDA_EISA_IRQ_14
case|:
name|irq
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|IDA_EISA_IRQ_11
case|:
name|irq
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|IDA_EISA_IRQ_10
case|:
name|irq
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"slot %d, illegal irq setting.\n"
argument_list|,
name|eisa_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|eisa_add_iospace
argument_list|(
name|dev
argument_list|,
operator|(
name|io_base
operator|+
name|IDA_EISA_IOPORT_START
operator|)
argument_list|,
name|IDA_EISA_IOPORT_LEN
argument_list|,
name|RESVADDR_NONE
argument_list|)
expr_stmt|;
name|eisa_add_intr
argument_list|(
name|dev
argument_list|,
name|irq
argument_list|,
name|EISA_TRIGGER_LEVEL
argument_list|)
expr_stmt|;
comment|/* XXX ??? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ida_eisa_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ida_softc
modifier|*
name|ida
decl_stmt|;
name|struct
name|ida_board
modifier|*
name|board
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|ida
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ida
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|board
operator|=
name|ida_eisa_match
argument_list|(
name|eisa_get_id
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ida
operator|->
name|cmd
operator|=
operator|*
name|board
operator|->
name|accessor
expr_stmt|;
name|ida
operator|->
name|flags
operator|=
name|board
operator|->
name|flags
expr_stmt|;
name|ida
operator|->
name|regs_res_type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|ida
operator|->
name|regs_res_id
operator|=
literal|0
expr_stmt|;
name|ida
operator|->
name|regs
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|ida
operator|->
name|regs_res_type
argument_list|,
operator|&
name|ida
operator|->
name|regs_res_id
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ida
operator|->
name|regs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate register resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
comment|/* parent	*/
name|NULL
argument_list|,
comment|/* alignment	*/
literal|0
argument_list|,
comment|/* boundary	*/
literal|0
argument_list|,
comment|/* lowaddr	*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* highaddr	*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* filter	*/
name|NULL
argument_list|,
comment|/* filterarg	*/
name|NULL
argument_list|,
comment|/* maxsize	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* nsegments	*/
name|BUS_SPACE_UNRESTRICTED
argument_list|,
comment|/* maxsegsize	*/
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* flags	*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* lockfunc	*/
name|NULL
argument_list|,
comment|/* lockarg	*/
name|NULL
argument_list|,
operator|&
name|ida
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't allocate DMA tag\n"
argument_list|)
expr_stmt|;
name|ida_free
argument_list|(
name|ida
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|ida
operator|->
name|irq_res_type
operator|=
name|SYS_RES_IRQ
expr_stmt|;
name|ida
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|ida
operator|->
name|irq_res_type
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ida
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|ida_free
argument_list|(
name|ida
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ida
operator|->
name|irq
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_ENTROPY
argument_list|,
name|NULL
argument_list|,
name|ida_intr
argument_list|,
name|ida
argument_list|,
operator|&
name|ida
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't setup interrupt\n"
argument_list|)
expr_stmt|;
name|ida_free
argument_list|(
name|ida
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|ida_init
argument_list|(
name|ida
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ida_free
argument_list|(
name|ida
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ida_attach
argument_list|(
name|ida
argument_list|)
expr_stmt|;
name|ida
operator|->
name|flags
operator||=
name|IDA_ATTACHED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ida
argument_list|,
name|eisa
argument_list|,
name|ida_eisa_driver
argument_list|,
name|ida_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

