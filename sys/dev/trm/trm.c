begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      O.S   : FreeBSD CAM  *	FILE NAME  : trm.c					        *	     BY    : C.L. Huang 	(ching@tekram.com.tw)  *                   Erich Chen     (erich@tekram.com.tw)  *      Description: Device Driver for Tekram SCSI adapters  *                   DC395U/UW/F ,DC315/U(TRM-S1040)  *                   DC395U2D/U2W(TRM-S2080)  *                   PCI SCSI Bus Master Host Adapter	  *                   (SCSI chip set used Tekram ASIC TRM-S1040,TRM-S2080)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *	HISTORY:					  *						  *	REV#	DATE	NAME    	DESCRIPTION	  *  1.05   05/01/1999  ERICH CHEN  First released for 3.x.x (CAM)  *  1.06   07/29/1999  ERICH CHEN  Modify for NEW PCI  *  1.07   12/12/1999  ERICH CHEN  Modify for 3.3.x ,DCB no free  *  1.08   06/12/2000  ERICH CHEN  Modify for 4.x.x   *  1.09   11/03/2000  ERICH CHEN  Modify for 4.1.R ,new sim  *  1.10   10/10/2001  Oscar Feng  Fixed CAM rescan hang up bug.	  *  1.11   10/13/2001  Oscar Feng  Fixed wrong Async speed display bug.	  */
end_comment

begin_comment
comment|/*-  * (C)Copyright 1995-2001 Tekram Technology Co.,Ltd.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * Imported into FreeBSD source repository, and updated to compile under    * FreeBSD-3.0-DEVELOPMENT, by Stefan Esser<se@FreeBSD.Org>, 1996-12-17    */
end_comment

begin_comment
comment|/*  * Updated to compile under FreeBSD 5.0-CURRENT by Olivier Houchard  *<doginou@ci0.org>, 2002-03-04  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
end_if

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<dev/trm/trm.h>
end_include

begin_define
define|#
directive|define
name|trm_reg_read8
parameter_list|(
name|reg
parameter_list|)
value|bus_space_read_1(pACB->tag, pACB->bsh, reg)
end_define

begin_define
define|#
directive|define
name|trm_reg_read16
parameter_list|(
name|reg
parameter_list|)
value|bus_space_read_2(pACB->tag, pACB->bsh, reg)
end_define

begin_define
define|#
directive|define
name|trm_reg_read32
parameter_list|(
name|reg
parameter_list|)
value|bus_space_read_4(pACB->tag, pACB->bsh, reg)
end_define

begin_define
define|#
directive|define
name|trm_reg_write8
parameter_list|(
name|value
parameter_list|,
name|reg
parameter_list|)
value|bus_space_write_1(pACB->tag, pACB->bsh,\ 		reg, value)
end_define

begin_define
define|#
directive|define
name|trm_reg_write16
parameter_list|(
name|value
parameter_list|,
name|reg
parameter_list|)
value|bus_space_write_2(pACB->tag, pACB->bsh,\ 		reg, value)
end_define

begin_define
define|#
directive|define
name|trm_reg_write32
parameter_list|(
name|value
parameter_list|,
name|reg
parameter_list|)
value|bus_space_write_4(pACB->tag, pACB->bsh,\ 		reg, value)
end_define

begin_define
define|#
directive|define
name|PCI_Vendor_ID_TEKRAM
value|0x1DE1
end_define

begin_define
define|#
directive|define
name|PCI_Device_ID_TRM_S1040
value|0x0391
end_define

begin_define
define|#
directive|define
name|PCI_DEVICEID_TRMS1040
value|0x03911DE1
end_define

begin_define
define|#
directive|define
name|PCI_DEVICEID_TRMS2080
value|0x03921DE1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|trm_DEBUG1
end_ifdef

begin_define
define|#
directive|define
name|TRM_DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
value|printf("trm: " fmt, ##arg)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TRM_DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
value|{}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TRM_DEBUG */
end_comment

begin_function_decl
specifier|static
name|void
name|trm_check_eeprom
parameter_list|(
name|PNVRAMTYPE
name|pEEpromBuf
parameter_list|,
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NVRAM_trm_read_all
parameter_list|(
name|PNVRAMTYPE
name|pEEpromBuf
parameter_list|,
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|NVRAM_trm_get_data
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|bAddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NVRAM_trm_write_all
parameter_list|(
name|PNVRAMTYPE
name|pEEpromBuf
parameter_list|,
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NVRAM_trm_set_data
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|bAddr
parameter_list|,
name|u_int8_t
name|bData
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NVRAM_trm_write_cmd
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|bCmd
parameter_list|,
name|u_int8_t
name|bAddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NVRAM_trm_wait_30us
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_Interrupt
parameter_list|(
name|void
modifier|*
name|vpACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_DataOutPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_DataInPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_CommandPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_StatusPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_MsgOutPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_MsgInPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_DataOutPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_DataInPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_CommandPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_StatusPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_MsgOutPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_MsgInPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_Nop0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_Nop1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_SetXferRate
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_DataIO_transfer
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
name|ioDir
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_Disconnect
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_Reselect
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_SRBdone
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_DoingSRB_Done
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_ScsiRstDetect
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_ResetSCSIBus
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_RequestSense
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_EnableMsgOutAbort2
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_EnableMsgOutAbort1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_SendSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trm_probe
parameter_list|(
name|device_t
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trm_attach
parameter_list|(
name|device_t
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_reset
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|trm_StartSCSI
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trm_initAdapter
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int16_t
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_initDCB
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|u_int16_t
name|unit
parameter_list|,
name|u_int32_t
name|i
parameter_list|,
name|u_int32_t
name|j
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trm_initSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_initACB
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|adaptType
parameter_list|,
name|u_int16_t
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* CAM SIM entry points */
end_comment

begin_define
define|#
directive|define
name|ccb_trmsrb_ptr
value|spriv_ptr0
end_define

begin_define
define|#
directive|define
name|ccb_trmacb_ptr
value|spriv_ptr1
end_define

begin_function_decl
specifier|static
name|void
name|trm_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trm_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
modifier|*
name|trm_SCSI_phase0
index|[]
init|=
block|{
name|trm_DataOutPhase0
block|,
comment|/* phase:0 */
name|trm_DataInPhase0
block|,
comment|/* phase:1 */
name|trm_CommandPhase0
block|,
comment|/* phase:2 */
name|trm_StatusPhase0
block|,
comment|/* phase:3 */
name|trm_Nop0
block|,
comment|/* phase:4 */
name|trm_Nop1
block|,
comment|/* phase:5 */
name|trm_MsgOutPhase0
block|,
comment|/* phase:6 */
name|trm_MsgInPhase0
block|,
comment|/* phase:7 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  *          stateV = (void *) trm_SCSI_phase1[phase]  *  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|trm_SCSI_phase1
index|[]
init|=
block|{
name|trm_DataOutPhase1
block|,
comment|/* phase:0 */
name|trm_DataInPhase1
block|,
comment|/* phase:1 */
name|trm_CommandPhase1
block|,
comment|/* phase:2 */
name|trm_StatusPhase1
block|,
comment|/* phase:3 */
name|trm_Nop0
block|,
comment|/* phase:4 */
name|trm_Nop1
block|,
comment|/* phase:5 */
name|trm_MsgOutPhase1
block|,
comment|/* phase:6 */
name|trm_MsgInPhase1
block|,
comment|/* phase:7 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NVRAMTYPE
name|trm_eepromBuf
index|[
name|TRM_MAX_ADAPTER_NUM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *Fast20:  000	 50ns, 20.0 Mbytes/s  *	       001	 75ns, 13.3 Mbytes/s  *	       010	100ns, 10.0 Mbytes/s  *	       011	125ns,  8.0 Mbytes/s  *	       100	150ns,  6.6 Mbytes/s  *	       101	175ns,  5.7 Mbytes/s  *	       110	200ns,  5.0 Mbytes/s  *	       111	250ns,  4.0 Mbytes/s  *  *Fast40:  000	 25ns, 40.0 Mbytes/s  *	       001	 50ns, 20.0 Mbytes/s  *	       010	 75ns, 13.3 Mbytes/s  *	       011	100ns, 10.0 Mbytes/s  *	       100	125ns,  8.0 Mbytes/s  *	       101	150ns,  6.6 Mbytes/s  *	       110	175ns,  5.7 Mbytes/s  *	       111	200ns,  5.0 Mbytes/s  */
end_comment

begin_comment
comment|/* real period: */
end_comment

begin_decl_stmt
name|u_int8_t
name|dc395x_clock_period
index|[]
init|=
block|{
literal|12
block|,
comment|/*  48  ns 20   MB/sec */
literal|18
block|,
comment|/*  72  ns 13.3 MB/sec */
literal|25
block|,
comment|/* 100  ns 10.0 MB/sec */
literal|31
block|,
comment|/* 124  ns  8.0 MB/sec */
literal|37
block|,
comment|/* 148  ns  6.6 MB/sec */
literal|43
block|,
comment|/* 172  ns  5.7 MB/sec */
literal|50
block|,
comment|/* 200  ns  5.0 MB/sec */
literal|62
comment|/* 248  ns  4.0 MB/sec */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8_t
name|dc395u2x_clock_period
index|[]
init|=
block|{
literal|10
block|,
comment|/*  25  ns 40.0 MB/sec */
literal|12
block|,
comment|/*  48  ns 20.0 MB/sec */
literal|18
block|,
comment|/*  72  ns 13.3 MB/sec */
literal|25
block|,
comment|/* 100  ns 10.0 MB/sec */
literal|31
block|,
comment|/* 124  ns  8.0 MB/sec */
literal|37
block|,
comment|/* 148  ns  6.6 MB/sec */
literal|43
block|,
comment|/* 172  ns  5.7 MB/sec */
literal|50
block|,
comment|/* 200  ns  5.0 MB/sec */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|dc395x_tinfo_period
value|dc395x_clock_period
end_define

begin_define
define|#
directive|define
name|dc395u2x_tinfo_period
value|dc395u2x_clock_period
end_define

begin_function
specifier|static
name|PSRB
name|trm_GetSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|int
name|intflag
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
if|if
condition|(
name|pSRB
condition|)
block|{
name|pACB
operator|->
name|pFreeSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|pSRB
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_RewaitSRB0
parameter_list|(
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|PSRB
name|psrb1
decl_stmt|;
name|int
name|intflag
decl_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|psrb1
operator|=
name|pDCB
operator|->
name|pWaitingSRB
operator|)
condition|)
block|{
name|pSRB
operator|->
name|pNextSRB
operator|=
name|psrb1
expr_stmt|;
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|pSRB
expr_stmt|;
block|}
else|else
block|{
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|pWaitingLastSRB
operator|=
name|pSRB
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_RewaitSRB
parameter_list|(
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|PSRB
name|psrb1
decl_stmt|;
name|int
name|intflag
decl_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pDCB
operator|->
name|GoingSRBCnt
operator|--
expr_stmt|;
name|psrb1
operator|=
name|pDCB
operator|->
name|pGoingSRB
expr_stmt|;
if|if
condition|(
name|pSRB
operator|==
name|psrb1
condition|)
comment|/* 		 * if this SRB is GoingSRB 		 * remove this SRB from GoingSRB Q 		 */
name|pDCB
operator|->
name|pGoingSRB
operator|=
name|psrb1
operator|->
name|pNextSRB
expr_stmt|;
else|else
block|{
comment|/* 		 * if this SRB is not current GoingSRB 		 * remove this SRB from GoingSRB Q 		 */
while|while
condition|(
name|pSRB
operator|!=
name|psrb1
operator|->
name|pNextSRB
condition|)
name|psrb1
operator|=
name|psrb1
operator|->
name|pNextSRB
expr_stmt|;
name|psrb1
operator|->
name|pNextSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
if|if
condition|(
name|pSRB
operator|==
name|pDCB
operator|->
name|pGoingLastSRB
condition|)
name|pDCB
operator|->
name|pGoingLastSRB
operator|=
name|psrb1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|psrb1
operator|=
name|pDCB
operator|->
name|pWaitingSRB
operator|)
condition|)
block|{
comment|/* 		 * if WaitingSRB Q is not NULL 		 * Q back this SRB into WaitingSRB 		 */
name|pSRB
operator|->
name|pNextSRB
operator|=
name|psrb1
expr_stmt|;
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|pSRB
expr_stmt|;
block|}
else|else
block|{
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|pWaitingLastSRB
operator|=
name|pSRB
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DoWaitingSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|int
name|intflag
decl_stmt|;
name|PDCB
name|ptr
decl_stmt|,
name|ptr1
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pACB
operator|->
name|pActiveDCB
operator|)
operator|&&
operator|!
operator|(
name|pACB
operator|->
name|ACBFlag
operator|&
operator|(
name|RESET_DETECT
operator|+
name|RESET_DONE
operator|+
name|RESET_DEV
operator|)
operator|)
condition|)
block|{
name|ptr
operator|=
name|pACB
operator|->
name|pDCBRunRobin
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ptr
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
name|pACB
operator|->
name|pDCBRunRobin
operator|=
name|ptr
expr_stmt|;
block|}
name|ptr1
operator|=
name|ptr
expr_stmt|;
for|for
control|(
init|;
name|ptr1
condition|;
control|)
block|{
name|pACB
operator|->
name|pDCBRunRobin
operator|=
name|ptr1
operator|->
name|pNextDCB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ptr1
operator|->
name|MaxActiveCommandCnt
operator|>
name|ptr1
operator|->
name|GoingSRBCnt
operator|)
operator|||
operator|!
operator|(
name|pSRB
operator|=
name|ptr1
operator|->
name|pWaitingSRB
operator|)
condition|)
block|{
if|if
condition|(
name|pACB
operator|->
name|pDCBRunRobin
operator|==
name|ptr
condition|)
break|break;
name|ptr1
operator|=
name|ptr1
operator|->
name|pNextDCB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|trm_StartSCSI
argument_list|(
name|pACB
argument_list|,
name|ptr1
argument_list|,
name|pSRB
argument_list|)
condition|)
block|{
comment|/*  				 * If trm_StartSCSI return 0 : 				 * current interrupt status is interrupt enable  				 * It's said that SCSI processor is unoccupied  				 */
name|ptr1
operator|->
name|GoingSRBCnt
operator|++
expr_stmt|;
if|if
condition|(
name|ptr1
operator|->
name|pWaitingLastSRB
operator|==
name|pSRB
condition|)
block|{
name|ptr1
operator|->
name|pWaitingSRB
operator|=
name|NULL
expr_stmt|;
name|ptr1
operator|->
name|pWaitingLastSRB
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|ptr1
operator|->
name|pWaitingSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ptr1
operator|->
name|pGoingSRB
condition|)
name|ptr1
operator|->
name|pGoingLastSRB
operator|->
name|pNextSRB
operator|=
name|pSRB
expr_stmt|;
else|else
name|ptr1
operator|->
name|pGoingSRB
operator|=
name|pSRB
expr_stmt|;
name|ptr1
operator|->
name|pGoingLastSRB
operator|=
name|pSRB
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_SRBwaiting
parameter_list|(
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
if|if
condition|(
name|pDCB
operator|->
name|pWaitingSRB
condition|)
block|{
name|pDCB
operator|->
name|pWaitingLastSRB
operator|->
name|pNextSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|pWaitingLastSRB
operator|=
name|pSRB
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|pWaitingLastSRB
operator|=
name|pSRB
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|trm_get_sense_bufaddr
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|pSRB
operator|->
name|TagNumber
expr_stmt|;
return|return
operator|(
name|pACB
operator|->
name|sense_busaddr
operator|+
operator|(
name|offset
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|scsi_sense_data
modifier|*
name|trm_get_sense_buf
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|pSRB
operator|->
name|TagNumber
expr_stmt|;
return|return
operator|(
operator|&
name|pACB
operator|->
name|sense_buffers
index|[
name|offset
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_ExecuteSRB
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|dm_segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|PACB
name|pACB
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|u_long
name|totalxferlen
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pSRB
operator|=
operator|(
name|PSRB
operator|)
name|arg
expr_stmt|;
name|ccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_trmacb_ptr
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm_ExecuteSRB..........\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
block|{
name|PSEG
name|psg
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|end_seg
decl_stmt|;
name|int
name|op
decl_stmt|;
comment|/* Copy the segments into our SG list */
name|end_seg
operator|=
name|dm_segs
operator|+
name|nseg
expr_stmt|;
name|psg
operator|=
name|pSRB
operator|->
name|pSRBSGL
expr_stmt|;
while|while
condition|(
name|dm_segs
operator|<
name|end_seg
condition|)
block|{
name|psg
operator|->
name|address
operator|=
name|dm_segs
operator|->
name|ds_addr
expr_stmt|;
name|psg
operator|->
name|length
operator|=
operator|(
name|u_long
operator|)
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|totalxferlen
operator|+=
name|dm_segs
operator|->
name|ds_len
expr_stmt|;
name|psg
operator|++
expr_stmt|;
name|dm_segs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
block|{
name|op
operator|=
name|BUS_DMASYNC_PREREAD
expr_stmt|;
block|}
else|else
block|{
name|op
operator|=
name|BUS_DMASYNC_PREWRITE
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
name|pSRB
operator|->
name|RetryCnt
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
name|totalxferlen
expr_stmt|;
name|pSRB
operator|->
name|SRBSGCount
operator|=
name|nseg
expr_stmt|;
name|pSRB
operator|->
name|SRBSGIndex
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|AdaptStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBFlag
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|ScsiPhase
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* SCSI bus free Phase */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
if|if
condition|(
name|nseg
operator|!=
literal|0
condition|)
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
name|pACB
operator|->
name|pFreeSRB
operator|=
name|pSRB
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SIM_QUEUED
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Need a timeout handler */
block|ccb->ccb_h.timeout_ch = timeout(trmtimeout, (caddr_t)srb, (ccb->ccb_h.timeout * hz) / 1000);
endif|#
directive|endif
name|trm_SendSRB
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_SendSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|;
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pDCB
operator|->
name|MaxActiveCommandCnt
operator|>
name|pDCB
operator|->
name|GoingSRBCnt
operator|)
operator|||
operator|(
name|pACB
operator|->
name|pActiveDCB
operator|)
operator|||
operator|(
name|pACB
operator|->
name|ACBFlag
operator|&
operator|(
name|RESET_DETECT
operator|+
name|RESET_DONE
operator|+
name|RESET_DEV
operator|)
operator|)
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"pDCB->MaxCommand=%d \n"
argument_list|,
name|pDCB
operator|->
name|MaxActiveCommandCnt
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pDCB->GoingSRBCnt=%d \n"
argument_list|,
name|pDCB
operator|->
name|GoingSRBCnt
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pACB->pActiveDCB=%8x \n"
argument_list|,
operator|(
name|u_int
operator|)
name|pACB
operator|->
name|pActiveDCB
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pACB->ACBFlag=%x \n"
argument_list|,
name|pACB
operator|->
name|ACBFlag
argument_list|)
expr_stmt|;
name|trm_SRBwaiting
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
goto|goto
name|SND_EXIT
goto|;
block|}
if|if
condition|(
name|pDCB
operator|->
name|pWaitingSRB
condition|)
block|{
name|trm_SRBwaiting
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|pSRB
operator|=
name|pDCB
operator|->
name|pWaitingSRB
expr_stmt|;
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|trm_StartSCSI
argument_list|(
name|pACB
argument_list|,
name|pDCB
argument_list|,
name|pSRB
argument_list|)
condition|)
block|{
comment|/*  	 * If trm_StartSCSI return 0 : 	 * current interrupt status is interrupt enable  	 * It's said that SCSI processor is unoccupied  	 */
name|pDCB
operator|->
name|GoingSRBCnt
operator|++
expr_stmt|;
comment|/* stack waiting SRB*/
if|if
condition|(
name|pDCB
operator|->
name|pGoingSRB
condition|)
block|{
name|pDCB
operator|->
name|pGoingLastSRB
operator|->
name|pNextSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|pGoingLastSRB
operator|=
name|pSRB
expr_stmt|;
block|}
else|else
block|{
name|pDCB
operator|->
name|pGoingSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|pGoingLastSRB
operator|=
name|pSRB
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  	 * If trm_StartSCSI return 1 : 	 * current interrupt status is interrupt disreenable  	 * It's said that SCSI processor has more one SRB need to do 	 */
name|trm_RewaitSRB0
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
name|SND_EXIT
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_action
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|,
name|union
name|ccb
modifier|*
name|pccb
parameter_list|)
block|{
name|PACB
name|pACB
decl_stmt|;
name|int
name|actionflags
decl_stmt|;
name|u_int
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|pccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"trm_action\n"
operator|)
argument_list|)
expr_stmt|;
name|actionflags
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|target_lun
operator|=
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
switch|switch
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
case|case
name|XPT_NOOP
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_NOOP \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Execute the requested I/O operation  	 	 */
case|case
name|XPT_SCSI_IO
case|:
block|{
name|PDCB
name|pDCB
init|=
name|NULL
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
decl_stmt|;
name|pcsio
operator|=
operator|&
name|pccb
operator|->
name|csio
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" XPT_SCSI_IO \n"
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm: target_id= %d target_lun= %d \n"
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pACB->scan_devices[target_id][target_lun]= %d \n"
argument_list|,
name|pACB
operator|->
name|scan_devices
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_INPROG
condition|)
block|{
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|actionflags
argument_list|)
expr_stmt|;
return|return;
block|}
name|pDCB
operator|=
operator|&
name|pACB
operator|->
name|DCBarray
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pDCB
operator|->
name|DCBstatus
operator|&
name|DS_IN_QUEUE
operator|)
condition|)
block|{
name|pACB
operator|->
name|scan_devices
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
operator|=
literal|1
expr_stmt|;
name|trm_initDCB
argument_list|(
name|pACB
argument_list|,
name|pDCB
argument_list|,
name|pACB
operator|->
name|AdapterUnit
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Assign an SRB and connect it with this ccb. 			 */
name|pSRB
operator|=
name|trm_GetSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pSRB
condition|)
block|{
comment|/* Freeze SIMQ */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|actionflags
argument_list|)
expr_stmt|;
return|return;
block|}
name|pSRB
operator|->
name|pSRBDCB
operator|=
name|pDCB
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|ccb_trmsrb_ptr
operator|=
name|pSRB
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|ccb_trmacb_ptr
operator|=
name|pACB
expr_stmt|;
name|pSRB
operator|->
name|pccb
operator|=
name|pccb
expr_stmt|;
name|pSRB
operator|->
name|ScsiCmdLen
operator|=
name|pcsio
operator|->
name|cdb_len
expr_stmt|;
comment|/*  			 * move layer of CAM command block to layer of SCSI 			 * Request Block for SCSI processor command doing 			 */
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_ptr
argument_list|,
name|pSRB
operator|->
name|CmdBlock
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
name|pACB
operator|->
name|pFreeSRB
operator|=
name|pSRB
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|actionflags
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|bcopy
argument_list|(
name|pcsio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|pSRB
operator|->
name|CmdBlock
argument_list|,
name|pcsio
operator|->
name|cdb_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SCATTER_VALID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|vmflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vmflags
operator|=
name|splsoftvm
argument_list|()
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|pcsio
operator|->
name|data_ptr
argument_list|,
name|pcsio
operator|->
name|dxfer_len
argument_list|,
name|trm_ExecuteSRB
argument_list|,
name|pSRB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|splx
argument_list|(
name|vmflags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bus_dma_segment
name|seg
decl_stmt|;
comment|/* Pointer to physical buffer */
name|seg
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|pcsio
operator|->
name|data_ptr
expr_stmt|;
name|seg
operator|.
name|ds_len
operator|=
name|pcsio
operator|->
name|dxfer_len
expr_stmt|;
name|trm_ExecuteSRB
argument_list|(
name|pSRB
argument_list|,
operator|&
name|seg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*  CAM_SCATTER_VALID */
name|struct
name|bus_dma_segment
modifier|*
name|segs
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_SG_LIST_PHYS
operator|)
operator|==
literal|0
operator|||
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DATA_PHYS
operator|)
operator|!=
literal|0
condition|)
block|{
name|pSRB
operator|->
name|pNextSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
name|pACB
operator|->
name|pFreeSRB
operator|=
name|pSRB
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_PROVIDE_FAIL
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|actionflags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* cam SG list is physical, 					 *  cam data is virtual  					 */
name|segs
operator|=
operator|(
expr|struct
name|bus_dma_segment
operator|*
operator|)
name|pcsio
operator|->
name|data_ptr
expr_stmt|;
name|trm_ExecuteSRB
argument_list|(
name|pSRB
argument_list|,
name|segs
argument_list|,
name|pcsio
operator|->
name|sglist_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  CAM_SCATTER_VALID */
block|}
else|else
name|trm_ExecuteSRB
argument_list|(
name|pSRB
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XPT_GDEV_TYPE
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_GDEV_TYPE \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_GDEVLIST
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_GDEVLIST \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Path routing inquiry  	       	 * Path Inquiry CCB  		 */
case|case
name|XPT_PATH_INQ
case|:
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|pccb
operator|->
name|cpi
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" XPT_PATH_INQ \n"
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
operator||
name|PI_WIDE_16
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_target
operator|=
literal|15
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
name|pACB
operator|->
name|max_lun
expr_stmt|;
comment|/* 7 or 0 */
name|cpi
operator|->
name|initiator_id
operator|=
name|pACB
operator|->
name|AdaptSCSIID
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|3300
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"Tekram_TRM"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|psim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|psim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * Release a frozen SIM queue  		 * Release SIM Queue  		 */
case|case
name|XPT_REL_SIMQ
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_REL_SIMQ \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Set Asynchronous Callback Parameters  		 * Set Asynchronous Callback CCB  		 */
case|case
name|XPT_SASYNC_CB
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_SASYNC_CB \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Set device type information  		 * Set Device Type CCB   		 */
case|case
name|XPT_SDEV_TYPE
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_SDEV_TYPE \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * (Re)Scan the SCSI Bus  	 	 * Rescan the given bus, or bus/target/lun  		 */
case|case
name|XPT_SCAN_BUS
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_SCAN_BUS \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Get EDT entries matching the given pattern   		 */
case|case
name|XPT_DEV_MATCH
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_DEV_MATCH \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Turn on debugging for a bus, target or lun        		 */
case|case
name|XPT_DEBUG
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_DEBUG \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 			 * XPT_ABORT = 0x10, Abort the specified CCB  			 * Abort XPT request CCB  			 */
case|case
name|XPT_ABORT
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_ABORT \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Reset the specified SCSI bus  		 * Reset SCSI Bus CCB   		 */
case|case
name|XPT_RESET_BUS
case|:
block|{
name|int
name|i
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" XPT_RESET_BUS \n"
argument_list|)
expr_stmt|;
name|trm_reset
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|ACBFlag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * Bus Device Reset the specified SCSI device  		 * Reset SCSI Device CCB   		 */
case|case
name|XPT_RESET_DEV
case|:
comment|/* 		 * Don't (yet?) support vendor 		 * specific commands. 		 */
name|TRM_DPRINTF
argument_list|(
literal|" XPT_RESET_DEV \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Terminate the I/O process  		 * Terminate I/O Process Request CCB   		 */
case|case
name|XPT_TERM_IO
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_TERM_IO \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Scan Logical Unit  		 */
case|case
name|XPT_SCAN_LUN
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_SCAN_LUN \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Get/Set transfer rate/width/disconnection/tag queueing  		 * settings  		 * (GET) default/user transfer settings for the target  	 	 */
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|pccb
operator|->
name|cts
decl_stmt|;
name|int
name|intflag
decl_stmt|;
name|struct
name|trm_transinfo
modifier|*
name|tinfo
decl_stmt|;
name|PDCB
name|pDCB
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_SCSI
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|SCSI_REV_2
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SPI
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
literal|2
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" XPT_GET_TRAN_SETTINGS \n"
argument_list|)
expr_stmt|;
name|pDCB
operator|=
operator|&
name|pACB
operator|->
name|DCBarray
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
expr_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/* 			 * disable interrupt 			 */
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
comment|/* current transfer settings */
if|if
condition|(
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|TRM_CUR_DISCENB
condition|)
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
else|else
name|spi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* no tag& disconnect */
if|if
condition|(
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|TRM_CUR_TAGENB
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|tinfo
operator|=
operator|&
name|pDCB
operator|->
name|tinfo
operator|.
name|current
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"CURRENT:  cts->flags= %2x \n"
argument_list|,
name|cts
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* default(user) transfer settings */
if|if
condition|(
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|TRM_USR_DISCENB
condition|)
name|spi
operator|->
name|flags
operator|=
name|CTS_SPI_FLAGS_DISC_ENB
expr_stmt|;
else|else
name|spi
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&
name|TRM_USR_TAGENB
condition|)
name|scsi
operator|->
name|flags
operator||=
name|CTS_SCSI_FLAGS_TAG_ENB
expr_stmt|;
name|tinfo
operator|=
operator|&
name|pDCB
operator|->
name|tinfo
operator|.
name|user
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"USER: cts->flags= %2x \n"
argument_list|,
name|cts
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
name|spi
operator|->
name|sync_period
operator|=
name|tinfo
operator|->
name|period
expr_stmt|;
name|spi
operator|->
name|sync_offset
operator|=
name|tinfo
operator|->
name|offset
expr_stmt|;
name|spi
operator|->
name|bus_width
operator|=
name|tinfo
operator|->
name|width
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pDCB->SyncPeriod: %d  \n"
argument_list|,
name|pDCB
operator|->
name|SyncPeriod
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"period: %d  \n"
argument_list|,
name|tinfo
operator|->
name|period
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"offset: %d  \n"
argument_list|,
name|tinfo
operator|->
name|offset
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"width: %d  \n"
argument_list|,
name|tinfo
operator|->
name|width
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
name|spi
operator|->
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
operator||
name|CTS_SPI_VALID_BUS_WIDTH
operator||
name|CTS_SPI_VALID_DISC
expr_stmt|;
name|scsi
operator|->
name|valid
operator|=
name|CTS_SCSI_VALID_TQ
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*  		 * Get/Set transfer rate/width/disconnection/tag queueing  		 * settings 		 * (Set) transfer rate/width negotiation settings  		 */
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|pccb
operator|->
name|cts
decl_stmt|;
name|u_int
name|update_type
decl_stmt|;
name|int
name|intflag
decl_stmt|;
name|PDCB
name|pDCB
decl_stmt|;
name|struct
name|ccb_trans_settings_scsi
modifier|*
name|scsi
init|=
operator|&
name|cts
operator|->
name|proto_specific
operator|.
name|scsi
decl_stmt|;
name|struct
name|ccb_trans_settings_spi
modifier|*
name|spi
init|=
operator|&
name|cts
operator|->
name|xport_specific
operator|.
name|spi
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" XPT_SET_TRAN_SETTINGS \n"
argument_list|)
expr_stmt|;
name|update_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|update_type
operator||=
name|TRM_TRANS_GOAL
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_USER_SETTINGS
condition|)
name|update_type
operator||=
name|TRM_TRANS_USER
expr_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pDCB
operator|=
operator|&
name|pACB
operator|->
name|DCBarray
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_DISC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*ccb disc enables */
if|if
condition|(
name|update_type
operator|&
name|TRM_TRANS_GOAL
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_CUR_DISCENB
expr_stmt|;
else|else
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|TRM_CUR_DISCENB
expr_stmt|;
block|}
if|if
condition|(
name|update_type
operator|&
name|TRM_TRANS_USER
condition|)
block|{
if|if
condition|(
operator|(
name|spi
operator|->
name|flags
operator|&
name|CTS_SPI_FLAGS_DISC_ENB
operator|)
operator|!=
literal|0
condition|)
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_USR_DISCENB
expr_stmt|;
else|else
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|TRM_USR_DISCENB
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scsi
operator|->
name|valid
operator|&
name|CTS_SCSI_VALID_TQ
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* if ccb tag q active */
if|if
condition|(
name|update_type
operator|&
name|TRM_TRANS_GOAL
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_CUR_TAGENB
expr_stmt|;
else|else
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|TRM_CUR_TAGENB
expr_stmt|;
block|}
if|if
condition|(
name|update_type
operator|&
name|TRM_TRANS_USER
condition|)
block|{
if|if
condition|(
operator|(
name|scsi
operator|->
name|flags
operator|&
name|CTS_SCSI_FLAGS_TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_USR_TAGENB
expr_stmt|;
else|else
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|TRM_USR_TAGENB
expr_stmt|;
block|}
block|}
comment|/* Minimum sync period factor	*/
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_RATE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* if ccb sync active */
comment|/* TRM-S1040 MinSyncPeriod = 4 clocks/byte */
if|if
condition|(
operator|(
name|spi
operator|->
name|sync_period
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|spi
operator|->
name|sync_period
operator|<
literal|125
operator|)
condition|)
name|spi
operator|->
name|sync_period
operator|=
literal|125
expr_stmt|;
comment|/* 1/(125*4) minsync 2 MByte/sec */
if|if
condition|(
operator|(
name|spi
operator|->
name|valid
operator|&
name|CTS_SPI_VALID_SYNC_OFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|==
literal|0
condition|)
name|spi
operator|->
name|sync_period
operator|=
literal|0
expr_stmt|;
comment|/* TRM-S1040 MaxSyncOffset = 15 bytes*/
if|if
condition|(
name|spi
operator|->
name|sync_offset
operator|>
literal|15
condition|)
name|spi
operator|->
name|sync_offset
operator|=
literal|15
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|TRM_TRANS_USER
operator|)
operator|!=
literal|0
condition|)
block|{
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
name|spi
operator|->
name|bus_width
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|update_type
operator|&
name|TRM_TRANS_GOAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|spi
operator|->
name|sync_period
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|spi
operator|->
name|sync_offset
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|spi
operator|->
name|bus_width
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Calculate the geometry parameters for a device give 		 * the sector size and volume size.     		 */
case|case
name|XPT_CALC_GEOMETRY
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_CALC_GEOMETRY \n"
argument_list|)
expr_stmt|;
name|cam_calc_geometry
argument_list|(
operator|&
name|pccb
operator|->
name|ccg
argument_list|,
comment|/*extended*/
literal|1
argument_list|)
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_ENG_INQ
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_ENG_INQ \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * HBA execute engine request  		 * This structure must match SCSIIO size  		 */
case|case
name|XPT_ENG_EXEC
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_ENG_EXEC \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * XPT_EN_LUN = 0x30, Enable LUN as a target  		 * Target mode structures.  	 	 */
case|case
name|XPT_EN_LUN
case|:
comment|/* 		 * Don't (yet?) support vendor 		 * specific commands. 		 */
name|TRM_DPRINTF
argument_list|(
literal|" XPT_EN_LUN \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		* Execute target I/O request  		*/
case|case
name|XPT_TARGET_IO
case|:
comment|/* 		 * Don't (yet?) support vendor 		 * specific commands. 		 */
name|TRM_DPRINTF
argument_list|(
literal|" XPT_TARGET_IO \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Accept Host Target Mode CDB         		 */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* 		 * Don't (yet?) support vendor 		 * specific commands. 		 */
name|TRM_DPRINTF
argument_list|(
literal|" XPT_ACCEPT_TARGET_IO \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Continue Host Target I/O Connection   		 */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* 		 * Don't (yet?) support vendor 		 * specific commands. 		 */
name|TRM_DPRINTF
argument_list|(
literal|" XPT_CONT_TARGET_IO \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Notify Host Target driver of event   		 */
case|case
name|XPT_IMMED_NOTIFY
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_IMMED_NOTIFY \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Acknowledgement of event        		 */
case|case
name|XPT_NOTIFY_ACK
case|:
name|TRM_DPRINTF
argument_list|(
literal|" XPT_NOTIFY_ACK \n"
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * XPT_VUNIQUE = 0x80 		 */
case|case
name|XPT_VUNIQUE
case|:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|actionflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_poll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|psim
parameter_list|)
block|{
name|trm_Interrupt
argument_list|(
name|cam_sim_softc
argument_list|(
name|psim
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_ResetDevParam
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|,
name|pdcb
decl_stmt|;
name|PNVRAMTYPE
name|pEEpromBuf
decl_stmt|;
name|u_int8_t
name|PeriodIndex
decl_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
if|if
condition|(
name|pDCB
operator|==
name|NULL
condition|)
return|return;
name|pdcb
operator|=
name|pDCB
expr_stmt|;
do|do
block|{
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|SYNC_NEGO_DONE
operator|+
name|WIDE_NEGO_DONE
operator|)
expr_stmt|;
name|pDCB
operator|->
name|SyncPeriod
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|SyncOffset
operator|=
literal|0
expr_stmt|;
name|pEEpromBuf
operator|=
operator|&
name|trm_eepromBuf
index|[
name|pACB
operator|->
name|AdapterUnit
index|]
expr_stmt|;
name|pDCB
operator|->
name|DevMode
operator|=
name|pEEpromBuf
operator|->
name|NvramTarget
index|[
name|pDCB
operator|->
name|TargetID
index|]
operator|.
name|NvmTarCfg0
expr_stmt|;
name|pDCB
operator|->
name|AdpMode
operator|=
name|pEEpromBuf
operator|->
name|NvramChannelCfg
expr_stmt|;
name|PeriodIndex
operator|=
name|pEEpromBuf
operator|->
name|NvramTarget
index|[
name|pDCB
operator|->
name|TargetID
index|]
operator|.
name|NvmTarPeriod
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|AdaptType
operator|==
literal|1
condition|)
comment|/* is U2? */
name|pDCB
operator|->
name|MaxNegoPeriod
operator|=
name|dc395u2x_clock_period
index|[
name|PeriodIndex
index|]
expr_stmt|;
else|else
name|pDCB
operator|->
name|MaxNegoPeriod
operator|=
name|dc395x_clock_period
index|[
name|PeriodIndex
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pDCB
operator|->
name|DevMode
operator|&
name|NTC_DO_WIDE_NEGO
operator|)
operator|&&
operator|(
name|pACB
operator|->
name|Config
operator|&
name|HCC_WIDE_CARD
operator|)
condition|)
name|pDCB
operator|->
name|SyncMode
operator||=
name|WIDE_NEGO_ENABLE
expr_stmt|;
name|pDCB
operator|=
name|pDCB
operator|->
name|pNextDCB
expr_stmt|;
block|}
do|while
condition|(
name|pdcb
operator|!=
name|pDCB
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_RecoverSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|,
name|pdcb
decl_stmt|;
name|PSRB
name|psrb
decl_stmt|,
name|psrb2
decl_stmt|;
name|u_int16_t
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
if|if
condition|(
name|pDCB
operator|==
name|NULL
condition|)
return|return;
name|pdcb
operator|=
name|pDCB
expr_stmt|;
do|do
block|{
name|cnt
operator|=
name|pdcb
operator|->
name|GoingSRBCnt
expr_stmt|;
name|psrb
operator|=
name|pdcb
operator|->
name|pGoingSRB
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|psrb2
operator|=
name|psrb
expr_stmt|;
name|psrb
operator|=
name|psrb
operator|->
name|pNextSRB
expr_stmt|;
if|if
condition|(
name|pdcb
operator|->
name|pWaitingSRB
condition|)
block|{
name|psrb2
operator|->
name|pNextSRB
operator|=
name|pdcb
operator|->
name|pWaitingSRB
expr_stmt|;
name|pdcb
operator|->
name|pWaitingSRB
operator|=
name|psrb2
expr_stmt|;
block|}
else|else
block|{
name|pdcb
operator|->
name|pWaitingSRB
operator|=
name|psrb2
expr_stmt|;
name|pdcb
operator|->
name|pWaitingLastSRB
operator|=
name|psrb2
expr_stmt|;
name|psrb2
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|pdcb
operator|->
name|GoingSRBCnt
operator|=
literal|0
expr_stmt|;
name|pdcb
operator|->
name|pGoingSRB
operator|=
name|NULL
expr_stmt|;
name|pdcb
operator|=
name|pdcb
operator|->
name|pNextDCB
expr_stmt|;
block|}
do|while
condition|(
name|pdcb
operator|!=
name|pDCB
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_reset
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|int
name|intflag
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm: RESET"
argument_list|)
expr_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0x00
argument_list|,
name|TRMREG_DMA_INTEN
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0x00
argument_list|,
name|TRMREG_SCSI_INTEN
argument_list|)
expr_stmt|;
name|trm_ResetSCSIBus
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|500
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0x7F
argument_list|,
name|TRMREG_SCSI_INTEN
argument_list|)
expr_stmt|;
comment|/* Enable DMA interrupt	*/
name|trm_reg_write8
argument_list|(
name|EN_SCSIINTR
argument_list|,
name|TRMREG_DMA_INTEN
argument_list|)
expr_stmt|;
comment|/* Clear DMA FIFO */
name|trm_reg_write8
argument_list|(
name|CLRXFIFO
argument_list|,
name|TRMREG_DMA_CONTROL
argument_list|)
expr_stmt|;
comment|/* Clear SCSI FIFO */
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
name|trm_ResetDevParam
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_DoingSRB_Done
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|pActiveDCB
operator|=
name|NULL
expr_stmt|;
name|pACB
operator|->
name|ACBFlag
operator|=
literal|0
expr_stmt|;
comment|/* RESET_DETECT, RESET_DONE ,RESET_DEV */
name|trm_DoWaitingSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/* Tell the XPT layer that a bus reset occured    */
if|if
condition|(
name|pACB
operator|->
name|ppath
operator|!=
name|NULL
condition|)
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|pACB
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|trm_StartSCSI
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|u_int16_t
name|return_code
decl_stmt|;
name|u_int8_t
name|scsicommand
decl_stmt|,
name|i
decl_stmt|,
name|command
decl_stmt|,
name|identify_message
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
decl_stmt|;
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|pcsio
operator|=
operator|&
name|pccb
operator|->
name|csio
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pACB
operator|->
name|AdaptSCSIID
argument_list|,
name|TRMREG_SCSI_HOSTID
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|TargetID
argument_list|,
name|TRMREG_SCSI_TARGETID
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncPeriod
argument_list|,
name|TRMREG_SCSI_SYNC
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncOffset
argument_list|,
name|TRMREG_SCSI_OFFSET
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|ScsiPhase
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* initial phase */
comment|/* Flush FIFO */
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
name|identify_message
operator|=
name|pDCB
operator|->
name|IdentifyMsg
expr_stmt|;
if|if
condition|(
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|==
name|REQUEST_SENSE
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|SRBFlag
operator|&
name|AUTO_REQSENSE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_ENABLE
operator|)
operator|&&
operator|!
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_DONE
operator|)
operator|)
operator|||
operator|(
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
operator|)
operator|&&
operator|!
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_DONE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pDCB
operator|->
name|IdentifyMsg
operator|&
literal|7
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|!=
name|INQUIRY
operator|)
condition|)
block|{
name|scsicommand
operator|=
name|SCMD_SEL_ATNSTOP
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_MSGOUT
expr_stmt|;
goto|goto
name|polling
goto|;
block|}
block|}
comment|/*         	* Send identify message	        	*/
name|trm_reg_write8
argument_list|(
operator|(
name|identify_message
operator|&
literal|0xBF
operator|)
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|scsicommand
operator|=
name|SCMD_SEL_ATN
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_START_
expr_stmt|;
block|}
else|else
block|{
comment|/* not inquiry,request sense,auto request sense */
comment|/*  		 * Send identify message	 		 */
name|trm_reg_write8
argument_list|(
name|identify_message
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|scsicommand
operator|=
name|SCMD_SEL_ATN
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_START_
expr_stmt|;
if|if
condition|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|EN_TAG_QUEUING
condition|)
block|{
comment|/* Send Tag message */
name|trm_reg_write8
argument_list|(
name|MSG_SIMPLE_QTAG
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pSRB
operator|->
name|TagNumber
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|scsicommand
operator|=
name|SCMD_SEL_ATN3
expr_stmt|;
block|}
block|}
name|polling
label|:
comment|/* 	 * 	 Send CDB ..command block .........			 	 */
if|if
condition|(
name|pSRB
operator|->
name|SRBFlag
operator|&
name|AUTO_REQSENSE
condition|)
block|{
name|trm_reg_write8
argument_list|(
name|REQUEST_SENSE
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
operator|(
name|pDCB
operator|->
name|IdentifyMsg
operator|<<
literal|5
operator|)
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pcsio
operator|->
name|sense_len
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pSRB
operator|->
name|CmdBlock
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pSRB
operator|->
name|ScsiCmdLen
condition|;
name|i
operator|++
control|)
block|{
name|command
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|command
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|trm_reg_read16
argument_list|(
name|TRMREG_SCSI_STATUS
argument_list|)
operator|&
name|SCSIINTERRUPT
condition|)
block|{
comment|/*  	     * If trm_StartSCSI return 1 : 	     * current interrupt status is interrupt disreenable  	     * It's said that SCSI processor has more one SRB need to do,      	     * SCSI processor has been occupied by one SRB. 	     */
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_READY
expr_stmt|;
name|return_code
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/*  	   * If trm_StartSCSI return 0 : 	   * current interrupt status is interrupt enable  	   * It's said that SCSI processor is unoccupied  	   */
name|pSRB
operator|->
name|ScsiPhase
operator|=
name|SCSI_NOP1
expr_stmt|;
comment|/* SCSI bus free Phase */
name|pACB
operator|->
name|pActiveDCB
operator|=
name|pDCB
expr_stmt|;
name|pDCB
operator|->
name|pActiveSRB
operator|=
name|pSRB
expr_stmt|;
name|return_code
operator|=
literal|0
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
operator||
name|DO_HWRESELECT
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop*/
comment|/* 		 * SCSI cammand  		 */
name|trm_reg_write8
argument_list|(
name|scsicommand
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|return_code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_Interrupt
parameter_list|(
name|vpACB
parameter_list|)
name|void
modifier|*
name|vpACB
decl_stmt|;
block|{
name|PACB
name|pACB
decl_stmt|;
name|PDCB
name|pDCB
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|u_int16_t
name|phase
decl_stmt|;
name|void
function_decl|(
modifier|*
name|stateV
function_decl|)
parameter_list|(
name|PACB
parameter_list|,
name|PSRB
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|)
function_decl|;
name|u_int16_t
name|scsi_status
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|scsi_intstatus
decl_stmt|;
name|pACB
operator|=
name|vpACB
expr_stmt|;
name|scsi_status
operator|=
name|trm_reg_read16
argument_list|(
name|TRMREG_SCSI_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scsi_status
operator|&
name|SCSIINTERRUPT
operator|)
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"trm_Interrupt: TRMREG_SCSI_STATUS scsi_status = NULL ,return......"
argument_list|)
expr_stmt|;
return|return;
block|}
name|TRM_DPRINTF
argument_list|(
literal|"scsi_status=%2x,"
argument_list|,
name|scsi_status
argument_list|)
expr_stmt|;
name|scsi_intstatus
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_INTSTATUS
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"scsi_intstatus=%2x,"
argument_list|,
name|scsi_intstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_intstatus
operator|&
operator|(
name|INT_SELTIMEOUT
operator||
name|INT_DISCONNECT
operator|)
condition|)
block|{
name|trm_Disconnect
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scsi_intstatus
operator|&
name|INT_RESELECTED
condition|)
block|{
name|trm_Reselect
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scsi_intstatus
operator|&
name|INT_SCSIRESET
condition|)
block|{
name|trm_ScsiRstDetect
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scsi_intstatus
operator|&
operator|(
name|INT_BUSSERVICE
operator||
name|INT_CMDDONE
operator|)
condition|)
block|{
name|pDCB
operator|=
name|pACB
operator|->
name|pActiveDCB
expr_stmt|;
name|KASSERT
argument_list|(
name|pDCB
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no active DCB"
operator|)
argument_list|)
expr_stmt|;
name|pSRB
operator|=
name|pDCB
operator|->
name|pActiveSRB
expr_stmt|;
if|if
condition|(
name|pDCB
operator|->
name|DCBFlag
operator|&
name|ABORT_DEV_
condition|)
name|trm_EnableMsgOutAbort1
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|phase
operator|=
operator|(
name|u_int16_t
operator|)
name|pSRB
operator|->
name|ScsiPhase
expr_stmt|;
comment|/* phase: */
name|stateV
operator|=
operator|(
name|void
operator|*
operator|)
name|trm_SCSI_phase0
index|[
name|phase
index|]
expr_stmt|;
name|stateV
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
operator|&
name|scsi_status
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|ScsiPhase
operator|=
name|scsi_status
operator|&
name|PHASEMASK
expr_stmt|;
comment|/* phase:0,1,2,3,4,5,6,7 */
name|phase
operator|=
operator|(
name|u_int16_t
operator|)
name|scsi_status
operator|&
name|PHASEMASK
expr_stmt|;
name|stateV
operator|=
operator|(
name|void
operator|*
operator|)
name|trm_SCSI_phase1
index|[
name|phase
index|]
expr_stmt|;
name|stateV
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
operator|&
name|scsi_status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trm_MsgOutPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|SRBState
operator|&
operator|(
name|SRB_UNEXPECT_RESEL
operator|+
name|SRB_ABORT_SENT
operator|)
condition|)
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/*.. initial phase*/
block|}
end_function

begin_function
specifier|static
name|void
name|trm_MsgOutPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|u_int8_t
name|bval
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr
decl_stmt|;
name|PDCB
name|pDCB
decl_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pActiveDCB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_MSGOUT
operator|)
condition|)
block|{
name|cnt
operator|=
name|pSRB
operator|->
name|MsgCnt
expr_stmt|;
if|if
condition|(
name|cnt
condition|)
block|{
name|ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pSRB
operator|->
name|MsgOutBuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|trm_reg_write8
argument_list|(
operator|*
name|ptr
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pDCB
operator|->
name|DCBFlag
operator|&
name|ABORT_DEV_
operator|)
operator|&&
operator|(
name|pSRB
operator|->
name|MsgOutBuf
index|[
literal|0
index|]
operator|==
name|MSG_ABORT
operator|)
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_ABORT_SENT
expr_stmt|;
block|}
block|}
else|else
block|{
name|bval
operator|=
name|MSG_ABORT
expr_stmt|;
if|if
condition|(
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|==
name|INQUIRY
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|==
name|REQUEST_SENSE
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|SRBFlag
operator|&
name|AUTO_REQSENSE
operator|)
condition|)
block|{
if|if
condition|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
condition|)
block|{
goto|goto
name|mop1
goto|;
block|}
block|}
name|trm_reg_write8
argument_list|(
name|bval
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mop1
label|:
comment|/* message out phase */
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_DO_WIDE_NEGO
operator|)
operator|&&
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_ENABLE
operator|)
condition|)
block|{
comment|/* 	   	   * WIDE DATA TRANSFER REQUEST code (03h) 		   */
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|SYNC_NEGO_DONE
operator||
name|EN_ATN_STOP
operator|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
operator|(
name|pDCB
operator|->
name|IdentifyMsg
operator|&
literal|0xBF
operator|)
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|MSG_EXTENDED
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* (01h) */
name|trm_reg_write8
argument_list|(
literal|2
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* Message length (02h) */
name|trm_reg_write8
argument_list|(
literal|3
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* wide data xfer (03h) */
name|trm_reg_write8
argument_list|(
literal|1
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* width:0(8bit),1(16bit),2(32bit) */
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_DO_WIDE_NEGO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_DO_SYNC_NEGO
operator|)
operator|&&
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
operator|)
condition|)
block|{
comment|/* 	   	   * SYNCHRONOUS DATA TRANSFER REQUEST code (01h) 		   */
if|if
condition|(
operator|!
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_DONE
operator|)
condition|)
name|trm_reg_write8
argument_list|(
operator|(
name|pDCB
operator|->
name|IdentifyMsg
operator|&
literal|0xBF
operator|)
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|MSG_EXTENDED
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* (01h) */
name|trm_reg_write8
argument_list|(
literal|3
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* Message length (03h) */
name|trm_reg_write8
argument_list|(
literal|1
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* SYNCHRONOUS DATA TRANSFER REQUEST code (01h) */
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|MaxNegoPeriod
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* Transfer peeriod factor */
name|trm_reg_write8
argument_list|(
operator|(
name|pACB
operator|->
name|AdaptType
operator|==
literal|1
operator|)
condition|?
literal|31
else|:
literal|15
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* REQ/ACK offset */
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_DO_SYNC_NEGO
expr_stmt|;
block|}
block|}
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_FIFO_OUT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_CommandPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|trm_CommandPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|;
name|u_int8_t
modifier|*
name|ptr
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
decl_stmt|;
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|pcsio
operator|=
operator|&
name|pccb
operator|->
name|csio
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_CLRATN
operator||
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBFlag
operator|&
name|AUTO_REQSENSE
operator|)
condition|)
block|{
name|cnt
operator|=
operator|(
name|u_int16_t
operator|)
name|pSRB
operator|->
name|ScsiCmdLen
expr_stmt|;
name|ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pSRB
operator|->
name|CmdBlock
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|trm_reg_write8
argument_list|(
operator|*
name|ptr
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|trm_reg_write8
argument_list|(
name|REQUEST_SENSE
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pActiveDCB
expr_stmt|;
comment|/* target id */
name|trm_reg_write8
argument_list|(
operator|(
name|pDCB
operator|->
name|IdentifyMsg
operator|<<
literal|5
operator|)
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
comment|/* sizeof(struct scsi_sense_data) */
name|trm_reg_write8
argument_list|(
name|pcsio
operator|->
name|sense_len
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
block|}
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_COMMAND
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop*/
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_FIFO_OUT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DataOutPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|;
name|u_int8_t
name|TempDMAstatus
decl_stmt|,
name|SGIndexTemp
decl_stmt|;
name|u_int16_t
name|scsi_status
decl_stmt|;
name|PSEG
name|pseg
decl_stmt|;
name|u_long
name|TempSRBXferredLength
decl_stmt|,
name|dLeftCounter
init|=
literal|0
decl_stmt|;
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
name|scsi_status
operator|=
operator|*
name|pscsi_status
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_XFERPAD
operator|)
condition|)
block|{
if|if
condition|(
name|scsi_status
operator|&
name|PARITYERROR
condition|)
name|pSRB
operator|->
name|SRBStatus
operator||=
name|PARITY_ERROR
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scsi_status
operator|&
name|SCSIXFERDONE
operator|)
condition|)
block|{
comment|/* 		   * when data transfer from DMA FIFO to SCSI FIFO 		   * if there was some data left in SCSI FIFO 		   */
name|dLeftCounter
operator|=
call|(
name|u_long
call|)
argument_list|(
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_FIFOCNT
argument_list|)
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
if|if
condition|(
name|pDCB
operator|->
name|SyncPeriod
operator|&
name|WIDE_SYNC
condition|)
block|{
comment|/* 		   	   * if WIDE scsi SCSI FIFOCNT unit is word 	   		   * so need to * 2    			   */
name|dLeftCounter
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 		 * caculate all the residue data that not yet tranfered 		 * SCSI transfer counter + left in SCSI FIFO data 		 * 		 * .....TRM_SCSI_COUNTER (24bits) 		 * The counter always decrement by one for every SCSI byte  		 *transfer. 		 * .....TRM_SCSI_FIFOCNT (5bits) 		 * The counter is SCSI FIFO offset counter 		 */
name|dLeftCounter
operator|+=
name|trm_reg_read32
argument_list|(
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dLeftCounter
operator|==
literal|1
condition|)
block|{
name|dLeftCounter
operator|=
literal|0
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dLeftCounter
operator|==
literal|0
operator|)
operator|||
operator|(
name|scsi_status
operator|&
name|SCSIXFERCNT_2_ZERO
operator|)
condition|)
block|{
name|TempDMAstatus
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_DMA_STATUS
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|TempDMAstatus
operator|&
name|DMAXFERCOMP
operator|)
condition|)
block|{
name|TempDMAstatus
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_DMA_STATUS
argument_list|)
expr_stmt|;
block|}
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Update SG list		*/
comment|/* 	   	   * if transfer not yet complete    		   * there were some data residue in SCSI FIFO or 		   * SCSI transfer counter not empty 		   */
if|if
condition|(
name|pSRB
operator|->
name|SRBTotalXferLength
operator|!=
name|dLeftCounter
condition|)
block|{
comment|/* 		  	   * data that had transferred length 	   		   */
name|TempSRBXferredLength
operator|=
name|pSRB
operator|->
name|SRBTotalXferLength
operator|-
name|dLeftCounter
expr_stmt|;
comment|/* 				 * next time to be transferred length 				 */
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
name|dLeftCounter
expr_stmt|;
comment|/* 				 * parsing from last time disconnect SRBSGIndex 				 */
name|pseg
operator|=
name|pSRB
operator|->
name|pSRBSGL
operator|+
name|pSRB
operator|->
name|SRBSGIndex
expr_stmt|;
for|for
control|(
name|SGIndexTemp
operator|=
name|pSRB
operator|->
name|SRBSGIndex
init|;
name|SGIndexTemp
operator|<
name|pSRB
operator|->
name|SRBSGCount
condition|;
name|SGIndexTemp
operator|++
control|)
block|{
comment|/*  					 * find last time which SG transfer be  					 * disconnect  					 */
if|if
condition|(
name|TempSRBXferredLength
operator|>=
name|pseg
operator|->
name|length
condition|)
name|TempSRBXferredLength
operator|-=
name|pseg
operator|->
name|length
expr_stmt|;
else|else
block|{
comment|/* 			   		   * update last time disconnected SG  					   * list 				   	   */
name|pseg
operator|->
name|length
operator|-=
name|TempSRBXferredLength
expr_stmt|;
comment|/* residue data length  */
name|pseg
operator|->
name|address
operator|+=
name|TempSRBXferredLength
expr_stmt|;
comment|/* residue data pointer */
name|pSRB
operator|->
name|SRBSGIndex
operator|=
name|SGIndexTemp
expr_stmt|;
break|break;
block|}
name|pseg
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|trm_reg_write8
argument_list|(
name|STOPDMAXFER
argument_list|,
name|TRMREG_DMA_CONTROL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DataOutPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|u_int16_t
name|ioDir
decl_stmt|;
comment|/* 	 * do prepare befor transfer when data out phase 	 */
name|ioDir
operator|=
name|XFERDATAOUT
expr_stmt|;
name|trm_DataIO_transfer
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|ioDir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DataInPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|u_int8_t
name|TempDMAstatus
decl_stmt|,
name|SGIndexTemp
decl_stmt|;
name|u_int16_t
name|scsi_status
decl_stmt|;
name|PSEG
name|pseg
decl_stmt|;
name|u_long
name|TempSRBXferredLength
decl_stmt|,
name|dLeftCounter
init|=
literal|0
decl_stmt|;
name|scsi_status
operator|=
operator|*
name|pscsi_status
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_XFERPAD
operator|)
condition|)
block|{
if|if
condition|(
name|scsi_status
operator|&
name|PARITYERROR
condition|)
name|pSRB
operator|->
name|SRBStatus
operator||=
name|PARITY_ERROR
expr_stmt|;
name|dLeftCounter
operator|+=
name|trm_reg_read32
argument_list|(
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dLeftCounter
operator|==
literal|0
operator|)
operator|||
operator|(
name|scsi_status
operator|&
name|SCSIXFERCNT_2_ZERO
operator|)
condition|)
block|{
name|TempDMAstatus
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_DMA_STATUS
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|TempDMAstatus
operator|&
name|DMAXFERCOMP
operator|)
condition|)
name|TempDMAstatus
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_DMA_STATUS
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*    		   * parsing the case: 	   	   * when a transfer not yet complete  	   	   * but be disconnected by uper layer 	   	   * if transfer not yet complete 	   	   * there were some data residue in SCSI FIFO or 	   	   * SCSI transfer counter not empty 	   	   */
if|if
condition|(
name|pSRB
operator|->
name|SRBTotalXferLength
operator|!=
name|dLeftCounter
condition|)
block|{
comment|/* 				 * data that had transferred length 				 */
name|TempSRBXferredLength
operator|=
name|pSRB
operator|->
name|SRBTotalXferLength
operator|-
name|dLeftCounter
expr_stmt|;
comment|/* 			 	 * next time to be transferred length 				 */
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
name|dLeftCounter
expr_stmt|;
comment|/* 				 * parsing from last time disconnect SRBSGIndex 				 */
name|pseg
operator|=
name|pSRB
operator|->
name|pSRBSGL
operator|+
name|pSRB
operator|->
name|SRBSGIndex
expr_stmt|;
for|for
control|(
name|SGIndexTemp
operator|=
name|pSRB
operator|->
name|SRBSGIndex
init|;
name|SGIndexTemp
operator|<
name|pSRB
operator|->
name|SRBSGCount
condition|;
name|SGIndexTemp
operator|++
control|)
block|{
comment|/*  	   		   * find last time which SG transfer be disconnect  	   		   */
if|if
condition|(
name|TempSRBXferredLength
operator|>=
name|pseg
operator|->
name|length
condition|)
name|TempSRBXferredLength
operator|-=
name|pseg
operator|->
name|length
expr_stmt|;
else|else
block|{
comment|/*    				   * update last time disconnected SG list 				   */
name|pseg
operator|->
name|length
operator|-=
name|TempSRBXferredLength
expr_stmt|;
comment|/* residue data length  */
name|pseg
operator|->
name|address
operator|+=
name|TempSRBXferredLength
expr_stmt|;
comment|/* residue data pointer */
name|pSRB
operator|->
name|SRBSGIndex
operator|=
name|SGIndexTemp
expr_stmt|;
break|break;
block|}
name|pseg
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DataInPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|u_int16_t
name|ioDir
decl_stmt|;
comment|/* 	 * do prepare befor transfer when data in phase 	 */
name|ioDir
operator|=
name|XFERDATAIN
expr_stmt|;
name|trm_DataIO_transfer
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|ioDir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DataIO_transfer
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
name|ioDir
parameter_list|)
block|{
name|u_int8_t
name|bval
decl_stmt|;
name|PDCB
name|pDCB
decl_stmt|;
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|SRBSGIndex
operator|<
name|pSRB
operator|->
name|SRBSGCount
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|SRBTotalXferLength
operator|!=
literal|0
condition|)
block|{
comment|/*  			 * load what physical address of Scatter/Gather list  			 table want to be transfer 			 */
name|TRM_DPRINTF
argument_list|(
literal|" SG->address=%8x \n"
argument_list|,
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|address
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" SG->length=%8x \n"
argument_list|,
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|length
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" pDCB->SyncPeriod=%x \n"
argument_list|,
name|pDCB
operator|->
name|SyncPeriod
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" pSRB->pSRBSGL=%8x \n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|pSRB
operator|->
name|pSRBSGL
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" pSRB->SRBSGPhyAddr=%8x \n"
argument_list|,
name|pSRB
operator|->
name|SRBSGPhyAddr
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" pSRB->SRBSGIndex=%d \n"
argument_list|,
name|pSRB
operator|->
name|SRBSGIndex
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" pSRB->SRBSGCount=%d \n"
argument_list|,
name|pSRB
operator|->
name|SRBSGCount
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|" pSRB->SRBTotalXferLength=%d \n"
argument_list|,
name|pSRB
operator|->
name|SRBTotalXferLength
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_DATA_XFER
expr_stmt|;
name|trm_reg_write32
argument_list|(
literal|0
argument_list|,
name|TRMREG_DMA_XHIGHADDR
argument_list|)
expr_stmt|;
name|trm_reg_write32
argument_list|(
operator|(
name|pSRB
operator|->
name|SRBSGPhyAddr
operator|+
operator|(
operator|(
name|u_long
operator|)
name|pSRB
operator|->
name|SRBSGIndex
operator|<<
literal|3
operator|)
operator|)
argument_list|,
name|TRMREG_DMA_XLOWADDR
argument_list|)
expr_stmt|;
comment|/* 			 * load how many bytes in the Scatter/Gather  			 * list table  			 */
name|trm_reg_write32
argument_list|(
operator|(
call|(
name|u_long
call|)
argument_list|(
name|pSRB
operator|->
name|SRBSGCount
operator|-
name|pSRB
operator|->
name|SRBSGIndex
argument_list|)
operator|<<
literal|3
operator|)
argument_list|,
name|TRMREG_DMA_XCNT
argument_list|)
expr_stmt|;
comment|/* 			 * load total transfer length (24bits) max value 			 * 16Mbyte  			 */
name|trm_reg_write32
argument_list|(
name|pSRB
operator|->
name|SRBTotalXferLength
argument_list|,
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
comment|/* Start DMA transfer */
name|trm_reg_write16
argument_list|(
name|ioDir
argument_list|,
name|TRMREG_DMA_COMMAND
argument_list|)
expr_stmt|;
comment|/* Start SCSI transfer */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 			 * SCSI cammand  			 */
name|bval
operator|=
operator|(
name|ioDir
operator|==
name|XFERDATAOUT
operator|)
condition|?
name|SCMD_DMA_OUT
else|:
name|SCMD_DMA_IN
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|bval
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* xfer pad */
if|if
condition|(
name|pSRB
operator|->
name|SRBSGCount
condition|)
block|{
name|pSRB
operator|->
name|AdaptStatus
operator|=
name|H_OVER_UNDER_RUN
expr_stmt|;
name|pSRB
operator|->
name|SRBStatus
operator||=
name|OVER_RUN
expr_stmt|;
block|}
if|if
condition|(
name|pDCB
operator|->
name|SyncPeriod
operator|&
name|WIDE_SYNC
condition|)
name|trm_reg_write32
argument_list|(
literal|2
argument_list|,
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
else|else
name|trm_reg_write32
argument_list|(
literal|1
argument_list|,
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioDir
operator|==
name|XFERDATAOUT
condition|)
name|trm_reg_write16
argument_list|(
literal|0
argument_list|,
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
else|else
name|trm_reg_read16
argument_list|(
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_XFERPAD
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 			 * SCSI cammand  			 */
name|bval
operator|=
operator|(
name|ioDir
operator|==
name|XFERDATAOUT
operator|)
condition|?
name|SCMD_FIFO_OUT
else|:
name|SCMD_FIFO_IN
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|bval
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trm_StatusPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|pSRB
operator|->
name|TargetStatus
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_COMPLETED
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/*.. initial phase*/
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_StatusPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
if|if
condition|(
name|trm_reg_read16
argument_list|(
name|TRMREG_DMA_COMMAND
argument_list|)
operator|&
literal|0x0001
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_FIFOCNT
argument_list|)
operator|&
literal|0x40
operator|)
condition|)
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|trm_reg_read16
argument_list|(
name|TRMREG_DMA_FIFOCNT
argument_list|)
operator|&
literal|0x8000
operator|)
condition|)
name|trm_reg_write8
argument_list|(
name|CLRXFIFO
argument_list|,
name|TRMREG_DMA_CONTROL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|trm_reg_read16
argument_list|(
name|TRMREG_DMA_FIFOCNT
argument_list|)
operator|&
literal|0x8000
operator|)
condition|)
name|trm_reg_write8
argument_list|(
name|CLRXFIFO
argument_list|,
name|TRMREG_DMA_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_FIFOCNT
argument_list|)
operator|&
literal|0x40
operator|)
condition|)
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
block|}
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_STATUS
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_COMP
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *scsiiom		   *       trm_MsgInPhase0: one of trm_SCSI_phase0[] vectors  *            stateV = (void *) trm_SCSI_phase0[phase]  *		           if phase =7      * extended message codes:  *  *   code        description  *  *    02h        Reserved  *    00h        MODIFY DATA  POINTER  *    01h        SYNCHRONOUS DATA TRANSFER REQUEST  *    03h        WIDE DATA TRANSFER REQUEST  * 04h - 7Fh     Reserved  * 80h - FFh     Vendor specific    *		          */
end_comment

begin_function
specifier|static
name|void
name|trm_MsgInPhase0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|u_int8_t
name|message_in_code
decl_stmt|,
name|bIndex
decl_stmt|,
name|message_in_tag_id
decl_stmt|;
name|PDCB
name|pDCB
decl_stmt|;
name|PSRB
name|pSRBTemp
decl_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pActiveDCB
expr_stmt|;
name|message_in_code
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_EXTEND_MSGIN
operator|)
condition|)
block|{
if|if
condition|(
name|message_in_code
operator|==
name|MSG_DISCONNECT
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_DISCONNECT
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|message_in_code
operator|==
name|MSG_SAVE_PTR
condition|)
block|{
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|message_in_code
operator|==
name|MSG_EXTENDED
operator|)
operator|||
operator|(
operator|(
name|message_in_code
operator|>=
name|MSG_SIMPLE_QTAG
operator|)
operator|&&
operator|(
name|message_in_code
operator|<=
name|MSG_ORDER_QTAG
operator|)
operator|)
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_EXTEND_MSGIN
expr_stmt|;
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|=
name|message_in_code
expr_stmt|;
comment|/* extended message      (01h) */
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|1
expr_stmt|;
name|pSRB
operator|->
name|pMsgPtr
operator|=
operator|&
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|1
index|]
expr_stmt|;
comment|/* extended message length (n) */
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|message_in_code
operator|==
name|MSG_REJECT_
condition|)
block|{
comment|/* Reject message */
if|if
condition|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_ENABLE
condition|)
block|{
comment|/* do wide nego reject */
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator||=
name|WIDE_NEGO_DONE
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|SYNC_NEGO_DONE
operator||
name|EN_ATN_STOP
operator||
name|WIDE_NEGO_ENABLE
operator|)
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|&=
operator|~
operator|(
name|SRB_DO_WIDE_NEGO
operator|+
name|SRB_MSGIN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
operator|)
operator|&&
operator|!
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_DONE
operator|)
condition|)
block|{
comment|/* Set ATN, in case ATN was clear */
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_MSGOUT
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_SETATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Clear ATN */
name|trm_reg_write16
argument_list|(
name|DO_CLRATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
condition|)
block|{
comment|/* do sync nego reject */
name|trm_reg_write16
argument_list|(
name|DO_CLRATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_DO_SYNC_NEGO
condition|)
block|{
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|SYNC_NEGO_ENABLE
operator|+
name|SYNC_NEGO_DONE
operator|)
expr_stmt|;
name|pDCB
operator|->
name|SyncPeriod
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|SyncOffset
operator|=
literal|0
expr_stmt|;
comment|/*                					 * 					 *   program SCSI control register 					 * 					 */
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncPeriod
argument_list|,
name|TRMREG_SCSI_SYNC
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncOffset
argument_list|,
name|TRMREG_SCSI_OFFSET
argument_list|)
expr_stmt|;
name|trm_SetXferRate
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|pDCB
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|message_in_code
operator|==
name|MSG_IGNOREWIDE
condition|)
block|{
name|trm_reg_write32
argument_list|(
literal|1
argument_list|,
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_FIFO
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Restore data pointer message */
comment|/* Save data pointer message	  */
comment|/* Completion message		  */
comment|/* NOP message       	          */
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/*     	   * Parsing incomming extented messages  	   */
operator|*
name|pSRB
operator|->
name|pMsgPtr
operator|=
name|message_in_code
expr_stmt|;
name|pSRB
operator|->
name|MsgCnt
operator|++
expr_stmt|;
name|pSRB
operator|->
name|pMsgPtr
operator|++
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pSRB->MsgInBuf[0]=%2x \n "
argument_list|,
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pSRB->MsgInBuf[1]=%2x \n "
argument_list|,
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pSRB->MsgInBuf[2]=%2x \n "
argument_list|,
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pSRB->MsgInBuf[3]=%2x \n "
argument_list|,
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"pSRB->MsgInBuf[4]=%2x \n "
argument_list|,
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|>=
name|MSG_SIMPLE_QTAG
operator|)
operator|&&
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|<=
name|MSG_ORDER_QTAG
operator|)
condition|)
block|{
comment|/* 	   	   * is QUEUE tag message :    		   * 	   	   * byte 0: 	   	   * HEAD    QUEUE TAG (20h) 	   	   * ORDERED QUEUE TAG (21h) 	   	   * SIMPLE  QUEUE TAG (22h) 	   	   * byte 1: 	   	   * Queue tag (00h - FFh) 	   	   */
if|if
condition|(
name|pSRB
operator|->
name|MsgCnt
operator|==
literal|2
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
literal|0
expr_stmt|;
name|message_in_tag_id
operator|=
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|1
index|]
expr_stmt|;
name|pSRB
operator|=
name|pDCB
operator|->
name|pGoingSRB
expr_stmt|;
name|pSRBTemp
operator|=
name|pDCB
operator|->
name|pGoingLastSRB
expr_stmt|;
if|if
condition|(
name|pSRB
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|TagNumber
operator|!=
name|message_in_tag_id
condition|)
block|{
if|if
condition|(
name|pSRB
operator|==
name|pSRBTemp
condition|)
block|{
goto|goto
name|mingx0
goto|;
block|}
name|pSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|pDCB
operator|->
name|DCBFlag
operator|&
name|ABORT_DEV_
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_ABORT_SENT
expr_stmt|;
name|trm_EnableMsgOutAbort1
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_DISCONNECT
operator|)
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"SRB not yet disconnect........ \n "
argument_list|)
expr_stmt|;
goto|goto
name|mingx0
goto|;
block|}
name|pDCB
operator|->
name|pActiveSRB
operator|=
name|pSRB
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_DATA_XFER
expr_stmt|;
block|}
else|else
block|{
name|mingx0
label|:
name|pSRB
operator|=
operator|&
name|pACB
operator|->
name|TmpSRB
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_UNEXPECT_RESEL
expr_stmt|;
name|pDCB
operator|->
name|pActiveSRB
operator|=
name|pSRB
expr_stmt|;
name|pSRB
operator|->
name|MsgOutBuf
index|[
literal|0
index|]
operator|=
name|MSG_ABORT_TAG
expr_stmt|;
name|trm_EnableMsgOutAbort2
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 			 * SCSI command  			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|==
name|MSG_EXTENDED
operator|)
operator|&&
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|2
index|]
operator|==
literal|3
operator|)
operator|&&
operator|(
name|pSRB
operator|->
name|MsgCnt
operator|==
literal|4
operator|)
condition|)
block|{
comment|/* 	   	   * is Wide data xfer Extended message : 	   	   * ====================================== 	   	   * WIDE DATA TRANSFER REQUEST    		   * ====================================== 		   * byte 0 :  Extended message (01h) 		   * byte 1 :  Extended message length (02h) 		   * byte 2 :  WIDE DATA TRANSFER code (03h) 		   * byte 3 :  Transfer width exponent  		   */
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|&=
operator|~
operator|(
name|SRB_EXTEND_MSGIN
operator|+
name|SRB_DO_WIDE_NEGO
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|1
index|]
operator|!=
literal|2
operator|)
condition|)
block|{
comment|/* Length is wrong, reject it  */
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|WIDE_NEGO_ENABLE
operator|+
name|WIDE_NEGO_DONE
operator|)
expr_stmt|;
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|1
expr_stmt|;
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|=
name|MSG_REJECT_
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_SETATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 				 * SCSI command 				 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_ENABLE
condition|)
block|{
comment|/* Do wide negoniation */
if|if
condition|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|>
literal|2
condition|)
block|{
comment|/*> 32 bit	*/
comment|/* reject_msg: */
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|WIDE_NEGO_ENABLE
operator|+
name|WIDE_NEGO_DONE
operator|)
expr_stmt|;
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|1
expr_stmt|;
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|=
name|MSG_REJECT_
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_SETATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 					 * SCSI command 					 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|==
literal|2
condition|)
block|{
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
comment|/* do 16 bits	*/
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_DONE
operator|)
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|&=
operator|~
operator|(
name|SRB_DO_WIDE_NEGO
operator|+
name|SRB_MSGIN
operator|)
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator||=
name|WIDE_NEGO_DONE
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|SYNC_NEGO_DONE
operator||
name|EN_ATN_STOP
operator||
name|WIDE_NEGO_ENABLE
operator|)
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* is Wide data xfer */
name|pDCB
operator|->
name|SyncPeriod
operator||=
name|WIDE_SYNC
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_16_BIT
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_MSGOUT
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_SETATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
comment|/* it's important for atn stop */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* 			 * SCSI command 			 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|==
name|MSG_EXTENDED
operator|)
operator|&&
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|2
index|]
operator|==
literal|1
operator|)
operator|&&
operator|(
name|pSRB
operator|->
name|MsgCnt
operator|==
literal|5
operator|)
condition|)
block|{
comment|/* 			 * is 8bit transfer Extended message : 			 * ================================= 			 * SYNCHRONOUS DATA TRANSFER REQUEST 			 * ================================= 			 * byte 0 :  Extended message (01h) 			 * byte 1 :  Extended message length (03) 			 * byte 2 :  SYNCHRONOUS DATA TRANSFER code (01h) 			 * byte 3 :  Transfer period factor  			 * byte 4 :  REQ/ACK offset   			 */
name|pSRB
operator|->
name|SRBState
operator|&=
operator|~
operator|(
name|SRB_EXTEND_MSGIN
operator|+
name|SRB_DO_SYNC_NEGO
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|1
index|]
operator|!=
literal|3
operator|)
operator|||
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|2
index|]
operator|!=
literal|1
operator|)
condition|)
block|{
comment|/* reject_msg: */
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|1
expr_stmt|;
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|0
index|]
operator|=
name|MSG_REJECT_
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_SETATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 				 * SCSI cammand  				 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|)
operator|||
operator|!
operator|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|4
index|]
operator|)
condition|)
block|{
comment|/* set async */
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
comment|/* disable sync& sync nego */
name|pDCB
operator|->
name|SyncMode
operator|&=
operator|~
operator|(
name|SYNC_NEGO_ENABLE
operator|+
name|SYNC_NEGO_DONE
operator|)
expr_stmt|;
name|pDCB
operator|->
name|SyncPeriod
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|SyncOffset
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
comment|/*                				 * 				 *   program SCSI control register 				 * 				 */
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncPeriod
argument_list|,
name|TRMREG_SCSI_SYNC
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncOffset
argument_list|,
name|TRMREG_SCSI_OFFSET
argument_list|)
expr_stmt|;
name|trm_SetXferRate
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|pDCB
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 				 * SCSI cammand  				 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* set sync */
name|pDCB
operator|=
name|pSRB
operator|->
name|pSRBDCB
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator||=
name|SYNC_NEGO_ENABLE
operator|+
name|SYNC_NEGO_DONE
expr_stmt|;
name|pDCB
operator|->
name|MaxNegoPeriod
operator|=
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
expr_stmt|;
comment|/* Transfer period factor */
name|pDCB
operator|->
name|SyncOffset
operator|=
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|4
index|]
expr_stmt|;
comment|/* REQ/ACK offset */
if|if
condition|(
name|pACB
operator|->
name|AdaptType
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|bIndex
operator|=
literal|0
init|;
name|bIndex
operator|<
literal|7
condition|;
name|bIndex
operator|++
control|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|<=
name|dc395u2x_clock_period
index|[
name|bIndex
index|]
condition|)
block|{
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|dc395u2x_tinfo_period
index|[
name|bIndex
index|]
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|dc395u2x_tinfo_period
index|[
name|bIndex
index|]
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|pDCB
operator|->
name|SyncOffset
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|pDCB
operator|->
name|SyncOffset
expr_stmt|;
name|pDCB
operator|->
name|SyncPeriod
operator||=
operator|(
name|bIndex
operator||
name|LVDS_SYNC
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|bIndex
operator|=
literal|0
init|;
name|bIndex
operator|<
literal|7
condition|;
name|bIndex
operator|++
control|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|MsgInBuf
index|[
literal|3
index|]
operator|<=
name|dc395x_clock_period
index|[
name|bIndex
index|]
condition|)
block|{
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
name|dc395x_tinfo_period
index|[
name|bIndex
index|]
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
name|dc395x_tinfo_period
index|[
name|bIndex
index|]
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
name|pDCB
operator|->
name|SyncOffset
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
name|pDCB
operator|->
name|SyncOffset
expr_stmt|;
name|pDCB
operator|->
name|SyncPeriod
operator||=
operator|(
name|bIndex
operator||
name|ALT_SYNC
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*                				 * 	 			 *   program SCSI control register 	 			 * 	 			 */
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncPeriod
argument_list|,
name|TRMREG_SCSI_SYNC
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncOffset
argument_list|,
name|TRMREG_SCSI_OFFSET
argument_list|)
expr_stmt|;
name|trm_SetXferRate
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|,
name|pDCB
argument_list|)
expr_stmt|;
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/*.. initial phase*/
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop*/
comment|/* 	            ** SCSI command  	            */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|*
name|pscsi_status
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* .. initial phase */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop */
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trm_MsgInPhase1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
name|trm_reg_write32
argument_list|(
literal|1
argument_list|,
name|TRMREG_SCSI_COUNTER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_MSGIN
operator|)
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|&=
name|SRB_DISCONNECT
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator||=
name|SRB_MSGIN
expr_stmt|;
block|}
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop*/
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_FIFO_IN
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_Nop0
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|trm_Nop1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|u_int16_t
modifier|*
name|pscsi_status
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|trm_SetXferRate
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|struct
name|ccb_trans_settings
name|neg
decl_stmt|;
name|u_int16_t
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|u_int8_t
name|bval
decl_stmt|;
name|PDCB
name|pDCBTemp
decl_stmt|;
comment|/* 	 * set all lun device's  period , offset 	 */
name|TRM_DPRINTF
argument_list|(
literal|"trm_SetXferRate\n"
argument_list|)
expr_stmt|;
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|memset
argument_list|(
operator|&
name|neg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|sync_period
operator|=
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|sync_offset
operator|=
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
expr_stmt|;
name|neg
operator|.
name|xport_specific
operator|.
name|spi
operator|.
name|valid
operator|=
name|CTS_SPI_VALID_SYNC_RATE
operator||
name|CTS_SPI_VALID_SYNC_OFFSET
expr_stmt|;
name|xpt_setup_ccb
argument_list|(
operator|&
name|neg
operator|.
name|ccb_h
argument_list|,
name|pccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
comment|/* priority */
literal|1
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_TRANSFER_NEG
argument_list|,
name|pccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
operator|&
name|neg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pDCB
operator|->
name|IdentifyMsg
operator|&
literal|0x07
operator|)
condition|)
block|{
name|pDCBTemp
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
name|cnt
operator|=
name|pACB
operator|->
name|DeviceCnt
expr_stmt|;
name|bval
operator|=
name|pDCB
operator|->
name|TargetID
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pDCBTemp
operator|->
name|TargetID
operator|==
name|bval
condition|)
block|{
name|pDCBTemp
operator|->
name|SyncPeriod
operator|=
name|pDCB
operator|->
name|SyncPeriod
expr_stmt|;
name|pDCBTemp
operator|->
name|SyncOffset
operator|=
name|pDCB
operator|->
name|SyncOffset
expr_stmt|;
name|pDCBTemp
operator|->
name|SyncMode
operator|=
name|pDCB
operator|->
name|SyncMode
expr_stmt|;
block|}
name|pDCBTemp
operator|=
name|pDCBTemp
operator|->
name|pNextDCB
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * scsiiom		  *            trm_Interrupt         *		          *  *    ---SCSI bus phase  *  * 	PH_DATA_OUT	        0x00	 Data out phase	                * 	PH_DATA_IN	        0x01	 Data in phase	              * 	PH_COMMAND	        0x02	 Command phase	   * 	PH_STATUS	        0x03	 Status phase  *	PH_BUS_FREE	        0x04	 Invalid phase used as bus free	  * 	PH_BUS_FREE	        0x05	 Invalid phase used as bus free	  * 	PH_MSG_OUT	        0x06	 Message out phase  * 	PH_MSG_IN	        0x07	 Message in phase  *  */
end_comment

begin_function
specifier|static
name|void
name|trm_Disconnect
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|,
name|psrb
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cnt
decl_stmt|;
name|u_int
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm_Disconnect...............\n "
argument_list|)
expr_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pActiveDCB
expr_stmt|;
if|if
condition|(
operator|!
name|pDCB
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|" Exception Disconnect DCB=NULL..............\n "
argument_list|)
expr_stmt|;
name|j
operator|=
literal|400
expr_stmt|;
while|while
condition|(
operator|--
name|j
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 msec */
name|trm_reg_write16
argument_list|(
operator|(
name|DO_CLRFIFO
operator||
name|DO_HWRESELECT
operator|)
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
return|return;
block|}
name|pSRB
operator|=
name|pDCB
operator|->
name|pActiveSRB
expr_stmt|;
comment|/* bug pSRB=0 */
name|target_id
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|target_lun
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|":pDCB->pActiveSRB= %8x \n "
argument_list|,
operator|(
name|u_int
operator|)
name|pDCB
operator|->
name|pActiveSRB
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|pActiveDCB
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|ScsiPhase
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* SCSI bus free Phase */
name|trm_reg_write16
argument_list|(
operator|(
name|DO_CLRFIFO
operator||
name|DO_HWRESELECT
operator|)
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_UNEXPECT_RESEL
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
literal|0
expr_stmt|;
name|trm_DoWaitingSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_ABORT_SENT
condition|)
block|{
name|pDCB
operator|->
name|DCBFlag
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
name|pDCB
operator|->
name|GoingSRBCnt
expr_stmt|;
name|pDCB
operator|->
name|GoingSRBCnt
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|=
name|pDCB
operator|->
name|pGoingSRB
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|psrb
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
name|pSRB
operator|->
name|pNextSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
name|pACB
operator|->
name|pFreeSRB
operator|=
name|pSRB
expr_stmt|;
name|pSRB
operator|=
name|psrb
expr_stmt|;
block|}
name|pDCB
operator|->
name|pGoingSRB
operator|=
literal|0
expr_stmt|;
name|trm_DoWaitingSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
operator|(
name|SRB_START_
operator|+
name|SRB_MSGOUT
operator|)
operator|)
operator|||
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
operator|(
name|SRB_DISCONNECT
operator|+
name|SRB_COMPLETED
operator|)
operator|)
condition|)
block|{
comment|/* Selection time out */
if|if
condition|(
operator|!
operator|(
name|pACB
operator|->
name|scan_devices
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
operator|)
operator|&&
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|!=
literal|0x00
operator|&&
comment|/* TEST UNIT READY */
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|!=
name|INQUIRY
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_READY
expr_stmt|;
name|trm_RewaitSRB
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pSRB
operator|->
name|TargetStatus
operator|=
name|SCSI_STAT_SEL_TIMEOUT
expr_stmt|;
goto|goto
name|disc1
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_DISCONNECT
condition|)
block|{
comment|/* 			 * SRB_DISCONNECT 			 */
name|trm_DoWaitingSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_COMPLETED
condition|)
block|{
name|disc1
label|:
comment|/* 		   * SRB_COMPLETED 		   */
name|pDCB
operator|->
name|pActiveSRB
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_FREE
expr_stmt|;
name|trm_SRBdone
argument_list|(
name|pACB
argument_list|,
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_Reselect
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|u_int16_t
name|RselTarLunId
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm_Reselect................. \n"
argument_list|)
expr_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pActiveDCB
expr_stmt|;
if|if
condition|(
name|pDCB
condition|)
block|{
comment|/* Arbitration lost but Reselection win */
name|pSRB
operator|=
name|pDCB
operator|->
name|pActiveSRB
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_READY
expr_stmt|;
name|trm_RewaitSRB
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
comment|/* Read Reselected Target Id and LUN */
name|RselTarLunId
operator|=
name|trm_reg_read16
argument_list|(
name|TRMREG_SCSI_TARGETID
argument_list|)
operator|&
literal|0x1FFF
expr_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
while|while
condition|(
name|RselTarLunId
operator|!=
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|pDCB
operator|->
name|TargetID
operator|)
condition|)
block|{
comment|/* get pDCB of the reselect id */
name|pDCB
operator|=
name|pDCB
operator|->
name|pNextDCB
expr_stmt|;
block|}
name|pACB
operator|->
name|pActiveDCB
operator|=
name|pDCB
expr_stmt|;
if|if
condition|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|EN_TAG_QUEUING
condition|)
block|{
name|pSRB
operator|=
operator|&
name|pACB
operator|->
name|TmpSRB
expr_stmt|;
name|pDCB
operator|->
name|pActiveSRB
operator|=
name|pSRB
expr_stmt|;
block|}
else|else
block|{
name|pSRB
operator|=
name|pDCB
operator|->
name|pActiveSRB
expr_stmt|;
if|if
condition|(
operator|!
name|pSRB
operator|||
operator|!
operator|(
name|pSRB
operator|->
name|SRBState
operator|&
name|SRB_DISCONNECT
operator|)
condition|)
block|{
comment|/* 	   	   * abort command    		   */
name|pSRB
operator|=
operator|&
name|pACB
operator|->
name|TmpSRB
expr_stmt|;
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_UNEXPECT_RESEL
expr_stmt|;
name|pDCB
operator|->
name|pActiveSRB
operator|=
name|pSRB
expr_stmt|;
name|trm_EnableMsgOutAbort1
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pDCB
operator|->
name|DCBFlag
operator|&
name|ABORT_DEV_
condition|)
block|{
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_ABORT_SENT
expr_stmt|;
name|trm_EnableMsgOutAbort1
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
else|else
name|pSRB
operator|->
name|SRBState
operator|=
name|SRB_DATA_XFER
expr_stmt|;
block|}
block|}
name|pSRB
operator|->
name|ScsiPhase
operator|=
name|PH_BUS_FREE
expr_stmt|;
comment|/* SCSI bus free Phase */
comment|/*  	 * Program HA ID, target ID, period and offset 	 */
name|trm_reg_write8
argument_list|(
operator|(
name|u_int8_t
operator|)
name|RselTarLunId
argument_list|,
name|TRMREG_SCSI_TARGETID
argument_list|)
expr_stmt|;
comment|/* target ID */
name|trm_reg_write8
argument_list|(
name|pACB
operator|->
name|AdaptSCSIID
argument_list|,
name|TRMREG_SCSI_HOSTID
argument_list|)
expr_stmt|;
comment|/* host   ID */
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncPeriod
argument_list|,
name|TRMREG_SCSI_SYNC
argument_list|)
expr_stmt|;
comment|/* period    */
name|trm_reg_write8
argument_list|(
name|pDCB
operator|->
name|SyncOffset
argument_list|,
name|TRMREG_SCSI_OFFSET
argument_list|)
expr_stmt|;
comment|/* offset    */
name|trm_reg_write16
argument_list|(
name|DO_DATALATCH
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* it's important for atn stop*/
comment|/* 	 * SCSI cammand  	 */
name|trm_reg_write8
argument_list|(
name|SCMD_MSGACCEPT
argument_list|,
name|TRMREG_SCSI_COMMAND
argument_list|)
expr_stmt|;
comment|/* to rls the /ACK signal */
block|}
end_function

begin_function
specifier|static
name|void
name|trm_SRBdone
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|PSRB
name|psrb
decl_stmt|;
name|u_int8_t
name|bval
decl_stmt|,
name|bval1
decl_stmt|,
name|status
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
decl_stmt|;
name|PSCSI_INQDATA
name|ptr
decl_stmt|;
name|int
name|intflag
decl_stmt|;
name|u_int
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|PDCB
name|pTempDCB
decl_stmt|;
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
if|if
condition|(
name|pccb
operator|==
name|NULL
condition|)
return|return;
name|pcsio
operator|=
operator|&
name|pccb
operator|->
name|csio
expr_stmt|;
name|target_id
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|target_lun
operator|=
name|pSRB
operator|->
name|pccb
operator|->
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmasync_op_t
name|op
decl_stmt|;
if|if
condition|(
operator|(
name|pccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|==
name|CAM_DIR_IN
condition|)
name|op
operator|=
name|BUS_DMASYNC_POSTREAD
expr_stmt|;
else|else
name|op
operator|=
name|BUS_DMASYNC_POSTWRITE
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 	 * target status 	 * 	 */
name|status
operator|=
name|pSRB
operator|->
name|TargetStatus
expr_stmt|;
name|pcsio
operator|->
name|scsi_status
operator|=
name|SCSI_STAT_GOOD
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|SRBFlag
operator|&
name|AUTO_REQSENSE
condition|)
block|{
comment|/*     	   * status of auto request sense  	   */
name|pSRB
operator|->
name|SRBFlag
operator|&=
operator|~
name|AUTO_REQSENSE
expr_stmt|;
name|pSRB
operator|->
name|AdaptStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
block|{
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
goto|goto
name|ckc_e
goto|;
block|}
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|&
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|)
operator|)
operator|=
name|pSRB
operator|->
name|Segment0
index|[
literal|0
index|]
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|&
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|4
index|]
operator|)
operator|)
operator|=
name|pSRB
operator|->
name|Segment0
index|[
literal|1
index|]
expr_stmt|;
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
name|pSRB
operator|->
name|Segment1
index|[
literal|1
index|]
expr_stmt|;
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|address
operator|=
name|pSRB
operator|->
name|SgSenseTemp
operator|.
name|address
expr_stmt|;
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|length
operator|=
name|pSRB
operator|->
name|SgSenseTemp
operator|.
name|length
expr_stmt|;
name|pcsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|bcopy
argument_list|(
name|trm_get_sense_buf
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
argument_list|,
operator|&
name|pcsio
operator|->
name|sense_data
argument_list|,
name|pcsio
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|pcsio
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
operator||
name|CAM_AUTOSNS_VALID
expr_stmt|;
goto|goto
name|ckc_e
goto|;
block|}
comment|/* 	 * target status 	 */
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|SCSI_STATUS_CHECK_COND
condition|)
block|{
if|if
condition|(
operator|(
name|pcsio
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"trm_RequestSense..................\n"
argument_list|)
expr_stmt|;
name|trm_RequestSense
argument_list|(
name|pACB
argument_list|,
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
return|return;
block|}
name|pcsio
operator|->
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
goto|goto
name|ckc_e
goto|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCSI_STAT_QUEUEFULL
condition|)
block|{
name|bval
operator|=
operator|(
name|u_int8_t
operator|)
name|pDCB
operator|->
name|GoingSRBCnt
expr_stmt|;
name|bval
operator|--
expr_stmt|;
name|pDCB
operator|->
name|MaxActiveCommandCnt
operator|=
name|bval
expr_stmt|;
name|trm_RewaitSRB
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|AdaptStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCSI_STAT_SEL_TIMEOUT
condition|)
block|{
name|pSRB
operator|->
name|AdaptStatus
operator|=
name|H_SEL_TIMEOUT
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
name|pcsio
operator|->
name|scsi_status
operator|=
name|SCSI_STAT_SEL_TIMEOUT
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCSI_STAT_BUSY
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"trm: target busy at %s %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|pcsio
operator|->
name|scsi_status
operator|=
name|SCSI_STAT_BUSY
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_BUSY
expr_stmt|;
return|return;
comment|/* The device busy, try again later?	  */
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|SCSI_STAT_RESCONFLICT
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"trm: target reserved at %s %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|pcsio
operator|->
name|scsi_status
operator|=
name|SCSI_STAT_RESCONFLICT
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
comment|/*XXX*/
return|return;
block|}
else|else
block|{
name|pSRB
operator|->
name|AdaptStatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pSRB
operator|->
name|RetryCnt
condition|)
block|{
name|pSRB
operator|->
name|RetryCnt
operator|--
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|SRBSGIndex
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trm_StartSCSI
argument_list|(
name|pACB
argument_list|,
name|pDCB
argument_list|,
name|pSRB
argument_list|)
condition|)
block|{
comment|/*  				   * If trm_StartSCSI return 1 : 				   * current interrupt status is interrupt  				   * disreenable  				   * It's said that SCSI processor has more  				   * one SRB need to do 				   */
name|trm_RewaitSRB
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|TRM_DPRINTF
argument_list|(
literal|"trm: driver stuffup at %s %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/*   	 * process initiator status.......................... 	 * Adapter (initiator) status 	 */
name|status
operator|=
name|pSRB
operator|->
name|AdaptStatus
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|H_OVER_UNDER_RUN
condition|)
block|{
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_DATA_RUN_ERR
expr_stmt|;
comment|/* Illegal length (over/under run) */
block|}
elseif|else
if|if
condition|(
name|pSRB
operator|->
name|SRBStatus
operator|&
name|PARITY_ERROR
condition|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"trm: driver stuffup %s %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|goal
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Driver failed to perform operation */
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_UNCOR_PARITY
expr_stmt|;
block|}
else|else
block|{
comment|/* no error */
name|pSRB
operator|->
name|AdaptStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
comment|/* there is no error, (sense is invalid) */
block|}
block|}
name|ckc_e
label|:
if|if
condition|(
name|pACB
operator|->
name|scan_devices
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
condition|)
block|{
comment|/* 	   *   if SCSI command in "scan devices" duty 	   */
if|if
condition|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|==
name|TEST_UNIT_READY
condition|)
name|pACB
operator|->
name|scan_devices
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
operator|=
literal|0
expr_stmt|;
comment|/* SCSI command phase :test unit ready */
elseif|else
if|if
condition|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|==
name|INQUIRY
condition|)
block|{
comment|/*  		   * SCSI command phase :inquiry scsi device data  		   * (type,capacity,manufacture....  		   */
if|if
condition|(
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|==
name|CAM_SEL_TIMEOUT
condition|)
goto|goto
name|NO_DEV
goto|;
name|ptr
operator|=
operator|(
name|PSCSI_INQDATA
operator|)
name|pcsio
operator|->
name|data_ptr
expr_stmt|;
comment|/* page fault */
name|TRM_DPRINTF
argument_list|(
literal|"trm_SRBdone..PSCSI_INQDATA:%2x \n"
argument_list|,
name|ptr
operator|->
name|DevType
argument_list|)
expr_stmt|;
name|bval1
operator|=
name|ptr
operator|->
name|DevType
operator|&
name|SCSI_DEVTYPE
expr_stmt|;
if|if
condition|(
name|bval1
operator|==
name|SCSI_NODEV
condition|)
block|{
name|NO_DEV
label|:
name|TRM_DPRINTF
argument_list|(
literal|"trm_SRBdone NO Device:target_id= %d ,target_lun= %d \n"
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pACB
operator|->
name|scan_devices
index|[
name|target_id
index|]
index|[
name|target_lun
index|]
operator|=
literal|0
expr_stmt|;
comment|/* no device set scan device flag =0*/
comment|/* pDCB Q link */
comment|/* move the head of DCB to tempDCB*/
name|pTempDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
comment|/* search current DCB for pass link */
while|while
condition|(
name|pTempDCB
operator|->
name|pNextDCB
operator|!=
name|pDCB
condition|)
block|{
name|pTempDCB
operator|=
name|pTempDCB
operator|->
name|pNextDCB
expr_stmt|;
block|}
comment|/* 				 * when the current DCB found than connect  				 * current DCB tail  				 */
comment|/* to the DCB tail that before current DCB */
name|pTempDCB
operator|->
name|pNextDCB
operator|=
name|pDCB
operator|->
name|pNextDCB
expr_stmt|;
comment|/* 				 * if there was only one DCB ,connect his tail 				 * to his head  				 */
if|if
condition|(
name|pACB
operator|->
name|pLinkDCB
operator|==
name|pDCB
condition|)
name|pACB
operator|->
name|pLinkDCB
operator|=
name|pTempDCB
operator|->
name|pNextDCB
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|pDCBRunRobin
operator|==
name|pDCB
condition|)
name|pACB
operator|->
name|pDCBRunRobin
operator|=
name|pTempDCB
operator|->
name|pNextDCB
expr_stmt|;
name|pDCB
operator|->
name|DCBstatus
operator|&=
operator|~
name|DS_IN_QUEUE
expr_stmt|;
name|pACB
operator|->
name|DeviceCnt
operator|--
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|DeviceCnt
operator|==
literal|0
condition|)
block|{
name|pACB
operator|->
name|pLinkDCB
operator|=
name|NULL
expr_stmt|;
name|pACB
operator|->
name|pDCBRunRobin
operator|=
name|NULL
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|trm_DEBUG1
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|28
condition|;
name|j
operator|++
control|)
block|{
name|TRM_DPRINTF
argument_list|(
literal|"ptr=%2x "
argument_list|,
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|ptr
operator|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pDCB
operator|->
name|DevType
operator|=
name|bval1
expr_stmt|;
if|if
condition|(
name|bval1
operator|==
name|SCSI_DASD
operator|||
name|bval1
operator|==
name|SCSI_OPTICAL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|ptr
operator|->
name|Vers
operator|&
literal|0x07
operator|)
operator|>=
literal|2
operator|)
operator|||
operator|(
operator|(
name|ptr
operator|->
name|RDF
operator|&
literal|0x0F
operator|)
operator|==
literal|2
operator|)
operator|)
operator|&&
operator|(
name|ptr
operator|->
name|Flags
operator|&
name|SCSI_INQ_CMDQUEUE
operator|)
operator|&&
operator|(
name|pDCB
operator|->
name|DevMode
operator|&
name|TAG_QUEUING_
operator|)
operator|&&
operator|(
name|pDCB
operator|->
name|DevMode
operator|&
name|EN_DISCONNECT_
operator|)
condition|)
block|{
if|if
condition|(
name|pDCB
operator|->
name|DevMode
operator|&
name|TAG_QUEUING_
condition|)
block|{
name|pDCB
operator|->
name|MaxActiveCommandCnt
operator|=
name|pACB
operator|->
name|TagMaxNum
expr_stmt|;
name|pDCB
operator|->
name|SyncMode
operator||=
name|EN_TAG_QUEUING
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_CUR_TAGENB
expr_stmt|;
block|}
else|else
block|{
name|pDCB
operator|->
name|SyncMode
operator||=
name|EN_ATN_STOP
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
name|TRM_CUR_TAGENB
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* pSRB->CmdBlock[0] == INQUIRY */
block|}
comment|/* pACB->scan_devices[target_id][target_lun] */
block|}
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
comment|/*  ReleaseSRB(pDCB, pSRB); */
if|if
condition|(
name|pSRB
operator|==
name|pDCB
operator|->
name|pGoingSRB
condition|)
name|pDCB
operator|->
name|pGoingSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
else|else
block|{
name|psrb
operator|=
name|pDCB
operator|->
name|pGoingSRB
expr_stmt|;
while|while
condition|(
name|psrb
operator|->
name|pNextSRB
operator|!=
name|pSRB
condition|)
block|{
name|psrb
operator|=
name|psrb
operator|->
name|pNextSRB
expr_stmt|;
block|}
name|psrb
operator|->
name|pNextSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
if|if
condition|(
name|pSRB
operator|==
name|pDCB
operator|->
name|pGoingLastSRB
condition|)
block|{
name|pDCB
operator|->
name|pGoingLastSRB
operator|=
name|psrb
expr_stmt|;
block|}
block|}
name|pSRB
operator|->
name|pNextSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
name|pACB
operator|->
name|pFreeSRB
operator|=
name|pSRB
expr_stmt|;
name|pDCB
operator|->
name|GoingSRBCnt
operator|--
expr_stmt|;
name|trm_DoWaitingSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
comment|/*  Notify cmd done */
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_DoingSRB_Done
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PDCB
name|pDCB
decl_stmt|,
name|pdcb
decl_stmt|;
name|PSRB
name|psrb
decl_stmt|,
name|psrb2
decl_stmt|;
name|u_int16_t
name|cnt
decl_stmt|,
name|i
decl_stmt|;
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|pDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
if|if
condition|(
name|pDCB
operator|==
name|NULL
condition|)
return|return;
name|pdcb
operator|=
name|pDCB
expr_stmt|;
do|do
block|{
name|cnt
operator|=
name|pdcb
operator|->
name|GoingSRBCnt
expr_stmt|;
name|psrb
operator|=
name|pdcb
operator|->
name|pGoingSRB
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|psrb2
operator|=
name|psrb
operator|->
name|pNextSRB
expr_stmt|;
name|pccb
operator|=
name|psrb
operator|->
name|pccb
expr_stmt|;
name|pccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
comment|/*  ReleaseSRB(pDCB, pSRB); */
name|psrb
operator|->
name|pNextSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
name|pACB
operator|->
name|pFreeSRB
operator|=
name|psrb
expr_stmt|;
name|xpt_done
argument_list|(
name|pccb
argument_list|)
expr_stmt|;
name|psrb
operator|=
name|psrb2
expr_stmt|;
block|}
name|pdcb
operator|->
name|GoingSRBCnt
operator|=
literal|0
expr_stmt|;
empty_stmt|;
name|pdcb
operator|->
name|pGoingSRB
operator|=
name|NULL
expr_stmt|;
name|pdcb
operator|=
name|pdcb
operator|->
name|pNextDCB
expr_stmt|;
block|}
do|while
condition|(
name|pdcb
operator|!=
name|pDCB
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_ResetSCSIBus
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|int
name|intflag
decl_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|pACB
operator|->
name|ACBFlag
operator||=
name|RESET_DEV
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_RSTSCSI
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|trm_reg_read16
argument_list|(
name|TRMREG_SCSI_INTSTATUS
argument_list|)
operator|&
name|INT_SCSIRESET
operator|)
condition|)
empty_stmt|;
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_ScsiRstDetect
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|int
name|intflag
decl_stmt|;
name|u_long
name|wlval
decl_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm_ScsiRstDetect \n"
argument_list|)
expr_stmt|;
name|wlval
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|--
name|wlval
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|STOPDMAXFER
argument_list|,
name|TRMREG_DMA_CONTROL
argument_list|)
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_CLRFIFO
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|ACBFlag
operator|&
name|RESET_DEV
condition|)
name|pACB
operator|->
name|ACBFlag
operator||=
name|RESET_DONE
expr_stmt|;
else|else
block|{
name|pACB
operator|->
name|ACBFlag
operator||=
name|RESET_DETECT
expr_stmt|;
name|trm_ResetDevParam
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/*	trm_DoingSRB_Done(pACB); ???? */
name|trm_RecoverSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|pActiveDCB
operator|=
name|NULL
expr_stmt|;
name|pACB
operator|->
name|ACBFlag
operator|=
literal|0
expr_stmt|;
name|trm_DoWaitingSRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_RequestSense
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|pccb
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|pcsio
decl_stmt|;
name|pccb
operator|=
name|pSRB
operator|->
name|pccb
expr_stmt|;
name|pcsio
operator|=
operator|&
name|pccb
operator|->
name|csio
expr_stmt|;
name|pSRB
operator|->
name|SRBFlag
operator||=
name|AUTO_REQSENSE
expr_stmt|;
name|pSRB
operator|->
name|Segment0
index|[
literal|0
index|]
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|&
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|)
operator|)
expr_stmt|;
name|pSRB
operator|->
name|Segment0
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|&
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|4
index|]
operator|)
operator|)
expr_stmt|;
name|pSRB
operator|->
name|Segment1
index|[
literal|0
index|]
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|(
name|pSRB
operator|->
name|ScsiCmdLen
operator|<<
literal|8
operator|)
operator|+
name|pSRB
operator|->
name|SRBSGCount
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|Segment1
index|[
literal|1
index|]
operator|=
name|pSRB
operator|->
name|SRBTotalXferLength
expr_stmt|;
comment|/* ?????????? */
comment|/* $$$$$$ Status of initiator/target $$$$$$$$ */
name|pSRB
operator|->
name|AdaptStatus
operator|=
literal|0
expr_stmt|;
name|pSRB
operator|->
name|TargetStatus
operator|=
literal|0
expr_stmt|;
comment|/* $$$$$$ Status of initiator/target $$$$$$$$ */
name|pSRB
operator|->
name|SRBTotalXferLength
operator|=
sizeof|sizeof
argument_list|(
name|pcsio
operator|->
name|sense_data
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|SgSenseTemp
operator|.
name|address
operator|=
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|address
expr_stmt|;
name|pSRB
operator|->
name|SgSenseTemp
operator|.
name|length
operator|=
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|length
expr_stmt|;
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|address
operator|=
name|trm_get_sense_bufaddr
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|pSRBSGL
operator|->
name|length
operator|=
operator|(
name|u_long
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|pSRB
operator|->
name|SRBSGCount
operator|=
literal|1
expr_stmt|;
name|pSRB
operator|->
name|SRBSGIndex
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
operator|&
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|0
index|]
operator|)
operator|)
operator|=
literal|0x00000003
expr_stmt|;
name|pSRB
operator|->
name|CmdBlock
index|[
literal|1
index|]
operator|=
name|pDCB
operator|->
name|IdentifyMsg
operator|<<
literal|5
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
operator|(
name|pSRB
operator|->
name|CmdBlock
index|[
literal|4
index|]
operator|)
operator|)
operator|=
name|pcsio
operator|->
name|sense_len
expr_stmt|;
name|pSRB
operator|->
name|ScsiCmdLen
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|trm_StartSCSI
argument_list|(
name|pACB
argument_list|,
name|pDCB
argument_list|,
name|pSRB
argument_list|)
condition|)
comment|/*  	    * If trm_StartSCSI return 1 : 	    * current interrupt status is interrupt disreenable  	    * It's said that SCSI processor has more one SRB need to do 	    */
name|trm_RewaitSRB
argument_list|(
name|pDCB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_EnableMsgOutAbort2
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|pSRB
operator|->
name|MsgCnt
operator|=
literal|1
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|DO_SETATN
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_EnableMsgOutAbort1
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PSRB
name|pSRB
parameter_list|)
block|{
name|pSRB
operator|->
name|MsgOutBuf
index|[
literal|0
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|trm_EnableMsgOutAbort2
argument_list|(
name|pACB
argument_list|,
name|pSRB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_initDCB
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|PDCB
name|pDCB
parameter_list|,
name|u_int16_t
name|unit
parameter_list|,
name|u_int32_t
name|i
parameter_list|,
name|u_int32_t
name|j
parameter_list|)
block|{
name|PNVRAMTYPE
name|pEEpromBuf
decl_stmt|;
name|u_int8_t
name|bval
decl_stmt|,
name|PeriodIndex
decl_stmt|;
name|u_int
name|target_id
decl_stmt|,
name|target_lun
decl_stmt|;
name|PDCB
name|pTempDCB
decl_stmt|;
name|int
name|intflag
decl_stmt|;
name|target_id
operator|=
name|i
expr_stmt|;
name|target_lun
operator|=
name|j
expr_stmt|;
comment|/* 	 *  Using the lun 0 device to init other DCB first, if the device  	 *  has been initialized. 	 *  I don't want init sync arguments one by one, it is the same. 	 */
if|if
condition|(
name|target_lun
operator|!=
literal|0
operator|&&
operator|(
name|pACB
operator|->
name|DCBarray
index|[
name|target_id
index|]
index|[
literal|0
index|]
operator|.
name|DCBstatus
operator|&
name|DS_IN_QUEUE
operator|)
condition|)
name|bcopy
argument_list|(
operator|&
name|pACB
operator|->
name|DCBarray
index|[
name|target_id
index|]
index|[
literal|0
index|]
argument_list|,
name|pDCB
argument_list|,
sizeof|sizeof
argument_list|(
name|TRM_DCB
argument_list|)
argument_list|)
expr_stmt|;
name|intflag
operator|=
name|splcam
argument_list|()
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|pLinkDCB
operator|==
literal|0
condition|)
block|{
name|pACB
operator|->
name|pLinkDCB
operator|=
name|pDCB
expr_stmt|;
comment|/*  		 * RunRobin impersonate the role  		 * that let each device had good proportion  		 * about SCSI command proceeding  		 */
name|pACB
operator|->
name|pDCBRunRobin
operator|=
name|pDCB
expr_stmt|;
name|pDCB
operator|->
name|pNextDCB
operator|=
name|pDCB
expr_stmt|;
block|}
else|else
block|{
name|pTempDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
comment|/* search the last nod of DCB link */
while|while
condition|(
name|pTempDCB
operator|->
name|pNextDCB
operator|!=
name|pACB
operator|->
name|pLinkDCB
condition|)
name|pTempDCB
operator|=
name|pTempDCB
operator|->
name|pNextDCB
expr_stmt|;
comment|/* connect current DCB with last DCB tail */
name|pTempDCB
operator|->
name|pNextDCB
operator|=
name|pDCB
expr_stmt|;
comment|/* connect current DCB tail to this DCB Q head */
name|pDCB
operator|->
name|pNextDCB
operator|=
name|pACB
operator|->
name|pLinkDCB
expr_stmt|;
block|}
name|splx
argument_list|(
name|intflag
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|DeviceCnt
operator|++
expr_stmt|;
name|pDCB
operator|->
name|TargetID
operator|=
name|target_id
expr_stmt|;
name|pDCB
operator|->
name|TargetLUN
operator|=
name|target_lun
expr_stmt|;
name|pDCB
operator|->
name|pWaitingSRB
operator|=
name|NULL
expr_stmt|;
name|pDCB
operator|->
name|pGoingSRB
operator|=
name|NULL
expr_stmt|;
name|pDCB
operator|->
name|GoingSRBCnt
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|pActiveSRB
operator|=
name|NULL
expr_stmt|;
name|pDCB
operator|->
name|MaxActiveCommandCnt
operator|=
literal|1
expr_stmt|;
name|pDCB
operator|->
name|DCBFlag
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|DCBstatus
operator||=
name|DS_IN_QUEUE
expr_stmt|;
comment|/* $$$$$$$ */
name|pEEpromBuf
operator|=
operator|&
name|trm_eepromBuf
index|[
name|unit
index|]
expr_stmt|;
name|pDCB
operator|->
name|DevMode
operator|=
name|pEEpromBuf
operator|->
name|NvramTarget
index|[
name|target_id
index|]
operator|.
name|NvmTarCfg0
expr_stmt|;
name|pDCB
operator|->
name|AdpMode
operator|=
name|pEEpromBuf
operator|->
name|NvramChannelCfg
expr_stmt|;
comment|/* $$$$$$$ */
comment|/*  	 * disconnect enable ? 	 */
if|if
condition|(
name|pDCB
operator|->
name|DevMode
operator|&
name|NTC_DO_DISCONNECT
condition|)
block|{
name|bval
operator|=
literal|0xC0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_USR_DISCENB
expr_stmt|;
block|}
else|else
block|{
name|bval
operator|=
literal|0x80
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
operator|(
name|TRM_USR_DISCENB
operator|)
expr_stmt|;
block|}
name|bval
operator||=
name|target_lun
expr_stmt|;
name|pDCB
operator|->
name|IdentifyMsg
operator|=
name|bval
expr_stmt|;
if|if
condition|(
name|target_lun
operator|!=
literal|0
operator|&&
operator|(
name|pACB
operator|->
name|DCBarray
index|[
name|target_id
index|]
index|[
literal|0
index|]
operator|.
name|DCBstatus
operator|&
name|DS_IN_QUEUE
operator|)
condition|)
return|return;
comment|/* $$$$$$$ */
comment|/* 	 * tag Qing enable ? 	 */
if|if
condition|(
name|pDCB
operator|->
name|DevMode
operator|&
name|TAG_QUEUING_
condition|)
block|{
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator||=
name|TRM_USR_TAGENB
expr_stmt|;
block|}
else|else
name|pDCB
operator|->
name|tinfo
operator|.
name|disc_tag
operator|&=
operator|~
operator|(
name|TRM_USR_TAGENB
operator|)
expr_stmt|;
comment|/* $$$$$$$ */
comment|/* 	 * wide nego ,sync nego enable ? 	 */
name|pDCB
operator|->
name|SyncPeriod
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|SyncOffset
operator|=
literal|0
expr_stmt|;
name|PeriodIndex
operator|=
name|pEEpromBuf
operator|->
name|NvramTarget
index|[
name|target_id
index|]
operator|.
name|NvmTarPeriod
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|AdaptType
operator|==
literal|1
condition|)
block|{
comment|/* is U2? */
name|pDCB
operator|->
name|MaxNegoPeriod
operator|=
name|dc395u2x_clock_period
index|[
name|PeriodIndex
index|]
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|pDCB
operator|->
name|MaxNegoPeriod
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
operator|)
condition|?
literal|31
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pDCB
operator|->
name|MaxNegoPeriod
operator|=
name|dc395x_clock_period
index|[
name|PeriodIndex
index|]
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|period
operator|=
name|pDCB
operator|->
name|MaxNegoPeriod
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|offset
operator|=
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|SYNC_NEGO_ENABLE
operator|)
condition|?
literal|15
else|:
literal|0
expr_stmt|;
block|}
name|pDCB
operator|->
name|SyncMode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pDCB
operator|->
name|DevMode
operator|&
name|NTC_DO_WIDE_NEGO
operator|)
operator|&&
operator|(
name|pACB
operator|->
name|Config
operator|&
name|HCC_WIDE_CARD
operator|)
condition|)
name|pDCB
operator|->
name|SyncMode
operator||=
name|WIDE_NEGO_ENABLE
expr_stmt|;
comment|/* enable wide nego */
if|if
condition|(
name|pDCB
operator|->
name|DevMode
operator|&
name|NTC_DO_SYNC_NEGO
condition|)
name|pDCB
operator|->
name|SyncMode
operator||=
name|SYNC_NEGO_ENABLE
expr_stmt|;
comment|/* enable sync nego */
comment|/* $$$$$$$ */
comment|/* 	 *	Fill in tinfo structure. 	 */
name|pDCB
operator|->
name|tinfo
operator|.
name|user
operator|.
name|width
operator|=
operator|(
name|pDCB
operator|->
name|SyncMode
operator|&
name|WIDE_NEGO_ENABLE
operator|)
condition|?
name|MSG_EXT_WDTR_BUS_16_BIT
else|:
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|period
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|pDCB
operator|->
name|tinfo
operator|.
name|current
operator|.
name|width
operator|=
name|MSG_EXT_WDTR_BUS_8_BIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_srbmapSG
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|PSRB
name|pSRB
decl_stmt|;
name|pSRB
operator|=
operator|(
name|PSRB
operator|)
name|arg
expr_stmt|;
name|pSRB
operator|->
name|SRBSGPhyAddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_destroySRB
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|PSRB
name|pSRB
decl_stmt|;
name|pSRB
operator|=
name|pACB
operator|->
name|pFreeSRB
expr_stmt|;
while|while
condition|(
name|pSRB
condition|)
block|{
if|if
condition|(
name|pSRB
operator|->
name|sg_dmamap
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|,
name|pSRB
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|,
name|pSRB
operator|->
name|pSRBSGL
argument_list|,
name|pSRB
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|,
name|pSRB
operator|->
name|sg_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pSRB
operator|->
name|dmamap
condition|)
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
name|pSRB
operator|->
name|dmamap
argument_list|)
expr_stmt|;
name|pSRB
operator|=
name|pSRB
operator|->
name|pNextSRB
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|trm_initSRB
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
name|u_int16_t
name|i
decl_stmt|;
name|PSRB
name|pSRB
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRM_MAX_SRB_CNT
condition|;
name|i
operator|++
control|)
block|{
name|pSRB
operator|=
operator|(
name|PSRB
operator|)
operator|&
name|pACB
operator|->
name|pFreeSRB
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pSRB
operator|->
name|pSRBSGL
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pSRB
operator|->
name|sg_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|,
name|pSRB
operator|->
name|sg_dmamap
argument_list|,
name|pSRB
operator|->
name|pSRBSGL
argument_list|,
name|TRM_MAX_SG_LISTENTRY
operator|*
sizeof|sizeof
argument_list|(
name|SGentry
argument_list|)
argument_list|,
name|trm_srbmapSG
argument_list|,
name|pSRB
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TRM_MAX_SRB_CNT
operator|-
literal|1
condition|)
block|{
comment|/* 			 * link all SRB  			 */
name|pSRB
operator|->
name|pNextSRB
operator|=
operator|&
name|pACB
operator|->
name|pFreeSRB
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * load NULL to NextSRB of the last SRB 			 */
name|pSRB
operator|->
name|pNextSRB
operator|=
name|NULL
expr_stmt|;
block|}
name|pSRB
operator|->
name|TagNumber
operator|=
name|i
expr_stmt|;
comment|/* 		 * Create the dmamap.  This is no longer optional! 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|pSRB
operator|->
name|dmamap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_initACB
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|adaptType
parameter_list|,
name|u_int16_t
name|unit
parameter_list|)
block|{
name|PNVRAMTYPE
name|pEEpromBuf
decl_stmt|;
name|pEEpromBuf
operator|=
operator|&
name|trm_eepromBuf
index|[
name|unit
index|]
expr_stmt|;
name|pACB
operator|->
name|max_id
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|pEEpromBuf
operator|->
name|NvramChannelCfg
operator|&
name|NAC_SCANLUN
condition|)
name|pACB
operator|->
name|max_lun
operator|=
literal|7
expr_stmt|;
else|else
name|pACB
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|TRM_DPRINTF
argument_list|(
literal|"trm: pACB->max_id= %d pACB->max_lun= %d \n"
argument_list|,
name|pACB
operator|->
name|max_id
argument_list|,
name|pACB
operator|->
name|max_lun
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|pLinkDCB
operator|=
name|NULL
expr_stmt|;
name|pACB
operator|->
name|pDCBRunRobin
operator|=
name|NULL
expr_stmt|;
name|pACB
operator|->
name|pActiveDCB
operator|=
name|NULL
expr_stmt|;
name|pACB
operator|->
name|AdapterUnit
operator|=
operator|(
name|u_int8_t
operator|)
name|unit
expr_stmt|;
name|pACB
operator|->
name|AdaptSCSIID
operator|=
name|pEEpromBuf
operator|->
name|NvramScsiId
expr_stmt|;
name|pACB
operator|->
name|AdaptSCSILUN
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|DeviceCnt
operator|=
literal|0
expr_stmt|;
name|pACB
operator|->
name|AdaptType
operator|=
name|adaptType
expr_stmt|;
name|pACB
operator|->
name|TagMaxNum
operator|=
literal|2
operator|<<
name|pEEpromBuf
operator|->
name|NvramMaxTag
expr_stmt|;
name|pACB
operator|->
name|ACBFlag
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|NVRAM_trm_write_all
parameter_list|(
name|PNVRAMTYPE
name|pEEpromBuf
parameter_list|,
name|PACB
name|pACB
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|bpEeprom
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pEEpromBuf
decl_stmt|;
name|u_int8_t
name|bAddr
decl_stmt|;
comment|/* Enable SEEPROM */
name|trm_reg_write8
argument_list|(
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_CONTROL
argument_list|)
operator||
name|EN_EEPROM
operator|)
argument_list|,
name|TRMREG_GEN_CONTROL
argument_list|)
expr_stmt|;
comment|/* 	 * Write enable 	 */
name|NVRAM_trm_write_cmd
argument_list|(
name|pACB
argument_list|,
literal|0x04
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
for|for
control|(
name|bAddr
operator|=
literal|0
init|;
name|bAddr
operator|<
literal|128
condition|;
name|bAddr
operator|++
operator|,
name|bpEeprom
operator|++
control|)
block|{
name|NVRAM_trm_set_data
argument_list|(
name|pACB
argument_list|,
name|bAddr
argument_list|,
operator|*
name|bpEeprom
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Write disable 	 */
name|NVRAM_trm_write_cmd
argument_list|(
name|pACB
argument_list|,
literal|0x04
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/* Disable SEEPROM */
name|trm_reg_write8
argument_list|(
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_CONTROL
argument_list|)
operator|&
operator|~
name|EN_EEPROM
operator|)
argument_list|,
name|TRMREG_GEN_CONTROL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|NVRAM_trm_set_data
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|bAddr
parameter_list|,
name|u_int8_t
name|bData
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|bSendData
decl_stmt|;
comment|/*  	 * Send write command& address	 	 */
name|NVRAM_trm_write_cmd
argument_list|(
name|pACB
argument_list|,
literal|0x05
argument_list|,
name|bAddr
argument_list|)
expr_stmt|;
comment|/*  	 * Write data  	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|bData
operator|<<=
literal|1
control|)
block|{
name|bSendData
operator|=
name|NVR_SELECT
expr_stmt|;
if|if
condition|(
name|bData
operator|&
literal|0x80
condition|)
comment|/* Start from bit 7	*/
name|bSendData
operator||=
name|NVR_BITOUT
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|bSendData
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
operator|(
name|bSendData
operator||
name|NVR_CLOCK
operator|)
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
name|trm_reg_write8
argument_list|(
name|NVR_SELECT
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/* 	 * Disable chip select  	 */
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|NVR_SELECT
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
comment|/*  	 * Wait for write ready	 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|trm_reg_write8
argument_list|(
operator|(
name|NVR_SELECT
operator||
name|NVR_CLOCK
operator|)
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|NVR_SELECT
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
if|if
condition|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_NVRAM
argument_list|)
operator|&
name|NVR_BITIN
condition|)
block|{
break|break;
block|}
block|}
comment|/*  	 * Disable chip select  	 */
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|NVRAM_trm_read_all
parameter_list|(
name|PNVRAMTYPE
name|pEEpromBuf
parameter_list|,
name|PACB
name|pACB
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|bpEeprom
init|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pEEpromBuf
decl_stmt|;
name|u_int8_t
name|bAddr
decl_stmt|;
comment|/* 	 * Enable SEEPROM  	 */
name|trm_reg_write8
argument_list|(
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_CONTROL
argument_list|)
operator||
name|EN_EEPROM
operator|)
argument_list|,
name|TRMREG_GEN_CONTROL
argument_list|)
expr_stmt|;
for|for
control|(
name|bAddr
operator|=
literal|0
init|;
name|bAddr
operator|<
literal|128
condition|;
name|bAddr
operator|++
operator|,
name|bpEeprom
operator|++
control|)
operator|*
name|bpEeprom
operator|=
name|NVRAM_trm_get_data
argument_list|(
name|pACB
argument_list|,
name|bAddr
argument_list|)
expr_stmt|;
comment|/*  	 * Disable SEEPROM  	 */
name|trm_reg_write8
argument_list|(
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_CONTROL
argument_list|)
operator|&
operator|~
name|EN_EEPROM
operator|)
argument_list|,
name|TRMREG_GEN_CONTROL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|NVRAM_trm_get_data
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|bAddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|bReadData
decl_stmt|,
name|bData
init|=
literal|0
decl_stmt|;
comment|/*  	* Send read command& address 	*/
name|NVRAM_trm_write_cmd
argument_list|(
name|pACB
argument_list|,
literal|0x06
argument_list|,
name|bAddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/*  	   * Read data 	   */
name|trm_reg_write8
argument_list|(
operator|(
name|NVR_SELECT
operator||
name|NVR_CLOCK
operator|)
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|NVR_SELECT
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
comment|/*  		 * Get data bit while falling edge  		 */
name|bReadData
operator|=
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|bData
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|bReadData
operator|&
name|NVR_BITIN
condition|)
block|{
name|bData
operator||=
literal|1
expr_stmt|;
block|}
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Disable chip select  	 */
name|trm_reg_write8
argument_list|(
literal|0
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
return|return
operator|(
name|bData
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|NVRAM_trm_wait_30us
parameter_list|(
name|PACB
name|pACB
parameter_list|)
block|{
comment|/*    ScsiPortStallExecution(30);	 wait 30 us	*/
name|trm_reg_write8
argument_list|(
literal|5
argument_list|,
name|TRMREG_GEN_TIMER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_STATUS
argument_list|)
operator|&
name|GTIMEOUT
operator|)
condition|)
empty_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|NVRAM_trm_write_cmd
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int8_t
name|bCmd
parameter_list|,
name|u_int8_t
name|bAddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int8_t
name|bSendData
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
operator|,
name|bCmd
operator|<<=
literal|1
control|)
block|{
comment|/*     	   * Program SB+OP code		    	   */
name|bSendData
operator|=
name|NVR_SELECT
expr_stmt|;
if|if
condition|(
name|bCmd
operator|&
literal|0x04
condition|)
name|bSendData
operator||=
name|NVR_BITOUT
expr_stmt|;
comment|/* start from bit 2 */
name|trm_reg_write8
argument_list|(
name|bSendData
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
operator|(
name|bSendData
operator||
name|NVR_CLOCK
operator|)
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
operator|,
name|bAddr
operator|<<=
literal|1
control|)
block|{
comment|/*  	   * Program address		 	   */
name|bSendData
operator|=
name|NVR_SELECT
expr_stmt|;
if|if
condition|(
name|bAddr
operator|&
literal|0x40
condition|)
comment|/* Start from bit 6	*/
name|bSendData
operator||=
name|NVR_BITOUT
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|bSendData
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
operator|(
name|bSendData
operator||
name|NVR_CLOCK
operator|)
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
name|trm_reg_write8
argument_list|(
name|NVR_SELECT
argument_list|,
name|TRMREG_GEN_NVRAM
argument_list|)
expr_stmt|;
name|NVRAM_trm_wait_30us
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_check_eeprom
parameter_list|(
name|PNVRAMTYPE
name|pEEpromBuf
parameter_list|,
name|PACB
name|pACB
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|wpEeprom
init|=
operator|(
name|u_int16_t
operator|*
operator|)
name|pEEpromBuf
decl_stmt|;
name|u_int16_t
name|wAddr
decl_stmt|,
name|wCheckSum
decl_stmt|;
name|u_long
name|dAddr
decl_stmt|,
modifier|*
name|dpEeprom
decl_stmt|;
name|NVRAM_trm_read_all
argument_list|(
name|pEEpromBuf
argument_list|,
name|pACB
argument_list|)
expr_stmt|;
name|wCheckSum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|wAddr
operator|=
literal|0
operator|,
name|wpEeprom
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|pEEpromBuf
init|;
name|wAddr
operator|<
literal|64
condition|;
name|wAddr
operator|++
operator|,
name|wpEeprom
operator|++
control|)
block|{
name|wCheckSum
operator|+=
operator|*
name|wpEeprom
expr_stmt|;
block|}
if|if
condition|(
name|wCheckSum
operator|!=
literal|0x1234
condition|)
block|{
comment|/*     	   * Checksum error, load default	 	   */
name|pEEpromBuf
operator|->
name|NvramSubVendorID
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|PCI_Vendor_ID_TEKRAM
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramSubVendorID
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|PCI_Vendor_ID_TEKRAM
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramSubSysID
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|PCI_Device_ID_TRM_S1040
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramSubSysID
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|PCI_Device_ID_TRM_S1040
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramSubClass
operator|=
literal|0x00
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramVendorID
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|PCI_Vendor_ID_TEKRAM
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramVendorID
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|PCI_Vendor_ID_TEKRAM
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramDeviceID
index|[
literal|0
index|]
operator|=
operator|(
name|u_int8_t
operator|)
name|PCI_Device_ID_TRM_S1040
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramDeviceID
index|[
literal|1
index|]
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|PCI_Device_ID_TRM_S1040
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramReserved
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|dAddr
operator|=
literal|0
operator|,
name|dpEeprom
operator|=
operator|(
name|u_long
operator|*
operator|)
name|pEEpromBuf
operator|->
name|NvramTarget
init|;
name|dAddr
operator|<
literal|16
condition|;
name|dAddr
operator|++
operator|,
name|dpEeprom
operator|++
control|)
block|{
operator|*
name|dpEeprom
operator|=
literal|0x00000077
expr_stmt|;
comment|/* NvmTarCfg3,NvmTarCfg2,NvmTarPeriod,NvmTarCfg0 */
block|}
operator|*
name|dpEeprom
operator|++
operator|=
literal|0x04000F07
expr_stmt|;
comment|/* NvramMaxTag,NvramDelayTime,NvramChannelCfg,NvramScsiId */
operator|*
name|dpEeprom
operator|++
operator|=
literal|0x00000015
expr_stmt|;
comment|/* NvramReserved1,NvramBootLun,NvramBootTarget,NvramReserved0 */
for|for
control|(
name|dAddr
operator|=
literal|0
init|;
name|dAddr
operator|<
literal|12
condition|;
name|dAddr
operator|++
operator|,
name|dpEeprom
operator|++
control|)
operator|*
name|dpEeprom
operator|=
literal|0x00
expr_stmt|;
name|pEEpromBuf
operator|->
name|NvramCheckSum
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|wAddr
operator|=
literal|0
operator|,
name|wCheckSum
operator|=
literal|0
operator|,
name|wpEeprom
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|pEEpromBuf
init|;
name|wAddr
operator|<
literal|63
condition|;
name|wAddr
operator|++
operator|,
name|wpEeprom
operator|++
control|)
name|wCheckSum
operator|+=
operator|*
name|wpEeprom
expr_stmt|;
operator|*
name|wpEeprom
operator|=
literal|0x1234
operator|-
name|wCheckSum
expr_stmt|;
name|NVRAM_trm_write_all
argument_list|(
name|pEEpromBuf
argument_list|,
name|pACB
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|trm_initAdapter
parameter_list|(
name|PACB
name|pACB
parameter_list|,
name|u_int16_t
name|unit
parameter_list|)
block|{
name|PNVRAMTYPE
name|pEEpromBuf
decl_stmt|;
name|u_int16_t
name|wval
decl_stmt|;
name|u_int8_t
name|bval
decl_stmt|;
name|pEEpromBuf
operator|=
operator|&
name|trm_eepromBuf
index|[
name|unit
index|]
expr_stmt|;
comment|/* 250ms selection timeout */
name|trm_reg_write8
argument_list|(
name|SEL_TIMEOUT
argument_list|,
name|TRMREG_SCSI_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Mask all the interrupt */
name|trm_reg_write8
argument_list|(
literal|0x00
argument_list|,
name|TRMREG_DMA_INTEN
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
literal|0x00
argument_list|,
name|TRMREG_SCSI_INTEN
argument_list|)
expr_stmt|;
comment|/* Reset SCSI module */
name|trm_reg_write16
argument_list|(
name|DO_RSTMODULE
argument_list|,
name|TRMREG_SCSI_CONTROL
argument_list|)
expr_stmt|;
comment|/* program configuration 0 */
name|pACB
operator|->
name|Config
operator|=
name|HCC_AUTOTERM
operator||
name|HCC_PARITY
expr_stmt|;
if|if
condition|(
name|trm_reg_read8
argument_list|(
name|TRMREG_GEN_STATUS
argument_list|)
operator|&
name|WIDESCSI
condition|)
name|pACB
operator|->
name|Config
operator||=
name|HCC_WIDE_CARD
expr_stmt|;
if|if
condition|(
name|pEEpromBuf
operator|->
name|NvramChannelCfg
operator|&
name|NAC_POWERON_SCSI_RESET
condition|)
name|pACB
operator|->
name|Config
operator||=
name|HCC_SCSI_RESET
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|Config
operator|&
name|HCC_PARITY
condition|)
name|bval
operator|=
name|PHASELATCH
operator||
name|INITIATOR
operator||
name|BLOCKRST
operator||
name|PARITYCHECK
expr_stmt|;
else|else
name|bval
operator|=
name|PHASELATCH
operator||
name|INITIATOR
operator||
name|BLOCKRST
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|bval
argument_list|,
name|TRMREG_SCSI_CONFIG0
argument_list|)
expr_stmt|;
comment|/* program configuration 1 */
name|trm_reg_write8
argument_list|(
literal|0x13
argument_list|,
name|TRMREG_SCSI_CONFIG1
argument_list|)
expr_stmt|;
comment|/* program Host ID */
name|bval
operator|=
name|pEEpromBuf
operator|->
name|NvramScsiId
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|bval
argument_list|,
name|TRMREG_SCSI_HOSTID
argument_list|)
expr_stmt|;
comment|/* set ansynchronous transfer */
name|trm_reg_write8
argument_list|(
literal|0x00
argument_list|,
name|TRMREG_SCSI_OFFSET
argument_list|)
expr_stmt|;
comment|/* Trun LED control off*/
name|wval
operator|=
name|trm_reg_read16
argument_list|(
name|TRMREG_GEN_CONTROL
argument_list|)
operator|&
literal|0x7F
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|wval
argument_list|,
name|TRMREG_GEN_CONTROL
argument_list|)
expr_stmt|;
comment|/* DMA config */
name|wval
operator|=
name|trm_reg_read16
argument_list|(
name|TRMREG_DMA_CONFIG
argument_list|)
operator||
name|DMA_ENHANCE
expr_stmt|;
name|trm_reg_write16
argument_list|(
name|wval
argument_list|,
name|TRMREG_DMA_CONFIG
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupt status */
name|trm_reg_read8
argument_list|(
name|TRMREG_SCSI_INTSTATUS
argument_list|)
expr_stmt|;
comment|/* Enable SCSI interrupt */
name|trm_reg_write8
argument_list|(
literal|0x7F
argument_list|,
name|TRMREG_SCSI_INTEN
argument_list|)
expr_stmt|;
name|trm_reg_write8
argument_list|(
name|EN_SCSIINTR
argument_list|,
name|TRMREG_DMA_INTEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_mapSRB
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|PACB
name|pACB
decl_stmt|;
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|arg
expr_stmt|;
name|pACB
operator|->
name|srb_physbase
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trm_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|baddr
decl_stmt|;
name|baddr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|baddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PACB
name|trm_init
parameter_list|(
name|u_int16_t
name|unit
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|PACB
name|pACB
decl_stmt|;
name|int
name|rid
init|=
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|adaptType
init|=
literal|0
decl_stmt|;
name|pACB
operator|=
operator|(
name|PACB
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pACB
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: cannot allocate ACB !\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pACB
operator|->
name|iores
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|iores
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"trm_init: bus_alloc_resource failed!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCI_DEVICEID_TRMS1040
case|:
name|adaptType
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PCI_DEVICEID_TRMS2080
case|:
name|adaptType
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"trm_init %d: unknown adapter type!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|pACB
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|pACB
operator|->
name|tag
operator|=
name|rman_get_bustag
argument_list|(
name|pACB
operator|->
name|iores
argument_list|)
expr_stmt|;
name|pACB
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|pACB
operator|->
name|iores
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|MAXBSIZE
argument_list|,
comment|/*nsegments*/
name|TRM_NSEG
argument_list|,
comment|/*maxsegsz*/
name|TRM_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
comment|/* dmat */
operator|&
name|pACB
operator|->
name|buffer_dmat
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* DMA tag for our ccb structures */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|pACB
operator|->
name|parent_dmat
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|TRM_MAX_SRB_CNT
operator|*
sizeof|sizeof
argument_list|(
name|TRM_SRB
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|TRM_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
comment|/*dmat*/
operator|&
name|pACB
operator|->
name|srb_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trm_init %d: bus_dma_tag_create SRB failure\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pACB
operator|->
name|pFreeSRB
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pACB
operator|->
name|srb_dmamap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trm_init %d: bus_dmamem_alloc SRB failure\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|,
name|pACB
operator|->
name|pFreeSRB
argument_list|,
name|TRM_MAX_SRB_CNT
operator|*
sizeof|sizeof
argument_list|(
name|TRM_SRB
argument_list|)
argument_list|,
name|trm_mapSRB
argument_list|,
name|pACB
argument_list|,
comment|/* flags */
literal|0
argument_list|)
expr_stmt|;
comment|/* Create, allocate, and map DMA buffers for autosense data */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|*
name|TRM_MAX_SRB_CNT
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|TRM_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
operator|&
name|pACB
operator|->
name|sense_dmat
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create sense buffer dmat\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pACB
operator|->
name|sense_buffers
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pACB
operator|->
name|sense_dmamap
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|bus_dmamap_load
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|,
name|pACB
operator|->
name|sense_buffers
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|*
name|TRM_MAX_SRB_CNT
argument_list|,
name|trm_dmamap_cb
argument_list|,
operator|&
name|pACB
operator|->
name|sense_busaddr
argument_list|,
comment|/*flags*/
literal|0
argument_list|)
expr_stmt|;
name|trm_check_eeprom
argument_list|(
operator|&
name|trm_eepromBuf
index|[
name|unit
index|]
argument_list|,
name|pACB
argument_list|)
expr_stmt|;
name|trm_initACB
argument_list|(
name|pACB
argument_list|,
name|adaptType
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|pACB
operator|->
name|max_id
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pACB
operator|->
name|AdaptSCSIID
operator|==
name|i
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|pACB
operator|->
name|max_lun
operator|+
literal|1
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|pACB
operator|->
name|scan_devices
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
comment|/* we assume we need to scan all devices */
name|trm_initDCB
argument_list|(
name|pACB
argument_list|,
operator|&
name|pACB
operator|->
name|DCBarray
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|unit
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
name|pACB
operator|->
name|pFreeSRB
argument_list|,
name|TRM_MAX_SRB_CNT
operator|*
sizeof|sizeof
argument_list|(
name|TRM_SRB
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent_dmat*/
name|NULL
argument_list|,
comment|/*alignment*/
literal|1
argument_list|,
comment|/*boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/*filter*/
name|NULL
argument_list|,
comment|/*filterarg*/
name|NULL
argument_list|,
comment|/*maxsize*/
name|TRM_MAX_SG_LISTENTRY
operator|*
sizeof|sizeof
argument_list|(
name|SGentry
argument_list|)
argument_list|,
comment|/*nsegments*/
literal|1
argument_list|,
comment|/*maxsegsz*/
name|TRM_MAXTRANSFER_SIZE
argument_list|,
comment|/*flags*/
literal|0
argument_list|,
comment|/*lockfunc*/
name|busdma_lock_mutex
argument_list|,
comment|/*lockarg*/
operator|&
name|Giant
argument_list|,
comment|/*dmat*/
operator|&
name|pACB
operator|->
name|sg_dmat
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|trm_initSRB
argument_list|(
name|pACB
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"trm_initSRB: error\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|trm_initAdapter
argument_list|(
name|pACB
argument_list|,
name|unit
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"trm_initAdapter: initial ERROR\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
return|return
operator|(
name|pACB
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|pACB
operator|->
name|iores
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pACB
operator|->
name|iores
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|sense_dmamap
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_buffers
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|sense_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|sg_dmat
condition|)
block|{
name|trm_destroySRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|srb_dmamap
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|pFreeSRB
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|srb_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cam_devq
modifier|*
name|device_Q
decl_stmt|;
name|u_long
name|device_id
decl_stmt|;
name|PACB
name|pACB
init|=
literal|0
decl_stmt|;
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_id
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * These cards do not allow memory mapped accesses 	 */
if|if
condition|(
operator|(
name|pACB
operator|=
name|trm_init
argument_list|(
operator|(
name|u_int16_t
operator|)
name|unit
argument_list|,
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: trm_init error!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* After setting up the adapter, map our interrupt */
comment|/*   	 * Now let the CAM generic SCSI layer find the SCSI devices on the bus 	 * start queue to reset to the idle loop. 	 * Create device queue of SIM(s) 	 * (MAX_START_JOB - 1) : max_sim_transactions 	 */
name|pACB
operator|->
name|irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|irq
operator|==
name|NULL
operator|||
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|pACB
operator|->
name|irq
argument_list|,
name|INTR_TYPE_CAM
argument_list|,
name|NULL
argument_list|,
name|trm_Interrupt
argument_list|,
name|pACB
argument_list|,
operator|&
name|pACB
operator|->
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: register Interrupt handler error!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|device_Q
operator|=
name|cam_simq_alloc
argument_list|(
name|TRM_MAX_START_JOB
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_Q
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: device_Q == NULL !\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Now tell the generic SCSI layer 	 * about our bus. 	 * If this is the xpt layer creating a sim, then it's OK 	 * to wait for an allocation. 	 * XXX Should we pass in a flag to indicate that wait is OK? 	 * 	 *                    SIM allocation 	 * 	 *                 SCSI Interface Modules 	 * The sim driver creates a sim for each controller.  The sim device 	 * queue is separately created in order to allow resource sharing betwee 	 * sims.  For instance, a driver may create one sim for each channel of 	 * a multi-channel controller and use the same queue for each channel. 	 * In this way, the queue resources are shared across all the channels 	 * of the multi-channel controller. 	 * trm_action     : sim_action_func 	 * trm_poll       : sim_poll_func 	 * "trm"        : sim_name ,if sim_name =  "xpt" ..M_DEVBUF,M_WAITOK 	 * pACB         : *softc    if sim_name<> "xpt" ..M_DEVBUF,M_NOWAIT 	 * pACB->unit   : unit 	 * 1            : max_dev_transactions 	 * MAX_TAGS     : max_tagged_dev_transactions 	 * 	 *  *******Construct our first channel SIM entry 	 */
name|pACB
operator|->
name|psim
operator|=
name|cam_sim_alloc
argument_list|(
name|trm_action
argument_list|,
name|trm_poll
argument_list|,
literal|"trm"
argument_list|,
name|pACB
argument_list|,
name|unit
argument_list|,
literal|1
argument_list|,
name|TRM_MAX_TAGS_CMD_QUEUE
argument_list|,
name|device_Q
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|psim
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: SIM allocate fault !\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|cam_simq_free
argument_list|(
name|device_Q
argument_list|)
expr_stmt|;
comment|/* SIM allocate fault*/
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: xpt_bus_register fault !\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|pACB
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|printf
argument_list|(
literal|"trm%d: xpt_create_path fault !\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|pACB
operator|->
name|iores
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pACB
operator|->
name|iores
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|sg_dmat
condition|)
block|{
name|trm_destroySRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|srb_dmamap
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|pFreeSRB
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|srb_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|sense_dmamap
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_buffers
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pACB
operator|->
name|sense_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|buffer_dmat
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pACB
operator|->
name|irq
argument_list|,
name|pACB
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|irq
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pACB
operator|->
name|psim
condition|)
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *                  pci_device *         trm_probe (device_t tag, pcidi_t type) * */
end_comment

begin_function
specifier|static
name|int
name|trm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCI_DEVICEID_TRMS1040
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Tekram DC395U/UW/F DC315/U Fast20 Wide SCSI Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
name|PCI_DEVICEID_TRMS2080
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Tekram DC395U2D/U2W Fast40 Wide SCSI Adapter"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|trm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|PACB
name|pACB
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|pACB
operator|->
name|iores
argument_list|)
expr_stmt|;
name|trm_destroySRB
argument_list|(
name|pACB
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|sg_dmat
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|pFreeSRB
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|,
name|pACB
operator|->
name|srb_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|srb_dmat
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_buffers
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|,
name|pACB
operator|->
name|sense_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|sense_dmat
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|pACB
operator|->
name|buffer_dmat
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|pACB
operator|->
name|irq
argument_list|,
name|pACB
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|pACB
operator|->
name|irq
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|pACB
operator|->
name|ppath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|pACB
operator|->
name|ppath
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|pACB
operator|->
name|psim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|pACB
operator|->
name|psim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|trm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|trm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|trm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|trm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|trm_driver
init|=
block|{
literal|"trm"
block|,
name|trm_methods
block|,
expr|sizeof
operator|(
expr|struct
name|_ACB
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|trm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|trm
argument_list|,
name|pci
argument_list|,
name|trm_driver
argument_list|,
name|trm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|trm
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|trm
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

