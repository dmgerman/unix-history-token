begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_tx.c,v 1.9.2.1 2000/02/21 22:29:13 niklas Exp $	*/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 Semen Ustimenko (semen@iclub.nsu.ru)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * EtherPower II 10/100  Fast Ethernet (tx0)  * (aka SMC9432TX based on SMC83c170 EPIC chip)  *   * Thanks are going to Steve Bauer and Jason Wright.  *  * todo:  *	Implement FULL IFF_MULTICAST support.  *	  */
end_comment

begin_comment
comment|/* We should define compile time options before if_txvar.h included */
end_comment

begin_define
define|#
directive|define
name|EARLY_RX
value|1
end_define

begin_comment
comment|/*#define	EPIC_DEBUG	1*/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|NBPFILTER
value|1
end_define

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for vtophys */
end_comment

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miidevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/lxtphyreg.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|<pci/if_txvar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __OpenBSD__ */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_define
define|#
directive|define
name|NVLAN
value|0
end_define

begin_comment
comment|/* not sure if/how OpenBSD supports VLANs */
end_comment

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miidevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/lxtphyreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcidevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/if_txvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|tx
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|EPIC_INTR_RET_TYPE
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __OpenBSD__ */
end_comment

begin_define
define|#
directive|define
name|EPIC_INTR_RET_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|epic_ifioctl
name|__P
argument_list|(
operator|(
specifier|register
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EPIC_INTR_RET_TYPE
name|epic_intr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_common_attach
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_init
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_stop
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_rx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_tx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_init_rings
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_free_rings
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_stop_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_start_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_rx_mode
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_tx_mode
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_set_mc_table
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_read_eeprom
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_output_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_input_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_eeprom_clock
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_write_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_read_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_read_phy_reg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_write_phy_reg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_miibus_readreg
name|__P
argument_list|(
operator|(
name|device_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_miibus_writereg
name|__P
argument_list|(
operator|(
name|device_t
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_miibus_statchg
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_miibus_mediainit
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_ifmedia_upd
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifmedia_sts
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -------------------------------------------------------------------------    OS-specific part    ------------------------------------------------------------------------- */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
end_if

begin_comment
comment|/* -----------------------------OpenBSD------------------------------------- */
end_comment

begin_decl_stmt
name|int
name|epic_openbsd_probe
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epic_openbsd_attach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|epic_openbsd_shutdown
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfattach
name|tx_ca
init|=
block|{
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
block|,
name|epic_openbsd_probe
block|,
name|epic_openbsd_attach
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cfdriver
name|tx_cd
init|=
block|{
name|NULL
block|,
literal|"tx"
block|,
name|DV_IFNET
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Synopsis: Check if device id corresponds with SMC83C170 id. */
end_comment

begin_function
name|int
name|epic_openbsd_probe
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|void
modifier|*
name|match
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
if|if
condition|(
name|PCI_VENDOR
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|!=
name|SMC_VENDORID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|PCI_PRODUCT
argument_list|(
name|pa
operator|->
name|pa_id
argument_list|)
operator|==
name|SMC_DEVICEID_83C170
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|epic_openbsd_attach
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|self
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|self
decl_stmt|;
name|struct
name|pci_attach_args
modifier|*
name|pa
init|=
name|aux
decl_stmt|;
name|pci_chipset_tag_t
name|pc
init|=
name|pa
operator|->
name|pa_pc
decl_stmt|;
name|pci_intr_handle_t
name|ih
decl_stmt|;
specifier|const
name|char
modifier|*
name|intrstr
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|bus_addr_t
name|iobase
decl_stmt|;
name|bus_size_t
name|iosize
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|;
name|command
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
name|command
operator||=
name|PCI_COMMAND_IO_ENABLE
operator||
name|PCI_COMMAND_MEM_ENABLE
operator||
name|PCI_COMMAND_MASTER_ENABLE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_conf_read
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EPIC_USEIOSPACE
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|PCI_COMMAND_IO_ENABLE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": failed to enable I/O ports\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pci_io_find
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BASEIO
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|iosize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't find i/o space\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bus_space_map
argument_list|(
name|pa
operator|->
name|pa_iot
argument_list|,
name|iobase
argument_list|,
name|iosize
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_sh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map i/o space\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|pa
operator|->
name|pa_iot
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|PCI_COMMAND_MEM_ENABLE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|": failed to enable memory mapping\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pci_mem_find
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_tag
argument_list|,
name|PCI_BASEMEM
argument_list|,
operator|&
name|iobase
argument_list|,
operator|&
name|iosize
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't find mem space\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bus_space_map
argument_list|(
name|pa
operator|->
name|pa_memt
argument_list|,
name|iobase
argument_list|,
name|iosize
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_sh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map i/o space\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|pa
operator|->
name|pa_memt
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|dev
operator|.
name|dv_xname
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epic_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epic_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epic_ifwatchdog
expr_stmt|;
comment|/* Do common attach procedure */
if|if
condition|(
name|epic_common_attach
argument_list|(
name|sc
argument_list|)
condition|)
return|return;
comment|/* Map interrupt */
if|if
condition|(
name|pci_intr_map
argument_list|(
name|pc
argument_list|,
name|pa
operator|->
name|pa_intrtag
argument_list|,
name|pa
operator|->
name|pa_intrpin
argument_list|,
name|pa
operator|->
name|pa_intrline
argument_list|,
operator|&
name|ih
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|": can't map interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|intrstr
operator|=
name|pci_intr_string
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ih
operator|=
name|pci_intr_establish
argument_list|(
name|pc
argument_list|,
name|ih
argument_list|,
name|IPL_NET
argument_list|,
name|epic_intr
argument_list|,
name|sc
argument_list|,
name|self
operator|->
name|dv_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|sc
operator|->
name|sc_ih
condition|)
block|{
name|printf
argument_list|(
literal|": can't establish interrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrstr
condition|)
name|printf
argument_list|(
literal|" at %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|": %s"
argument_list|,
name|intrstr
argument_list|)
expr_stmt|;
comment|/* Display some info */
name|printf
argument_list|(
literal|" address %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_macaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init ifmedia interface */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|.
name|mii_media
argument_list|,
literal|0
argument_list|,
name|epic_ifmedia_upd
argument_list|,
name|epic_ifmedia_sts
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mii
operator|.
name|mii_ifp
operator|=
name|ifp
expr_stmt|;
name|sc
operator|->
name|sc_mii
operator|.
name|mii_readreg
operator|=
name|epic_miibus_readreg
expr_stmt|;
name|sc
operator|->
name|sc_mii
operator|.
name|mii_writereg
operator|=
name|epic_miibus_writereg
expr_stmt|;
name|sc
operator|->
name|sc_mii
operator|.
name|mii_statchg
operator|=
name|epic_miibus_statchg
expr_stmt|;
name|mii_phy_probe
argument_list|(
name|self
argument_list|,
operator|&
name|sc
operator|->
name|sc_mii
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|.
name|mii_phys
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_NONE
argument_list|)
expr_stmt|;
block|}
else|else
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_mii
operator|.
name|mii_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
comment|/* Attach os interface and bpf */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set shutdown routine to stop DMA process */
name|shutdownhook_establish
argument_list|(
name|epic_openbsd_shutdown
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Simple call epic_stop() */
end_comment

begin_function
name|void
name|epic_openbsd_shutdown
parameter_list|(
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/* -----------------------------FreeBSD------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
name|int
name|epic_freebsd_probe
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_freebsd_attach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_freebsd_shutdown
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_freebsd_detach
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|epic_type
modifier|*
name|epic_devtype
name|__P
argument_list|(
operator|(
name|device_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|epic_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|epic_freebsd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|epic_freebsd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|epic_freebsd_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|epic_freebsd_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|epic_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|epic_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|epic_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_mediainit
argument_list|,
name|epic_miibus_mediainit
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|epic_driver
init|=
block|{
literal|"tx"
block|,
name|epic_methods
block|,
expr|sizeof
operator|(
name|epic_softc_t
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|epic_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_tx
argument_list|,
name|pci
argument_list|,
name|epic_driver
argument_list|,
name|epic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|tx
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|epic_type
name|epic_devs
index|[]
init|=
block|{
block|{
name|SMC_VENDORID
block|,
name|SMC_DEVICEID_83C170
block|,
literal|"SMC EtherPower II 10/100"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|epic_freebsd_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|epic_type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|epic_devtype
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|t
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|epic_type
modifier|*
name|epic_devtype
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|epic_type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|epic_devs
expr_stmt|;
while|while
condition|(
name|t
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|t
operator|->
name|ven_id
operator|)
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|t
operator|->
name|dev_id
operator|)
condition|)
block|{
return|return
operator|(
name|t
operator|)
return|;
block|}
name|t
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EPIC_USEIOSPACE
argument_list|)
end_if

begin_define
define|#
directive|define
name|EPIC_RES
value|SYS_RES_IOPORT
end_define

begin_define
define|#
directive|define
name|EPIC_RID
value|PCIR_BASEIO
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EPIC_RES
value|SYS_RES_MEMORY
end_define

begin_define
define|#
directive|define
name|EPIC_RID
value|PCIR_BASEMEM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do FreeBSD-specific attach routine, like map registers, alloc softc  * structure and etc.  */
end_comment

begin_function
specifier|static
name|int
name|epic_freebsd_attach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
name|command
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|,
name|rid
decl_stmt|,
name|tmp
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Preinitialize softc structure */
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Fill ifnet structure */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"tx"
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epic_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epic_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epic_ifwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|if_init_f_t
operator|*
operator|)
name|epic_init
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|TX_RING_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* Enable ports, memory and busmastering */
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator||=
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|command
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|command
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_USEIOSPACE
argument_list|)
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|PCIM_CMD_PORTEN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable I/O mapping!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|command
operator|&
name|PCIM_CMD_MEMEN
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable memory mapping!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
endif|#
directive|endif
name|rid
operator|=
name|EPIC_RID
expr_stmt|;
name|sc
operator|->
name|res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|EPIC_RES
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't map ports/memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_st
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
comment|/* Allocate interrupt */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't map interrupt\n"
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|EPIC_RES
argument_list|,
name|EPIC_RID
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|epic_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|EPIC_RES
argument_list|,
name|EPIC_RID
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't set up irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Bring the chip out of low-power mode and reset it. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Workaround for Application Note 7-15 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
name|TEST1_CLOCK_TEST
argument_list|)
expr_stmt|;
comment|/* Do OS independent part, including chip wakeup and reset */
if|if
condition|(
name|epic_common_attach
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"memory distribution error\n"
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|EPIC_RES
argument_list|,
name|EPIC_RID
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Do ifmedia setup */
if|if
condition|(
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|epic_ifmedia_upd
argument_list|,
name|epic_ifmedia_sts
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MII without any PHY!?\n"
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|EPIC_RES
argument_list|,
name|EPIC_RID
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Display ethernet address ,... */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"address %6D,"
argument_list|,
name|sc
operator|->
name|sc_macaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* board type and ... */
name|printf
argument_list|(
literal|" type "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x2c
init|;
name|i
operator|<
literal|0x32
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
operator|(
name|u_int8_t
operator|)
name|tmp
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|u_int8_t
operator|)
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
operator|(
name|u_int8_t
operator|)
name|tmp
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|u_int8_t
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Attach to OS's managers */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
name|fail
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach driver and free resources  */
end_comment

begin_function
specifier|static
name|int
name|epic_freebsd_detach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|EPIC_RES
argument_list|,
name|EPIC_RID
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|pool
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|EPIC_RES
end_undef

begin_undef
undef|#
directive|undef
name|EPIC_RID
end_undef

begin_comment
comment|/*  * Stop all chip I/O so that the kernel's probe routines don't  * get confused by errant DMAs when rebooting.  */
end_comment

begin_function
specifier|static
name|void
name|epic_freebsd_shutdown
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __OpenBSD__ */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------    OS-independing part    ------------------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * This is if_ioctl handler.   */
end_comment

begin_function
specifier|static
name|int
name|epic_ifioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|x
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|==
name|ifr
operator|->
name|ifr_mtu
condition|)
break|break;
comment|/* XXX Though the datasheet doesn't imply any  		 * limitations on RX and TX sizes beside max 64Kb 		 * DMA transfer, seems we can't send more then 1600 		 * data bytes per ethernet packet. (Transmitter hangs 		 * up if more data is sent) 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|+
name|ifp
operator|->
name|if_hdrlen
operator|<=
name|EPIC_MAX_MTU
condition|)
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
else|#
directive|else
comment|/* __OpenBSD__ */
case|case
name|SIOCSIFADDR
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
if|#
directive|if
name|INET
case|case
name|AF_INET
case|:
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Handle IFF_PROMISC flag */
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update out multicast list */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300000
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
argument_list|)
else|:
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * OS-independed part of attach process. allocate memory for descriptors  * and frag lists, wake up chip, read MAC address and PHY identyfier.  * Return -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|epic_common_attach
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|caddr_t
name|pool
decl_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
name|PAGE_SIZE
operator|,
name|sc
operator|->
name|pool
operator|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pool
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|": can't allocate memory for buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Align pool on PAGE_SIZE */
name|pool
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|pool
expr_stmt|;
name|pool
operator|=
call|(
name|caddr_t
call|)
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
name|pool
operator|+
name|PAGE_SIZE
operator|-
literal|1
argument_list|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Distribute memory */
name|sc
operator|->
name|tx_flist
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|rx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|tx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
comment|/* Bring the chip out of low-power mode. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Workaround for Application Note 7-15 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
name|TEST1_CLOCK_TEST
argument_list|)
expr_stmt|;
comment|/* Read mac address from EEPROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
name|i
index|]
operator|=
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Set Non-Volatile Control Register from EEPROM */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|NVCTL
argument_list|,
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|EEPROM_NVCTL
argument_list|)
operator|&
literal|0x1F
argument_list|)
expr_stmt|;
comment|/* Set defaults */
name|sc
operator|->
name|tx_threshold
operator|=
name|TRANSMIT_THRESHOLD
expr_stmt|;
name|sc
operator|->
name|txcon
operator|=
name|TXCON_DEFAULT
expr_stmt|;
name|sc
operator|->
name|miicfg
operator|=
name|MIICFG_SMI_ENABLE
expr_stmt|;
name|sc
operator|->
name|phyid
operator|=
name|EPIC_UNKN_PHY
expr_stmt|;
name|sc
operator|->
name|serinst
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Fetch card id */
name|sc
operator|->
name|cardvend
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIR_SUBVEND_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cardid
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIR_SUBDEV_0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cardvend
operator|!=
name|SMC_VENDORID
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": unknown card vendor 0x%04x\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|cardvend
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is if_start handler. It takes mbufs from if_snd queue  * and queue them for transmit, one by one, until TX ring become full  * or queue become empty.  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|epic_frag_list
modifier|*
name|flist
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|flist
operator|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
comment|/* Get next packet to send */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* If nothing to send, return */
if|if
condition|(
name|NULL
operator|==
name|m0
condition|)
return|return;
comment|/* Fill fragments list */
for|for
control|(
name|m
operator|=
name|m0
operator|,
name|i
operator|=
literal|0
init|;
operator|(
name|NULL
operator|!=
name|m
operator|)
operator|&&
operator|(
name|i
operator|<
name|EPIC_MAX_FRAGS
operator|)
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
operator|,
name|i
operator|++
control|)
block|{
name|flist
operator|->
name|frag
index|[
name|i
index|]
operator|.
name|fraglen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|frag
index|[
name|i
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flist
operator|->
name|numfrags
operator|=
name|i
expr_stmt|;
comment|/* If packet was more than EPIC_MAX_FRAGS parts, */
comment|/* recopy packet to new allocated mbuf cluster */
if|if
condition|(
name|NULL
operator|!=
name|m
condition|)
block|{
name|EPIC_MGETCLUSTER
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|=
literal|1
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
block|}
name|buf
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
name|sc
operator|->
name|pending_txs
operator|++
expr_stmt|;
name|sc
operator|->
name|cur_tx
operator|=
operator|(
name|sc
operator|->
name|cur_tx
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
expr_stmt|;
name|desc
operator|->
name|control
operator|=
literal|0x01
expr_stmt|;
name|desc
operator|->
name|txlength
operator|=
name|max
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
comment|/* Set watchdog timer */
name|ifp
operator|->
name|if_timer
operator|=
literal|8
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|EPIC_BPFTAP_ARG
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Synopsis: Finish all received frames.  */
end_comment

begin_function
specifier|static
name|void
name|epic_rx_done
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int16_t
name|len
decl_stmt|;
name|struct
name|epic_rx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|sc
operator|->
name|rx_desc
index|[
name|sc
operator|->
name|cur_rx
index|]
operator|.
name|status
operator|&
literal|0x8000
operator|)
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|rx_buffer
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|rx_desc
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
comment|/* Switch to next descriptor */
name|sc
operator|->
name|cur_rx
operator|=
operator|(
name|sc
operator|->
name|cur_rx
operator|+
literal|1
operator|)
operator|&
name|RX_RING_MASK
expr_stmt|;
comment|/* Check for errors, this should happend */
comment|/* only if SAVE_ERRORED_PACKETS is set, */
comment|/* normaly rx errors generate RXE interrupt */
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": Rx error status: 0x%x\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|,
name|desc
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
continue|continue;
block|}
comment|/* Save packet length and mbuf contained packet */
name|len
operator|=
name|desc
operator|->
name|rxlength
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|m
operator|=
name|buf
operator|->
name|mbuf
expr_stmt|;
comment|/* Try to get mbuf cluster */
name|EPIC_MGETCLUSTER
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
block|{
name|buf
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Point to new mbuf, and give descriptor to chip */
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* First mbuf in packet holds the ethernet and packet headers */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
operator|(
name|sc
operator|->
name|sc_if
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* Give mbuf to BPFILTER */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|EPIC_BPFTAP_ARG
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
endif|#
directive|endif
comment|/* !__FreeBSD__ */
comment|/* Second mbuf holds packet ifself */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Give mbuf to OS */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Successfuly received frame */
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Synopsis: Do last phase of transmission. I.e. if desc is   * transmitted, decrease pending_txs counter, free mbuf contained  * packet, switch to next descriptor and repeat until no packets  * are pending or descriptor is not transmitted yet.  */
end_comment

begin_function
specifier|static
name|void
name|epic_tx_done
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|dirty_tx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|dirty_tx
expr_stmt|;
name|status
operator|=
name|desc
operator|->
name|status
expr_stmt|;
comment|/* If packet is not transmitted, thou followed */
comment|/* packets are not transmitted too */
if|if
condition|(
name|status
operator|&
literal|0x8000
condition|)
break|break;
comment|/* Packet is transmitted. Switch to next and */
comment|/* free mbuf */
name|sc
operator|->
name|pending_txs
operator|--
expr_stmt|;
name|sc
operator|->
name|dirty_tx
operator|=
operator|(
name|sc
operator|->
name|dirty_tx
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* Check for errors and collisions */
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0x1F
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|status
operator|&
literal|0x1001
operator|)
operator|==
literal|0x1001
condition|)
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": frame not transmitted due collisions\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt function  */
end_comment

begin_function
specifier|static
name|EPIC_INTR_RET_TYPE
name|epic_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|,
name|i
init|=
literal|4
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|int
name|claimed
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|i
operator|--
operator|&&
operator|(
operator|(
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|)
operator|&
name|INTSTAT_INT_ACTV
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|claimed
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_RCC
operator||
name|INTSTAT_OVW
operator|)
condition|)
block|{
name|epic_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|status
operator|&
name|INTSTAT_OVW
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": RX buffer overflow\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|INTSTAT_RQE
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": RX FIFO overflow\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|)
operator|&
name|COMMAND_RXQUEUED
operator|)
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator|)
condition|)
block|{
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_head
condition|)
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
comment|/* Check for errors */
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_RXE
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator|)
condition|)
block|{
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": PCI fatal error occured (%s%s%s%s)\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PMA
operator|)
condition|?
literal|"PMA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PTA
operator|)
condition|?
literal|" PTA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_APE
operator|)
condition|?
literal|" APE"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_DPE
operator|)
condition|?
literal|" DPE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|&
name|INTSTAT_RXE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": CRC/Alignment error\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* Tx FIFO underflow. Increase tx threshold, */
comment|/* if it grown above 2048, disable EARLY_TX */
if|if
condition|(
name|status
operator|&
name|INTSTAT_TXU
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_threshold
operator|>
literal|0x800
condition|)
block|{
name|sc
operator|->
name|txcon
operator|&=
operator|~
name|TXCON_EARLY_TRANSMIT_ENABLE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": TX underrun error, early tx disabled\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tx_threshold
operator|+=
literal|0x40
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": TX underrun error, tx threshold increased to %d\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|,
name|sc
operator|->
name|tx_threshold
operator|)
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXUGO
operator||
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* If no packets are pending, thus no timeouts */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
return|return
name|claimed
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Synopsis: This one is called if packets wasn't transmitted  * during timeout. Try to deallocate transmitted packets, and   * if success continue to work.  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifwatchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": device timeout %d packets, "
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|)
expr_stmt|;
comment|/* Try to finish queued packets */
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If not successful */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|>
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sc
operator|->
name|pending_txs
expr_stmt|;
comment|/* Reinitialize board */
name|printf
argument_list|(
literal|"reinitialization\n"
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"seems we can continue normaly\n"
argument_list|)
expr_stmt|;
comment|/* Start output */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
condition|)
name|epic_ifstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set media options.  */
end_comment

begin_function
specifier|static
name|int
name|epic_ifmedia_upd
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|int
name|cfg
decl_stmt|,
name|media
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|mii
operator|->
name|mii_media
expr_stmt|;
name|media
operator|=
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
expr_stmt|;
comment|/* Do not do anything if interface is not up */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Lookup current selected PHY 	 */
if|if
condition|(
name|IFM_INST
argument_list|(
name|media
argument_list|)
operator|==
name|sc
operator|->
name|serinst
condition|)
block|{
name|sc
operator|->
name|phyid
operator|=
name|EPIC_SERIAL
expr_stmt|;
name|sc
operator|->
name|physc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* If we're not selecting serial interface, select MII mode */
name|sc
operator|->
name|miicfg
operator|&=
operator|~
name|MIICFG_SERIAL_ENABLE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICFG
argument_list|,
name|sc
operator|->
name|miicfg
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": MII selected\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Default to unknown PHY */
name|sc
operator|->
name|phyid
operator|=
name|EPIC_UNKN_PHY
expr_stmt|;
comment|/* Lookup selected PHY */
for|for
control|(
name|miisc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mii
operator|->
name|mii_phys
argument_list|)
init|;
name|miisc
operator|!=
name|NULL
condition|;
name|miisc
operator|=
name|LIST_NEXT
argument_list|(
name|miisc
argument_list|,
name|mii_list
argument_list|)
control|)
block|{
if|if
condition|(
name|IFM_INST
argument_list|(
name|media
argument_list|)
operator|==
name|miisc
operator|->
name|mii_inst
condition|)
block|{
name|sc
operator|->
name|physc
operator|=
name|miisc
expr_stmt|;
break|break;
block|}
block|}
comment|/* Identify selected PHY */
if|if
condition|(
name|sc
operator|->
name|physc
condition|)
block|{
name|int
name|id1
decl_stmt|,
name|id2
decl_stmt|,
name|model
decl_stmt|,
name|oui
decl_stmt|;
name|id1
operator|=
name|PHY_READ
argument_list|(
name|sc
operator|->
name|physc
argument_list|,
name|MII_PHYIDR1
argument_list|)
expr_stmt|;
name|id2
operator|=
name|PHY_READ
argument_list|(
name|sc
operator|->
name|physc
argument_list|,
name|MII_PHYIDR2
argument_list|)
expr_stmt|;
name|oui
operator|=
name|MII_OUI
argument_list|(
name|id1
argument_list|,
name|id2
argument_list|)
expr_stmt|;
name|model
operator|=
name|MII_MODEL
argument_list|(
name|id2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|oui
condition|)
block|{
case|case
name|MII_OUI_QUALSEMI
case|:
if|if
condition|(
name|model
operator|==
name|MII_MODEL_QUALSEMI_QS6612
condition|)
name|sc
operator|->
name|phyid
operator|=
name|EPIC_QS6612_PHY
expr_stmt|;
break|break;
case|case
name|MII_OUI_xxALTIMA
case|:
if|if
condition|(
name|model
operator|==
name|MII_MODEL_xxALTIMA_AC101
condition|)
name|sc
operator|->
name|phyid
operator|=
name|EPIC_AC101_PHY
expr_stmt|;
break|break;
case|case
name|MII_OUI_xxLEVEL1
case|:
if|if
condition|(
name|model
operator|==
name|MII_MODEL_xxLEVEL1_LXT970
condition|)
name|sc
operator|->
name|phyid
operator|=
name|EPIC_LXT970_PHY
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Do PHY specific card setup 	 */
comment|/* Call this, to isolate all not selected PHYs and 	 * set up selected 	 */
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* Do our own setup */
switch|switch
condition|(
name|sc
operator|->
name|phyid
condition|)
block|{
case|case
name|EPIC_QS6612_PHY
case|:
break|break;
case|case
name|EPIC_AC101_PHY
case|:
comment|/* We have to powerup fiber tranceivers */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_FX
condition|)
name|sc
operator|->
name|miicfg
operator||=
name|MIICFG_694_ENABLE
expr_stmt|;
else|else
name|sc
operator|->
name|miicfg
operator|&=
operator|~
name|MIICFG_694_ENABLE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICFG
argument_list|,
name|sc
operator|->
name|miicfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPIC_LXT970_PHY
case|:
comment|/* We have to powerup fiber tranceivers */
name|cfg
operator|=
name|PHY_READ
argument_list|(
name|sc
operator|->
name|physc
argument_list|,
name|MII_LXTPHY_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_FX
condition|)
name|cfg
operator||=
name|CONFIG_LEDC1
operator||
name|CONFIG_LEDC0
expr_stmt|;
else|else
name|cfg
operator|&=
operator|~
operator|(
name|CONFIG_LEDC1
operator||
name|CONFIG_LEDC0
operator|)
expr_stmt|;
name|PHY_WRITE
argument_list|(
name|sc
operator|->
name|physc
argument_list|,
name|MII_LXTPHY_CONFIG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPIC_SERIAL
case|:
comment|/* Select serial PHY, (10base2/BNC usually) */
name|sc
operator|->
name|miicfg
operator||=
name|MIICFG_694_ENABLE
operator||
name|MIICFG_SERIAL_ENABLE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICFG
argument_list|,
name|sc
operator|->
name|miicfg
argument_list|)
expr_stmt|;
comment|/* There is no driver to fill this */
name|mii
operator|->
name|mii_media_active
operator|=
name|media
expr_stmt|;
name|mii
operator|->
name|mii_media_status
operator|=
literal|0
expr_stmt|;
comment|/* We need to call this manualy as i wasn't called 		 * in mii_mediachg() 		 */
name|epic_miibus_statchg
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": SERIAL selected\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": ERROR! Unknown PHY selected\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report current media status.  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifmedia_sts
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|mii
operator|->
name|mii_media
expr_stmt|;
comment|/* Nothing should be selected if interface is down */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_NONE
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Call underlying pollstat, if not serial PHY */
if|if
condition|(
name|sc
operator|->
name|phyid
operator|!=
name|EPIC_SERIAL
condition|)
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* Simply copy media info */
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Callback routine, called on media change.  */
end_comment

begin_function
specifier|static
name|void
name|epic_miibus_statchg
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|media
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|media
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|sc
operator|->
name|txcon
operator|&=
operator|~
operator|(
name|TXCON_LOOPBACK_MODE
operator||
name|TXCON_FULL_DUPLEX
operator|)
expr_stmt|;
comment|/* If we are in full-duplex mode or loopback operation, 	 * we need to decouple receiver and transmitter. 	 */
if|if
condition|(
name|IFM_OPTIONS
argument_list|(
name|media
argument_list|)
operator|&
operator|(
name|IFM_FDX
operator||
name|IFM_LOOP
operator|)
condition|)
name|sc
operator|->
name|txcon
operator||=
name|TXCON_FULL_DUPLEX
expr_stmt|;
comment|/* On some cards we need manualy set fullduplex led */
if|if
condition|(
name|sc
operator|->
name|cardid
operator|==
name|SMC9432FTX
operator|||
name|sc
operator|->
name|cardid
operator|==
name|SMC9432FTX_SC
condition|)
block|{
if|if
condition|(
name|IFM_OPTIONS
argument_list|(
name|media
argument_list|)
operator|&
name|IFM_FDX
condition|)
name|sc
operator|->
name|miicfg
operator||=
name|MIICFG_694_ENABLE
expr_stmt|;
else|else
name|sc
operator|->
name|miicfg
operator|&=
operator|~
name|MIICFG_694_ENABLE
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICFG
argument_list|,
name|sc
operator|->
name|miicfg
argument_list|)
expr_stmt|;
block|}
comment|/* Update baudrate */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_TX
operator|&&
name|IFM_SUBTYPE
argument_list|(
name|media
argument_list|)
operator|==
name|IFM_100_FX
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
else|else
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_miibus_mediainit
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|media
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|ifm
operator|=
operator|&
name|mii
operator|->
name|mii_media
expr_stmt|;
comment|/* Add Serial Media Interface if present, this applies to 	 * SMC9432BTX serie 	 */
if|if
condition|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICFG
argument_list|)
operator|&
name|MIICFG_PHY_PRESENT
condition|)
block|{
comment|/* Store its instance */
name|sc
operator|->
name|serinst
operator|=
name|mii
operator|->
name|mii_instance
operator|++
expr_stmt|;
comment|/* Add as 10base2/BNC media */
name|media
operator|=
name|IFM_MAKEWORD
argument_list|(
name|IFM_ETHER
argument_list|,
name|IFM_10_2
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|serinst
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
name|ifm
argument_list|,
name|media
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Report to user */
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": serial PHY detected (10Base2/BNC)\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Reset chip, allocate rings, and update media.  */
end_comment

begin_function
specifier|static
name|int
name|epic_init
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* If interface is already running, then we need not do anything */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Soft reset the chip (we have to power up card before) */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Reset takes 15 pci ticks which depends on PCI bus speed. 	 * Assuming it>= 33000000 hz, we have wait at least 495e-6 sec. 	 */
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* Wake up */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Workaround for Application Note 7-15 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
name|TEST1_CLOCK_TEST
argument_list|)
expr_stmt|;
comment|/* Initialize rings */
if|if
condition|(
name|epic_init_rings
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": failed to init rings\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Give rings to EPIC */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PRCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PTCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put node address to EPIC */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN0
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN1
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN2
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|sc_macaddr
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* Set tx mode, includeing transmit threshold */
name|epic_set_tx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Compute and set RXCON. */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set multicast table */
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable interrupts by setting the interrupt mask. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTMASK
argument_list|,
name|INTSTAT_RCC
operator||
comment|/* INTSTAT_RQE | INTSTAT_OVW | INTSTAT_RXE | */
comment|/* INTSTAT_TXC | */
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_FATAL
argument_list|)
expr_stmt|;
comment|/* Acknowledge all pending interrupts */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable interrupts,  set for PCI read multiple and etc */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_ENABLE_INTERRUPT
operator||
name|GENCTL_MEMORY_READ_MULTIPLE
operator||
name|GENCTL_ONECOPY
operator||
name|GENCTL_RECEIVE_FIFO_THRESHOLD64
argument_list|)
expr_stmt|;
comment|/* Mark interface running ... */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
comment|/* ... and free */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* Start Rx process */
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset all PHYs */
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_instance
condition|)
block|{
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
block|}
comment|/* Set appropriate media */
name|epic_ifmedia_upd
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Synopsis: calculate and set Rx mode. Chip must be in idle state to  * access RXCON.  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_rx_mode
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|flags
init|=
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
decl_stmt|;
name|u_int32_t
name|rxcon
init|=
name|RXCON_DEFAULT
decl_stmt|;
name|rxcon
operator||=
operator|(
name|flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|RXCON_PROMISCUOUS_MODE
else|:
literal|0
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RXCON
argument_list|,
name|rxcon
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Synopsis: Set transmit control register. Chip must be in idle state to  * access TXCON.  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_tx_mode
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|txcon
operator|&
name|TXCON_EARLY_TRANSMIT_ENABLE
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ETXTHR
argument_list|,
name|sc
operator|->
name|tx_threshold
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|sc
operator|->
name|txcon
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Synopsis: This function should update multicast hash table.  * I suppose there is a bug in chips MC filter so this function  * only set it to receive all MC packets. The second problem is  * that we should wait for TX and RX processes to stop before  * reprogramming MC filter. The epic_stop_activity() and   * epic_start_activity() should help to do this.  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_mc_table
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC0
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC2
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC3
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*   * Synopsis: Start receive process and transmit one, if they need.  */
end_comment

begin_function
specifier|static
name|void
name|epic_start_activity
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* Start rx process */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
operator||
name|COMMAND_START_RX
operator||
operator|(
name|sc
operator|->
name|pending_txs
condition|?
name|COMMAND_TXQUEUED
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": activity started\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Synopsis: Completely stop Rx and Tx processes. If TQE is set additional  * packet needs to be queued to stop Tx DMA.  */
end_comment

begin_function
specifier|static
name|void
name|epic_stop_activity
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Stop Tx and Rx DMA */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_STOP_RX
operator||
name|COMMAND_STOP_RDMA
operator||
name|COMMAND_STOP_TDMA
argument_list|)
expr_stmt|;
comment|/* Wait Rx and Tx DMA to stop (why 1 ms ??? XXX) */
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": waiting Rx and Tx DMA to stop\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|INTSTAT_TXIDLE
operator||
name|INTSTAT_RXIDLE
operator|)
operator|)
operator|==
operator|(
name|INTSTAT_TXIDLE
operator||
name|INTSTAT_RXIDLE
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_RXIDLE
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": can't stop Rx DMA\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": can't stop Tx DMA\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Catch all finished packets */
name|epic_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*      * May need to queue one more packet if TQE, this is rare but existing      * case.      */
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TQE
operator|)
operator|&&
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
block|{
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|epic_frag_list
modifier|*
name|flist
decl_stmt|;
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": queue last packet\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|flist
operator|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|status
operator|&
literal|0x8000
operator|)
operator|||
operator|(
name|buf
operator|->
name|mbuf
operator|!=
name|NULL
operator|)
condition|)
return|return;
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m0
condition|)
return|return;
comment|/* Prepare mbuf */
name|m0
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MHLEN
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m0
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* Fill fragments list */
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m0
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|=
literal|1
expr_stmt|;
comment|/* Fill in descriptor */
name|buf
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
name|sc
operator|->
name|pending_txs
operator|++
expr_stmt|;
name|sc
operator|->
name|cur_tx
operator|=
operator|(
name|sc
operator|->
name|cur_tx
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
expr_stmt|;
name|desc
operator|->
name|control
operator|=
literal|0x01
expr_stmt|;
name|desc
operator|->
name|txlength
operator|=
name|max
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Launch transmition */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_STOP_TDMA
operator||
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
comment|/* Wait Tx DMA to stop (for how long??? XXX) */
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": waiting Tx DMA to stop\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
operator|==
name|INTSTAT_TXIDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": can't stop TX DMA\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
name|EPIC_FORMAT
literal|": activity stoped\n"
operator|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Synopsis: Shut down board and deallocates rings.  */
end_comment

begin_function
specifier|static
name|void
name|epic_stop
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Try to stop Rx and TX processes */
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset chip */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Make chip go to bed */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_POWER_DOWN
argument_list|)
expr_stmt|;
comment|/* Free memory allocated for rings */
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Mark as stoped */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Synopsis: This function should free all memory allocated for rings.  */
end_comment

begin_function
specifier|static
name|void
name|epic_free_rings
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Synopsis:  Allocates mbufs for Rx ring and point Rx descs to them.  * Point Tx descs to fragment lists. Check that all descs and fraglists  * are bounded and aligned properly.  */
end_comment

begin_function
specifier|static
name|int
name|epic_init_rings
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|cur_rx
operator|=
name|sc
operator|->
name|cur_tx
operator|=
name|sc
operator|->
name|dirty_tx
operator|=
name|sc
operator|->
name|pending_txs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Owned by driver */
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|RX_RING_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! rx_desc is misbound or misaligned\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|EPIC_MGETCLUSTER
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
block|{
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* Max RX buffer length */
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Set owner bit to NIC */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
name|TX_RING_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! tx_desc is misbound or misaligned\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_flist
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
name|EPIC_FORMAT
literal|": WARNING! frag_list is misbound or misaligned\n"
argument_list|,
name|EPIC_ARGS
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * EEPROM operation functions  */
end_comment

begin_function
specifier|static
name|void
name|epic_write_eepromreg
parameter_list|(
name|sc
parameter_list|,
name|val
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|val
decl_stmt|;
block|{
name|u_int16_t
name|i
decl_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
break|break;
return|return;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|epic_read_eepromreg
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
return|return
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|epic_eeprom_clock
parameter_list|(
name|sc
parameter_list|,
name|val
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int8_t
name|val
decl_stmt|;
block|{
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
operator|(
name|val
operator||
literal|0x4
operator|)
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|epic_read_eepromreg
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_output_eepromw
parameter_list|(
name|sc
parameter_list|,
name|val
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0x0B
argument_list|)
expr_stmt|;
else|else
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|epic_input_eepromw
parameter_list|(
name|sc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|u_int16_t
name|retval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0x10
condition|)
block|{
name|retval
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epic_read_eeprom
parameter_list|(
name|sc
parameter_list|,
name|loc
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|u_int16_t
name|loc
decl_stmt|;
block|{
name|u_int16_t
name|dataval
decl_stmt|;
name|u_int16_t
name|read_cmd
decl_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_read_eepromreg
argument_list|(
name|sc
argument_list|)
operator|&
literal|0x40
condition|)
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0x3F
operator|)
operator||
literal|0x180
expr_stmt|;
else|else
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0xFF
operator|)
operator||
literal|0x600
expr_stmt|;
name|epic_output_eepromw
argument_list|(
name|sc
argument_list|,
name|read_cmd
argument_list|)
expr_stmt|;
name|dataval
operator|=
name|epic_input_eepromw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|dataval
return|;
block|}
end_function

begin_comment
comment|/*  * Here goes MII read/write routines  */
end_comment

begin_function
specifier|static
name|int
name|epic_read_phy_reg
parameter_list|(
name|sc
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|,
operator|(
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
name|phy
operator|<<
literal|9
operator|)
operator||
literal|0x01
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIIDATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_write_phy_reg
parameter_list|(
name|sc
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|,
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIIDATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|,
operator|(
operator|(
name|reg
operator|<<
literal|4
operator|)
operator||
operator|(
name|phy
operator|<<
literal|9
operator|)
operator||
literal|0x02
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|)
operator|&
literal|0x02
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|epic_miibus_readreg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epic_miibus_writereg
parameter_list|(
name|dev
parameter_list|,
name|phy
parameter_list|,
name|reg
parameter_list|,
name|data
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|int
name|phy
decl_stmt|,
name|reg
decl_stmt|,
name|data
decl_stmt|;
block|{
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

