begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Semen Ustimenko (semen@iclub.nsu.ru)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: if_tx.c,v 1.32 1998/07/03 23:59:09 galv Exp $  *  */
end_comment

begin_comment
comment|/*  * EtherPower II 10/100  Fast Ethernet (tx0)  * (aka SMC9432TX based on SMC83c170 EPIC chip)  *  * TODO:  *	Deal with TX threshold (probably we should calculate it depending  *	    on processor speed, as did the MS-DOS driver).  *	Deal with bus mastering, i.e. i realy don't know what to do with  *	    it and how it can improve performance.  *	Implement FULL IFF_MULTICAST support.  *	Calculate optimal RX and TX rings size.  *	Test, test and test again:-)  *	  */
end_comment

begin_comment
comment|/* We should define compile time options before smc83c170.h included */
end_comment

begin_comment
comment|/*#define	EPIC_NOIFMEDIA	1*/
end_comment

begin_comment
comment|/*#define	EPIC_USEIOSPACE	1*/
end_comment

begin_comment
comment|/*#define	EARLY_RX	1*/
end_comment

begin_comment
comment|/*#define	EARLY_TX	1*/
end_comment

begin_comment
comment|/*#define	EPIC_DEBUG	1*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
end_if

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|a
parameter_list|)
value|printf a
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to get either mbuf cluster or nothing */
end_comment

begin_define
define|#
directive|define
name|EPIC_MGETCLUSTER
parameter_list|(
name|m
parameter_list|)
define|\
value|{ MGETHDR((m),M_DONTWAIT,MT_DATA); \ 	  if (m) { \ 	    MCLGET((m),M_DONTWAIT); \ 	    if( NULL == ((m)->m_flags& M_EXT) ){ \ 	      m_freem(m); \ 	      (m) = NULL; \ 	    } \ 	  } \ 	}
end_define

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCSIFMEDIA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
end_if

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/smc83c170.h>
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|epic_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|txdevice
init|=
block|{
literal|"tx"
block|,
name|epic_pci_probe
block|,
name|epic_pci_attach
block|,
operator|&
name|epic_pci_count
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Append this driver to pci drivers list  */
end_comment

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|txdevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ifioctl function  *  * splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|epic_ifioctl
name|__P
argument_list|(
operator|(
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|x
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Handle IFF_PROMISC flag */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
comment|/* Handle IFF_LINKx flags */
name|epic_set_media_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Update out multicast list */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|epic_ac
argument_list|)
else|:
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|epic_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * ifstart function  *  * splimp() assumed to be done  */
end_comment

begin_function
specifier|static
name|void
name|epic_ifstart
parameter_list|(
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|epic_frag_list
modifier|*
name|flist
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If no link is established,   */
comment|/* simply free all mbufs in queue */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|BMSR_LINK_STATUS
operator|&
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
operator|)
condition|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_snd
operator|)
argument_list|,
name|m0
argument_list|)
expr_stmt|;
while|while
condition|(
name|m0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_snd
operator|)
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Link is OK, queue packets to NIC */
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
name|flist
operator|=
name|sc
operator|->
name|tx_flist
operator|+
name|sc
operator|->
name|cur_tx
expr_stmt|;
comment|/* Get next packet to send */
name|IF_DEQUEUE
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_snd
operator|)
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* If nothing to send, return */
if|if
condition|(
name|NULL
operator|==
name|m0
condition|)
return|return;
comment|/* If descriptor is busy, set IFF_OACTIVE and exit */
if|if
condition|(
name|desc
operator|->
name|status
operator|&
literal|0x8000
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: desc is busy in ifstart, up and down interface please"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: mbuf not freed in ifstart, up and down interface plase"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fill fragments list */
name|flist
operator|->
name|numfrags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
operator|(
name|NULL
operator|!=
name|m
operator|)
operator|&&
operator|(
name|flist
operator|->
name|numfrags
operator|<
literal|63
operator|)
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|flist
operator|->
name|frag
index|[
name|flist
operator|->
name|numfrags
index|]
operator|.
name|fraglen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|flist
operator|->
name|frag
index|[
name|flist
operator|->
name|numfrags
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|++
expr_stmt|;
block|}
comment|/* If packet was more than 63 parts, */
comment|/* recopy packet to new allocated mbuf cluster */
if|if
condition|(
name|NULL
operator|!=
name|m
condition|)
block|{
name|EPIC_MGETCLUSTER
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|m
condition|)
block|{
name|printf
argument_list|(
literal|"\ntx%d: cannot allocate mbuf cluster"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fraglen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|epic_if
expr_stmt|;
name|flist
operator|->
name|numfrags
operator|=
literal|1
expr_stmt|;
name|flist
operator|->
name|frag
index|[
literal|0
index|]
operator|.
name|fragaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|m
expr_stmt|;
block|}
comment|/* Save mbuf */
name|buf
operator|->
name|mbuf
operator|=
name|m0
expr_stmt|;
comment|/* Packet queued successful */
name|sc
operator|->
name|pending_txs
operator|++
expr_stmt|;
comment|/* Switch to next descriptor */
name|sc
operator|->
name|cur_tx
operator|=
operator|(
name|sc
operator|->
name|cur_tx
operator|+
literal|1
operator|)
operator|%
name|TX_RING_SIZE
expr_stmt|;
comment|/* Does not generate TXC */
name|desc
operator|->
name|control
operator|=
literal|0x01
expr_stmt|;
comment|/* Packet should be at least ETHER_MIN_LEN */
name|desc
operator|->
name|txlength
operator|=
name|max
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
comment|/* Pass ownership to the chip */
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Trigger an immediate transmit demand. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set watchdog timer */
name|ifp
operator|->
name|if_timer
operator|=
literal|8
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  *  * splimp() invoked before epic_intr_normal()  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|epic_rx_done
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|struct
name|epic_rx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|sc
operator|->
name|rx_desc
index|[
name|sc
operator|->
name|cur_rx
index|]
operator|.
name|status
operator|&
literal|0x8000
operator|)
operator|&&
expr|\
name|i
operator|++
operator|<
name|RX_RING_SIZE
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|rx_buffer
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|rx_desc
operator|+
name|sc
operator|->
name|cur_rx
expr_stmt|;
comment|/* Switch to next descriptor */
name|sc
operator|->
name|cur_rx
operator|=
operator|(
name|sc
operator|->
name|cur_rx
operator|+
literal|1
operator|)
operator|%
name|RX_RING_SIZE
expr_stmt|;
comment|/* Check for errors, this should happend */
comment|/* only if SAVE_ERRORED_PACKETS is set, */
comment|/* normaly rx errors generate RXE interrupt */
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|status
operator|&
literal|1
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: Rx error status: 0x%x"
operator|,
name|sc
operator|->
name|unit
operator|,
name|desc
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
continue|continue;
block|}
comment|/* Save packet length and mbuf contained packet */
name|len
operator|=
name|desc
operator|->
name|rxlength
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|m
operator|=
name|buf
operator|->
name|mbuf
expr_stmt|;
comment|/* Try to get mbuf cluster */
name|EPIC_MGETCLUSTER
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
block|{
name|printf
argument_list|(
literal|"\ntx%d: cannot allocate mbuf cluster"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|m
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Point to new mbuf, and give descriptor to chip */
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* First mbuf in packet holds the ethernet and packet headers */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
operator|(
name|sc
operator|->
name|epic_if
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* Give mbuf to BPFILTER */
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Accept only our packets, broadcasts and multicasts */
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|epic_ac
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* Second mbuf holds packet ifself */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Give mbuf to OS */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Successfuly received frame */
name|sc
operator|->
name|epic_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Do last phase of transmission. I.e. if desc is   * transmitted, decrease pending_txs counter, free mbuf contained  * packet, switch to next descriptor and repeat until no packets  * are pending or descriptro is not transmitted yet.  */
end_comment

begin_decl_stmt
specifier|static
name|__inline
name|void
name|epic_tx_done
name|__P
argument_list|(
operator|(
specifier|register
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
while|while
condition|(
name|sc
operator|->
name|pending_txs
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
name|sc
operator|->
name|tx_buffer
operator|+
name|sc
operator|->
name|dirty_tx
expr_stmt|;
name|desc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|sc
operator|->
name|dirty_tx
expr_stmt|;
name|status
operator|=
name|desc
operator|->
name|status
expr_stmt|;
comment|/* If packet is not transmitted, thou followed */
comment|/* packets are not transmitted too */
if|if
condition|(
name|status
operator|&
literal|0x8000
condition|)
break|break;
comment|/* Packet is transmitted. Switch to next and */
comment|/* free mbuf */
name|sc
operator|->
name|pending_txs
operator|--
expr_stmt|;
name|sc
operator|->
name|dirty_tx
operator|=
operator|(
name|sc
operator|->
name|dirty_tx
operator|+
literal|1
operator|)
operator|%
name|TX_RING_SIZE
expr_stmt|;
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* Check for errors and collisions */
if|if
condition|(
name|status
operator|&
literal|0x0001
condition|)
name|sc
operator|->
name|epic_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
else|else
name|sc
operator|->
name|epic_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_collisions
operator|+=
operator|(
name|status
operator|>>
literal|8
operator|)
operator|&
literal|0x1F
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|status
operator|&
literal|0x1001
operator|)
operator|==
literal|0x1001
condition|)
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: frame not transmitted due collisions"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|<
name|TX_RING_SIZE
condition|)
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Interrupt function  *  * splimp() assumed to be done   */
end_comment

begin_function
specifier|static
name|void
name|epic_intr_normal
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|status
decl_stmt|,
name|i
init|=
literal|4
decl_stmt|;
do|do
block|{
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_RCC
operator||
name|INTSTAT_OVW
operator|)
condition|)
block|{
name|epic_rx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|status
operator|&
name|INTSTAT_OVW
condition|)
name|printf
argument_list|(
literal|"\ntx%d: Rx buffer overflowed"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|INTSTAT_RQE
condition|)
name|printf
argument_list|(
literal|"\ntx%d: Rx FIFO overflowed"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|)
operator|&
name|COMMAND_RXQUEUED
operator|)
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator|)
condition|)
block|{
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|INTSTAT_TQE
operator||
name|INTSTAT_TCC
operator|)
operator|)
operator|&&
operator|(
name|sc
operator|->
name|pending_txs
operator|>
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"\ntx%d: %d packets pending after TQE/TCC"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|&&
name|sc
operator|->
name|epic_if
operator|.
name|if_snd
operator|.
name|ifq_head
condition|)
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|INTSTAT_GP2
operator|)
operator|&&
operator|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
operator|)
condition|)
block|{
name|u_int32_t
name|phystatus
decl_stmt|;
name|phystatus
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|QS6612_INTSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|phystatus
operator|&
name|INTSTAT_AN_COMPLETE
condition|)
block|{
name|u_int32_t
name|bmcr
decl_stmt|;
if|if
condition|(
name|epic_autoneg
argument_list|(
name|sc
argument_list|)
operator|==
name|EPIC_FULL_DUPLEX
condition|)
block|{
name|bmcr
operator|=
name|BMCR_FULL_DUPLEX
operator||
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|TXCON_FULL_DUPLEX
operator||
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Default to half-duplex */
name|bmcr
operator|=
operator|~
name|BMCR_FULL_DUPLEX
operator|&
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* There is apparently QS6612 chip bug: */
comment|/* BMCR_FULL_DUPLEX flag is not updated by */
comment|/* autonegotiation process, so update it by hands */
comment|/* so we can rely on it in epic_ifmedia_status() */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|bmcr
argument_list|)
expr_stmt|;
block|}
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
operator|&
name|BMSR_LINK_STATUS
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: WARNING! link down"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|EPIC_LINK_DOWN
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: link up"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|EPIC_LINK_DOWN
expr_stmt|;
block|}
comment|/* We should clear GP2 int again after we clear it on PHY */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|,
name|INTSTAT_GP2
argument_list|)
expr_stmt|;
block|}
comment|/* Check for errors */
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_RXE
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
name|INTSTAT_FATAL
operator||
name|INTSTAT_PMA
operator||
name|INTSTAT_PTA
operator||
name|INTSTAT_APE
operator||
name|INTSTAT_DPE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\ntx%d: PCI fatal error occured (%s%s%s%s)"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PMA
operator|)
condition|?
literal|"PMA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_PTA
operator|)
condition|?
literal|" PTA"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_APE
operator|)
condition|?
literal|" APE"
else|:
literal|""
argument_list|,
operator|(
name|status
operator|&
name|INTSTAT_DPE
operator|)
condition|?
literal|" DPE"
else|:
literal|""
argument_list|)
expr_stmt|;
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|INTSTAT_RXE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: CRC/Alignment error"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* Tx FIFO underflow. Should not happend if */
comment|/* we don't use early tx, handle it anyway */
if|if
condition|(
name|status
operator|&
name|INTSTAT_TXU
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: Tx underrun error"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
comment|/* Restart the transmit process. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXUGO
operator||
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|i
operator|--
operator|&&
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_INT_ACTV
operator|)
condition|)
do|;
comment|/* If no packets are pending, thus no timeouts */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|==
literal|0
condition|)
name|sc
operator|->
name|epic_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Synopsis: This one is called if packets wasn't transmitted  * during timeout. Try to deallocate transmitted packets, and   * if success continue to work.  *  * splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_ifwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\ntx%d: device timeout %d packets, "
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|)
expr_stmt|;
comment|/* Try to finish queued packets */
name|epic_tx_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If not successful */
if|if
condition|(
name|sc
operator|->
name|pending_txs
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPIC_DEBUG
argument_list|)
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|epic_dump_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sc
operator|->
name|pending_txs
expr_stmt|;
comment|/* Reinitialize board */
name|printf
argument_list|(
literal|"reinitialization"
argument_list|)
expr_stmt|;
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"seems we can continue normaly"
argument_list|)
expr_stmt|;
comment|/* Start output */
if|if
condition|(
name|sc
operator|->
name|epic_if
operator|.
name|if_snd
operator|.
name|ifq_head
condition|)
name|epic_ifstart
argument_list|(
operator|&
name|sc
operator|->
name|epic_if
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Check if PCI id corresponds with board id.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|epic_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
if|if
condition|(
name|PCI_VENDORID
argument_list|(
name|device_id
argument_list|)
operator|!=
name|SMC_VENDORID
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|PCI_CHIPID
argument_list|(
name|device_id
argument_list|)
operator|==
name|CHIPID_83C170
condition|)
return|return
literal|"SMC 83c170"
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Synopsis: Allocate memory for softc, descriptors and frag lists.  * Connect to interrupt, and get memory/io address of card registers.  * Preinitialize softc structure, attach to if manager, ifmedia manager  * and bpf. Read media configuration and etc.  *  * splimp() invoked here  */
end_comment

begin_function
specifier|static
name|void
name|epic_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|epic_softc_t
modifier|*
name|sc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EPIC_USEIOSPACE
argument_list|)
name|u_int32_t
name|iobase
decl_stmt|;
else|#
directive|else
name|caddr_t
name|pmembase
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|s
decl_stmt|,
name|tmp
decl_stmt|;
name|u_int32_t
name|pool
decl_stmt|;
comment|/* Allocate memory for softc, hardware descriptors and frag lists */
name|sc
operator|=
operator|(
name|epic_softc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|*
name|TX_RING_SIZE
operator|+
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* Align pool on PAGE_SIZE */
name|pool
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
name|sc
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
expr_stmt|;
name|pool
operator|=
operator|(
name|pool
operator|+
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Preinitialize softc structure */
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|epic_softc_t
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
comment|/* Fill ifnet structure */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|epic_if
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"tx"
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epic_ifioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epic_ifstart
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|epic_ifwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|if_init_f_t
operator|*
operator|)
name|epic_init
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
comment|/* Get iobase or membase */
if|#
directive|if
name|defined
argument_list|(
name|EPIC_USEIOSPACE
argument_list|)
if|if
condition|(
operator|!
name|pci_map_port
argument_list|(
name|config_id
argument_list|,
name|PCI_CBIO
argument_list|,
operator|(
name|u_short
operator|*
operator|)
operator|&
operator|(
name|sc
operator|->
name|iobase
operator|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: cannot map port\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_CBMA
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
operator|(
name|sc
operator|->
name|csr
operator|)
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|pmembase
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: cannot map memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sc
operator|->
name|tx_flist
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|*
name|TX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|rx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
name|pool
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|*
name|RX_RING_SIZE
expr_stmt|;
name|sc
operator|->
name|tx_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|pool
expr_stmt|;
comment|/* Bring the chip out of low-power mode. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* Magic?!  If we don't set this bit the MII interface won't work. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Read mac address from EEPROM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|/
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
name|i
index|]
operator|=
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Display ethernet address ,... */
name|printf
argument_list|(
literal|"tx%d: address %02x:%02x:%02x:%02x:%02x:%02x,"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|epic_macaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* board type and ... */
name|printf
argument_list|(
literal|" type "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x2c
init|;
name|i
operator|<
literal|0x32
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|epic_read_eeprom
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
operator|(
name|u_int8_t
operator|)
name|tmp
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|u_int8_t
operator|)
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|>>=
literal|8
expr_stmt|;
if|if
condition|(
literal|' '
operator|==
operator|(
name|u_int8_t
operator|)
name|tmp
condition|)
break|break;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|u_int8_t
operator|)
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* Read current media config and display it too */
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|tmp
operator|=
name|IFM_ETHER
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
name|BMCR_AUTONEGOTIATION
condition|)
block|{
name|printf
argument_list|(
literal|", Auto-Neg "
argument_list|)
expr_stmt|;
comment|/* To avoid bug in QS6612 read LPAR enstead of BMSR */
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"100Mbps "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"10Mbps "
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_10_FD
operator||
name|ANAR_100_TX_FD
operator|)
condition|)
name|printf
argument_list|(
literal|"FD"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|tmp
operator||=
name|IFM_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
name|BMCR_100MBPS
condition|)
block|{
name|printf
argument_list|(
literal|", 100Mbps "
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|tmp
operator||=
name|IFM_100_TX
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK2
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|", 10Mbps "
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|tmp
operator||=
name|IFM_10_T
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|i
operator|&
name|BMCR_FULL_DUPLEX
condition|)
block|{
name|printf
argument_list|(
literal|"FD"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|tmp
operator||=
name|IFM_FDX
expr_stmt|;
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Init ifmedia interface */
if|#
directive|if
name|defined
argument_list|(
name|SIOCSIFMEDIA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
literal|0
argument_list|,
name|epic_ifmedia_change
argument_list|,
name|epic_ifmedia_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_LOOP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10_T
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_LOOP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|IFM_ETHER
operator||
name|IFM_LOOP
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|ifmedia
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Identify PHY */
name|sc
operator|->
name|phyid
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_PHYIDR1
argument_list|)
operator|<<
literal|6
expr_stmt|;
name|sc
operator|->
name|phyid
operator||=
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_PHYIDR2
argument_list|)
operator|>>
literal|10
operator|)
operator|&
literal|0x3F
expr_stmt|;
if|if
condition|(
name|QS6612_OUI
operator|!=
name|sc
operator|->
name|phyid
condition|)
name|printf
argument_list|(
literal|"tx%d: WARNING! phy unknown (0x%x), "
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|phyid
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Map interrupt */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|epic_intr_normal
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"tx%d: couldn't map interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set shut down routine to stop DMA processes on reboot */
name|at_shutdown
argument_list|(
name|epic_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_POST_SYNC
argument_list|)
expr_stmt|;
comment|/*  Attach to if manager */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SIOCSIFMEDIA
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EPIC_NOIFMEDIA
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|epic_ifmedia_change
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
block|{
if|if
condition|(
name|IFM_TYPE
argument_list|(
operator|(
operator|(
name|epic_softc_t
operator|*
operator|)
operator|(
name|ifp
operator|->
name|if_softc
operator|)
operator|)
operator|->
name|ifmedia
operator|.
name|ifm_media
argument_list|)
operator|!=
name|IFM_ETHER
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|epic_set_media_speed
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_ifmedia_status
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
expr|struct
name|ifmediareq
operator|*
name|ifmr
operator|)
argument_list|)
block|{
name|epic_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int32_t
name|bmcr
decl_stmt|;
name|u_int32_t
name|bmsr
decl_stmt|;
name|bmcr
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|bmsr
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bmsr
operator|&
name|BMSR_LINK_STATUS
operator|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|bmcr
operator|&
name|BMCR_AUTONEGOTIATION
operator|)
condition|?
name|IFM_AUTO
else|:
name|IFM_NONE
expr_stmt|;
return|return;
block|}
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|bmcr
operator|&
name|BMCR_100MBPS
operator|)
condition|?
name|IFM_100_TX
else|:
name|IFM_10_T
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
name|bmcr
operator|&
name|BMCR_FULL_DUPLEX
operator|)
condition|?
name|IFM_FDX
else|:
literal|0
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
operator|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|)
operator|&
name|TXCON_LOOPBACK_MODE
operator|)
operator|==
name|TXCON_LOOPBACK_MODE_INT
operator|)
condition|?
name|IFM_LOOP
else|:
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Reset chip, PHY, allocate rings  *   * splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|epic_init
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Soft reset the chip */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
comment|/* Reset takes 15 pci ticks which depends on processor speed */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Wake up */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ?????? */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TEST1
argument_list|,
literal|0x0008
argument_list|)
expr_stmt|;
comment|/* Initialize rings */
if|if
condition|(
name|epic_init_rings
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\ntx%d: failed to initialize rings"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Give rings to EPIC */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PRCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|PTCDAR
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put node address to EPIC */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN0
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN1
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|LAN2
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|sc
operator|->
name|epic_macaddr
operator|)
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|EARLY_TX
argument_list|)
comment|/* Set transmit threshold */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|ETXTHR
argument_list|,
name|TRANSMIT_THRESHOLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|IPG
argument_list|,
literal|0x1010
argument_list|)
expr_stmt|;
comment|/* Compute and set RXCON. */
name|epic_set_rx_mode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set media speed mode */
name|epic_init_phy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_set_media_speed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set multicast table */
name|epic_set_mc_table
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable interrupts by setting the interrupt mask. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTMASK
argument_list|,
name|INTSTAT_RCC
operator||
name|INTSTAT_RQE
operator||
name|INTSTAT_OVW
operator||
name|INTSTAT_RXE
operator||
name|INTSTAT_TXC
operator||
name|INTSTAT_TCC
operator||
name|INTSTAT_TQE
operator||
name|INTSTAT_TXU
operator||
name|INTSTAT_FATAL
operator||
operator|(
operator|(
name|QS6612_OUI
operator|==
name|sc
operator|->
name|phyid
operator|)
condition|?
name|INTSTAT_GP2
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Enable interrupts,  set for PCI read multiple and etc */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_ENABLE_INTERRUPT
operator||
name|GENCTL_MEMORY_READ_MULTIPLE
operator||
name|GENCTL_ONECOPY
operator||
name|GENCTL_RECEIVE_FIFO_THRESHOLD64
argument_list|)
expr_stmt|;
comment|/* Mark interface running ... */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
else|else
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
comment|/* ... and free */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* Start Rx process */
name|epic_start_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: calculate and set Rx mode  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_rx_mode
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|flags
init|=
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
decl_stmt|;
name|u_int32_t
name|rxcon
init|=
name|RXCON_DEFAULT
operator||
name|RXCON_RECEIVE_MULTICAST_FRAMES
operator||
name|RXCON_RECEIVE_BROADCAST_FRAMES
decl_stmt|;
name|rxcon
operator||=
operator|(
name|flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|RXCON_PROMISCUOUS_MODE
else|:
literal|0
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|RXCON
argument_list|,
name|rxcon
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Synopsis: Reset PHY and do PHY-special initialization:  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_init_phy
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|u_int32_t
name|i
decl_stmt|;
comment|/* Reset PHY */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
operator|&
name|BMCR_RESET
operator|)
condition|)
break|break;
if|if
condition|(
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
operator|&
name|BMCR_RESET
condition|)
name|printf
argument_list|(
literal|"\ntx%d: WARNING! cannot reset PHY"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|phyid
condition|)
block|{
case|case
name|QS6612_OUI
case|:
comment|/* Init QS6612 and EPIC to generate interrupt when AN complete*/
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|NVCTL
argument_list|,
name|NVCTL_GP1_OUTPUT_ENABLE
argument_list|)
expr_stmt|;
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|QS6612_INTSTAT
argument_list|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|QS6612_INTMASK
argument_list|,
name|INTMASK_THUNDERLAN
operator||
name|INTSTAT_AN_COMPLETE
operator||
name|INTSTAT_LINK_STATUS
argument_list|)
expr_stmt|;
comment|/* Enable QS6612 extended cable length capabilites */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|QS6612_MCTL
argument_list|,
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|QS6612_MCTL
argument_list|)
operator||
name|MCTL_BTEXT
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Set PHY to media type specified by IFF_LINK* flags or  * ifmedia structure.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_set_media_speed
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|u_int16_t
name|media
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_NET_IF_MEDIA_H_
argument_list|)
name|u_int32_t
name|tgtmedia
init|=
name|sc
operator|->
name|ifmedia
operator|.
name|ifm_cur
operator|->
name|ifm_media
decl_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|!=
name|IFM_AUTO
condition|)
block|{
comment|/* Set mode */
name|media
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|==
name|IFM_100_TX
operator|)
condition|?
name|BMCR_100MBPS
else|:
literal|0
expr_stmt|;
name|media
operator||=
operator|(
name|tgtmedia
operator|&
name|IFM_FDX
operator|)
condition|?
name|BMCR_FULL_DUPLEX
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_baudrate
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|tgtmedia
argument_list|)
operator|==
name|IFM_100_TX
operator|)
condition|?
literal|100000000
else|:
literal|10000000
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|media
operator|=
name|TXCON_DEFAULT
expr_stmt|;
if|if
condition|(
name|tgtmedia
operator|&
name|IFM_FDX
condition|)
name|media
operator||=
name|TXCON_FULL_DUPLEX
expr_stmt|;
elseif|else
if|if
condition|(
name|tgtmedia
operator|&
name|IFM_LOOP
condition|)
name|media
operator||=
name|TXCON_LOOPBACK_MODE_INT
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|media
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
comment|/* Set mode */
name|media
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
operator|)
condition|?
name|BMCR_100MBPS
else|:
literal|0
expr_stmt|;
name|media
operator||=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK1
operator|)
condition|?
name|BMCR_FULL_DUPLEX
else|:
literal|0
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_baudrate
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
operator|)
condition|?
literal|100000000
else|:
literal|10000000
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|media
operator|=
name|TXCON_DEFAULT
expr_stmt|;
name|media
operator||=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
operator|)
condition|?
name|TXCON_FULL_DUPLEX
else|:
literal|0
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|media
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|sc
operator|->
name|epic_if
operator|.
name|if_baudrate
operator|=
literal|100000000
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
comment|/* Set and restart autoneg */
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_RESTART_AUTONEG
argument_list|)
expr_stmt|;
comment|/* If it is not QS6612 PHY, try to get result of autoneg. */
if|if
condition|(
name|QS6612_OUI
operator|!=
name|sc
operator|->
name|phyid
condition|)
block|{
comment|/* Wait 3 seconds for the autoneg to finish 			 * This is the recommended time from the DP83840A data 			 * sheet Section 7.1 			 */
name|DELAY
argument_list|(
literal|3000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_autoneg
argument_list|(
name|sc
argument_list|)
operator|==
name|EPIC_FULL_DUPLEX
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|TXCON_FULL_DUPLEX
operator||
name|TXCON_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* Else it will be done when GP2 int occured */
block|}
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * This functions get results of the autoneg processes of the phy  * It implements the workaround that is described in section 7.2& 7.3 of the   * DP83840A data sheet  * http://www.national.com/ds/DP/DP83840A.pdf  */
end_comment

begin_function
specifier|static
name|int
name|epic_autoneg
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
name|u_int16_t
name|media
decl_stmt|;
name|u_int16_t
name|i
decl_stmt|;
comment|/* BMSR must be read twice to update the link status bit 	 * since that bit is a latch bit          */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|BMSR_LINK_STATUS
operator|)
operator|&&
operator|(
name|i
operator|&
name|BMSR_AUTONEG_COMPLETE
operator|)
condition|)
block|{
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_LPAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|ANAR_100_TX_FD
operator||
name|ANAR_10_FD
operator|)
condition|)
return|return
name|EPIC_FULL_DUPLEX
return|;
else|else
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
else|else
block|{
comment|/*Auto-negotiation or link status is not 1 		  Thus the auto-negotiation failed and one 		  must take other means to fix it. 		 */
comment|/* ANER must be read twice to get the correct reading for the  		 * Multiple link fault bit -- it is a latched bit 	 	 */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_ANER
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_ANER
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|ANER_MULTIPLE_LINK_FAULT
condition|)
block|{
comment|/* it can be forced to 100Mb/s Half-Duplex */
name|media
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
operator|(
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_FULL_DUPLEX
operator|)
expr_stmt|;
name|media
operator||=
name|BMCR_100MBPS
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
comment|/* read BMSR again to determine link status */
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMSR_LINK_STATUS
condition|)
block|{
comment|/* port is linked to the non Auto-Negotiation 				 * 100Mbs partner. 			 	 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
else|else
block|{
name|media
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|)
expr_stmt|;
name|media
operator|&=
operator|~
operator|(
name|BMCR_AUTONEGOTIATION
operator||
name|BMCR_FULL_DUPLEX
operator||
name|BMCR_100MBPS
operator|)
expr_stmt|;
name|PHY_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMCR
argument_list|,
name|media
argument_list|)
expr_stmt|;
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
name|i
operator|=
name|PHY_READ_2
argument_list|(
name|sc
argument_list|,
name|DP83840_BMSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|BMSR_LINK_STATUS
condition|)
block|{
comment|/*port is linked to the non 					 * Auto-Negotiation10Mbs partner 			 	 	 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
block|}
block|}
comment|/* If we get here we are most likely not connected 		 * so lets default it to half duplex 		 */
return|return
name|EPIC_HALF_DUPLEX
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Synopsis: This function should update multicast hash table.  * I suppose there is a bug in chips MC filter so this function  * only set it to receive all MC packets. The second problem is  * that we should wait for TX and RX processes to stop before  * reprogramming MC filter. The epic_stop_activity() and   * epic_start_activity() should help to do this.  */
end_comment

begin_function
specifier|static
name|void
name|epic_set_mc_table
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|epic_if
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC0
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC1
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC2
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MC3
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|epic_shutdown
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
name|epic_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Synopsis: Start receive process, should check that all internal chip   * pointers are set properly.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_start_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
comment|/* Start rx process */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_RXQUEUED
operator||
name|COMMAND_START_RX
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: Completely stop Rx and Tx processes. If TQE is set additional  * packet needs to be queued to stop Tx DMA.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_stop_activity
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Stop Tx and Rx DMA */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_STOP_RX
operator||
name|COMMAND_STOP_RDMA
operator||
name|COMMAND_STOP_TDMA
argument_list|)
expr_stmt|;
comment|/* Wait only Rx DMA */
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: waiting Rx DMA to stop"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_RXIDLE
operator|)
operator|==
name|INTSTAT_RXIDLE
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_RXIDLE
operator|)
condition|)
name|printf
argument_list|(
literal|"\ntx%d: can't stop RX DMA"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* May need to queue one more packet if TQE */
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TQE
operator|)
operator|&&
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: queue last packet"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* Turn it to loopback mode */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|TXCON
argument_list|,
name|TXCON_DEFAULT
operator||
name|TXCON_LOOPBACK_MODE_INT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_desc
index|[
name|sc
operator|->
name|cur_tx
index|]
operator|.
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_desc
index|[
name|sc
operator|->
name|cur_tx
index|]
operator|.
name|buflength
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|sc
operator|->
name|tx_desc
index|[
name|sc
operator|->
name|cur_tx
index|]
operator|.
name|control
operator|=
literal|0x14
expr_stmt|;
name|sc
operator|->
name|tx_desc
index|[
name|sc
operator|->
name|cur_tx
index|]
operator|.
name|txlength
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|sc
operator|->
name|tx_desc
index|[
name|sc
operator|->
name|cur_tx
index|]
operator|.
name|status
operator|=
literal|0x8000
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|,
name|COMMAND_TXQUEUED
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"\ntx%d: waiting Tx DMA to stop"
operator|,
name|sc
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait TX DMA to stop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x100000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
operator|==
name|INTSTAT_TXIDLE
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INTSTAT_TXIDLE
operator|)
condition|)
name|printf
argument_list|(
literal|"\ntx%d: can't stop TX DMA"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  *  Synopsis: Shut down board and deallocates rings.  *  *  splimp() invoked here  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_stop
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|epic_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* Disable interrupts */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|INTMASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Try to stop Rx and TX processes */
name|epic_stop_activity
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset chip */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|GENCTL
argument_list|,
name|GENCTL_SOFT_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Free memory allocated for rings */
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Mark as stoped */
name|sc
operator|->
name|epic_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis: This function should free all memory allocated for rings.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_free_rings
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|mbuf
condition|)
name|m_freem
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*  * Synopsis:  Allocates mbufs for Rx ring and point Rx descs to them.  * Point Tx descs to fragment lists. Check that all descs and fraglists  * are bounded and aligned properly.  */
end_comment

begin_function
specifier|static
name|int
name|epic_init_rings
parameter_list|(
name|epic_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|sc
operator|->
name|cur_rx
operator|=
name|sc
operator|->
name|cur_tx
operator|=
name|sc
operator|->
name|dirty_tx
operator|=
name|sc
operator|->
name|pending_txs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_rx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|rx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|rx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Owned by driver */
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|rx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|RX_RING_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_rx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
literal|"\ntx%d: WARNING! rx_desc is misbound or misaligned"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|EPIC_MGETCLUSTER
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|buf
operator|->
name|mbuf
condition|)
block|{
name|epic_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|mtod
argument_list|(
name|buf
operator|->
name|mbuf
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflength
operator|=
name|ETHER_MAX_FRAME_LEN
expr_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0x8000
expr_stmt|;
comment|/* Give to EPIC */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_RING_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|epic_tx_buffer
modifier|*
name|buf
init|=
name|sc
operator|->
name|tx_buffer
operator|+
name|i
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|desc
init|=
name|sc
operator|->
name|tx_desc
operator|+
name|i
decl_stmt|;
name|desc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_desc
operator|+
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|TX_RING_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|next
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_tx_desc
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
literal|"\ntx%d: WARNING! tx_desc is misbound or misaligned"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|desc
operator|->
name|bufaddr
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tx_flist
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|3
operator|)
operator|||
operator|(
operator|(
name|desc
operator|->
name|bufaddr
operator|&
literal|0xFFF
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|epic_frag_list
argument_list|)
operator|>
literal|0x1000
operator|)
condition|)
name|printf
argument_list|(
literal|"\ntx%d: WARNING! frag_list is misbound or misaligned"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * EEPROM operation functions  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|epic_write_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int8_t
name|val
operator|)
argument_list|)
block|{
name|u_int16_t
name|i
decl_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
break|break;
return|return;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_read_eepromreg
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
return|return
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EECTL
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|epic_eeprom_clock
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int8_t
name|val
operator|)
argument_list|)
block|{
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
operator|(
name|val
operator||
literal|0x4
operator|)
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|epic_read_eepromreg
argument_list|(
name|sc
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_output_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|val
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0x0B
argument_list|)
expr_stmt|;
else|else
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_input_eepromw
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|u_int16_t
name|retval
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0xF
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tmp
operator|=
name|epic_eeprom_clock
argument_list|(
name|sc
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0x10
condition|)
block|{
name|retval
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|epic_read_eeprom
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|loc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
name|dataval
decl_stmt|;
name|u_int16_t
name|read_cmd
decl_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|epic_read_eepromreg
argument_list|(
name|sc
argument_list|)
operator|&
literal|0x40
condition|)
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0x3F
operator|)
operator||
literal|0x180
expr_stmt|;
else|else
name|read_cmd
operator|=
operator|(
name|loc
operator|&
literal|0xFF
operator|)
operator||
literal|0x600
expr_stmt|;
name|epic_output_eepromw
argument_list|(
name|sc
argument_list|,
name|read_cmd
argument_list|)
expr_stmt|;
name|dataval
operator|=
name|epic_input_eepromw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|epic_write_eepromreg
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|dataval
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|epic_read_phy_register
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|loc
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|,
operator|(
operator|(
name|loc
operator|<<
literal|4
operator|)
operator||
literal|0x0601
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|)
operator|&
literal|1
operator|)
condition|)
break|break;
return|return
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIIDATA
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_write_phy_register
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|,
name|u_int16_t
name|loc
operator|,
name|u_int16_t
name|val
operator|)
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIIDATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|,
operator|(
operator|(
name|loc
operator|<<
literal|4
operator|)
operator||
literal|0x0602
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x1000
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|MIICTL
argument_list|)
operator|&
literal|2
operator|)
condition|)
break|break;
return|return;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|epic_dump_state
name|__P
argument_list|(
operator|(
name|epic_softc_t
operator|*
name|sc
operator|)
argument_list|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|epic_tx_desc
modifier|*
name|tdesc
decl_stmt|;
name|struct
name|epic_rx_desc
modifier|*
name|rdesc
decl_stmt|;
name|printf
argument_list|(
literal|"\ntx%d: cur_rx: %d, pending_txs: %d, dirty_tx: %d, cur_tx: %d"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|cur_rx
argument_list|,
name|sc
operator|->
name|pending_txs
argument_list|,
name|sc
operator|->
name|dirty_tx
argument_list|,
name|sc
operator|->
name|cur_tx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ntx%d: COMMAND: 0x%08x, INTSTAT: 0x%08x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|COMMAND
argument_list|)
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|INTSTAT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ntx%d: PRCDAR: 0x%08x, PTCDAR: 0x%08x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|PRCDAR
argument_list|)
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|PTCDAR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ntx%d: dumping rx descriptors"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|RX_RING_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|rdesc
operator|=
name|sc
operator|->
name|rx_desc
operator|+
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"\ndesc%d: %4d 0x%04x, 0x%08x, %4d, 0x%08x"
argument_list|,
name|j
argument_list|,
name|rdesc
operator|->
name|rxlength
argument_list|,
name|rdesc
operator|->
name|status
argument_list|,
name|rdesc
operator|->
name|bufaddr
argument_list|,
name|rdesc
operator|->
name|buflength
argument_list|,
name|rdesc
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ntx%d: dumping tx descriptors"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TX_RING_SIZE
condition|;
name|j
operator|++
control|)
block|{
name|tdesc
operator|=
name|sc
operator|->
name|tx_desc
operator|+
name|j
expr_stmt|;
name|printf
argument_list|(
literal|"\ndesc%d: %4d 0x%04x, 0x%08x, 0x%04x %4d, 0x%08x, mbuf: 0x%08x"
argument_list|,
name|j
argument_list|,
name|tdesc
operator|->
name|txlength
argument_list|,
name|tdesc
operator|->
name|status
argument_list|,
name|tdesc
operator|->
name|bufaddr
argument_list|,
name|tdesc
operator|->
name|control
argument_list|,
name|tdesc
operator|->
name|buflength
argument_list|,
name|tdesc
operator|->
name|next
argument_list|,
name|sc
operator|->
name|tx_buffer
index|[
name|j
index|]
operator|.
name|mbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

end_unit

