begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * cyclades cyclom-y serial driver  *	Andrew Herbert<andrew@werple.apana.org.au>, 17 August 1993  *  * Copyright (c) 1993 Andrew Herbert.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name Andrew Herbert may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"cy.h"
end_include

begin_comment
comment|/*  * TODO:  * Atomic COR change.  * Consoles.  */
end_comment

begin_comment
comment|/*  * Temporary compile-time configuration options.  */
end_comment

begin_define
define|#
directive|define
name|RxFifoThreshold
value|(CD1400_RX_FIFO_SIZE / 2)
end_define

begin_comment
comment|/* Number of chars in the receiver FIFO before an 			 * an interrupt is generated.  Should depend on 			 * line speed.  Needs to be about 6 on a 486DX33 			 * for 4 active ports at 115200 bps.  Why doesn't 			 * 10 work? 			 */
end_comment

begin_define
define|#
directive|define
name|PollMode
end_define

begin_comment
comment|/* Use polling-based irq service routine, not the 			 * hardware svcack lines.  Must be defined for 			 * Cyclom-16Y boards.  Less efficient for Cyclom-8Ys, 			 * and stops 4 * 115200 bps from working. 			 */
end_comment

begin_undef
undef|#
directive|undef
name|Smarts
end_undef

begin_comment
comment|/* Enable slightly more CD1400 intelligence.  Mainly 			 * the output CR/LF processing, plus we can avoid a 			 * few checks usually done in ttyinput(). 			 * 			 * XXX not fully implemented, and not particularly 			 * worthwhile. 			 */
end_comment

begin_undef
undef|#
directive|undef
name|CyDebug
end_undef

begin_comment
comment|/* Include debugging code (not very expensive). */
end_comment

begin_comment
comment|/* These will go away. */
end_comment

begin_undef
undef|#
directive|undef
name|SOFT_CTS_OFLOW
end_undef

begin_define
define|#
directive|define
name|SOFT_HOTCHAR
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/cyreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/cd1400.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDISA
end_ifndef

begin_error
error|#
directive|error
literal|"The cy device requires the old isa compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_comment
comment|/** xxx_LOCK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_COMLOCK
end_ifdef

begin_define
define|#
directive|define
name|COM_LOCK
parameter_list|()
value|mtx_lock_spin(&com_mtx)
end_define

begin_define
define|#
directive|define
name|COM_UNLOCK
parameter_list|()
value|mtx_unlock_spin(&com_mtx)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COM_LOCK
parameter_list|()
end_define

begin_define
define|#
directive|define
name|COM_UNLOCK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_COMLOCK */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SMP */
end_comment

begin_define
define|#
directive|define
name|COM_LOCK
parameter_list|()
end_define

begin_define
define|#
directive|define
name|COM_UNLOCK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|com_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dictionary so that I can name everything *sio* or *com* to compare with  * sio.c.  There is also lots of ugly formatting and unnecessary ifdefs to  * simplify the comparision.  These will go away.  */
end_comment

begin_define
define|#
directive|define
name|LSR_BI
value|CD1400_RDSR_BREAK
end_define

begin_define
define|#
directive|define
name|LSR_FE
value|CD1400_RDSR_FE
end_define

begin_define
define|#
directive|define
name|LSR_OE
value|CD1400_RDSR_OE
end_define

begin_define
define|#
directive|define
name|LSR_PE
value|CD1400_RDSR_PE
end_define

begin_define
define|#
directive|define
name|MCR_DTR
value|CD1400_MSVR2_DTR
end_define

begin_define
define|#
directive|define
name|MCR_RTS
value|CD1400_MSVR1_RTS
end_define

begin_define
define|#
directive|define
name|MSR_CTS
value|CD1400_MSVR2_CTS
end_define

begin_define
define|#
directive|define
name|MSR_DCD
value|CD1400_MSVR2_CD
end_define

begin_define
define|#
directive|define
name|MSR_DSR
value|CD1400_MSVR2_DSR
end_define

begin_define
define|#
directive|define
name|MSR_RI
value|CD1400_MSVR2_RI
end_define

begin_define
define|#
directive|define
name|NSIO
value|(NCY * CY_MAX_PORTS)
end_define

begin_define
define|#
directive|define
name|comconsole
value|cyconsole
end_define

begin_define
define|#
directive|define
name|comdefaultrate
value|cydefaultrate
end_define

begin_define
define|#
directive|define
name|com_events
value|cy_events
end_define

begin_define
define|#
directive|define
name|comhardclose
value|cyhardclose
end_define

begin_define
define|#
directive|define
name|commctl
value|cymctl
end_define

begin_define
define|#
directive|define
name|comparam
value|cyparam
end_define

begin_define
define|#
directive|define
name|comspeed
value|cyspeed
end_define

begin_define
define|#
directive|define
name|comstart
value|cystart
end_define

begin_define
define|#
directive|define
name|comwakeup
value|cywakeup
end_define

begin_define
define|#
directive|define
name|p_com_addr
value|p_cy_addr
end_define

begin_define
define|#
directive|define
name|sioattach
value|cyattach
end_define

begin_define
define|#
directive|define
name|sioclose
value|cyclose
end_define

begin_define
define|#
directive|define
name|siodriver
value|cydriver
end_define

begin_define
define|#
directive|define
name|siodtrwakeup
value|cydtrwakeup
end_define

begin_define
define|#
directive|define
name|sioinput
value|cyinput
end_define

begin_define
define|#
directive|define
name|siointr
value|cyintr
end_define

begin_define
define|#
directive|define
name|siointr1
value|cyintr1
end_define

begin_define
define|#
directive|define
name|sioioctl
value|cyioctl
end_define

begin_define
define|#
directive|define
name|sioopen
value|cyopen
end_define

begin_define
define|#
directive|define
name|siopoll
value|cypoll
end_define

begin_define
define|#
directive|define
name|sioprobe
value|cyprobe
end_define

begin_define
define|#
directive|define
name|siosettimeout
value|cysettimeout
end_define

begin_define
define|#
directive|define
name|siosetwater
value|cysetwater
end_define

begin_define
define|#
directive|define
name|comstop
value|cystop
end_define

begin_define
define|#
directive|define
name|siowrite
value|cywrite
end_define

begin_define
define|#
directive|define
name|sio_ih
value|cy_ih
end_define

begin_define
define|#
directive|define
name|sio_irec
value|cy_irec
end_define

begin_define
define|#
directive|define
name|sio_timeout
value|cy_timeout
end_define

begin_define
define|#
directive|define
name|sio_timeout_handle
value|cy_timeout_handle
end_define

begin_define
define|#
directive|define
name|sio_timeouts_until_log
value|cy_timeouts_until_log
end_define

begin_define
define|#
directive|define
name|CY_MAX_PORTS
value|(CD1400_NO_OF_CHANNELS * CY_MAX_CD1400s)
end_define

begin_comment
comment|/* We encode the cyclom unit number (cyu) in spare bits in the IVR's. */
end_comment

begin_define
define|#
directive|define
name|CD1400_xIVR_CHAN_SHIFT
value|3
end_define

begin_define
define|#
directive|define
name|CD1400_xIVR_CHAN
value|0x1F
end_define

begin_comment
comment|/*  * ETC states.  com->etc may also contain a hardware ETC command value,  * meaning that execution of that command is pending.  */
end_comment

begin_define
define|#
directive|define
name|ETC_NONE
value|0
end_define

begin_comment
comment|/* we depend on bzero() setting this */
end_comment

begin_define
define|#
directive|define
name|ETC_BREAK_STARTING
value|1
end_define

begin_define
define|#
directive|define
name|ETC_BREAK_STARTED
value|2
end_define

begin_define
define|#
directive|define
name|ETC_BREAK_ENDING
value|3
end_define

begin_define
define|#
directive|define
name|ETC_BREAK_ENDED
value|4
end_define

begin_define
define|#
directive|define
name|LOTS_OF_EVENTS
value|64
end_define

begin_comment
comment|/* helps separate urgent events from input */
end_comment

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|DEV_TO_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev)))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_comment
comment|/*  * Not all of the magic is parametrized in the following macros.  16 and  * 0xff are related to the bitfields in a udev_t.  CY_MAX_PORTS must be  * ((0xff& ~MINOR_MAGIC_MASK) + 1) for things to work.  */
end_comment

begin_define
define|#
directive|define
name|MINOR_TO_UNIT
parameter_list|(
name|mynor
parameter_list|)
value|(((mynor)>> 16) * CY_MAX_PORTS \ 				 | (((mynor)& 0xff)& ~MINOR_MAGIC_MASK))
end_define

begin_define
define|#
directive|define
name|UNIT_TO_MINOR
parameter_list|(
name|unit
parameter_list|)
value|(((unit) / CY_MAX_PORTS)<< 16 \ 				 | (((unit)& 0xff)& ~MINOR_MAGIC_MASK))
end_define

begin_comment
comment|/*  * com state bits.  * (CS_BUSY | CS_TTGO) and (CS_BUSY | CS_TTGO | CS_ODEVREADY) must be higher  * than the other bits so that they can be tested as a group without masking  * off the low bits.  *  * The following com and tty flags correspond closely:  *	CS_BUSY		= TS_BUSY (maintained by comstart(), siopoll() and  *				   comstop())  *	CS_TTGO		= ~TS_TTSTOP (maintained by comparam() and comstart())  *	CS_CTS_OFLOW	= CCTS_OFLOW (maintained by comparam())  *	CS_RTS_IFLOW	= CRTS_IFLOW (maintained by comparam())  * TS_FLUSH is not used.  * XXX I think TIOCSETA doesn't clear TS_TTSTOP when it clears IXON.  * XXX CS_*FLOW should be CF_*FLOW in com->flags (control flags not state).  */
end_comment

begin_define
define|#
directive|define
name|CS_BUSY
value|0x80
end_define

begin_comment
comment|/* output in progress */
end_comment

begin_define
define|#
directive|define
name|CS_TTGO
value|0x40
end_define

begin_comment
comment|/* output not stopped by XOFF */
end_comment

begin_define
define|#
directive|define
name|CS_ODEVREADY
value|0x20
end_define

begin_comment
comment|/* external device h/w ready (CTS) */
end_comment

begin_define
define|#
directive|define
name|CS_CHECKMSR
value|1
end_define

begin_comment
comment|/* check of MSR scheduled */
end_comment

begin_define
define|#
directive|define
name|CS_CTS_OFLOW
value|2
end_define

begin_comment
comment|/* use CTS output flow control */
end_comment

begin_define
define|#
directive|define
name|CS_DTR_OFF
value|0x10
end_define

begin_comment
comment|/* DTR held off */
end_comment

begin_define
define|#
directive|define
name|CS_ODONE
value|4
end_define

begin_comment
comment|/* output completed */
end_comment

begin_define
define|#
directive|define
name|CS_RTS_IFLOW
value|8
end_define

begin_comment
comment|/* use RTS input flow control */
end_comment

begin_define
define|#
directive|define
name|CSE_ODONE
value|1
end_define

begin_comment
comment|/* output transmitted */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|error_desc
index|[]
init|=
block|{
define|#
directive|define
name|CE_OVERRUN
value|0
literal|"silo overflow"
block|,
define|#
directive|define
name|CE_INTERRUPT_BUF_OVERFLOW
value|1
literal|"interrupt-level buffer overflow"
block|,
define|#
directive|define
name|CE_TTY_BUF_OVERFLOW
value|2
literal|"tty-level buffer overflow"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CE_NTYPES
value|3
end_define

begin_define
define|#
directive|define
name|CE_RECORD
parameter_list|(
name|com
parameter_list|,
name|errnum
parameter_list|)
value|(++(com)->delta_error_counts[errnum])
end_define

begin_comment
comment|/* types.  XXX - should be elsewhere */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_comment
comment|/* boolean */
end_comment

begin_typedef
typedef|typedef
name|u_char
specifier|volatile
modifier|*
name|cy_addr
typedef|;
end_typedef

begin_comment
comment|/* queue of linear buffers */
end_comment

begin_struct
struct|struct
name|lbq
block|{
name|u_char
modifier|*
name|l_head
decl_stmt|;
comment|/* next char to process */
name|u_char
modifier|*
name|l_tail
decl_stmt|;
comment|/* one past the last char to process */
name|struct
name|lbq
modifier|*
name|l_next
decl_stmt|;
comment|/* next in queue */
name|bool_t
name|l_queued
decl_stmt|;
comment|/* nonzero if queued */
block|}
struct|;
end_struct

begin_comment
comment|/* com device structure */
end_comment

begin_struct
struct|struct
name|com_s
block|{
name|u_char
name|state
decl_stmt|;
comment|/* miscellaneous flag bits */
name|bool_t
name|active_out
decl_stmt|;
comment|/* nonzero if the callout device is open */
if|#
directive|if
literal|0
block|u_char	cfcr_image;
comment|/* copy of value written to CFCR */
endif|#
directive|endif
name|u_char
name|etc
decl_stmt|;
comment|/* pending Embedded Transmit Command */
name|u_char
name|extra_state
decl_stmt|;
comment|/* more flag bits, separate for order trick */
if|#
directive|if
literal|0
block|u_char	fifo_image;
comment|/* copy of value written to FIFO */
endif|#
directive|endif
name|u_char
name|gfrcr_image
decl_stmt|;
comment|/* copy of value read from GFRCR */
if|#
directive|if
literal|0
block|bool_t	hasfifo;
comment|/* nonzero for 16550 UARTs */
block|bool_t	loses_outints;
comment|/* nonzero if device loses output interrupts */
endif|#
directive|endif
name|u_char
name|mcr_dtr
decl_stmt|;
comment|/* MCR bit that is wired to DTR */
name|u_char
name|mcr_image
decl_stmt|;
comment|/* copy of value written to MCR */
name|u_char
name|mcr_rts
decl_stmt|;
comment|/* MCR bit that is wired to RTS */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|COM_MULTIPORT
block|bool_t	multiport;
comment|/* is this unit part of a multiport device? */
endif|#
directive|endif
comment|/* COM_MULTIPORT */
block|bool_t	no_irq;
comment|/* nonzero if irq is not attached */
block|bool_t	poll;
comment|/* nonzero if polling is required */
block|bool_t	poll_output;
comment|/* nonzero if polling for output is required */
endif|#
directive|endif
name|int
name|unit
decl_stmt|;
comment|/* unit	number */
name|int
name|dtr_wait
decl_stmt|;
comment|/* time to hold DTR down on close (* 1/hz) */
if|#
directive|if
literal|0
block|u_int	tx_fifo_size;
endif|#
directive|endif
name|u_int
name|wopeners
decl_stmt|;
comment|/* # processes waiting for DCD in open() */
comment|/* 	 * The high level of the driver never reads status registers directly 	 * because there would be too many side effects to handle conveniently. 	 * Instead, it reads copies of the registers stored here by the 	 * interrupt handler. 	 */
name|u_char
name|last_modem_status
decl_stmt|;
comment|/* last MSR read by intr handler */
name|u_char
name|prev_modem_status
decl_stmt|;
comment|/* last MSR handled by high level */
name|u_char
name|hotchar
decl_stmt|;
comment|/* ldisc-specific char to be handled ASAP */
name|u_char
modifier|*
name|ibuf
decl_stmt|;
comment|/* start of input buffer */
name|u_char
modifier|*
name|ibufend
decl_stmt|;
comment|/* end of input buffer */
name|u_char
modifier|*
name|ibufold
decl_stmt|;
comment|/* old input buffer, to be freed */
name|u_char
modifier|*
name|ihighwater
decl_stmt|;
comment|/* threshold in input buffer */
name|u_char
modifier|*
name|iptr
decl_stmt|;
comment|/* next free spot in input buffer */
name|int
name|ibufsize
decl_stmt|;
comment|/* size of ibuf (not include error bytes) */
name|int
name|ierroff
decl_stmt|;
comment|/* offset of error bytes in ibuf */
name|struct
name|lbq
name|obufq
decl_stmt|;
comment|/* head of queue of output buffers */
name|struct
name|lbq
name|obufs
index|[
literal|2
index|]
decl_stmt|;
comment|/* output buffers */
name|int
name|cy_align
decl_stmt|;
comment|/* index for register alignment */
name|cy_addr
name|cy_iobase
decl_stmt|;
comment|/* base address of this port's cyclom */
name|cy_addr
name|iobase
decl_stmt|;
comment|/* base address of this port's cd1400 */
name|int
name|mcr_rts_reg
decl_stmt|;
comment|/* cd1400 reg number of reg holding mcr_rts */
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* cross reference */
comment|/* Initial state. */
name|struct
name|termios
name|it_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|it_out
decl_stmt|;
comment|/* Lock state. */
name|struct
name|termios
name|lt_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|lt_out
decl_stmt|;
name|bool_t
name|do_timestamp
decl_stmt|;
name|bool_t
name|do_dcd_timestamp
decl_stmt|;
name|struct
name|timeval
name|timestamp
decl_stmt|;
name|struct
name|timeval
name|dcd_timestamp
decl_stmt|;
name|u_long
name|bytes_in
decl_stmt|;
comment|/* statistics */
name|u_long
name|bytes_out
decl_stmt|;
name|u_int
name|delta_error_counts
index|[
name|CE_NTYPES
index|]
decl_stmt|;
name|u_long
name|error_counts
index|[
name|CE_NTYPES
index|]
decl_stmt|;
name|u_int
name|recv_exception
decl_stmt|;
comment|/* exception chars received */
name|u_int
name|mdm
decl_stmt|;
comment|/* modem signal changes */
ifdef|#
directive|ifdef
name|CyDebug
name|u_int
name|start_count
decl_stmt|;
comment|/* no. of calls to comstart() */
name|u_int
name|start_real
decl_stmt|;
comment|/* no. of calls that did something */
endif|#
directive|endif
name|u_char
name|car
decl_stmt|;
comment|/* CD1400 CAR shadow (if first unit in cd) */
name|u_char
name|channel_control
decl_stmt|;
comment|/* CD1400 CCR control command shadow */
name|u_char
name|cor
index|[
literal|3
index|]
decl_stmt|;
comment|/* CD1400 COR1-3 shadows */
name|u_char
name|intr_enable
decl_stmt|;
comment|/* CD1400 SRER shadow */
comment|/* 	 * Data area for output buffers.  Someday we should build the output 	 * buffer queue without copying data. 	 */
name|u_char
name|obuf1
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|obuf2
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* PCI driver entry point. */
end_comment

begin_decl_stmt
name|int
name|cyattach_common
name|__P
argument_list|(
operator|(
name|cy_addr
name|cy_iobase
operator|,
name|int
name|cy_align
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ointhand2_t
name|siointr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_units
name|__P
argument_list|(
operator|(
name|cy_addr
name|cy_iobase
operator|,
name|int
name|cy_align
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sioattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd1400_channel_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|int
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd1400_channel_cmd_wait
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd_etc
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|int
name|etc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cd_getreg
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|int
name|reg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd_setreg
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|int
name|reg
operator|,
name|int
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|siodtrwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|comhardclose
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sioinput
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|critical_t
operator|*
name|savecrit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static	void	siointr1	__P((struct com_s *com));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|commctl
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|int
name|bits
operator|,
name|int
name|how
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|siopoll
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sioprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|siosettimeout
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|siosetwater
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|speed_t
name|speed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comspeed
name|__P
argument_list|(
operator|(
name|speed_t
name|speed
operator|,
name|u_long
name|cy_clock
operator|,
name|int
operator|*
name|prescaler_io
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|comstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|comstop
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|rw
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|comwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disc_optim
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|,
expr|struct
name|com_s
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_decl_stmt
name|void
name|cystatus
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|driver_name
index|[]
init|=
literal|"cy"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table and macro for fast conversion from a unit number to its com struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|com_s
modifier|*
name|p_com_addr
index|[
name|NSIO
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|com_addr
parameter_list|(
name|unit
parameter_list|)
value|(p_com_addr[unit])
end_define

begin_decl_stmt
name|struct
name|isa_driver
name|siodriver
init|=
block|{
name|INTR_TYPE_TTY
operator||
name|INTR_FAST
block|,
name|sioprobe
block|,
name|sioattach
block|,
name|driver_name
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_ISA_DRIVER
argument_list|(
name|cy
argument_list|,
name|cydriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|sioopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sioclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|siowrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sioioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|48
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sio_cdevsw
init|=
block|{
comment|/* open */
name|sioopen
block|,
comment|/* close */
name|sioclose
block|,
comment|/* read */
name|ttyread
block|,
comment|/* write */
name|siowrite
block|,
comment|/* ioctl */
name|sioioctl
block|,
comment|/* poll */
name|ttypoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
name|driver_name
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_TTY
operator||
name|D_KQFILTER
block|,
comment|/* kqfilter */
name|ttykqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comconsole
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|speed_t
name|comdefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|com_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input chars + weighted output completions */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sio_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sio_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sio_timeouts_until_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|sio_timeout_handle
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|sio_timeout_handle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|cd_inbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_inbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cd_outbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_outbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_svrr_probes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_timeouts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|cy_chip_offset
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0400
block|,
literal|0x0800
block|,
literal|0x0c00
block|,
literal|0x0200
block|,
literal|0x0600
block|,
literal|0x0a00
block|,
literal|0x0e00
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_nr_cd1400s
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_total_devices
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|RxFifoThreshold
end_undef

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|RxFifoThreshold
init|=
operator|(
name|CD1400_RX_FIFO_SIZE
operator|/
literal|2
operator|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sioprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|cy_addr
name|iobase
decl_stmt|;
name|iobase
operator|=
operator|(
name|cy_addr
operator|)
name|dev
operator|->
name|id_maddr
expr_stmt|;
comment|/* Cyclom-16Y hardware reset (Cyclom-8Ys don't care) */
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY16_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX? */
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* wait for the board to get its act together */
comment|/* this is needed to get the board out of reset */
name|cy_outb
argument_list|(
name|iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
return|return
operator|(
name|cy_units
argument_list|(
name|iobase
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cy_units
parameter_list|(
name|cy_iobase
parameter_list|,
name|cy_align
parameter_list|)
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
block|{
name|int
name|cyu
decl_stmt|;
name|u_char
name|firmware_version
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|CY_MAX_CD1400s
condition|;
operator|++
name|cyu
control|)
block|{
name|iobase
operator|=
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
expr_stmt|;
comment|/* wait for chip to become ready for new command */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|)
condition|)
break|break;
block|}
comment|/* clear the GFRCR register */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* issue a reset command */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FULLRESET
argument_list|)
expr_stmt|;
comment|/* wait for the CD1400 to initialize itself */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* retrieve firmware version */
name|firmware_version
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|firmware_version
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
break|break;
block|}
comment|/* 		 * Anything in the 0x40-0x4F range is fine. 		 * If one CD1400 is bad then we don't support higher 		 * numbered good ones on this board. 		 */
if|if
condition|(
operator|(
name|firmware_version
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x40
condition|)
break|break;
block|}
return|return
operator|(
name|cyu
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioattach
parameter_list|(
name|isdp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
block|{
name|int
name|adapter
decl_stmt|;
name|adapter
operator|=
name|cyattach_common
argument_list|(
operator|(
name|cy_addr
operator|)
name|isdp
operator|->
name|id_maddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX 	 * This kludge is to allow ISA/PCI device specifications in the 	 * kernel config file to be in any order. 	 */
if|if
condition|(
name|isdp
operator|->
name|id_unit
operator|!=
name|adapter
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: attached as cy%d\n"
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|isdp
operator|->
name|id_unit
operator|=
name|adapter
expr_stmt|;
comment|/* XXX */
block|}
name|isdp
operator|->
name|id_ointr
operator|=
name|siointr
expr_stmt|;
comment|/* isdp->id_ri_flags |= RI_FAST; XXX unimplemented - use newbus! */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cyattach_common
parameter_list|(
name|cy_iobase
parameter_list|,
name|cy_align
parameter_list|)
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
block|{
name|int
name|adapter
decl_stmt|;
name|int
name|cyu
decl_stmt|;
name|u_char
name|firmware_version
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|minorbase
decl_stmt|;
name|int
name|ncyu
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|adapter
operator|=
name|cy_total_devices
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|adapter
operator|>=
name|NCY
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: can't attach adapter: insufficient cy devices configured\n"
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ncyu
operator|=
name|cy_units
argument_list|(
name|cy_iobase
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncyu
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cy_nr_cd1400s
index|[
name|adapter
index|]
operator|=
name|ncyu
expr_stmt|;
name|cy_total_devices
operator|++
expr_stmt|;
name|unit
operator|=
name|adapter
operator|*
name|CY_MAX_PORTS
expr_stmt|;
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|ncyu
condition|;
operator|++
name|cyu
control|)
block|{
name|int
name|cdu
decl_stmt|;
name|iobase
operator|=
call|(
name|cy_addr
call|)
argument_list|(
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
argument_list|)
expr_stmt|;
name|firmware_version
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* Set up a receive timeout period of than 1+ ms. */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_PPR
argument_list|,
name|cy_align
argument_list|,
name|howmany
argument_list|(
name|CY_CLOCK
argument_list|(
name|firmware_version
argument_list|)
operator|/
name|CD1400_PPR_PRESCALER
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cdu
operator|=
literal|0
init|;
name|cdu
operator|<
name|CD1400_NO_OF_CHANNELS
condition|;
operator|++
name|cdu
operator|,
operator|++
name|unit
control|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
name|com
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|com
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
break|break;
name|com
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|com
operator|->
name|gfrcr_image
operator|=
name|firmware_version
expr_stmt|;
if|if
condition|(
name|CY_RTS_DTR_SWAPPED
argument_list|(
name|firmware_version
argument_list|)
condition|)
block|{
name|com
operator|->
name|mcr_dtr
operator|=
name|MCR_RTS
expr_stmt|;
name|com
operator|->
name|mcr_rts
operator|=
name|MCR_DTR
expr_stmt|;
name|com
operator|->
name|mcr_rts_reg
operator|=
name|CD1400_MSVR2
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|mcr_dtr
operator|=
name|MCR_DTR
expr_stmt|;
name|com
operator|->
name|mcr_rts
operator|=
name|MCR_RTS
expr_stmt|;
name|com
operator|->
name|mcr_rts_reg
operator|=
name|CD1400_MSVR1
expr_stmt|;
block|}
name|com
operator|->
name|dtr_wait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
operator|=
name|com
operator|->
name|obuf1
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
operator|=
name|com
operator|->
name|obuf2
expr_stmt|;
name|com
operator|->
name|cy_align
operator|=
name|cy_align
expr_stmt|;
name|com
operator|->
name|cy_iobase
operator|=
name|cy_iobase
expr_stmt|;
name|com
operator|->
name|iobase
operator|=
name|iobase
expr_stmt|;
name|com
operator|->
name|car
operator|=
operator|~
name|CD1400_CAR_CHAN
expr_stmt|;
comment|/* 	 * We don't use all the flags from<sys/ttydefaults.h> since they 	 * are only relevant for logins.  It's important to have echo off 	 * initially so that the line doesn't start blathering before the 	 * echo flag can be turned off. 	 */
name|com
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|comconsole
condition|)
block|{
name|com
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
operator||
name|CLOCAL
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|com
operator|->
name|lt_out
operator|.
name|c_cflag
operator|=
name|com
operator|->
name|lt_in
operator|.
name|c_cflag
operator|=
name|CLOCAL
expr_stmt|;
block|}
if|if
condition|(
name|siosetwater
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|it_in
operator|.
name|c_ispeed
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|com
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|termioschars
argument_list|(
operator|&
name|com
operator|->
name|it_in
argument_list|)
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|com
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|comdefaultrate
expr_stmt|;
name|com
operator|->
name|it_out
operator|=
name|com
operator|->
name|it_in
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|com_addr
argument_list|(
name|unit
argument_list|)
operator|=
name|com
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sio_ih
operator|==
name|NULL
condition|)
block|{
name|cdevsw_add
argument_list|(
operator|&
name|sio_cdevsw
argument_list|)
expr_stmt|;
name|swi_add
argument_list|(
operator|&
name|tty_ithd
argument_list|,
literal|"tty:cy"
argument_list|,
name|siopoll
argument_list|,
name|NULL
argument_list|,
name|SWI_TTY
argument_list|,
literal|0
argument_list|,
operator|&
name|sio_ih
argument_list|)
expr_stmt|;
block|}
name|minorbase
operator|=
name|UNIT_TO_MINOR
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|minorbase
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyc%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|minorbase
operator||
name|CONTROL_INIT_STATE
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyic%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|minorbase
operator||
name|CONTROL_LOCK_STATE
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttylc%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|minorbase
operator||
name|CALLOUT_MASK
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuac%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|minorbase
operator||
name|CALLOUT_MASK
operator||
name|CONTROL_INIT_STATE
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuaic%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|minorbase
operator||
name|CALLOUT_MASK
operator||
name|CONTROL_LOCK_STATE
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cualc%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ensure an edge for the next interrupt */
name|cy_outb
argument_list|(
name|cy_iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|adapter
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|unit
operator|>=
name|NSIO
operator|||
operator|(
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tp
operator|=
name|dev
operator|->
name|si_tty
operator|=
name|com
operator|->
name|tp
operator|=
name|ttymalloc
argument_list|(
name|com
operator|->
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * We jump to this label after all non-interrupted sleeps to pick 	 * up any changes of the device state. 	 */
name|open_top
label|:
while|while
condition|(
name|com
operator|->
name|state
operator|&
name|CS_DTR_OFF
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|com
operator|->
name|dtr_wait
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cydtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * The device is open, so everything has been initialized. 		 * Handle conflicts. 		 */
if|if
condition|(
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
block|{
if|if
condition|(
operator|!
name|com
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|com
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cybi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|suser_td
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it.  Initialization is done twice in many 		 * cases: to preempt sleeping callin opens if we are 		 * callout, and to complete a callin open after DCD rises. 		 */
name|tp
operator|->
name|t_oproc
operator|=
name|comstart
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|comstop
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|comparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
name|com
operator|->
name|it_out
else|:
name|com
operator|->
name|it_in
expr_stmt|;
comment|/* Encode per-board unit in LIVR for access in intr routines. */
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_LIVR
argument_list|,
operator|(
name|unit
operator|&
name|CD1400_xIVR_CHAN
operator|)
operator|<<
name|CD1400_xIVR_CHAN_SHIFT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|com->poll = com->no_irq; 		com->poll_output = com->loses_outints;
endif|#
directive|endif
operator|++
name|com
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|comparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|--
name|com
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|#
directive|if
literal|0
block|if (com->hasfifo) {
comment|/* 			 * (Re)enable and flush fifos. 			 * 			 * Certain SMC chips cause problems if the fifos 			 * are enabled while input is ready.  Turn off the 			 * fifo if necessary to clear the input.  We test 			 * the input ready bit after enabling the fifos 			 * since we've already enabled them in comparam() 			 * and to handle races between enabling and fresh 			 * input. 			 */
block|while (TRUE) { 				outb(iobase + com_fifo, 				     FIFO_RCV_RST | FIFO_XMT_RST 				     | com->fifo_image); 				DELAY(100); 				if (!(inb(com->line_status_port)& LSR_RXRDY)) 					break; 				outb(iobase + com_fifo, 0); 				DELAY(100); 				(void) inb(com->data_port); 			} 		}  		savecrit = critical_enter(); 		COM_LOCK(); 		(void) inb(com->line_status_port); 		(void) inb(com->data_port); 		com->prev_modem_status = com->last_modem_status 		    = inb(com->modem_status_port); 		outb(iobase + com_ier, IER_ERXRDY | IER_ETXRDY | IER_ERLS 				       | IER_EMSC); 		COM_UNLOCK(); 		critical_exit(savecrit);
else|#
directive|else
comment|/* !0 */
comment|/* 		 * Flush fifos.  This requires a full channel reset which 		 * also disables the transmitter and receiver.  Recover 		 * from this. 		 */
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_CHANRESET
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|prev_modem_status
operator|=
name|com
operator|->
name|last_modem_status
operator|=
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|CD1400_SRER_MDMCH
operator||
name|CD1400_SRER_RXDATA
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 0 */
comment|/* 		 * Handle initial DCD.  Callout devices get a fake initial 		 * DCD (trapdoor DCD).  If we are callout, then any sleeping 		 * callin opens get woken up and resume sleeping on "cybi" 		 * instead of "cydcd". 		 */
comment|/* 		 * XXX `mynor& CALLOUT_MASK' should be 		 * `tp->t_cflag& (SOFT_CARRIER | TRAPDOOR_CARRIER) where 		 * TRAPDOOR_CARRIER is the default initial state for callout 		 * devices and SOFT_CARRIER is like CLOCAL except it hides 		 * the true carrier. 		 */
if|if
condition|(
name|com
operator|->
name|prev_modem_status
operator|&
name|MSR_DCD
operator|||
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 	 * Wait for DCD if necessary. 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
operator|++
name|com
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cydcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|com
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|com
operator|->
name|active_out
operator|=
name|TRUE
expr_stmt|;
name|siosettimeout
argument_list|()
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|com
operator|->
name|wopeners
operator|==
literal|0
condition|)
name|comhardclose
argument_list|(
name|com
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|com
operator|=
name|com_addr
argument_list|(
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cd_etc
argument_list|(
name|com
argument_list|,
name|CD1400_ETC_STOPBREAK
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|comstop
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|comhardclose
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|siosettimeout
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|broken
comment|/* session holds a ref to the tty; can't deallocate */
name|ttyfree
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|com
operator|->
name|tp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|comhardclose
parameter_list|(
name|com
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
block|{
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|unit
operator|=
name|com
operator|->
name|unit
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|com->poll = FALSE; 	com->poll_output = FALSE;
endif|#
directive|endif
name|com
operator|->
name|do_timestamp
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|outb(iobase + com_cfcr, com->cfcr_image&= ~CFCR_SBREAK);
else|#
directive|else
comment|/* XXX */
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|etc
operator|=
name|ETC_NONE
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR2
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|&=
operator|~
name|CD1400_COR2_ETC
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FTF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|{
if|#
directive|if
literal|0
block|outb(iobase + com_ier, 0);
else|#
directive|else
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
literal|0
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
comment|/* 		     * XXX we will miss any carrier drop between here and the 		     * next open.  Perhaps we should watch DCD even when the 		     * port is closed; it is not sufficient to check it at 		     * the next open because it might go up and down while 		     * we're not watching. 		     */
operator|||
operator|(
operator|!
name|com
operator|->
name|active_out
operator|&&
operator|!
operator|(
name|com
operator|->
name|prev_modem_status
operator|&
name|MSR_DCD
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|it_in
operator|.
name|c_cflag
operator|&
name|CLOCAL
operator|)
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
comment|/* Disable receiver (leave transmitter enabled). */
name|com
operator|->
name|channel_control
operator|=
name|CD1400_CCR_CMDCHANCTL
operator||
name|CD1400_CCR_XMTEN
operator||
name|CD1400_CCR_RCVDIS
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|dtr_wait
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_DTR_OFF
operator|)
condition|)
block|{
name|timeout
argument_list|(
name|siodtrwakeup
argument_list|,
name|com
argument_list|,
name|com
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_DTR_OFF
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
block|if (com->hasfifo) {
comment|/* 		 * Disable fifos so that they are off after controlled 		 * reboots.  Some BIOSes fail to detect 16550s when the 		 * fifos are enabled. 		 */
block|outb(iobase + com_fifo, 0); 	}
endif|#
directive|endif
name|com
operator|->
name|active_out
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restart any wopeners */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|siowrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
operator|->
name|tp
expr_stmt|;
comment|/* 	 * (XXX) We disallow virtual consoles if the physical console is 	 * a serial port.  This is in case there is a display attached that 	 * is not the console.  In that situation we don't need/want the X 	 * server taking over the console. 	 */
if|if
condition|(
name|constty
operator|!=
name|NULL
operator|&&
name|unit
operator|==
name|comconsole
condition|)
name|constty
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* XXX duplicate ttwrite(), but without so much output processing on 	 * CR& LF chars.  Hardly worth the effort, given that high-throughput 	 * sessions are raw anyhow. 	 */
else|#
directive|else
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|siodtrwakeup
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|com
operator|=
operator|(
expr|struct
name|com_s
operator|*
operator|)
name|chan
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_DTR_OFF
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function:  *  a) needs to be called with COM_LOCK() held, and  *  b) needs to return with COM_LOCK() held.  */
end_comment

begin_function
specifier|static
name|void
name|sioinput
parameter_list|(
name|com
parameter_list|,
name|savecrit
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|critical_t
modifier|*
name|savecrit
decl_stmt|;
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|incc
decl_stmt|;
name|u_char
name|line_status
decl_stmt|;
name|int
name|recv_data
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|buf
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|com_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
comment|/* 		 * Avoid the grotesquely inefficient lineswitch routine 		 * (ttyinput) in "raw" mode.  It usually takes about 450 		 * instructions (that's without canonical processing or echo!). 		 * slinput is reasonably fast (usually 40 instructions plus 		 * call overhead). 		 */
do|do
block|{
comment|/* 			 * This may look odd, but it is using save-and-enable 			 * semantics instead of the save-and-disable semantics 			 * that are used everywhere else. 			 */
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
operator|*
name|savecrit
argument_list|)
expr_stmt|;
name|incc
operator|=
name|com
operator|->
name|iptr
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|incc
operator|>
name|tp
operator|->
name|t_ihiwat
operator|&&
operator|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
operator|||
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|com
operator|->
name|delta_error_counts
index|[
name|CE_TTY_BUF_OVERFLOW
index|]
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|incc
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|incc
expr_stmt|;
name|tk_nin
operator|+=
name|incc
expr_stmt|;
name|tk_rawcc
operator|+=
name|incc
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|incc
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|comstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
operator|*
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|buf
operator|<
name|com
operator|->
name|iptr
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
comment|/* 			 * This may look odd, but it is using save-and-enable 			 * semantics instead of the save-and-disable semantics 			 * that are used everywhere else. 			 */
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
operator|*
name|savecrit
argument_list|)
expr_stmt|;
name|line_status
operator|=
name|buf
index|[
name|com
operator|->
name|ierroff
index|]
expr_stmt|;
name|recv_data
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
operator|(
name|LSR_BI
operator||
name|LSR_FE
operator||
name|LSR_OE
operator||
name|LSR_PE
operator|)
condition|)
block|{
if|if
condition|(
name|line_status
operator|&
name|LSR_BI
condition|)
name|recv_data
operator||=
name|TTY_BI
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|LSR_FE
condition|)
name|recv_data
operator||=
name|TTY_FE
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|LSR_OE
condition|)
name|recv_data
operator||=
name|TTY_OE
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|LSR_PE
condition|)
name|recv_data
operator||=
name|TTY_PE
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|recv_data
operator|,
name|tp
operator|)
expr_stmt|;
operator|*
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|buf
operator|<
name|com
operator|->
name|iptr
condition|)
do|;
block|}
name|com_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
comment|/* 	 * There is now room for another low-level buffer full of input, 	 * so enable RTS if it is now disabled and there is room in the 	 * high-level buffer. 	 */
if|if
condition|(
operator|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|mcr_image
operator|&
name|com
operator|->
name|mcr_rts
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image |= MCR_RTS);
else|#
directive|else
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|siointr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|baseu
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cyu
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
comment|/* XXX could this be placed down lower in the loop? */
name|baseu
operator|=
name|unit
operator|*
name|CY_MAX_PORTS
expr_stmt|;
name|cy_align
operator|=
name|com_addr
argument_list|(
name|baseu
argument_list|)
operator|->
name|cy_align
expr_stmt|;
name|cy_iobase
operator|=
name|com_addr
argument_list|(
name|baseu
argument_list|)
operator|->
name|cy_iobase
expr_stmt|;
comment|/* check each CD1400 in turn */
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|cy_nr_cd1400s
index|[
name|unit
index|]
condition|;
operator|++
name|cyu
control|)
block|{
name|iobase
operator|=
call|(
name|cy_addr
call|)
argument_list|(
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
argument_list|)
expr_stmt|;
comment|/* poll to see if it has any work */
name|status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SVRR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|cy_svrr_probes
expr_stmt|;
endif|#
directive|endif
comment|/* service requests as appropriate, giving priority to RX */
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_RXRDY
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_char
modifier|*
name|ioptr
decl_stmt|;
name|u_char
name|line_status
decl_stmt|;
name|u_char
name|recv_data
decl_stmt|;
name|u_char
name|serv_type
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_rir
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_rir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter rx service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_rir
argument_list|)
expr_stmt|;
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
argument_list|)
operator|->
name|car
operator|=
name|save_rir
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|serv_type
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIVR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|serv_type
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack receive service */
name|serv_type
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|+
operator|(
operator|(
name|serv_type
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|serv_type
operator|&
name|CD1400_RIVR_EXCEPTION
condition|)
block|{
operator|++
name|com
operator|->
name|recv_exception
expr_stmt|;
name|line_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* break/unnattached error bits or real input? */
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_SPECIAL
operator|&&
name|com
operator|->
name|hotchar
operator|!=
literal|0
condition|)
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* XXX "intelligent" PFO error handling would break O error handling */
if|if
condition|(
name|line_status
operator|&
operator|(
name|LSR_PE
operator||
name|LSR_FE
operator||
name|LSR_BI
operator|)
condition|)
block|{
comment|/* 				  Don't store PE if IGNPAR and BI if IGNBRK, 				  this hack allows "raw" tty optimization 				  works even if IGN* is set. 				*/
if|if
condition|(
name|com
operator|->
name|tp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|(
operator|(
name|line_status
operator|&
operator|(
name|LSR_PE
operator||
name|LSR_FE
operator|)
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|IGNPAR
operator|)
operator|)
operator|||
operator|(
operator|(
name|line_status
operator|&
name|LSR_BI
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|IGNBRK
operator|)
operator|)
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
operator|(
name|line_status
operator|&
operator|(
name|LSR_PE
operator||
name|LSR_FE
operator|)
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
operator|&&
operator|(
operator|(
name|line_status
operator|&
name|LSR_FE
operator|)
operator|||
operator|(
operator|(
name|line_status
operator|&
name|LSR_PE
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|)
operator|)
condition|)
name|recv_data
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 1 */
operator|++
name|com
operator|->
name|bytes_in
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioptr
operator|=
name|com
operator|->
name|iptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|>=
name|com
operator|->
name|ibufend
condition|)
name|CE_RECORD
argument_list|(
name|com
argument_list|,
name|CE_INTERRUPT_BUF_OVERFLOW
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|com
operator|->
name|do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|timestamp
argument_list|)
expr_stmt|;
operator|++
name|com_events
expr_stmt|;
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|com
operator|->
name|ierroff
index|]
operator|=
name|line_status
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
operator|++
name|ioptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|==
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, 					     com->mcr_image&= ~MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|line_status
operator|&
name|LSR_OE
condition|)
name|CE_RECORD
argument_list|(
name|com
argument_list|,
name|CE_OVERRUN
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cont
goto|;
block|}
else|else
block|{
name|int
name|ifree
decl_stmt|;
name|count
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
goto|goto
name|cont
goto|;
name|com
operator|->
name|bytes_in
operator|+=
name|count
expr_stmt|;
name|ioptr
operator|=
name|com
operator|->
name|iptr
expr_stmt|;
name|ifree
operator|=
name|com
operator|->
name|ibufend
operator|-
name|ioptr
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|ifree
condition|)
block|{
name|count
operator|-=
name|ifree
expr_stmt|;
name|com_events
operator|+=
name|ifree
expr_stmt|;
if|if
condition|(
name|ifree
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|timestamp
argument_list|)
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|com
operator|->
name|ierroff
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|ioptr
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ifree
operator|!=
literal|0
condition|)
do|;
block|}
name|com
operator|->
name|delta_error_counts
index|[
name|CE_INTERRUPT_BUF_OVERFLOW
index|]
operator|+=
name|count
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioptr
operator|<=
name|com
operator|->
name|ihighwater
operator|&&
name|ioptr
operator|+
name|count
operator|>
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, 					     com->mcr_image&= ~MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|com_events
operator|+=
name|count
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|com
operator|->
name|ierroff
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|ioptr
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
name|com
operator|->
name|iptr
operator|=
name|ioptr
expr_stmt|;
block|}
name|cont
label|:
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|cy_align
argument_list|,
name|save_rir
operator|&
operator|~
operator|(
name|CD1400_RIR_RDIREQ
operator||
name|CD1400_RIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_MDMCH
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
name|modem_status
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_mir
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_mir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter modem service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_mir
argument_list|)
expr_stmt|;
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
argument_list|)
operator|->
name|car
operator|=
name|save_mir
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_mir
operator|&
name|CD1400_MIR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack modem service */
name|vector
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKM
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|vector
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|com
operator|->
name|mdm
expr_stmt|;
name|modem_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|modem_status
operator|!=
name|com
operator|->
name|last_modem_status
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|do_dcd_timestamp
operator|&&
operator|!
operator|(
name|com
operator|->
name|last_modem_status
operator|&
name|MSR_DCD
operator|)
operator|&&
name|modem_status
operator|&
name|MSR_DCD
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|dcd_timestamp
argument_list|)
expr_stmt|;
comment|/* 			 * Schedule high level to handle DCD changes.  Note 			 * that we don't use the delta bits anywhere.  Some 			 * UARTs mess them up, and it's easy to remember the 			 * previous bits and calculate the delta. 			 */
name|com
operator|->
name|last_modem_status
operator|=
name|modem_status
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
operator|)
condition|)
block|{
name|com_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_CHECKMSR
expr_stmt|;
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
comment|/* handle CTS change immediately for crisp flow ctl */
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CTS_OFLOW
condition|)
block|{
if|if
condition|(
name|modem_status
operator|&
name|MSR_CTS
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_ODEVREADY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODEVREADY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|cy_align
argument_list|,
name|save_mir
operator|&
operator|~
operator|(
name|CD1400_MIR_RDIREQ
operator||
name|CD1400_MIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_TXRDY
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_tir
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_tir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter tx service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_tir
argument_list|)
expr_stmt|;
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
argument_list|)
operator|->
name|car
operator|=
name|save_tir
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_tir
operator|&
name|CD1400_TIR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack transmit service */
name|vector
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKT
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|vector
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|com
operator|->
name|etc
operator|!=
name|ETC_NONE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
block|{
comment|/* 					 * Here due to sloppy SRER_TXRDY 					 * enabling.  Ignore.  Come back when 					 * tx is empty. 					 */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
goto|goto
name|terminate_tx_service
goto|;
block|}
switch|switch
condition|(
name|com
operator|->
name|etc
condition|)
block|{
case|case
name|CD1400_ETC_SENDBREAK
case|:
case|case
name|CD1400_ETC_STOPBREAK
case|:
comment|/* 					 * Start the command.  Come back on 					 * next tx empty interrupt, hopefully 					 * after command has been executed. 					 */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR2
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator||=
name|CD1400_COR2_ETC
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
name|CD1400_ETC_CMD
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|etc
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|CD1400_ETC_SENDBREAK
condition|)
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_STARTING
expr_stmt|;
else|else
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_ENDING
expr_stmt|;
goto|goto
name|terminate_tx_service
goto|;
case|case
name|ETC_BREAK_STARTING
case|:
comment|/* 					 * BREAK is now on.  Continue with 					 * SRER_TXMPTY processing, hopefully 					 * don't come back. 					 */
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_STARTED
expr_stmt|;
break|break;
case|case
name|ETC_BREAK_STARTED
case|:
comment|/* 					 * Came back due to sloppy SRER_TXMPTY 					 * enabling.  Hope again. 					 */
break|break;
case|case
name|ETC_BREAK_ENDING
case|:
comment|/* 					 * BREAK is now off.  Continue with 					 * SRER_TXMPTY processing and don't 					 * come back.  The SWI handler will 					 * restart tx interrupts if necessary. 					 */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR2
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|&=
operator|~
name|CD1400_COR2_ETC
argument_list|)
expr_stmt|;
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_ENDED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
operator|)
condition|)
block|{
name|com_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_ODONE
expr_stmt|;
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETC_BREAK_ENDED
case|:
comment|/* 					 * Shouldn't get here.  Hope again. 					 */
break|break;
block|}
block|}
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXMPTY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
operator|)
condition|)
block|{
name|com_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator||=
name|CSE_ODONE
expr_stmt|;
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
block|}
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|&=
operator|~
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
goto|goto
name|terminate_tx_service
goto|;
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
block|{
name|u_char
modifier|*
name|ioptr
decl_stmt|;
name|u_int
name|ocount
decl_stmt|;
name|ioptr
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_head
expr_stmt|;
name|ocount
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|-
name|ioptr
expr_stmt|;
if|if
condition|(
name|ocount
operator|>
name|CD1400_TX_FIFO_SIZE
condition|)
name|ocount
operator|=
name|CD1400_TX_FIFO_SIZE
expr_stmt|;
name|com
operator|->
name|bytes_out
operator|+=
name|ocount
expr_stmt|;
do|do
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
operator|*
name|ioptr
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|ocount
operator|!=
literal|0
condition|)
do|;
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|ioptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|>=
name|com
operator|->
name|obufq
operator|.
name|l_tail
condition|)
block|{
name|struct
name|lbq
modifier|*
name|qp
decl_stmt|;
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
name|qp
operator|->
name|l_queued
operator|=
name|FALSE
expr_stmt|;
name|qp
operator|=
name|qp
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|qp
operator|!=
name|NULL
condition|)
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|qp
operator|->
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|qp
operator|->
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
name|qp
expr_stmt|;
block|}
else|else
block|{
comment|/* output just completed */
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_BUSY
expr_stmt|;
comment|/* 					 * The setting of CSE_ODONE may be 					 * stale here.  We currently only 					 * use it when CS_BUSY is set, and 					 * fixing it when we clear CS_BUSY 					 * is easiest. 					 */
if|if
condition|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
condition|)
block|{
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator|&=
operator|~
name|CSE_ODONE
expr_stmt|;
block|}
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
operator|)
condition|)
block|{
name|com_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_ODONE
expr_stmt|;
comment|/* handle at high level ASAP */
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* terminate service context */
name|terminate_tx_service
label|:
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|cy_align
argument_list|,
name|save_tir
operator|&
operator|~
operator|(
name|CD1400_TIR_RDIREQ
operator||
name|CD1400_TIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* ensure an edge for the next interrupt */
name|cy_outb
argument_list|(
name|cy_iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|swi_sched
argument_list|(
name|sio_ih
argument_list|,
name|SWI_NOSWITCH
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void siointr1(com) 	struct com_s	*com; { }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sioioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|int
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|com
operator|->
name|it_out
else|:
operator|&
name|com
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|com
operator|->
name|lt_out
else|:
operator|&
name|com
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser_td
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|com
operator|->
name|lt_out
else|:
operator|&
name|com
operator|->
name|lt_in
decl_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|td
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
if|#
directive|if
literal|0
block|outb(iobase + com_cfcr, com->cfcr_image |= CFCR_SBREAK);
else|#
directive|else
name|cd_etc
argument_list|(
name|com
argument_list|,
name|CD1400_ETC_SENDBREAK
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TIOCCBRK
case|:
if|#
directive|if
literal|0
block|outb(iobase + com_cfcr, com->cfcr_image&= ~CFCR_SBREAK);
else|#
directive|else
name|cd_etc
argument_list|(
name|com
argument_list|,
name|CD1400_ETC_STOPBREAK
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TIOCSDTR
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * XXX should disallow changing MCR_RTS if CS_RTS_IFLOW is set.  The 	 * changes get undone on the next call to comparam(). 	 */
case|case
name|TIOCMSET
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|commctl
argument_list|(
name|com
argument_list|,
literal|0
argument_list|,
name|DMGET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
comment|/* must be root since the wait applies to following logins */
name|error
operator|=
name|suser_td
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|com
operator|->
name|dtr_wait
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|com
operator|->
name|dtr_wait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|TIOCTIMESTAMP
case|:
name|com
operator|->
name|do_timestamp
operator|=
name|TRUE
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|com
operator|->
name|timestamp
expr_stmt|;
break|break;
case|case
name|TIOCDCDTIMESTAMP
case|:
name|com
operator|->
name|do_dcd_timestamp
operator|=
name|TRUE
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|com
operator|->
name|dcd_timestamp
expr_stmt|;
break|break;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|siopoll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|cy_timeouts
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|com_events
operator|==
literal|0
condition|)
return|return;
name|repeat
label|:
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSIO
condition|;
operator|++
name|unit
control|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|incc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
continue|continue;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * XXX forget any events related to closed devices 			 * (actually never opened devices) so that we don't 			 * loop. 			 */
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|incc
operator|=
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
condition|)
block|{
name|incc
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CHECKMSR
expr_stmt|;
block|}
name|com_events
operator|-=
name|incc
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
if|if
condition|(
name|incc
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sio%d: %d events for device with no tp\n"
argument_list|,
name|unit
argument_list|,
name|incc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|com
operator|->
name|iptr
operator|!=
name|com
operator|->
name|ibuf
condition|)
block|{
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|sioinput
argument_list|(
name|com
argument_list|,
operator|&
name|savecrit
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
condition|)
block|{
name|u_char
name|delta_modem_status
decl_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|sioinput
argument_list|(
name|com
argument_list|,
operator|&
name|savecrit
argument_list|)
expr_stmt|;
name|delta_modem_status
operator|=
name|com
operator|->
name|last_modem_status
operator|^
name|com
operator|->
name|prev_modem_status
expr_stmt|;
name|com
operator|->
name|prev_modem_status
operator|=
name|com
operator|->
name|last_modem_status
expr_stmt|;
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CHECKMSR
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta_modem_status
operator|&
name|MSR_DCD
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
name|com
operator|->
name|prev_modem_status
operator|&
name|MSR_DCD
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
condition|)
block|{
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator|&=
operator|~
name|CSE_ODONE
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|com
operator|->
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|etc
operator|!=
name|ETC_NONE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDED
condition|)
name|com
operator|->
name|etc
operator|=
name|ETC_NONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|etc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
condition|)
block|{
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODONE
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|com_events
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|com_events
operator|>=
name|LOTS_OF_EVENTS
condition|)
goto|goto
name|repeat
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|comparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|bits
decl_stmt|;
name|int
name|cflag
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
name|cor_change
decl_stmt|;
name|u_long
name|cy_clock
decl_stmt|;
name|int
name|idivisor
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|int
name|iprescaler
decl_stmt|;
name|int
name|itimeout
decl_stmt|;
name|int
name|odivisor
decl_stmt|;
name|int
name|oprescaler
decl_stmt|;
name|u_char
name|opt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
comment|/* do historical conversions */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|unit
operator|=
name|DEV_TO_UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* check requested parameters */
name|cy_clock
operator|=
name|CY_CLOCK
argument_list|(
name|com
operator|->
name|gfrcr_image
argument_list|)
expr_stmt|;
name|idivisor
operator|=
name|comspeed
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|cy_clock
argument_list|,
operator|&
name|iprescaler
argument_list|)
expr_stmt|;
if|if
condition|(
name|idivisor
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|odivisor
operator|=
name|comspeed
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|cy_clock
argument_list|,
operator|&
name|oprescaler
argument_list|)
expr_stmt|;
if|if
condition|(
name|odivisor
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* parameters are OK, convert them to the com struct and the device */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|odivisor
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
comment|/* hang up line */
else|else
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|siosetwater
argument_list|(
name|com
argument_list|,
name|t
operator|->
name|c_ispeed
argument_list|)
expr_stmt|;
comment|/* XXX we don't actually change the speed atomically. */
if|if
condition|(
name|idivisor
operator|!=
literal|0
condition|)
block|{
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_RBPR
argument_list|,
name|idivisor
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_RCOR
argument_list|,
name|iprescaler
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|odivisor
operator|!=
literal|0
condition|)
block|{
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_TBPR
argument_list|,
name|odivisor
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_TCOR
argument_list|,
name|oprescaler
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * channel control 	 *	receiver enable 	 *	transmitter enable (always set) 	 */
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|opt
operator|=
name|CD1400_CCR_CMDCHANCTL
operator||
name|CD1400_CCR_XMTEN
operator||
operator|(
name|cflag
operator|&
name|CREAD
condition|?
name|CD1400_CCR_RCVEN
else|:
name|CD1400_CCR_RCVDIS
operator|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|channel_control
condition|)
block|{
name|com
operator|->
name|channel_control
operator|=
name|opt
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Smarts
comment|/* set special chars */
comment|/* XXX if one is _POSIX_VDISABLE, can't use some others */
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR1
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR2
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR3
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR4
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * set channel option register 1 - 	 *	parity mode 	 *	stop bits 	 *	char length 	 */
name|opt
operator|=
literal|0
expr_stmt|;
comment|/* parity */
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|opt
operator||=
name|CD1400_COR1_PARODD
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_PARNORMAL
expr_stmt|;
block|}
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
name|INPCK
operator|)
condition|)
name|opt
operator||=
name|CD1400_COR1_NOINPCK
expr_stmt|;
name|bits
operator|=
literal|1
operator|+
literal|1
expr_stmt|;
comment|/* stop bits */
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
block|{
operator|++
name|bits
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_STOP2
expr_stmt|;
block|}
comment|/* char length */
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|bits
operator|+=
literal|5
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|bits
operator|+=
literal|6
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|bits
operator|+=
literal|7
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS7
expr_stmt|;
break|break;
default|default:
name|bits
operator|+=
literal|8
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS8
expr_stmt|;
break|break;
block|}
name|cor_change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|0
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR1
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR1
argument_list|,
name|com
operator|->
name|cor
index|[
literal|0
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set receive time-out period, normally to max(one char time, 5 ms). 	 */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|itimeout
operator|=
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_RTPR
argument_list|)
expr_stmt|;
else|else
block|{
name|itimeout
operator|=
operator|(
literal|1000
operator|*
name|bits
operator|+
name|t
operator|->
name|c_ispeed
operator|-
literal|1
operator|)
operator|/
name|t
operator|->
name|c_ispeed
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
define|#
directive|define
name|MIN_RTP
value|1
else|#
directive|else
define|#
directive|define
name|MIN_RTP
value|5
endif|#
directive|endif
if|if
condition|(
name|itimeout
operator|<
name|MIN_RTP
condition|)
name|itimeout
operator|=
name|MIN_RTP
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
operator|)
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|!=
literal|0
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|!=
literal|0
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
operator|>
name|itimeout
condition|)
name|itimeout
operator|=
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|itimeout
operator|>
literal|255
condition|)
name|itimeout
operator|=
literal|255
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_RTPR
argument_list|,
name|itimeout
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 2 - 	 *	flow control 	 */
name|opt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|opt
operator||=
name|CD1400_COR2_IXANY
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|opt
operator||=
name|CD1400_COR2_IXOFF
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_COR2_CCTS_OFLOW
expr_stmt|;
endif|#
directive|endif
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|1
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR2
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR2
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 3 - 	 *	receiver FIFO interrupt threshold 	 *	flow control 	 */
name|opt
operator|=
name|RxFifoThreshold
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
condition|)
name|opt
operator||=
name|CD1400_COR3_SCD34
expr_stmt|;
comment|/* detect INTR& SUSP chars */
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
comment|/* detect and transparently handle START and STOP chars */
name|opt
operator||=
name|CD1400_COR3_FCT
operator||
name|CD1400_COR3_SCD12
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR3
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR3
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* notify the CD1400 if COR1-3 have changed */
if|if
condition|(
name|cor_change
condition|)
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDCORCHG
operator||
name|cor_change
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 4 - 	 *	CR/NL processing 	 *	break processing 	 *	received exception processing 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNCR
condition|)
name|opt
operator||=
name|CD1400_COR4_IGNCR
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* 	 * we need a new ttyinput() for this, as we don't want to 	 * have ICRNL&& INLCR being done in both layers, or to have 	 * synchronisation problems 	 */
if|if
condition|(
name|iflag
operator|&
name|ICRNL
condition|)
name|opt
operator||=
name|CD1400_COR4_ICRNL
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|INLCR
condition|)
name|opt
operator||=
name|CD1400_COR4_INLCR
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
name|opt
operator||=
name|CD1400_COR4_IGNBRK
operator||
name|CD1400_COR4_NOBRKINT
expr_stmt|;
comment|/* 	 * The `-ignbrk -brkint parmrk' case is not handled by the hardware, 	 * so only tell the hardware about -brkint if -parmrk. 	 */
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
operator|(
name|BRKINT
operator||
name|PARMRK
operator|)
operator|)
condition|)
name|opt
operator||=
name|CD1400_COR4_NOBRKINT
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX using this "intelligence" breaks reporting of overruns. */
block|if (iflag& IGNPAR) 		opt |= CD1400_COR4_PFO_DISCARD; 	else { 		if (iflag& PARMRK) 			opt |= CD1400_COR4_PFO_ESC; 		else 			opt |= CD1400_COR4_PFO_NUL; 	}
else|#
directive|else
name|opt
operator||=
name|CD1400_COR4_PFO_EXCEPTION
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR4
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 5 - 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|opt
operator||=
name|CD1400_COR5_ISTRIP
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_iflag
operator|&
name|IEXTEN
condition|)
comment|/* enable LNEXT (e.g. ctrl-v quoting) handling */
name|opt
operator||=
name|CD1400_COR5_LNEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|ONLCR
condition|)
name|opt
operator||=
name|CD1400_COR5_ONLCR
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|OCRNL
condition|)
name|opt
operator||=
name|CD1400_COR5_OCRNL
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR5
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * We always generate modem status change interrupts for CD changes. 	 * Among other things, this is necessary to track TS_CARR_ON for 	 * pstat to print even when the driver doesn't care.  CD changes 	 * should be rare so interrupts for them are not worth extra code to 	 * avoid.  We avoid interrupts for other modem status changes (except 	 * for CTS changes when SOFT_CTS_OFLOW is configured) since this is 	 * simplest and best. 	 */
comment|/* 	 * set modem change option register 1 	 *	generate modem interrupts on which 1 -> 0 input transitions 	 *	also controls auto-DTR output flow-control, which we don't use 	 */
name|opt
operator|=
name|CD1400_MCOR1_CDzd
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_MCOR1_CTSzd
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MCOR1
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * set modem change option register 2 	 *	generate modem interrupts on specific 0 -> 1 input transitions 	 */
name|opt
operator|=
name|CD1400_MCOR2_CDod
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_MCOR2_CTSod
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MCOR2
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * XXX should have done this long ago, but there is too much state 	 * to change all atomically. 	 */
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_TTGO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
condition|)
name|com
operator|->
name|state
operator||=
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_RTS_IFLOW
expr_stmt|;
comment|/* 		 * If CS_RTS_IFLOW just changed from off to on, the change 		 * needs to be propagated to MCR_RTS.  This isn't urgent, 		 * so do it later by calling comstart() instead of repeating 		 * a lot of code from comstart() here. 		 */
block|}
elseif|else
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_RTS_IFLOW
expr_stmt|;
comment|/* 		 * CS_RTS_IFLOW just changed from on to off.  Force MCR_RTS 		 * on here, since comstart() won't do it later. 		 */
if|#
directive|if
literal|0
block|outb(com->modem_ctl_port, com->mcr_image |= MCR_RTS);
else|#
directive|else
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Set up state to handle output flow control. 	 * XXX - worth handling MDMBUF (DCD) flow control at the lowest level? 	 * Now has 10+ msec latency, while CTS flow has 50- usec latency. 	 */
name|com
operator|->
name|state
operator||=
name|CS_ODEVREADY
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CTS_OFLOW
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_CTS_OFLOW
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|last_modem_status
operator|&
name|MSR_CTS
operator|)
condition|)
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODEVREADY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XXX shouldn't call functions while intrs are disabled. */
name|disc_optim
argument_list|(
name|tp
argument_list|,
name|t
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Recover from fiddling with CS_TTGO.  We used to call siointr1() 	 * unconditionally, but that defeated the careful discarding of 	 * stale input in sioopen(). 	 */
block|if (com->state>= (CS_BUSY | CS_TTGO)) 		siointr1(com);
endif|#
directive|endif
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|comstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|ibufold
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|com
operator|->
name|ibufold
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|com
operator|->
name|ibufold
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siosetwater
parameter_list|(
name|com
parameter_list|,
name|speed
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|speed_t
name|speed
decl_stmt|;
block|{
name|int
name|cp4ticks
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
name|int
name|ibufsize
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
comment|/* 	 * Make the buffer size large enough to handle a softtty interrupt 	 * latency of about 2 ticks without loss of throughput or data 	 * (about 3 ticks if input flow control is not used or not honoured, 	 * but a bit less for CS5-CS7 modes). 	 */
name|cp4ticks
operator|=
name|speed
operator|/
literal|10
operator|/
name|hz
operator|*
literal|4
expr_stmt|;
for|for
control|(
name|ibufsize
operator|=
literal|128
init|;
name|ibufsize
operator|<
name|cp4ticks
condition|;
control|)
name|ibufsize
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ibufsize
operator|==
name|com
operator|->
name|ibufsize
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate input buffer.  The extra factor of 2 in the size is 	 * to allow for an error byte for each input byte. 	 */
name|ibuf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|ibufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibuf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Initialize non-critical variables. */
name|com
operator|->
name|ibufold
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
name|com
operator|->
name|ibufsize
operator|=
name|ibufsize
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_ififosize
operator|=
literal|2
operator|*
name|ibufsize
expr_stmt|;
name|tp
operator|->
name|t_ispeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|t_ospeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Read current input buffer, if any.  Continue with interrupts 	 * disabled. 	 */
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|iptr
operator|!=
name|com
operator|->
name|ibuf
condition|)
name|sioinput
argument_list|(
name|com
argument_list|,
operator|&
name|savecrit
argument_list|)
expr_stmt|;
comment|/*- 	 * Initialize critical variables, including input buffer watermarks. 	 * The external device is asked to stop sending when the buffer 	 * exactly reaches high water, or when the high level requests it. 	 * The high level is notified immediately (rather than at a later 	 * clock tick) when this watermark is reached. 	 * The buffer size is chosen so the watermark should almost never 	 * be reached. 	 * The low watermark is invisibly 0 since the buffer is always 	 * emptied all at once. 	 */
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
operator|=
name|ibuf
expr_stmt|;
name|com
operator|->
name|ibufend
operator|=
name|ibuf
operator|+
name|ibufsize
expr_stmt|;
name|com
operator|->
name|ierroff
operator|=
name|ibufsize
expr_stmt|;
name|com
operator|->
name|ihighwater
operator|=
name|ibuf
operator|+
literal|3
operator|*
name|ibufsize
operator|/
literal|4
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|comstart
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
name|bool_t
name|started
decl_stmt|;
endif|#
directive|endif
name|int
name|unit
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|unit
operator|=
name|DEV_TO_UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|com
operator|->
name|start_count
expr_stmt|;
name|started
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
condition|)
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|state
operator||=
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|mcr_image
operator|&
name|com
operator|->
name|mcr_rts
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image&= ~MCR_RTS);
else|#
directive|else
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|mcr_image
operator|&
name|com
operator|->
name|mcr_rts
operator|)
operator|&&
name|com
operator|->
name|iptr
operator|<
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image |= MCR_RTS);
else|#
directive|else
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|struct
name|lbq
modifier|*
name|qp
decl_stmt|;
name|struct
name|lbq
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|started
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obuf1
operator|+
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|com
operator|->
name|obuf1
argument_list|,
sizeof|sizeof
name|com
operator|->
name|obuf1
argument_list|)
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_next
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
operator|=
name|TRUE
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
condition|)
block|{
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|qp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|qp
operator|=
name|next
expr_stmt|;
name|qp
operator|->
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|0
index|]
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
operator|&&
operator|!
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|started
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obuf2
operator|+
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|com
operator|->
name|obuf2
argument_list|,
sizeof|sizeof
name|com
operator|->
name|obuf2
argument_list|)
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_next
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
operator|=
name|TRUE
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
condition|)
block|{
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|qp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|qp
operator|=
name|next
expr_stmt|;
name|qp
operator|->
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|1
index|]
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CyDebug
if|if
condition|(
name|started
condition|)
operator|++
name|com
operator|->
name|start_real
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|savecrit = critical_enter(); 	COM_LOCK(); 	if (com->state>= (CS_BUSY | CS_TTGO)) 		siointr1(com);
comment|/* fake interrupt to start output */
block|COM_UNLOCK(); 	critical_exit(savecrit);
endif|#
directive|endif
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|comstop
parameter_list|(
name|tp
parameter_list|,
name|rw
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|bool_t
name|wakeup_etc
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|DEV_TO_UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup_etc
operator|=
name|FALSE
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
operator|=
name|FALSE
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
condition|)
block|{
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator|&=
operator|~
name|CSE_ODONE
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|etc
operator|!=
name|ETC_NONE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDED
condition|)
name|com
operator|->
name|etc
operator|=
name|ETC_NONE
expr_stmt|;
name|wakeup_etc
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
condition|)
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
operator|(
name|CS_ODONE
operator||
name|CS_BUSY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
comment|/* XXX no way to reset only input fifo. */
name|com_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_etc
condition|)
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|etc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
operator|&&
name|com
operator|->
name|etc
operator|==
name|ETC_NONE
condition|)
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FTF
argument_list|)
expr_stmt|;
name|comstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|commctl
parameter_list|(
name|com
parameter_list|,
name|bits
parameter_list|,
name|how
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|how
decl_stmt|;
block|{
name|int
name|mcr
decl_stmt|;
name|int
name|msr
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
if|if
condition|(
name|how
operator|==
name|DMGET
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|channel_control
operator|&
name|CD1400_CCR_RCVEN
condition|)
name|bits
operator||=
name|TIOCM_LE
expr_stmt|;
name|mcr
operator|=
name|com
operator|->
name|mcr_image
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|com
operator|->
name|mcr_dtr
condition|)
name|bits
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|com
operator|->
name|mcr_rts
condition|)
comment|/* XXX wired on for Cyclom-8Ys */
name|bits
operator||=
name|TIOCM_RTS
expr_stmt|;
comment|/* 		 * We must read the modem status from the hardware because 		 * we don't generate modem status change interrupts for all 		 * changes, so com->prev_modem_status is not guaranteed to 		 * be up to date.  This is safe, unlike for sio, because 		 * reading the status register doesn't clear pending modem 		 * status change interrupts. 		 */
name|msr
operator|=
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_CTS
condition|)
name|bits
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_DCD
condition|)
name|bits
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_DSR
condition|)
name|bits
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_RI
condition|)
comment|/* XXX not connected except for Cyclom-16Y? */
name|bits
operator||=
name|TIOCM_RI
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
block|}
name|mcr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_DTR
condition|)
name|mcr
operator||=
name|com
operator|->
name|mcr_dtr
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_RTS
condition|)
name|mcr
operator||=
name|com
operator|->
name|mcr_rts
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|DMSET
case|:
name|com
operator|->
name|mcr_image
operator|=
name|mcr
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMBIS
case|:
name|com
operator|->
name|mcr_image
operator|=
name|mcr
operator|=
name|com
operator|->
name|mcr_image
operator||
name|mcr
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMBIC
case|:
name|com
operator|->
name|mcr_image
operator|=
name|mcr
operator|=
name|com
operator|->
name|mcr_image
operator|&
operator|~
name|mcr
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
break|break;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|siosettimeout
parameter_list|()
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|bool_t
name|someopen
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Set our timeout period to 1 second if no polled devices are open. 	 * Otherwise set it to max(1/200, 1/hz). 	 * Enable timeouts iff some device is open. 	 */
name|untimeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout_handle
argument_list|)
expr_stmt|;
name|sio_timeout
operator|=
name|hz
expr_stmt|;
name|someopen
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSIO
condition|;
operator|++
name|unit
control|)
block|{
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|someopen
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
literal|0
block|if (com->poll || com->poll_output) { 				sio_timeout = hz> 200 ? hz / 200 : 1; 				break; 			}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|someopen
condition|)
block|{
name|sio_timeouts_until_log
operator|=
name|hz
operator|/
name|sio_timeout
expr_stmt|;
name|sio_timeout_handle
operator|=
name|timeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Flush error messages, if any. */
name|sio_timeouts_until_log
operator|=
literal|1
expr_stmt|;
name|comwakeup
argument_list|(
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout_handle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|comwakeup
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|sio_timeout_handle
operator|=
name|timeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Recover from lost output interrupts. 	 * Poll any lines that don't use interrupts. 	 */
block|for (unit = 0; unit< NSIO; ++unit) { 		com = com_addr(unit); 		if (com != NULL&& (com->state>= (CS_BUSY | CS_TTGO) || com->poll)) { 			critical_t	savecrit;  			savecrit = critical_enter(); 			COM_LOCK(); 			siointr1(com); 			COM_UNLOCK(); 			critical_exit(savecrit); 		} 	}
endif|#
directive|endif
comment|/* 	 * Check for and log errors, but not too often. 	 */
if|if
condition|(
operator|--
name|sio_timeouts_until_log
operator|>
literal|0
condition|)
return|return;
name|sio_timeouts_until_log
operator|=
name|hz
operator|/
name|sio_timeout
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSIO
condition|;
operator|++
name|unit
control|)
block|{
name|int
name|errnum
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|errnum
operator|=
literal|0
init|;
name|errnum
operator|<
name|CE_NTYPES
condition|;
operator|++
name|errnum
control|)
block|{
name|u_int
name|delta
decl_stmt|;
name|u_long
name|total
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|delta
operator|=
name|com
operator|->
name|delta_error_counts
index|[
name|errnum
index|]
expr_stmt|;
name|com
operator|->
name|delta_error_counts
index|[
name|errnum
index|]
operator|=
literal|0
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
continue|continue;
name|total
operator|=
name|com
operator|->
name|error_counts
index|[
name|errnum
index|]
operator|+=
name|delta
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy%d: %u more %s%s (total %lu)\n"
argument_list|,
name|unit
argument_list|,
name|delta
argument_list|,
name|error_desc
index|[
name|errnum
index|]
argument_list|,
name|delta
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disc_optim
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|,
name|com
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
name|u_char
name|opt
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX can skip a lot more cases if Smarts.  Maybe 	 * (IGNCR | ISTRIP | IXON) in c_iflag.  But perhaps we 	 * shouldn't skip if (TS_CNTTB | TS_LNCH) is set in t_state. 	 */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
name|com
operator|->
name|hotchar
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_hotchar
expr_stmt|;
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
name|opt
operator|=
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|&
operator|~
name|CD1400_COR3_SCD34
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
condition|)
block|{
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR3
argument_list|,
name|com
operator|->
name|hotchar
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR4
argument_list|,
name|com
operator|->
name|hotchar
argument_list|)
expr_stmt|;
name|opt
operator||=
name|CD1400_COR3_SCD34
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR3
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDCORCHG
operator||
name|CD1400_CCR_COR3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|Smarts
end_ifdef

begin_comment
comment|/* standard line discipline input routine */
end_comment

begin_function
name|int
name|cyinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
name|int
name|c
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
comment|/* XXX duplicate ttyinput(), but without the IXOFF/IXON/ISTRIP/IPARMRK 	 * bits, as they are done by the CD1400.  Hardly worth the effort, 	 * given that high-throughput sessions are raw anyhow. 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Smarts */
end_comment

begin_function
specifier|static
name|int
name|comspeed
parameter_list|(
name|speed
parameter_list|,
name|cy_clock
parameter_list|,
name|prescaler_io
parameter_list|)
name|speed_t
name|speed
decl_stmt|;
name|u_long
name|cy_clock
decl_stmt|;
name|int
modifier|*
name|prescaler_io
decl_stmt|;
block|{
name|int
name|actual
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|divider
decl_stmt|;
name|int
name|prescaler
decl_stmt|;
name|int
name|prescaler_unit
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|speed
operator|<
literal|0
operator|||
name|speed
operator|>
literal|150000
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* determine which prescaler to use */
for|for
control|(
name|prescaler_unit
operator|=
literal|4
operator|,
name|prescaler
operator|=
literal|2048
init|;
name|prescaler_unit
condition|;
name|prescaler_unit
operator|--
operator|,
name|prescaler
operator|>>=
literal|2
control|)
block|{
if|if
condition|(
name|cy_clock
operator|/
name|prescaler
operator|/
name|speed
operator|>
literal|63
condition|)
break|break;
block|}
name|divider
operator|=
operator|(
name|cy_clock
operator|/
name|prescaler
operator|*
literal|2
operator|/
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* round off */
if|if
condition|(
name|divider
operator|>
literal|255
condition|)
name|divider
operator|=
literal|255
expr_stmt|;
name|actual
operator|=
name|cy_clock
operator|/
name|prescaler
operator|/
name|divider
expr_stmt|;
comment|/* 10 times error in percent: */
name|error
operator|=
operator|(
operator|(
name|actual
operator|-
operator|(
name|long
operator|)
name|speed
operator|)
operator|*
literal|2000
operator|/
operator|(
name|long
operator|)
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* 3.0% max error tolerance */
if|if
condition|(
name|error
operator|<
operator|-
literal|30
operator|||
name|error
operator|>
literal|30
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
literal|0
block|printf("prescaler = %d (%d)\n", prescaler, prescaler_unit); 	printf("divider = %d (%x)\n", divider, divider); 	printf("actual = %d\n", actual); 	printf("error = %d\n", error);
endif|#
directive|endif
operator|*
name|prescaler_io
operator|=
name|prescaler_unit
expr_stmt|;
return|return
operator|(
name|divider
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd1400_channel_cmd
parameter_list|(
name|com
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|cd1400_channel_cmd_wait
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_CCR
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd_wait
argument_list|(
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd1400_channel_cmd_wait
parameter_list|(
name|com
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
block|{
name|struct
name|timeval
name|start
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|usec
decl_stmt|;
if|if
condition|(
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_CCR
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|microtime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_CCR
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|usec
operator|=
literal|1000000
operator|*
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|start
operator|.
name|tv_sec
operator|)
operator|+
name|tv
operator|.
name|tv_usec
operator|-
name|start
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|usec
operator|>=
literal|5000
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy%d: channel command timeout (%ld usec)\n"
argument_list|,
name|com
operator|->
name|unit
argument_list|,
name|usec
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cd_etc
parameter_list|(
name|com
parameter_list|,
name|etc
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|etc
decl_stmt|;
block|{
name|critical_t
name|savecrit
decl_stmt|;
comment|/* 	 * We can't change the hardware's ETC state while there are any 	 * characters in the tx fifo, since those characters would be 	 * interpreted as commands!  Unputting characters from the fifo 	 * is difficult, so we wait up to 12 character times for the fifo 	 * to drain.  The command will be delayed for up to 2 character 	 * times for the tx to become empty.  Unputting characters from 	 * the tx holding and shift registers is impossible, so we wait 	 * for the tx to become empty so that the command is sure to be 	 * executed soon after we issue it. 	 */
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|etc
condition|)
goto|goto
name|wait
goto|;
if|if
condition|(
operator|(
name|etc
operator|==
name|CD1400_ETC_SENDBREAK
operator|&&
operator|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_STARTING
operator|||
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_STARTED
operator|)
operator|)
operator|||
operator|(
name|etc
operator|==
name|CD1400_ETC_STOPBREAK
operator|&&
operator|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDING
operator|||
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDED
operator|||
name|com
operator|->
name|etc
operator|==
name|ETC_NONE
operator|)
operator|)
condition|)
block|{
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
return|return;
block|}
name|com
operator|->
name|etc
operator|=
name|etc
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
name|wait
label|:
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
while|while
condition|(
name|com
operator|->
name|etc
operator|==
name|etc
operator|&&
name|tsleep
argument_list|(
operator|&
name|com
operator|->
name|etc
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cyetc"
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
end_function

begin_function
specifier|static
name|int
name|cd_getreg
parameter_list|(
name|com
parameter_list|,
name|reg
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|basecom
decl_stmt|;
name|u_char
name|car
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|register_t
name|eflags
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|val
decl_stmt|;
name|basecom
operator|=
name|com_addr
argument_list|(
name|com
operator|->
name|unit
operator|&
operator|~
operator|(
name|CD1400_NO_OF_CHANNELS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|car
operator|=
name|com
operator|->
name|unit
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|cy_align
operator|=
name|com
operator|->
name|cy_align
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|eflags
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|PSL_I
condition|)
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|basecom
operator|->
name|car
operator|!=
name|car
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|basecom
operator|->
name|car
operator|=
name|car
argument_list|)
expr_stmt|;
name|val
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|reg
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|PSL_I
condition|)
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd_setreg
parameter_list|(
name|com
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|basecom
decl_stmt|;
name|u_char
name|car
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|critical_t
name|savecrit
decl_stmt|;
name|register_t
name|eflags
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|basecom
operator|=
name|com_addr
argument_list|(
name|com
operator|->
name|unit
operator|&
operator|~
operator|(
name|CD1400_NO_OF_CHANNELS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|car
operator|=
name|com
operator|->
name|unit
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|cy_align
operator|=
name|com
operator|->
name|cy_align
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|eflags
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|savecrit
operator|=
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|PSL_I
condition|)
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|basecom
operator|->
name|car
operator|!=
name|car
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|basecom
operator|->
name|car
operator|=
name|car
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|reg
argument_list|,
name|cy_align
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|eflags
operator|&
name|PSL_I
condition|)
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|(
name|savecrit
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_comment
comment|/* useful in ddb */
end_comment

begin_function
name|void
name|cystatus
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|u_int
name|ocount
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info for channel %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total cyclom service probes:\t%d\n"
argument_list|,
name|cy_svrr_probes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to upper layer:\t\t%d\n"
argument_list|,
name|cy_timeouts
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
return|return;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cd1400 base address:\\tt%p\n"
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved channel_control:\t\t0x%02x\n"
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved cor1-3:\t\t\t0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|com
operator|->
name|cor
index|[
literal|0
index|]
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request enable reg:\t0x%02x (0x%02x cached)\n"
argument_list|,
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|)
argument_list|,
name|com
operator|->
name|intr_enable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request register:\t0x%02x\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SVRR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem status:\t\t\t0x%02x (0x%02x cached)\n"
argument_list|,
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|)
argument_list|,
name|com
operator|->
name|prev_modem_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx/tx/mdm interrupt registers:\t0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"com state:\t\t\t0x%02x\n"
argument_list|,
name|com
operator|->
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to comstart():\t\t%d (%d useful)\n"
argument_list|,
name|com
operator|->
name|start_count
argument_list|,
name|com
operator|->
name|start_real
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx buffer chars free:\t\t%d\n"
argument_list|,
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
argument_list|)
expr_stmt|;
name|ocount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
condition|)
name|ocount
operator|+=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
operator|-
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
condition|)
name|ocount
operator|+=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
operator|-
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
expr_stmt|;
name|printf
argument_list|(
literal|"tx buffer chars:\t\t%u\n"
argument_list|,
name|ocount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received chars:\t\t\t%d\n"
argument_list|,
name|com
operator|->
name|bytes_in
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received exceptions:\t\t%d\n"
argument_list|,
name|com
operator|->
name|recv_exception
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem signal deltas:\t\t%d\n"
argument_list|,
name|com
operator|->
name|mdm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"transmitted chars:\t\t%d\n"
argument_list|,
name|com
operator|->
name|bytes_out
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"tty state:\t\t\t0x%08x\n"
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"upper layer queue lengths:\t%d raw, %d canon, %d output\n"
argument_list|,
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"tty state:\t\t\tclosed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CyDebug */
end_comment

end_unit

