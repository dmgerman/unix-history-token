begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * cyclades cyclom-y serial driver  *	Andrew Herbert<andrew@werple.apana.org.au>, 17 August 1993  *  * Copyright (c) 1993 Andrew Herbert.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name Andrew Herbert may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: cy.c,v 1.59 1997/12/28 06:23:03 bde Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"cy.h"
end_include

begin_comment
comment|/*  * TODO:  * Implement BREAK.  * Fix overflows when closing line.  * Atomic COR change.  * Consoles.  */
end_comment

begin_comment
comment|/*  * Temporary compile-time configuration options.  */
end_comment

begin_define
define|#
directive|define
name|RxFifoThreshold
value|(CD1400_RX_FIFO_SIZE / 2)
end_define

begin_comment
comment|/* Number of chars in the receiver FIFO before an 			 * an interrupt is generated.  Should depend on 			 * line speed.  Needs to be about 6 on a 486DX33 			 * for 4 active ports at 115200 bps.  Why doesn't 			 * 10 work? 			 */
end_comment

begin_define
define|#
directive|define
name|PollMode
end_define

begin_comment
comment|/* Use polling-based irq service routine, not the 			 * hardware svcack lines.  Must be defined for 			 * Cyclom-16Y boards.  Less efficient for Cyclom-8Ys, 			 * and stops 4 * 115200 bps from working. 			 */
end_comment

begin_undef
undef|#
directive|undef
name|Smarts
end_undef

begin_comment
comment|/* Enable slightly more CD1400 intelligence.  Mainly 			 * the output CR/LF processing, plus we can avoid a 			 * few checks usually done in ttyinput(). 			 * 			 * XXX not fully implemented, and not particularly 			 * worthwhile. 			 */
end_comment

begin_undef
undef|#
directive|undef
name|CyDebug
end_undef

begin_comment
comment|/* Include debugging code (not very expensive). */
end_comment

begin_comment
comment|/* These will go away. */
end_comment

begin_undef
undef|#
directive|undef
name|SOFT_CTS_OFLOW
end_undef

begin_define
define|#
directive|define
name|SOFT_HOTCHAR
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/cyreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/cd1400.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_define
define|#
directive|define
name|disable_intr
parameter_list|()
value|COM_DISABLE_INTR()
end_define

begin_define
define|#
directive|define
name|enable_intr
parameter_list|()
value|COM_ENABLE_INTR()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_comment
comment|/*  * Dictionary so that I can name everything *sio* or *com* to compare with  * sio.c.  There is also lots of ugly formatting and unnecessary ifdefs to  * simplify the comparision.  These will go away.  */
end_comment

begin_define
define|#
directive|define
name|LSR_BI
value|CD1400_RDSR_BREAK
end_define

begin_define
define|#
directive|define
name|LSR_FE
value|CD1400_RDSR_FE
end_define

begin_define
define|#
directive|define
name|LSR_OE
value|CD1400_RDSR_OE
end_define

begin_define
define|#
directive|define
name|LSR_PE
value|CD1400_RDSR_PE
end_define

begin_define
define|#
directive|define
name|MCR_DTR
value|CD1400_MSVR2_DTR
end_define

begin_define
define|#
directive|define
name|MCR_RTS
value|CD1400_MSVR1_RTS
end_define

begin_define
define|#
directive|define
name|MSR_CTS
value|CD1400_MSVR2_CTS
end_define

begin_define
define|#
directive|define
name|MSR_DCD
value|CD1400_MSVR2_CD
end_define

begin_define
define|#
directive|define
name|MSR_DSR
value|CD1400_MSVR2_DSR
end_define

begin_define
define|#
directive|define
name|MSR_RI
value|CD1400_MSVR2_RI
end_define

begin_define
define|#
directive|define
name|NSIO
value|(NCY * CY_MAX_PORTS)
end_define

begin_define
define|#
directive|define
name|comconsole
value|cyconsole
end_define

begin_define
define|#
directive|define
name|comdefaultrate
value|cydefaultrate
end_define

begin_define
define|#
directive|define
name|com_events
value|cy_events
end_define

begin_define
define|#
directive|define
name|comhardclose
value|cyhardclose
end_define

begin_define
define|#
directive|define
name|commctl
value|cymctl
end_define

begin_define
define|#
directive|define
name|comparam
value|cyparam
end_define

begin_define
define|#
directive|define
name|comspeed
value|cyspeed
end_define

begin_define
define|#
directive|define
name|comstart
value|cystart
end_define

begin_define
define|#
directive|define
name|comwakeup
value|cywakeup
end_define

begin_define
define|#
directive|define
name|nsio_tty
value|ncy_tty
end_define

begin_define
define|#
directive|define
name|p_com_addr
value|p_cy_addr
end_define

begin_define
define|#
directive|define
name|sioattach
value|cyattach
end_define

begin_define
define|#
directive|define
name|sioclose
value|cyclose
end_define

begin_define
define|#
directive|define
name|siodevtotty
value|cydevtotty
end_define

begin_define
define|#
directive|define
name|siodriver
value|cydriver
end_define

begin_define
define|#
directive|define
name|siodtrwakeup
value|cydtrwakeup
end_define

begin_define
define|#
directive|define
name|sioioctl
value|cyioctl
end_define

begin_define
define|#
directive|define
name|siointr
value|cyintr
end_define

begin_define
define|#
directive|define
name|siointr1
value|cyintr1
end_define

begin_define
define|#
directive|define
name|sioopen
value|cyopen
end_define

begin_define
define|#
directive|define
name|siopoll
value|cypoll
end_define

begin_define
define|#
directive|define
name|sioprobe
value|cyprobe
end_define

begin_define
define|#
directive|define
name|sioread
value|cyread
end_define

begin_define
define|#
directive|define
name|siosettimeout
value|cysettimeout
end_define

begin_define
define|#
directive|define
name|siostop
value|cystop
end_define

begin_define
define|#
directive|define
name|siowrite
value|cywrite
end_define

begin_define
define|#
directive|define
name|sio_timeout
value|cy_timeout
end_define

begin_define
define|#
directive|define
name|sio_timeouts_until_log
value|cy_timeouts_until_log
end_define

begin_define
define|#
directive|define
name|sio_timeout_handle
value|cy_timeout_handle
end_define

begin_define
define|#
directive|define
name|sio_tty
value|cy_tty
end_define

begin_define
define|#
directive|define
name|CY_MAX_PORTS
value|(CD1400_NO_OF_CHANNELS * CY_MAX_CD1400s)
end_define

begin_comment
comment|/* We encode the cyclom unit number (cyu) in spare bits in the IVR's. */
end_comment

begin_define
define|#
directive|define
name|CD1400_xIVR_CHAN_SHIFT
value|3
end_define

begin_define
define|#
directive|define
name|CD1400_xIVR_CHAN
value|0x1F
end_define

begin_define
define|#
directive|define
name|LOTS_OF_EVENTS
value|64
end_define

begin_comment
comment|/* helps separate urgent events from input */
end_comment

begin_define
define|#
directive|define
name|RB_I_HIGH_WATER
value|(TTYHOG - 2 * RS_IBUFSIZE)
end_define

begin_define
define|#
directive|define
name|RS_IBUFSIZE
value|256
end_define

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|DEV_TO_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev)))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_UNIT
parameter_list|(
name|mynor
parameter_list|)
value|(((mynor)>> 16) * CY_MAX_PORTS \ 				 | (((mynor)& 0xff)& ~MINOR_MAGIC_MASK))
end_define

begin_comment
comment|/*  * Input buffer watermarks.  * The external device is asked to stop sending when the buffer exactly reaches  * high water, or when the high level requests it.  * The high level is notified immediately (rather than at a later clock tick)  * when this watermark is reached.  * The buffer size is chosen so the watermark should almost never be reached.  * The low watermark is invisibly 0 since the buffer is always emptied all at  * once.  */
end_comment

begin_define
define|#
directive|define
name|RS_IHIGHWATER
value|(3 * RS_IBUFSIZE / 4)
end_define

begin_comment
comment|/*  * com state bits.  * (CS_BUSY | CS_TTGO) and (CS_BUSY | CS_TTGO | CS_ODEVREADY) must be higher  * than the other bits so that they can be tested as a group without masking  * off the low bits.  *  * The following com and tty flags correspond closely:  *	CS_BUSY		= TS_BUSY (maintained by comstart(), siopoll() and  *				   siostop())  *	CS_TTGO		= ~TS_TTSTOP (maintained by comparam() and comstart())  *	CS_CTS_OFLOW	= CCTS_OFLOW (maintained by comparam())  *	CS_RTS_IFLOW	= CRTS_IFLOW (maintained by comparam())  * TS_FLUSH is not used.  * XXX I think TIOCSETA doesn't clear TS_TTSTOP when it clears IXON.  * XXX CS_*FLOW should be CF_*FLOW in com->flags (control flags not state).  */
end_comment

begin_define
define|#
directive|define
name|CS_BUSY
value|0x80
end_define

begin_comment
comment|/* output in progress */
end_comment

begin_define
define|#
directive|define
name|CS_TTGO
value|0x40
end_define

begin_comment
comment|/* output not stopped by XOFF */
end_comment

begin_define
define|#
directive|define
name|CS_ODEVREADY
value|0x20
end_define

begin_comment
comment|/* external device h/w ready (CTS) */
end_comment

begin_define
define|#
directive|define
name|CS_CHECKMSR
value|1
end_define

begin_comment
comment|/* check of MSR scheduled */
end_comment

begin_define
define|#
directive|define
name|CS_CTS_OFLOW
value|2
end_define

begin_comment
comment|/* use CTS output flow control */
end_comment

begin_define
define|#
directive|define
name|CS_DTR_OFF
value|0x10
end_define

begin_comment
comment|/* DTR held off */
end_comment

begin_define
define|#
directive|define
name|CS_ODONE
value|4
end_define

begin_comment
comment|/* output completed */
end_comment

begin_define
define|#
directive|define
name|CS_RTS_IFLOW
value|8
end_define

begin_comment
comment|/* use RTS input flow control */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|error_desc
index|[]
init|=
block|{
define|#
directive|define
name|CE_OVERRUN
value|0
literal|"silo overflow"
block|,
define|#
directive|define
name|CE_INTERRUPT_BUF_OVERFLOW
value|1
literal|"interrupt-level buffer overflow"
block|,
define|#
directive|define
name|CE_TTY_BUF_OVERFLOW
value|2
literal|"tty-level buffer overflow"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CE_NTYPES
value|3
end_define

begin_define
define|#
directive|define
name|CE_RECORD
parameter_list|(
name|com
parameter_list|,
name|errnum
parameter_list|)
value|(++(com)->delta_error_counts[errnum])
end_define

begin_comment
comment|/* types.  XXX - should be elsewhere */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_comment
comment|/* boolean */
end_comment

begin_typedef
typedef|typedef
name|u_char
specifier|volatile
modifier|*
name|cy_addr
typedef|;
end_typedef

begin_comment
comment|/* queue of linear buffers */
end_comment

begin_struct
struct|struct
name|lbq
block|{
name|u_char
modifier|*
name|l_head
decl_stmt|;
comment|/* next char to process */
name|u_char
modifier|*
name|l_tail
decl_stmt|;
comment|/* one past the last char to process */
name|struct
name|lbq
modifier|*
name|l_next
decl_stmt|;
comment|/* next in queue */
name|bool_t
name|l_queued
decl_stmt|;
comment|/* nonzero if queued */
block|}
struct|;
end_struct

begin_comment
comment|/* com device structure */
end_comment

begin_struct
struct|struct
name|com_s
block|{
name|u_char
name|state
decl_stmt|;
comment|/* miscellaneous flag bits */
name|bool_t
name|active_out
decl_stmt|;
comment|/* nonzero if the callout device is open */
if|#
directive|if
literal|0
block|u_char	cfcr_image;
comment|/* copy of value written to CFCR */
block|u_char	fifo_image;
comment|/* copy of value written to FIFO */
block|bool_t	hasfifo;
comment|/* nonzero for 16550 UARTs */
block|bool_t	loses_outints;
comment|/* nonzero if device loses output interrupts */
endif|#
directive|endif
name|u_char
name|mcr_image
decl_stmt|;
comment|/* copy of value written to MCR */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|COM_MULTIPORT
block|bool_t	multiport;
comment|/* is this unit part of a multiport device? */
endif|#
directive|endif
comment|/* COM_MULTIPORT */
block|bool_t	no_irq;
comment|/* nonzero if irq is not attached */
block|bool_t	poll;
comment|/* nonzero if polling is required */
block|bool_t	poll_output;
comment|/* nonzero if polling for output is required */
endif|#
directive|endif
name|int
name|unit
decl_stmt|;
comment|/* unit	number */
name|int
name|dtr_wait
decl_stmt|;
comment|/* time to hold DTR down on close (* 1/hz) */
if|#
directive|if
literal|0
block|u_int	tx_fifo_size;
endif|#
directive|endif
name|u_int
name|wopeners
decl_stmt|;
comment|/* # processes waiting for DCD in open() */
comment|/* 	 * The high level of the driver never reads status registers directly 	 * because there would be too many side effects to handle conveniently. 	 * Instead, it reads copies of the registers stored here by the 	 * interrupt handler. 	 */
name|u_char
name|last_modem_status
decl_stmt|;
comment|/* last MSR read by intr handler */
name|u_char
name|prev_modem_status
decl_stmt|;
comment|/* last MSR handled by high level */
name|u_char
name|hotchar
decl_stmt|;
comment|/* ldisc-specific char to be handled ASAP */
name|u_char
modifier|*
name|ibuf
decl_stmt|;
comment|/* start of input buffer */
name|u_char
modifier|*
name|ibufend
decl_stmt|;
comment|/* end of input buffer */
name|u_char
modifier|*
name|ihighwater
decl_stmt|;
comment|/* threshold in input buffer */
name|u_char
modifier|*
name|iptr
decl_stmt|;
comment|/* next free spot in input buffer */
name|struct
name|lbq
name|obufq
decl_stmt|;
comment|/* head of queue of output buffers */
name|struct
name|lbq
name|obufs
index|[
literal|2
index|]
decl_stmt|;
comment|/* output buffers */
name|int
name|cy_align
decl_stmt|;
comment|/* index for register alignment */
name|cy_addr
name|cy_iobase
decl_stmt|;
comment|/* base address of this port's cyclom */
name|cy_addr
name|iobase
decl_stmt|;
comment|/* base address of this port's cd1400 */
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* cross reference */
comment|/* Initial state. */
name|struct
name|termios
name|it_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|it_out
decl_stmt|;
comment|/* Lock state. */
name|struct
name|termios
name|lt_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|lt_out
decl_stmt|;
name|bool_t
name|do_timestamp
decl_stmt|;
name|bool_t
name|do_dcd_timestamp
decl_stmt|;
name|struct
name|timeval
name|timestamp
decl_stmt|;
name|struct
name|timeval
name|dcd_timestamp
decl_stmt|;
name|u_long
name|bytes_in
decl_stmt|;
comment|/* statistics */
name|u_long
name|bytes_out
decl_stmt|;
name|u_int
name|delta_error_counts
index|[
name|CE_NTYPES
index|]
decl_stmt|;
name|u_long
name|error_counts
index|[
name|CE_NTYPES
index|]
decl_stmt|;
name|u_int
name|recv_exception
decl_stmt|;
comment|/* exception chars received */
name|u_int
name|mdm
decl_stmt|;
comment|/* modem signal changes */
ifdef|#
directive|ifdef
name|CyDebug
name|u_int
name|start_count
decl_stmt|;
comment|/* no. of calls to comstart() */
name|u_int
name|start_real
decl_stmt|;
comment|/* no. of calls that did something */
endif|#
directive|endif
name|u_char
name|channel_control
decl_stmt|;
comment|/* CD1400 CCR control command shadow */
name|u_char
name|cor
index|[
literal|3
index|]
decl_stmt|;
comment|/* CD1400 COR1-3 shadows */
name|u_char
name|intr_enable
decl_stmt|;
comment|/* CD1400 SRER shadow */
comment|/* 	 * Ping-pong input buffers.  The extra factor of 2 in the sizes is 	 * to allow for an error byte for each input byte. 	 */
define|#
directive|define
name|CE_INPUT_OFFSET
value|RS_IBUFSIZE
name|u_char
name|ibuf1
index|[
literal|2
operator|*
name|RS_IBUFSIZE
index|]
decl_stmt|;
name|u_char
name|ibuf2
index|[
literal|2
operator|*
name|RS_IBUFSIZE
index|]
decl_stmt|;
comment|/* 	 * Data area for output buffers.  Someday we should build the output 	 * buffer queue without copying data. 	 */
name|u_char
name|obuf1
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|obuf2
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token_ttyd
decl_stmt|;
name|void
modifier|*
name|devfs_token_ttyl
decl_stmt|;
name|void
modifier|*
name|devfs_token_ttyi
decl_stmt|;
name|void
modifier|*
name|devfs_token_cuaa
decl_stmt|;
name|void
modifier|*
name|devfs_token_cual
decl_stmt|;
name|void
modifier|*
name|devfs_token_cuai
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * XXX public functions in drivers should be declared in headers produced  * by `config', not here.  */
end_comment

begin_comment
comment|/* Interrupt handling entry point. */
end_comment

begin_decl_stmt
name|void
name|siopoll
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device switch entry points. */
end_comment

begin_define
define|#
directive|define
name|sioreset
value|noreset
end_define

begin_define
define|#
directive|define
name|siommap
value|nommap
end_define

begin_define
define|#
directive|define
name|siostrategy
value|nostrategy
end_define

begin_comment
comment|/* PCI driver entry point. */
end_comment

begin_decl_stmt
name|int
name|cyattach_common
name|__P
argument_list|(
operator|(
name|cy_addr
name|cy_iobase
operator|,
name|int
name|cy_align
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_units
name|__P
argument_list|(
operator|(
name|cy_addr
name|cy_iobase
operator|,
name|int
name|cy_align
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sioattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cd1400_channel_cmd
name|__P
argument_list|(
operator|(
name|cy_addr
name|iobase
operator|,
name|int
name|cmd
operator|,
name|int
name|cy_align
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|siodtrwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|comhardclose
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static	void	siointr1	__P((struct com_s *com));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|commctl
name|__P
argument_list|(
operator|(
expr|struct
name|com_s
operator|*
name|com
operator|,
name|int
name|bits
operator|,
name|int
name|how
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sioprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|siosettimeout
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comspeed
name|__P
argument_list|(
operator|(
name|speed_t
name|speed
operator|,
name|int
operator|*
name|prescaler_io
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|comstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|comwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disc_optim
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|,
expr|struct
name|com_s
operator|*
name|com
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_decl_stmt
name|void
name|cystatus
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|driver_name
index|[]
init|=
literal|"cy"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table and macro for fast conversion from a unit number to its com struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|com_s
modifier|*
name|p_com_addr
index|[
name|NSIO
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|com_addr
parameter_list|(
name|unit
parameter_list|)
value|(p_com_addr[unit])
end_define

begin_decl_stmt
name|struct
name|isa_driver
name|siodriver
init|=
block|{
name|sioprobe
block|,
name|sioattach
block|,
name|driver_name
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|sioopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sioclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|sioread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|siowrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sioioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_stop_t
name|siostop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|siodevtotty
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|48
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sio_cdevsw
init|=
block|{
name|sioopen
block|,
name|sioclose
block|,
name|sioread
block|,
name|siowrite
block|,
name|sioioctl
block|,
name|siostop
block|,
name|noreset
block|,
name|siodevtotty
block|,
name|ttpoll
block|,
name|nommap
block|,
name|NULL
block|,
name|driver_name
block|,
name|NULL
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|comconsole
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|speed_t
name|comdefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|com_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input chars + weighted output completions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sio_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sio_timeouts_until_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|sio_timeout_handle
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|sio_timeout_handle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX */
end_comment

begin_else
unit|static struct tty	*sio_tty[NSIO];
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|tty
name|sio_tty
index|[
name|NSIO
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|int
name|nsio_tty
init|=
name|NSIO
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|cd_inbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_inbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cd_outbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_outbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_svrr_probes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_timeouts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|cy_chip_offset
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0400
block|,
literal|0x0800
block|,
literal|0x0c00
block|,
literal|0x0200
block|,
literal|0x0600
block|,
literal|0x0a00
block|,
literal|0x0e00
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_nr_cd1400s
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_total_devices
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|RxFifoThreshold
end_undef

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|RxFifoThreshold
init|=
operator|(
name|CD1400_RX_FIFO_SIZE
operator|/
literal|2
operator|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sioprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|cy_addr
name|iobase
decl_stmt|;
name|iobase
operator|=
operator|(
name|cy_addr
operator|)
name|dev
operator|->
name|id_maddr
expr_stmt|;
comment|/* Cyclom-16Y hardware reset (Cyclom-8Ys don't care) */
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CY16_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX? */
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* wait for the board to get its act together */
comment|/* this is needed to get the board out of reset */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
return|return
operator|(
name|cy_units
argument_list|(
name|iobase
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cy_units
parameter_list|(
name|cy_iobase
parameter_list|,
name|cy_align
parameter_list|)
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
block|{
name|int
name|cyu
decl_stmt|;
name|u_char
name|firmware_version
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|CY_MAX_CD1400s
condition|;
operator|++
name|cyu
control|)
block|{
name|iobase
operator|=
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
expr_stmt|;
comment|/* wait for chip to become ready for new command */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|)
condition|)
break|break;
block|}
comment|/* clear the GFRCR register */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* issue a reset command */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FULLRESET
argument_list|)
expr_stmt|;
comment|/* wait for the CD1400 to initialize itself */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* retrieve firmware version */
name|firmware_version
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|firmware_version
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
break|break;
block|}
comment|/* 		 * Anything in the 0x40-0x4F range is fine. 		 * If one CD1400 is bad then we don't support higher 		 * numbered good ones on this board. 		 */
if|if
condition|(
operator|(
name|firmware_version
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x40
condition|)
break|break;
block|}
return|return
operator|(
name|cyu
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioattach
parameter_list|(
name|isdp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
block|{
name|int
name|adapter
decl_stmt|;
name|adapter
operator|=
name|cyattach_common
argument_list|(
operator|(
name|cy_addr
operator|)
name|isdp
operator|->
name|id_maddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX 	 * This kludge is to allow ISA/PCI device specifications in the 	 * kernel config file to be in any order. 	 */
if|if
condition|(
name|isdp
operator|->
name|id_unit
operator|!=
name|adapter
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: attached as cy%d\n"
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|isdp
operator|->
name|id_unit
operator|=
name|adapter
expr_stmt|;
comment|/* XXX */
block|}
name|isdp
operator|->
name|id_ri_flags
operator||=
name|RI_FAST
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cyattach_common
parameter_list|(
name|cy_iobase
parameter_list|,
name|cy_align
parameter_list|)
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
block|{
name|int
name|adapter
decl_stmt|;
name|int
name|cyu
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|ncyu
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|adapter
operator|=
name|cy_total_devices
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|adapter
operator|>=
name|NCY
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: can't attach adapter: insufficient cy devices configured\n"
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ncyu
operator|=
name|cy_units
argument_list|(
name|cy_iobase
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncyu
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cy_nr_cd1400s
index|[
name|adapter
index|]
operator|=
name|ncyu
expr_stmt|;
name|cy_total_devices
operator|++
expr_stmt|;
name|unit
operator|=
name|adapter
operator|*
name|CY_MAX_PORTS
expr_stmt|;
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|ncyu
condition|;
operator|++
name|cyu
control|)
block|{
name|int
name|cdu
decl_stmt|;
name|iobase
operator|=
call|(
name|cy_addr
call|)
argument_list|(
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
argument_list|)
expr_stmt|;
comment|/* Set up a receive timeout period of than 1+ ms. */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_PPR
argument_list|,
name|cy_align
argument_list|,
name|howmany
argument_list|(
name|CY_CLOCK
operator|/
name|CD1400_PPR_PRESCALER
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cdu
operator|=
literal|0
init|;
name|cdu
operator|<
name|CD1400_NO_OF_CHANNELS
condition|;
operator|++
name|cdu
operator|,
operator|++
name|unit
control|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
name|com
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|com
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
break|break;
name|bzero
argument_list|(
name|com
argument_list|,
sizeof|sizeof
expr|*
name|com
argument_list|)
expr_stmt|;
name|com
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|com
operator|->
name|dtr_wait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
operator|=
name|com
operator|->
name|ibuf1
expr_stmt|;
name|com
operator|->
name|ibufend
operator|=
name|com
operator|->
name|ibuf1
operator|+
name|RS_IBUFSIZE
expr_stmt|;
name|com
operator|->
name|ihighwater
operator|=
name|com
operator|->
name|ibuf1
operator|+
name|RS_IHIGHWATER
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
operator|=
name|com
operator|->
name|obuf1
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
operator|=
name|com
operator|->
name|obuf2
expr_stmt|;
name|com
operator|->
name|cy_align
operator|=
name|cy_align
expr_stmt|;
name|com
operator|->
name|cy_iobase
operator|=
name|cy_iobase
expr_stmt|;
name|com
operator|->
name|iobase
operator|=
name|iobase
expr_stmt|;
comment|/* 	 * We don't use all the flags from<sys/ttydefaults.h> since they 	 * are only relevant for logins.  It's important to have echo off 	 * initially so that the line doesn't start blathering before the 	 * echo flag can be turned off. 	 */
name|com
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|comconsole
condition|)
block|{
name|com
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
operator||
name|CLOCAL
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|com
operator|->
name|lt_out
operator|.
name|c_cflag
operator|=
name|com
operator|->
name|lt_in
operator|.
name|c_cflag
operator|=
name|CLOCAL
expr_stmt|;
block|}
name|termioschars
argument_list|(
operator|&
name|com
operator|->
name|it_in
argument_list|)
expr_stmt|;
name|com
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|com
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|comdefaultrate
expr_stmt|;
name|com
operator|->
name|it_out
operator|=
name|com
operator|->
name|it_in
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|com_addr
argument_list|(
name|unit
argument_list|)
operator|=
name|com
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|sio_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|com
operator|->
name|devfs_token_ttyd
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|unit
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyc%n%n"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|com
operator|->
name|devfs_token_ttyi
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|unit
operator||
name|CONTROL_INIT_STATE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyic%n%n"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|com
operator|->
name|devfs_token_ttyl
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|unit
operator||
name|CONTROL_LOCK_STATE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttylc%n%n"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|com
operator|->
name|devfs_token_cuaa
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|unit
operator||
name|CALLOUT_MASK
argument_list|,
name|DV_CHR
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuac%n%n"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|com
operator|->
name|devfs_token_cuai
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|unit
operator||
name|CALLOUT_MASK
operator||
name|CONTROL_INIT_STATE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuaic%n%n"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
name|com
operator|->
name|devfs_token_cual
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sio_cdevsw
argument_list|,
name|unit
operator||
name|CALLOUT_MASK
operator||
name|CONTROL_LOCK_STATE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cualc%n%n"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* ensure an edge for the next interrupt */
name|cd_outb
argument_list|(
name|cy_iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|adapter
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|unit
operator|>=
name|NSIO
operator|||
operator|(
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
comment|/* XXX */
block|tp = com->tp = sio_tty[unit] = ttymalloc(sio_tty[unit]);
else|#
directive|else
name|tp
operator|=
name|com
operator|->
name|tp
operator|=
operator|&
name|sio_tty
index|[
name|unit
index|]
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * We jump to this label after all non-interrupted sleeps to pick 	 * up any changes of the device state. 	 */
name|open_top
label|:
while|while
condition|(
name|com
operator|->
name|state
operator|&
name|CS_DTR_OFF
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|com
operator|->
name|dtr_wait
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cydtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * The device is open, so everything has been initialized. 		 * Handle conflicts. 		 */
if|if
condition|(
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
block|{
if|if
condition|(
operator|!
name|com
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|com
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cybi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it.  Initialization is done twice in many 		 * cases: to preempt sleeping callin opens if we are 		 * callout, and to complete a callin open after DCD rises. 		 */
name|tp
operator|->
name|t_oproc
operator|=
name|comstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|comparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
name|com
operator|->
name|it_out
else|:
name|com
operator|->
name|it_in
expr_stmt|;
if|#
directive|if
literal|0
block|(void)commctl(com, TIOCM_DTR | TIOCM_RTS, DMSET); 		com->poll = com->no_irq; 		com->poll_output = com->loses_outints;
endif|#
directive|endif
operator|++
name|com
operator|->
name|wopeners
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
comment|/* reset this channel */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR_CMDRESET
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
comment|/* 		 * Resetting disables the transmitter and receiver as well as 		 * flushing the fifos so some of our cached state becomes 		 * invalid.  The documentation suggests that all registers 		 * for the current channel are reset to defaults, but 		 * apparently none are.  We wouldn't want DTR cleared. 		 */
name|com
operator|->
name|channel_control
operator|=
literal|0
expr_stmt|;
comment|/* Encode per-board unit in LIVR for access in intr routines. */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_LIVR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
operator|(
name|unit
operator|&
name|CD1400_xIVR_CHAN
operator|)
operator|<<
name|CD1400_xIVR_CHAN_SHIFT
argument_list|)
expr_stmt|;
comment|/* 		 * raise dtr and generally set things up correctly.  this 		 * has the side-effect of selecting the appropriate cd1400 		 * channel, to help us with subsequent channel control stuff 		 */
name|error
operator|=
name|comparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|--
name|com
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * XXX we should goto open_top if comparam() slept. 		 */
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (com->hasfifo) {
comment|/* 			 * (Re)enable and drain fifos. 			 * 			 * Certain SMC chips cause problems if the fifos 			 * are enabled while input is ready.  Turn off the 			 * fifo if necessary to clear the input.  We test 			 * the input ready bit after enabling the fifos 			 * since we've already enabled them in comparam() 			 * and to handle races between enabling and fresh 			 * input. 			 */
block|while (TRUE) { 				outb(iobase + com_fifo, 				     FIFO_RCV_RST | FIFO_XMT_RST 				     | com->fifo_image); 				DELAY(100); 				if (!(inb(com->line_status_port)& LSR_RXRDY)) 					break; 				outb(iobase + com_fifo, 0); 				DELAY(100); 				(void) inb(com->data_port); 			} 		}  		disable_intr(); 		(void) inb(com->line_status_port); 		(void) inb(com->data_port); 		com->prev_modem_status = com->last_modem_status 		    = inb(com->modem_status_port); 		outb(iobase + com_ier, IER_ERXRDY | IER_ETXRDY | IER_ERLS 				       | IER_EMSC); 		enable_intr();
else|#
directive|else
comment|/* !0 */
comment|/* XXX raise RTS too */
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|com
operator|->
name|prev_modem_status
operator|=
name|com
operator|->
name|last_modem_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|CD1400_SRER_MDMCH
operator||
name|CD1400_SRER_RXDATA
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 0 */
comment|/* 		 * Handle initial DCD.  Callout devices get a fake initial 		 * DCD (trapdoor DCD).  If we are callout, then any sleeping 		 * callin opens get woken up and resume sleeping on "cybi" 		 * instead of "cydcd". 		 */
comment|/* 		 * XXX `mynor& CALLOUT_MASK' should be 		 * `tp->t_cflag& (SOFT_CARRIER | TRAPDOOR_CARRIER) where 		 * TRAPDOOR_CARRIER is the default initial state for callout 		 * devices and SOFT_CARRIER is like CLOCAL except it hides 		 * the true carrier. 		 */
if|if
condition|(
name|com
operator|->
name|prev_modem_status
operator|&
name|MSR_DCD
operator|||
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
block|}
comment|/* 	 * Wait for DCD if necessary. 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
operator|++
name|com
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cydcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|com
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|com
operator|->
name|active_out
operator|=
name|TRUE
expr_stmt|;
name|siosettimeout
argument_list|()
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|com
operator|->
name|wopeners
operator|==
literal|0
condition|)
name|comhardclose
argument_list|(
name|com
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|com
operator|=
name|com_addr
argument_list|(
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|com
argument_list|)
expr_stmt|;
name|siostop
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|comhardclose
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|siosettimeout
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|broken
comment|/* session holds a ref to the tty; can't deallocate */
name|ttyfree
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|com
operator|->
name|tp
operator|=
name|sio_tty
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|comhardclose
parameter_list|(
name|com
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
block|{
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|com
operator|->
name|unit
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|com->poll = FALSE; 	com->poll_output = FALSE;
endif|#
directive|endif
name|com
operator|->
name|do_timestamp
operator|=
literal|0
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|outb(iobase + com_cfcr, com->cfcr_image&= ~CFCR_SBREAK);
endif|#
directive|endif
block|{
if|#
directive|if
literal|0
block|outb(iobase + com_ier, 0);
else|#
directive|else
name|disable_intr
argument_list|()
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
literal|0
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
comment|/* 		     * XXX we will miss any carrier drop between here and the 		     * next open.  Perhaps we should watch DCD even when the 		     * port is closed; it is not sufficient to check it at 		     * the next open because it might go up and down while 		     * we're not watching. 		     */
operator|||
operator|!
name|com
operator|->
name|active_out
operator|&&
operator|!
operator|(
name|com
operator|->
name|prev_modem_status
operator|&
name|MSR_DCD
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|it_in
operator|.
name|c_cflag
operator|&
name|CLOCAL
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
comment|/* Disable receiver (leave transmitter enabled). */
name|com
operator|->
name|channel_control
operator|=
name|CD1400_CCR_CMDCHANCTL
operator||
name|CD1400_CCR_XMTEN
operator||
name|CD1400_CCR_RCVDIS
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|iobase
argument_list|,
name|com
operator|->
name|channel_control
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|dtr_wait
operator|!=
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|siodtrwakeup
argument_list|,
name|com
argument_list|,
name|com
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_DTR_OFF
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
block|if (com->hasfifo) {
comment|/* 		 * Disable fifos so that they are off after controlled 		 * reboots.  Some BIOSes fail to detect 16550s when the 		 * fifos are enabled. 		 */
block|outb(iobase + com_fifo, 0); 	}
endif|#
directive|endif
name|com
operator|->
name|active_out
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restart any wopeners */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sioread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|tp
operator|=
name|com_addr
argument_list|(
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
argument_list|)
operator|->
name|tp
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siowrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
operator|->
name|tp
expr_stmt|;
comment|/* 	 * (XXX) We disallow virtual consoles if the physical console is 	 * a serial port.  This is in case there is a display attached that 	 * is not the console.  In that situation we don't need/want the X 	 * server taking over the console. 	 */
if|if
condition|(
name|constty
operator|!=
name|NULL
operator|&&
name|unit
operator|==
name|comconsole
condition|)
name|constty
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* XXX duplicate ttwrite(), but without so much output processing on 	 * CR& LF chars.  Hardly worth the effort, given that high-throughput 	 * sessions are raw anyhow. 	 */
else|#
directive|else
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|siodtrwakeup
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|com
operator|=
operator|(
expr|struct
name|com_s
operator|*
operator|)
name|chan
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_DTR_OFF
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|siointr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|baseu
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cyu
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
comment|/* XXX could this be placed down lower in the loop? */
name|baseu
operator|=
name|unit
operator|*
name|CY_MAX_PORTS
expr_stmt|;
name|cy_align
operator|=
name|com_addr
argument_list|(
name|baseu
argument_list|)
operator|->
name|cy_align
expr_stmt|;
name|cy_iobase
operator|=
name|com_addr
argument_list|(
name|baseu
argument_list|)
operator|->
name|cy_iobase
expr_stmt|;
comment|/* check each CD1400 in turn */
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|cy_nr_cd1400s
index|[
name|unit
index|]
condition|;
operator|++
name|cyu
control|)
block|{
name|iobase
operator|=
call|(
name|cy_addr
call|)
argument_list|(
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
argument_list|)
expr_stmt|;
comment|/* poll to see if it has any work */
name|status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SVRR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|cy_svrr_probes
expr_stmt|;
endif|#
directive|endif
comment|/* service requests as appropriate, giving priority to RX */
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_RXRDY
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_char
modifier|*
name|ioptr
decl_stmt|;
name|u_char
name|line_status
decl_stmt|;
name|u_char
name|recv_data
decl_stmt|;
name|u_char
name|serv_type
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_car
decl_stmt|;
name|u_char
name|save_rir
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_rir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|save_car
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter rx service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_rir
argument_list|)
expr_stmt|;
name|serv_type
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIVR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|serv_type
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack receive service */
name|serv_type
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKR
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|+
operator|(
operator|(
name|serv_type
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|serv_type
operator|&
name|CD1400_RIVR_EXCEPTION
condition|)
block|{
operator|++
name|com
operator|->
name|recv_exception
expr_stmt|;
name|line_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* break/unnattached error bits or real input? */
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_SPECIAL
operator|&&
name|com
operator|->
name|hotchar
operator|!=
literal|0
condition|)
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* XXX "intelligent" PFO error handling would break O error handling */
if|if
condition|(
name|line_status
operator|&
operator|(
name|LSR_PE
operator||
name|LSR_FE
operator||
name|LSR_BI
operator|)
condition|)
block|{
comment|/* 				  Don't store PE if IGNPAR and BI if IGNBRK, 				  this hack allows "raw" tty optimization 				  works even if IGN* is set. 				*/
if|if
condition|(
name|com
operator|->
name|tp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|(
name|line_status
operator|&
operator|(
name|LSR_PE
operator||
name|LSR_FE
operator|)
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|IGNPAR
operator|)
operator|||
operator|(
name|line_status
operator|&
name|LSR_BI
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|IGNBRK
operator|)
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
operator|(
name|line_status
operator|&
operator|(
name|LSR_PE
operator||
name|LSR_FE
operator|)
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
operator|&&
operator|(
operator|(
name|line_status
operator|&
name|LSR_FE
operator|)
operator|||
operator|(
name|line_status
operator|&
name|LSR_PE
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|)
condition|)
name|recv_data
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 1 */
operator|++
name|com
operator|->
name|bytes_in
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ioptr
operator|=
name|com
operator|->
name|iptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|>=
name|com
operator|->
name|ibufend
condition|)
name|CE_RECORD
argument_list|(
name|com
argument_list|,
name|CE_INTERRUPT_BUF_OVERFLOW
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|com
operator|->
name|do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|timestamp
argument_list|)
expr_stmt|;
operator|++
name|com_events
expr_stmt|;
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|CE_INPUT_OFFSET
index|]
operator|=
name|line_status
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
operator|++
name|ioptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|==
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, 					     com->mcr_image&= ~MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|MCR_RTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|line_status
operator|&
name|LSR_OE
condition|)
name|CE_RECORD
argument_list|(
name|com
argument_list|,
name|CE_OVERRUN
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cont
goto|;
block|}
else|else
block|{
name|int
name|ifree
decl_stmt|;
name|count
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|->
name|bytes_in
operator|+=
name|count
expr_stmt|;
name|ioptr
operator|=
name|com
operator|->
name|iptr
expr_stmt|;
name|ifree
operator|=
name|com
operator|->
name|ibufend
operator|-
name|ioptr
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|ifree
condition|)
block|{
name|count
operator|-=
name|ifree
expr_stmt|;
name|com_events
operator|+=
name|ifree
expr_stmt|;
if|if
condition|(
name|ifree
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|timestamp
argument_list|)
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|CE_INPUT_OFFSET
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|ioptr
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ifree
operator|!=
literal|0
condition|)
do|;
block|}
name|com
operator|->
name|delta_error_counts
index|[
name|CE_INTERRUPT_BUF_OVERFLOW
index|]
operator|+=
name|count
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioptr
operator|<=
name|com
operator|->
name|ihighwater
operator|&&
name|ioptr
operator|+
name|count
operator|>
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, 					     com->mcr_image&= ~MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|MCR_RTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|com_events
operator|+=
name|count
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|hotchar
condition|)
name|setsofttty
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|CE_INPUT_OFFSET
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|ioptr
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
name|com
operator|->
name|iptr
operator|=
name|ioptr
expr_stmt|;
block|}
name|cont
label|:
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|cy_align
argument_list|,
name|save_rir
operator|&
operator|~
operator|(
name|CD1400_RIR_RDIREQ
operator||
name|CD1400_RIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_car
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_MDMCH
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
name|modem_status
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_car
decl_stmt|;
name|u_char
name|save_mir
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_mir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|save_car
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter modem service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_mir
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_mir
operator|&
name|CD1400_MIR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack modem service */
name|vector
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKM
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|vector
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|com
operator|->
name|mdm
expr_stmt|;
name|modem_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|modem_status
operator|!=
name|com
operator|->
name|last_modem_status
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|do_dcd_timestamp
operator|&&
operator|!
operator|(
name|com
operator|->
name|last_modem_status
operator|&
name|MSR_DCD
operator|)
operator|&&
name|modem_status
operator|&
name|MSR_DCD
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|dcd_timestamp
argument_list|)
expr_stmt|;
comment|/* 			 * Schedule high level to handle DCD changes.  Note 			 * that we don't use the delta bits anywhere.  Some 			 * UARTs mess them up, and it's easy to remember the 			 * previous bits and calculate the delta. 			 */
name|com
operator|->
name|last_modem_status
operator|=
name|modem_status
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
operator|)
condition|)
block|{
name|com_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_CHECKMSR
expr_stmt|;
name|setsofttty
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
comment|/* handle CTS change immediately for crisp flow ctl */
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CTS_OFLOW
condition|)
block|{
if|if
condition|(
name|modem_status
operator|&
name|MSR_CTS
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_ODEVREADY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator||=
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODEVREADY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|&=
operator|~
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|cy_align
argument_list|,
name|save_mir
operator|&
operator|~
operator|(
name|CD1400_MIR_RDIREQ
operator||
name|CD1400_MIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_car
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_TXRDY
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_car
decl_stmt|;
name|u_char
name|save_tir
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_tir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|save_car
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter tx service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_tir
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_tir
operator|&
name|CD1400_TIR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack transmit service */
name|vector
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKT
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|vector
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
block|{
name|u_char
modifier|*
name|ioptr
decl_stmt|;
name|u_int
name|ocount
decl_stmt|;
name|ioptr
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_head
expr_stmt|;
name|ocount
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|-
name|ioptr
expr_stmt|;
if|if
condition|(
name|ocount
operator|>
name|CD1400_TX_FIFO_SIZE
condition|)
name|ocount
operator|=
name|CD1400_TX_FIFO_SIZE
expr_stmt|;
name|com
operator|->
name|bytes_out
operator|+=
name|ocount
expr_stmt|;
do|do
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
operator|*
name|ioptr
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|ocount
operator|!=
literal|0
condition|)
do|;
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|ioptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|>=
name|com
operator|->
name|obufq
operator|.
name|l_tail
condition|)
block|{
name|struct
name|lbq
modifier|*
name|qp
decl_stmt|;
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
name|qp
operator|->
name|l_queued
operator|=
name|FALSE
expr_stmt|;
name|qp
operator|=
name|qp
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|qp
operator|!=
name|NULL
condition|)
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|qp
operator|->
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|qp
operator|->
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
name|qp
expr_stmt|;
block|}
else|else
block|{
comment|/* output just completed */
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_BUSY
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|&=
operator|~
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
operator|)
condition|)
block|{
name|com_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_ODONE
expr_stmt|;
comment|/* handle at high level ASAP */
name|setsofttty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|cy_align
argument_list|,
name|save_tir
operator|&
operator|~
operator|(
name|CD1400_TIR_RDIREQ
operator||
name|CD1400_TIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_car
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* ensure an edge for the next interrupt */
name|cd_outb
argument_list|(
name|cy_iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|schedsofttty
argument_list|()
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void siointr1(com) 	struct com_s	*com; { }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sioioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|int
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
argument_list|)
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|com
operator|->
name|it_out
else|:
operator|&
name|com
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|com
operator|->
name|lt_out
else|:
operator|&
name|com
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|com
operator|->
name|lt_out
else|:
operator|&
name|com
operator|->
name|lt_in
decl_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
if|#
directive|if
literal|0
block|case TIOCSBRK: 		outb(iobase + com_cfcr, com->cfcr_image |= CFCR_SBREAK); 		break; 	case TIOCCBRK: 		outb(iobase + com_cfcr, com->cfcr_image&= ~CFCR_SBREAK); 		break;
endif|#
directive|endif
comment|/* 0 */
case|case
name|TIOCSDTR
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * XXX should disallow changing MCR_RTS if CS_RTS_IFLOW is set.  The 	 * changes get undone on the next call to comparam(). 	 */
case|case
name|TIOCMSET
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|commctl
argument_list|(
name|com
argument_list|,
literal|0
argument_list|,
name|DMGET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
comment|/* must be root since the wait applies to following logins */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|com
operator|->
name|dtr_wait
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|com
operator|->
name|dtr_wait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|TIOCTIMESTAMP
case|:
name|com
operator|->
name|do_timestamp
operator|=
name|TRUE
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|com
operator|->
name|timestamp
expr_stmt|;
break|break;
case|case
name|TIOCDCDTIMESTAMP
case|:
name|com
operator|->
name|do_dcd_timestamp
operator|=
name|TRUE
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|com
operator|->
name|dcd_timestamp
expr_stmt|;
break|break;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|siopoll
parameter_list|()
block|{
name|int
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|cy_timeouts
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|com_events
operator|==
literal|0
condition|)
return|return;
name|repeat
label|:
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSIO
condition|;
operator|++
name|unit
control|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|incc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
continue|continue;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * XXX forget any events related to closed devices 			 * (actually never opened devices) so that we don't 			 * loop. 			 */
name|disable_intr
argument_list|()
expr_stmt|;
name|incc
operator|=
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
condition|)
block|{
name|incc
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CHECKMSR
expr_stmt|;
block|}
name|com_events
operator|-=
name|incc
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|incc
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sio%d: %d events for device with no tp\n"
argument_list|,
name|unit
argument_list|,
name|incc
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* switch the role of the low-level input buffers */
if|if
condition|(
name|com
operator|->
name|iptr
operator|==
operator|(
name|ibuf
operator|=
name|com
operator|->
name|ibuf
operator|)
condition|)
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
comment|/* not used, but compiler can't tell */
name|incc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|ibuf
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|incc
operator|=
name|com
operator|->
name|iptr
operator|-
name|buf
expr_stmt|;
name|com_events
operator|-=
name|incc
expr_stmt|;
if|if
condition|(
name|ibuf
operator|==
name|com
operator|->
name|ibuf1
condition|)
name|ibuf
operator|=
name|com
operator|->
name|ibuf2
expr_stmt|;
else|else
name|ibuf
operator|=
name|com
operator|->
name|ibuf1
expr_stmt|;
name|com
operator|->
name|ibufend
operator|=
name|ibuf
operator|+
name|RS_IBUFSIZE
expr_stmt|;
name|com
operator|->
name|ihighwater
operator|=
name|ibuf
operator|+
name|RS_IHIGHWATER
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|ibuf
expr_stmt|;
comment|/* 			 * There is now room for another low-level buffer full 			 * of input, so enable RTS if it is now disabled and 			 * there is room in the high-level buffer. 			 */
if|if
condition|(
operator|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|mcr_image
operator|&
name|MCR_RTS
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, 				     com->mcr_image |= MCR_RTS);
else|#
directive|else
name|iobase
operator|=
name|com
operator|->
name|iobase
operator|,
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
operator|,
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|MCR_RTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|enable_intr
argument_list|()
expr_stmt|;
name|com
operator|->
name|ibuf
operator|=
name|ibuf
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
condition|)
block|{
name|u_char
name|delta_modem_status
decl_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|delta_modem_status
operator|=
name|com
operator|->
name|last_modem_status
operator|^
name|com
operator|->
name|prev_modem_status
expr_stmt|;
name|com
operator|->
name|prev_modem_status
operator|=
name|com
operator|->
name|last_modem_status
expr_stmt|;
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CHECKMSR
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|delta_modem_status
operator|&
name|MSR_DCD
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
name|com
operator|->
name|prev_modem_status
operator|&
name|MSR_DCD
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
condition|)
block|{
name|disable_intr
argument_list|()
expr_stmt|;
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODONE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
operator|)
condition|)
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|incc
operator|<=
literal|0
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
continue|continue;
comment|/* 		 * Avoid the grotesquely inefficient lineswitch routine 		 * (ttyinput) in "raw" mode.  It usually takes about 450 		 * instructions (that's without canonical processing or echo!). 		 * slinput is reasonably fast (usually 40 instructions plus 		 * call overhead). 		 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|incc
operator|>=
name|RB_I_HIGH_WATER
operator|&&
operator|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
operator|||
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tk_nin
operator|+=
name|incc
expr_stmt|;
name|tk_rawcc
operator|+=
name|incc
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|incc
expr_stmt|;
name|com
operator|->
name|delta_error_counts
index|[
name|CE_TTY_BUF_OVERFLOW
index|]
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|incc
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|comstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
do|do
block|{
name|u_char
name|line_status
decl_stmt|;
name|int
name|recv_data
decl_stmt|;
name|line_status
operator|=
operator|(
name|u_char
operator|)
name|buf
index|[
name|CE_INPUT_OFFSET
index|]
expr_stmt|;
name|recv_data
operator|=
operator|(
name|u_char
operator|)
operator|*
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
operator|(
name|LSR_BI
operator||
name|LSR_FE
operator||
name|LSR_OE
operator||
name|LSR_PE
operator|)
condition|)
block|{
if|if
condition|(
name|line_status
operator|&
name|LSR_BI
condition|)
name|recv_data
operator||=
name|TTY_BI
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|LSR_FE
condition|)
name|recv_data
operator||=
name|TTY_FE
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|LSR_OE
condition|)
name|recv_data
operator||=
name|TTY_OE
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|LSR_PE
condition|)
name|recv_data
operator||=
name|TTY_PE
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|recv_data
operator|,
name|tp
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|incc
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|com_events
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|com_events
operator|>=
name|LOTS_OF_EVENTS
condition|)
goto|goto
name|repeat
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|comparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|bits
decl_stmt|;
name|int
name|cflag
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
name|cor_change
decl_stmt|;
name|int
name|idivisor
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|iprescaler
decl_stmt|;
name|int
name|itimeout
decl_stmt|;
name|int
name|odivisor
decl_stmt|;
name|int
name|oprescaler
decl_stmt|;
name|u_char
name|opt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* do historical conversions */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
comment|/* check requested parameters */
name|idivisor
operator|=
name|comspeed
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
operator|&
name|iprescaler
argument_list|)
expr_stmt|;
if|if
condition|(
name|idivisor
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|odivisor
operator|=
name|comspeed
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
operator|&
name|oprescaler
argument_list|)
expr_stmt|;
if|if
condition|(
name|odivisor
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* parameters are OK, convert them to the com struct and the device */
name|unit
operator|=
name|DEV_TO_UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|odivisor
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
comment|/* hang up line */
else|else
operator|(
name|void
operator|)
name|commctl
argument_list|(
name|com
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
if|if
condition|(
name|idivisor
operator|!=
literal|0
condition|)
block|{
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RBPR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|idivisor
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RCOR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|iprescaler
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|odivisor
operator|!=
literal|0
condition|)
block|{
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TBPR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|odivisor
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TCOR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|oprescaler
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * channel control 	 *	receiver enable 	 *	transmitter enable (always set) 	 */
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|opt
operator|=
name|CD1400_CCR_CMDCHANCTL
operator||
name|CD1400_CCR_XMTEN
operator||
operator|(
name|cflag
operator|&
name|CREAD
condition|?
name|CD1400_CCR_RCVEN
else|:
name|CD1400_CCR_RCVDIS
operator|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|channel_control
condition|)
block|{
name|com
operator|->
name|channel_control
operator|=
name|opt
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|iobase
argument_list|,
name|opt
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Smarts
comment|/* set special chars */
comment|/* XXX if one is _POSIX_VDISABLE, can't use some others */
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SCHR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SCHR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SCHR3
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SCHR4
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * set channel option register 1 - 	 *	parity mode 	 *	stop bits 	 *	char length 	 */
name|opt
operator|=
literal|0
expr_stmt|;
comment|/* parity */
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|opt
operator||=
name|CD1400_COR1_PARODD
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_PARNORMAL
expr_stmt|;
block|}
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
name|INPCK
operator|)
condition|)
name|opt
operator||=
name|CD1400_COR1_NOINPCK
expr_stmt|;
name|bits
operator|=
literal|1
operator|+
literal|1
expr_stmt|;
comment|/* stop bits */
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
block|{
operator|++
name|bits
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_STOP2
expr_stmt|;
block|}
comment|/* char length */
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|bits
operator|+=
literal|5
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|bits
operator|+=
literal|6
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|bits
operator|+=
literal|7
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS7
expr_stmt|;
break|break;
default|default:
name|bits
operator|+=
literal|8
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS8
expr_stmt|;
break|break;
block|}
name|cor_change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|0
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR1
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|0
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set receive time-out period, normally to max(one char time, 5 ms). 	 */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|itimeout
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RTPR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
else|else
block|{
name|itimeout
operator|=
operator|(
literal|1000
operator|*
name|bits
operator|+
name|t
operator|->
name|c_ispeed
operator|-
literal|1
operator|)
operator|/
name|t
operator|->
name|c_ispeed
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
define|#
directive|define
name|MIN_RTP
value|1
else|#
directive|else
define|#
directive|define
name|MIN_RTP
value|5
endif|#
directive|endif
if|if
condition|(
name|itimeout
operator|<
name|MIN_RTP
condition|)
name|itimeout
operator|=
name|MIN_RTP
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
operator|)
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|!=
literal|0
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|!=
literal|0
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
operator|>
name|itimeout
condition|)
name|itimeout
operator|=
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|itimeout
operator|>
literal|255
condition|)
name|itimeout
operator|=
literal|255
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RTPR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|itimeout
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 2 - 	 *	flow control 	 */
name|opt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|opt
operator||=
name|CD1400_COR2_IXANY
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|opt
operator||=
name|CD1400_COR2_IXOFF
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_COR2_CCTS_OFLOW
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|1
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR2
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * set channel option register 3 - 	 *	receiver FIFO interrupt threshold 	 *	flow control 	 */
name|opt
operator|=
name|RxFifoThreshold
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
condition|)
name|opt
operator||=
name|CD1400_COR3_SCD34
expr_stmt|;
comment|/* detect INTR& SUSP chars */
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
comment|/* detect and transparently handle START and STOP chars */
name|opt
operator||=
name|CD1400_COR3_FCT
operator||
name|CD1400_COR3_SCD12
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR3
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR3
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* notify the CD1400 if COR1-3 have changed */
if|if
condition|(
name|cor_change
condition|)
name|cd1400_channel_cmd
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR_CMDCORCHG
operator||
name|cor_change
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 4 - 	 *	CR/NL processing 	 *	break processing 	 *	received exception processing 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNCR
condition|)
name|opt
operator||=
name|CD1400_COR4_IGNCR
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* 	 * we need a new ttyinput() for this, as we don't want to 	 * have ICRNL&& INLCR being done in both layers, or to have 	 * synchronisation problems 	 */
if|if
condition|(
name|iflag
operator|&
name|ICRNL
condition|)
name|opt
operator||=
name|CD1400_COR4_ICRNL
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|INLCR
condition|)
name|opt
operator||=
name|CD1400_COR4_INLCR
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
name|opt
operator||=
name|CD1400_COR4_IGNBRK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
name|BRKINT
operator|)
condition|)
name|opt
operator||=
name|CD1400_COR4_NOBRKINT
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX using this "intelligence" breaks reporting of overruns. */
block|if (iflag& IGNPAR) 		opt |= CD1400_COR4_PFO_DISCARD; 	else { 		if (iflag& PARMRK) 			opt |= CD1400_COR4_PFO_ESC; 		else 			opt |= CD1400_COR4_PFO_NUL; 	}
else|#
directive|else
name|opt
operator||=
name|CD1400_COR4_PFO_EXCEPTION
expr_stmt|;
endif|#
directive|endif
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR4
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 5 - 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|opt
operator||=
name|CD1400_COR5_ISTRIP
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_iflag
operator|&
name|IEXTEN
condition|)
comment|/* enable LNEXT (e.g. ctrl-v quoting) handling */
name|opt
operator||=
name|CD1400_COR5_LNEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|ONLCR
condition|)
name|opt
operator||=
name|CD1400_COR5_ONLCR
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|OCRNL
condition|)
name|opt
operator||=
name|CD1400_COR5_OCRNL
expr_stmt|;
endif|#
directive|endif
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR5
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * We always generate modem status change interrupts for CD changes. 	 * Among other things, this is necessary to track TS_CARR_ON for 	 * pstat to print even when the driver doesn't care.  CD changes 	 * should be rare so interrupts for them are not worth extra code to 	 * avoid.  We avoid interrupts for other modem status changes (except 	 * for CTS changes when SOFT_CTS_OFLOW is configured) since this is 	 * simplest and best. 	 */
comment|/* 	 * set modem change option register 1 	 *	generate modem interrupts on which 1 -> 0 input transitions 	 *	also controls auto-DTR output flow-control, which we don't use 	 */
name|opt
operator|=
name|CD1400_MCOR1_CDzd
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_MCOR1_CTSzd
expr_stmt|;
endif|#
directive|endif
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MCOR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * set modem change option register 2 	 *	generate modem interrupts on specific 0 -> 1 input transitions 	 */
name|opt
operator|=
name|CD1400_MCOR2_CDod
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_MCOR2_CTSod
expr_stmt|;
endif|#
directive|endif
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MCOR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * XXX should have done this long ago, but there is too much state 	 * to change all atomically. 	 */
name|disable_intr
argument_list|()
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_TTGO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
condition|)
name|com
operator|->
name|state
operator||=
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_RTS_IFLOW
expr_stmt|;
comment|/* 		 * If CS_RTS_IFLOW just changed from off to on, the change 		 * needs to be propagated to MCR_RTS.  This isn't urgent, 		 * so do it later by calling comstart() instead of repeating 		 * a lot of code from comstart() here. 		 */
block|}
elseif|else
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_RTS_IFLOW
expr_stmt|;
comment|/* 		 * CS_RTS_IFLOW just changed from on to off.  Force MCR_RTS 		 * on here, since comstart() won't do it later. 		 */
if|#
directive|if
literal|0
block|outb(com->modem_ctl_port, com->mcr_image |= MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|MCR_RTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Set up state to handle output flow control. 	 * XXX - worth handling MDMBUF (DCD) flow control at the lowest level? 	 * Now has 10+ msec latency, while CTS flow has 50- usec latency. 	 */
name|com
operator|->
name|state
operator||=
name|CS_ODEVREADY
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CTS_OFLOW
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_CTS_OFLOW
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|last_modem_status
operator|&
name|MSR_CTS
operator|)
condition|)
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODEVREADY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XXX shouldn't call functions while intrs are disabled. */
name|disc_optim
argument_list|(
name|tp
argument_list|,
name|t
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Recover from fiddling with CS_TTGO.  We used to call siointr1() 	 * unconditionally, but that defeated the careful discarding of 	 * stale input in sioopen(). 	 */
block|if (com->state>= (CS_BUSY | CS_TTGO)) 		siointr1(com);
endif|#
directive|endif
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator||=
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|&=
operator|~
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|enable_intr
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|comstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|comstart
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
name|bool_t
name|started
decl_stmt|;
endif|#
directive|endif
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|DEV_TO_UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|com
operator|->
name|start_count
expr_stmt|;
name|started
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|disable_intr
argument_list|()
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
condition|)
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|&=
operator|~
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|state
operator||=
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator||=
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|mcr_image
operator|&
name|MCR_RTS
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image&= ~MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|MCR_RTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|mcr_image
operator|&
name|MCR_RTS
operator|)
operator|&&
name|com
operator|->
name|iptr
operator|<
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image |= MCR_RTS);
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|MCR_RTS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|struct
name|lbq
modifier|*
name|qp
decl_stmt|;
name|struct
name|lbq
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|started
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obuf1
operator|+
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|com
operator|->
name|obuf1
argument_list|,
sizeof|sizeof
name|com
operator|->
name|obuf1
argument_list|)
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_next
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
operator|=
name|TRUE
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
condition|)
block|{
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|qp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|qp
operator|=
name|next
expr_stmt|;
name|qp
operator|->
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|0
index|]
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator||=
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|enable_intr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
operator|&&
operator|!
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|started
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obuf2
operator|+
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|com
operator|->
name|obuf2
argument_list|,
sizeof|sizeof
name|com
operator|->
name|obuf2
argument_list|)
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_next
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
operator|=
name|TRUE
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
condition|)
block|{
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|qp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|qp
operator|=
name|next
expr_stmt|;
name|qp
operator|->
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|1
index|]
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator||=
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|enable_intr
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CyDebug
if|if
condition|(
name|started
condition|)
operator|++
name|com
operator|->
name|start_real
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|disable_intr(); 	if (com->state>= (CS_BUSY | CS_TTGO)) 		siointr1(com);
comment|/* fake interrupt to start output */
block|enable_intr();
endif|#
directive|endif
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|siostop
parameter_list|(
name|tp
parameter_list|,
name|rw
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|DEV_TO_UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
operator|=
name|FALSE
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
condition|)
name|com_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
operator|(
name|CS_ODONE
operator||
name|CS_BUSY
operator|)
expr_stmt|;
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
name|com_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
block|}
name|enable_intr
argument_list|()
expr_stmt|;
name|comstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* XXX should clear h/w fifos too. */
block|}
end_function

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|siodevtotty
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|unit
operator|>=
name|NSIO
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|sio_tty
index|[
name|unit
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|commctl
parameter_list|(
name|com
parameter_list|,
name|bits
parameter_list|,
name|how
parameter_list|)
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|how
decl_stmt|;
block|{
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|mcr
decl_stmt|;
name|int
name|msr
decl_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|DMGET
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|channel_control
operator|&
name|CD1400_CCR_RCVEN
condition|)
name|bits
operator||=
name|TIOCM_LE
expr_stmt|;
name|mcr
operator|=
name|com
operator|->
name|mcr_image
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|MCR_DTR
condition|)
name|bits
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|MCR_RTS
condition|)
comment|/* XXX wired on for Cyclom-8Ys */
name|bits
operator||=
name|TIOCM_RTS
expr_stmt|;
comment|/* 		 * We must read the modem status from the hardware because 		 * we don't generate modem status change interrupts for all 		 * changes, so com->prev_modem_status is not guaranteed to 		 * be up to date.  This is safe, unlike for sio, because 		 * reading the status register doesn't clear pending modem 		 * status change interrupts. 		 */
name|msr
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_CTS
condition|)
name|bits
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_DCD
condition|)
name|bits
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_DSR
condition|)
name|bits
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|MSR_RI
condition|)
comment|/* XXX not connected except for Cyclom-16Y? */
name|bits
operator||=
name|TIOCM_RI
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
block|}
name|mcr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_DTR
condition|)
name|mcr
operator||=
name|MCR_DTR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_RTS
condition|)
name|mcr
operator||=
name|MCR_RTS
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|DMSET
case|:
name|com
operator|->
name|mcr_image
operator|=
name|mcr
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMBIS
case|:
name|com
operator|->
name|mcr_image
operator|=
name|mcr
operator|=
name|com
operator|->
name|mcr_image
operator||
name|mcr
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMBIC
case|:
name|com
operator|->
name|mcr_image
operator|=
name|mcr
operator|=
name|com
operator|->
name|mcr_image
operator|&
operator|~
name|mcr
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
break|break;
block|}
name|enable_intr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|siosettimeout
parameter_list|()
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|bool_t
name|someopen
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Set our timeout period to 1 second if no polled devices are open. 	 * Otherwise set it to max(1/200, 1/hz). 	 * Enable timeouts iff some device is open. 	 */
name|untimeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout_handle
argument_list|)
expr_stmt|;
name|sio_timeout
operator|=
name|hz
expr_stmt|;
name|someopen
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSIO
condition|;
operator|++
name|unit
control|)
block|{
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|someopen
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
literal|0
block|if (com->poll || com->poll_output) { 				sio_timeout = hz> 200 ? hz / 200 : 1; 				break; 			}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|someopen
condition|)
block|{
name|sio_timeouts_until_log
operator|=
name|hz
operator|/
name|sio_timeout
expr_stmt|;
name|sio_timeout_handle
operator|=
name|timeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Flush error messages, if any. */
name|sio_timeouts_until_log
operator|=
literal|1
expr_stmt|;
name|comwakeup
argument_list|(
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout_handle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|comwakeup
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|sio_timeout_handle
operator|=
name|timeout
argument_list|(
name|comwakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|sio_timeout
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Recover from lost output interrupts. 	 * Poll any lines that don't use interrupts. 	 */
block|for (unit = 0; unit< NSIO; ++unit) { 		com = com_addr(unit); 		if (com != NULL&& (com->state>= (CS_BUSY | CS_TTGO) || com->poll)) { 			disable_intr(); 			siointr1(com); 			enable_intr(); 		} 	}
endif|#
directive|endif
comment|/* 	 * Check for and log errors, but not too often. 	 */
if|if
condition|(
operator|--
name|sio_timeouts_until_log
operator|>
literal|0
condition|)
return|return;
name|sio_timeouts_until_log
operator|=
name|hz
operator|/
name|sio_timeout
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSIO
condition|;
operator|++
name|unit
control|)
block|{
name|int
name|errnum
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|errnum
operator|=
literal|0
init|;
name|errnum
operator|<
name|CE_NTYPES
condition|;
operator|++
name|errnum
control|)
block|{
name|u_int
name|delta
decl_stmt|;
name|u_long
name|total
decl_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|delta
operator|=
name|com
operator|->
name|delta_error_counts
index|[
name|errnum
index|]
expr_stmt|;
name|com
operator|->
name|delta_error_counts
index|[
name|errnum
index|]
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
continue|continue;
name|total
operator|=
name|com
operator|->
name|error_counts
index|[
name|errnum
index|]
operator|+=
name|delta
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy%d: %u more %s%s (total %lu)\n"
argument_list|,
name|unit
argument_list|,
name|delta
argument_list|,
name|error_desc
index|[
name|errnum
index|]
argument_list|,
name|delta
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disc_optim
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|,
name|com
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
name|cy_addr
name|iobase
decl_stmt|;
name|u_char
name|opt
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX can skip a lot more cases if Smarts.  Maybe 	 * (IGNCR | ISTRIP | IXON) in c_iflag.  But perhaps we 	 * shouldn't skip if (TS_CNTTB | TS_LNCH) is set in t_state. 	 */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
comment|/* 	 * Prepare to reduce input latency for packet 	 * discplines with a end of packet character. 	 */
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|SLIPDISC
condition|)
name|com
operator|->
name|hotchar
operator|=
literal|0xc0
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|PPPDISC
condition|)
name|com
operator|->
name|hotchar
operator|=
literal|0x7e
expr_stmt|;
else|else
name|com
operator|->
name|hotchar
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
name|opt
operator|=
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|&
operator|~
name|CD1400_COR3_SCD34
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|hotchar
operator|!=
literal|0
condition|)
block|{
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SCHR3
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|hotchar
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SCHR4
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|hotchar
argument_list|)
expr_stmt|;
name|opt
operator||=
name|CD1400_COR3_SCD34
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR3
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
operator|->
name|iobase
argument_list|,
name|CD1400_CCR_CMDCORCHG
operator||
name|CD1400_CCR_COR3
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|Smarts
end_ifdef

begin_comment
comment|/* standard line discipline input routine */
end_comment

begin_function
name|int
name|cyinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
name|int
name|c
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
comment|/* XXX duplicate ttyinput(), but without the IXOFF/IXON/ISTRIP/IPARMRK 	 * bits, as they are done by the CD1400.  Hardly worth the effort, 	 * given that high-throughput sessions are raw anyhow. 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Smarts */
end_comment

begin_function
specifier|static
name|int
name|comspeed
parameter_list|(
name|speed
parameter_list|,
name|prescaler_io
parameter_list|)
name|speed_t
name|speed
decl_stmt|;
name|int
modifier|*
name|prescaler_io
decl_stmt|;
block|{
name|int
name|actual
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|divider
decl_stmt|;
name|int
name|prescaler
decl_stmt|;
name|int
name|prescaler_unit
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|speed
operator|<
literal|0
operator|||
name|speed
operator|>
literal|150000
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* determine which prescaler to use */
for|for
control|(
name|prescaler_unit
operator|=
literal|4
operator|,
name|prescaler
operator|=
literal|2048
init|;
name|prescaler_unit
condition|;
name|prescaler_unit
operator|--
operator|,
name|prescaler
operator|>>=
literal|2
control|)
block|{
if|if
condition|(
name|CY_CLOCK
operator|/
name|prescaler
operator|/
name|speed
operator|>
literal|63
condition|)
break|break;
block|}
name|divider
operator|=
operator|(
name|CY_CLOCK
operator|/
name|prescaler
operator|*
literal|2
operator|/
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* round off */
if|if
condition|(
name|divider
operator|>
literal|255
condition|)
name|divider
operator|=
literal|255
expr_stmt|;
name|actual
operator|=
name|CY_CLOCK
operator|/
name|prescaler
operator|/
name|divider
expr_stmt|;
name|error
operator|=
operator|(
operator|(
name|actual
operator|-
name|speed
operator|)
operator|*
literal|2000
operator|/
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* percentage */
comment|/* 3.0% max error tolerance */
if|if
condition|(
name|error
operator|<
operator|-
literal|30
operator|||
name|error
operator|>
literal|30
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|#
directive|if
literal|0
block|printf("prescaler = %d (%d)\n", prescaler, prescaler_unit); 	printf("divider = %d (%x)\n", divider, divider); 	printf("actual = %d\n", actual); 	printf("error = %d\n", error);
endif|#
directive|endif
operator|*
name|prescaler_io
operator|=
name|prescaler_unit
expr_stmt|;
return|return
operator|(
name|divider
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd1400_channel_cmd
parameter_list|(
name|iobase
parameter_list|,
name|cmd
parameter_list|,
name|cy_align
parameter_list|)
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
block|{
comment|/* XXX hsu@clinet.fi: This is always more dependent on ISA bus speed, 	   as the card is probed every round?  Replaced delaycount with 8k. 	   Either delaycount has to be implemented in FreeBSD or more sensible 	   way of doing these should be implemented.  DELAY isn't enough here. 	   */
name|u_int
name|maxwait
init|=
literal|5
operator|*
literal|8
operator|*
literal|1024
decl_stmt|;
comment|/* approx. 5 ms */
comment|/* wait for processing of previous command to complete */
while|while
condition|(
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|)
operator|&&
name|maxwait
operator|--
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|maxwait
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy: channel command timeout (%d loops) - arrgh\n"
argument_list|,
literal|5
operator|*
literal|8
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_comment
comment|/* useful in ddb */
end_comment

begin_function
name|void
name|cystatus
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|u_int
name|ocount
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|com
operator|=
name|com_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info for channel %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total cyclom service probes:\t%d\n"
argument_list|,
name|cy_svrr_probes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to upper layer:\t\t%d\n"
argument_list|,
name|cy_timeouts
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
return|return;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cd1400 base address:\\tt%p\n"
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|,
name|unit
operator|&
name|CD1400_CAR_CHAN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved channel_control:\t\t0x%02x\n"
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved cor1-3:\t\t\t0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|com
operator|->
name|cor
index|[
literal|0
index|]
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request enable reg:\t0x%02x (0x%02x cached)\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|com
operator|->
name|intr_enable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request register:\t0x%02x\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SVRR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem status:\t\t\t0x%02x (0x%02x cached)\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|com
operator|->
name|prev_modem_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx/tx/mdm interrupt registers:\t0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"com state:\t\t\t0x%02x\n"
argument_list|,
name|com
operator|->
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to comstart():\t\t%d (%d useful)\n"
argument_list|,
name|com
operator|->
name|start_count
argument_list|,
name|com
operator|->
name|start_real
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx buffer chars free:\t\t%d\n"
argument_list|,
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
argument_list|)
expr_stmt|;
name|ocount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
condition|)
name|ocount
operator|+=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
operator|-
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
condition|)
name|ocount
operator|+=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
operator|-
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
expr_stmt|;
name|printf
argument_list|(
literal|"tx buffer chars:\t\t%u\n"
argument_list|,
name|ocount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received chars:\t\t\t%d\n"
argument_list|,
name|com
operator|->
name|bytes_in
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received exceptions:\t\t%d\n"
argument_list|,
name|com
operator|->
name|recv_exception
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem signal deltas:\t\t%d\n"
argument_list|,
name|com
operator|->
name|mdm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"transmitted chars:\t\t%d\n"
argument_list|,
name|com
operator|->
name|bytes_out
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"tty state:\t\t\t0x%08x\n"
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"upper layer queue lengths:\t%d raw, %d canon, %d output\n"
argument_list|,
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"tty state:\t\t\tclosed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CyDebug */
end_comment

end_unit

