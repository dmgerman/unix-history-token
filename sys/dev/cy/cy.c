begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * cyclades cyclom-y serial driver  *	Andrew Herbert<andrew@werple.apana.org.au>, 17 August 1993  *  * Copyright (c) 1993 Andrew Herbert.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name Andrew Herbert may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_comment
comment|/*  * TODO:  * Atomic COR change.  * Consoles.  */
end_comment

begin_comment
comment|/*  * Temporary compile-time configuration options.  */
end_comment

begin_define
define|#
directive|define
name|RxFifoThreshold
value|(CD1400_RX_FIFO_SIZE / 2)
end_define

begin_comment
comment|/* Number of chars in the receiver FIFO before an 			 * an interrupt is generated.  Should depend on 			 * line speed.  Needs to be about 6 on a 486DX33 			 * for 4 active ports at 115200 bps.  Why doesn't 			 * 10 work? 			 */
end_comment

begin_define
define|#
directive|define
name|PollMode
end_define

begin_comment
comment|/* Use polling-based irq service routine, not the 			 * hardware svcack lines.  Must be defined for 			 * Cyclom-16Y boards.  Less efficient for Cyclom-8Ys, 			 * and stops 4 * 115200 bps from working. 			 */
end_comment

begin_undef
undef|#
directive|undef
name|Smarts
end_undef

begin_comment
comment|/* Enable slightly more CD1400 intelligence.  Mainly 			 * the output CR/LF processing, plus we can avoid a 			 * few checks usually done in ttyinput(). 			 * 			 * XXX not fully implemented, and not particularly 			 * worthwhile. 			 */
end_comment

begin_undef
undef|#
directive|undef
name|CyDebug
end_undef

begin_comment
comment|/* Include debugging code (not very expensive). */
end_comment

begin_comment
comment|/* These will go away. */
end_comment

begin_undef
undef|#
directive|undef
name|SOFT_CTS_OFLOW
end_undef

begin_define
define|#
directive|define
name|SOFT_HOTCHAR
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/cd1400.h>
end_include

begin_include
include|#
directive|include
file|<dev/cy/cyreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/cy/cyvar.h>
end_include

begin_define
define|#
directive|define
name|NCY
value|10
end_define

begin_comment
comment|/* KLUDGE */
end_comment

begin_define
define|#
directive|define
name|NPORTS
value|(NCY * CY_MAX_PORTS)
end_define

begin_define
define|#
directive|define
name|CY_MAX_PORTS
value|(CD1400_NO_OF_CHANNELS * CY_MAX_CD1400s)
end_define

begin_comment
comment|/* We encode the cyclom unit number (cyu) in spare bits in the IVR's. */
end_comment

begin_define
define|#
directive|define
name|CD1400_xIVR_CHAN_SHIFT
value|3
end_define

begin_define
define|#
directive|define
name|CD1400_xIVR_CHAN
value|0x1F
end_define

begin_comment
comment|/*  * ETC states.  com->etc may also contain a hardware ETC command value,  * meaning that execution of that command is pending.  */
end_comment

begin_define
define|#
directive|define
name|ETC_NONE
value|0
end_define

begin_comment
comment|/* we depend on bzero() setting this */
end_comment

begin_define
define|#
directive|define
name|ETC_BREAK_STARTING
value|1
end_define

begin_define
define|#
directive|define
name|ETC_BREAK_STARTED
value|2
end_define

begin_define
define|#
directive|define
name|ETC_BREAK_ENDING
value|3
end_define

begin_define
define|#
directive|define
name|ETC_BREAK_ENDED
value|4
end_define

begin_define
define|#
directive|define
name|LOTS_OF_EVENTS
value|64
end_define

begin_comment
comment|/* helps separate urgent events from input */
end_comment

begin_comment
comment|/*  * com state bits.  * (CS_BUSY | CS_TTGO) and (CS_BUSY | CS_TTGO | CS_ODEVREADY) must be higher  * than the other bits so that they can be tested as a group without masking  * off the low bits.  *  * The following com and tty flags correspond closely:  *	CS_BUSY		= TS_BUSY (maintained by cystart(), cypoll() and  *				   comstop())  *	CS_TTGO		= ~TS_TTSTOP (maintained by cyparam() and cystart())  *	CS_CTS_OFLOW	= CCTS_OFLOW (maintained by cyparam())  *	CS_RTS_IFLOW	= CRTS_IFLOW (maintained by cyparam())  * TS_FLUSH is not used.  * XXX I think TIOCSETA doesn't clear TS_TTSTOP when it clears IXON.  * XXX CS_*FLOW should be CF_*FLOW in com->flags (control flags not state).  */
end_comment

begin_define
define|#
directive|define
name|CS_BUSY
value|0x80
end_define

begin_comment
comment|/* output in progress */
end_comment

begin_define
define|#
directive|define
name|CS_TTGO
value|0x40
end_define

begin_comment
comment|/* output not stopped by XOFF */
end_comment

begin_define
define|#
directive|define
name|CS_ODEVREADY
value|0x20
end_define

begin_comment
comment|/* external device h/w ready (CTS) */
end_comment

begin_define
define|#
directive|define
name|CS_CHECKMSR
value|1
end_define

begin_comment
comment|/* check of MSR scheduled */
end_comment

begin_define
define|#
directive|define
name|CS_CTS_OFLOW
value|2
end_define

begin_comment
comment|/* use CTS output flow control */
end_comment

begin_define
define|#
directive|define
name|CS_ODONE
value|4
end_define

begin_comment
comment|/* output completed */
end_comment

begin_define
define|#
directive|define
name|CS_RTS_IFLOW
value|8
end_define

begin_comment
comment|/* use RTS input flow control */
end_comment

begin_define
define|#
directive|define
name|CSE_ODONE
value|1
end_define

begin_comment
comment|/* output transmitted */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|error_desc
index|[]
init|=
block|{
define|#
directive|define
name|CE_OVERRUN
value|0
literal|"silo overflow"
block|,
define|#
directive|define
name|CE_INTERRUPT_BUF_OVERFLOW
value|1
literal|"interrupt-level buffer overflow"
block|,
define|#
directive|define
name|CE_TTY_BUF_OVERFLOW
value|2
literal|"tty-level buffer overflow"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CE_NTYPES
value|3
end_define

begin_define
define|#
directive|define
name|CE_RECORD
parameter_list|(
name|com
parameter_list|,
name|errnum
parameter_list|)
value|(++(com)->delta_error_counts[errnum])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_define
define|#
directive|define
name|COM_LOCK
parameter_list|()
value|mtx_lock_spin(&cy_lock)
end_define

begin_define
define|#
directive|define
name|COM_UNLOCK
parameter_list|()
value|mtx_unlock_spin(&cy_lock)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COM_LOCK
parameter_list|()
end_define

begin_define
define|#
directive|define
name|COM_UNLOCK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* types.  XXX - should be elsewhere */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_comment
comment|/* boolean */
end_comment

begin_comment
comment|/* queue of linear buffers */
end_comment

begin_struct
struct|struct
name|lbq
block|{
name|u_char
modifier|*
name|l_head
decl_stmt|;
comment|/* next char to process */
name|u_char
modifier|*
name|l_tail
decl_stmt|;
comment|/* one past the last char to process */
name|struct
name|lbq
modifier|*
name|l_next
decl_stmt|;
comment|/* next in queue */
name|bool_t
name|l_queued
decl_stmt|;
comment|/* nonzero if queued */
block|}
struct|;
end_struct

begin_comment
comment|/* com device structure */
end_comment

begin_struct
struct|struct
name|com_s
block|{
name|u_char
name|state
decl_stmt|;
comment|/* miscellaneous flag bits */
name|u_char
name|etc
decl_stmt|;
comment|/* pending Embedded Transmit Command */
name|u_char
name|extra_state
decl_stmt|;
comment|/* more flag bits, separate for order trick */
name|u_char
name|gfrcr_image
decl_stmt|;
comment|/* copy of value read from GFRCR */
name|u_char
name|mcr_dtr
decl_stmt|;
comment|/* MCR bit that is wired to DTR */
name|u_char
name|mcr_image
decl_stmt|;
comment|/* copy of value written to MCR */
name|u_char
name|mcr_rts
decl_stmt|;
comment|/* MCR bit that is wired to RTS */
name|int
name|unit
decl_stmt|;
comment|/* unit	number */
comment|/* 	 * The high level of the driver never reads status registers directly 	 * because there would be too many side effects to handle conveniently. 	 * Instead, it reads copies of the registers stored here by the 	 * interrupt handler. 	 */
name|u_char
name|last_modem_status
decl_stmt|;
comment|/* last MSR read by intr handler */
name|u_char
name|prev_modem_status
decl_stmt|;
comment|/* last MSR handled by high level */
name|u_char
modifier|*
name|ibuf
decl_stmt|;
comment|/* start of input buffer */
name|u_char
modifier|*
name|ibufend
decl_stmt|;
comment|/* end of input buffer */
name|u_char
modifier|*
name|ibufold
decl_stmt|;
comment|/* old input buffer, to be freed */
name|u_char
modifier|*
name|ihighwater
decl_stmt|;
comment|/* threshold in input buffer */
name|u_char
modifier|*
name|iptr
decl_stmt|;
comment|/* next free spot in input buffer */
name|int
name|ibufsize
decl_stmt|;
comment|/* size of ibuf (not include error bytes) */
name|int
name|ierroff
decl_stmt|;
comment|/* offset of error bytes in ibuf */
name|struct
name|lbq
name|obufq
decl_stmt|;
comment|/* head of queue of output buffers */
name|struct
name|lbq
name|obufs
index|[
literal|2
index|]
decl_stmt|;
comment|/* output buffers */
name|int
name|cy_align
decl_stmt|;
comment|/* index for register alignment */
name|cy_addr
name|cy_iobase
decl_stmt|;
comment|/* base address of this port's cyclom */
name|cy_addr
name|iobase
decl_stmt|;
comment|/* base address of this port's cd1400 */
name|int
name|mcr_rts_reg
decl_stmt|;
comment|/* cd1400 reg number of reg holding mcr_rts */
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* cross reference */
name|u_long
name|bytes_in
decl_stmt|;
comment|/* statistics */
name|u_long
name|bytes_out
decl_stmt|;
name|u_int
name|delta_error_counts
index|[
name|CE_NTYPES
index|]
decl_stmt|;
name|u_long
name|error_counts
index|[
name|CE_NTYPES
index|]
decl_stmt|;
name|u_int
name|recv_exception
decl_stmt|;
comment|/* exception chars received */
name|u_int
name|mdm
decl_stmt|;
comment|/* modem signal changes */
ifdef|#
directive|ifdef
name|CyDebug
name|u_int
name|start_count
decl_stmt|;
comment|/* no. of calls to cystart() */
name|u_int
name|start_real
decl_stmt|;
comment|/* no. of calls that did something */
endif|#
directive|endif
name|u_char
name|car
decl_stmt|;
comment|/* CD1400 CAR shadow (if first unit in cd) */
name|u_char
name|channel_control
decl_stmt|;
comment|/* CD1400 CCR control command shadow */
name|u_char
name|cor
index|[
literal|3
index|]
decl_stmt|;
comment|/* CD1400 COR1-3 shadows */
name|u_char
name|intr_enable
decl_stmt|;
comment|/* CD1400 SRER shadow */
comment|/* 	 * Data area for output buffers.  Someday we should build the output 	 * buffer queue without copying data. 	 */
name|u_char
name|obuf1
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|obuf2
index|[
literal|256
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|devclass_t
name|cy_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cy_driver_name
index|[]
init|=
literal|"cy"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cd1400_channel_cmd
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd1400_channel_cmd_wait
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd_etc
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|etc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd_getreg
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd_setreg
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cyinput
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cypoll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cysettimeout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cysetwater
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|speed_t
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cyspeed
parameter_list|(
name|speed_t
name|speed
parameter_list|,
name|u_long
name|cy_clock
parameter_list|,
name|int
modifier|*
name|prescaler_io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|cywakeup
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|disc_optim
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|,
name|struct
name|com_s
modifier|*
name|com
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|t_break_t
name|cybreak
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_modem_t
name|cymodem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_open_t
name|cyopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|t_close_t
name|cyclose
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_function_decl
name|void
name|cystatus
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cy_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_inited
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table and macro for fast conversion from a unit number to its com struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|com_s
modifier|*
name|p_cy_addr
index|[
name|NPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cy_addr
parameter_list|(
name|unit
parameter_list|)
value|(p_cy_addr[unit])
end_define

begin_decl_stmt
specifier|static
name|u_int
name|cy_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input chars + weighted output completions */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|cy_fast_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|cy_slow_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_timeouts_until_log
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|cy_timeout_handle
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|cy_timeout_handle
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|cd_inbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_inbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cd_outbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_outbs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_svrr_probes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cy_timeouts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|cy_chip_offset
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0400
block|,
literal|0x0800
block|,
literal|0x0c00
block|,
literal|0x0200
block|,
literal|0x0600
block|,
literal|0x0a00
block|,
literal|0x0e00
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_nr_cd1400s
index|[
name|NCY
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cy_total_devices
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|RxFifoThreshold
end_undef

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|RxFifoThreshold
init|=
operator|(
name|CD1400_RX_FIFO_SIZE
operator|/
literal|2
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|cy_units
parameter_list|(
name|cy_addr
name|cy_iobase
parameter_list|,
name|int
name|cy_align
parameter_list|)
block|{
name|int
name|cyu
decl_stmt|;
name|u_char
name|firmware_version
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|CY_MAX_CD1400s
condition|;
operator|++
name|cyu
control|)
block|{
name|iobase
operator|=
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
expr_stmt|;
comment|/* wait for chip to become ready for new command */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|)
condition|)
break|break;
block|}
comment|/* clear the GFRCR register */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* issue a reset command */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CCR
argument_list|,
name|cy_align
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FULLRESET
argument_list|)
expr_stmt|;
comment|/* XXX bogus initialization to avoid a gcc bug/warning. */
name|firmware_version
operator|=
literal|0
expr_stmt|;
comment|/* wait for the CD1400 to initialize itself */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* retrieve firmware version */
name|firmware_version
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|firmware_version
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
break|break;
block|}
comment|/* 		 * Anything in the 0x40-0x4F range is fine. 		 * If one CD1400 is bad then we don't support higher 		 * numbered good ones on this board. 		 */
if|if
condition|(
operator|(
name|firmware_version
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x40
condition|)
break|break;
block|}
return|return
operator|(
name|cyu
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cyattach_common
parameter_list|(
name|cy_addr
name|cy_iobase
parameter_list|,
name|int
name|cy_align
parameter_list|)
block|{
name|int
name|adapter
decl_stmt|;
name|int
name|cyu
decl_stmt|;
name|u_char
name|firmware_version
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|int
name|ncyu
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
while|while
condition|(
name|cy_inited
operator|!=
literal|2
condition|)
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|cy_inited
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mtx_init
argument_list|(
operator|&
name|cy_lock
argument_list|,
name|cy_driver_name
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|cy_inited
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|adapter
operator|=
name|cy_total_devices
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|adapter
operator|>=
name|NCY
condition|)
block|{
name|printf
argument_list|(
literal|"cy%d: can't attach adapter: insufficient cy devices configured\n"
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ncyu
operator|=
name|cy_units
argument_list|(
name|cy_iobase
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncyu
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cy_nr_cd1400s
index|[
name|adapter
index|]
operator|=
name|ncyu
expr_stmt|;
name|cy_total_devices
operator|++
expr_stmt|;
name|unit
operator|=
name|adapter
operator|*
name|CY_MAX_PORTS
expr_stmt|;
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|ncyu
condition|;
operator|++
name|cyu
control|)
block|{
name|int
name|cdu
decl_stmt|;
name|iobase
operator|=
call|(
name|cy_addr
call|)
argument_list|(
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
argument_list|)
expr_stmt|;
name|firmware_version
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_GFRCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* Set up a receive timeout period of than 1+ ms. */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_PPR
argument_list|,
name|cy_align
argument_list|,
name|howmany
argument_list|(
name|CY_CLOCK
argument_list|(
name|firmware_version
argument_list|)
operator|/
name|CD1400_PPR_PRESCALER
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cdu
operator|=
literal|0
init|;
name|cdu
operator|<
name|CD1400_NO_OF_CHANNELS
condition|;
operator|++
name|cdu
operator|,
operator|++
name|unit
control|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
name|com
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|com
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
break|break;
name|com
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|com
operator|->
name|gfrcr_image
operator|=
name|firmware_version
expr_stmt|;
if|if
condition|(
name|CY_RTS_DTR_SWAPPED
argument_list|(
name|firmware_version
argument_list|)
condition|)
block|{
name|com
operator|->
name|mcr_dtr
operator|=
name|CD1400_MSVR1_RTS
expr_stmt|;
name|com
operator|->
name|mcr_rts
operator|=
name|CD1400_MSVR2_DTR
expr_stmt|;
name|com
operator|->
name|mcr_rts_reg
operator|=
name|CD1400_MSVR2
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|mcr_dtr
operator|=
name|CD1400_MSVR2_DTR
expr_stmt|;
name|com
operator|->
name|mcr_rts
operator|=
name|CD1400_MSVR1_RTS
expr_stmt|;
name|com
operator|->
name|mcr_rts_reg
operator|=
name|CD1400_MSVR1
expr_stmt|;
block|}
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
operator|=
name|com
operator|->
name|obuf1
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
operator|=
name|com
operator|->
name|obuf2
expr_stmt|;
name|com
operator|->
name|cy_align
operator|=
name|cy_align
expr_stmt|;
name|com
operator|->
name|cy_iobase
operator|=
name|cy_iobase
expr_stmt|;
name|com
operator|->
name|iobase
operator|=
name|iobase
expr_stmt|;
name|com
operator|->
name|car
operator|=
operator|~
name|CD1400_CAR_CHAN
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
operator|=
name|ttyalloc
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_open
operator|=
name|cyopen
expr_stmt|;
name|tp
operator|->
name|t_close
operator|=
name|cyclose
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|cystart
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|comstop
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|cyparam
expr_stmt|;
name|tp
operator|->
name|t_break
operator|=
name|cybreak
expr_stmt|;
name|tp
operator|->
name|t_modem
operator|=
name|cymodem
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|com
expr_stmt|;
if|if
condition|(
name|cysetwater
argument_list|(
name|com
argument_list|,
name|tp
operator|->
name|t_init_in
operator|.
name|c_ispeed
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|com
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cy_addr
argument_list|(
name|unit
argument_list|)
operator|=
name|com
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cy_fast_ih
operator|==
name|NULL
condition|)
block|{
name|swi_add
argument_list|(
operator|&
name|tty_intr_event
argument_list|,
literal|"cy"
argument_list|,
name|cypoll
argument_list|,
name|NULL
argument_list|,
name|SWI_TTY
argument_list|,
literal|0
argument_list|,
operator|&
name|cy_fast_ih
argument_list|)
expr_stmt|;
name|swi_add
argument_list|(
operator|&
name|clk_intr_event
argument_list|,
literal|"cy"
argument_list|,
name|cypoll
argument_list|,
name|NULL
argument_list|,
name|SWI_CLOCK
argument_list|,
literal|0
argument_list|,
operator|&
name|cy_slow_ih
argument_list|)
expr_stmt|;
block|}
name|ttycreate
argument_list|(
name|tp
argument_list|,
name|TS_CALLOUT
argument_list|,
literal|"c%r%r"
argument_list|,
name|adapter
argument_list|,
name|unit
operator|%
name|CY_MAX_PORTS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ensure an edge for the next interrupt */
name|cy_outb
argument_list|(
name|cy_iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|cy_addr
argument_list|(
name|adapter
operator|*
name|CY_MAX_PORTS
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyopen
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|cdev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * We jump to this label after all non-interrupted sleeps to pick 	 * up any changes of the device state. 	 */
comment|/* Encode per-board unit in LIVR for access in intr routines. */
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_LIVR
argument_list|,
operator|(
name|com
operator|->
name|unit
operator|&
name|CD1400_xIVR_CHAN
operator|)
operator|<<
name|CD1400_xIVR_CHAN_SHIFT
argument_list|)
expr_stmt|;
comment|/* 	 * Flush fifos.  This requires a full channel reset which 	 * also disables the transmitter and receiver.  Recover 	 * from this. 	 */
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_CHANRESET
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|prev_modem_status
operator|=
name|com
operator|->
name|last_modem_status
operator|=
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|CD1400_SRER_MDMCH
operator||
name|CD1400_SRER_RXDATA
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|cysettimeout
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|cy_addr
name|iobase
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|unit
operator|=
name|com
operator|->
name|unit
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* XXX */
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|etc
operator|=
name|ETC_NONE
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR2
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|&=
operator|~
name|CD1400_COR2_ETC
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|cd_etc
argument_list|(
name|com
argument_list|,
name|CD1400_ETC_STOPBREAK
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FTF
argument_list|)
expr_stmt|;
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
literal|0
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
comment|/* 		     * XXX we will miss any carrier drop between here and the 		     * next open.  Perhaps we should watch DCD even when the 		     * port is closed; it is not sufficient to check it at 		     * the next open because it might go up and down while 		     * we're not watching. 		     */
operator|||
operator|(
operator|!
name|tp
operator|->
name|t_actout
operator|&&
operator|!
operator|(
name|com
operator|->
name|prev_modem_status
operator|&
name|CD1400_MSVR2_CD
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_init_in
operator|.
name|c_cflag
operator|&
name|CLOCAL
operator|)
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|cymodem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
argument_list|)
expr_stmt|;
comment|/* Disable receiver (leave transmitter enabled). */
name|com
operator|->
name|channel_control
operator|=
name|CD1400_CCR_CMDCHANCTL
operator||
name|CD1400_CCR_XMTEN
operator||
name|CD1400_CCR_RCVDIS
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|ttydtrwaitstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
name|tp
operator|->
name|t_actout
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_actout
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restart any wopeners */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function:  *  a) needs to be called with COM_LOCK() held, and  *  b) needs to return with COM_LOCK() held.  */
end_comment

begin_function
specifier|static
name|void
name|cyinput
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|incc
decl_stmt|;
name|u_char
name|line_status
decl_stmt|;
name|int
name|recv_data
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|buf
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|cy_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
comment|/* 		 * Avoid the grotesquely inefficient lineswitch routine 		 * (ttyinput) in "raw" mode.  It usually takes about 450 		 * instructions (that's without canonical processing or echo!). 		 * slinput is reasonably fast (usually 40 instructions plus 		 * call overhead). 		 */
do|do
block|{
comment|/* 			 * This may look odd, but it is using save-and-enable 			 * semantics instead of the save-and-disable semantics 			 * that are used everywhere else. 			 */
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|incc
operator|=
name|com
operator|->
name|iptr
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|incc
operator|>
name|tp
operator|->
name|t_ihiwat
operator|&&
operator|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
operator|||
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|com
operator|->
name|delta_error_counts
index|[
name|CE_TTY_BUF_OVERFLOW
index|]
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|incc
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|incc
expr_stmt|;
name|tk_nin
operator|+=
name|incc
expr_stmt|;
name|tk_rawcc
operator|+=
name|incc
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|incc
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|cystart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|buf
operator|<
name|com
operator|->
name|iptr
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
comment|/* 			 * This may look odd, but it is using save-and-enable 			 * semantics instead of the save-and-disable semantics 			 * that are used everywhere else. 			 */
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|line_status
operator|=
name|buf
index|[
name|com
operator|->
name|ierroff
index|]
expr_stmt|;
name|recv_data
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
operator|(
name|CD1400_RDSR_BREAK
operator||
name|CD1400_RDSR_FE
operator||
name|CD1400_RDSR_OE
operator||
name|CD1400_RDSR_PE
operator|)
condition|)
block|{
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_BREAK
condition|)
name|recv_data
operator||=
name|TTY_BI
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_FE
condition|)
name|recv_data
operator||=
name|TTY_FE
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_OE
condition|)
name|recv_data
operator||=
name|TTY_OE
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_PE
condition|)
name|recv_data
operator||=
name|TTY_PE
expr_stmt|;
block|}
name|ttyld_rint
argument_list|(
name|tp
argument_list|,
name|recv_data
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|buf
operator|<
name|com
operator|->
name|iptr
condition|)
do|;
block|}
name|cy_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
comment|/* 	 * There is now room for another low-level buffer full of input, 	 * so enable RTS if it is now disabled and there is room in the 	 * high-level buffer. 	 */
if|if
condition|(
operator|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|mcr_image
operator|&
name|com
operator|->
name|mcr_rts
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cyintr
parameter_list|(
name|void
modifier|*
name|vcom
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|basecom
decl_stmt|;
name|int
name|baseu
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|cy_addr
name|cy_iobase
decl_stmt|;
name|int
name|cyu
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
comment|/* XXX could this be placed down lower in the loop? */
name|basecom
operator|=
operator|(
expr|struct
name|com_s
operator|*
operator|)
name|vcom
expr_stmt|;
name|baseu
operator|=
name|basecom
operator|->
name|unit
expr_stmt|;
name|cy_align
operator|=
name|basecom
operator|->
name|cy_align
expr_stmt|;
name|cy_iobase
operator|=
name|basecom
operator|->
name|cy_iobase
expr_stmt|;
name|unit
operator|=
name|baseu
operator|/
name|CY_MAX_PORTS
expr_stmt|;
comment|/* check each CD1400 in turn */
for|for
control|(
name|cyu
operator|=
literal|0
init|;
name|cyu
operator|<
name|cy_nr_cd1400s
index|[
name|unit
index|]
condition|;
operator|++
name|cyu
control|)
block|{
name|iobase
operator|=
call|(
name|cy_addr
call|)
argument_list|(
name|cy_iobase
operator|+
operator|(
name|cy_chip_offset
index|[
name|cyu
index|]
operator|<<
name|cy_align
operator|)
argument_list|)
expr_stmt|;
comment|/* poll to see if it has any work */
name|status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SVRR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
continue|continue;
comment|// XXX - FILTER_STRAY?
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|cy_svrr_probes
expr_stmt|;
endif|#
directive|endif
comment|/* service requests as appropriate, giving priority to RX */
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_RXRDY
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|u_char
modifier|*
name|ioptr
decl_stmt|;
name|u_char
name|line_status
decl_stmt|;
name|u_char
name|recv_data
decl_stmt|;
name|u_char
name|serv_type
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_rir
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_rir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter rx service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_rir
argument_list|)
expr_stmt|;
name|cy_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
argument_list|)
operator|->
name|car
operator|=
name|save_rir
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|serv_type
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIVR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|serv_type
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack receive service */
name|serv_type
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|baseu
operator|+
operator|+
operator|(
operator|(
name|serv_type
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|serv_type
operator|&
name|CD1400_RIVR_EXCEPTION
condition|)
block|{
operator|++
name|com
operator|->
name|recv_exception
expr_stmt|;
name|line_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* break/unnattached error bits or real input? */
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_SPECIAL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_hotchar
operator|!=
literal|0
condition|)
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* XXX "intelligent" PFO error handling would break O error handling */
if|if
condition|(
name|line_status
operator|&
operator|(
name|CD1400_RDSR_PE
operator||
name|CD1400_RDSR_FE
operator||
name|CD1400_RDSR_BREAK
operator|)
condition|)
block|{
comment|/* 				  Don't store PE if IGNPAR and BI if IGNBRK, 				  this hack allows "raw" tty optimization 				  works even if IGN* is set. 				*/
if|if
condition|(
name|com
operator|->
name|tp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|(
operator|(
name|line_status
operator|&
operator|(
name|CD1400_RDSR_PE
operator||
name|CD1400_RDSR_FE
operator|)
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|IGNPAR
operator|)
operator|)
operator|||
operator|(
operator|(
name|line_status
operator|&
name|CD1400_RDSR_BREAK
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|IGNBRK
operator|)
operator|)
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
operator|(
name|line_status
operator|&
operator|(
name|CD1400_RDSR_PE
operator||
name|CD1400_RDSR_FE
operator|)
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
operator|&&
operator|(
operator|(
name|line_status
operator|&
name|CD1400_RDSR_FE
operator|)
operator|||
operator|(
operator|(
name|line_status
operator|&
name|CD1400_RDSR_PE
operator|)
operator|&&
operator|(
name|com
operator|->
name|tp
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|)
operator|)
condition|)
name|recv_data
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 1 */
operator|++
name|com
operator|->
name|bytes_in
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|tp
operator|->
name|t_hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|tp
operator|->
name|t_hotchar
condition|)
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioptr
operator|=
name|com
operator|->
name|iptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|>=
name|com
operator|->
name|ibufend
condition|)
name|CE_RECORD
argument_list|(
name|com
argument_list|,
name|CE_INTERRUPT_BUF_OVERFLOW
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|com
operator|->
name|tp
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|tp
operator|->
name|t_timestamp
argument_list|)
expr_stmt|;
operator|++
name|cy_events
expr_stmt|;
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|com
operator|->
name|ierroff
index|]
operator|=
name|line_status
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
operator|++
name|ioptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|==
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_status
operator|&
name|CD1400_RDSR_OE
condition|)
name|CE_RECORD
argument_list|(
name|com
argument_list|,
name|CE_OVERRUN
argument_list|)
expr_stmt|;
block|}
goto|goto
name|cont
goto|;
block|}
else|else
block|{
name|int
name|ifree
decl_stmt|;
name|count
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDCR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
goto|goto
name|cont
goto|;
name|com
operator|->
name|bytes_in
operator|+=
name|count
expr_stmt|;
name|ioptr
operator|=
name|com
operator|->
name|iptr
expr_stmt|;
name|ifree
operator|=
name|com
operator|->
name|ibufend
operator|-
name|ioptr
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|ifree
condition|)
block|{
name|count
operator|-=
name|ifree
expr_stmt|;
name|cy_events
operator|+=
name|ifree
expr_stmt|;
if|if
condition|(
name|ifree
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|tp
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|tp
operator|->
name|t_timestamp
argument_list|)
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|tp
operator|->
name|t_hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|tp
operator|->
name|t_hotchar
condition|)
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|com
operator|->
name|ierroff
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|ioptr
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|ifree
operator|!=
literal|0
condition|)
do|;
block|}
name|com
operator|->
name|delta_error_counts
index|[
name|CE_INTERRUPT_BUF_OVERFLOW
index|]
operator|+=
name|count
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|tp
operator|->
name|t_hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|tp
operator|->
name|t_hotchar
condition|)
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|tp
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_do_timestamp
condition|)
name|microtime
argument_list|(
operator|&
name|com
operator|->
name|tp
operator|->
name|t_timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioptr
operator|<=
name|com
operator|->
name|ihighwater
operator|&&
name|ioptr
operator|+
name|count
operator|>
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
name|cy_events
operator|+=
name|count
expr_stmt|;
do|do
block|{
name|recv_data
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RDSR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
if|if
condition|(
name|com
operator|->
name|tp
operator|->
name|t_hotchar
operator|!=
literal|0
operator|&&
name|recv_data
operator|==
name|com
operator|->
name|tp
operator|->
name|t_hotchar
condition|)
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioptr
index|[
literal|0
index|]
operator|=
name|recv_data
expr_stmt|;
name|ioptr
index|[
name|com
operator|->
name|ierroff
index|]
operator|=
literal|0
expr_stmt|;
operator|++
name|ioptr
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
name|com
operator|->
name|iptr
operator|=
name|ioptr
expr_stmt|;
block|}
name|cont
label|:
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|cy_align
argument_list|,
name|save_rir
operator|&
operator|~
operator|(
name|CD1400_RIR_RDIREQ
operator||
name|CD1400_RIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_MDMCH
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
name|modem_status
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_mir
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_mir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter modem service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_mir
argument_list|)
expr_stmt|;
name|cy_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
argument_list|)
operator|->
name|car
operator|=
name|save_mir
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_mir
operator|&
name|CD1400_MIR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack modem service */
name|vector
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKM
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|vector
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|com
operator|->
name|mdm
expr_stmt|;
name|modem_status
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|modem_status
operator|!=
name|com
operator|->
name|last_modem_status
condition|)
block|{
comment|/* 			 * Schedule high level to handle DCD changes.  Note 			 * that we don't use the delta bits anywhere.  Some 			 * UARTs mess them up, and it's easy to remember the 			 * previous bits and calculate the delta. 			 */
name|com
operator|->
name|last_modem_status
operator|=
name|modem_status
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
operator|)
condition|)
block|{
name|cy_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_CHECKMSR
expr_stmt|;
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
comment|/* handle CTS change immediately for crisp flow ctl */
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CTS_OFLOW
condition|)
block|{
if|if
condition|(
name|modem_status
operator|&
name|CD1400_MSVR2_CTS
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_ODEVREADY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODEVREADY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|cy_align
argument_list|,
name|save_mir
operator|&
operator|~
operator|(
name|CD1400_MIR_RDIREQ
operator||
name|CD1400_MIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_TXRDY
condition|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_tir
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
name|save_tir
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
comment|/* enter tx service */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|save_tir
argument_list|)
expr_stmt|;
name|cy_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
argument_list|)
operator|->
name|car
operator|=
name|save_tir
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|baseu
operator|+
name|cyu
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_tir
operator|&
name|CD1400_TIR_CHAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ack transmit service */
name|vector
operator|=
name|cy_inb
argument_list|(
name|iobase
argument_list|,
name|CY8_SVCACKT
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|baseu
operator|+
operator|(
operator|(
name|vector
operator|>>
name|CD1400_xIVR_CHAN_SHIFT
operator|)
operator|&
name|CD1400_xIVR_CHAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|com
operator|->
name|etc
operator|!=
name|ETC_NONE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
block|{
comment|/* 					 * Here due to sloppy SRER_TXRDY 					 * enabling.  Ignore.  Come back when 					 * tx is empty. 					 */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
goto|goto
name|terminate_tx_service
goto|;
block|}
switch|switch
condition|(
name|com
operator|->
name|etc
condition|)
block|{
case|case
name|CD1400_ETC_SENDBREAK
case|:
case|case
name|CD1400_ETC_STOPBREAK
case|:
comment|/* 					 * Start the command.  Come back on 					 * next tx empty interrupt, hopefully 					 * after command has been executed. 					 */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR2
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator||=
name|CD1400_COR2_ETC
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
name|CD1400_ETC_CMD
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|etc
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|CD1400_ETC_SENDBREAK
condition|)
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_STARTING
expr_stmt|;
else|else
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_ENDING
expr_stmt|;
goto|goto
name|terminate_tx_service
goto|;
case|case
name|ETC_BREAK_STARTING
case|:
comment|/* 					 * BREAK is now on.  Continue with 					 * SRER_TXMPTY processing, hopefully 					 * don't come back. 					 */
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_STARTED
expr_stmt|;
break|break;
case|case
name|ETC_BREAK_STARTED
case|:
comment|/* 					 * Came back due to sloppy SRER_TXMPTY 					 * enabling.  Hope again. 					 */
break|break;
case|case
name|ETC_BREAK_ENDING
case|:
comment|/* 					 * BREAK is now off.  Continue with 					 * SRER_TXMPTY processing and don't 					 * come back.  The SWI handler will 					 * restart tx interrupts if necessary. 					 */
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_COR2
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|&=
operator|~
name|CD1400_COR2_ETC
argument_list|)
expr_stmt|;
name|com
operator|->
name|etc
operator|=
name|ETC_BREAK_ENDED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
operator|)
condition|)
block|{
name|cy_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_ODONE
expr_stmt|;
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETC_BREAK_ENDED
case|:
comment|/* 					 * Shouldn't get here.  Hope again. 					 */
break|break;
block|}
block|}
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXMPTY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
operator|)
condition|)
block|{
name|cy_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator||=
name|CSE_ODONE
expr_stmt|;
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|&=
operator|~
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
goto|goto
name|terminate_tx_service
goto|;
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
block|{
name|u_char
modifier|*
name|ioptr
decl_stmt|;
name|u_int
name|ocount
decl_stmt|;
name|ioptr
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_head
expr_stmt|;
name|ocount
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|-
name|ioptr
expr_stmt|;
if|if
condition|(
name|ocount
operator|>
name|CD1400_TX_FIFO_SIZE
condition|)
name|ocount
operator|=
name|CD1400_TX_FIFO_SIZE
expr_stmt|;
name|com
operator|->
name|bytes_out
operator|+=
name|ocount
expr_stmt|;
do|do
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TDR
argument_list|,
name|cy_align
argument_list|,
operator|*
name|ioptr
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|ocount
operator|!=
literal|0
condition|)
do|;
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|ioptr
expr_stmt|;
if|if
condition|(
name|ioptr
operator|>=
name|com
operator|->
name|obufq
operator|.
name|l_tail
condition|)
block|{
name|struct
name|lbq
modifier|*
name|qp
decl_stmt|;
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
name|qp
operator|->
name|l_queued
operator|=
name|FALSE
expr_stmt|;
name|qp
operator|=
name|qp
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|qp
operator|!=
name|NULL
condition|)
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|qp
operator|->
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|qp
operator|->
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
name|qp
expr_stmt|;
block|}
else|else
block|{
comment|/* output just completed */
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_BUSY
expr_stmt|;
comment|/* 					 * The setting of CSE_ODONE may be 					 * stale here.  We currently only 					 * use it when CS_BUSY is set, and 					 * fixing it when we clear CS_BUSY 					 * is easiest. 					 */
if|if
condition|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
condition|)
block|{
name|cy_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator|&=
operator|~
name|CSE_ODONE
expr_stmt|;
block|}
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SRER
argument_list|,
name|cy_align
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
operator|)
condition|)
block|{
name|cy_events
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_ODONE
expr_stmt|;
comment|/* handle at high level ASAP */
name|swi_sched
argument_list|(
name|cy_fast_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* terminate service context */
name|terminate_tx_service
label|:
ifdef|#
directive|ifdef
name|PollMode
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|cy_align
argument_list|,
name|save_tir
operator|&
operator|~
operator|(
name|CD1400_TIR_RDIREQ
operator||
name|CD1400_TIR_RBUSY
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_EOSRR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* ensure an edge for the next interrupt */
name|cy_outb
argument_list|(
name|cy_iobase
argument_list|,
name|CY_CLEAR_INTR
argument_list|,
name|cy_align
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|swi_sched
argument_list|(
name|cy_slow_ih
argument_list|,
name|SWI_DELAY
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cybreak
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sig
condition|)
name|cd_etc
argument_list|(
name|com
argument_list|,
name|CD1400_ETC_SENDBREAK
argument_list|)
expr_stmt|;
else|else
name|cd_etc
argument_list|(
name|com
argument_list|,
name|CD1400_ETC_STOPBREAK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cypoll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|cy_timeouts
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cy_events
operator|==
literal|0
condition|)
return|return;
name|repeat
label|:
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NPORTS
condition|;
operator|++
name|unit
control|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|incc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
continue|continue;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * XXX forget any events related to closed devices 			 * (actually never opened devices) so that we don't 			 * loop. 			 */
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|incc
operator|=
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
condition|)
block|{
name|incc
operator|+=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CHECKMSR
expr_stmt|;
block|}
name|cy_events
operator|-=
name|incc
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|incc
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"cy%d: %d events for device with no tp\n"
argument_list|,
name|unit
argument_list|,
name|incc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|com
operator|->
name|iptr
operator|!=
name|com
operator|->
name|ibuf
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|cyinput
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_CHECKMSR
condition|)
block|{
name|u_char
name|delta_modem_status
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|cyinput
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|delta_modem_status
operator|=
name|com
operator|->
name|last_modem_status
operator|^
name|com
operator|->
name|prev_modem_status
expr_stmt|;
name|com
operator|->
name|prev_modem_status
operator|=
name|com
operator|->
name|last_modem_status
expr_stmt|;
name|cy_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CHECKMSR
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|delta_modem_status
operator|&
name|CD1400_MSVR2_CD
condition|)
name|ttyld_modem
argument_list|(
name|tp
argument_list|,
name|com
operator|->
name|prev_modem_status
operator|&
name|CD1400_MSVR2_CD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|cy_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator|&=
operator|~
name|CSE_ODONE
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|com
operator|->
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|com
operator|->
name|etc
operator|!=
name|ETC_NONE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDED
condition|)
name|com
operator|->
name|etc
operator|=
name|ETC_NONE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|etc
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|cy_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODONE
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|ttyld_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cy_events
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|cy_events
operator|>=
name|LOTS_OF_EVENTS
condition|)
goto|goto
name|repeat
goto|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
name|int
name|cflag
decl_stmt|;
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|u_char
name|cor_change
decl_stmt|;
name|u_long
name|cy_clock
decl_stmt|;
name|int
name|idivisor
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|int
name|iprescaler
decl_stmt|;
name|int
name|itimeout
decl_stmt|;
name|int
name|odivisor
decl_stmt|;
name|int
name|oprescaler
decl_stmt|;
name|u_char
name|opt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
comment|/* check requested parameters */
name|cy_clock
operator|=
name|CY_CLOCK
argument_list|(
name|com
operator|->
name|gfrcr_image
argument_list|)
expr_stmt|;
name|idivisor
operator|=
name|cyspeed
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|cy_clock
argument_list|,
operator|&
name|iprescaler
argument_list|)
expr_stmt|;
if|if
condition|(
name|idivisor
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|odivisor
operator|=
name|cyspeed
argument_list|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|?
name|t
operator|->
name|c_ospeed
else|:
name|tp
operator|->
name|t_ospeed
argument_list|,
name|cy_clock
argument_list|,
operator|&
name|oprescaler
argument_list|)
expr_stmt|;
if|if
condition|(
name|odivisor
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* parameters are OK, convert them to the com struct and the device */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|cymodem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|cymodem
argument_list|(
name|tp
argument_list|,
name|SER_DTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cysetwater
argument_list|(
name|com
argument_list|,
name|t
operator|->
name|c_ispeed
argument_list|)
expr_stmt|;
comment|/* XXX we don't actually change the speed atomically. */
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_RBPR
argument_list|,
name|idivisor
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_RCOR
argument_list|,
name|iprescaler
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_TBPR
argument_list|,
name|odivisor
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_TCOR
argument_list|,
name|oprescaler
argument_list|)
expr_stmt|;
comment|/* 	 * channel control 	 *	receiver enable 	 *	transmitter enable (always set) 	 */
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|opt
operator|=
name|CD1400_CCR_CMDCHANCTL
operator||
name|CD1400_CCR_XMTEN
operator||
operator|(
name|cflag
operator|&
name|CREAD
condition|?
name|CD1400_CCR_RCVEN
else|:
name|CD1400_CCR_RCVDIS
operator|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|channel_control
condition|)
block|{
name|com
operator|->
name|channel_control
operator|=
name|opt
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Smarts
comment|/* set special chars */
comment|/* XXX if one is _POSIX_VDISABLE, can't use some others */
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR1
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR2
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR3
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR4
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * set channel option register 1 - 	 *	parity mode 	 *	stop bits 	 *	char length 	 */
name|opt
operator|=
literal|0
expr_stmt|;
comment|/* parity */
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|opt
operator||=
name|CD1400_COR1_PARODD
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_PARNORMAL
expr_stmt|;
block|}
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
name|INPCK
operator|)
condition|)
name|opt
operator||=
name|CD1400_COR1_NOINPCK
expr_stmt|;
name|bits
operator|=
literal|1
operator|+
literal|1
expr_stmt|;
comment|/* stop bits */
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
block|{
operator|++
name|bits
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_STOP2
expr_stmt|;
block|}
comment|/* char length */
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|bits
operator|+=
literal|5
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|bits
operator|+=
literal|6
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|bits
operator|+=
literal|7
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS7
expr_stmt|;
break|break;
default|default:
name|bits
operator|+=
literal|8
expr_stmt|;
name|opt
operator||=
name|CD1400_COR1_CS8
expr_stmt|;
break|break;
block|}
name|cor_change
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|0
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR1
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR1
argument_list|,
name|com
operator|->
name|cor
index|[
literal|0
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set receive time-out period, normally to max(one char time, 5 ms). 	 */
name|itimeout
operator|=
operator|(
literal|1000
operator|*
name|bits
operator|+
name|t
operator|->
name|c_ispeed
operator|-
literal|1
operator|)
operator|/
name|t
operator|->
name|c_ispeed
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_HOTCHAR
define|#
directive|define
name|MIN_RTP
value|1
else|#
directive|else
define|#
directive|define
name|MIN_RTP
value|5
endif|#
directive|endif
if|if
condition|(
name|itimeout
operator|<
name|MIN_RTP
condition|)
name|itimeout
operator|=
name|MIN_RTP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
operator|)
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|!=
literal|0
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|!=
literal|0
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
operator|>
name|itimeout
condition|)
name|itimeout
operator|=
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|itimeout
operator|>
literal|255
condition|)
name|itimeout
operator|=
literal|255
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_RTPR
argument_list|,
name|itimeout
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 2 - 	 *	flow control 	 */
name|opt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|opt
operator||=
name|CD1400_COR2_IXANY
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|opt
operator||=
name|CD1400_COR2_IXOFF
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_COR2_CCTS_OFLOW
expr_stmt|;
endif|#
directive|endif
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|1
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR2
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR2
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* 	 * set channel option register 3 - 	 *	receiver FIFO interrupt threshold 	 *	flow control 	 */
name|opt
operator|=
name|RxFifoThreshold
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
condition|)
name|opt
operator||=
name|CD1400_COR3_SCD34
expr_stmt|;
comment|/* detect INTR& SUSP chars */
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
comment|/* detect and transparently handle START and STOP chars */
name|opt
operator||=
name|CD1400_COR3_FCT
operator||
name|CD1400_COR3_SCD12
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cor_change
operator||=
name|CD1400_CCR_COR3
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR3
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* notify the CD1400 if COR1-3 have changed */
if|if
condition|(
name|cor_change
condition|)
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDCORCHG
operator||
name|cor_change
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 4 - 	 *	CR/NL processing 	 *	break processing 	 *	received exception processing 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNCR
condition|)
name|opt
operator||=
name|CD1400_COR4_IGNCR
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* 	 * we need a new ttyinput() for this, as we don't want to 	 * have ICRNL&& INLCR being done in both layers, or to have 	 * synchronisation problems 	 */
if|if
condition|(
name|iflag
operator|&
name|ICRNL
condition|)
name|opt
operator||=
name|CD1400_COR4_ICRNL
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|INLCR
condition|)
name|opt
operator||=
name|CD1400_COR4_INLCR
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
name|opt
operator||=
name|CD1400_COR4_IGNBRK
operator||
name|CD1400_COR4_NOBRKINT
expr_stmt|;
comment|/* 	 * The `-ignbrk -brkint parmrk' case is not handled by the hardware, 	 * so only tell the hardware about -brkint if -parmrk. 	 */
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
operator|(
name|BRKINT
operator||
name|PARMRK
operator|)
operator|)
condition|)
name|opt
operator||=
name|CD1400_COR4_NOBRKINT
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX using this "intelligence" breaks reporting of overruns. */
block|if (iflag& IGNPAR) 		opt |= CD1400_COR4_PFO_DISCARD; 	else { 		if (iflag& PARMRK) 			opt |= CD1400_COR4_PFO_ESC; 		else 			opt |= CD1400_COR4_PFO_NUL; 	}
else|#
directive|else
name|opt
operator||=
name|CD1400_COR4_PFO_EXCEPTION
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR4
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * set channel option register 5 - 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|opt
operator||=
name|CD1400_COR5_ISTRIP
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_iflag
operator|&
name|IEXTEN
condition|)
comment|/* enable LNEXT (e.g. ctrl-v quoting) handling */
name|opt
operator||=
name|CD1400_COR5_LNEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|ONLCR
condition|)
name|opt
operator||=
name|CD1400_COR5_ONLCR
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|OCRNL
condition|)
name|opt
operator||=
name|CD1400_COR5_OCRNL
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR5
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * We always generate modem status change interrupts for CD changes. 	 * Among other things, this is necessary to track TS_CARR_ON for 	 * pstat to print even when the driver doesn't care.  CD changes 	 * should be rare so interrupts for them are not worth extra code to 	 * avoid.  We avoid interrupts for other modem status changes (except 	 * for CTS changes when SOFT_CTS_OFLOW is configured) since this is 	 * simplest and best. 	 */
comment|/* 	 * set modem change option register 1 	 *	generate modem interrupts on which 1 -> 0 input transitions 	 *	also controls auto-DTR output flow-control, which we don't use 	 */
name|opt
operator|=
name|CD1400_MCOR1_CDzd
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_MCOR1_CTSzd
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MCOR1
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * set modem change option register 2 	 *	generate modem interrupts on specific 0 -> 1 input transitions 	 */
name|opt
operator|=
name|CD1400_MCOR2_CDod
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|opt
operator||=
name|CD1400_MCOR2_CTSod
expr_stmt|;
endif|#
directive|endif
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MCOR2
argument_list|,
name|opt
argument_list|)
expr_stmt|;
comment|/* 	 * XXX should have done this long ago, but there is too much state 	 * to change all atomically. 	 */
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_TTGO
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
condition|)
name|com
operator|->
name|state
operator||=
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_RTS_IFLOW
expr_stmt|;
comment|/* 		 * If CS_RTS_IFLOW just changed from off to on, the change 		 * needs to be propagated to CD1400_MSVR1_RTS.  This isn't urgent, 		 * so do it later by calling cystart() instead of repeating 		 * a lot of code from cystart() here. 		 */
block|}
elseif|else
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_RTS_IFLOW
expr_stmt|;
comment|/* 		 * CS_RTS_IFLOW just changed from on to off.  Force CD1400_MSVR1_RTS 		 * on here, since cystart() won't do it later. 		 */
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up state to handle output flow control. 	 * XXX - worth handling MDMBUF (DCD) flow control at the lowest level? 	 * Now has 10+ msec latency, while CTS flow has 50- usec latency. 	 */
name|com
operator|->
name|state
operator||=
name|CS_ODEVREADY
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFT_CTS_OFLOW
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_CTS_OFLOW
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|com
operator|->
name|state
operator||=
name|CS_CTS_OFLOW
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|last_modem_status
operator|&
name|CD1400_MSVR2_CTS
operator|)
condition|)
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_ODEVREADY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* XXX shouldn't call functions while intrs are disabled. */
name|disc_optim
argument_list|(
name|tp
argument_list|,
name|t
argument_list|,
name|com
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Recover from fiddling with CS_TTGO.  We used to call cyintr1() 	 * unconditionally, but that defeated the careful discarding of 	 * stale input in cyopen(). 	 */
block|if (com->state>= (CS_BUSY | CS_TTGO)) 		cyintr1(com);
endif|#
directive|endif
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|cystart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|ibufold
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|com
operator|->
name|ibufold
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|com
operator|->
name|ibufold
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cysetwater
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|speed_t
name|speed
parameter_list|)
block|{
name|int
name|cp4ticks
decl_stmt|;
name|u_char
modifier|*
name|ibuf
decl_stmt|;
name|int
name|ibufsize
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* 	 * Make the buffer size large enough to handle a softtty interrupt 	 * latency of about 2 ticks without loss of throughput or data 	 * (about 3 ticks if input flow control is not used or not honoured, 	 * but a bit less for CS5-CS7 modes). 	 */
name|cp4ticks
operator|=
name|speed
operator|/
literal|10
operator|/
name|hz
operator|*
literal|4
expr_stmt|;
for|for
control|(
name|ibufsize
operator|=
literal|128
init|;
name|ibufsize
operator|<
name|cp4ticks
condition|;
control|)
name|ibufsize
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|ibufsize
operator|==
name|com
operator|->
name|ibufsize
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate input buffer.  The extra factor of 2 in the size is 	 * to allow for an error byte for each input byte. 	 */
name|ibuf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|ibufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibuf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Initialize non-critical variables. */
name|com
operator|->
name|ibufold
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
name|com
operator|->
name|ibufsize
operator|=
name|ibufsize
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_ififosize
operator|=
literal|2
operator|*
name|ibufsize
expr_stmt|;
name|tp
operator|->
name|t_ispeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tp
operator|->
name|t_ospeedwat
operator|=
operator|(
name|speed_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Read current input buffer, if any.  Continue with interrupts 	 * disabled. 	 */
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|iptr
operator|!=
name|com
operator|->
name|ibuf
condition|)
name|cyinput
argument_list|(
name|com
argument_list|)
expr_stmt|;
comment|/*- 	 * Initialize critical variables, including input buffer watermarks. 	 * The external device is asked to stop sending when the buffer 	 * exactly reaches high water, or when the high level requests it. 	 * The high level is notified immediately (rather than at a later 	 * clock tick) when this watermark is reached. 	 * The buffer size is chosen so the watermark should almost never 	 * be reached. 	 * The low watermark is invisibly 0 since the buffer is always 	 * emptied all at once. 	 */
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
operator|=
name|ibuf
expr_stmt|;
name|com
operator|->
name|ibufend
operator|=
name|ibuf
operator|+
name|ibufsize
expr_stmt|;
name|com
operator|->
name|ierroff
operator|=
name|ibufsize
expr_stmt|;
name|com
operator|->
name|ihighwater
operator|=
name|ibuf
operator|+
literal|3
operator|*
name|ibufsize
operator|/
literal|4
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
name|bool_t
name|started
decl_stmt|;
endif|#
directive|endif
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
operator|++
name|com
operator|->
name|start_count
expr_stmt|;
name|started
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
condition|)
block|{
name|com
operator|->
name|state
operator|&=
operator|~
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|state
operator||=
name|CS_TTGO
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
operator|&&
operator|!
operator|(
name|com
operator|->
name|intr_enable
operator|&
name|CD1400_SRER_TXRDY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|mcr_image
operator|&
name|com
operator|->
name|mcr_rts
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image&= ~CD1400_MSVR1_RTS);
else|#
directive|else
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|com
operator|->
name|mcr_image
operator|&
name|com
operator|->
name|mcr_rts
operator|)
operator|&&
name|com
operator|->
name|iptr
operator|<
name|com
operator|->
name|ihighwater
operator|&&
name|com
operator|->
name|state
operator|&
name|CS_RTS_IFLOW
condition|)
if|#
directive|if
literal|0
then|outb(com->modem_ctl_port, com->mcr_image |= CD1400_MSVR1_RTS);
else|#
directive|else
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|com
operator|->
name|mcr_rts_reg
argument_list|,
name|com
operator|->
name|mcr_image
operator||=
name|com
operator|->
name|mcr_rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|struct
name|lbq
modifier|*
name|qp
decl_stmt|;
name|struct
name|lbq
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|started
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obuf1
operator|+
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|com
operator|->
name|obuf1
argument_list|,
sizeof|sizeof
name|com
operator|->
name|obuf1
argument_list|)
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_next
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
operator|=
name|TRUE
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
condition|)
block|{
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|qp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|qp
operator|=
name|next
expr_stmt|;
name|qp
operator|->
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|0
index|]
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
operator|&&
operator|!
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|started
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obuf2
operator|+
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|com
operator|->
name|obuf2
argument_list|,
sizeof|sizeof
name|com
operator|->
name|obuf2
argument_list|)
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_next
operator|=
name|NULL
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
operator|=
name|TRUE
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_BUSY
condition|)
block|{
name|qp
operator|=
name|com
operator|->
name|obufq
operator|.
name|l_next
expr_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|qp
operator|->
name|l_next
operator|)
operator|!=
name|NULL
condition|)
name|qp
operator|=
name|next
expr_stmt|;
name|qp
operator|->
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|com
operator|->
name|obufq
operator|.
name|l_head
operator|=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_tail
operator|=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
expr_stmt|;
name|com
operator|->
name|obufq
operator|.
name|l_next
operator|=
operator|&
name|com
operator|->
name|obufs
index|[
literal|1
index|]
expr_stmt|;
name|com
operator|->
name|state
operator||=
name|CS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|>=
operator|(
name|CS_BUSY
operator||
name|CS_TTGO
operator||
name|CS_ODEVREADY
operator|)
condition|)
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXMPTY
operator|)
operator||
name|CD1400_SRER_TXRDY
argument_list|)
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CyDebug
if|if
condition|(
name|started
condition|)
operator|++
name|com
operator|->
name|start_real
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|critical_enter(); 	COM_LOCK(); 	if (com->state>= (CS_BUSY | CS_TTGO)) 		cyintr1(com);
comment|/* fake interrupt to start output */
block|COM_UNLOCK(); 	critical_exit();
endif|#
directive|endif
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|comstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|bool_t
name|wakeup_etc
decl_stmt|;
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
name|wakeup_etc
operator|=
name|FALSE
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
operator|=
name|FALSE
expr_stmt|;
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|extra_state
operator|&
name|CSE_ODONE
condition|)
block|{
name|cy_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|extra_state
operator|&=
operator|~
name|CSE_ODONE
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|etc
operator|!=
name|ETC_NONE
condition|)
block|{
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDED
condition|)
name|com
operator|->
name|etc
operator|=
name|ETC_NONE
expr_stmt|;
name|wakeup_etc
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|state
operator|&
name|CS_ODONE
condition|)
name|cy_events
operator|-=
name|LOTS_OF_EVENTS
expr_stmt|;
name|com
operator|->
name|state
operator|&=
operator|~
operator|(
name|CS_ODONE
operator||
name|CS_BUSY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
comment|/* XXX no way to reset only input fifo. */
name|cy_events
operator|-=
operator|(
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
operator|)
expr_stmt|;
name|com
operator|->
name|iptr
operator|=
name|com
operator|->
name|ibuf
expr_stmt|;
block|}
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|wakeup_etc
condition|)
name|wakeup
argument_list|(
operator|&
name|com
operator|->
name|etc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
operator|&&
name|com
operator|->
name|etc
operator|==
name|ETC_NONE
condition|)
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDRESET
operator||
name|CD1400_CCR_FTF
argument_list|)
expr_stmt|;
name|cystart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cymodem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sigon
parameter_list|,
name|int
name|sigoff
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|mcr
decl_stmt|;
name|int
name|msr
decl_stmt|;
name|com
operator|=
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sigon
operator|==
literal|0
operator|&&
name|sigoff
operator|==
literal|0
condition|)
block|{
name|sigon
operator|=
literal|0
expr_stmt|;
name|mcr
operator|=
name|com
operator|->
name|mcr_image
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|com
operator|->
name|mcr_dtr
condition|)
name|sigon
operator||=
name|SER_DTR
expr_stmt|;
if|if
condition|(
name|mcr
operator|&
name|com
operator|->
name|mcr_rts
condition|)
comment|/* XXX wired on for Cyclom-8Ys */
name|sigon
operator||=
name|SER_RTS
expr_stmt|;
comment|/* 		 * We must read the modem status from the hardware because 		 * we don't generate modem status change interrupts for all 		 * changes, so com->prev_modem_status is not guaranteed to 		 * be up to date.  This is safe, unlike for sio, because 		 * reading the status register doesn't clear pending modem 		 * status change interrupts. 		 */
name|msr
operator|=
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|CD1400_MSVR2_CTS
condition|)
name|sigon
operator||=
name|SER_CTS
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|CD1400_MSVR2_CD
condition|)
name|sigon
operator||=
name|SER_DCD
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|CD1400_MSVR2_DSR
condition|)
name|sigon
operator||=
name|SER_DSR
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|CD1400_MSVR2_RI
condition|)
comment|/* XXX not connected except for Cyclom-16Y? */
name|sigon
operator||=
name|SER_RI
expr_stmt|;
return|return
operator|(
name|sigon
operator|)
return|;
block|}
name|mcr
operator|=
name|com
operator|->
name|mcr_image
expr_stmt|;
if|if
condition|(
name|sigon
operator|&
name|SER_DTR
condition|)
name|mcr
operator||=
name|com
operator|->
name|mcr_dtr
expr_stmt|;
if|if
condition|(
name|sigoff
operator|&
name|SER_DTR
condition|)
name|mcr
operator|&=
operator|~
name|com
operator|->
name|mcr_dtr
expr_stmt|;
if|if
condition|(
name|sigon
operator|&
name|SER_RTS
condition|)
name|mcr
operator||=
name|com
operator|->
name|mcr_rts
expr_stmt|;
if|if
condition|(
name|sigoff
operator|&
name|SER_RTS
condition|)
name|mcr
operator|&=
operator|~
name|com
operator|->
name|mcr_rts
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|com
operator|->
name|mcr_image
operator|=
name|mcr
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR1
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|,
name|mcr
argument_list|)
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cysettimeout
parameter_list|()
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|bool_t
name|someopen
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* 	 * Set our timeout period to 1 second if no polled devices are open. 	 * Otherwise set it to max(1/200, 1/hz). 	 * Enable timeouts iff some device is open. 	 */
name|untimeout
argument_list|(
name|cywakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|cy_timeout_handle
argument_list|)
expr_stmt|;
name|cy_timeout
operator|=
name|hz
expr_stmt|;
name|someopen
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NPORTS
condition|;
operator|++
name|unit
control|)
block|{
name|com
operator|=
name|cy_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|!=
name|NULL
operator|&&
name|com
operator|->
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|someopen
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|someopen
condition|)
block|{
name|cy_timeouts_until_log
operator|=
name|hz
operator|/
name|cy_timeout
expr_stmt|;
name|cy_timeout_handle
operator|=
name|timeout
argument_list|(
name|cywakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|cy_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Flush error messages, if any. */
name|cy_timeouts_until_log
operator|=
literal|1
expr_stmt|;
name|cywakeup
argument_list|(
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|cywakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|cy_timeout_handle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cywakeup
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|cy_timeout_handle
operator|=
name|timeout
argument_list|(
name|cywakeup
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|cy_timeout
argument_list|)
expr_stmt|;
comment|/* 	 * Check for and log errors, but not too often. 	 */
if|if
condition|(
operator|--
name|cy_timeouts_until_log
operator|>
literal|0
condition|)
return|return;
name|cy_timeouts_until_log
operator|=
name|hz
operator|/
name|cy_timeout
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NPORTS
condition|;
operator|++
name|unit
control|)
block|{
name|int
name|errnum
decl_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|errnum
operator|=
literal|0
init|;
name|errnum
operator|<
name|CE_NTYPES
condition|;
operator|++
name|errnum
control|)
block|{
name|u_int
name|delta
decl_stmt|;
name|u_long
name|total
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
name|delta
operator|=
name|com
operator|->
name|delta_error_counts
index|[
name|errnum
index|]
expr_stmt|;
name|com
operator|->
name|delta_error_counts
index|[
name|errnum
index|]
operator|=
literal|0
expr_stmt|;
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|delta
operator|==
literal|0
condition|)
continue|continue;
name|total
operator|=
name|com
operator|->
name|error_counts
index|[
name|errnum
index|]
operator|+=
name|delta
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy%d: %u more %s%s (total %lu)\n"
argument_list|,
name|unit
argument_list|,
name|delta
argument_list|,
name|error_desc
index|[
name|errnum
index|]
argument_list|,
name|delta
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|total
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disc_optim
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|,
name|struct
name|com_s
modifier|*
name|com
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
name|u_char
name|opt
decl_stmt|;
endif|#
directive|endif
name|ttyldoptim
argument_list|(
name|tp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SOFT_HOTCHAR
name|opt
operator|=
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|&
operator|~
name|CD1400_COR3_SCD34
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|tp
operator|->
name|t_hotchar
operator|!=
literal|0
condition|)
block|{
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR3
argument_list|,
name|com
operator|->
name|tp
operator|->
name|t_hotchar
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SCHR4
argument_list|,
name|com
operator|->
name|tp
operator|->
name|t_hotchar
argument_list|)
expr_stmt|;
name|opt
operator||=
name|CD1400_COR3_SCD34
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|!=
name|com
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_COR3
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
operator|=
name|opt
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|com
argument_list|,
name|CD1400_CCR_CMDCORCHG
operator||
name|CD1400_CCR_COR3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|Smarts
end_ifdef

begin_comment
comment|/* standard line discipline input routine */
end_comment

begin_function
name|int
name|cyinput
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
comment|/* XXX duplicate ttyinput(), but without the IXOFF/IXON/ISTRIP/IPARMRK 	 * bits, as they are done by the CD1400.  Hardly worth the effort, 	 * given that high-throughput session are raw anyhow. 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Smarts */
end_comment

begin_function
specifier|static
name|int
name|cyspeed
parameter_list|(
name|speed_t
name|speed
parameter_list|,
name|u_long
name|cy_clock
parameter_list|,
name|int
modifier|*
name|prescaler_io
parameter_list|)
block|{
name|int
name|actual
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|divider
decl_stmt|;
name|int
name|prescaler
decl_stmt|;
name|int
name|prescaler_unit
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|speed
operator|<
literal|0
operator|||
name|speed
operator|>
literal|150000
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* determine which prescaler to use */
for|for
control|(
name|prescaler_unit
operator|=
literal|4
operator|,
name|prescaler
operator|=
literal|2048
init|;
name|prescaler_unit
condition|;
name|prescaler_unit
operator|--
operator|,
name|prescaler
operator|>>=
literal|2
control|)
block|{
if|if
condition|(
name|cy_clock
operator|/
name|prescaler
operator|/
name|speed
operator|>
literal|63
condition|)
break|break;
block|}
name|divider
operator|=
operator|(
name|cy_clock
operator|/
name|prescaler
operator|*
literal|2
operator|/
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* round off */
if|if
condition|(
name|divider
operator|>
literal|255
condition|)
name|divider
operator|=
literal|255
expr_stmt|;
name|actual
operator|=
name|cy_clock
operator|/
name|prescaler
operator|/
name|divider
expr_stmt|;
comment|/* 10 times error in percent: */
name|error
operator|=
operator|(
operator|(
name|actual
operator|-
operator|(
name|long
operator|)
name|speed
operator|)
operator|*
literal|2000
operator|/
operator|(
name|long
operator|)
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* 3.0% max error tolerance */
if|if
condition|(
name|error
operator|<
operator|-
literal|30
operator|||
name|error
operator|>
literal|30
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|prescaler_io
operator|=
name|prescaler_unit
expr_stmt|;
return|return
operator|(
name|divider
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd1400_channel_cmd
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|cd1400_channel_cmd_wait
argument_list|(
name|com
argument_list|)
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_CCR
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cd1400_channel_cmd_wait
argument_list|(
name|com
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd1400_channel_cmd_wait
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|)
block|{
name|struct
name|timeval
name|start
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|usec
decl_stmt|;
if|if
condition|(
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_CCR
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|microtime
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_CCR
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|usec
operator|=
literal|1000000
operator|*
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|start
operator|.
name|tv_sec
operator|)
operator|+
name|tv
operator|.
name|tv_usec
operator|-
name|start
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|usec
operator|>=
literal|5000
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy%d: channel command timeout (%ld usec)\n"
argument_list|,
name|com
operator|->
name|unit
argument_list|,
name|usec
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cd_etc
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|etc
parameter_list|)
block|{
comment|/* 	 * We can't change the hardware's ETC state while there are any 	 * characters in the tx fifo, since those characters would be 	 * interpreted as commands!  Unputting characters from the fifo 	 * is difficult, so we wait up to 12 character times for the fifo 	 * to drain.  The command will be delayed for up to 2 character 	 * times for the tx to become empty.  Unputting characters from 	 * the tx holding and shift registers is impossible, so we wait 	 * for the tx to become empty so that the command is sure to be 	 * executed soon after we issue it. 	 */
name|critical_enter
argument_list|()
expr_stmt|;
name|COM_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|etc
operator|==
name|etc
condition|)
goto|goto
name|wait
goto|;
if|if
condition|(
operator|(
name|etc
operator|==
name|CD1400_ETC_SENDBREAK
operator|&&
operator|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_STARTING
operator|||
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_STARTED
operator|)
operator|)
operator|||
operator|(
name|etc
operator|==
name|CD1400_ETC_STOPBREAK
operator|&&
operator|(
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDING
operator|||
name|com
operator|->
name|etc
operator|==
name|ETC_BREAK_ENDED
operator|||
name|com
operator|->
name|etc
operator|==
name|ETC_NONE
operator|)
operator|)
condition|)
block|{
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
return|return;
block|}
name|com
operator|->
name|etc
operator|=
name|etc
expr_stmt|;
name|cd_setreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|,
name|com
operator|->
name|intr_enable
operator|=
operator|(
name|com
operator|->
name|intr_enable
operator|&
operator|~
name|CD1400_SRER_TXRDY
operator|)
operator||
name|CD1400_SRER_TXMPTY
argument_list|)
expr_stmt|;
name|wait
label|:
name|COM_UNLOCK
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
while|while
condition|(
name|com
operator|->
name|etc
operator|==
name|etc
operator|&&
name|tsleep
argument_list|(
operator|&
name|com
operator|->
name|etc
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cyetc"
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
block|}
end_function

begin_function
specifier|static
name|int
name|cd_getreg
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|basecom
decl_stmt|;
name|u_char
name|car
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|need_unlock
decl_stmt|;
endif|#
directive|endif
name|int
name|val
decl_stmt|;
name|basecom
operator|=
name|cy_addr
argument_list|(
name|com
operator|->
name|unit
operator|&
operator|~
operator|(
name|CD1400_NO_OF_CHANNELS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|car
operator|=
name|com
operator|->
name|unit
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|cy_align
operator|=
name|com
operator|->
name|cy_align
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|need_unlock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_owned
argument_list|(
operator|&
name|cy_lock
argument_list|)
condition|)
block|{
name|COM_LOCK
argument_list|()
expr_stmt|;
name|need_unlock
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|basecom
operator|->
name|car
operator|!=
name|car
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|basecom
operator|->
name|car
operator|=
name|car
argument_list|)
expr_stmt|;
name|val
operator|=
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|reg
argument_list|,
name|cy_align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|need_unlock
condition|)
name|COM_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|critical_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd_setreg
parameter_list|(
name|struct
name|com_s
modifier|*
name|com
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|basecom
decl_stmt|;
name|u_char
name|car
decl_stmt|;
name|int
name|cy_align
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|need_unlock
decl_stmt|;
endif|#
directive|endif
name|basecom
operator|=
name|cy_addr
argument_list|(
name|com
operator|->
name|unit
operator|&
operator|~
operator|(
name|CD1400_NO_OF_CHANNELS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|car
operator|=
name|com
operator|->
name|unit
operator|&
name|CD1400_CAR_CHAN
expr_stmt|;
name|cy_align
operator|=
name|com
operator|->
name|cy_align
expr_stmt|;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|need_unlock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mtx_owned
argument_list|(
operator|&
name|cy_lock
argument_list|)
condition|)
block|{
name|COM_LOCK
argument_list|()
expr_stmt|;
name|need_unlock
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|basecom
operator|->
name|car
operator|!=
name|car
condition|)
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|CD1400_CAR
argument_list|,
name|cy_align
argument_list|,
name|basecom
operator|->
name|car
operator|=
name|car
argument_list|)
expr_stmt|;
name|cd_outb
argument_list|(
name|iobase
argument_list|,
name|reg
argument_list|,
name|cy_align
argument_list|,
name|val
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|need_unlock
condition|)
name|COM_UNLOCK
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_comment
comment|/* useful in ddb */
end_comment

begin_function
name|void
name|cystatus
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|com_s
modifier|*
name|com
decl_stmt|;
name|cy_addr
name|iobase
decl_stmt|;
name|u_int
name|ocount
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|com
operator|=
name|cy_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info for channel %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total cyclom service probes:\t%d\n"
argument_list|,
name|cy_svrr_probes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to upper layer:\t\t%d\n"
argument_list|,
name|cy_timeouts
argument_list|)
expr_stmt|;
if|if
condition|(
name|com
operator|==
name|NULL
condition|)
return|return;
name|iobase
operator|=
name|com
operator|->
name|iobase
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cd1400 base address:\\tt%p\n"
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved channel_control:\t\t0x%02x\n"
argument_list|,
name|com
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved cor1-3:\t\t\t0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|com
operator|->
name|cor
index|[
literal|0
index|]
argument_list|,
name|com
operator|->
name|cor
index|[
literal|1
index|]
argument_list|,
name|com
operator|->
name|cor
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request enable reg:\t0x%02x (0x%02x cached)\n"
argument_list|,
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_SRER
argument_list|)
argument_list|,
name|com
operator|->
name|intr_enable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request register:\t0x%02x\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_SVRR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem status:\t\t\t0x%02x (0x%02x cached)\n"
argument_list|,
name|cd_getreg
argument_list|(
name|com
argument_list|,
name|CD1400_MSVR2
argument_list|)
argument_list|,
name|com
operator|->
name|prev_modem_status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx/tx/mdm interrupt registers:\t0x%02x 0x%02x 0x%02x\n"
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_RIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_TIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|,
name|cd_inb
argument_list|(
name|iobase
argument_list|,
name|CD1400_MIR
argument_list|,
name|com
operator|->
name|cy_align
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"com state:\t\t\t0x%02x\n"
argument_list|,
name|com
operator|->
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to cystart():\t\t%d (%d useful)\n"
argument_list|,
name|com
operator|->
name|start_count
argument_list|,
name|com
operator|->
name|start_real
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx buffer chars free:\t\t%d\n"
argument_list|,
name|com
operator|->
name|iptr
operator|-
name|com
operator|->
name|ibuf
argument_list|)
expr_stmt|;
name|ocount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_queued
condition|)
name|ocount
operator|+=
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_tail
operator|-
name|com
operator|->
name|obufs
index|[
literal|0
index|]
operator|.
name|l_head
expr_stmt|;
if|if
condition|(
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_queued
condition|)
name|ocount
operator|+=
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_tail
operator|-
name|com
operator|->
name|obufs
index|[
literal|1
index|]
operator|.
name|l_head
expr_stmt|;
name|printf
argument_list|(
literal|"tx buffer chars:\t\t%u\n"
argument_list|,
name|ocount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received chars:\t\t\t%d\n"
argument_list|,
name|com
operator|->
name|bytes_in
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"received exceptions:\t\t%d\n"
argument_list|,
name|com
operator|->
name|recv_exception
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem signal deltas:\t\t%d\n"
argument_list|,
name|com
operator|->
name|mdm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"transmitted chars:\t\t%d\n"
argument_list|,
name|com
operator|->
name|bytes_out
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|tp
operator|=
name|com
operator|->
name|tp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"tty state:\t\t\t0x%08x\n"
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"upper layer queue lengths:\t%d raw, %d canon, %d output\n"
argument_list|,
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"tty state:\t\t\tclosed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CyDebug */
end_comment

end_unit

