begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2014 Bjoern A. Zeeb  * All rights reserved.  *  * This software was developed by SRI International and the University of  * Cambridge Computer Laboratory under DARPA/AFRL contract FA8750-11-C-0249  * ("MRC2"), as part of the DARPA MRC research programme.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This driver is modelled after atse(4).  We need to seriously reduce the  * per-driver code we have to write^wcopy& paste.  *  * TODO:  * - figure out on the HW side why some data is LE and some is BE.  * - general set of improvements possible (e.g., reduce times of copying,  *   do on-the-copy checksum calculations)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|"opt_netfpga.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"if_nf10bmacreg.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NF10BMAC_MAX_PKTS
end_ifndef

begin_comment
comment|/*  * We have a 4k buffer in HW, so do not try to send more than 3 packets.  * At the time of writing HW is orders of magnitude faster than we can  * enqueue so it would not matter but need an escape.  */
end_comment

begin_define
define|#
directive|define
name|NF10BMAC_MAX_PKTS
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NF10BMAC_WATCHDOG_TIME
end_ifndef

begin_define
define|#
directive|define
name|NF10BMAC_WATCHDOG_TIME
value|5
end_define

begin_comment
comment|/* seconds */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_decl_stmt
specifier|static
name|poll_handler_t
name|nf10bmac_poll
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NF10BMAC_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->nf10bmac_mtx)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->nf10bmac_mtx)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_LOCK_ASSERT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|mtx_assert(&(_sc)->nf10bmac_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_CTRL0
value|0x00
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TX_DATA
value|0x00
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TX_META
value|0x08
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TX_LEN
value|0x10
end_define

begin_define
define|#
directive|define
name|NF10BMAC_RX_DATA
value|0x00
end_define

begin_define
define|#
directive|define
name|NF10BMAC_RX_META
value|0x08
end_define

begin_define
define|#
directive|define
name|NF10BMAC_RX_LEN
value|0x10
end_define

begin_define
define|#
directive|define
name|NF10BMAC_INTR_CLEAR_DIS
value|0x00
end_define

begin_define
define|#
directive|define
name|NF10BMAC_INTR_CTRL
value|0x08
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_MAC0
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_CPU0
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_MAC1
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_CPU1
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_MAC2
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_CPU2
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_MAC3
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_TUSER_CPU3
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_DATA_LEN_MASK
value|0x0000ffff
end_define

begin_define
define|#
directive|define
name|NF10BMAC_DATA_DPORT_MASK
value|0xff000000
end_define

begin_define
define|#
directive|define
name|NF10BMAC_DATA_DPORT_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|NF10BMAC_DATA_SPORT_MASK
value|0x00ff0000
end_define

begin_define
define|#
directive|define
name|NF10BMAC_DATA_SPORT_SHIFT
value|16
end_define

begin_define
define|#
directive|define
name|NF10BMAC_DATA_LAST
value|0x00008000
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NF10BMAC_64BIT
end_ifdef

begin_define
define|#
directive|define
name|NF10BMAC_DATA_STRB
value|0x000000ff
end_define

begin_define
define|#
directive|define
name|REGWTYPE
value|uint64_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NF10BMAC_DATA_STRB
value|0x0000000f
end_define

begin_define
define|#
directive|define
name|REGWTYPE
value|uint32_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|nf10bmac_write
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|REGWTYPE
name|reg
parameter_list|,
name|REGWTYPE
name|val
parameter_list|,
specifier|const
name|char
modifier|*
name|f
name|__unused
parameter_list|,
specifier|const
name|int
name|l
name|__unused
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NF10BMAC_64BIT
name|bus_write_8
argument_list|(
name|res
argument_list|,
name|reg
argument_list|,
name|htole64
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|reg
argument_list|,
name|htole32
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|REGWTYPE
name|nf10bmac_read
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|REGWTYPE
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
name|f
name|__unused
parameter_list|,
specifier|const
name|int
name|l
name|__unused
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NF10BMAC_64BIT
return|return
operator|(
name|le64toh
argument_list|(
name|bus_read_8
argument_list|(
name|res
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|le32toh
argument_list|(
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nf10bmac_write_be
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|REGWTYPE
name|reg
parameter_list|,
name|REGWTYPE
name|val
parameter_list|,
specifier|const
name|char
modifier|*
name|f
name|__unused
parameter_list|,
specifier|const
name|int
name|l
name|__unused
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NF10BMAC_64BIT
name|bus_write_8
argument_list|(
name|res
argument_list|,
name|reg
argument_list|,
name|htobe64
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bus_write_4
argument_list|(
name|res
argument_list|,
name|reg
argument_list|,
name|htobe32
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|REGWTYPE
name|nf10bmac_read_be
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|REGWTYPE
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
name|f
name|__unused
parameter_list|,
specifier|const
name|int
name|l
name|__unused
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NF10BMAC_64BIT
return|return
operator|(
name|be64toh
argument_list|(
name|bus_read_8
argument_list|(
name|res
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|be32toh
argument_list|(
name|bus_read_4
argument_list|(
name|res
argument_list|,
name|reg
argument_list|)
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|NF10BMAC_WRITE_CTRL
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|nf10bmac_write((sc)->nf10bmac_ctrl_res, (reg), (val),		\ 	    __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_WRITE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|nf10bmac_write((sc)->nf10bmac_tx_mem_res, (reg), (val),		\ 	    __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_READ
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|nf10bmac_read((sc)->nf10bmac_rx_mem_res, (reg),			\ 	    __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_WRITE_BE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|nf10bmac_write_be((sc)->nf10bmac_tx_mem_res, (reg), (val),	\ 	    __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_READ_BE
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|nf10bmac_read_be((sc)->nf10bmac_rx_mem_res, (reg),		\ 	    __func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_WRITE_INTR
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|,
name|_f
parameter_list|,
name|_l
parameter_list|)
define|\
value|nf10bmac_write((sc)->nf10bmac_intr_res, (reg), (val),		\ 	    (_f), (_l))
end_define

begin_define
define|#
directive|define
name|NF10BMAC_RX_INTR_CLEAR_DIS
parameter_list|(
name|sc
parameter_list|)
define|\
value|NF10BMAC_WRITE_INTR((sc), NF10BMAC_INTR_CLEAR_DIS, 1,		\ 	__func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_RX_INTR_ENABLE
parameter_list|(
name|sc
parameter_list|)
define|\
value|NF10BMAC_WRITE_INTR((sc), NF10BMAC_INTR_CTRL, 1,		\ 	__func__, __LINE__)
end_define

begin_define
define|#
directive|define
name|NF10BMAC_RX_INTR_DISABLE
parameter_list|(
name|sc
parameter_list|)
define|\
value|NF10BMAC_WRITE_INTR((sc), NF10BMAC_INTR_CTRL, 0,		\ 	__func__, __LINE__)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
end_ifdef

begin_function_decl
specifier|static
name|void
name|nf10bmac_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|nf10bmac_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|nf10bmac_devclass
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nf10bmac_tx_locked
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int32_t
name|len
decl_stmt|,
name|l
decl_stmt|,
name|ml
decl_stmt|;
name|REGWTYPE
name|md
decl_stmt|,
name|val
decl_stmt|;
name|NF10BMAC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: m is null: sc=%p"
operator|,
name|__func__
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|,
operator|(
literal|"%s: not a pkthdr: m=%p"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy to buffer to minimize our pain as we can only store 	 * double words which, after the first mbuf gets out of alignment 	 * quite quickly. 	 */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|sc
operator|->
name|nf10bmac_tx_buf
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Write the length at start of packet. */
name|NF10BMAC_WRITE
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_TX_LEN
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the meta data and data. */
name|ml
operator|=
name|len
operator|/
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|len
operator|-=
operator|(
name|ml
operator|*
sizeof|sizeof
argument_list|(
name|val
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<=
name|ml
condition|;
name|l
operator|++
control|)
block|{
name|int32_t
name|cl
decl_stmt|;
name|cl
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|md
operator|=
operator|(
name|NF10BMAC_TUSER_CPU0
operator|<<
name|NF10BMAC_DATA_SPORT_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|ml
operator|||
operator|(
name|len
operator|==
literal|0
operator|&&
name|l
operator|==
operator|(
name|ml
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|l
operator|==
name|ml
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|uint8_t
name|s
decl_stmt|;
name|int
name|sl
decl_stmt|;
if|if
condition|(
name|l
operator|==
operator|(
name|ml
operator|-
literal|1
operator|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|cl
operator|=
name|len
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
operator|,
name|sl
operator|=
name|len
init|;
name|sl
operator|>
literal|0
condition|;
name|sl
operator|--
control|)
name|s
operator||=
operator|(
literal|1
operator|<<
operator|(
name|sl
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|md
operator||=
operator|(
name|s
operator|&
name|NF10BMAC_DATA_STRB
operator|)
expr_stmt|;
name|md
operator||=
name|NF10BMAC_DATA_LAST
expr_stmt|;
block|}
block|}
else|else
block|{
name|md
operator||=
name|NF10BMAC_DATA_STRB
expr_stmt|;
block|}
name|NF10BMAC_WRITE
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_TX_META
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_tx_buf
index|[
name|l
operator|*
sizeof|sizeof
argument_list|(
name|val
argument_list|)
index|]
argument_list|,
operator|&
name|val
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|NF10BMAC_WRITE_BE
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_TX_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* If anyone is interested give them a copy. */
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|nf10bmac_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|NF10BMAC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc
operator|->
name|nf10bmac_flags
operator|&
name|NF10BMAC_FLAGS_LINK
operator|)
operator|==
literal|0
condition|)
return|return;
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
comment|/* 	 * Disable the watchdog while sending, we are batching packets. 	 * Though we should never reach 5 seconds, and are holding the lock, 	 * but who knows. 	 */
name|sc
operator|->
name|nf10bmac_watchdog_timer
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Send up to MAX_PKTS_PER_TX_LOOP packets. */
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
operator|&&
name|count
operator|<
name|NF10BMAC_MAX_PKTS
condition|;
name|count
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|error
operator|=
name|nf10bmac_tx_locked
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
name|done
label|:
comment|/* If the IP core walks into Nekromanteion try to bail out. */
comment|/* XXX-BZ useless until we have direct FIFO fill status feedback. */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|sc
operator|->
name|nf10bmac_watchdog_timer
operator|=
name|NF10BMAC_WATCHDOG_TIME
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nf10bmac_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_eat_packet_munch_munch
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|REGWTYPE
name|md
decl_stmt|,
name|val
decl_stmt|;
do|do
block|{
name|md
operator|=
name|NF10BMAC_READ_BE
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_META
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|!=
literal|0
condition|)
name|val
operator|=
name|NF10BMAC_READ_BE
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_DATA
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|md
operator|&
name|NF10BMAC_DATA_LAST
operator|)
operator|==
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|nf10bmac_rx_locked
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|REGWTYPE
name|md
decl_stmt|,
name|val
decl_stmt|;
name|int32_t
name|len
decl_stmt|,
name|l
decl_stmt|;
comment|/* 	 * General problem here in case we need to sync ourselves to the 	 * beginning of a packet.  Length will only be set for the first 	 * read, and together with strb we can detect the begining (or 	 * skip to tlast). 	 */
name|len
operator|=
name|NF10BMAC_READ
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_LEN
argument_list|)
operator|&
name|NF10BMAC_DATA_LEN_MASK
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|MCLBYTES
operator|-
name|ETHER_ALIGN
operator|)
condition|)
block|{
name|nf10bmac_eat_packet_munch_munch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|md
operator|=
name|NF10BMAC_READ
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_META
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* No packet data available. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We are in the middle of a packet. */
name|nf10bmac_eat_packet_munch_munch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Invalid length "hint". */
name|device_printf
argument_list|(
name|sc
operator|->
name|nf10bmac_dev
argument_list|,
literal|"Unexpected length %d on zero strb\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Assume at this point that we have data and a full packet. */
if|if
condition|(
operator|(
name|len
operator|+
name|ETHER_ALIGN
operator|)
operator|>=
name|MINCLSIZE
condition|)
block|{
comment|/* Get a cluster. */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
comment|/* Hey this still fits into the mbuf+pkthdr. */
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MHLEN
expr_stmt|;
block|}
comment|/* Make sure upper layers will be aligned. */
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
comment|/* 	while ((md& NF10BMAC_DATA_STRB) != 0&& l< len) { */
while|while
condition|(
name|l
operator|<
name|len
condition|)
block|{
name|size_t
name|cl
decl_stmt|;
if|if
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_LAST
operator|)
operator|==
literal|0
operator|&&
operator|(
name|len
operator|-
name|l
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|val
argument_list|)
condition|)
block|{
comment|/* 			 * Our length and LAST disagree. We have a valid STRB. 			 * We could continue until we fill the mbuf and just 			 * log the invlid length "hint".  For now drop the 			 * packet on the floor and count the error. 			 */
name|nf10bmac_eat_packet_munch_munch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|len
operator|-
name|l
operator|)
operator|<=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|cl
operator|=
name|len
operator|-
name|l
expr_stmt|;
block|}
else|else
block|{
name|cl
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Read the first bytes of data as well. */
name|val
operator|=
name|NF10BMAC_READ_BE
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_DATA
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|l
operator|)
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|l
operator|+=
name|cl
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_LAST
operator|)
operator|!=
literal|0
operator|||
name|l
operator|>=
name|len
condition|)
break|break;
else|else
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|md
operator|=
name|NF10BMAC_READ
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_META
argument_list|)
expr_stmt|;
block|}
name|cl
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|==
literal|0
operator|&&
name|cl
operator|--
operator|>
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|md
operator|=
name|NF10BMAC_READ
argument_list|(
name|sc
argument_list|,
name|NF10BMAC_RX_META
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We should get out of this loop with tlast and tsrb. */
if|if
condition|(
operator|(
name|md
operator|&
name|NF10BMAC_DATA_LAST
operator|)
operator|==
literal|0
operator|||
operator|(
name|md
operator|&
name|NF10BMAC_DATA_STRB
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|nf10bmac_dev
argument_list|,
literal|"Unexpected rx loop end state: "
literal|"md=0x%08jx len=%d l=%d\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|md
argument_list|,
name|len
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nf10bmac_stop_locked
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|NF10BMAC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
name|sc
operator|->
name|nf10bmac_watchdog_timer
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|NF10BMAC_RX_INTR_CLEAR_DIS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_flags
operator|&=
operator|~
name|NF10BMAC_FLAGS_LINK
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nf10bmac_reset
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * If we do not have an ether address set, initialize to the same 	 * OUI as NetFPGA-10G Linux driver does (which luckily seems 	 * unallocated).  We just change the NIC specific part from 	 * the slightly long "\0NF10C0" to "\0NFBSD". 	 * Oh and we keep the way of setting it from a string as they do. 	 * It's an amazing way to hide it. 	 * XXX-BZ If NetFPGA gets their own OUI we should fix this. 	 */
if|if
condition|(
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|2
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|3
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|4
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|5
index|]
operator|==
literal|0x00
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_eth_addr
argument_list|,
literal|"\0NFBSD"
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_eth_addr
index|[
literal|5
index|]
operator|+=
name|sc
operator|->
name|nf10bmac_unit
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_init_locked
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|;
name|NF10BMAC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Must update the ether address if changed.  Given we do not handle 	 * in nf10bmac_ioctl() but it's in the general framework, just always 	 * do it here before nf10bmac_reset(). 	 */
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|nf10bmac_ifp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|eaddr
argument_list|,
operator|&
name|sc
operator|->
name|nf10bmac_eth_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* XXX-BZ we do not have any way to tell the NIC our ether address. */
comment|/* Make things frind to halt, cleanup, ... */
name|nf10bmac_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* ... reset, ... */
name|nf10bmac_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Memory rings?  DMA engine? MC filter?  MII? */
comment|/* Instead drain the FIFO; or at least a possible first packet.. */
name|nf10bmac_eat_packet_munch_munch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* Only enable interrupts if we are not polling. */
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|NF10BMAC_RX_INTR_CLEAR_DIS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|NF10BMAC_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* We have no underlying media, fake link state. */
name|sc
operator|->
name|nf10bmac_flags
operator|=
name|NF10BMAC_FLAGS_LINK
expr_stmt|;
comment|/* Always up. */
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|nf10bmac_ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_tick
argument_list|,
name|hz
argument_list|,
name|nf10bmac_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|nf10bmac_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nf10bmac_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
end_ifdef

begin_function
specifier|static
name|void
name|nf10bmac_watchdog
parameter_list|(
name|struct
name|nf10bmac_softc
modifier|*
name|sc
parameter_list|)
block|{
name|NF10BMAC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nf10bmac_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|nf10bmac_watchdog_timer
operator|>
literal|0
condition|)
return|return;
name|device_printf
argument_list|(
name|sc
operator|->
name|nf10bmac_dev
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|nf10bmac_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|nf10bmac_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|nf10bmac_start_locked
argument_list|(
name|sc
operator|->
name|nf10bmac_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_tick
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|nf10bmac_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|NF10BMAC_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
expr_stmt|;
name|nf10bmac_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_tick
argument_list|,
name|hz
argument_list|,
name|nf10bmac_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|nf10bmac_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rx_npkts
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|nf10bmac_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
expr_stmt|;
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
block|{
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* NF10BMAC_RX_INTR_DISABLE(sc); */
name|NF10BMAC_RX_INTR_CLEAR_DIS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* We only have an RX interrupt and no status information. */
name|rx_npkts
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rx_npkts
operator|<
name|NF10BMAC_MAX_PKTS
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|nf10bmac_rx_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx_npkts
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
comment|/* Re-enable interrupts. */
name|NF10BMAC_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|nf10bmac_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|int
name|nf10bmac_poll
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rx_npkts
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
while|while
condition|(
name|rx_npkts
operator|<
name|count
condition|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|nf10bmac_rx_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rx_npkts
operator|+=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
block|}
name|nf10bmac_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_npkts
operator|>
literal|0
operator|||
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
comment|/* We currently cannot do much. */
empty_stmt|;
block|}
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|We only support polling mode
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEVICE_POLLING */
end_comment

begin_function
specifier|static
name|int
name|nf10bmac_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{
comment|/* Do nothing. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nf10bmac_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|imr
parameter_list|)
block|{
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_10G_T
operator||
name|IFM_FDX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nf10bmac_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|nf10bmac_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* Nothing we can do. */
empty_stmt|;
else|else
name|nf10bmac_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|nf10bmac_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_POLLING
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_POLLING
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_POLLING
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|nf10bmac_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|NF10BMAC_RX_INTR_CLEAR_DIS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 			 * Do not allow disabling of polling if we do 			 * not have interrupts. 			 */
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|nf10bmac_rx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|NF10BMAC_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_POLLING
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* DEVICE_POLLING */
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|nf10bmac_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic device handling routines.  */
end_comment

begin_function
name|int
name|nf10bmac_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_tick
argument_list|,
operator|&
name|sc
operator|->
name|nf10bmac_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|nf10bmac_tx_buf
operator|=
name|malloc
argument_list|(
name|ETHER_MAX_LEN_JUMBO
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Reset the adapter. */
name|nf10bmac_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Setup interface. */
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"if_alloc() failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
comment|/* | IFF_MULTICAST; */
name|ifp
operator|->
name|if_ioctl
operator|=
name|nf10bmac_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|nf10bmac_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|nf10bmac_init
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|NF10BMAC_MAX_PKTS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|NF10BMAC_MAX_PKTS
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* Call media-indepedent attach routine. */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|nf10bmac_eth_addr
argument_list|)
expr_stmt|;
comment|/* Tell the upper layer(s) about vlan mtu support. */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* We will enable polling by default if no irqs available. See below. */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_POLLING
expr_stmt|;
endif|#
directive|endif
comment|/* We need more media attention.  Fake it! */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_media
argument_list|,
literal|0
argument_list|,
name|nf10bmac_media_change
argument_list|,
name|nf10bmac_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_10G_T
argument_list|)
expr_stmt|;
comment|/* Initialise. */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Hook up interrupts. Well the one. */
if|if
condition|(
name|sc
operator|->
name|nf10bmac_rx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|nf10bmac_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|nf10bmac_rx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"enabling RX IRQ failed\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
operator|||
name|sc
operator|->
name|nf10bmac_rx_irq_res
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* If not on and no IRQs force it on. */
if|if
condition|(
name|sc
operator|->
name|nf10bmac_rx_irq_res
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_POLLING
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"forcing to polling due to no interrupts\n"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ether_poll_register
argument_list|(
name|nf10bmac_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
else|#
directive|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no DEVICE_POLLING in kernel and no IRQs\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|NF10BMAC_RX_INTR_ENABLE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|err
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|nf10bmac_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nf10bmac_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx_initialized
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_mtx
argument_list|)
argument_list|,
operator|(
literal|"%s: mutex not initialized"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|nf10bmac_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_POLLING
condition|)
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Only cleanup if attach succeeded. */
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|NF10BMAC_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|nf10bmac_stop_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NF10BMAC_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_WATCHDOG
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_tick
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nf10bmac_rx_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_irq_res
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_media
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|nf10bmac_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Shared with the attachment specific (e.g., fdt) implementation. */
end_comment

begin_function
name|void
name|nf10bmac_detach_resources
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|nf10bmac_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nf10bmac_rx_irq_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_irq_rid
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_rx_irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nf10bmac_intr_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|nf10bmac_intr_rid
argument_list|,
name|sc
operator|->
name|nf10bmac_intr_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_intr_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nf10bmac_rx_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_mem_rid
argument_list|,
name|sc
operator|->
name|nf10bmac_rx_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_rx_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nf10bmac_tx_mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|nf10bmac_tx_mem_rid
argument_list|,
name|sc
operator|->
name|nf10bmac_tx_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_tx_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|nf10bmac_ctrl_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|nf10bmac_ctrl_rid
argument_list|,
name|sc
operator|->
name|nf10bmac_ctrl_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nf10bmac_ctrl_res
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|nf10bmac_detach_dev
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nf10bmac_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* We are basically in undefined state now. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"nf10bmac_detach() failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nf10bmac_detach_resources
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end */
end_comment

end_unit

