begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998,1999,2000 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"ata.h"
end_include

begin_include
include|#
directive|include
file|"isa.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_include
include|#
directive|include
file|"atadisk.h"
end_include

begin_include
include|#
directive|include
file|"atapicd.h"
end_include

begin_include
include|#
directive|include
file|"atapifd.h"
end_include

begin_include
include|#
directive|include
file|"atapist.h"
end_include

begin_include
include|#
directive|include
file|"opt_global.h"
end_include

begin_include
include|#
directive|include
file|"opt_ata.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ata/ata-all.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/atapi-all.h>
end_include

begin_comment
comment|/* misc defines */
end_comment

begin_define
define|#
directive|define
name|IOMASK
value|0xfffffffc
end_define

begin_define
define|#
directive|define
name|ATA_IOADDR_RID
value|0
end_define

begin_define
define|#
directive|define
name|ATA_ALTADDR_RID
value|1
end_define

begin_define
define|#
directive|define
name|ATA_BMADDR_RID
value|2
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|ata_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_boot_attach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_getparam
parameter_list|(
name|struct
name|ata_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_service
parameter_list|(
name|struct
name|ata_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|active2str
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bswap
parameter_list|(
name|int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|btrim
parameter_list|(
name|int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpack
parameter_list|(
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local vars */
end_comment

begin_decl_stmt
specifier|static
name|devclass_t
name|ata_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ata_pci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|intr_config_hook
modifier|*
name|ata_delayed_attach
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ata_conf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ATA
argument_list|,
literal|"ATA generic"
argument_list|,
literal|"ATA driver generic layer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|NISA
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|ata_ids
index|[]
init|=
block|{
block|{
literal|0x0006d041
block|,
literal|"Generic ESDI/IDE/ATA controller"
block|}
block|,
comment|/* PNP0600 */
block|{
literal|0x0106d041
block|,
literal|"Plus Hardcard II"
block|}
block|,
comment|/* PNP0601 */
block|{
literal|0x0206d041
block|,
literal|"Plus Hardcard IIXL/EZ"
block|}
block|,
comment|/* PNP0602 */
block|{
literal|0x0306d041
block|,
literal|"Generic ATA"
block|}
block|,
comment|/* PNP0603 */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ata_isa_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|port
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|u_long
name|tmp
decl_stmt|;
comment|/* check isapnp ids */
if|if
condition|(
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|ata_ids
argument_list|)
operator|==
name|ENXIO
condition|)
return|return
name|ENXIO
return|;
comment|/* allocate the port range */
name|rid
operator|=
name|ATA_IOADDR_RID
expr_stmt|;
name|port
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ATA_IOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
return|return
name|ENOMEM
return|;
comment|/* alloctate the altport range */
if|if
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
block|{
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|1
argument_list|,
name|rman_get_start
argument_list|(
name|port
argument_list|)
operator|+
name|ATA_ALTOFFSET
argument_list|,
name|ATA_ALTIOSIZE
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|scp
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|scp
operator|->
name|flags
operator||=
name|ATA_USE_16BIT
expr_stmt|;
return|return
name|ata_probe
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ata_isa_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ata_isa_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ata_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ata_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ata_isa_driver
init|=
block|{
literal|"ata"
block|,
name|ata_isa_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata
argument_list|,
name|isa
argument_list|,
name|ata_isa_driver
argument_list|,
name|ata_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|ata_pccard_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|port
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|len
decl_stmt|;
comment|/* allocate the port range */
name|rid
operator|=
name|ATA_IOADDR_RID
expr_stmt|;
name|len
operator|=
name|bus_get_resource_count
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|port
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|len
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
return|return
name|ENOMEM
return|;
comment|/*       * if we got more than the default ATA_IOSIZE ports, this is likely      * a pccard system where the altio ports are located just after the      * normal io ports, so no need to allocate them.      */
if|if
condition|(
name|len
operator|<=
name|ATA_IOSIZE
condition|)
block|{
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_ALTADDR_RID
argument_list|,
name|rman_get_start
argument_list|(
name|port
argument_list|)
operator|+
name|ATA_ALTOFFSET
argument_list|,
name|ATA_ALTIOSIZE
argument_list|)
expr_stmt|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|scp
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|scp
operator|->
name|flags
operator||=
name|ATA_USE_16BIT
expr_stmt|;
return|return
name|ata_probe
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ata_pccard_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ata_pccard_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ata_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ata_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ata_pccard_driver
init|=
block|{
literal|"ata"
block|,
name|ata_pccard_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata
argument_list|,
name|pccard
argument_list|,
name|ata_pccard_driver
argument_list|,
name|ata_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_struct
struct|struct
name|ata_pci_softc
block|{
name|struct
name|resource
modifier|*
name|bmio
decl_stmt|;
name|struct
name|resource
name|bmio_1
decl_stmt|;
name|struct
name|resource
name|bmio_2
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq
decl_stmt|;
name|int
name|irqcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ata_find_dev
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|type
parameter_list|,
name|u_int32_t
name|revid
parameter_list|)
block|{
name|device_t
modifier|*
name|children
decl_stmt|,
name|child
decl_stmt|;
name|int
name|nchildren
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|device_get_children
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nchildren
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
block|{
name|child
operator|=
name|children
index|[
name|i
index|]
expr_stmt|;
comment|/* check that it's on the same silicon and the device we want */
if|if
condition|(
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|==
name|pci_get_slot
argument_list|(
name|child
argument_list|)
operator|&&
name|pci_get_vendor
argument_list|(
name|child
argument_list|)
operator|==
operator|(
name|type
operator|&
literal|0xffff
operator|)
operator|&&
name|pci_get_device
argument_list|(
name|child
argument_list|)
operator|==
operator|(
operator|(
name|type
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
operator|)
operator|&&
name|pci_get_revid
argument_list|(
name|child
argument_list|)
operator|>=
name|revid
condition|)
block|{
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ata_pci_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIC_STORAGE
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* supported chipsets */
case|case
literal|0x12308086
case|:
return|return
literal|"Intel PIIX ATA controller"
return|;
case|case
literal|0x70108086
case|:
return|return
literal|"Intel PIIX3 ATA controller"
return|;
case|case
literal|0x71118086
case|:
case|case
literal|0x71998086
case|:
return|return
literal|"Intel PIIX4 ATA33 controller"
return|;
case|case
literal|0x24218086
case|:
return|return
literal|"Intel ICH0 ATA33 controller"
return|;
case|case
literal|0x24118086
case|:
return|return
literal|"Intel ICH ATA66 controller"
return|;
case|case
literal|0x244b8086
case|:
return|return
literal|"Intel ICH2 ATA100 controller"
return|;
case|case
literal|0x522910b9
case|:
return|return
literal|"AcerLabs Aladdin ATA33 controller"
return|;
case|case
literal|0x05711106
case|:
if|if
condition|(
name|ata_find_dev
argument_list|(
name|dev
argument_list|,
literal|0x05861106
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|"VIA 82C586 ATA33 controller"
return|;
if|if
condition|(
name|ata_find_dev
argument_list|(
name|dev
argument_list|,
literal|0x05961106
argument_list|,
literal|0x12
argument_list|)
condition|)
return|return
literal|"VIA 82C596 ATA66 controller"
return|;
if|if
condition|(
name|ata_find_dev
argument_list|(
name|dev
argument_list|,
literal|0x05961106
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|"VIA 82C596 ATA33 controller"
return|;
if|if
condition|(
name|ata_find_dev
argument_list|(
name|dev
argument_list|,
literal|0x06861106
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|"VIA 82C686 ATA66 controller"
return|;
return|return
literal|"VIA Apollo ATA controller"
return|;
case|case
literal|0x55131039
case|:
return|return
literal|"SiS 5591 ATA33 controller"
return|;
case|case
literal|0x06461095
case|:
return|return
literal|"CMD 646 ATA controller"
return|;
case|case
literal|0xc6931080
case|:
if|if
condition|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_STORAGE_IDE
condition|)
return|return
literal|"Cypress 82C693 ATA controller"
return|;
break|break;
case|case
literal|0x01021078
case|:
return|return
literal|"Cyrix 5530 ATA33 controller"
return|;
case|case
literal|0x74091022
case|:
return|return
literal|"AMD 756 ATA66 controller"
return|;
case|case
literal|0x4d33105a
case|:
return|return
literal|"Promise ATA33 controller"
return|;
case|case
literal|0x4d38105a
case|:
return|return
literal|"Promise ATA66 controller"
return|;
case|case
literal|0x0d30105a
case|:
case|case
literal|0x4d30105a
case|:
return|return
literal|"Promise ATA100 controller"
return|;
case|case
literal|0x00041103
case|:
switch|switch
condition|(
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x01
case|:
return|return
literal|"HighPoint HPT366 ATA66 controller"
return|;
case|case
literal|0x02
case|:
return|return
literal|"HighPoint HPT368 ATA66 controller"
return|;
case|case
literal|0x03
case|:
case|case
literal|0x04
case|:
return|return
literal|"HighPoint HPT370 ATA100 controller"
return|;
default|default:
return|return
literal|"Unknown revision HighPoint ATA controller"
return|;
block|}
comment|/* unsupported but known chipsets, generic DMA only */
case|case
literal|0x10001042
case|:
case|case
literal|0x10011042
case|:
return|return
literal|"RZ 100? ATA controller !WARNING! buggy chip data loss possible"
return|;
case|case
literal|0x06401095
case|:
return|return
literal|"CMD 640 ATA controller !WARNING! buggy chip data loss possible"
return|;
comment|/* unknown chipsets, try generic DMA if it seems possible */
default|default:
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_STORAGE
operator|&&
operator|(
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_STORAGE_IDE
operator|)
condition|)
return|return
literal|"Generic PCI ATA controller"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|desc
init|=
name|ata_pci_match
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|desc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_add_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
comment|/* check if this is located at one of the std addresses */
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ata"
argument_list|,
name|unit
argument_list|)
operator|)
condition|)
return|return
name|ENOMEM
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ata"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
return|return
name|ENOMEM
return|;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int8_t
name|class
decl_stmt|,
name|subclass
decl_stmt|;
name|u_int32_t
name|type
decl_stmt|,
name|cmd
decl_stmt|;
name|int
name|rid
decl_stmt|;
comment|/* set up vendor-specific stuff */
name|type
operator|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|class
operator|=
name|pci_get_class
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|subclass
operator|=
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* is this controller busmaster DMA capable ? */
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
condition|)
block|{
comment|/* is busmastering support turned on ? */
if|if
condition|(
operator|(
name|cmd
operator|&
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
operator|)
operator|==
operator|(
name|PCIM_CMD_PORTEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator|)
condition|)
block|{
comment|/* is there a valid port range to connect to ? */
name|rid
operator|=
literal|0x20
expr_stmt|;
name|sc
operator|->
name|bmio
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|bmio
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Busmastering DMA not configured\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Busmastering DMA not enabled\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
literal|0x4d33105a
operator|||
name|type
operator|==
literal|0x4d38105a
operator|||
name|type
operator|==
literal|0x4d30105a
operator|||
name|type
operator|==
literal|0x0d30105a
operator|||
name|type
operator|==
literal|0x00041103
condition|)
block|{
comment|/* Promise and HighPoint controllers support busmastering DMA */
name|rid
operator|=
literal|0x20
expr_stmt|;
name|sc
operator|->
name|bmio
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we dont know this controller, no busmastering DMA */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Busmastering DMA not supported\n"
argument_list|)
expr_stmt|;
block|}
comment|/* do extra chipset specific setups */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x522910b9
case|:
comment|/* Aladdin need to activate the ATAPI FIFO */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x53
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x53
argument_list|,
literal|1
argument_list|)
operator|&
operator|~
literal|0x01
operator|)
operator||
literal|0x02
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4d38105a
case|:
comment|/* Promise 66& 100 need their clock changed */
case|case
literal|0x4d30105a
case|:
case|case
literal|0x0d30105a
case|:
name|outb
argument_list|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|bmio
argument_list|)
operator|+
literal|0x11
argument_list|,
name|inb
argument_list|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|bmio
argument_list|)
operator|+
literal|0x11
argument_list|)
operator||
literal|0x0a
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0x4d33105a
case|:
comment|/* Promise (all) need burst mode to be turned on */
name|outb
argument_list|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|bmio
argument_list|)
operator|+
literal|0x1f
argument_list|,
name|inb
argument_list|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|bmio
argument_list|)
operator|+
literal|0x1f
argument_list|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00041103
case|:
comment|/* HighPoint */
switch|switch
condition|(
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x01
case|:
comment|/* turn off interrupt prediction */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x51
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x51
argument_list|,
literal|1
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
case|case
literal|0x03
case|:
case|case
literal|0x04
case|:
comment|/* turn off interrupt prediction */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x51
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x51
argument_list|,
literal|1
argument_list|)
operator|&
operator|~
literal|0x02
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x55
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x55
argument_list|,
literal|1
argument_list|)
operator|&
operator|~
literal|0x02
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* turn on interrupts */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x5a
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x5a
argument_list|,
literal|1
argument_list|)
operator|&
operator|~
literal|0x10
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x05711106
case|:
case|case
literal|0x74091022
case|:
comment|/* VIA 82C586, 82C596, 82C686& AMD 756 default setup */
comment|/* set prefetch, postwrite */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x41
argument_list|,
literal|1
argument_list|)
operator||
literal|0xf0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set fifo configuration half'n'half */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x43
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x43
argument_list|,
literal|1
argument_list|)
operator|&
literal|0x90
operator|)
operator||
literal|0x2a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set status register read retry */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x44
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x44
argument_list|,
literal|1
argument_list|)
operator||
literal|0x08
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set DMA read& end-of-sector fifo flush */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x46
argument_list|,
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x46
argument_list|,
literal|1
argument_list|)
operator|&
literal|0x0c
operator|)
operator||
literal|0xf0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set sector size */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x60
argument_list|,
name|DEV_BSIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x68
argument_list|,
name|DEV_BSIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* prepare for ATA-66 on the 82C686 and rev 0x12 and newer 82C596's */
if|if
condition|(
name|ata_find_dev
argument_list|(
name|dev
argument_list|,
literal|0x06861106
argument_list|,
literal|0
argument_list|)
operator|||
name|ata_find_dev
argument_list|(
name|dev
argument_list|,
literal|0x05961106
argument_list|,
literal|0x12
argument_list|)
condition|)
block|{
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x50
argument_list|,
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x50
argument_list|,
literal|4
argument_list|)
operator||
literal|0x070f070f
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/*      * the Cypress chip is a mess, it contains two ATA functions, but       * both channels are visible on the first one.      * simply ignore the second function for now, as the right      * solution (ignoring the second channel on the first function)      * doesn't work with the crappy ATA interrupt setup on the alpha.      */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
operator|==
literal|0xc6931080
operator|&&
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|>
literal|1
condition|)
return|return
literal|0
return|;
name|ata_pci_add_child
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
operator|||
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x18
argument_list|,
literal|4
argument_list|)
operator|&
name|IOMASK
condition|)
name|ata_pci_add_child
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|uintptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|": at 0x%x"
argument_list|,
name|scp
operator|->
name|ioaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" irq %d"
argument_list|,
literal|14
operator|+
name|unit
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|ata_pci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ata_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|masterdev
init|=
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|myrid
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
condition|)
block|{
switch|switch
condition|(
operator|*
name|rid
condition|)
block|{
case|case
name|ATA_IOADDR_RID
case|:
if|if
condition|(
name|masterdev
condition|)
block|{
name|myrid
operator|=
literal|0
expr_stmt|;
name|start
operator|=
operator|(
name|unit
operator|==
literal|0
condition|?
name|IO_WD1
else|:
name|IO_WD2
operator|)
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|ATA_IOSIZE
operator|-
literal|1
expr_stmt|;
name|count
operator|=
name|ATA_IOSIZE
expr_stmt|;
block|}
else|else
name|myrid
operator|=
literal|0x10
operator|+
literal|8
operator|*
name|unit
expr_stmt|;
break|break;
case|case
name|ATA_ALTADDR_RID
case|:
if|if
condition|(
name|masterdev
condition|)
block|{
name|myrid
operator|=
literal|0
expr_stmt|;
name|start
operator|=
operator|(
name|unit
operator|==
literal|0
condition|?
name|IO_WD1
else|:
name|IO_WD2
operator|)
operator|+
name|ATA_ALTOFFSET
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|ATA_ALTIOSIZE
operator|-
literal|1
expr_stmt|;
name|count
operator|=
name|ATA_ALTIOSIZE
expr_stmt|;
block|}
else|else
name|myrid
operator|=
literal|0x14
operator|+
literal|8
operator|*
name|unit
expr_stmt|;
break|break;
case|case
name|ATA_BMADDR_RID
case|:
comment|/* the busmaster resource is shared between the two channels */
if|if
condition|(
name|sc
operator|->
name|bmio
condition|)
block|{
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|bmio_1
operator|=
operator|*
name|sc
operator|->
name|bmio
expr_stmt|;
name|sc
operator|->
name|bmio_1
operator|.
name|r_end
operator|=
name|sc
operator|->
name|bmio
operator|->
name|r_start
operator|+
name|ATA_BM_OFFSET1
expr_stmt|;
return|return
operator|&
name|sc
operator|->
name|bmio_1
return|;
block|}
else|else
block|{
name|sc
operator|->
name|bmio_2
operator|=
operator|*
name|sc
operator|->
name|bmio
expr_stmt|;
name|sc
operator|->
name|bmio_2
operator|.
name|r_start
operator|=
name|sc
operator|->
name|bmio
operator|->
name|r_start
operator|+
name|ATA_BM_OFFSET1
expr_stmt|;
name|sc
operator|->
name|bmio_2
operator|.
name|r_end
operator|=
name|sc
operator|->
name|bmio_2
operator|.
name|r_start
operator|+
name|ATA_BM_OFFSET1
expr_stmt|;
return|return
operator|&
name|sc
operator|->
name|bmio_2
return|;
block|}
block|}
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|masterdev
condition|)
comment|/* make the parent just pass through the allocation. */
return|return
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|myrid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
return|;
else|else
comment|/* we are using the parent resource directly. */
return|return
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|myrid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
if|if
condition|(
operator|*
name|rid
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|masterdev
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
return|return
name|alpha_platform_alloc_ide_intr
argument_list|(
name|unit
argument_list|)
return|;
else|#
directive|else
name|int
name|irq
init|=
operator|(
name|unit
operator|==
literal|0
condition|?
literal|14
else|:
literal|15
operator|)
decl_stmt|;
return|return
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|irq
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|,
name|flags
operator|&
operator|~
name|RF_SHAREABLE
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* primary and secondary channels share the same interrupt */
name|sc
operator|->
name|irqcnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq
condition|)
name|sc
operator|->
name|irq
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|sc
operator|->
name|irq
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|ata_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|uintptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|masterdev
init|=
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
decl_stmt|;
name|int
name|myrid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
condition|)
block|{
switch|switch
condition|(
name|rid
condition|)
block|{
case|case
name|ATA_IOADDR_RID
case|:
if|if
condition|(
name|masterdev
condition|)
name|myrid
operator|=
literal|0
expr_stmt|;
else|else
name|myrid
operator|=
literal|0x10
operator|+
literal|8
operator|*
name|unit
expr_stmt|;
break|break;
case|case
name|ATA_ALTADDR_RID
case|:
if|if
condition|(
name|masterdev
condition|)
name|myrid
operator|=
literal|0
expr_stmt|;
else|else
name|myrid
operator|=
literal|0x14
operator|+
literal|8
operator|*
name|unit
expr_stmt|;
break|break;
case|case
name|ATA_BMADDR_RID
case|:
return|return
literal|0
return|;
default|default:
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
name|masterdev
condition|)
comment|/* make the parent just pass through the allocation. */
return|return
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|myrid
argument_list|,
name|r
argument_list|)
return|;
else|else
comment|/* we are using the parent resource directly. */
return|return
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|myrid
argument_list|,
name|r
argument_list|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
if|if
condition|(
name|rid
operator|!=
literal|0
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|masterdev
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
return|return
name|alpha_platform_release_ide_intr
argument_list|(
name|unit
argument_list|,
name|r
argument_list|)
return|;
else|#
directive|else
return|return
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|irqcnt
condition|)
return|return
literal|0
return|;
return|return
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
return|;
block|}
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
return|return
name|alpha_platform_setup_ide_intr
argument_list|(
name|irq
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
return|;
else|#
directive|else
return|return
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
return|return
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_pci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
condition|)
block|{
ifdef|#
directive|ifdef
name|__alpha__
return|return
name|alpha_platform_teardown_ide_intr
argument_list|(
name|irq
argument_list|,
name|cookie
argument_list|)
return|;
else|#
directive|else
return|return
name|BUS_TEARDOWN_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
return|return
name|BUS_TEARDOWN_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ata_pci_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ata_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ata_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* bus methods */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ata_pci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ata_pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ata_pci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ata_pci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ata_pci_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ata_pci_driver
init|=
block|{
literal|"atapci"
block|,
name|ata_pci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_pci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atapci
argument_list|,
name|pci
argument_list|,
name|ata_pci_driver
argument_list|,
name|ata_pci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ata_pcisub_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* kids of pci ata chipsets has their physical unit number in ivars */
name|scp
operator|->
name|unit
operator|=
operator|(
name|uintptr_t
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|scp
operator|->
name|chiptype
operator|=
name|pci_get_devid
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ata_probe
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ata_pcisub_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ata_pcisub_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ata_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ata_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ata_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ata_pcisub_driver
init|=
block|{
literal|"ata"
block|,
name|ata_pcisub_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata
argument_list|,
name|atapci
argument_list|,
name|ata_pcisub_driver
argument_list|,
name|ata_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ata_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|io
init|=
literal|0
decl_stmt|;
name|struct
name|resource
modifier|*
name|altio
init|=
literal|0
decl_stmt|;
name|struct
name|resource
modifier|*
name|bmio
init|=
literal|0
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|u_int32_t
name|ioaddr
decl_stmt|,
name|altioaddr
decl_stmt|,
name|bmaddr
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|status0
decl_stmt|,
name|status1
decl_stmt|;
if|if
condition|(
operator|!
name|scp
operator|||
name|scp
operator|->
name|flags
operator|&
name|ATA_ATTACHED
condition|)
return|return
name|ENXIO
return|;
comment|/* initialize the softc basics */
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|scp
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|scp
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
name|rid
operator|=
name|ATA_IOADDR_RID
expr_stmt|;
name|io
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ATA_IOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|io
condition|)
goto|goto
name|failure
goto|;
name|ioaddr
operator|=
name|rman_get_start
argument_list|(
name|io
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ATA_ALTADDR_RID
expr_stmt|;
name|altio
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ATA_ALTIOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|altio
condition|)
block|{
if|if
condition|(
name|pci_get_progif
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|&
name|PCIP_STORAGE_IDE_MASTERDEV
condition|)
name|altioaddr
operator|=
name|rman_get_start
argument_list|(
name|altio
argument_list|)
expr_stmt|;
else|else
name|altioaddr
operator|=
name|rman_get_start
argument_list|(
name|altio
argument_list|)
operator|+
literal|0x02
expr_stmt|;
block|}
else|else
name|altioaddr
operator|=
name|ioaddr
operator|+
name|ATA_IOSIZE
expr_stmt|;
name|rid
operator|=
name|ATA_BMADDR_RID
expr_stmt|;
name|bmio
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|bmaddr
operator|=
name|bmio
condition|?
name|rman_get_start
argument_list|(
name|bmio
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* store the IO resources for eventual later release */
name|scp
operator|->
name|r_io
operator|=
name|io
expr_stmt|;
name|scp
operator|->
name|r_altio
operator|=
name|altio
expr_stmt|;
name|scp
operator|->
name|r_bmio
operator|=
name|bmio
expr_stmt|;
comment|/* store the physical IO addresse for easy access */
name|scp
operator|->
name|ioaddr
operator|=
name|ioaddr
expr_stmt|;
name|scp
operator|->
name|altioaddr
operator|=
name|altioaddr
expr_stmt|;
name|scp
operator|->
name|bmaddr
operator|=
name|bmaddr
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"iobase=0x%04x altiobase=0x%04x bmaddr=0x%04x\n"
argument_list|,
name|scp
operator|->
name|ioaddr
argument_list|,
name|scp
operator|->
name|altioaddr
argument_list|,
name|scp
operator|->
name|bmaddr
argument_list|)
expr_stmt|;
comment|/* do we have any signs of ATA/ATAPI HW being present ? */
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status0
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_SLAVE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status1
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status0
operator|&
literal|0xf8
operator|)
operator|!=
literal|0xf8
operator|&&
name|status0
operator|!=
literal|0xa5
condition|)
name|mask
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
operator|(
name|status1
operator|&
literal|0xf8
operator|)
operator|!=
literal|0xf8
operator|&&
name|status1
operator|!=
literal|0xa5
condition|)
name|mask
operator||=
literal|0x02
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"mask=%02x status0=%02x status1=%02x\n"
argument_list|,
name|mask
argument_list|,
name|status0
argument_list|,
name|status1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
goto|goto
name|failure
goto|;
name|ata_reset
argument_list|(
name|scp
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"devices = 0x%x\n"
argument_list|,
name|scp
operator|->
name|devices
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
goto|goto
name|failure
goto|;
name|TAILQ_INIT
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|failure
label|:
if|if
condition|(
name|io
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_IOADDR_RID
argument_list|,
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|altio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_ALTADDR_RID
argument_list|,
name|altio
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_BMADDR_RID
argument_list|,
name|bmio
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"probe allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|scp
operator|||
name|scp
operator|->
name|flags
operator|&
name|ATA_ATTACHED
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|->
name|r_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
operator|->
name|r_irq
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"unable to allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|scp
operator|->
name|r_irq
argument_list|,
name|INTR_TYPE_BIO
argument_list|,
name|ata_intr
argument_list|,
name|scp
argument_list|,
operator|&
name|scp
operator|->
name|ih
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/*      * do not attach devices if we are in early boot, this is done later       * when interrupts are enabled by a hook into the boot process.      * otherwise attach what the probe has found in scp->devices.      */
if|if
condition|(
operator|!
name|ata_delayed_attach
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_MASTER
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_MASTER
expr_stmt|;
if|#
directive|if
name|NATADISK
operator|>
literal|0
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|scp
operator|->
name|flags
operator||=
name|ATA_ATTACHED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|scp
operator|||
operator|!
operator|(
name|scp
operator|->
name|flags
operator|&
name|ATA_ATTACHED
operator|)
condition|)
return|return
name|ENXIO
return|;
if|#
directive|if
name|NATADISK
operator|>
literal|0
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
name|ad_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
name|ad_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
name|atapi_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
name|atapi_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|ATA_MASTER
argument_list|)
index|]
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|ATA_MASTER
argument_list|)
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|ATA_MASTER
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|ATA_SLAVE
argument_list|)
index|]
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|ATA_SLAVE
argument_list|)
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|ATA_SLAVE
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|scp
operator|->
name|dev_softc
index|[
name|ATA_DEV
argument_list|(
name|ATA_MASTER
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|dev_softc
index|[
name|ATA_DEV
argument_list|(
name|ATA_SLAVE
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mode
index|[
name|ATA_DEV
argument_list|(
name|ATA_MASTER
argument_list|)
index|]
operator|=
name|ATA_PIO
expr_stmt|;
name|scp
operator|->
name|mode
index|[
name|ATA_DEV
argument_list|(
name|ATA_SLAVE
argument_list|)
index|]
operator|=
name|ATA_PIO
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|scp
operator|->
name|r_irq
argument_list|,
name|scp
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|r_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|r_bmio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_BMADDR_RID
argument_list|,
name|scp
operator|->
name|r_bmio
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|r_altio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_ALTADDR_RID
argument_list|,
name|scp
operator|->
name|r_altio
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_IOADDR_RID
argument_list|,
name|scp
operator|->
name|r_io
argument_list|)
expr_stmt|;
name|scp
operator|->
name|flags
operator|&=
operator|~
name|ATA_ATTACHED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ata_reinit
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_getparam
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|u_int8_t
name|command
parameter_list|)
block|{
name|struct
name|ata_params
modifier|*
name|ata_parm
decl_stmt|;
name|int8_t
name|buffer
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
comment|/* select drive */
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* enable interrupt */
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* apparently some devices needs this repeated */
do|do
block|{
if|if
condition|(
name|ata_command
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
name|command
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ATA_WAIT_INTR
argument_list|)
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"identify failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|retry
operator|++
operator|>
literal|4
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"identify retries exceeded\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|ata_wait
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
operator|(
operator|(
name|command
operator|==
name|ATA_C_ATAPI_IDENTIFY
operator|)
condition|?
name|ATA_S_DRQ
else|:
operator|(
name|ATA_S_READY
operator||
name|ATA_S_DSC
operator||
name|ATA_S_DRQ
operator|)
operator|)
argument_list|)
condition|)
do|;
name|insw
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DATA
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|ata_parm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
name|M_ATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ata_parm
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"malloc for identify data failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|ata_parm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|ATA_C_ATA_IDENTIFY
operator|||
operator|!
operator|(
operator|(
name|ata_parm
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|ata_parm
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|ata_parm
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|ata_parm
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
name|bswap
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|btrim
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|bpack
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|,
name|ata_parm
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|bswap
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|btrim
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|bpack
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|,
name|ata_parm
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
operator|=
name|ata_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_boot_attach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
comment|/*      * run through all ata devices and look for real ATA& ATAPI devices      * using the hints we found in the early probe, this avoids some of      * the delays probing of non-exsistent devices can cause.      */
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_MASTER
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_MASTER
expr_stmt|;
block|}
if|#
directive|if
name|NATADISK
operator|>
literal|0
comment|/* now we know whats there, do the real attach, first the ATA disks */
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
comment|/* then the atapi devices */
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ata_delayed_attach
condition|)
block|{
name|config_intrhook_disestablish
argument_list|(
name|ata_delayed_attach
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ata_delayed_attach
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|ata_delayed_attach
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ata_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
operator|(
expr|struct
name|ata_softc
operator|*
operator|)
name|data
decl_stmt|;
name|u_int8_t
name|dmastat
init|=
literal|0
decl_stmt|;
comment|/*       * since we might share the IRQ with another device, and in some      * cases with our twin channel, we only want to process interrupts      * that we know this channel generated.      */
switch|switch
condition|(
name|scp
operator|->
name|chiptype
condition|)
block|{
if|#
directive|if
name|NPCI
operator|>
literal|0
case|case
literal|0x00041103
case|:
comment|/* HighPoint HPT366/368/370 */
if|if
condition|(
operator|(
operator|(
name|dmastat
operator|=
name|ata_dmastatus
argument_list|(
name|scp
argument_list|)
operator|)
operator|&
operator|(
name|ATA_BMSTAT_ACTIVE
operator||
name|ATA_BMSTAT_INTERRUPT
operator|)
operator|)
operator|!=
name|ATA_BMSTAT_INTERRUPT
condition|)
return|return;
name|outb
argument_list|(
name|scp
operator|->
name|bmaddr
operator|+
name|ATA_BMSTAT_PORT
argument_list|,
name|dmastat
operator||
name|ATA_BMSTAT_INTERRUPT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4d33105a
case|:
comment|/* Promise Ultra/Fasttrak 33 */
case|case
literal|0x4d38105a
case|:
comment|/* Promise Ultra/Fasttrak 66 */
case|case
literal|0x4d30105a
case|:
comment|/* Promise Ultra/Fasttrak 100 */
case|case
literal|0x0d30105a
case|:
comment|/* Promise OEM ATA100 */
block|{
name|struct
name|ata_pci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|inl
argument_list|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|bmio
argument_list|)
operator|+
literal|0x1c
argument_list|)
operator|&
operator|(
operator|(
name|scp
operator|->
name|unit
operator|)
condition|?
literal|0x00004000
else|:
literal|0x00000400
operator|)
operator|)
condition|)
return|return;
block|}
endif|#
directive|endif
default|default:
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_DMA_ACTIVE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dmastat
operator|=
name|ata_dmastatus
argument_list|(
name|scp
argument_list|)
operator|)
operator|&
operator|(
name|ATA_BMSTAT_ACTIVE
operator||
name|ATA_BMSTAT_INTERRUPT
operator|)
operator|)
operator|!=
name|ATA_BMSTAT_INTERRUPT
condition|)
return|return;
name|outb
argument_list|(
name|scp
operator|->
name|bmaddr
operator|+
name|ATA_BMSTAT_PORT
argument_list|,
name|dmastat
operator||
name|ATA_BMSTAT_INTERRUPT
argument_list|)
expr_stmt|;
block|}
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* if drive is busy it didn't interrupt */
if|if
condition|(
name|inb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|)
operator|&
name|ATA_S_BUSY
condition|)
return|return;
comment|/* clear interrupt and get status */
name|scp
operator|->
name|status
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|scp
operator|->
name|error
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|)
expr_stmt|;
comment|/* find& call the responsible driver to process this interrupt */
switch|switch
condition|(
name|scp
operator|->
name|active
condition|)
block|{
if|#
directive|if
name|NATADISK
operator|>
literal|0
case|case
name|ATA_ACTIVE_ATA
case|:
if|if
condition|(
operator|!
name|scp
operator|->
name|running
operator|||
name|ad_interrupt
argument_list|(
name|scp
operator|->
name|running
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
break|break;
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
case|case
name|ATA_ACTIVE_ATAPI
case|:
if|if
condition|(
operator|!
name|scp
operator|->
name|running
operator|||
name|atapi_interrupt
argument_list|(
name|scp
operator|->
name|running
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
break|break;
endif|#
directive|endif
case|case
name|ATA_WAIT_INTR
case|:
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_WAIT_READY
case|:
break|break;
case|case
name|ATA_REINITING
case|:
return|return;
case|case
name|ATA_IDLE
case|:
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
block|{
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE
expr_stmt|;
if|if
condition|(
name|ata_service
argument_list|(
name|scp
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
block|}
comment|/* FALLTHROUGH */
default|default:
ifdef|#
directive|ifdef
name|ATA_DEBUG
block|{
specifier|static
name|int
name|intr_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|intr_count
operator|++
operator|<
literal|10
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"unwanted interrupt %d status = %02x\n"
argument_list|,
name|intr_count
argument_list|,
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|NULL
expr_stmt|;
name|ata_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ata_start
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
if|#
directive|if
name|NATADISK
operator|>
literal|0
name|struct
name|ad_request
modifier|*
name|ad_request
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
name|struct
name|atapi_request
modifier|*
name|atapi_request
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|active
operator|!=
name|ATA_IDLE
condition|)
return|return;
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE
expr_stmt|;
if|#
directive|if
name|NATADISK
operator|>
literal|0
comment|/* find& call the responsible driver if anything on the ATA queue */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
condition|)
name|ad_start
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
condition|)
name|ad_start
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ad_request
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|,
name|ad_request
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE_ATA
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|ad_request
expr_stmt|;
if|if
condition|(
name|ad_transfer
argument_list|(
name|ad_request
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
comment|/* find& call the responsible driver if anything on the ATAPI queue */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
condition|)
name|atapi_start
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
condition|)
name|atapi_start
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|atapi_request
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|,
name|atapi_request
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE_ATAPI
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|atapi_request
expr_stmt|;
name|atapi_transfer
argument_list|(
name|atapi_request
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_reset
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
modifier|*
name|mask
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|u_int8_t
name|status0
init|=
name|ATA_S_BUSY
decl_stmt|,
name|status1
init|=
name|ATA_S_BUSY
decl_stmt|;
comment|/* reset channel */
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_IDS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* wait for BUSY to go inactive */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|310000
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|status0
operator|&
name|ATA_S_BUSY
condition|)
block|{
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status0
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status0
operator|&
name|ATA_S_BUSY
operator|)
condition|)
block|{
comment|/* check for ATAPI signature while its still there */
if|if
condition|(
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|)
operator|==
name|ATAPI_MAGIC_LSB
operator|&&
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_MSB
argument_list|)
operator|==
name|ATAPI_MAGIC_MSB
condition|)
name|scp
operator|->
name|devices
operator||=
name|ATA_ATAPI_MASTER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status1
operator|&
name|ATA_S_BUSY
condition|)
block|{
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_SLAVE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|status1
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status1
operator|&
name|ATA_S_BUSY
operator|)
condition|)
block|{
comment|/* check for ATAPI signature while its still there */
if|if
condition|(
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|)
operator|==
name|ATAPI_MAGIC_LSB
operator|&&
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_MSB
argument_list|)
operator|==
name|ATAPI_MAGIC_MSB
condition|)
name|scp
operator|->
name|devices
operator||=
name|ATA_ATAPI_SLAVE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|mask
operator|==
literal|0x01
condition|)
comment|/* wait for master only */
if|if
condition|(
operator|!
operator|(
name|status0
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|mask
operator|==
literal|0x02
condition|)
comment|/* wait for slave only */
if|if
condition|(
operator|!
operator|(
name|status1
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
if|if
condition|(
operator|*
name|mask
operator|==
literal|0x03
condition|)
comment|/* wait for both master& slave */
if|if
condition|(
operator|!
operator|(
name|status0
operator|&
name|ATA_S_BUSY
operator|)
operator|&&
operator|!
operator|(
name|status1
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|status0
operator|&
name|ATA_S_BUSY
condition|)
operator|*
name|mask
operator|&=
operator|~
literal|0x01
expr_stmt|;
if|if
condition|(
name|status1
operator|&
name|ATA_S_BUSY
condition|)
operator|*
name|mask
operator|&=
operator|~
literal|0x02
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"mask=%02x status0=%02x status1=%02x\n"
argument_list|,
operator|*
name|mask
argument_list|,
name|status0
argument_list|,
name|status1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
block|{
name|scp
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*       * OK, we have at least one device on the chain, checks for ATAPI       * already done, if none check if its a good old ATA device.      */
if|if
condition|(
name|status0
operator|!=
literal|0x00
operator|&&
operator|!
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
operator|)
condition|)
block|{
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
operator|(
name|ATA_D_IBM
operator||
name|ATA_MASTER
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|,
literal|0x58
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|)
operator|!=
literal|0x58
operator|&&
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|)
operator|==
literal|0xa5
condition|)
block|{
name|scp
operator|->
name|devices
operator||=
name|ATA_ATA_MASTER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status1
operator|!=
literal|0x00
operator|&&
operator|!
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
operator|)
condition|)
block|{
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
operator|(
name|ATA_D_IBM
operator||
name|ATA_SLAVE
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|,
literal|0x58
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|)
operator|!=
literal|0x58
operator|&&
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|)
operator|==
literal|0xa5
condition|)
block|{
name|scp
operator|->
name|devices
operator||=
name|ATA_ATA_SLAVE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|ata_reinit
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|,
name|omask
decl_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_REINITING
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_MASTER
operator||
name|ATA_ATAPI_MASTER
operator|)
condition|)
name|mask
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_SLAVE
operator||
name|ATA_ATAPI_SLAVE
operator|)
condition|)
name|mask
operator||=
literal|0x02
expr_stmt|;
if|if
condition|(
name|mask
condition|)
block|{
name|omask
operator|=
name|mask
expr_stmt|;
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"resetting devices .. "
argument_list|)
expr_stmt|;
name|ata_reset
argument_list|(
name|scp
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|omask
operator|!=
name|mask
condition|)
name|printf
argument_list|(
literal|" device dissapeared! %d "
argument_list|,
name|omask
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
if|#
directive|if
name|NATADISK
operator|>
literal|0
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
condition|)
name|ad_reinit
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
condition|)
name|ad_reinit
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NATAPICD
operator|>
literal|0
operator|||
name|NATAPIFD
operator|>
literal|0
operator|||
name|NATAPIST
operator|>
literal|0
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
condition|)
name|atapi_reinit
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
condition|)
name|atapi_reinit
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|ata_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_service
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
comment|/* do we have a SERVICE request from the drive ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
operator|(
name|ATA_S_SERVICE
operator||
name|ATA_S_ERROR
operator||
name|ATA_S_DRQ
operator|)
operator|)
operator|==
name|ATA_S_SERVICE
condition|)
block|{
name|outb
argument_list|(
name|scp
operator|->
name|bmaddr
operator|+
name|ATA_BMSTAT_PORT
argument_list|,
name|ata_dmastatus
argument_list|(
name|scp
argument_list|)
operator||
name|ATA_BMSTAT_INTERRUPT
argument_list|)
expr_stmt|;
if|#
directive|if
name|NATADISK
operator|>
literal|0
if|if
condition|(
operator|(
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|)
operator|&
name|ATA_SLAVE
operator|)
operator|==
name|ATA_MASTER
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
condition|)
return|return
name|ad_service
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
condition|)
return|return
name|ad_service
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|ATA_OP_FINISHED
return|;
block|}
end_function

begin_function
name|int
name|ata_wait
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|u_int8_t
name|mask
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|int
name|statio
init|=
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_STATUS
decl_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
operator|<
literal|5000000
condition|)
block|{
comment|/* timeout 5 secs */
name|scp
operator|->
name|status
operator|=
name|inb
argument_list|(
name|statio
argument_list|)
expr_stmt|;
comment|/* if drive fails status, reselect the drive just to be sure */
if|if
condition|(
name|scp
operator|->
name|status
operator|==
literal|0xff
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"no status, reselecting device\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|=
name|inb
argument_list|(
name|statio
argument_list|)
expr_stmt|;
block|}
comment|/* are we done ? */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
if|if
condition|(
name|timeout
operator|>
literal|1000
condition|)
block|{
name|timeout
operator|+=
literal|1000
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeout
operator|+=
literal|10
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|scp
operator|->
name|error
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>=
literal|5000000
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
operator|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
operator|)
return|;
comment|/* Wait 50 msec for bits wanted. */
name|timeout
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
name|timeout
operator|--
condition|)
block|{
name|scp
operator|->
name|status
operator|=
name|inb
argument_list|(
name|statio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|scp
operator|->
name|error
operator|=
name|inb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_command
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int16_t
name|cylinder
parameter_list|,
name|u_int8_t
name|head
parameter_list|,
name|u_int8_t
name|sector
parameter_list|,
name|u_int8_t
name|count
parameter_list|,
name|u_int8_t
name|feature
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ATA_DEBUG
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"ata_command: addr=%04x, cmd=%02x, "
literal|"c=%d, h=%d, s=%d, count=%d, feature=%d, flags=%02x\n"
argument_list|,
name|scp
operator|->
name|ioaddr
argument_list|,
name|command
argument_list|,
name|cylinder
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|count
argument_list|,
name|feature
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* disable interrupt from device */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
comment|/* select device */
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
argument_list|)
expr_stmt|;
comment|/* ready to issue command ? */
if|if
condition|(
name|ata_wait
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"timeout waiting to give command=%02x s=%02x e=%02x\n"
argument_list|,
name|command
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|scp
operator|->
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_FEATURE
argument_list|,
name|feature
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_COUNT
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_SECTOR
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_MSB
argument_list|,
name|cylinder
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CYL_LSB
argument_list|,
name|cylinder
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
operator||
name|head
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|ATA_WAIT_INTR
case|:
if|if
condition|(
name|scp
operator|->
name|active
operator|!=
name|ATA_IDLE
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"WARNING: WAIT_INTR active=%s\n"
argument_list|,
name|active2str
argument_list|(
name|scp
operator|->
name|active
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_WAIT_INTR
expr_stmt|;
name|asleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
name|PRIBIO
argument_list|,
literal|"atacmd"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CMD
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* enable interrupt */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|await
argument_list|(
name|PRIBIO
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"ata_command: timeout waiting for intr\n"
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ATA_WAIT_READY
case|:
if|if
condition|(
name|scp
operator|->
name|active
operator|!=
name|ATA_IDLE
operator|&&
name|scp
operator|->
name|active
operator|!=
name|ATA_REINITING
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"WARNING: WAIT_READY active=%s\n"
argument_list|,
name|active2str
argument_list|(
name|scp
operator|->
name|active
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|active
operator|!=
name|ATA_REINITING
condition|)
name|scp
operator|->
name|active
operator|=
name|ATA_WAIT_READY
expr_stmt|;
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CMD
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_wait
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
name|ATA_S_READY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"timeout waiting for command=%02x s=%02x e=%02x\n"
argument_list|,
name|command
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|scp
operator|->
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|active
operator|!=
name|ATA_REINITING
condition|)
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
break|break;
case|case
name|ATA_IMMEDIATE
case|:
name|outb
argument_list|(
name|scp
operator|->
name|ioaddr
operator|+
name|ATA_CMD
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"DANGER: illegal interrupt flag=%s\n"
argument_list|,
name|active2str
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* enable interrupt */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
name|outb
argument_list|(
name|scp
operator|->
name|altioaddr
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ata_get_lun
parameter_list|(
name|u_int32_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|lun
init|=
name|ffs
argument_list|(
operator|~
operator|*
name|map
argument_list|)
operator|-
literal|1
decl_stmt|;
operator|*
name|map
operator||=
operator|(
literal|1
operator|<<
name|lun
operator|)
expr_stmt|;
return|return
name|lun
return|;
block|}
end_function

begin_function
name|void
name|ata_free_lun
parameter_list|(
name|u_int32_t
modifier|*
name|map
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
operator|*
name|map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|lun
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ata_printf
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|device
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|printf
argument_list|(
literal|"ata%d: "
argument_list|,
name|device_get_unit
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|printf
argument_list|(
literal|"ata%d-%s: "
argument_list|,
name|device_get_unit
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
argument_list|,
operator|(
name|device
operator|==
name|ATA_MASTER
operator|)
condition|?
literal|"master"
else|:
literal|"slave"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ata_mode2str
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ATA_PIO
case|:
return|return
literal|"BIOSPIO"
return|;
case|case
name|ATA_PIO0
case|:
return|return
literal|"PIO0"
return|;
case|case
name|ATA_PIO1
case|:
return|return
literal|"PIO1"
return|;
case|case
name|ATA_PIO2
case|:
return|return
literal|"PIO2"
return|;
case|case
name|ATA_PIO3
case|:
return|return
literal|"PIO3"
return|;
case|case
name|ATA_PIO4
case|:
return|return
literal|"PIO4"
return|;
case|case
name|ATA_WDMA2
case|:
return|return
literal|"WDMA2"
return|;
case|case
name|ATA_UDMA2
case|:
return|return
literal|"UDMA33"
return|;
case|case
name|ATA_UDMA4
case|:
return|return
literal|"UDMA66"
return|;
case|case
name|ATA_UDMA5
case|:
return|return
literal|"UDMA100"
return|;
case|case
name|ATA_DMA
case|:
return|return
literal|"BIOSDMA"
return|;
default|default:
return|return
literal|"???"
return|;
block|}
block|}
end_function

begin_function
name|int
name|ata_pio2mode
parameter_list|(
name|int
name|pio
parameter_list|)
block|{
switch|switch
condition|(
name|pio
condition|)
block|{
default|default:
case|case
literal|0
case|:
return|return
name|ATA_PIO0
return|;
case|case
literal|1
case|:
return|return
name|ATA_PIO1
return|;
case|case
literal|2
case|:
return|return
name|ATA_PIO2
return|;
case|case
literal|3
case|:
return|return
name|ATA_PIO3
return|;
case|case
literal|4
case|:
return|return
name|ATA_PIO4
return|;
block|}
block|}
end_function

begin_function
name|int
name|ata_pmode
parameter_list|(
name|struct
name|ata_params
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|atavalid
operator|&
name|ATA_FLAG_64_70
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|apiomodes
operator|&
literal|2
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|ap
operator|->
name|apiomodes
operator|&
literal|1
condition|)
return|return
literal|3
return|;
block|}
if|if
condition|(
name|ap
operator|->
name|opiomode
operator|==
literal|2
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ap
operator|->
name|opiomode
operator|==
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ap
operator|->
name|opiomode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_wmode
parameter_list|(
name|struct
name|ata_params
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|wdmamodes
operator|&
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ap
operator|->
name|wdmamodes
operator|&
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ap
operator|->
name|wdmamodes
operator|&
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_umode
parameter_list|(
name|struct
name|ata_params
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|atavalid
operator|&
name|ATA_FLAG_88
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x20
condition|)
return|return
literal|5
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x10
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x08
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x04
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x02
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x01
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|active2str
parameter_list|(
name|int
name|active
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
switch|switch
condition|(
name|active
condition|)
block|{
case|case
name|ATA_IDLE
case|:
return|return
operator|(
literal|"ATA_IDLE"
operator|)
return|;
case|case
name|ATA_IMMEDIATE
case|:
return|return
operator|(
literal|"ATA_IMMEDIATE"
operator|)
return|;
case|case
name|ATA_WAIT_INTR
case|:
return|return
operator|(
literal|"ATA_WAIT_INTR"
operator|)
return|;
case|case
name|ATA_WAIT_READY
case|:
return|return
operator|(
literal|"ATA_WAIT_READY"
operator|)
return|;
case|case
name|ATA_ACTIVE
case|:
return|return
operator|(
literal|"ATA_ACTIVE"
operator|)
return|;
case|case
name|ATA_ACTIVE_ATA
case|:
return|return
operator|(
literal|"ATA_ACTIVE_ATA"
operator|)
return|;
case|case
name|ATA_ACTIVE_ATAPI
case|:
return|return
operator|(
literal|"ATA_ACTIVE_ATAPI"
operator|)
return|;
case|case
name|ATA_REINITING
case|:
return|return
operator|(
literal|"ATA_REINITING"
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%02x"
argument_list|,
name|active
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bswap
parameter_list|(
name|int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|ptr
init|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|len
operator|)
decl_stmt|;
while|while
condition|(
operator|--
name|ptr
operator|>=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
condition|)
operator|*
name|ptr
operator|=
name|ntohs
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btrim
parameter_list|(
name|int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int8_t
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
init|;
name|ptr
operator|<
name|buf
operator|+
name|len
condition|;
operator|++
name|ptr
control|)
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
operator|+
name|len
operator|-
literal|1
init|;
name|ptr
operator|>=
name|buf
operator|&&
operator|*
name|ptr
operator|==
literal|' '
condition|;
operator|--
name|ptr
control|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpack
parameter_list|(
name|int8_t
modifier|*
name|src
parameter_list|,
name|int8_t
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|blank
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
name|blank
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blank
operator|&&
name|src
index|[
name|i
index|]
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|blank
operator|&&
name|src
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
block|{
name|dst
index|[
name|j
operator|++
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|blank
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|src
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
name|blank
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
block|}
name|dst
index|[
name|j
operator|++
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|len
condition|)
name|dst
index|[
name|j
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_change_mode
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
name|scp
operator|->
name|active
operator|!=
name|ATA_IDLE
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|,
name|PRIBIO
argument_list|,
literal|"atachm"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_REINITING
expr_stmt|;
name|ata_dmainit
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
name|ata_pmode
argument_list|(
name|ATA_PARAM
argument_list|(
name|scp
argument_list|,
name|device
argument_list|)
argument_list|)
argument_list|,
name|mode
operator|<
name|ATA_DMA
condition|?
operator|-
literal|1
else|:
name|ata_wmode
argument_list|(
name|ATA_PARAM
argument_list|(
name|scp
argument_list|,
name|device
argument_list|)
argument_list|)
argument_list|,
name|mode
operator|<
name|ATA_DMA
condition|?
operator|-
literal|1
else|:
name|ata_umode
argument_list|(
name|ATA_PARAM
argument_list|(
name|scp
argument_list|,
name|device
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|ata_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_ata
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|ctlr
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* readout internal state */
name|bzero
argument_list|(
name|ata_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_conf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|scp
operator|->
name|dev_softc
index|[
name|i
index|]
condition|)
name|strcat
argument_list|(
name|ata_conf
argument_list|,
literal|"---,"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|mode
index|[
name|i
index|]
operator|>=
name|ATA_DMA
condition|)
name|strcat
argument_list|(
name|ata_conf
argument_list|,
literal|"dma,"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|ata_conf
argument_list|,
literal|"pio,"
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|ata_conf
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_conf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
name|ata_conf
decl_stmt|;
comment|/* update internal state */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"pio"
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"PIO"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|i
operator|>>
literal|1
argument_list|)
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|i
operator|&
literal|1
index|]
operator|&&
name|scp
operator|->
name|mode
index|[
name|i
operator|&
literal|1
index|]
operator|>=
name|ATA_DMA
condition|)
name|ata_change_mode
argument_list|(
name|scp
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
name|ATA_SLAVE
else|:
name|ATA_MASTER
argument_list|,
name|ATA_PIO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"dma"
argument_list|,
literal|3
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"DMA"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|i
operator|>>
literal|1
argument_list|)
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|i
operator|&
literal|1
index|]
operator|&&
name|scp
operator|->
name|mode
index|[
name|i
operator|&
literal|1
index|]
operator|<
name|ATA_DMA
condition|)
name|ata_change_mode
argument_list|(
name|scp
argument_list|,
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
name|ATA_SLAVE
else|:
name|ATA_MASTER
argument_list|,
name|ATA_DMA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"---"
argument_list|,
literal|3
argument_list|)
condition|)
break|break;
name|ptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
literal|','
operator|||
operator|++
name|i
operator|>
operator|(
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
operator|<<
literal|1
operator|)
condition|)
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|atamodes
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_conf
argument_list|)
argument_list|,
name|sysctl_hw_ata
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ata_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* register boot attach to be run when interrupts are enabled */
if|if
condition|(
operator|!
operator|(
name|ata_delayed_attach
operator|=
operator|(
expr|struct
name|intr_config_hook
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_config_hook
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ata: malloc of delayed attach hook failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|ata_delayed_attach
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|intr_config_hook
argument_list|)
argument_list|)
expr_stmt|;
name|ata_delayed_attach
operator|->
name|ich_func
operator|=
operator|(
name|void
operator|*
operator|)
name|ata_boot_attach
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
name|ata_delayed_attach
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ata: config_intrhook_establish failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ata_delayed_attach
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|atadev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_SECOND
argument_list|,
argument|ata_init
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

