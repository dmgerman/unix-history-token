begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998,1999,2000,2001 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_include
include|#
directive|include
file|"opt_ata.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ata/ata-all.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-disk.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/atapi-all.h>
end_include

begin_comment
comment|/* device structures */
end_comment

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ataioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ata_cdevsw
init|=
block|{
comment|/* open */
name|nullopen
block|,
comment|/* close */
name|nullclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|ataioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"ata"
block|,
comment|/* maj */
literal|159
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|ata_boot_attach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_getparam
parameter_list|(
name|struct
name|ata_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_service
parameter_list|(
name|struct
name|ata_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|active2str
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bswap
parameter_list|(
name|int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|btrim
parameter_list|(
name|int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpack
parameter_list|(
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_change_mode
parameter_list|(
name|struct
name|ata_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|ata
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"ATA driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* global vars */
end_comment

begin_decl_stmt
name|devclass_t
name|ata_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local vars */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|intr_config_hook
modifier|*
name|ata_delayed_attach
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ATA
argument_list|,
literal|"ATA generic"
argument_list|,
literal|"ATA driver generic layer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* misc defines */
end_comment

begin_define
define|#
directive|define
name|MASTER
value|0
end_define

begin_define
define|#
directive|define
name|SLAVE
value|1
end_define

begin_function
name|int
name|ata_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|scp
operator|->
name|r_io
operator|||
name|scp
operator|->
name|r_altio
operator|||
name|scp
operator|->
name|r_irq
condition|)
return|return
name|EEXIST
return|;
comment|/* initialize the softc basics */
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|scp
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|rid
operator|=
name|ATA_IOADDR_RID
expr_stmt|;
name|scp
operator|->
name|r_io
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ATA_IOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
operator|->
name|r_io
condition|)
goto|goto
name|failure
goto|;
name|rid
operator|=
name|ATA_ALTADDR_RID
expr_stmt|;
name|scp
operator|->
name|r_altio
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ATA_ALTIOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
operator|->
name|r_altio
condition|)
goto|goto
name|failure
goto|;
name|rid
operator|=
name|ATA_BMADDR_RID
expr_stmt|;
name|scp
operator|->
name|r_bmio
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|ATA_BMIOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"iobase=0x%04x altiobase=0x%04x bmaddr=0x%04x\n"
argument_list|,
operator|(
name|int
operator|)
name|rman_get_start
argument_list|(
name|scp
operator|->
name|r_io
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|rman_get_start
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|)
argument_list|,
operator|(
name|scp
operator|->
name|r_bmio
operator|)
condition|?
operator|(
name|int
operator|)
name|rman_get_start
argument_list|(
name|scp
operator|->
name|r_bmio
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
name|ata_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|failure
label|:
if|if
condition|(
name|scp
operator|->
name|r_io
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_IOADDR_RID
argument_list|,
name|scp
operator|->
name|r_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|r_altio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_ALTADDR_RID
argument_list|,
name|scp
operator|->
name|r_altio
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|r_bmio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_BMADDR_RID
argument_list|,
name|scp
operator|->
name|r_bmio
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"probe allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
name|int
name|ata_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENXIO
return|;
name|rid
operator|=
name|ATA_IRQ_RID
expr_stmt|;
name|scp
operator|->
name|r_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
operator|->
name|r_irq
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"unable to allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|scp
operator|->
name|r_irq
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_ENTROPY
argument_list|,
name|ata_intr
argument_list|,
name|scp
argument_list|,
operator|&
name|scp
operator|->
name|ih
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/*      * do not attach devices if we are in early boot, this is done later       * when interrupts are enabled by a hook into the boot process.      * otherwise attach what the probe has found in scp->devices.      */
if|if
condition|(
operator|!
name|ata_delayed_attach
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_MASTER
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_MASTER
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATADISK
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ata_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
operator|||
operator|!
name|scp
operator|->
name|devices
condition|)
return|return
name|ENXIO
return|;
comment|/* make sure channel is not busy SOS XXX */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|scp
operator|->
name|active
argument_list|,
name|ATA_IDLE
argument_list|,
name|ATA_CONTROL
argument_list|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|,
name|PRIBIO
argument_list|,
literal|"atachm"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* disable interrupts on devices */
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_SLAVE
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATADISK
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|ad_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|ad_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|atapi_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|atapi_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mode
index|[
name|MASTER
index|]
operator|=
name|ATA_PIO
expr_stmt|;
name|scp
operator|->
name|mode
index|[
name|SLAVE
index|]
operator|=
name|ATA_PIO
expr_stmt|;
name|scp
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|scp
operator|->
name|r_irq
argument_list|,
name|scp
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|scp
operator|->
name|r_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|r_bmio
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_BMADDR_RID
argument_list|,
name|scp
operator|->
name|r_bmio
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_ALTADDR_RID
argument_list|,
name|scp
operator|->
name|r_altio
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|ATA_IOADDR_RID
argument_list|,
name|scp
operator|->
name|r_io
argument_list|)
expr_stmt|;
name|scp
operator|->
name|r_io
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_altio
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_bmio
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_irq
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ata_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ata_reinit
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ataioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int32_t
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ata_cmd
modifier|*
name|iocmd
init|=
operator|(
expr|struct
name|ata_cmd
operator|*
operator|)
name|addr
decl_stmt|;
name|device_t
name|device
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|IOCATA
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
name|iocmd
operator|->
name|channel
operator|>=
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
operator|(
name|device
operator|=
name|devclass_get_device
argument_list|(
name|ata_devclass
argument_list|,
name|iocmd
operator|->
name|channel
argument_list|)
operator|)
condition|)
return|return
name|ENODEV
return|;
switch|switch
condition|(
name|iocmd
operator|->
name|cmd
condition|)
block|{
case|case
name|ATAATTACH
case|:
block|{
comment|/* should enable channel HW on controller that can SOS XXX */
name|error
operator|=
name|ata_probe
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ata_attach
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|ATADETACH
case|:
block|{
name|error
operator|=
name|ata_detach
argument_list|(
name|device
argument_list|)
expr_stmt|;
comment|/* should disable channel HW on controller that can SOS XXX */
return|return
name|error
return|;
block|}
case|case
name|ATAREINIT
case|:
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENODEV
return|;
comment|/* make sure channel is not busy SOS XXX */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|scp
operator|->
name|active
argument_list|,
name|ATA_IDLE
argument_list|,
name|ATA_ACTIVE
argument_list|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|,
name|PRIBIO
argument_list|,
literal|"atachm"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|error
operator|=
name|ata_reinit
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|ATAGMODE
case|:
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
condition|)
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|MASTER
index|]
operator|=
name|scp
operator|->
name|mode
index|[
name|MASTER
index|]
expr_stmt|;
else|else
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|MASTER
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
condition|)
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|SLAVE
index|]
operator|=
name|scp
operator|->
name|mode
index|[
name|SLAVE
index|]
expr_stmt|;
else|else
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|SLAVE
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ATASMODE
case|:
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
operator|&&
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|MASTER
index|]
operator|>=
literal|0
condition|)
block|{
name|ata_change_mode
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|MASTER
index|]
operator|=
name|scp
operator|->
name|mode
index|[
name|MASTER
index|]
expr_stmt|;
block|}
else|else
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|MASTER
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
operator|&&
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|SLAVE
index|]
operator|>=
literal|0
condition|)
block|{
name|ata_change_mode
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|SLAVE
index|]
operator|=
name|scp
operator|->
name|mode
index|[
name|SLAVE
index|]
expr_stmt|;
block|}
else|else
name|iocmd
operator|->
name|u
operator|.
name|mode
operator|.
name|mode
index|[
name|SLAVE
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|ATAGPARM
case|:
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENODEV
return|;
name|iocmd
operator|->
name|u
operator|.
name|param
operator|.
name|type
index|[
name|MASTER
index|]
operator|=
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_MASTER
operator||
name|ATA_ATAPI_MASTER
operator|)
expr_stmt|;
name|iocmd
operator|->
name|u
operator|.
name|param
operator|.
name|type
index|[
name|SLAVE
index|]
operator|=
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_SLAVE
operator||
name|ATA_ATAPI_SLAVE
operator|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_name
index|[
name|MASTER
index|]
condition|)
name|strcpy
argument_list|(
name|iocmd
operator|->
name|u
operator|.
name|param
operator|.
name|name
index|[
name|MASTER
index|]
argument_list|,
name|scp
operator|->
name|dev_name
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_name
index|[
name|SLAVE
index|]
condition|)
name|strcpy
argument_list|(
name|iocmd
operator|->
name|u
operator|.
name|param
operator|.
name|name
index|[
name|SLAVE
index|]
argument_list|,
name|scp
operator|->
name|dev_name
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
condition|)
name|bcopy
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
argument_list|,
operator|&
name|iocmd
operator|->
name|u
operator|.
name|param
operator|.
name|params
index|[
name|MASTER
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
condition|)
name|bcopy
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
argument_list|,
operator|&
name|iocmd
operator|->
name|u
operator|.
name|param
operator|.
name|params
index|[
name|SLAVE
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
case|case
name|ATAPICMD
case|:
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|struct
name|atapi_softc
modifier|*
name|atp
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|scp
operator|=
name|device_get_softc
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scp
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
operator|!
name|scp
operator|->
name|dev_softc
index|[
name|iocmd
operator|->
name|device
index|]
operator|||
operator|!
operator|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|iocmd
operator|->
name|device
operator|==
literal|0
condition|?
name|ATA_ATAPI_MASTER
else|:
name|ATA_ATAPI_SLAVE
operator|)
operator|)
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
operator|!
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|count
argument_list|,
name|M_ATA
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
return|return
name|ENOMEM
return|;
name|atp
operator|=
name|scp
operator|->
name|dev_softc
index|[
name|iocmd
operator|->
name|device
index|]
expr_stmt|;
if|if
condition|(
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|flags
operator|&
name|ATAPI_CMD_WRITE
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|data
argument_list|,
name|buf
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|atapi_queue_cmd
argument_list|(
name|atp
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|ccb
argument_list|,
name|buf
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|count
argument_list|,
operator|(
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|flags
operator|==
name|ATAPI_CMD_READ
condition|?
name|ATPR_F_READ
else|:
literal|0
operator|)
operator||
name|ATPR_F_QUIET
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|timeout
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|error
operator|=
name|error
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|atp
operator|->
name|sense
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atapi_reqsense
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|flags
operator|&
name|ATAPI_CMD_READ
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|data
argument_list|,
name|iocmd
operator|->
name|u
operator|.
name|atapi
operator|.
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|ENOTTY
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_getparam
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|u_int8_t
name|command
parameter_list|)
block|{
name|struct
name|ata_params
modifier|*
name|ata_parm
decl_stmt|;
name|int8_t
name|buffer
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
comment|/* select drive */
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* enable interrupt */
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* apparently some devices needs this repeated */
do|do
block|{
if|if
condition|(
name|ata_command
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
name|command
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ATA_WAIT_INTR
argument_list|)
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"identify failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|retry
operator|++
operator|>
literal|4
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"identify retries exceeded\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|ata_wait
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
operator|(
operator|(
name|command
operator|==
name|ATA_C_ATAPI_IDENTIFY
operator|)
condition|?
name|ATA_S_DRQ
else|:
operator|(
name|ATA_S_READY
operator||
name|ATA_S_DSC
operator||
name|ATA_S_DRQ
operator|)
operator|)
argument_list|)
condition|)
do|;
name|ATA_INSW
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DATA
argument_list|,
operator|(
name|int16_t
operator|*
operator|)
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|ata_parm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|,
name|M_ATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ata_parm
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"malloc for identify data failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|ata_parm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|ATA_C_ATA_IDENTIFY
operator|||
operator|!
operator|(
operator|(
name|ata_parm
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|ata_parm
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|ata_parm
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|ata_parm
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
name|bswap
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|btrim
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|bpack
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|,
name|ata_parm
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|bswap
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|btrim
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|bpack
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|,
name|ata_parm
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ata_parm
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
operator|=
name|ata_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_boot_attach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
decl_stmt|;
name|int
name|ctlr
decl_stmt|;
comment|/*      * run through all ata devices and look for real ATA& ATAPI devices      * using the hints we found in the early probe, this avoids some of      * the delays probing of non-exsistent devices can cause.      */
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_SLAVE
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATA_MASTER
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|scp
operator|->
name|devices
operator|&=
operator|~
name|ATA_ATAPI_MASTER
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEV_ATADISK
comment|/* now we know whats there, do the real attach, first the ATA disks */
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
comment|/* then the atapi devices */
for|for
control|(
name|ctlr
operator|=
literal|0
init|;
name|ctlr
operator|<
name|devclass_get_maxunit
argument_list|(
name|ata_devclass
argument_list|)
condition|;
name|ctlr
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|scp
operator|=
name|devclass_get_softc
argument_list|(
name|ata_devclass
argument_list|,
name|ctlr
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ata_delayed_attach
condition|)
block|{
name|config_intrhook_disestablish
argument_list|(
name|ata_delayed_attach
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ata_delayed_attach
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|ata_delayed_attach
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ata_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ata_softc
modifier|*
name|scp
init|=
operator|(
expr|struct
name|ata_softc
operator|*
operator|)
name|data
decl_stmt|;
comment|/*       * on PCI systems we might share an interrupt line with another      * device or our twin ATA channel, so call scp->intr_func to figure       * out if it is really an interrupt we should process here      */
if|if
condition|(
name|scp
operator|->
name|intr_func
operator|&&
name|scp
operator|->
name|intr_func
argument_list|(
name|scp
argument_list|)
condition|)
return|return;
comment|/* if drive is busy it didn't interrupt */
if|if
condition|(
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|)
operator|&
name|ATA_S_BUSY
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|)
operator|&
name|ATA_S_DRQ
operator|)
condition|)
return|return;
block|}
comment|/* clear interrupt and get status */
name|scp
operator|->
name|status
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|scp
operator|->
name|error
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
comment|/* find& call the responsible driver to process this interrupt */
switch|switch
condition|(
name|scp
operator|->
name|active
condition|)
block|{
ifdef|#
directive|ifdef
name|DEV_ATADISK
case|case
name|ATA_ACTIVE_ATA
case|:
if|if
condition|(
operator|!
name|scp
operator|->
name|running
operator|||
name|ad_interrupt
argument_list|(
name|scp
operator|->
name|running
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
case|case
name|ATA_ACTIVE_ATAPI
case|:
if|if
condition|(
operator|!
name|scp
operator|->
name|running
operator|||
name|atapi_interrupt
argument_list|(
name|scp
operator|->
name|running
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
break|break;
endif|#
directive|endif
case|case
name|ATA_WAIT_INTR
case|:
case|case
name|ATA_WAIT_INTR
operator||
name|ATA_CONTROL
case|:
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATA_WAIT_READY
case|:
case|case
name|ATA_WAIT_READY
operator||
name|ATA_CONTROL
case|:
break|break;
case|case
name|ATA_IDLE
case|:
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
block|{
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ata_service
argument_list|(
name|scp
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
block|}
comment|/* FALLTHROUGH */
default|default:
ifdef|#
directive|ifdef
name|ATA_DEBUG
block|{
specifier|static
name|int
name|intr_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|intr_count
operator|++
operator|<
literal|10
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"unwanted interrupt %d %sstatus = %02x\n"
argument_list|,
name|intr_count
argument_list|,
name|active2str
argument_list|(
name|scp
operator|->
name|active
argument_list|)
argument_list|,
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|scp
operator|->
name|active
operator|&=
name|ATA_CONTROL
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|active
operator|&
name|ATA_CONTROL
condition|)
return|return;
name|scp
operator|->
name|running
operator|=
name|NULL
expr_stmt|;
name|ata_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ata_start
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEV_ATADISK
name|struct
name|ad_request
modifier|*
name|ad_request
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
name|struct
name|atapi_request
modifier|*
name|atapi_request
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|scp
operator|->
name|active
argument_list|,
name|ATA_IDLE
argument_list|,
name|ATA_ACTIVE
argument_list|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|DEV_ATADISK
comment|/* find& call the responsible driver if anything on the ATA queue */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|ad_start
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|ad_start
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ad_request
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|scp
operator|->
name|ata_queue
argument_list|,
name|ad_request
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE_ATA
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|ad_request
expr_stmt|;
if|if
condition|(
name|ad_transfer
argument_list|(
name|ad_request
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
comment|/* find& call the responsible driver if anything on the ATAPI queue */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|)
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|atapi_start
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|atapi_start
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|atapi_request
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|scp
operator|->
name|atapi_queue
argument_list|,
name|atapi_request
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_ACTIVE_ATAPI
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|atapi_request
expr_stmt|;
if|if
condition|(
name|atapi_transfer
argument_list|(
name|atapi_request
argument_list|)
operator|==
name|ATA_OP_CONTINUES
condition|)
return|return;
block|}
endif|#
directive|endif
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_reset
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
name|u_int8_t
name|lsb
decl_stmt|,
name|msb
decl_stmt|,
name|ostat0
decl_stmt|,
name|ostat1
decl_stmt|;
name|u_int8_t
name|stat0
init|=
name|ATA_S_BUSY
decl_stmt|,
name|stat1
init|=
name|ATA_S_BUSY
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|;
comment|/* do we have any signs of ATA/ATAPI HW being present ? */
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ostat0
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ostat0
operator|&
literal|0xf8
operator|)
operator|!=
literal|0xf8
operator|&&
name|ostat0
operator|!=
literal|0xa5
condition|)
name|mask
operator||=
literal|0x01
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_SLAVE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ostat1
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ostat1
operator|&
literal|0xf8
operator|)
operator|!=
literal|0xf8
operator|&&
name|ostat1
operator|!=
literal|0xa5
condition|)
name|mask
operator||=
literal|0x02
expr_stmt|;
name|scp
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return;
comment|/* in some setups we dont want to test for a slave */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_NO_SLAVE
condition|)
name|mask
operator|&=
operator|~
literal|0x02
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"mask=%02x ostat0=%02x ostat2=%02x\n"
argument_list|,
name|mask
argument_list|,
name|ostat0
argument_list|,
name|ostat1
argument_list|)
expr_stmt|;
comment|/* reset channel */
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_IDS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
comment|/* wait for BUSY to go inactive */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|310000
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|stat0
operator|&
name|ATA_S_BUSY
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|stat0
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
operator|)
condition|)
block|{
comment|/* check for ATAPI signature while its still there */
name|lsb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
name|msb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_MSB
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
literal|"ATAPI probe %02x %02x\n"
argument_list|,
name|lsb
argument_list|,
name|msb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|==
name|ATAPI_MAGIC_LSB
operator|&&
name|msb
operator|==
name|ATAPI_MAGIC_MSB
condition|)
name|scp
operator|->
name|devices
operator||=
name|ATA_ATAPI_MASTER
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat1
operator|&
name|ATA_S_BUSY
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_SLAVE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|stat1
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat1
operator|&
name|ATA_S_BUSY
operator|)
condition|)
block|{
comment|/* check for ATAPI signature while its still there */
name|lsb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
name|msb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_MSB
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
literal|"ATAPI probe %02x %02x\n"
argument_list|,
name|lsb
argument_list|,
name|msb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|==
name|ATAPI_MAGIC_LSB
operator|&&
name|msb
operator|==
name|ATAPI_MAGIC_MSB
condition|)
name|scp
operator|->
name|devices
operator||=
name|ATA_ATAPI_SLAVE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|==
literal|0x01
condition|)
comment|/* wait for master only */
if|if
condition|(
operator|!
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
if|if
condition|(
name|mask
operator|==
literal|0x02
condition|)
comment|/* wait for slave only */
if|if
condition|(
operator|!
operator|(
name|stat1
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
if|if
condition|(
name|mask
operator|==
literal|0x03
condition|)
comment|/* wait for both master& slave */
if|if
condition|(
operator|!
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
operator|)
operator|&&
operator|!
operator|(
name|stat1
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat0
operator|&
name|ATA_S_BUSY
condition|)
name|mask
operator|&=
operator|~
literal|0x01
expr_stmt|;
if|if
condition|(
name|stat1
operator|&
name|ATA_S_BUSY
condition|)
name|mask
operator|&=
operator|~
literal|0x02
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"mask=%02x stat0=%02x stat1=%02x\n"
argument_list|,
name|mask
argument_list|,
name|stat0
argument_list|,
name|stat1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return;
if|if
condition|(
name|mask
operator|&
literal|0x01
operator|&&
name|ostat0
operator|!=
literal|0x00
operator|&&
operator|!
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_MASTER
operator|)
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|,
literal|0x58
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
name|msb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
literal|"ATA probe %02x %02x\n"
argument_list|,
name|lsb
argument_list|,
name|msb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|!=
literal|0x58
operator|&&
name|msb
operator|==
literal|0xa5
condition|)
name|scp
operator|->
name|devices
operator||=
name|ATA_ATA_MASTER
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
literal|0x02
operator|&&
name|ostat1
operator|!=
literal|0x00
operator|&&
operator|!
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATAPI_SLAVE
operator|)
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_SLAVE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|,
literal|0x58
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
name|msb
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
literal|"ATA probe %02x %02x\n"
argument_list|,
name|lsb
argument_list|,
name|msb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsb
operator|!=
literal|0x58
operator|&&
name|msb
operator|==
literal|0xa5
condition|)
name|scp
operator|->
name|devices
operator||=
name|ATA_ATA_SLAVE
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"devices=%02x\n"
argument_list|,
name|scp
operator|->
name|devices
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ata_reinit
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|devices
decl_stmt|,
name|misdev
decl_stmt|,
name|newdev
decl_stmt|;
if|if
condition|(
operator|!
name|scp
operator|->
name|r_io
operator|||
operator|!
name|scp
operator|->
name|r_altio
operator|||
operator|!
name|scp
operator|->
name|r_irq
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|->
name|active
operator|=
name|ATA_CONTROL
expr_stmt|;
name|scp
operator|->
name|running
operator|=
name|NULL
expr_stmt|;
name|devices
operator|=
name|scp
operator|->
name|devices
expr_stmt|;
name|ata_printf
argument_list|(
name|scp
argument_list|,
operator|-
literal|1
argument_list|,
literal|"resetting devices .. "
argument_list|)
expr_stmt|;
name|ata_reset
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|misdev
operator|=
name|devices
operator|&
operator|~
name|scp
operator|->
name|devices
operator|)
condition|)
block|{
if|if
condition|(
name|misdev
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATADISK
if|if
condition|(
name|misdev
operator|&
name|ATA_ATA_MASTER
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|ad_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|misdev
operator|&
name|ATA_ATA_SLAVE
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|ad_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
if|if
condition|(
name|misdev
operator|&
name|ATA_ATAPI_MASTER
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|atapi_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|misdev
operator|&
name|ATA_ATAPI_SLAVE
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|atapi_detach
argument_list|(
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|misdev
operator|&
name|ATA_ATA_MASTER
operator|||
name|misdev
operator|&
name|ATA_ATAPI_MASTER
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|MASTER
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|misdev
operator|&
name|ATA_ATA_SLAVE
operator|||
name|misdev
operator|&
name|ATA_ATAPI_SLAVE
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
name|scp
operator|->
name|dev_param
index|[
name|SLAVE
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|newdev
operator|=
operator|~
name|devices
operator|&
name|scp
operator|->
name|devices
operator|)
condition|)
block|{
if|if
condition|(
name|newdev
operator|&
name|ATA_ATA_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|newdev
operator|&=
operator|~
name|ATA_ATA_MASTER
expr_stmt|;
if|if
condition|(
name|newdev
operator|&
name|ATA_ATA_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATA_IDENTIFY
argument_list|)
condition|)
name|newdev
operator|&=
operator|~
name|ATA_ATA_SLAVE
expr_stmt|;
if|if
condition|(
name|newdev
operator|&
name|ATA_ATAPI_MASTER
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|newdev
operator|&=
operator|~
name|ATA_ATAPI_MASTER
expr_stmt|;
if|if
condition|(
name|newdev
operator|&
name|ATA_ATAPI_SLAVE
condition|)
if|if
condition|(
name|ata_getparam
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|,
name|ATA_C_ATAPI_IDENTIFY
argument_list|)
condition|)
name|newdev
operator|&=
operator|~
name|ATA_ATAPI_SLAVE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|misdev
operator|&&
name|newdev
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATADISK
if|if
condition|(
name|newdev
operator|&
name|ATA_ATA_MASTER
operator|&&
operator|!
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|ad_reinit
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdev
operator|&
name|ATA_ATA_SLAVE
operator|&&
operator|!
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|ad_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATA_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|ad_reinit
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|DEV_ATAPICD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIFD
argument_list|)
operator|||
name|defined
argument_list|(
name|DEV_ATAPIST
argument_list|)
if|if
condition|(
name|newdev
operator|&
name|ATA_ATAPI_MASTER
operator|&&
operator|!
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_MASTER
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
name|atapi_reinit
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdev
operator|&
name|ATA_ATAPI_SLAVE
operator|&&
operator|!
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|atapi_attach
argument_list|(
name|scp
argument_list|,
name|ATA_SLAVE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|devices
operator|&
operator|(
name|ATA_ATAPI_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
name|atapi_reinit
argument_list|(
operator|(
expr|struct
name|atapi_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|ata_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_service
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|)
block|{
comment|/* do we have a SERVICE request from the drive ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
operator|(
name|ATA_S_SERVICE
operator||
name|ATA_S_ERROR
operator||
name|ATA_S_DRQ
operator|)
operator|)
operator|==
name|ATA_S_SERVICE
condition|)
block|{
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_bmio
argument_list|,
name|ATA_BMSTAT_PORT
argument_list|,
name|ata_dmastatus
argument_list|(
name|scp
argument_list|)
operator||
name|ATA_BMSTAT_INTERRUPT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATADISK
if|if
condition|(
operator|(
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|)
operator|&
name|ATA_SLAVE
operator|)
operator|==
name|ATA_MASTER
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_MASTER
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
condition|)
return|return
name|ad_service
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|MASTER
index|]
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|devices
operator|&
name|ATA_ATA_SLAVE
operator|)
operator|&&
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
condition|)
return|return
name|ad_service
argument_list|(
operator|(
expr|struct
name|ad_softc
operator|*
operator|)
name|scp
operator|->
name|dev_softc
index|[
name|SLAVE
index|]
argument_list|,
literal|0
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|ATA_OP_FINISHED
return|;
block|}
end_function

begin_function
name|int
name|ata_wait
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|u_int8_t
name|mask
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|timeout
operator|<
literal|5000000
condition|)
block|{
comment|/* timeout 5 secs */
name|scp
operator|->
name|status
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
comment|/* if drive fails status, reselect the drive just to be sure */
if|if
condition|(
name|scp
operator|->
name|status
operator|==
literal|0xff
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"no status, reselecting device\n"
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* are we done ? */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_BUSY
operator|)
condition|)
break|break;
if|if
condition|(
name|timeout
operator|>
literal|1000
condition|)
block|{
name|timeout
operator|+=
literal|1000
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timeout
operator|+=
literal|10
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|scp
operator|->
name|error
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|>=
literal|5000000
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
operator|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
operator|)
return|;
comment|/* Wait 50 msec for bits wanted. */
name|timeout
operator|=
literal|5000
expr_stmt|;
while|while
condition|(
name|timeout
operator|--
condition|)
block|{
name|scp
operator|->
name|status
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|scp
operator|->
name|error
operator|=
name|ATA_INB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|scp
operator|->
name|status
operator|&
name|ATA_S_ERROR
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_command
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|u_int8_t
name|command
parameter_list|,
name|u_int16_t
name|cylinder
parameter_list|,
name|u_int8_t
name|head
parameter_list|,
name|u_int8_t
name|sector
parameter_list|,
name|u_int8_t
name|count
parameter_list|,
name|u_int8_t
name|feature
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ATA_DEBUG
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"ata_command: addr=%04x, cmd=%02x, "
literal|"c=%d, h=%d, s=%d, count=%d, feature=%d, flags=%02x\n"
argument_list|,
name|rman_get_start
argument_list|(
name|scp
operator|->
name|r_io
argument_list|)
argument_list|,
name|command
argument_list|,
name|cylinder
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|count
argument_list|,
name|feature
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* sanity checks */
switch|switch
condition|(
name|scp
operator|->
name|active
condition|)
block|{
case|case
name|ATA_IDLE
case|:
break|break;
case|case
name|ATA_CONTROL
case|:
if|if
condition|(
name|flags
operator|==
name|ATA_WAIT_INTR
operator|||
name|flags
operator|==
name|ATA_WAIT_READY
condition|)
break|break;
goto|goto
name|out
goto|;
case|case
name|ATA_ACTIVE_ATA
case|:
case|case
name|ATA_ACTIVE_ATAPI
case|:
if|if
condition|(
name|flags
operator|==
name|ATA_IMMEDIATE
condition|)
break|break;
default|default:
name|out
label|:
name|printf
argument_list|(
literal|"ata_command called %s flags=%s cmd=%02x\n"
argument_list|,
name|active2str
argument_list|(
name|scp
operator|->
name|active
argument_list|)
argument_list|,
name|active2str
argument_list|(
name|flags
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* disable interrupt from device */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
comment|/* select device */
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
argument_list|)
expr_stmt|;
comment|/* ready to issue command ? */
if|if
condition|(
name|ata_wait
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"timeout waiting to give command=%02x s=%02x e=%02x\n"
argument_list|,
name|command
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|scp
operator|->
name|error
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_FEATURE
argument_list|,
name|feature
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_COUNT
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_SECTOR
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_MSB
argument_list|,
name|cylinder
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CYL_LSB
argument_list|,
name|cylinder
argument_list|)
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|device
operator||
name|head
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|ATA_WAIT_INTR
case|:
name|scp
operator|->
name|active
operator||=
name|ATA_WAIT_INTR
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CMD
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* enable interrupt */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
name|PRIBIO
argument_list|,
literal|"atacmd"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"ata_command: timeout waiting for intr\n"
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|&=
operator|~
name|ATA_WAIT_INTR
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ATA_WAIT_READY
case|:
name|scp
operator|->
name|active
operator||=
name|ATA_WAIT_READY
expr_stmt|;
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CMD
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_wait
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
name|ATA_S_READY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"timeout waiting for command=%02x s=%02x e=%02x\n"
argument_list|,
name|command
argument_list|,
name|scp
operator|->
name|status
argument_list|,
name|scp
operator|->
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|scp
operator|->
name|active
operator|&=
operator|~
name|ATA_WAIT_READY
expr_stmt|;
break|break;
case|case
name|ATA_IMMEDIATE
case|:
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_io
argument_list|,
name|ATA_CMD
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ata_printf
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
literal|"DANGER: illegal interrupt flag=%s\n"
argument_list|,
name|active2str
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* enable interrupt */
if|if
condition|(
name|scp
operator|->
name|flags
operator|&
name|ATA_QUEUED
condition|)
name|ATA_OUTB
argument_list|(
name|scp
operator|->
name|r_altio
argument_list|,
name|ATA_ALTSTAT
argument_list|,
name|ATA_A_4BIT
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|ata_set_name
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|M_ATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
condition|)
name|strcpy
argument_list|(
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_free_name
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
condition|)
name|free
argument_list|(
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
argument_list|,
name|M_ATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ata_get_lun
parameter_list|(
name|u_int32_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|lun
init|=
name|ffs
argument_list|(
operator|~
operator|*
name|map
argument_list|)
operator|-
literal|1
decl_stmt|;
operator|*
name|map
operator||=
operator|(
literal|1
operator|<<
name|lun
operator|)
expr_stmt|;
return|return
name|lun
return|;
block|}
end_function

begin_function
name|int
name|ata_test_lun
parameter_list|(
name|u_int32_t
modifier|*
name|map
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
return|return
operator|(
operator|*
name|map
operator|&
operator|(
literal|1
operator|<<
name|lun
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ata_free_lun
parameter_list|(
name|u_int32_t
modifier|*
name|map
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
operator|*
name|map
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|lun
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ata_printf
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|device
operator|==
operator|-
literal|1
condition|)
name|ret
operator|=
name|printf
argument_list|(
literal|"ata%d: "
argument_list|,
name|device_get_unit
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
condition|)
name|ret
operator|=
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|scp
operator|->
name|dev_name
index|[
name|ATA_DEV
argument_list|(
name|device
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|printf
argument_list|(
literal|"ata%d-%s: "
argument_list|,
name|device_get_unit
argument_list|(
name|scp
operator|->
name|dev
argument_list|)
argument_list|,
operator|(
name|device
operator|==
name|ATA_MASTER
operator|)
condition|?
literal|"master"
else|:
literal|"slave"
argument_list|)
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ata_mode2str
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ATA_PIO
case|:
return|return
literal|"BIOSPIO"
return|;
case|case
name|ATA_PIO0
case|:
return|return
literal|"PIO0"
return|;
case|case
name|ATA_PIO1
case|:
return|return
literal|"PIO1"
return|;
case|case
name|ATA_PIO2
case|:
return|return
literal|"PIO2"
return|;
case|case
name|ATA_PIO3
case|:
return|return
literal|"PIO3"
return|;
case|case
name|ATA_PIO4
case|:
return|return
literal|"PIO4"
return|;
case|case
name|ATA_WDMA2
case|:
return|return
literal|"WDMA2"
return|;
case|case
name|ATA_UDMA2
case|:
return|return
literal|"UDMA33"
return|;
case|case
name|ATA_UDMA4
case|:
return|return
literal|"UDMA66"
return|;
case|case
name|ATA_UDMA5
case|:
return|return
literal|"UDMA100"
return|;
case|case
name|ATA_DMA
case|:
return|return
literal|"BIOSDMA"
return|;
default|default:
return|return
literal|"???"
return|;
block|}
block|}
end_function

begin_function
name|int
name|ata_pio2mode
parameter_list|(
name|int
name|pio
parameter_list|)
block|{
switch|switch
condition|(
name|pio
condition|)
block|{
default|default:
case|case
literal|0
case|:
return|return
name|ATA_PIO0
return|;
case|case
literal|1
case|:
return|return
name|ATA_PIO1
return|;
case|case
literal|2
case|:
return|return
name|ATA_PIO2
return|;
case|case
literal|3
case|:
return|return
name|ATA_PIO3
return|;
case|case
literal|4
case|:
return|return
name|ATA_PIO4
return|;
block|}
block|}
end_function

begin_function
name|int
name|ata_pmode
parameter_list|(
name|struct
name|ata_params
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|atavalid
operator|&
name|ATA_FLAG_64_70
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|apiomodes
operator|&
literal|2
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|ap
operator|->
name|apiomodes
operator|&
literal|1
condition|)
return|return
literal|3
return|;
block|}
if|if
condition|(
name|ap
operator|->
name|opiomode
operator|==
literal|2
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ap
operator|->
name|opiomode
operator|==
literal|1
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ap
operator|->
name|opiomode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_wmode
parameter_list|(
name|struct
name|ata_params
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|wdmamodes
operator|&
literal|4
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ap
operator|->
name|wdmamodes
operator|&
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ap
operator|->
name|wdmamodes
operator|&
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_umode
parameter_list|(
name|struct
name|ata_params
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|atavalid
operator|&
name|ATA_FLAG_88
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x20
condition|)
return|return
literal|5
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x10
condition|)
return|return
literal|4
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x08
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x04
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x02
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ap
operator|->
name|udmamodes
operator|&
literal|0x01
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|active2str
parameter_list|(
name|int
name|active
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_IDLE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_IDLE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_IMMEDIATE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_IMMEDIATE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_WAIT_INTR
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_WAIT_INTR "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_WAIT_READY
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_WAIT_READY "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_ACTIVE
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_ACTIVE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_ACTIVE_ATA
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_ACTIVE_ATA "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_ACTIVE_ATAPI
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_ACTIVE_ATAPI "
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|&
name|ATA_CONTROL
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ATA_CONTROL "
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bswap
parameter_list|(
name|int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int16_t
modifier|*
name|ptr
init|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|buf
operator|+
name|len
operator|)
decl_stmt|;
while|while
condition|(
operator|--
name|ptr
operator|>=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
condition|)
operator|*
name|ptr
operator|=
name|ntohs
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btrim
parameter_list|(
name|int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int8_t
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
init|;
name|ptr
operator|<
name|buf
operator|+
name|len
condition|;
operator|++
name|ptr
control|)
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
operator|+
name|len
operator|-
literal|1
init|;
name|ptr
operator|>=
name|buf
operator|&&
operator|*
name|ptr
operator|==
literal|' '
condition|;
operator|--
name|ptr
control|)
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpack
parameter_list|(
name|int8_t
modifier|*
name|src
parameter_list|,
name|int8_t
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|blank
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
name|blank
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|blank
operator|&&
name|src
index|[
name|i
index|]
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|blank
operator|&&
name|src
index|[
name|i
index|]
operator|!=
literal|' '
condition|)
block|{
name|dst
index|[
name|j
operator|++
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
name|blank
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|src
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
name|blank
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
block|}
name|dst
index|[
name|j
operator|++
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|len
condition|)
name|dst
index|[
name|j
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_change_mode
parameter_list|(
name|struct
name|ata_softc
modifier|*
name|scp
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|umode
decl_stmt|,
name|wmode
decl_stmt|,
name|pmode
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|scp
operator|->
name|active
argument_list|,
name|ATA_IDLE
argument_list|,
name|ATA_ACTIVE
argument_list|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|,
name|PRIBIO
argument_list|,
literal|"atachm"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|umode
operator|=
name|ata_umode
argument_list|(
name|ATA_PARAM
argument_list|(
name|scp
argument_list|,
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|wmode
operator|=
name|ata_wmode
argument_list|(
name|ATA_PARAM
argument_list|(
name|scp
argument_list|,
name|device
argument_list|)
argument_list|)
expr_stmt|;
name|pmode
operator|=
name|ata_pmode
argument_list|(
name|ATA_PARAM
argument_list|(
name|scp
argument_list|,
name|device
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|ATA_DMA_MASK
condition|)
block|{
case|case
name|ATA_UDMA
case|:
if|if
condition|(
operator|(
name|mode
operator|&
name|ATA_MODE_MASK
operator|)
operator|<
name|umode
condition|)
name|umode
operator|=
name|mode
operator|&
name|ATA_MODE_MASK
expr_stmt|;
break|break;
case|case
name|ATA_WDMA
case|:
if|if
condition|(
operator|(
name|mode
operator|&
name|ATA_MODE_MASK
operator|)
operator|<
name|wmode
condition|)
name|wmode
operator|=
name|mode
operator|&
name|ATA_MODE_MASK
expr_stmt|;
name|umode
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|ATA_MODE_MASK
operator|)
operator|-
name|ATA_PIO0
operator|)
operator|<
name|pmode
condition|)
name|pmode
operator|=
operator|(
name|mode
operator|&
name|ATA_MODE_MASK
operator|)
operator|-
name|ATA_PIO0
expr_stmt|;
name|umode
operator|=
operator|-
literal|1
expr_stmt|;
name|wmode
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|ata_dmainit
argument_list|(
name|scp
argument_list|,
name|device
argument_list|,
name|pmode
argument_list|,
name|wmode
argument_list|,
name|umode
argument_list|)
expr_stmt|;
name|scp
operator|->
name|active
operator|=
name|ATA_IDLE
expr_stmt|;
name|ata_start
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* register controlling device */
name|make_dev
argument_list|(
operator|&
name|ata_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"ata"
argument_list|)
expr_stmt|;
comment|/* register boot attach to be run when interrupts are enabled */
if|if
condition|(
operator|!
operator|(
name|ata_delayed_attach
operator|=
operator|(
expr|struct
name|intr_config_hook
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_config_hook
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ata: malloc of delayed attach hook failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ata_delayed_attach
operator|->
name|ich_func
operator|=
operator|(
name|void
operator|*
operator|)
name|ata_boot_attach
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
name|ata_delayed_attach
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ata: config_intrhook_establish failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ata_delayed_attach
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|atadev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_SECOND
argument_list|,
argument|ata_init
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

