begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 - 2008 SÃ¸ren Schmidt<sos@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ata.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-all.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-pci.h>
end_include

begin_include
include|#
directive|include
file|<ata_if.h>
end_include

begin_comment
comment|/* local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|ata_ahci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_status
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_begin_transaction
parameter_list|(
name|struct
name|ata_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_end_transaction
parameter_list|(
name|struct
name|ata_request
modifier|*
name|request
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_pm_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_pm_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_hardreset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|uint32_t
modifier|*
name|signature
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|ata_ahci_softreset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ata_ahci_setup_fis
parameter_list|(
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|struct
name|ata_request
modifier|*
name|equest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_start
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_clo
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_start_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_ahci_stop_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * AHCI v1.x compliant SATA chipset support functions  */
end_comment

begin_function
specifier|static
name|int
name|ata_ahci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
comment|/* is this a possible AHCI candidate ? */
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIC_STORAGE
operator|||
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIS_STORAGE_SATA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* is this PCI device flagged as an AHCI compliant chip ? */
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIP_STORAGE_SATA_AHCI_1_0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s (ID=%08x) AHCI controller"
argument_list|,
name|ata_pcivendor2str
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%s AHCI controller"
argument_list|,
name|ata_pcivendor2str
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|chipinit
operator|=
name|ata_ahci_chipinit
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ata_ahci_chipinit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|speed
decl_stmt|;
name|u_int32_t
name|caps
decl_stmt|,
name|version
decl_stmt|;
comment|/* if we have a memory BAR(5) we are likely on an AHCI part */
name|ctlr
operator|->
name|r_type2
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|ctlr
operator|->
name|r_rid2
operator|=
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|r_res2
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|r_type2
argument_list|,
operator|&
name|ctlr
operator|->
name|r_rid2
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/* setup interrupt delivery if not done allready by a vendor driver */
if|if
condition|(
operator|!
name|ctlr
operator|->
name|r_irq
condition|)
block|{
if|if
condition|(
name|ata_setup_interrupt
argument_list|(
name|dev
argument_list|,
name|ata_generic_intr
argument_list|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|r_type2
argument_list|,
name|ctlr
operator|->
name|r_rid2
argument_list|,
name|ctlr
operator|->
name|r_res2
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI called from vendor specific driver\n"
argument_list|)
expr_stmt|;
comment|/* reset controller */
if|if
condition|(
operator|(
name|error
operator|=
name|ata_ahci_ctlr_reset
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|r_type2
argument_list|,
name|ctlr
operator|->
name|r_rid2
argument_list|,
name|ctlr
operator|->
name|r_res2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
empty_stmt|;
comment|/* get the number of HW channels */
name|ctlr
operator|->
name|ichannels
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_PI
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|channels
operator|=
name|MAX
argument_list|(
name|flsl
argument_list|(
name|ctlr
operator|->
name|ichannels
argument_list|)
argument_list|,
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_CAP
argument_list|)
operator|&
name|ATA_AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|reset
operator|=
name|ata_ahci_reset
expr_stmt|;
name|ctlr
operator|->
name|ch_attach
operator|=
name|ata_ahci_ch_attach
expr_stmt|;
name|ctlr
operator|->
name|ch_detach
operator|=
name|ata_ahci_ch_detach
expr_stmt|;
name|ctlr
operator|->
name|ch_suspend
operator|=
name|ata_ahci_ch_suspend
expr_stmt|;
name|ctlr
operator|->
name|ch_resume
operator|=
name|ata_ahci_ch_resume
expr_stmt|;
name|ctlr
operator|->
name|setmode
operator|=
name|ata_sata_setmode
expr_stmt|;
name|ctlr
operator|->
name|suspend
operator|=
name|ata_ahci_suspend
expr_stmt|;
name|ctlr
operator|->
name|resume
operator|=
name|ata_ahci_ctlr_reset
expr_stmt|;
comment|/* announce we support the HW */
name|version
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_VS
argument_list|)
expr_stmt|;
name|caps
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_CAP
argument_list|)
expr_stmt|;
name|speed
operator|=
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_ISS
operator|)
operator|>>
name|ATA_AHCI_CAP_ISS_SHIFT
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI v%x.%02x controller with %d %sGbps ports, PM %s\n"
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|20
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
operator|(
name|version
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
name|version
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SPM
operator|)
condition|?
literal|"supported"
else|:
literal|"not supported"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps:%s%s%s%s%s%s%s%s %sGbps"
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_64BIT
operator|)
condition|?
literal|" 64bit"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SNCQ
operator|)
condition|?
literal|" NCQ"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SSNTF
operator|)
condition|?
literal|" SNTF"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SMPS
operator|)
condition|?
literal|" MPS"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SSS
operator|)
condition|?
literal|" SS"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SALP
operator|)
condition|?
literal|" ALP"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SAL
operator|)
condition|?
literal|" AL"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SCLO
operator|)
condition|?
literal|" CLO"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s%s%s%s%s %dcmd%s%s%s %dports\n"
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SAM
operator|)
condition|?
literal|" AM"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SPM
operator|)
condition|?
literal|" PM"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_FBSS
operator|)
condition|?
literal|" FBS"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_PMD
operator|)
condition|?
literal|" PMD"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SSC
operator|)
condition|?
literal|" SSC"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_PSC
operator|)
condition|?
literal|" PSC"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_NCS
operator|)
operator|>>
name|ATA_AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_CCCS
operator|)
condition|?
literal|" CCC"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_EMS
operator|)
condition|?
literal|" EM"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_SXS
operator|)
condition|?
literal|" eSATA"
else|:
literal|""
argument_list|,
operator|(
name|caps
operator|&
name|ATA_AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ata_ahci_ctlr_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* enable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|,
name|ATA_AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* reset AHCI controller */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|,
name|ATA_AHCI_GHC_AE
operator||
name|ATA_AHCI_GHC_HR
argument_list|)
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|1000
init|;
name|timeout
operator|>
literal|0
condition|;
name|timeout
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|)
operator|&
name|ATA_AHCI_GHC_HR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI controller reset failure\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* reenable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|,
name|ATA_AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* clear interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_IS
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_IS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable AHCI interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|)
operator||
name|ATA_AHCI_GHC_IE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* disable interupts so the state change(s) doesn't trigger */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_GHC
argument_list|)
operator|&
operator|(
operator|~
name|ATA_AHCI_GHC_IE
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ata_ahci_ch_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|ata_ahci_dmainit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* set the SATA resources */
name|ch
operator|->
name|r_io
index|[
name|ATA_SSTATUS
index|]
operator|.
name|res
operator|=
name|ctlr
operator|->
name|r_res2
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SSTATUS
index|]
operator|.
name|offset
operator|=
name|ATA_AHCI_P_SSTS
operator|+
name|offset
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SERROR
index|]
operator|.
name|res
operator|=
name|ctlr
operator|->
name|r_res2
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SERROR
index|]
operator|.
name|offset
operator|=
name|ATA_AHCI_P_SERR
operator|+
name|offset
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SCONTROL
index|]
operator|.
name|res
operator|=
name|ctlr
operator|->
name|r_res2
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SCONTROL
index|]
operator|.
name|offset
operator|=
name|ATA_AHCI_P_SCTL
operator|+
name|offset
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SACTIVE
index|]
operator|.
name|res
operator|=
name|ctlr
operator|->
name|r_res2
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SACTIVE
index|]
operator|.
name|offset
operator|=
name|ATA_AHCI_P_SACT
operator|+
name|offset
expr_stmt|;
name|ch
operator|->
name|hw
operator|.
name|status
operator|=
name|ata_ahci_status
expr_stmt|;
name|ch
operator|->
name|hw
operator|.
name|begin_transaction
operator|=
name|ata_ahci_begin_transaction
expr_stmt|;
name|ch
operator|->
name|hw
operator|.
name|end_transaction
operator|=
name|ata_ahci_end_transaction
expr_stmt|;
name|ch
operator|->
name|hw
operator|.
name|command
operator|=
name|NULL
expr_stmt|;
comment|/* not used here */
name|ch
operator|->
name|hw
operator|.
name|softreset
operator|=
name|ata_ahci_softreset
expr_stmt|;
name|ch
operator|->
name|hw
operator|.
name|pm_read
operator|=
name|ata_ahci_pm_read
expr_stmt|;
name|ch
operator|->
name|hw
operator|.
name|pm_write
operator|=
name|ata_ahci_pm_write
expr_stmt|;
name|ata_ahci_ch_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ata_ahci_ch_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|ata_ahci_ch_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ata_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ata_ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
comment|/* Disable port interrupts. */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IE
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset command register. */
name|ata_ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ata_ahci_stop_fr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow everything including partial and slumber modes. */
name|ATA_IDX_OUTL
argument_list|(
name|ch
argument_list|,
name|ATA_SCONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Request slumber mode transition and give some time to get there. */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|ATA_AHCI_P_CMD_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Disable PHY. */
name|ATA_IDX_OUTL
argument_list|(
name|ch
argument_list|,
name|ATA_SCONTROL
argument_list|,
name|ATA_SC_DET_DISABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ata_ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint64_t
name|work
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IE
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* setup work areas */
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|ATA_AHCI_CL_OFFSET
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CLB
operator|+
name|offset
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CLBU
operator|+
name|offset
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|ATA_AHCI_FB_OFFSET
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_FB
operator|+
name|offset
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_FBU
operator|+
name|offset
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
comment|/* activate the channel and power/spin up device */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
operator|(
name|ATA_AHCI_P_CMD_ACTIVE
operator||
name|ATA_AHCI_P_CMD_POD
operator||
name|ATA_AHCI_P_CMD_SUD
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|1
operator|)
condition|?
name|ATA_AHCI_P_CMD_ALPE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|2
operator|)
condition|?
name|ATA_AHCI_P_CMD_ASP
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ata_ahci_start_fr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ata_ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_status
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|action
init|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_IS
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
define|#
directive|define
name|ATA_AHCI_STATBITS
define|\
value|(ATA_AHCI_P_IX_IF|ATA_AHCI_P_IX_HBD|ATA_AHCI_P_IX_HBF|ATA_AHCI_P_IX_TFE)
if|if
condition|(
name|action
operator|&
operator|(
literal|1
operator|<<
name|ch
operator|->
name|unit
operator|)
condition|)
block|{
name|u_int32_t
name|istatus
init|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IS
operator|+
name|offset
argument_list|)
decl_stmt|;
name|u_int32_t
name|cstatus
init|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CI
operator|+
name|offset
argument_list|)
decl_stmt|;
comment|/* clear interrupt(s) */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IS
operator|+
name|offset
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_IS
argument_list|,
literal|1
operator|<<
name|ch
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* do we have any PHY events ? */
if|if
condition|(
name|istatus
operator|&
operator|(
name|ATA_AHCI_P_IX_PRC
operator||
name|ATA_AHCI_P_IX_PC
operator|)
condition|)
name|ata_sata_phy_check_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* do we have a potentially hanging engine to take care of? */
comment|/* XXX SOS what todo on NCQ */
if|if
condition|(
operator|(
name|istatus
operator|&
name|ATA_AHCI_STATBITS
operator|)
operator|&&
operator|(
name|cstatus
operator|&
literal|1
operator|)
condition|)
block|{
name|u_int32_t
name|cmd
init|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|;
comment|/* kill off all activity on this channel */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
operator|&
operator|~
operator|(
name|ATA_AHCI_P_CMD_FRE
operator||
name|ATA_AHCI_P_CMD_ST
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX SOS this is not entirely wrong */
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
operator|&
name|ATA_AHCI_P_CMD_CR
condition|)
do|;
comment|/* start operations on this channel */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
operator||
operator|(
name|ATA_AHCI_P_CMD_FRE
operator||
name|ATA_AHCI_P_CMD_ST
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* XXX SOS what todo on NCQ */
return|return
operator|(
operator|!
operator|(
name|cstatus
operator|&
literal|1
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* must be called with ATA channel locked and state_mtx held */
end_comment

begin_function
specifier|static
name|int
name|ata_ahci_begin_transaction
parameter_list|(
name|struct
name|ata_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|request
operator|->
name|parent
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|request
operator|->
name|parent
argument_list|)
decl_stmt|;
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ata_ahci_cmd_list
modifier|*
name|clp
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|int
name|port
init|=
name|request
operator|->
name|unit
operator|&
literal|0x0f
decl_stmt|;
name|int
name|entries
init|=
literal|0
decl_stmt|;
name|int
name|fis_size
decl_stmt|;
comment|/* get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ata_ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CT_OFFSET
operator|)
expr_stmt|;
comment|/* setup the FIS for this request */
if|if
condition|(
operator|!
operator|(
name|fis_size
operator|=
name|ata_ahci_setup_fis
argument_list|(
name|ctp
argument_list|,
name|request
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|request
operator|->
name|parent
argument_list|,
literal|"setting up SATA FIS failed\n"
argument_list|)
expr_stmt|;
name|request
operator|->
name|result
operator|=
name|EIO
expr_stmt|;
return|return
name|ATA_OP_FINISHED
return|;
block|}
comment|/* if request moves data setup and load SG list */
if|if
condition|(
name|request
operator|->
name|flags
operator|&
operator|(
name|ATA_R_READ
operator||
name|ATA_R_WRITE
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|load
argument_list|(
name|request
argument_list|,
name|ctp
operator|->
name|prd_tab
argument_list|,
operator|&
name|entries
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|request
operator|->
name|parent
argument_list|,
literal|"setting up DMA failed\n"
argument_list|)
expr_stmt|;
name|request
operator|->
name|result
operator|=
name|EIO
expr_stmt|;
return|return
name|ATA_OP_FINISHED
return|;
block|}
block|}
comment|/* setup the command list entry */
name|clp
operator|=
operator|(
expr|struct
name|ata_ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CL_OFFSET
operator|)
expr_stmt|;
name|clp
operator|->
name|prd_length
operator|=
name|entries
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator|=
operator|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_WRITE
condition|?
name|ATA_AHCI_CMD_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_ATAPI
condition|?
operator|(
name|ATA_AHCI_CMD_ATAPI
operator||
name|ATA_AHCI_CMD_PREFETCH
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|fis_size
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator||
operator|(
name|port
operator|<<
literal|12
operator|)
expr_stmt|;
name|clp
operator|->
name|bytecount
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|cmd_table_phys
operator|=
name|htole64
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|ATA_AHCI_CT_OFFSET
argument_list|)
expr_stmt|;
comment|/* set command type bit */
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_ATAPI
condition|)
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
operator||
name|ATA_AHCI_P_CMD_ATAPI
argument_list|)
expr_stmt|;
else|else
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
operator|&
operator|~
name|ATA_AHCI_P_CMD_ATAPI
argument_list|)
expr_stmt|;
comment|/* issue command to controller */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CI
operator|+
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_ATAPI
operator|)
condition|)
block|{
comment|/* device reset doesn't interrupt */
if|if
condition|(
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|command
operator|==
name|ATA_DEVICE_RESET
condition|)
block|{
name|u_int32_t
name|tf_data
decl_stmt|;
name|int
name|timeout
init|=
literal|1000000
decl_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tf_data
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_TFD
operator|+
operator|(
name|ch
operator|->
name|unit
operator|<<
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|tf_data
operator|&
name|ATA_S_BUSY
operator|)
operator|&&
name|timeout
operator|--
condition|)
do|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"device_reset timeout=%dus\n"
argument_list|,
operator|(
literal|1000000
operator|-
name|timeout
operator|)
operator|*
literal|10
argument_list|)
expr_stmt|;
name|request
operator|->
name|status
operator|=
name|tf_data
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|request
operator|->
name|error
operator|=
name|tf_data
operator|>>
literal|8
expr_stmt|;
return|return
name|ATA_OP_FINISHED
return|;
block|}
block|}
comment|/* start the timeout */
name|callout_reset
argument_list|(
operator|&
name|request
operator|->
name|callout
argument_list|,
name|request
operator|->
name|timeout
operator|*
name|hz
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ata_timeout
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return
name|ATA_OP_CONTINUES
return|;
block|}
end_function

begin_comment
comment|/* must be called with ATA channel locked and state_mtx held */
end_comment

begin_function
specifier|static
name|int
name|ata_ahci_end_transaction
parameter_list|(
name|struct
name|ata_request
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|request
operator|->
name|parent
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|request
operator|->
name|parent
argument_list|)
decl_stmt|;
name|struct
name|ata_ahci_cmd_list
modifier|*
name|clp
decl_stmt|;
name|u_int32_t
name|tf_data
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
comment|/* kill the timeout */
name|callout_stop
argument_list|(
operator|&
name|request
operator|->
name|callout
argument_list|)
expr_stmt|;
comment|/* get status */
name|tf_data
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_TFD
operator|+
name|offset
argument_list|)
expr_stmt|;
name|request
operator|->
name|status
operator|=
name|tf_data
expr_stmt|;
comment|/* if error status get details */
if|if
condition|(
name|request
operator|->
name|status
operator|&
name|ATA_S_ERROR
condition|)
name|request
operator|->
name|error
operator|=
name|tf_data
operator|>>
literal|8
expr_stmt|;
comment|/* on control commands read back registers to the request struct */
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_CONTROL
condition|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_FB_OFFSET
operator|+
literal|0x40
decl_stmt|;
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|count
operator|=
name|fis
index|[
literal|12
index|]
operator||
operator|(
operator|(
name|u_int16_t
operator|)
name|fis
index|[
literal|13
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|=
name|fis
index|[
literal|4
index|]
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|fis
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|fis
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_48BIT
condition|)
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator||=
operator|(
operator|(
name|u_int64_t
operator|)
name|fis
index|[
literal|8
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|fis
index|[
literal|9
index|]
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|u_int64_t
operator|)
name|fis
index|[
literal|10
index|]
operator|<<
literal|40
operator|)
expr_stmt|;
else|else
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator||=
operator|(
call|(
name|u_int64_t
call|)
argument_list|(
name|fis
index|[
literal|7
index|]
operator|&
literal|0x0f
argument_list|)
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
comment|/* record how much data we actually moved */
name|clp
operator|=
operator|(
expr|struct
name|ata_ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CL_OFFSET
operator|)
expr_stmt|;
name|request
operator|->
name|donecount
operator|=
name|clp
operator|->
name|bytecount
expr_stmt|;
comment|/* release SG list etc */
name|ch
operator|->
name|dma
operator|.
name|unload
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return
name|ATA_OP_FINISHED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_issue_cmd
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int16_t
name|flags
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ata_ahci_cmd_list
modifier|*
name|clp
init|=
operator|(
expr|struct
name|ata_ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CL_OFFSET
operator|)
decl_stmt|;
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
init|=
operator|(
expr|struct
name|ata_ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CT_OFFSET
operator|)
decl_stmt|;
name|u_int32_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|int
name|port
init|=
operator|(
name|ctp
operator|->
name|cfis
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
decl_stmt|;
name|int
name|count
decl_stmt|;
name|clp
operator|->
name|prd_length
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator|=
operator|(
literal|20
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator||
name|flags
operator||
operator|(
name|port
operator|<<
literal|12
operator|)
expr_stmt|;
name|clp
operator|->
name|bytecount
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|cmd_table_phys
operator|=
name|htole64
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|ATA_AHCI_CT_OFFSET
argument_list|)
expr_stmt|;
comment|/* issue command to controller */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CI
operator|+
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* poll for command finished */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|timeout
condition|;
name|count
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|status
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CI
operator|+
name|offset
argument_list|)
operator|)
operator|&
literal|1
operator|)
condition|)
break|break;
block|}
comment|/* clear interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IS
operator|+
name|offset
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IS
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|&&
operator|(
name|count
operator|>=
name|timeout
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ahci_issue_cmd timeout: %d of %dms, status=%08x\n"
argument_list|,
name|count
argument_list|,
name|timeout
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_pm_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
init|=
operator|(
expr|struct
name|ata_ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CT_OFFSET
operator|)
decl_stmt|;
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_FB_OFFSET
operator|+
literal|0x40
decl_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|ctp
operator|->
name|cfis
index|[
literal|1
index|]
operator|=
literal|0x8f
expr_stmt|;
comment|/* command FIS to PM port */
name|ctp
operator|->
name|cfis
index|[
literal|2
index|]
operator|=
name|ATA_READ_PM
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|3
index|]
operator|=
name|reg
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|7
index|]
operator|=
name|port
operator||
name|ATA_D_LBA
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
if|if
condition|(
name|ata_ahci_issue_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error reading PM port\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
operator|*
name|result
operator|=
name|fis
index|[
literal|12
index|]
operator||
operator|(
name|fis
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|fis
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|fis
index|[
literal|6
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_pm_write
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_int32_t
name|value
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
init|=
operator|(
expr|struct
name|ata_ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CT_OFFSET
operator|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|ctp
operator|->
name|cfis
index|[
literal|1
index|]
operator|=
literal|0x8f
expr_stmt|;
comment|/* command FIS to PM port */
name|ctp
operator|->
name|cfis
index|[
literal|2
index|]
operator|=
name|ATA_WRITE_PM
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|3
index|]
operator|=
name|reg
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|7
index|]
operator|=
name|port
operator||
name|ATA_D_LBA
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|12
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|4
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
empty_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|5
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
empty_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|6
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
empty_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
if|if
condition|(
name|ata_ahci_issue_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error writing PM port\n"
argument_list|)
expr_stmt|;
return|return
name|ATA_E_ABORT
return|;
block|}
return|return
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_TFD
operator|+
name|offset
argument_list|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* kill off all activity on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
operator|&
operator|~
name|ATA_AHCI_P_CMD_ST
argument_list|)
expr_stmt|;
comment|/* XXX SOS this is not entirely wrong */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
operator|&
name|ATA_AHCI_P_CMD_CR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_clo
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* issue Command List Override if supported */
if|if
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_CAP
argument_list|)
operator|&
name|ATA_AHCI_CAP_SCLO
condition|)
block|{
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|ATA_AHCI_P_CMD_CLO
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"executing CLO failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
operator|&
name|ATA_AHCI_P_CMD_CLO
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_start
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
comment|/* clear SATA error register */
name|ATA_IDX_OUTL
argument_list|(
name|ch
argument_list|,
name|ATA_SERROR
argument_list|,
name|ATA_IDX_INL
argument_list|(
name|ch
argument_list|,
name|ATA_SERROR
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear any interrupts pending on this channel */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IS
operator|+
name|offset
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IS
operator|+
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start operations on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
operator||
name|ATA_AHCI_P_CMD_ST
operator||
operator|(
name|ch
operator|->
name|devices
operator|&
name|ATA_PORTMULTIPLIER
condition|?
name|ATA_AHCI_P_CMD_PMA
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_stop_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* kill off all activity on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
operator|&
operator|~
name|ATA_AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI FR engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
operator|&
name|ATA_AHCI_P_CMD_FR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_start_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
comment|/* start FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_CMD
operator|+
name|offset
argument_list|,
name|cmd
operator||
name|ATA_AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_wait_ready
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_TFD
operator|+
name|offset
argument_list|)
operator|)
operator|&
operator|(
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
name|t
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port is not ready (timeout %dms) tfd = %08x\n"
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ready wait time=%dms\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_hardreset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|uint32_t
modifier|*
name|signature
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
operator|*
name|signature
operator|=
literal|0xffffffff
expr_stmt|;
name|ata_ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Reset port */
if|if
condition|(
operator|!
name|ata_sata_phy_reset
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Wait for clearing busy status. */
if|if
condition|(
name|ata_ahci_wait_ready
argument_list|(
name|dev
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hardware reset timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
operator|*
name|signature
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_SIG
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ata_ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|ata_ahci_softreset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
init|=
operator|(
expr|struct
name|ata_ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|ATA_AHCI_CT_OFFSET
operator|)
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"software reset port %d...\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* kick controller into sane state */
name|ata_ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ata_ahci_clo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ata_ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* pull reset active */
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|1
index|]
operator|=
name|port
operator|&
literal|0x0f
expr_stmt|;
comment|//ctp->cfis[7] = ATA_D_LBA | ATA_D_IBM;
name|ctp
operator|->
name|cfis
index|[
literal|15
index|]
operator|=
operator|(
name|ATA_A_4BIT
operator||
name|ATA_A_RESET
operator|)
expr_stmt|;
if|if
condition|(
name|ata_ahci_issue_cmd
argument_list|(
name|dev
argument_list|,
name|ATA_AHCI_CMD_RESET
operator||
name|ATA_AHCI_CMD_CLR_BUSY
argument_list|,
literal|100
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"software reset set timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ata_udelay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* pull reset inactive -> device softreset */
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
name|ctp
operator|->
name|cfis
index|[
literal|1
index|]
operator|=
name|port
operator|&
literal|0x0f
expr_stmt|;
comment|//ctp->cfis[7] = ATA_D_LBA | ATA_D_IBM;
name|ctp
operator|->
name|cfis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
name|ata_ahci_issue_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|3000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_ahci_wait_ready
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"software reset clear timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_SIG
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ata_ahci_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|signature
decl_stmt|;
name|int
name|offset
init|=
name|ch
operator|->
name|unit
operator|<<
literal|7
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset...\n"
argument_list|)
expr_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IE
operator|+
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_ahci_hardreset
argument_list|(
name|dev
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|signature
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset done: phy reset found no device\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
comment|/* enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IE
operator|+
name|offset
argument_list|,
operator|(
name|ATA_AHCI_P_IX_CPD
operator||
name|ATA_AHCI_P_IX_PRC
operator||
name|ATA_AHCI_P_IX_PC
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_P_IE
operator|+
name|offset
argument_list|,
operator|(
name|ATA_AHCI_P_IX_CPD
operator||
name|ATA_AHCI_P_IX_TFE
operator||
name|ATA_AHCI_P_IX_HBF
operator||
name|ATA_AHCI_P_IX_HBD
operator||
name|ATA_AHCI_P_IX_IF
operator||
name|ATA_AHCI_P_IX_OF
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|?
name|ATA_AHCI_P_IX_PRC
operator||
name|ATA_AHCI_P_IX_PC
else|:
literal|0
operator|)
operator||
name|ATA_AHCI_P_IX_DP
operator||
name|ATA_AHCI_P_IX_UF
operator||
name|ATA_AHCI_P_IX_SDB
operator||
name|ATA_AHCI_P_IX_DS
operator||
name|ATA_AHCI_P_IX_PS
operator||
name|ATA_AHCI_P_IX_DHR
operator|)
argument_list|)
expr_stmt|;
comment|/* only probe for PortMultiplier if HW has support */
if|if
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_CAP
argument_list|)
operator|&
name|ATA_AHCI_CAP_SPM
condition|)
block|{
name|signature
operator|=
name|ata_ahci_softreset
argument_list|(
name|dev
argument_list|,
name|ATA_PM
argument_list|)
expr_stmt|;
comment|/* Workaround for some ATI chips, failing to soft-reset 	 * when port multiplicator supported, but absent. 	 * XXX: We can also check PxIS.IPMS==1 here to be sure. */
if|if
condition|(
name|signature
operator|==
literal|0xffffffff
condition|)
name|signature
operator|=
name|ata_ahci_softreset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signature
operator|=
name|ata_ahci_softreset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SIGNATURE: %08x\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|signature
operator|>>
literal|16
condition|)
block|{
case|case
literal|0x0000
case|:
name|ch
operator|->
name|devices
operator|=
name|ATA_ATA_MASTER
expr_stmt|;
break|break;
case|case
literal|0x9669
case|:
name|ch
operator|->
name|devices
operator|=
name|ATA_PORTMULTIPLIER
expr_stmt|;
name|ata_pm_identify
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xeb14
case|:
name|ch
operator|->
name|devices
operator|=
name|ATA_ATAPI_MASTER
expr_stmt|;
break|break;
default|default:
comment|/* SOS XXX */
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown signature, assuming disk device\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
name|ATA_ATA_MASTER
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset done: devices=%08x\n"
argument_list|,
name|ch
operator|->
name|devices
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ata_dmasetprd_args
modifier|*
name|args
init|=
name|xsc
decl_stmt|;
name|struct
name|ata_ahci_dma_prd
modifier|*
name|prd
init|=
name|args
operator|->
name|dmatab
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|args
operator|->
name|error
operator|=
name|error
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|prd
index|[
name|i
index|]
operator|.
name|dba
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|dbc
operator|=
name|htole32
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
literal|1
operator|)
operator|&
name|ATA_AHCI_PRD_MASK
argument_list|)
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|ATA_AHCI_DMA_ENTRIES
argument_list|,
operator|(
literal|"too many DMA segment entries\n"
operator|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|nsegs
operator|=
name|nsegs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_pci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ata_dmainit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* note start and stop are not used here */
name|ch
operator|->
name|dma
operator|.
name|setprd
operator|=
name|ata_ahci_dmasetprd
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|max_iosize
operator|=
operator|(
name|ATA_AHCI_DMA_ENTRIES
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_res2
argument_list|,
name|ATA_AHCI_CAP
argument_list|)
operator|&
name|ATA_AHCI_CAP_64BIT
condition|)
name|ch
operator|->
name|dma
operator|.
name|max_address
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_ahci_setup_fis
parameter_list|(
name|struct
name|ata_ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|struct
name|ata_request
modifier|*
name|request
parameter_list|)
block|{
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_ATAPI
condition|)
block|{
name|bzero
argument_list|(
name|ctp
operator|->
name|acmd
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|request
operator|->
name|u
operator|.
name|atapi
operator|.
name|ccb
argument_list|,
name|ctp
operator|->
name|acmd
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
return|return
name|ata_request2fis_h2d
argument_list|(
name|request
argument_list|,
operator|&
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|ATA_DECLARE_DRIVER
argument_list|(
name|ata_ahci
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

