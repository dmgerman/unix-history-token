begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 - 2008 SÃ¸ren Schmidt<sos@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ata.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-all.h>
end_include

begin_include
include|#
directive|include
file|<ata_if.h>
end_include

begin_function
name|void
name|ata_sata_phy_check_events
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|error
init|=
name|ATA_IDX_INL
argument_list|(
name|ch
argument_list|,
name|ATA_SERROR
argument_list|)
decl_stmt|;
comment|/* clear error bits/interrupt */
name|ATA_IDX_OUTL
argument_list|(
name|ch
argument_list|,
name|ATA_SERROR
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* if we have a connection event deal with it */
if|if
condition|(
operator|(
name|error
operator|&
name|ATA_SE_PHY_CHANGED
operator|)
operator|&&
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|u_int32_t
name|status
init|=
name|ATA_IDX_INL
argument_list|(
name|ch
argument_list|,
name|ATA_SSTATUS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|ATA_SS_CONWELL_MASK
operator|)
operator|==
name|ATA_SS_CONWELL_GEN1
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|ATA_SS_CONWELL_MASK
operator|)
operator|==
name|ATA_SS_CONWELL_GEN2
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DISCONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ch
operator|->
name|conntask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ata_sata_scr_read
parameter_list|(
name|struct
name|ata_channel
modifier|*
name|ch
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
operator|*
name|val
operator|=
name|ATA_IDX_INL
argument_list|(
name|ch
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|ATA_SSTATUS
case|:
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ATA_SERROR
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ATA_SCONTROL
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ch
operator|->
name|hw
operator|.
name|pm_read
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|r
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|ata_sata_scr_write
parameter_list|(
name|struct
name|ata_channel
modifier|*
name|ch
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|ATA_IDX_OUTL
argument_list|(
name|ch
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|ATA_SERROR
case|:
name|r
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ATA_SCONTROL
case|:
name|r
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ch
operator|->
name|hw
operator|.
name|pm_write
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|r
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ata_sata_connect
parameter_list|(
name|struct
name|ata_channel
modifier|*
name|ch
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* wait up to 1 second for "connect well" */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|100
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
name|ata_sata_scr_read
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SSTATUS
argument_list|,
operator|&
name|status
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|status
operator|&
name|ATA_SS_CONWELL_MASK
operator|)
operator|==
name|ATA_SS_CONWELL_GEN1
operator|||
operator|(
name|status
operator|&
name|ATA_SS_CONWELL_MASK
operator|)
operator|==
name|ATA_SS_CONWELL_GEN2
condition|)
break|break;
name|ata_udelay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>=
literal|100
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect timeout status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"p%d: SATA connect timeout status=%08x\n"
argument_list|,
name|port
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect time=%dms status=%08x\n"
argument_list|,
name|timeout
operator|*
literal|10
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"p%d: SATA connect time=%dms status=%08x\n"
argument_list|,
name|port
argument_list|,
name|timeout
operator|*
literal|10
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* clear SATA error register */
name|ata_sata_scr_write
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SERROR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ata_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|quick
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|loop
decl_stmt|,
name|retry
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|quick
condition|)
block|{
if|if
condition|(
name|ata_sata_scr_read
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SCONTROL
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|val
operator|&
name|ATA_SC_DET_MASK
operator|)
operator|==
name|ATA_SC_DET_IDLE
condition|)
return|return
name|ata_sata_connect
argument_list|(
name|ch
argument_list|,
name|port
argument_list|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hardware reset ...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"p%d: hardware reset ...\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
literal|10
condition|;
name|retry
operator|++
control|)
block|{
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|10
condition|;
name|loop
operator|++
control|)
block|{
if|if
condition|(
name|ata_sata_scr_write
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SCONTROL
argument_list|,
name|ATA_SC_DET_RESET
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ata_udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_sata_scr_read
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SCONTROL
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|val
operator|&
name|ATA_SC_DET_MASK
operator|)
operator|==
name|ATA_SC_DET_RESET
condition|)
break|break;
block|}
name|ata_udelay
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
literal|10
condition|;
name|loop
operator|++
control|)
block|{
if|if
condition|(
name|ata_sata_scr_write
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SCONTROL
argument_list|,
name|ATA_SC_DET_IDLE
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
operator|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ata_udelay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata_sata_scr_read
argument_list|(
name|ch
argument_list|,
name|port
argument_list|,
name|ATA_SCONTROL
argument_list|,
operator|&
name|val
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|val
operator|&
name|ATA_SC_DET_MASK
operator|)
operator|==
literal|0
condition|)
return|return
name|ata_sata_connect
argument_list|(
name|ch
argument_list|,
name|port
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ata_sata_setmode
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|ata_device
modifier|*
name|atadev
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/*      * if we detect that the device isn't a real SATA device we limit       * the transfer mode to UDMA5/ATA100.      * this works around the problems some devices has with the       * Marvell 88SX8030 SATA->PATA converters and UDMA6/ATA133.      */
if|if
condition|(
name|atadev
operator|->
name|param
operator|.
name|satacapabilities
operator|!=
literal|0x0000
operator|&&
name|atadev
operator|->
name|param
operator|.
name|satacapabilities
operator|!=
literal|0xffff
condition|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
comment|/* on some drives we need to set the transfer mode */
name|ata_controlcmd
argument_list|(
name|dev
argument_list|,
name|ATA_SETFEATURES
argument_list|,
name|ATA_SF_SETXFER
argument_list|,
literal|0
argument_list|,
name|ata_limit_mode
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
name|ATA_UDMA6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* query SATA STATUS for the speed */
if|if
condition|(
name|ch
operator|->
name|r_io
index|[
name|ATA_SSTATUS
index|]
operator|.
name|res
operator|&&
operator|(
operator|(
name|ATA_IDX_INL
argument_list|(
name|ch
argument_list|,
name|ATA_SSTATUS
argument_list|)
operator|&
name|ATA_SS_CONWELL_MASK
operator|)
operator|==
name|ATA_SS_CONWELL_GEN2
operator|)
condition|)
name|atadev
operator|->
name|mode
operator|=
name|ATA_SA300
expr_stmt|;
else|else
name|atadev
operator|->
name|mode
operator|=
name|ATA_SA150
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|ata_limit_mode
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
name|ATA_UDMA5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ata_controlcmd
argument_list|(
name|dev
argument_list|,
name|ATA_SETFEATURES
argument_list|,
name|ATA_SF_SETXFER
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
condition|)
name|atadev
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ata_request2fis_h2d
parameter_list|(
name|struct
name|ata_request
modifier|*
name|request
parameter_list|,
name|u_int8_t
modifier|*
name|fis
parameter_list|)
block|{
if|if
condition|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_ATAPI
condition|)
block|{
name|fis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|fis
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
name|request
operator|->
name|unit
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ATA_PACKET_CMD
expr_stmt|;
if|if
condition|(
name|request
operator|->
name|flags
operator|&
operator|(
name|ATA_R_READ
operator||
name|ATA_R_WRITE
operator|)
condition|)
name|fis
index|[
literal|3
index|]
operator|=
name|ATA_F_DMA
expr_stmt|;
else|else
block|{
name|fis
index|[
literal|5
index|]
operator|=
name|request
operator|->
name|transfersize
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|request
operator|->
name|transfersize
operator|>>
literal|8
expr_stmt|;
block|}
name|fis
index|[
literal|7
index|]
operator|=
name|ATA_D_LBA
expr_stmt|;
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
return|return
literal|20
return|;
block|}
else|else
block|{
name|fis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|fis
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
name|request
operator|->
name|unit
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|command
expr_stmt|;
name|fis
index|[
literal|3
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|feature
expr_stmt|;
name|fis
index|[
literal|4
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
expr_stmt|;
name|fis
index|[
literal|5
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|>>
literal|8
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|>>
literal|16
expr_stmt|;
name|fis
index|[
literal|7
index|]
operator|=
name|ATA_D_LBA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|request
operator|->
name|flags
operator|&
name|ATA_R_48BIT
operator|)
condition|)
name|fis
index|[
literal|7
index|]
operator||=
operator|(
name|ATA_D_IBM
operator||
operator|(
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|>>
literal|24
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
name|fis
index|[
literal|8
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|>>
literal|24
expr_stmt|;
name|fis
index|[
literal|9
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|>>
literal|32
expr_stmt|;
name|fis
index|[
literal|10
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|lba
operator|>>
literal|40
expr_stmt|;
name|fis
index|[
literal|11
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|feature
operator|>>
literal|8
expr_stmt|;
name|fis
index|[
literal|12
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|count
expr_stmt|;
name|fis
index|[
literal|13
index|]
operator|=
name|request
operator|->
name|u
operator|.
name|ata
operator|.
name|count
operator|>>
literal|8
expr_stmt|;
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
return|return
literal|20
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ata_pm_identify
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|pm_chipid
decl_stmt|,
name|pm_revision
decl_stmt|,
name|pm_ports
decl_stmt|;
name|int
name|port
decl_stmt|;
comment|/* get PM vendor& product data */
if|if
condition|(
name|ch
operator|->
name|hw
operator|.
name|pm_read
argument_list|(
name|dev
argument_list|,
name|ATA_PM
argument_list|,
literal|0
argument_list|,
operator|&
name|pm_chipid
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error getting PM vendor data\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get PM revision data */
if|if
condition|(
name|ch
operator|->
name|hw
operator|.
name|pm_read
argument_list|(
name|dev
argument_list|,
name|ATA_PM
argument_list|,
literal|1
argument_list|,
operator|&
name|pm_revision
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error getting PM revison data\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get number of HW ports on the PM */
if|if
condition|(
name|ch
operator|->
name|hw
operator|.
name|pm_read
argument_list|(
name|dev
argument_list|,
name|ATA_PM
argument_list|,
literal|2
argument_list|,
operator|&
name|pm_ports
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error getting PM port info\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pm_ports
operator|&=
literal|0x0000000f
expr_stmt|;
comment|/* chip specific quirks */
switch|switch
condition|(
name|pm_chipid
condition|)
block|{
case|case
literal|0x37261095
case|:
comment|/* This PM declares 6 ports, while only 5 of them are real. 	 * Port 5 is enclosure management bridge port, which has implementation 	 * problems, causing probe faults. Hide it for now. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SiI 3726 (rev=%x) Port Multiplier with %d (5) ports\n"
argument_list|,
name|pm_revision
argument_list|,
name|pm_ports
argument_list|)
expr_stmt|;
name|pm_ports
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|0x47261095
case|:
comment|/* This PM declares 7 ports, while only 5 of them are real. 	 * Port 5 is some fake "Config  Disk" with 640 sectors size, 	 * port 6 is enclosure management bridge port. 	 * Both fake ports has implementation problems, causing 	 * probe faults. Hide them for now. */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SiI 4726 (rev=%x) Port Multiplier with %d (5) ports\n"
argument_list|,
name|pm_revision
argument_list|,
name|pm_ports
argument_list|)
expr_stmt|;
name|pm_ports
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Port Multiplier (id=%08x rev=%x) with %d ports\n"
argument_list|,
name|pm_chipid
argument_list|,
name|pm_revision
argument_list|,
name|pm_ports
argument_list|)
expr_stmt|;
block|}
comment|/* reset all ports and register if anything connected */
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|pm_ports
condition|;
name|port
operator|++
control|)
block|{
name|u_int32_t
name|signature
decl_stmt|;
if|if
condition|(
operator|!
name|ata_sata_phy_reset
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
comment|/* 	 * XXX: I have no idea how to properly wait for PMP port hardreset 	 * completion. Without this delay soft reset does not completes 	 * successfully. 	 */
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|signature
operator|=
name|ch
operator|->
name|hw
operator|.
name|softreset
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"p%d: SIGNATURE=%08x\n"
argument_list|,
name|port
argument_list|,
name|signature
argument_list|)
expr_stmt|;
comment|/* figure out whats there */
switch|switch
condition|(
name|signature
operator|>>
literal|16
condition|)
block|{
case|case
literal|0x0000
case|:
name|ch
operator|->
name|devices
operator||=
operator|(
name|ATA_ATA_MASTER
operator|<<
name|port
operator|)
expr_stmt|;
continue|continue;
case|case
literal|0xeb14
case|:
name|ch
operator|->
name|devices
operator||=
operator|(
name|ATA_ATAPI_MASTER
operator|<<
name|port
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

end_unit

