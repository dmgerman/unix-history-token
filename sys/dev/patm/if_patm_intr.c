begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * Driver for IDT77252 based cards like ProSum's.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbpool.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/idt77252reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/if_patmvar.h>
end_include

begin_function_decl
specifier|static
name|void
name|patm_feed_sbufs
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_feed_lbufs
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_feed_vbufs
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_intr_tsif
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_intr_raw
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PATM_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|patm_mbuf_cnt
argument_list|(
name|u_int
name|unit
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Write free buf Q  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|patm_fbq_write
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|queue
parameter_list|,
name|uint32_t
name|h0
parameter_list|,
name|uint32_t
name|p0
parameter_list|,
name|uint32_t
name|h1
parameter_list|,
name|uint32_t
name|p1
parameter_list|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|FREEQ
argument_list|,
literal|"supplying(%u,%#x,%#x,%#x,%#x)"
argument_list|,
name|queue
argument_list|,
name|h0
argument_list|,
name|p0
argument_list|,
name|h1
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D0
argument_list|,
name|h0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D1
argument_list|,
name|p0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D2
argument_list|,
name|h1
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D3
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|patm_cmd_exec
argument_list|(
name|sc
argument_list|,
name|IDT_CMD_WFBQ
operator||
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt  */
end_comment

begin_function
name|void
name|patm_intr
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|uint32_t
name|stat
decl_stmt|,
name|cfg
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
specifier|const
name|uint32_t
name|ints
init|=
name|IDT_STAT_TSIF
operator||
name|IDT_STAT_TXICP
operator||
name|IDT_STAT_TSQF
operator||
name|IDT_STAT_TMROF
operator||
name|IDT_STAT_PHYI
operator||
name|IDT_STAT_RSQF
operator||
name|IDT_STAT_EPDU
operator||
name|IDT_STAT_RAWCF
operator||
name|IDT_STAT_RSQAF
decl_stmt|;
specifier|const
name|uint32_t
name|fbqa
init|=
name|IDT_STAT_FBQ3A
operator||
name|IDT_STAT_FBQ2A
operator||
name|IDT_STAT_FBQ1A
operator||
name|IDT_STAT_FBQ0A
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|stat
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_STAT
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_STAT
argument_list|,
name|stat
operator|&
operator|(
name|ints
operator||
name|fbqa
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* if we are stopped ack all interrupts and handle PHYI */
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_PHYI
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"PHYI (stopped)"
argument_list|)
expr_stmt|;
name|utopia_intr
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"stat=%08x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/* 	 * If the buffer queues are empty try to fill them. If this fails 	 * disable the interrupt. Otherwise enable the interrupt. 	 */
if|if
condition|(
name|stat
operator|&
name|fbqa
condition|)
block|{
name|cfg
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_FBQ0A
condition|)
name|patm_feed_sbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_FBQ1A
condition|)
name|patm_feed_lbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_FBQ2A
condition|)
block|{
comment|/* 			 * Workaround for missing interrupt on AAL0. Check the 			 * receive status queue if the FBQ2 is not full. 			 */
name|patm_intr_rsq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|patm_feed_vbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_STAT
argument_list|)
operator|&
name|fbqa
operator|)
operator|&&
operator|(
name|cfg
operator|&
name|IDT_CFG_FBIE
operator|)
condition|)
block|{
comment|/* failed */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|,
name|cfg
operator|&
operator|~
name|IDT_CFG_FBIE
argument_list|)
expr_stmt|;
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"out of buffers -- intr disabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|cfg
operator|&
name|IDT_CFG_FBIE
operator|)
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"bufQ intr re-enabled\n"
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|,
name|cfg
operator||
name|IDT_CFG_FBIE
argument_list|)
expr_stmt|;
block|}
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_STAT
argument_list|,
name|fbqa
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|stat
operator|&
name|ints
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|cnt
operator|==
literal|200
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: excessive interrupts\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|patm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_TSIF
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"TSIF"
argument_list|)
expr_stmt|;
name|patm_intr_tsif
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_TXICP
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"incomplete PDU transmitted\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_TSQF
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"TSQF\n"
argument_list|)
expr_stmt|;
name|patm_intr_tsif
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_TMROF
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"TMROF"
argument_list|)
expr_stmt|;
name|patm_intr_tsif
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_PHYI
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"PHYI"
argument_list|)
expr_stmt|;
name|utopia_intr
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_RSQF
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"RSQF\n"
argument_list|)
expr_stmt|;
name|patm_intr_rsq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_EPDU
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"EPDU"
argument_list|)
expr_stmt|;
name|patm_intr_rsq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_RAWCF
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"RAWCF"
argument_list|)
expr_stmt|;
name|patm_intr_raw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
operator|&
name|IDT_STAT_RSQAF
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"RSQAF"
argument_list|)
expr_stmt|;
name|patm_intr_rsq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IDT_STAT_FRAC2
argument_list|(
name|stat
argument_list|)
operator|!=
literal|0xf
condition|)
block|{
comment|/* 			 * Workaround for missing interrupt on AAL0. Check the 			 * receive status queue if the FBQ2 is not full. 			 */
name|patm_intr_rsq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|stat
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_STAT
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_STAT
argument_list|,
name|ints
operator|&
name|stat
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"stat=%08x"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|INTR
argument_list|,
literal|"... exit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the amount of buffers to feed into a given free buffer queue  *  * Feeding buffers is actually not so easy as it seems. We cannot use the  * fraction fields in the status registers, because they round down, i.e.  * if we have 34 buffers in the queue, it will show 1. If we now feed  * 512 - 1 * 32 buffers, we lose two buffers. The only reliable way to know  * how many buffers are in the queue are the FBQP registers.  */
end_comment

begin_function
specifier|static
name|u_int
name|patm_feed_cnt
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|q
parameter_list|)
block|{
name|u_int
name|w
decl_stmt|,
name|r
decl_stmt|,
name|reg
decl_stmt|;
name|u_int
name|feed
decl_stmt|;
name|int
name|free
decl_stmt|;
comment|/* get the FBQ read and write pointers */
name|reg
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQP0
operator|+
literal|4
operator|*
name|q
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|reg
operator|&
literal|0x7ff
operator|)
operator|>>
literal|1
expr_stmt|;
name|w
operator|=
operator|(
operator|(
name|reg
operator|>>
literal|16
operator|)
operator|&
literal|0x7ff
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* compute amount of free buffers */
if|if
condition|(
operator|(
name|free
operator|=
name|w
operator|-
name|r
operator|)
operator|<
literal|0
condition|)
name|free
operator|+=
literal|0x400
expr_stmt|;
name|KASSERT
argument_list|(
name|free
operator|<=
literal|512
argument_list|,
operator|(
literal|"bad FBQP 0x%x"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
name|feed
operator|=
literal|512
operator|-
name|free
expr_stmt|;
comment|/* can only feed pairs of buffers */
name|feed
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|feed
operator|>
literal|0
condition|)
name|feed
operator|-=
literal|2
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|FREEQ
argument_list|,
literal|"feeding %u buffers into queue %u"
argument_list|,
name|feed
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|feed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Feed small buffers into buffer queue 0  *  */
end_comment

begin_function
specifier|static
name|void
name|patm_feed_sbufs
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|feed
decl_stmt|;
name|bus_addr_t
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|void
modifier|*
name|v0
decl_stmt|;
name|uint32_t
name|h0
decl_stmt|,
name|h1
decl_stmt|;
name|feed
operator|=
name|patm_feed_cnt
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|feed
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|v0
operator|=
name|mbp_alloc
argument_list|(
name|sc
operator|->
name|sbuf_pool
argument_list|,
operator|&
name|p0
argument_list|,
operator|&
name|h0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|mbp_alloc
argument_list|(
name|sc
operator|->
name|sbuf_pool
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|h1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mbp_free
argument_list|(
name|sc
operator|->
name|sbuf_pool
argument_list|,
name|v0
argument_list|)
expr_stmt|;
break|break;
block|}
name|patm_fbq_write
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|h0
operator||
name|MBUF_SHANDLE
argument_list|,
operator|(
name|p0
operator|+
name|SMBUF_OFFSET
operator|)
argument_list|,
name|h1
operator||
name|MBUF_SHANDLE
argument_list|,
operator|(
name|p1
operator|+
name|SMBUF_OFFSET
operator|)
argument_list|)
expr_stmt|;
name|feed
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Feed small buffers into buffer queue 0  */
end_comment

begin_function
specifier|static
name|void
name|patm_feed_vbufs
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|feed
decl_stmt|;
name|bus_addr_t
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|void
modifier|*
name|v0
decl_stmt|;
name|uint32_t
name|h0
decl_stmt|,
name|h1
decl_stmt|;
name|feed
operator|=
name|patm_feed_cnt
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|feed
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|v0
operator|=
name|mbp_alloc
argument_list|(
name|sc
operator|->
name|vbuf_pool
argument_list|,
operator|&
name|p0
argument_list|,
operator|&
name|h0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|mbp_alloc
argument_list|(
name|sc
operator|->
name|vbuf_pool
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|h1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mbp_free
argument_list|(
name|sc
operator|->
name|vbuf_pool
argument_list|,
name|v0
argument_list|)
expr_stmt|;
break|break;
block|}
name|patm_fbq_write
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
name|h0
operator||
name|MBUF_VHANDLE
argument_list|,
operator|(
name|p0
operator|+
name|VMBUF_OFFSET
operator|)
argument_list|,
name|h1
operator||
name|MBUF_VHANDLE
argument_list|,
operator|(
name|p1
operator|+
name|VMBUF_OFFSET
operator|)
argument_list|)
expr_stmt|;
name|feed
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a large buffer  */
end_comment

begin_function
specifier|static
name|struct
name|lmbuf
modifier|*
name|patm_lmbuf_alloc
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|lmbuf
modifier|*
name|b
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|m
operator|->
name|m_data
operator|+=
name|LMBUF_OFFSET
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|lbuf_free_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|b
operator|->
name|phy
operator|=
literal|0
expr_stmt|;
comment|/* alignment */
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|,
name|b
operator|->
name|map
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|LMBUF_SIZE
argument_list|,
name|patm_load_callback
argument_list|,
operator|&
name|b
operator|->
name|phy
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"%s -- bus_dmamap_load: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|lbuf_free_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|b
operator|->
name|m
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Feed large buffers into buffer queue 1  */
end_comment

begin_function
specifier|static
name|void
name|patm_feed_lbufs
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|feed
decl_stmt|;
name|struct
name|lmbuf
modifier|*
name|b0
decl_stmt|,
modifier|*
name|b1
decl_stmt|;
name|feed
operator|=
name|patm_feed_cnt
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|feed
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|b0
operator|=
name|patm_lmbuf_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|b1
operator|=
name|patm_lmbuf_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|patm_lbuf_free
argument_list|(
name|sc
argument_list|,
name|b0
argument_list|)
expr_stmt|;
break|break;
block|}
name|patm_fbq_write
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|LMBUF_HANDLE
operator||
name|b0
operator|->
name|handle
argument_list|,
name|b0
operator|->
name|phy
argument_list|,
name|LMBUF_HANDLE
operator||
name|b1
operator|->
name|handle
argument_list|,
name|b1
operator|->
name|phy
argument_list|)
expr_stmt|;
name|feed
operator|-=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle transmit status interrupt  */
end_comment

begin_function
specifier|static
name|void
name|patm_intr_tsif
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|idt_tsqe
modifier|*
name|tsqe
init|=
name|sc
operator|->
name|tsq_next
decl_stmt|;
name|struct
name|idt_tsqe
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|stamp
decl_stmt|;
name|stamp
operator|=
name|le32toh
argument_list|(
name|tsqe
operator|->
name|stamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stamp
operator|&
name|IDT_TSQE_EMPTY
condition|)
return|return;
do|do
block|{
switch|switch
condition|(
name|IDT_TSQE_TYPE
argument_list|(
name|stamp
argument_list|)
condition|)
block|{
case|case
name|IDT_TSQE_TBD
case|:
name|patm_tx
argument_list|(
name|sc
argument_list|,
name|stamp
argument_list|,
name|le32toh
argument_list|(
name|tsqe
operator|->
name|stat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDT_TSQE_IDLE
case|:
name|patm_tx_idle
argument_list|(
name|sc
argument_list|,
name|le32toh
argument_list|(
name|tsqe
operator|->
name|stat
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* recycle */
name|tsqe
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
name|tsqe
operator|->
name|stamp
operator|=
name|htole32
argument_list|(
name|IDT_TSQE_EMPTY
argument_list|)
expr_stmt|;
comment|/* save pointer to this entry and advance */
name|prev
operator|=
name|tsqe
expr_stmt|;
if|if
condition|(
operator|++
name|tsqe
operator|==
operator|&
name|sc
operator|->
name|tsq
index|[
name|IDT_TSQ_SIZE
index|]
condition|)
name|tsqe
operator|=
operator|&
name|sc
operator|->
name|tsq
index|[
literal|0
index|]
expr_stmt|;
name|stamp
operator|=
name|le32toh
argument_list|(
name|tsqe
operator|->
name|stamp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|stamp
operator|&
name|IDT_TSQE_EMPTY
operator|)
condition|)
do|;
name|sc
operator|->
name|tsq_next
operator|=
name|tsqe
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TSQH
argument_list|,
operator|(
operator|(
name|prev
operator|-
name|sc
operator|->
name|tsq
operator|)
operator|<<
name|IDT_TSQE_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle receive interrupt  */
end_comment

begin_function
name|void
name|patm_intr_rsq
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|idt_rsqe
modifier|*
name|rsqe
decl_stmt|;
name|u_int
name|stat
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|rsq_last
operator|+
literal|1
operator|==
name|PATM_RSQ_SIZE
condition|)
name|rsqe
operator|=
operator|&
name|sc
operator|->
name|rsq
index|[
literal|0
index|]
expr_stmt|;
else|else
name|rsqe
operator|=
operator|&
name|sc
operator|->
name|rsq
index|[
name|sc
operator|->
name|rsq_last
operator|+
literal|1
index|]
expr_stmt|;
name|stat
operator|=
name|le32toh
argument_list|(
name|rsqe
operator|->
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|IDT_RSQE_VALID
operator|)
condition|)
return|return;
while|while
condition|(
name|stat
operator|&
name|IDT_RSQE_VALID
condition|)
block|{
name|patm_rx
argument_list|(
name|sc
argument_list|,
name|rsqe
argument_list|)
expr_stmt|;
comment|/* recycle RSQE */
name|rsqe
operator|->
name|cid
operator|=
literal|0
expr_stmt|;
name|rsqe
operator|->
name|handle
operator|=
literal|0
expr_stmt|;
name|rsqe
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|rsqe
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
comment|/* save pointer to this entry and advance */
if|if
condition|(
operator|++
name|sc
operator|->
name|rsq_last
operator|==
name|PATM_RSQ_SIZE
condition|)
name|sc
operator|->
name|rsq_last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|rsqe
operator|==
operator|&
name|sc
operator|->
name|rsq
index|[
name|PATM_RSQ_SIZE
index|]
condition|)
name|rsqe
operator|=
name|sc
operator|->
name|rsq
expr_stmt|;
name|stat
operator|=
name|le32toh
argument_list|(
name|rsqe
operator|->
name|stat
argument_list|)
expr_stmt|;
block|}
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RSQH
argument_list|,
name|sc
operator|->
name|rsq_phy
operator||
operator|(
name|sc
operator|->
name|rsq_last
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|patm_feed_sbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|patm_feed_lbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|patm_feed_vbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle raw cell receive.  *  * Note that the description on page 3-8 is wrong. The RAWHND contains not  * the same value as RAWCT. RAWCT points to the next address the chip is  * going to write to whike RAWHND points to the last cell's address the chip  * has written to.  */
end_comment

begin_function
specifier|static
name|void
name|patm_intr_raw
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|tail
decl_stmt|;
name|uint32_t
name|h
decl_stmt|,
modifier|*
name|cell
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|bus_dma_sync_size
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|,
name|sc
operator|->
name|sq_map
argument_list|,
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
operator|+
name|PATM_RSQ_SIZE
operator|*
name|IDT_RSQE_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|rawhnd
argument_list|)
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* first turn */
if|if
condition|(
name|sc
operator|->
name|rawh
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|rawh
operator|=
operator|&
name|sc
operator|->
name|lbufs
index|[
name|le32toh
argument_list|(
name|sc
operator|->
name|rawhnd
operator|->
name|handle
argument_list|)
operator|&
name|MBUF_HMASK
index|]
expr_stmt|;
block|}
name|tail
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rawhnd
operator|->
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|sc
operator|->
name|rawh
operator|->
name|phy
condition|)
comment|/* not really a raw interrupt */
return|return;
while|while
condition|(
name|tail
operator|+
literal|64
operator|!=
name|sc
operator|->
name|rawh
operator|->
name|phy
operator|+
name|sc
operator|->
name|rawi
operator|*
literal|64
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|bus_dmamap_sync_size
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|,
name|sc
operator|->
name|rawh
operator|->
name|map
argument_list|,
name|sc
operator|->
name|rawi
operator|*
literal|64
argument_list|,
literal|64
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cell
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|sc
operator|->
name|rawh
operator|->
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|sc
operator|->
name|rawi
operator|*
literal|64
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rawi
operator|==
operator|(
name|LMBUF_SIZE
operator|/
literal|64
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* chain */
name|h
operator|=
name|le32toh
argument_list|(
name|cell
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|patm_lbuf_free
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|rawh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rawh
operator|=
operator|&
name|sc
operator|->
name|lbufs
index|[
name|h
operator|&
name|MBUF_HMASK
index|]
expr_stmt|;
name|sc
operator|->
name|rawi
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|patm_rx_raw
argument_list|(
name|sc
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cell
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rawi
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free a large mbuf. This is called by us.  */
end_comment

begin_function
name|void
name|patm_lbuf_free
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lmbuf
modifier|*
name|b
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|,
name|b
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|b
operator|->
name|m
argument_list|)
expr_stmt|;
name|b
operator|->
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|lbuf_free_list
argument_list|,
name|b
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PATM_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|patm_mbuf_cnt
parameter_list|(
name|u_int
name|unit
parameter_list|)
block|{
name|devclass_t
name|dc
decl_stmt|;
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|used
decl_stmt|,
name|card
decl_stmt|,
name|free
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"patm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't find devclass\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid unit number: %d\n"
argument_list|,
name|__func__
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mbp_count
argument_list|(
name|sc
operator|->
name|sbuf_pool
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|card
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sbufs: %u on card, %u used, %u free\n"
argument_list|,
name|card
argument_list|,
name|used
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|mbp_count
argument_list|(
name|sc
operator|->
name|vbuf_pool
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|card
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aal0 bufs: %u on card, %u used, %u free\n"
argument_list|,
name|card
argument_list|,
name|used
argument_list|,
name|free
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

