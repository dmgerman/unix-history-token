begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * Driver for IDT77252 based cards like ProSum's.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_BPF
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbpool.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/idt77252reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/if_patmvar.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|patm
argument_list|,
name|utopia
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|patm
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|patm
argument_list|,
name|atm
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|patm
argument_list|,
name|libmbpool
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|devclass_t
name|patm_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|patm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|patm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|patm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|patm_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|patm_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|patm_driver
init|=
block|{
literal|"patm"
block|,
name|patm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|patm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|patm
argument_list|,
name|pci
argument_list|,
name|patm_driver
argument_list|,
name|patm_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|devid
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|devs
index|[]
init|=
block|{
block|{
name|PCI_DEVICE_IDT77252
block|,
literal|"NICStAR (77222/77252) ATM adapter"
block|}
block|,
block|{
name|PCI_DEVICE_IDT77v252
block|,
literal|"NICStAR (77v252) ATM adapter"
block|}
block|,
block|{
name|PCI_DEVICE_IDT77v222
block|,
literal|"NICStAR (77v222) ATM adapter"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_atm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|patm_phy_readregs
parameter_list|(
name|struct
name|ifatm
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_phy_writereg
parameter_list|(
name|struct
name|ifatm
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|utopia_methods
name|patm_utopia_methods
init|=
block|{
name|patm_phy_readregs
block|,
name|patm_phy_writereg
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|patm_destroy
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_sysctl_istats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_sysctl_eeprom
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_read_eeprom
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_sq_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_rbuf_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_txmap_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_env_getuint
parameter_list|(
name|struct
name|patm_softc
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PATM_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|patm_sysctl_regs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|patm_sysctl_tsq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|patm_dump_vc
argument_list|(
name|u_int
name|unit
argument_list|,
name|u_int
name|vc
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patm_dump_regs
argument_list|(
name|u_int
name|unit
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patm_dump_sram
argument_list|(
name|u_int
name|unit
argument_list|,
name|u_int
name|from
argument_list|,
name|u_int
name|words
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Probe for a IDT77252 controller  */
end_comment

begin_function
specifier|static
name|int
name|patm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_IDT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
operator|.
name|desc
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|devs
index|[
name|i
index|]
operator|.
name|devid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|devs
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach  */
end_comment

begin_function
specifier|static
name|int
name|patm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|u_int
name|a
decl_stmt|;
specifier|static
specifier|const
name|struct
name|idt_mmap
name|idt_mmap
index|[
literal|4
index|]
init|=
name|IDT_MMAP
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
ifdef|#
directive|ifdef
name|IATM_DEBUG
name|sc
operator|->
name|debug
operator|=
name|IATM_DEBUG
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ATM
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_IDTABR25
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|serial
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|hw_version
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|sw_version
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
operator|=
name|PATM_VPI_BITS
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|=
literal|0
expr_stmt|;
comment|/* set below */
empty_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vpcs
operator|=
literal|0
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|=
literal|0
expr_stmt|;
comment|/* set below */
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UNKNOWN
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|phy
operator|=
operator|&
name|sc
operator|->
name|utopia
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|patm_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|patm_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|patm_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
comment|/* do this early so we can destroy unconditionally */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|,
literal|"tst lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|,
literal|"vcc_close"
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|tst_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * Get revision 	 */
name|sc
operator|->
name|revision
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_REVID
argument_list|,
literal|4
argument_list|)
operator|&
literal|0xf
expr_stmt|;
comment|/* 	 * Enable PCI bus master and memory 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|IDT_PCI_REG_MEMBASE
expr_stmt|;
name|sc
operator|->
name|memres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|==
name|NULL
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|memh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the interrupt (enable it later) 	 */
name|sc
operator|->
name|irqid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irqres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irqid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
operator|==
literal|0
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"could not allocate irq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Construct the sysctl tree 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw_atm
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"istats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|patm_sysctl_istats
argument_list|,
literal|"S"
argument_list|,
literal|"internal statistics"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"eeprom"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|patm_sysctl_eeprom
argument_list|,
literal|"S"
argument_list|,
literal|"EEPROM contents"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lbuf_max"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|lbuf_max
argument_list|,
literal|0
argument_list|,
literal|"maximum number of large receive buffers"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|patm_env_getuint
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lbuf_max
argument_list|,
literal|"lbuf_max"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_txmaps"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|tx_maxmaps
argument_list|,
literal|0
argument_list|,
literal|"maximum number of TX DMA maps"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|patm_env_getuint
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tx_maxmaps
argument_list|,
literal|"tx_maxmaps"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PATM_DEBUG
if|if
condition|(
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
literal|0
argument_list|,
literal|"debug flags"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|sc
operator|->
name|debug
operator|=
name|PATM_DEBUG
expr_stmt|;
name|patm_env_getuint
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|debug
argument_list|,
literal|"debug"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"regs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|patm_sysctl_regs
argument_list|,
literal|"S"
argument_list|,
literal|"registers"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tsq"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|patm_sysctl_tsq
argument_list|,
literal|"S"
argument_list|,
literal|"TSQ"
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
endif|#
directive|endif
name|patm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Detect and attach the phy. 	 */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"attaching utopia"
argument_list|)
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|phy
operator|=
operator|&
name|sc
operator|->
name|utopia
expr_stmt|;
name|utopia_attach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
operator|&
name|patm_utopia_methods
argument_list|)
expr_stmt|;
comment|/* 	 * Start the PHY because we need the autodetection 	 */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"starting utopia"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|utopia_start
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_reset
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Read EEPROM */
name|patm_read_eeprom
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* analyze it */
if|if
condition|(
name|strncmp
argument_list|(
name|sc
operator|->
name|eeprom
operator|+
name|PATM_PROATM_NAME_OFFSET
argument_list|,
name|PATM_PROATM_NAME
argument_list|,
name|strlen
argument_list|(
name|PATM_PROATM_NAME
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|utopia
operator|.
name|chip
operator|->
name|type
operator|==
name|UTP_TYPE_IDT77105
condition|)
block|{
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_PROATM25
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_25_6M
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UTP_25
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PATM_25M
expr_stmt|;
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"ProATM 25 interface; "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cannot really know which media */
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_PROATM155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_155M
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_MM_155
expr_stmt|;
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"ProATM 155 interface; "
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|eeprom
operator|+
name|PATM_PROATM_MAC_OFFSET
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
argument_list|,
sizeof|sizeof
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|utopia
operator|.
name|chip
operator|->
name|type
operator|==
name|UTP_TYPE_IDT77105
condition|)
block|{
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_IDTABR25
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_25_6M
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_UTP_25
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PATM_25M
expr_stmt|;
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"IDT77252 25MBit interface; "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cannot really know which media */
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|device
operator|=
name|ATM_DEVICE_IDTABR155
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|=
name|ATM_RATE_155M
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|media
operator|=
name|IFM_ATM_MM_155
expr_stmt|;
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"IDT77252 155MBit interface; "
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|eeprom
operator|+
name|PATM_IDT_MAC_OFFSET
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
argument_list|,
sizeof|sizeof
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|esi
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"idt77252 Rev. %c; %s PHY\n"
argument_list|,
literal|'A'
operator|+
name|sc
operator|->
name|revision
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|chip
operator|->
name|name
argument_list|)
expr_stmt|;
name|utopia_reset_media
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_init_media
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
comment|/* 	 * Determine RAM size 	 */
for|for
control|(
name|a
operator|=
literal|0
init|;
name|a
operator|<
literal|0x20000
condition|;
name|a
operator|++
control|)
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0xdeadbeef
argument_list|)
expr_stmt|;
if|if
condition|(
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
literal|0x4004
argument_list|)
operator|==
literal|0xdeadbeef
condition|)
name|sc
operator|->
name|mmap
operator|=
operator|&
name|idt_mmap
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
literal|0x8000
argument_list|)
operator|==
literal|0xdeadbeef
condition|)
name|sc
operator|->
name|mmap
operator|=
operator|&
name|idt_mmap
index|[
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
literal|0x20000
argument_list|)
operator|==
literal|0xdeadbeef
condition|)
name|sc
operator|->
name|mmap
operator|=
operator|&
name|idt_mmap
index|[
literal|2
index|]
expr_stmt|;
else|else
name|sc
operator|->
name|mmap
operator|=
operator|&
name|idt_mmap
index|[
literal|3
index|]
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vci_bits
operator|=
name|sc
operator|->
name|mmap
operator|->
name|vcbits
operator|-
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|vpi_bits
expr_stmt|;
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|max_vccs
operator|=
name|sc
operator|->
name|mmap
operator|->
name|max_conn
expr_stmt|;
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"%uK x 32 SRAM; %u connections\n"
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|sram
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|max_conn
argument_list|)
expr_stmt|;
comment|/* initialize status queues */
name|error
operator|=
name|patm_sq_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* get TST */
name|sc
operator|->
name|tst_soft
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|sc
operator|->
name|mmap
operator|->
name|tst_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* allocate all the receive buffer stuff */
name|error
operator|=
name|patm_rbuf_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Allocate SCD tag 	 * 	 * Don't use BUS_DMA_ALLOCNOW, because we never need bouncing with 	 * bus_dmamem_alloc() 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patm_scd
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patm_scd
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|scd_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"SCD DMA tag create %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|scd_list
argument_list|)
expr_stmt|;
comment|/* allocate VCC zone and pointers */
if|if
condition|(
operator|(
name|sc
operator|->
name|vcc_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"PATM vccs"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patm_vcc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"cannot allocate zone for vccs\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|vccs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|mmap
operator|->
name|max_conn
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* allocate transmission resources */
name|error
operator|=
name|patm_txmap_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* poll while we are not running */
name|sc
operator|->
name|utopia
operator|.
name|flags
operator||=
name|UTP_FL_POLL_CARRIER
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"attaching interface"
argument_list|)
expr_stmt|;
name|atm_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ATM_RFC1483
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"attaching interrupt handler"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|patm_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"could not setup interrupt\n"
argument_list|)
expr_stmt|;
name|atm_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|patm_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach  */
end_comment

begin_function
specifier|static
name|int
name|patm_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|patm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|utopia
operator|.
name|state
operator|&
name|UTP_ST_ATTACHED
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"detaching utopia"
argument_list|)
expr_stmt|;
name|utopia_stop
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
name|utopia_detach
argument_list|(
operator|&
name|sc
operator|->
name|utopia
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|atm_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|patm_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy everything. Assume we are stopped.  */
end_comment

begin_function
specifier|static
name|void
name|patm_destroy
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_mapzone
operator|!=
name|NULL
condition|)
block|{
comment|/* all maps must be free */
while|while
condition|(
operator|(
name|map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sc
operator|->
name|tx_mapzone
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|tx_mapzone
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|scd_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vccs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|max_conn
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vcc_zone
operator|!=
name|NULL
condition|)
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lbufs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|lbuf_max
condition|;
name|i
operator|++
control|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|,
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|lbufs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|lbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sbuf_pool
operator|!=
name|NULL
condition|)
name|mbp_destroy
argument_list|(
name|sc
operator|->
name|sbuf_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|vbuf_pool
operator|!=
name|NULL
condition|)
name|mbp_destroy
argument_list|(
name|sc
operator|->
name|vbuf_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sbuf_tag
operator|!=
name|NULL
condition|)
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sbuf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tst_soft
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|tst_soft
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* 	 * Free all status queue memory resources 	 */
if|if
condition|(
name|sc
operator|->
name|tsq
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|,
name|sc
operator|->
name|sq_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|,
name|sc
operator|->
name|tsq
argument_list|,
name|sc
operator|->
name|sq_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irqres
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqid
argument_list|,
name|sc
operator|->
name|irqres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|IDT_PCI_REG_MEMBASE
argument_list|,
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
comment|/* this was initialize unconditionally */
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to find a variable in the environment and parse it as an unsigned  * integer.  */
end_comment

begin_function
specifier|static
name|void
name|patm_env_getuint
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
name|full
index|[
name|IFNAMSIZ
operator|+
literal|3
operator|+
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|u_long
name|u
decl_stmt|;
name|snprintf
argument_list|(
name|full
argument_list|,
sizeof|sizeof
argument_list|(
name|full
argument_list|)
argument_list|,
literal|"hw.%s.%s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
name|full
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|u
operator|=
name|strtoul
argument_list|(
name|val
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|val
operator|&&
operator|*
name|end
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"%s=%lu\n"
argument_list|,
name|full
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|*
name|var
operator|=
name|u
expr_stmt|;
block|}
name|freeenv
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sysctl handler for internal statistics  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|patm_sysctl_istats
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|uint32_t
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|stats
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handler for EEPROM  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|patm_sysctl_eeprom
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|eeprom
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the EEPROM. We assume that this is a XIRCOM 25020  */
end_comment

begin_function
specifier|static
name|void
name|patm_read_eeprom
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|gp
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|int
name|i
decl_stmt|,
name|addr
decl_stmt|;
specifier|static
specifier|const
name|uint32_t
name|tab
index|[]
init|=
block|{
comment|/* CS transition to reset the chip */
name|IDT_GP_EECS
operator||
name|IDT_GP_EESCLK
block|,
literal|0
block|,
comment|/* read command 0x03 */
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
name|IDT_GP_EEDO
block|,
name|IDT_GP_EESCLK
operator||
name|IDT_GP_EEDO
block|,
name|IDT_GP_EEDO
block|,
name|IDT_GP_EESCLK
operator||
name|IDT_GP_EEDO
block|,
literal|0
block|,
comment|/* address 0x00 */
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|,
name|IDT_GP_EESCLK
block|,
literal|0
block|, 	}
decl_stmt|;
comment|/* go to a known state (chip enabled) */
name|gp
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|)
expr_stmt|;
name|gp
operator|&=
operator|~
operator|(
name|IDT_GP_EESCLK
operator||
name|IDT_GP_EECS
operator||
name|IDT_GP_EEDO
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
name|gp
operator||
name|tab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
comment|/* read out the prom */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
literal|256
condition|;
name|addr
operator|++
control|)
block|{
name|byte
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|byte
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|)
operator|&
name|IDT_GP_EEDI
condition|)
name|byte
operator||=
literal|1
expr_stmt|;
comment|/* rising CLK */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
name|gp
operator||
name|IDT_GP_EESCLK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* falling clock */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|eeprom
index|[
name|addr
index|]
operator|=
name|byte
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * PHY access read  */
end_comment

begin_function
specifier|static
name|int
name|patm_phy_readregs
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|,
name|u_int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int
name|cnt
init|=
operator|*
name|n
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0x100
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|patm_cmd_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|reg
operator|<
literal|0x100
operator|&&
name|cnt
operator|>
literal|0
condition|)
block|{
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CMD
argument_list|,
name|IDT_MKCMD_RUTIL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|patm_cmd_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D0
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|PHY
argument_list|,
literal|"phy(%02x)=%02x"
argument_list|,
name|reg
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|val
operator|++
expr_stmt|;
name|reg
operator|++
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
operator|*
name|n
operator|=
operator|*
name|n
operator|-
name|cnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write PHY reg  */
end_comment

begin_function
specifier|static
name|int
name|patm_phy_writereg
parameter_list|(
name|struct
name|ifatm
modifier|*
name|ifatm
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|u_int
name|mask
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|ifatm
operator|->
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int
name|old
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0x100
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|patm_cmd_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CMD
argument_list|,
name|IDT_MKCMD_RUTIL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|patm_cmd_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|old
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D0
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|old
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
name|val
operator|&
name|mask
operator|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|PHY
argument_list|,
literal|"phy(%02x) %02x -> %02x"
argument_list|,
name|reg
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_D0
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CMD
argument_list|,
name|IDT_MKCMD_WUTIL
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|patm_cmd_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a large chunk of DMA able memory for the transmit  * and receive status queues. We align this to a page boundary  * to ensure the alignment.  */
end_comment

begin_function
specifier|static
name|int
name|patm_sq_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
comment|/* compute size of the two queues */
name|sc
operator|->
name|sq_size
operator|=
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
operator|+
name|PATM_RSQ_SIZE
operator|*
name|IDT_RSQE_SIZE
operator|+
name|IDT_RAWHND_SIZE
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"allocating status queues (%zu) ..."
argument_list|,
name|sc
operator|->
name|sq_size
argument_list|)
expr_stmt|;
comment|/* 	 * allocate tag 	 * Don't use BUS_DMA_ALLOCNOW, because we never need bouncing with 	 * bus_dmamem_alloc() 	 */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
name|PATM_SQ_ALIGNMENT
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|sq_size
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|sq_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sq_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"memory DMA tag create %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* allocate memory */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sq_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"memory DMA alloc %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* map it */
name|sc
operator|->
name|tsq_phy
operator|=
literal|0x1fff
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|,
name|sc
operator|->
name|sq_map
argument_list|,
name|p
argument_list|,
name|sc
operator|->
name|sq_size
argument_list|,
name|patm_load_callback
argument_list|,
operator|&
name|sc
operator|->
name|tsq_phy
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"memory DMA map load %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|,
name|p
argument_list|,
name|sc
operator|->
name|sq_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sq_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* set queue start */
name|sc
operator|->
name|tsq
operator|=
name|p
expr_stmt|;
name|sc
operator|->
name|rsq
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|rsq_phy
operator|=
name|sc
operator|->
name|tsq_phy
operator|+
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
expr_stmt|;
name|sc
operator|->
name|rawhnd
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sc
operator|->
name|rsq
operator|+
name|PATM_RSQ_SIZE
operator|*
name|IDT_RSQE_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|rawhnd_phy
operator|=
name|sc
operator|->
name|rsq_phy
operator|+
name|PATM_RSQ_SIZE
operator|*
name|IDT_RSQE_SIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize all receive buffer stuff  */
end_comment

begin_function
specifier|static
name|int
name|patm_rbuf_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"allocating Rx buffer resources ..."
argument_list|)
expr_stmt|;
comment|/* 	 * Create a tag for small buffers. We allocate these page wise. 	 * Don't use BUS_DMA_ALLOCNOW, because we never need bouncing with 	 * bus_dmamem_alloc() 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SMBUF_PAGE_SIZE
argument_list|,
literal|1
argument_list|,
name|SMBUF_PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sbuf_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"sbuf DMA tag create %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mbp_create
argument_list|(
operator|&
name|sc
operator|->
name|sbuf_pool
argument_list|,
literal|"patm sbufs"
argument_list|,
name|sc
operator|->
name|sbuf_tag
argument_list|,
name|SMBUF_MAX_PAGES
argument_list|,
name|SMBUF_PAGE_SIZE
argument_list|,
name|SMBUF_CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"smbuf pool create %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mbp_create
argument_list|(
operator|&
name|sc
operator|->
name|vbuf_pool
argument_list|,
literal|"patm vbufs"
argument_list|,
name|sc
operator|->
name|sbuf_tag
argument_list|,
name|VMBUF_MAX_PAGES
argument_list|,
name|SMBUF_PAGE_SIZE
argument_list|,
name|VMBUF_CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"vmbuf pool create %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create a tag for large buffers. 	 * Don't use BUS_DMA_ALLOCNOW, because it makes no sense with multiple 	 * maps using one tag. Rather use BUS_DMA_NOWAIT when loading the map 	 * to prevent EINPROGRESS. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|lbuf_tag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"lbuf DMA tag create %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|lbuf_max
operator|<
name|IDT_FBQ_SIZE
condition|)
name|sc
operator|->
name|lbuf_max
operator|=
name|LMBUF_MAX
expr_stmt|;
name|sc
operator|->
name|lbufs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|lbufs
index|[
literal|0
index|]
argument_list|)
operator|*
name|sc
operator|->
name|lbuf_max
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|lbuf_free_list
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|lbuf_max
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|lmbuf
modifier|*
name|b
init|=
operator|&
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
decl_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|b
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* must deallocate here, because a test for NULL 			 * does not work on most archs */
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|lbuf_tag
argument_list|,
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|lbufs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|lbufs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|b
operator|->
name|handle
operator|=
name|i
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|lbuf_free_list
argument_list|,
name|b
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate everything needed for the transmission maps.  */
end_comment

begin_function
specifier|static
name|int
name|patm_txmap_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
comment|/* get transmission tag */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|65536
argument_list|,
name|IDT_SCQ_SIZE
operator|-
literal|1
argument_list|,
literal|65536
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"cannot allocate TX tag %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|tx_mapzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PATM tx maps"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patm_txmap
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|tx_maxmaps
operator|<
name|PATM_CFG_TXMAPS_MAX
condition|)
name|sc
operator|->
name|tx_maxmaps
operator|=
name|PATM_CFG_TXMAPS_MAX
expr_stmt|;
name|sc
operator|->
name|tx_nmaps
operator|=
name|PATM_CFG_TXMAPS_INIT
expr_stmt|;
for|for
control|(
name|sc
operator|->
name|tx_nmaps
operator|=
literal|0
init|;
name|sc
operator|->
name|tx_nmaps
operator|<
name|PATM_CFG_TXMAPS_INIT
condition|;
name|sc
operator|->
name|tx_nmaps
operator|++
control|)
block|{
name|map
operator|=
name|uma_zalloc
argument_list|(
name|sc
operator|->
name|tx_mapzone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|uma_zfree
argument_list|(
name|sc
operator|->
name|tx_mapzone
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PATM_DEBUG
end_ifdef

begin_comment
comment|/*  * Sysctl handler for REGS  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|patm_sysctl_regs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|uint32_t
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|IDT_NOR_END
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDT_NOR_END
condition|;
name|i
operator|+=
literal|4
control|)
name|ret
index|[
name|i
operator|/
literal|4
index|]
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
name|IDT_NOR_END
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handler for TSQ  *  * LOCK: unlocked, needed  */
end_comment

begin_function
specifier|static
name|int
name|patm_sysctl_tsq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|sc
operator|->
name|tsq
argument_list|,
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|ret
argument_list|,
name|IDT_TSQ_SIZE
operator|*
name|IDT_TSQE_SIZE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ret
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * debugging  */
end_comment

begin_function
specifier|static
name|struct
name|patm_softc
modifier|*
name|patm_dump_unit
parameter_list|(
name|u_int
name|unit
parameter_list|)
block|{
name|devclass_t
name|dc
decl_stmt|;
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|dc
operator|=
name|devclass_find
argument_list|(
literal|"patm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't find devclass\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: invalid unit number: %d\n"
argument_list|,
name|__func__
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|patm_dump_vc
parameter_list|(
name|u_int
name|unit
parameter_list|,
name|u_int
name|vc
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|tct
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|rct
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|scd
index|[
literal|12
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|patm_dump_unit
argument_list|(
name|unit
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|tct
index|[
name|i
index|]
operator|=
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|vc
operator|*
literal|8
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|rct
index|[
name|i
index|]
operator|=
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|rct
operator|+
name|vc
operator|*
literal|4
operator|+
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|scd
index|[
name|i
index|]
operator|=
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
operator|(
name|tct
index|[
literal|0
index|]
operator|&
literal|0x7ffff
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TCT%3u: %08x %08x %08x %08x  %08x %08x %08x %08x\n"
argument_list|,
name|vc
argument_list|,
name|tct
index|[
literal|0
index|]
argument_list|,
name|tct
index|[
literal|1
index|]
argument_list|,
name|tct
index|[
literal|2
index|]
argument_list|,
name|tct
index|[
literal|3
index|]
argument_list|,
name|tct
index|[
literal|4
index|]
argument_list|,
name|tct
index|[
literal|5
index|]
argument_list|,
name|tct
index|[
literal|6
index|]
argument_list|,
name|tct
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RCT%3u: %08x %08x %08x %08x\n"
argument_list|,
name|vc
argument_list|,
name|rct
index|[
literal|0
index|]
argument_list|,
name|rct
index|[
literal|1
index|]
argument_list|,
name|rct
index|[
literal|2
index|]
argument_list|,
name|rct
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCD%3u: %08x %08x %08x %08x  %08x %08x %08x %08x\n"
argument_list|,
name|vc
argument_list|,
name|scd
index|[
literal|0
index|]
argument_list|,
name|scd
index|[
literal|1
index|]
argument_list|,
name|scd
index|[
literal|2
index|]
argument_list|,
name|scd
index|[
literal|3
index|]
argument_list|,
name|scd
index|[
literal|4
index|]
argument_list|,
name|scd
index|[
literal|5
index|]
argument_list|,
name|scd
index|[
literal|6
index|]
argument_list|,
name|scd
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        %08x %08x %08x %08x\n"
argument_list|,
name|scd
index|[
literal|8
index|]
argument_list|,
name|scd
index|[
literal|9
index|]
argument_list|,
name|scd
index|[
literal|10
index|]
argument_list|,
name|scd
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|patm_dump_regs
parameter_list|(
name|u_int
name|unit
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|patm_dump_unit
argument_list|(
name|unit
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IDT_NOR_DNOW
condition|;
name|i
operator|+=
literal|4
control|)
name|printf
argument_list|(
literal|"%x: %08x\n"
argument_list|,
name|i
argument_list|,
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|patm_dump_sram
parameter_list|(
name|u_int
name|unit
parameter_list|,
name|u_int
name|from
parameter_list|,
name|u_int
name|words
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|patm_dump_unit
argument_list|(
name|unit
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%05x:"
argument_list|,
name|from
operator|+
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %08x"
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|from
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|7
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|%
literal|8
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

