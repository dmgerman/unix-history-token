begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * Driver for IDT77252 based cards like ProSum's.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbpool.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/idt77252reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/if_patmvar.h>
end_include

begin_function_decl
specifier|static
name|void
name|patm_tst_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_scd_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Start the card. This assumes the mutex to be held  */
end_comment

begin_function
name|void
name|patm_initialize
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|cfg
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"configuring..."
argument_list|)
expr_stmt|;
comment|/* clear SRAM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|sram
operator|*
literal|1024
condition|;
name|i
operator|+=
literal|4
control|)
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_scd_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* configuration register. Setting NOIDLE makes the timing wrong! */
name|cfg
operator|=
name|IDT_CFG_TXFIFO9
operator||
name|IDT_CFG_RXQ512
operator||
name|PATM_CFG_VPI
operator||
comment|/* IDT_CFG_NOIDLE | */
name|sc
operator|->
name|mmap
operator|->
name|rxtab
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|PATM_UNASS
operator|)
condition|)
name|cfg
operator||=
name|IDT_CFG_IDLECLP
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* clean all the status queues and the Raw handle */
name|memset
argument_list|(
name|sc
operator|->
name|tsq
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sq_size
argument_list|)
expr_stmt|;
comment|/* initialize RSQ */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"RSQ %llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sc
operator|->
name|rsq_phy
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RSQB
argument_list|,
name|sc
operator|->
name|rsq_phy
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RSQT
argument_list|,
name|sc
operator|->
name|rsq_phy
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RSQH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rsq_last
operator|=
name|PATM_RSQ_SIZE
operator|-
literal|1
expr_stmt|;
comment|/* initialize TSTB */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TSTB
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|tst1base
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|patm_tst_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* initialize TSQ */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDT_TSQ_SIZE
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|tsq
index|[
name|i
index|]
operator|.
name|stamp
operator|=
name|htole32
argument_list|(
name|IDT_TSQE_EMPTY
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TSQB
argument_list|,
name|sc
operator|->
name|tsq_phy
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TSQH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TSQT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tsq_next
operator|=
name|sc
operator|->
name|tsq
expr_stmt|;
comment|/* GP */
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|&&
literal|0
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
name|IDT_GP_BIGE
argument_list|)
expr_stmt|;
else|#
directive|else
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VPM */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_VPM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* RxFIFO */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RXFD
argument_list|,
name|IDT_RXFD
argument_list|(
name|sc
operator|->
name|mmap
operator|->
name|rxfifo_addr
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|rxfifo_code
argument_list|)
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RXFT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RXFH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* RAWHND */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"RWH %llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sc
operator|->
name|rawhnd_phy
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RAWHND
argument_list|,
name|sc
operator|->
name|rawhnd_phy
argument_list|)
expr_stmt|;
comment|/* ABRSTD */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_ABRSTD
argument_list|,
name|IDT_ABRSTD
argument_list|(
name|sc
operator|->
name|mmap
operator|->
name|abrstd_addr
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|abrstd_code
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|abrstd_size
condition|;
name|i
operator|++
control|)
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|abrstd_addr
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_ABRRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_VBRRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* rate tables */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PATM_25M
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patm_rtables_size
condition|;
name|i
operator|++
control|)
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|rtables
operator|+
name|i
argument_list|,
name|patm_rtables25
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patm_rtables_size
condition|;
name|i
operator|++
control|)
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|rtables
operator|+
name|i
argument_list|,
name|patm_rtables155
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RTBL
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|rtables
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* Maximum deficit */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_MXDFCT
argument_list|,
literal|32
operator||
name|IDT_MDFCT_LCI
operator||
name|IDT_MDFCT_LNI
argument_list|)
expr_stmt|;
comment|/* Free buffer queues */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQP0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQWP0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQWP1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQWP2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQWP3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQS0
argument_list|,
operator|(
name|SMBUF_THRESHOLD
operator|<<
literal|28
operator|)
operator||
operator|(
name|SMBUF_NI_THRESH
operator|<<
literal|24
operator|)
operator||
operator|(
name|SMBUF_CI_THRESH
operator|<<
literal|20
operator|)
operator||
name|SMBUF_CELLS
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQS1
argument_list|,
operator|(
name|LMBUF_THRESHOLD
operator|<<
literal|28
operator|)
operator||
operator|(
name|LMBUF_NI_THRESH
operator|<<
literal|24
operator|)
operator||
operator|(
name|LMBUF_CI_THRESH
operator|<<
literal|20
operator|)
operator||
name|LMBUF_CELLS
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQS2
argument_list|,
operator|(
name|VMBUF_THRESHOLD
operator|<<
literal|28
operator|)
operator||
name|VMBUF_CELLS
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_FBQS3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make SCD0 for UBR0 */
if|if
condition|(
operator|(
name|sc
operator|->
name|scd0
operator|=
name|patm_scd_alloc
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"cannot create UBR0 SCD\n"
argument_list|)
expr_stmt|;
name|patm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|scd0
operator|->
name|q
operator|.
name|ifq_maxlen
operator|=
name|PATM_DLFT_MAXQ
expr_stmt|;
name|patm_scd_setup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|scd0
argument_list|)
expr_stmt|;
name|patm_tct_setup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|scd0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"go..."
argument_list|)
expr_stmt|;
name|sc
operator|->
name|utopia
operator|.
name|flags
operator|&=
operator|~
name|UTP_FL_POLL_CARRIER
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* enable interrupts, Tx and Rx paths */
name|cfg
operator||=
name|IDT_CFG_RXPTH
operator||
name|IDT_CFG_RXIIMM
operator||
name|IDT_CFG_RAWIE
operator||
name|IDT_CFG_RQFIE
operator||
name|IDT_CFG_TIMOIE
operator||
name|IDT_CFG_FBIE
operator||
name|IDT_CFG_TXENB
operator||
name|IDT_CFG_TXINT
operator||
name|IDT_CFG_TXUIE
operator||
name|IDT_CFG_TXSFI
operator||
name|IDT_CFG_PHYIE
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|max_conn
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|patm_load_vc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ATMEV_SEND_IFSTATE_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|carrier
operator|==
name|UTP_CARR_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * External callable start function  */
end_comment

begin_function
name|void
name|patm_init
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|patm_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|patm_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface  */
end_comment

begin_function
name|void
name|patm_stop
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
name|struct
name|patm_scd
modifier|*
name|scd
decl_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|utopia
operator|.
name|flags
operator||=
name|UTP_FL_POLL_CARRIER
expr_stmt|;
name|patm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|tst_state
expr_stmt|;
name|sc
operator|->
name|tst_state
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|tst_callout
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* this means we are just entering or leaving the timeout. 		 * wait a little bit. Doing this correctly would be more 		 * involved */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Give any waiters on closing a VCC a chance. They will stop 	 * to wait if they see that IFF_DRV_RUNNING disappeared. 	 */
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|)
expr_stmt|;
comment|/* free large buffers */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"freeing large buffers..."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|lbuf_max
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
operator|.
name|m
operator|!=
name|NULL
condition|)
name|patm_lbuf_free
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|lbufs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* free small buffers that are on the card */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"freeing small buffers..."
argument_list|)
expr_stmt|;
name|mbp_card_free
argument_list|(
name|sc
operator|->
name|sbuf_pool
argument_list|)
expr_stmt|;
comment|/* free aal0 buffers that are on the card */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"freeing aal0 buffers..."
argument_list|)
expr_stmt|;
name|mbp_card_free
argument_list|(
name|sc
operator|->
name|vbuf_pool
argument_list|)
expr_stmt|;
comment|/* freeing partial receive chains and reset vcc state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|max_conn
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|chain
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|chain
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|vflags
operator|&
operator|(
name|PATM_VCC_RX_CLOSING
operator||
name|PATM_VCC_TX_CLOSING
operator|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|sc
operator|->
name|vcc_zone
argument_list|,
name|sc
operator|->
name|vccs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* keep */
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|vflags
operator|&=
operator|~
name|PATM_VCC_OPEN
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|cps
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|vccs
index|[
name|i
index|]
operator|->
name|scd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* stop all active SCDs */
while|while
condition|(
operator|(
name|scd
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|scd_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* free queue packets */
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|scd
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* free transmitting packets */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDT_TSQE_TAG_SPACE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|scd
operator|->
name|on_card
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|scd
operator|->
name|on_card
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|map
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|patm_scd_free
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|scd0
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|PATM_CLR
expr_stmt|;
comment|/* reset raw cell queue */
name|sc
operator|->
name|rawh
operator|=
name|NULL
expr_stmt|;
name|ATMEV_SEND_IFSTATE_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|utopia
operator|.
name|carrier
operator|==
name|UTP_CARR_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop the card and reset it  */
end_comment

begin_function
name|void
name|patm_reset
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|ATTACH
argument_list|,
literal|"resetting..."
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|,
name|IDT_CFG_SWRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_RSQH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TSQH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
name|IDT_GP_PHY_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_GP
argument_list|,
name|IDT_GP_EEDO
operator||
name|IDT_GP_EECS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the soft TST to contain only ABR scheduling and  * write it to SRAM  */
end_comment

begin_function
specifier|static
name|void
name|patm_tst_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int
name|base
decl_stmt|,
name|idle
decl_stmt|;
name|base
operator|=
name|sc
operator|->
name|mmap
operator|->
name|tst1base
expr_stmt|;
name|idle
operator|=
name|sc
operator|->
name|mmap
operator|->
name|tst1base
operator|+
name|sc
operator|->
name|mmap
operator|->
name|tst_size
expr_stmt|;
comment|/* soft */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|tst_soft
index|[
name|i
index|]
operator|=
name|IDT_TST_VBR
expr_stmt|;
name|sc
operator|->
name|tst_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|tst_jump
index|[
literal|0
index|]
operator|=
name|base
operator|+
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|tst_jump
index|[
literal|1
index|]
operator|=
name|idle
operator|+
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|tst_base
index|[
literal|0
index|]
operator|=
name|base
expr_stmt|;
name|sc
operator|->
name|tst_base
index|[
literal|1
index|]
operator|=
name|idle
expr_stmt|;
comment|/* TST1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|base
operator|+
name|i
argument_list|,
name|IDT_TST_VBR
argument_list|)
expr_stmt|;
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tst_jump
index|[
literal|0
index|]
argument_list|,
name|IDT_TST_BR
operator||
operator|(
name|base
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* TST2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|idle
operator|+
name|i
argument_list|,
name|IDT_TST_VBR
argument_list|)
expr_stmt|;
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tst_jump
index|[
literal|1
index|]
argument_list|,
name|IDT_TST_BR
operator||
operator|(
name|idle
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tst_free
operator|=
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|tst_reserve
operator|=
name|sc
operator|->
name|tst_free
operator|*
name|PATM_TST_RESERVE
operator|/
literal|100
expr_stmt|;
name|sc
operator|->
name|bwrem
operator|=
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the SCDs. This is done by building a list of all free  * SCDs in SRAM. The first word of each potential SCD is used as a  * link to the next free SCD. The list is rooted in softc.  */
end_comment

begin_function
specifier|static
name|void
name|patm_scd_init
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|s
decl_stmt|;
comment|/* SRAM address of current SCD */
name|sc
operator|->
name|scd_free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|sc
operator|->
name|mmap
operator|->
name|scd_base
init|;
name|s
operator|+
literal|12
operator|<=
name|sc
operator|->
name|mmap
operator|->
name|tst1base
condition|;
name|s
operator|+=
literal|12
control|)
block|{
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|s
argument_list|,
name|sc
operator|->
name|scd_free
argument_list|)
expr_stmt|;
name|sc
operator|->
name|scd_free
operator|=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * allocate an SCQ  */
end_comment

begin_function
name|struct
name|patm_scd
modifier|*
name|patm_scd_alloc
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|sram
decl_stmt|,
name|next
decl_stmt|;
comment|/* SRAM address of this and next SCD */
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|struct
name|patm_scd
modifier|*
name|scd
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|bus_addr_t
name|phy
decl_stmt|;
comment|/* get an SCD from the free list */
if|if
condition|(
operator|(
name|sram
operator|=
name|sc
operator|->
name|scd_free
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|next
operator|=
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
argument_list|)
expr_stmt|;
comment|/* allocate memory for the queue and our host stuff */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|,
operator|&
name|p
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|phy
operator|=
literal|0x3ff
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|,
name|map
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|scd
operator|->
name|scq
argument_list|)
argument_list|,
name|patm_load_callback
argument_list|,
operator|&
name|phy
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|,
name|p
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|(
name|phy
operator|&
literal|0x1ff
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"SCD not aligned %lx"
operator|,
operator|(
name|u_long
operator|)
name|phy
operator|)
argument_list|)
expr_stmt|;
name|scd
operator|=
name|p
expr_stmt|;
name|bzero
argument_list|(
name|scd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scd
argument_list|)
argument_list|)
expr_stmt|;
name|scd
operator|->
name|sram
operator|=
name|sram
expr_stmt|;
name|scd
operator|->
name|phy
operator|=
name|phy
expr_stmt|;
name|scd
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|scd
operator|->
name|space
operator|=
name|IDT_SCQ_SIZE
expr_stmt|;
name|scd
operator|->
name|last_tag
operator|=
name|IDT_TSQE_TAG_SPACE
operator|-
literal|1
expr_stmt|;
name|scd
operator|->
name|q
operator|.
name|ifq_maxlen
operator|=
name|PATM_TX_IFQLEN
expr_stmt|;
comment|/* remove the scd from the free list */
name|sc
operator|->
name|scd_free
operator|=
name|next
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|scd_list
argument_list|,
name|scd
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|scd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an SCD  */
end_comment

begin_function
name|void
name|patm_scd_free
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_scd
modifier|*
name|scd
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|scd
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* clear SCD and insert link word */
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
argument_list|,
name|sc
operator|->
name|scd_free
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* put on free list */
name|sc
operator|->
name|scd_free
operator|=
name|scd
operator|->
name|sram
expr_stmt|;
comment|/* free memory */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|,
name|scd
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|scd_tag
argument_list|,
name|scd
argument_list|,
name|scd
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DMA loading helper function. This function handles the loading of  * all one segment DMA maps. The argument is a pointer to a bus_addr_t  * which must contain the desired alignment of the address as a bitmap.  */
end_comment

begin_function
name|void
name|patm_load_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|phy
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"too many segments for DMA: %d"
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|<=
literal|0xffffffffUL
argument_list|,
operator|(
literal|"phys addr too large %lx"
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|&
operator|*
name|phy
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bad alignment %lx:%lx"
operator|,
operator|(
name|u_long
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|,
operator|(
name|u_long
operator|)
operator|*
name|phy
operator|)
argument_list|)
expr_stmt|;
operator|*
name|phy
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

end_unit

