begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The TST allocation algorithm is from the IDT driver which is:  *  *	Copyright (c) 2000, 2001 Richard Hodges and Matriplex, inc.  *	All rights reserved.  *  *	Copyright (c) 1996, 1997, 1998, 1999 Mark Tinguely  *	All rights reserved.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * Driver for IDT77252 based cards like ProSum's.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_BPF
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbpool.h>
end_include

begin_include
include|#
directive|include
file|<dev/utopia/utopia.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/idt77252reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/patm/if_patmvar.h>
end_include

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|patm_tx_pad
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_launch
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_scd
modifier|*
name|scd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|patm_txmap
modifier|*
name|patm_txmap_get
parameter_list|(
name|struct
name|patm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_load_txbuf
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bus_size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_tst_alloc
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_tst_free
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_tst_timer
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_tst_update
parameter_list|(
name|struct
name|patm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|patm_tct_start
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dump_scd
argument_list|(
expr|struct
name|patm_softc
operator|*
name|sc
argument_list|,
expr|struct
name|patm_scd
operator|*
name|scd
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|patm_tct_print
argument_list|(
expr|struct
name|patm_softc
operator|*
name|sc
argument_list|,
name|u_int
name|cid
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure for communication with the loader function for transmission  */
end_comment

begin_struct
struct|struct
name|txarg
block|{
name|struct
name|patm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|patm_scd
modifier|*
name|scd
decl_stmt|;
comment|/* scheduling channel */
name|struct
name|patm_vcc
modifier|*
name|vcc
decl_stmt|;
comment|/* the VCC of this PDU */
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
name|u_int
name|hdr
decl_stmt|;
comment|/* cell header */
block|}
struct|;
end_struct

begin_function
specifier|static
name|__inline
name|u_int
name|cbr2slots
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
comment|/* compute the number of slots we need, make sure to get at least 	 * the specified PCR */
return|return
operator|(
call|(
name|u_int
call|)
argument_list|(
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
argument_list|)
operator|*
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
operator|+
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|-
literal|1
operator|)
operator|/
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|slots2cr
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|slots
parameter_list|)
block|{
return|return
operator|(
operator|(
name|slots
operator|*
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|+
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|2
operator|)
operator|/
operator|(
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check if we can open this one */
end_comment

begin_function
name|int
name|patm_tx_vcc_can_open
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
comment|/* check resources */
switch|switch
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_CBR
case|:
block|{
name|u_int
name|slots
init|=
name|cbr2slots
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
decl_stmt|;
if|if
condition|(
name|slots
operator|>
name|sc
operator|->
name|tst_free
operator|+
name|sc
operator|->
name|tst_reserve
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
case|case
name|ATMIO_TRAFFIC_VBR
case|:
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|scr
operator|>
name|sc
operator|->
name|bwrem
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
operator|>
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|scr
operator|>
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
operator|||
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|mbs
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|ATMIO_TRAFFIC_ABR
case|:
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|tbe
operator|==
literal|0
operator|||
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|nrm
operator|==
literal|0
condition|)
comment|/* needed to compute CRM */
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
operator|>
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|||
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|icr
operator|>
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
operator|||
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|mcr
operator|>
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|icr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|mcr
operator|>
name|sc
operator|->
name|bwrem
operator|||
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|icr
operator|>
name|sc
operator|->
name|bwrem
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NEXT_TAG
parameter_list|(
name|T
parameter_list|)
value|do {				\ 	(T) = ((T) + 1) % IDT_TSQE_TAG_SPACE;		\     } while (0)
end_define

begin_comment
comment|/*  * open it  */
end_comment

begin_function
name|void
name|patm_tx_vcc_open
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|struct
name|patm_scd
modifier|*
name|scd
decl_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_UBR
condition|)
block|{
comment|/* we use UBR0 */
name|vcc
operator|->
name|scd
operator|=
name|sc
operator|->
name|scd0
expr_stmt|;
name|vcc
operator|->
name|vflags
operator||=
name|PATM_VCC_TX_OPEN
expr_stmt|;
return|return;
block|}
comment|/* get an SCD */
name|scd
operator|=
name|patm_scd_alloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scd
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen */
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"out of SCDs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vcc
operator|->
name|scd
operator|=
name|scd
expr_stmt|;
name|patm_scd_setup
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|)
expr_stmt|;
name|patm_tct_setup
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|!=
name|ATMIO_TRAFFIC_CBR
condition|)
name|patm_tct_start
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
name|vcc
operator|->
name|vflags
operator||=
name|PATM_VCC_TX_OPEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * close the given vcc for transmission  */
end_comment

begin_function
name|void
name|patm_tx_vcc_close
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|struct
name|patm_scd
modifier|*
name|scd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|vcc
operator|->
name|vflags
operator||=
name|PATM_VCC_TX_CLOSING
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_UBR
condition|)
block|{
comment|/* let the queue PDUs go out */
name|vcc
operator|->
name|scd
operator|=
name|NULL
expr_stmt|;
name|vcc
operator|->
name|vflags
operator|&=
operator|~
operator|(
name|PATM_VCC_TX_OPEN
operator||
name|PATM_VCC_TX_CLOSING
operator|)
expr_stmt|;
return|return;
block|}
name|scd
operator|=
name|vcc
operator|->
name|scd
expr_stmt|;
comment|/* empty the waitq */
for|for
control|(
init|;
condition|;
control|)
block|{
name|_IF_DEQUEUE
argument_list|(
operator|&
name|scd
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scd
operator|->
name|num_on_card
operator|==
literal|0
condition|)
block|{
comment|/* we are idle */
name|vcc
operator|->
name|vflags
operator|&=
operator|~
name|PATM_VCC_TX_OPEN
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_CBR
condition|)
name|patm_tst_free
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_scd_free
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|)
expr_stmt|;
name|vcc
operator|->
name|scd
operator|=
name|NULL
expr_stmt|;
name|vcc
operator|->
name|vflags
operator|&=
operator|~
name|PATM_VCC_TX_CLOSING
expr_stmt|;
return|return;
block|}
comment|/* speed up transmission */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_UIER
argument_list|(
name|vcc
operator|->
name|cid
argument_list|,
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_ULACR
argument_list|(
name|vcc
operator|->
name|cid
argument_list|,
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait for the interrupt to drop the number to 0 */
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"%u buffers still on card"
argument_list|,
name|scd
operator|->
name|num_on_card
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* transmission side finally closed */
end_comment

begin_function
name|void
name|patm_tx_vcc_closed
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"%u.%u TX closed"
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|vpi
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_VBR
condition|)
name|sc
operator|->
name|bwrem
operator|+=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|scr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pull off packets from the interface queue and try to transmit them.  * If the transmission fails because of a full transmit channel, we drop  * packets for CBR and queue them for other channels up to limit.  * This limit should depend on the CDVT for VBR and ABR, but it doesn't.  */
end_comment

begin_function
name|void
name|patm_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|aph
decl_stmt|;
name|u_int
name|vpi
decl_stmt|,
name|vci
decl_stmt|,
name|cid
decl_stmt|;
name|struct
name|patm_vcc
modifier|*
name|vcc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* get a new mbuf */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* split of pseudo header */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|vci
operator|=
name|ATM_PH_VCI
argument_list|(
name|aph
argument_list|)
expr_stmt|;
name|vpi
operator|=
name|ATM_PH_VPI
argument_list|(
name|aph
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reject empty packets */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* check whether this is a legal vcc */
if|if
condition|(
operator|!
name|LEGAL_VPI
argument_list|(
name|sc
argument_list|,
name|vpi
argument_list|)
operator|||
operator|!
name|LEGAL_VCI
argument_list|(
name|sc
argument_list|,
name|vci
argument_list|)
operator|||
name|vci
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|cid
operator|=
name|PATM_CID
argument_list|(
name|sc
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|)
expr_stmt|;
name|vcc
operator|=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
expr_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* must be multiple of 48 if not AAL5 */
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_0
operator|||
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_34
condition|)
block|{
comment|/* XXX AAL3/4 format? */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|%
literal|48
operator|!=
literal|0
operator|&&
operator|(
name|m
operator|=
name|patm_tx_pad
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_RAW
condition|)
block|{
switch|switch
condition|(
name|vcc
operator|->
name|vflags
operator|&
name|PATM_RAW_FORMAT
condition|)
block|{
default|default:
case|case
name|PATM_RAW_CELL
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
literal|53
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PATM_RAW_NOHEC
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
literal|52
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|PATM_RAW_CS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
literal|64
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
comment|/* save data */
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|vcc
expr_stmt|;
comment|/* try to put it on the channels queue */
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|vcc
operator|->
name|scd
operator|->
name|q
argument_list|)
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_qfull
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|_IF_ENQUEUE
argument_list|(
operator|&
name|vcc
operator|->
name|scd
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_BPF
if|if
condition|(
operator|!
operator|(
name|vcc
operator|->
name|vcc
operator|.
name|flags
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|&&
operator|(
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
operator|)
operator|&&
operator|(
name|vcc
operator|->
name|vcc
operator|.
name|flags
operator|&
name|ATM_PH_LLCSNAP
operator|)
condition|)
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* kick the channel to life */
name|patm_launch
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|scd
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pad non-AAL5 packet to a multiple of 48-byte.  * We assume AAL0 only. We have still to decide on the format of AAL3/4.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|patm_tx_pad
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|last
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|u_int
name|plen
decl_stmt|,
name|pad
decl_stmt|,
name|space
decl_stmt|;
name|plen
operator|=
name|m_length
argument_list|(
name|m0
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"%s: mbuf length mismatch %d %u\n"
argument_list|,
name|__func__
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|plen
operator|%
literal|48
operator|==
literal|0
condition|)
return|return
operator|(
name|m0
operator|)
return|;
block|}
name|pad
operator|=
literal|48
operator|-
name|plen
operator|%
literal|48
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|last
argument_list|)
condition|)
block|{
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|last
argument_list|)
operator|>=
name|pad
condition|)
block|{
name|bzero
argument_list|(
name|last
operator|->
name|m_data
operator|+
name|last
operator|->
name|m_len
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|last
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
return|return
operator|(
name|m0
operator|)
return|;
block|}
name|space
operator|=
name|M_LEADINGSPACE
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|last
argument_list|)
operator|>=
name|pad
condition|)
block|{
name|bcopy
argument_list|(
name|last
operator|->
name|m_data
argument_list|,
name|last
operator|->
name|m_data
operator|+
name|space
argument_list|,
name|last
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|last
operator|->
name|m_data
operator|-=
name|space
expr_stmt|;
name|bzero
argument_list|(
name|last
operator|->
name|m_data
operator|+
name|last
operator|->
name|m_len
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|last
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
return|return
operator|(
name|m0
operator|)
return|;
block|}
block|}
name|MGET
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|pad
expr_stmt|;
name|last
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|m0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to put as many packets from the channels queue onto the channel  */
end_comment

begin_function
specifier|static
name|void
name|patm_launch
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_scd
modifier|*
name|scd
parameter_list|)
block|{
name|struct
name|txarg
name|a
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_int
name|segs
decl_stmt|;
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
name|int
name|error
decl_stmt|;
name|a
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|a
operator|.
name|scd
operator|=
name|scd
expr_stmt|;
comment|/* limit the number of outstanding packets to the tag space */
while|while
condition|(
name|scd
operator|->
name|num_on_card
operator|<
name|IDT_TSQE_TAG_SPACE
condition|)
block|{
comment|/* get the next packet */
name|_IF_DEQUEUE
argument_list|(
operator|&
name|scd
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|a
operator|.
name|vcc
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
expr_stmt|;
comment|/* we must know the number of segments beforehand - count 		 * this may actually give a wrong number of segments for 		 * AAL_RAW where we still need to remove the cell header */
name|segs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|m
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|m_next
control|)
if|if
condition|(
name|tmp
operator|->
name|m_len
operator|!=
literal|0
condition|)
name|segs
operator|++
expr_stmt|;
comment|/* check whether there is space in the queue */
if|if
condition|(
name|segs
operator|>=
name|scd
operator|->
name|space
condition|)
block|{
comment|/* put back */
name|_IF_PREPEND
argument_list|(
operator|&
name|scd
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_out_of_tbds
operator|++
expr_stmt|;
break|break;
block|}
comment|/* get a DMA map */
if|if
condition|(
operator|(
name|map
operator|=
name|patm_txmap_get
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|_IF_PREPEND
argument_list|(
operator|&
name|scd
operator|->
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|stats
operator|.
name|tx_out_of_maps
operator|++
expr_stmt|;
break|break;
block|}
comment|/* load the map */
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|map
expr_stmt|;
name|a
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
comment|/* handle AAL_RAW */
if|if
condition|(
name|a
operator|.
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_RAW
condition|)
block|{
name|u_char
name|hdr
index|[
literal|4
index|]
decl_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|a
operator|.
name|hdr
operator|=
operator|(
name|hdr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|hdr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|hdr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|hdr
index|[
literal|3
index|]
expr_stmt|;
switch|switch
condition|(
name|a
operator|.
name|vcc
operator|->
name|vflags
operator|&
name|PATM_RAW_FORMAT
condition|)
block|{
default|default:
case|case
name|PATM_RAW_CELL
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|PATM_RAW_NOHEC
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|PATM_RAW_CS
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|a
operator|.
name|hdr
operator|=
name|IDT_TBD_HDR
argument_list|(
name|a
operator|.
name|vcc
operator|->
name|vcc
operator|.
name|vpi
argument_list|,
name|a
operator|.
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|map
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|patm_load_txbuf
argument_list|,
operator|&
name|a
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|map
operator|->
name|map
argument_list|,
name|m
argument_list|,
name|patm_load_txbuf
argument_list|,
operator|&
name|a
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|stats
operator|.
name|tx_load_err
operator|++
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Load the DMA segments into the scheduling channel  */
end_comment

begin_function
specifier|static
name|void
name|patm_load_txbuf
parameter_list|(
name|void
modifier|*
name|uarg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|txarg
modifier|*
name|a
init|=
name|uarg
decl_stmt|;
name|struct
name|patm_scd
modifier|*
name|scd
init|=
name|a
operator|->
name|scd
decl_stmt|;
name|u_int
name|w1
decl_stmt|,
name|w3
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|idt_tbd
modifier|*
name|tbd
init|=
name|NULL
decl_stmt|;
name|u_int
name|rest
init|=
name|mapsize
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nseg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|segs
operator|->
name|ds_len
operator|==
literal|0
condition|)
block|{
comment|/* transmit buffer length must be> 0 */
name|nseg
operator|--
expr_stmt|;
name|segs
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* rest after this buffer */
name|rest
operator|-=
name|segs
operator|->
name|ds_len
expr_stmt|;
comment|/* put together status word */
name|w1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rest
operator|<
literal|48
comment|/*&& a->vcc->vcc.aal != ATMIO_AAL_5 */
condition|)
comment|/* last cell is in this buffer */
name|w1
operator||=
name|IDT_TBD_EPDU
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
condition|)
name|w1
operator||=
name|IDT_TBD_AAL5
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_34
condition|)
name|w1
operator||=
name|IDT_TBD_AAL34
expr_stmt|;
else|else
name|w1
operator||=
name|IDT_TBD_AAL0
expr_stmt|;
name|w1
operator||=
name|segs
operator|->
name|ds_len
expr_stmt|;
comment|/* AAL5 PDU length (unpadded) */
if|if
condition|(
name|a
operator|->
name|vcc
operator|->
name|vcc
operator|.
name|aal
operator|==
name|ATMIO_AAL_5
condition|)
name|w3
operator|=
name|mapsize
expr_stmt|;
else|else
name|w3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rest
operator|==
literal|0
condition|)
name|w1
operator||=
name|IDT_TBD_TSIF
operator||
name|IDT_TBD_GTSI
operator||
operator|(
name|scd
operator|->
name|tag
operator|<<
name|IDT_TBD_TAG_SHIFT
operator|)
expr_stmt|;
name|tbd
operator|=
operator|&
name|scd
operator|->
name|scq
index|[
name|scd
operator|->
name|tail
index|]
expr_stmt|;
name|tbd
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|w1
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|addr
operator|=
name|htole32
argument_list|(
name|segs
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|aal5
operator|=
name|htole32
argument_list|(
name|w3
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|hdr
operator|=
name|htole32
argument_list|(
name|a
operator|->
name|hdr
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|a
operator|->
name|sc
argument_list|,
name|TX
argument_list|,
literal|"TBD(%u): %08x %08x %08x %08x"
argument_list|,
name|scd
operator|->
name|tail
argument_list|,
name|w1
argument_list|,
name|segs
operator|->
name|ds_addr
argument_list|,
name|w3
argument_list|,
name|a
operator|->
name|hdr
argument_list|)
expr_stmt|;
comment|/* got to next entry */
if|if
condition|(
operator|++
name|scd
operator|->
name|tail
operator|==
name|IDT_SCQ_SIZE
condition|)
name|scd
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|nseg
operator|--
expr_stmt|;
name|segs
operator|++
expr_stmt|;
block|}
name|scd
operator|->
name|space
operator|-=
name|cnt
expr_stmt|;
name|scd
operator|->
name|num_on_card
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|rest
operator|==
literal|0
argument_list|,
operator|(
literal|"bad mbuf"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"no segs"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|scd
operator|->
name|space
operator|>
literal|0
argument_list|,
operator|(
literal|"scq full"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|scd
operator|->
name|on_card
index|[
name|scd
operator|->
name|tag
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"scd on_card wedged %u%s"
operator|,
name|scd
operator|->
name|tag
operator|,
name|dump_scd
argument_list|(
name|a
operator|->
name|sc
argument_list|,
name|scd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|scd
operator|->
name|on_card
index|[
name|scd
operator|->
name|tag
index|]
operator|=
name|a
operator|->
name|mbuf
expr_stmt|;
name|a
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|cnt
expr_stmt|;
name|NEXT_TAG
argument_list|(
name|scd
operator|->
name|tag
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|a
operator|->
name|sc
argument_list|,
name|TX
argument_list|,
literal|"SCD tail %u (%lx:%lx)"
argument_list|,
name|scd
operator|->
name|tail
argument_list|,
operator|(
name|u_long
operator|)
name|scd
operator|->
name|phy
argument_list|,
operator|(
name|u_long
operator|)
name|scd
operator|->
name|phy
operator|+
operator|(
name|scd
operator|->
name|tail
operator|<<
name|IDT_TBD_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|patm_sram_write
argument_list|(
name|a
operator|->
name|sc
argument_list|,
name|scd
operator|->
name|sram
argument_list|,
name|scd
operator|->
name|phy
operator|+
operator|(
name|scd
operator|->
name|tail
operator|<<
name|IDT_TBD_SHIFT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patm_sram_read
argument_list|(
name|a
operator|->
name|sc
argument_list|,
name|a
operator|->
name|vcc
operator|->
name|cid
operator|*
literal|8
operator|+
literal|3
argument_list|)
operator|&
name|IDT_TCT_IDLE
condition|)
block|{
comment|/* 		 * if the connection is idle start it. We cannot rely 		 * on a flag set by patm_tx_idle() here, because sometimes 		 * the card seems to place an idle TSI into the TSQ but 		 * forgets to raise an interrupt. 		 */
name|patm_nor_write
argument_list|(
name|a
operator|->
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_START
argument_list|(
name|a
operator|->
name|vcc
operator|->
name|cid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * packet transmitted  */
end_comment

begin_function
name|void
name|patm_tx
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|stamp
parameter_list|,
name|u_int
name|status
parameter_list|)
block|{
name|u_int
name|cid
decl_stmt|,
name|tag
decl_stmt|,
name|last
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|patm_vcc
modifier|*
name|vcc
decl_stmt|;
name|struct
name|patm_scd
modifier|*
name|scd
decl_stmt|;
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
comment|/* get the connection */
name|cid
operator|=
name|PATM_CID
argument_list|(
name|sc
argument_list|,
name|IDT_TBD_VPI
argument_list|(
name|status
argument_list|)
argument_list|,
name|IDT_TBD_VCI
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vcc
operator|=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* closed UBR connection */
return|return;
block|}
name|scd
operator|=
name|vcc
operator|->
name|scd
expr_stmt|;
name|tag
operator|=
name|IDT_TSQE_TAG
argument_list|(
name|stamp
argument_list|)
expr_stmt|;
name|last
operator|=
name|scd
operator|->
name|last_tag
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|last
condition|)
block|{
name|patm_printf
argument_list|(
name|sc
argument_list|,
literal|"same tag %u\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Errata 12 requests us to free all entries up to the one 	 * with the given tag. */
do|do
block|{
comment|/* next tag to try */
name|NEXT_TAG
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|m
operator|=
name|scd
operator|->
name|on_card
index|[
name|last
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%stag=%u"
operator|,
name|dump_scd
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|)
operator|,
name|tag
operator|)
argument_list|)
expr_stmt|;
name|scd
operator|->
name|on_card
index|[
name|last
index|]
operator|=
name|NULL
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|TX
argument_list|,
literal|"ok tag=%x"
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|map
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
expr_stmt|;
name|scd
operator|->
name|space
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|map
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|scd
operator|->
name|num_on_card
operator|--
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vflags
operator|&
name|PATM_VCC_TX_CLOSING
condition|)
block|{
if|if
condition|(
name|scd
operator|->
name|num_on_card
operator|==
literal|0
condition|)
block|{
comment|/* done with this VCC */
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_CBR
condition|)
name|patm_tst_free
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_scd_free
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|)
expr_stmt|;
name|vcc
operator|->
name|scd
operator|=
name|NULL
expr_stmt|;
name|vcc
operator|->
name|vflags
operator|&=
operator|~
name|PATM_VCC_TX_CLOSING
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|flags
operator|&
name|ATMIO_FLAG_ASYNC
condition|)
block|{
name|patm_tx_vcc_closed
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vcc
operator|->
name|vflags
operator|&
name|PATM_VCC_OPEN
operator|)
condition|)
name|patm_vcc_closed
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
block|}
else|else
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|vcc_cv
argument_list|)
expr_stmt|;
return|return;
block|}
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"%u buffers still on card"
argument_list|,
name|scd
operator|->
name|num_on_card
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_ABR
condition|)
block|{
comment|/* insist on speeding up transmission for ABR */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_UIER
argument_list|(
name|vcc
operator|->
name|cid
argument_list|,
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_ULACR
argument_list|(
name|vcc
operator|->
name|cid
argument_list|,
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|last
operator|!=
name|tag
condition|)
do|;
name|scd
operator|->
name|last_tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
operator|==
name|ATMIO_TRAFFIC_ABR
condition|)
block|{
name|u_int
name|acri
decl_stmt|,
name|cps
decl_stmt|;
name|acri
operator|=
operator|(
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
literal|8
operator|*
name|cid
operator|+
literal|2
argument_list|)
operator|>>
name|IDT_TCT_ACRI_SHIFT
operator|)
operator|&
literal|0x3fff
expr_stmt|;
name|cps
operator|=
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
operator|*
literal|32
operator|/
operator|(
operator|(
literal|1
operator|<<
operator|(
name|acri
operator|>>
literal|10
operator|)
operator|)
operator|*
operator|(
name|acri
operator|&
literal|0x3ff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cps
operator|!=
name|vcc
operator|->
name|cps
condition|)
block|{
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"ACRI=%04x CPS=%u"
argument_list|,
name|acri
argument_list|,
name|cps
argument_list|)
expr_stmt|;
name|ATMEV_SEND_ACR_CHANGED
argument_list|(
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|vpi
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|,
name|cps
argument_list|)
expr_stmt|;
name|vcc
operator|->
name|cps
operator|=
name|cps
expr_stmt|;
block|}
block|}
name|patm_launch
argument_list|(
name|sc
argument_list|,
name|scd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * VBR/ABR connection went idle  * Either restart it or set the idle flag.  */
end_comment

begin_function
name|void
name|patm_tx_idle
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cid
parameter_list|)
block|{
name|struct
name|patm_vcc
modifier|*
name|vcc
decl_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"idle %u"
argument_list|,
name|cid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vcc
operator|=
name|sc
operator|->
name|vccs
index|[
name|cid
index|]
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|vcc
operator|->
name|vflags
operator|&
operator|(
name|PATM_VCC_TX_OPEN
operator||
name|PATM_VCC_TX_CLOSING
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|vcc
operator|->
name|scd
operator|!=
name|NULL
operator|&&
operator|(
name|vcc
operator|->
name|scd
operator|->
name|num_on_card
operator|!=
literal|0
operator|||
name|_IF_QLEN
argument_list|(
operator|&
name|vcc
operator|->
name|scd
operator|->
name|q
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If there is any packet outstanding in the SCD re-activate 		 * the channel and kick it. 		 */
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_START
argument_list|(
name|vcc
operator|->
name|cid
argument_list|)
argument_list|)
expr_stmt|;
name|patm_launch
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|scd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert a (24bit) rate to the atm-forum form  * Our rate is never larger than 19 bit.  */
end_comment

begin_function
specifier|static
name|u_int
name|cps2atmf
parameter_list|(
name|u_int
name|cps
parameter_list|)
block|{
name|u_int
name|e
decl_stmt|;
if|if
condition|(
name|cps
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cps
operator|<<=
literal|9
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cps
operator|>
operator|(
literal|1024
operator|-
literal|1
operator|)
condition|)
block|{
name|e
operator|++
expr_stmt|;
name|cps
operator|>>=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
literal|1
operator|<<
literal|14
operator|)
operator||
operator|(
name|e
operator|<<
literal|9
operator|)
operator||
operator|(
name|cps
operator|&
literal|0x1ff
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a binary search on the log2rate table to convert the rate  * to its log form. This assumes that the ATM-Forum form is monotonically  * increasing with the plain cell rate.  */
end_comment

begin_function
specifier|static
name|u_int
name|rate2log
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|rate
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|tbl
decl_stmt|;
name|u_int
name|lower
decl_stmt|,
name|upper
decl_stmt|,
name|mid
decl_stmt|,
name|done
decl_stmt|,
name|val
decl_stmt|,
name|afr
decl_stmt|;
name|afr
operator|=
name|cps2atmf
argument_list|(
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PATM_25M
condition|)
name|tbl
operator|=
name|patm_rtables25
expr_stmt|;
else|else
name|tbl
operator|=
name|patm_rtables155
expr_stmt|;
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
literal|255
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|mid
operator|=
operator|(
name|lower
operator|+
name|upper
operator|)
operator|/
literal|2
expr_stmt|;
name|val
operator|=
name|tbl
index|[
name|mid
index|]
operator|>>
literal|17
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|afr
operator|||
name|upper
operator|==
name|lower
condition|)
break|break;
if|if
condition|(
name|afr
operator|>
name|val
condition|)
name|lower
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|upper
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|>
name|afr
operator|&&
name|mid
operator|>
literal|0
condition|)
name|mid
operator|--
expr_stmt|;
return|return
operator|(
name|mid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the table index for an increase table. The increase table  * must be selected not by the RIF itself, but by PCR/2^RIF. Each table  * represents an additive increase of a cell rate that can be computed  * from the first table entry (the value in this entry will not be clamped  * by the link rate).  */
end_comment

begin_function
specifier|static
name|u_int
name|get_air_table
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|rif
parameter_list|,
name|u_int
name|pcr
parameter_list|)
block|{
specifier|const
name|uint32_t
modifier|*
name|tbl
decl_stmt|;
name|u_int
name|increase
decl_stmt|,
name|base
decl_stmt|,
name|lair0
decl_stmt|,
name|ret
decl_stmt|,
name|t
decl_stmt|,
name|cps
decl_stmt|;
define|#
directive|define
name|GET_ENTRY
parameter_list|(
name|TAB
parameter_list|,
name|IDX
parameter_list|)
value|(0xffff& ((IDX& 1) ?			\ 	(tbl[512 + (IDX / 2) + 128 * (TAB)]>> 16) :			\ 	(tbl[512 + (IDX / 2) + 128 * (TAB)])))
define|#
directive|define
name|MANT_BITS
value|10
define|#
directive|define
name|FRAC_BITS
value|16
define|#
directive|define
name|DIFF_TO_FP
parameter_list|(
name|D
parameter_list|)
value|(((D)& ((1<< MANT_BITS) - 1))<< ((D)>> MANT_BITS))
define|#
directive|define
name|AFR_TO_INT
parameter_list|(
name|A
parameter_list|)
value|((1<< (((A)>> 9)& 0x1f)) * \ 			    (512 + ((A)& 0x1ff)) / 512 * ((A)>> 14))
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PATM_25M
condition|)
name|tbl
operator|=
name|patm_rtables25
expr_stmt|;
else|else
name|tbl
operator|=
name|patm_rtables155
expr_stmt|;
if|if
condition|(
name|rif
operator|>=
name|patm_rtables_ntab
condition|)
name|rif
operator|=
name|patm_rtables_ntab
operator|-
literal|1
expr_stmt|;
name|increase
operator|=
name|pcr
operator|>>
name|rif
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|patm_rtables_ntab
condition|;
name|t
operator|++
control|)
block|{
comment|/* get base rate of this table */
name|base
operator|=
name|GET_ENTRY
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* convert this to fixed point */
name|lair0
operator|=
name|DIFF_TO_FP
argument_list|(
name|base
argument_list|)
operator|>>
name|FRAC_BITS
expr_stmt|;
comment|/* get the CPS from the log2rate table */
name|cps
operator|=
name|AFR_TO_INT
argument_list|(
name|tbl
index|[
name|lair0
index|]
operator|>>
literal|17
argument_list|)
operator|-
literal|10
expr_stmt|;
if|if
condition|(
name|increase
operator|>=
name|cps
condition|)
break|break;
name|ret
operator|=
name|t
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|+
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the TCT  */
end_comment

begin_function
name|void
name|patm_tct_setup
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_scd
modifier|*
name|scd
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|uint32_t
name|tct
index|[
literal|8
index|]
decl_stmt|;
name|u_int
name|sram
decl_stmt|;
name|u_int
name|mbs
decl_stmt|,
name|token
decl_stmt|;
name|u_int
name|tmp
decl_stmt|,
name|crm
decl_stmt|,
name|rdf
decl_stmt|,
name|cdf
decl_stmt|,
name|air
decl_stmt|,
name|mcr
decl_stmt|;
name|bzero
argument_list|(
name|tct
argument_list|,
sizeof|sizeof
argument_list|(
name|tct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
block|{
comment|/* special case for UBR0 */
name|sram
operator|=
literal|0
expr_stmt|;
name|tct
index|[
literal|0
index|]
operator|=
name|IDT_TCT_UBR
operator||
name|scd
operator|->
name|sram
expr_stmt|;
name|tct
index|[
literal|7
index|]
operator|=
name|IDT_TCT_UBR_FLG
expr_stmt|;
block|}
else|else
block|{
name|sram
operator|=
name|vcc
operator|->
name|cid
operator|*
literal|8
expr_stmt|;
switch|switch
condition|(
name|vcc
operator|->
name|vcc
operator|.
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_CBR
case|:
name|patm_tst_alloc
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
name|tct
index|[
literal|0
index|]
operator|=
name|IDT_TCT_CBR
operator||
name|scd
operator|->
name|sram
expr_stmt|;
comment|/* must account for what was really allocated */
break|break;
case|case
name|ATMIO_TRAFFIC_VBR
case|:
comment|/* compute parameters for the TCT */
name|scd
operator|->
name|init_er
operator|=
name|rate2log
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
argument_list|)
expr_stmt|;
name|scd
operator|->
name|lacr
operator|=
name|rate2log
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|scr
argument_list|)
expr_stmt|;
comment|/* get the 16-bit fraction of SCR/PCR 			 * both a 24 bit. Do it the simple way. */
name|token
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|scr
operator|<<
literal|16
argument_list|)
operator|/
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"VBR: init_er=%u lacr=%u "
literal|"token=0x%04x\n"
argument_list|,
name|scd
operator|->
name|init_er
argument_list|,
name|scd
operator|->
name|lacr
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|tct
index|[
literal|0
index|]
operator|=
name|IDT_TCT_VBR
operator||
name|scd
operator|->
name|sram
expr_stmt|;
name|tct
index|[
literal|2
index|]
operator|=
name|IDT_TCT_TSIF
expr_stmt|;
name|tct
index|[
literal|3
index|]
operator|=
name|IDT_TCT_IDLE
operator||
name|IDT_TCT_HALT
expr_stmt|;
name|tct
index|[
literal|4
index|]
operator|=
name|IDT_TCT_MAXIDLE
expr_stmt|;
name|tct
index|[
literal|5
index|]
operator|=
literal|0x01000000
expr_stmt|;
if|if
condition|(
operator|(
name|mbs
operator|=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|mbs
operator|)
operator|>
literal|0xff
condition|)
name|mbs
operator|=
literal|0xff
expr_stmt|;
name|tct
index|[
literal|6
index|]
operator|=
operator|(
name|mbs
operator|<<
literal|16
operator|)
operator||
name|token
expr_stmt|;
name|sc
operator|->
name|bwrem
operator|-=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|scr
expr_stmt|;
break|break;
case|case
name|ATMIO_TRAFFIC_ABR
case|:
name|scd
operator|->
name|init_er
operator|=
name|rate2log
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
argument_list|)
expr_stmt|;
name|scd
operator|->
name|lacr
operator|=
name|rate2log
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|icr
argument_list|)
expr_stmt|;
name|mcr
operator|=
name|rate2log
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|mcr
argument_list|)
expr_stmt|;
comment|/* compute CRM */
name|tmp
operator|=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|tbe
operator|/
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|nrm
expr_stmt|;
if|if
condition|(
name|tmp
operator|*
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|nrm
operator|<
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|tbe
condition|)
name|tmp
operator|++
expr_stmt|;
for|for
control|(
name|crm
operator|=
literal|1
init|;
name|tmp
operator|>
operator|(
literal|1
operator|<<
name|crm
operator|)
condition|;
name|crm
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|crm
operator|>
literal|0x7
condition|)
name|crm
operator|=
literal|7
expr_stmt|;
name|air
operator|=
name|get_air_table
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|rif
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rdf
operator|=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|rdf
operator|)
operator|>=
name|patm_rtables_ntab
condition|)
name|rdf
operator|=
name|patm_rtables_ntab
operator|-
literal|1
expr_stmt|;
name|rdf
operator|+=
name|patm_rtables_ntab
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|cdf
operator|=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|cdf
operator|)
operator|>=
name|patm_rtables_ntab
condition|)
name|cdf
operator|=
name|patm_rtables_ntab
operator|-
literal|1
expr_stmt|;
name|cdf
operator|+=
name|patm_rtables_ntab
operator|+
literal|4
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"ABR: init_er=%u lacr=%u mcr=%u "
literal|"crm=%u air=%u rdf=%u cdf=%u\n"
argument_list|,
name|scd
operator|->
name|init_er
argument_list|,
name|scd
operator|->
name|lacr
argument_list|,
name|mcr
argument_list|,
name|crm
argument_list|,
name|air
argument_list|,
name|rdf
argument_list|,
name|cdf
argument_list|)
expr_stmt|;
name|tct
index|[
literal|0
index|]
operator|=
name|IDT_TCT_ABR
operator||
name|scd
operator|->
name|sram
expr_stmt|;
name|tct
index|[
literal|1
index|]
operator|=
name|crm
operator|<<
name|IDT_TCT_CRM_SHIFT
expr_stmt|;
name|tct
index|[
literal|3
index|]
operator|=
name|IDT_TCT_HALT
operator||
name|IDT_TCT_IDLE
operator||
operator|(
literal|4
operator|<<
name|IDT_TCT_NAGE_SHIFT
operator|)
expr_stmt|;
name|tct
index|[
literal|4
index|]
operator|=
name|mcr
operator|<<
name|IDT_TCT_LMCR_SHIFT
expr_stmt|;
name|tct
index|[
literal|5
index|]
operator|=
operator|(
name|cdf
operator|<<
name|IDT_TCT_CDF_SHIFT
operator|)
operator||
operator|(
name|rdf
operator|<<
name|IDT_TCT_RDF_SHIFT
operator|)
operator||
operator|(
name|air
operator|<<
name|IDT_TCT_AIR_SHIFT
operator|)
expr_stmt|;
name|sc
operator|->
name|bwrem
operator|-=
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|mcr
expr_stmt|;
break|break;
block|}
block|}
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|0
argument_list|,
name|tct
index|[
literal|0
index|]
argument_list|,
name|tct
index|[
literal|1
index|]
argument_list|,
name|tct
index|[
literal|2
index|]
argument_list|,
name|tct
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|4
argument_list|,
name|tct
index|[
literal|4
index|]
argument_list|,
name|tct
index|[
literal|5
index|]
argument_list|,
name|tct
index|[
literal|6
index|]
argument_list|,
name|tct
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"TCT[%u]: %08x %08x %08x %08x  %08x %08x %08x %08x"
argument_list|,
name|sram
operator|/
literal|8
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|0
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|1
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|2
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|3
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|4
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|5
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|6
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a channel  */
end_comment

begin_function
specifier|static
name|void
name|patm_tct_start
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_UIER
argument_list|(
name|vcc
operator|->
name|cid
argument_list|,
name|vcc
operator|->
name|scd
operator|->
name|init_er
argument_list|)
argument_list|)
expr_stmt|;
name|patm_nor_write
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_TCMDQ
argument_list|,
name|IDT_TCMDQ_SLACR
argument_list|(
name|vcc
operator|->
name|cid
argument_list|,
name|vcc
operator|->
name|scd
operator|->
name|lacr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|patm_tct_print
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|cid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PATM_DEBUG
name|u_int
name|sram
init|=
name|cid
operator|*
literal|8
decl_stmt|;
endif|#
directive|endif
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"TCT[%u]: %08x %08x %08x %08x  %08x %08x %08x %08x"
argument_list|,
name|sram
operator|/
literal|8
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|0
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|1
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|2
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|3
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|4
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|5
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|6
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|sram
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup the SCD  */
end_comment

begin_function
name|void
name|patm_scd_setup
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_scd
modifier|*
name|scd
parameter_list|)
block|{
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|0
argument_list|,
name|scd
operator|->
name|phy
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_sram_write4
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|VCC
argument_list|,
literal|"SCD(%x): %08x %08x %08x %08x %08x %08x %08x %08x"
argument_list|,
name|scd
operator|->
name|sram
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|0
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|1
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|2
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|3
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|4
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|5
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|6
argument_list|)
argument_list|,
name|patm_sram_read
argument_list|(
name|sc
argument_list|,
name|scd
operator|->
name|sram
operator|+
literal|7
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the TX map table if possible  */
end_comment

begin_function
specifier|static
name|void
name|patm_txmaps_grow
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_nmaps
operator|>=
name|sc
operator|->
name|tx_maxmaps
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|tx_nmaps
init|;
name|i
operator|<
name|sc
operator|->
name|tx_nmaps
operator|+
name|PATM_CFG_TXMAPS_STEP
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|=
name|uma_zalloc
argument_list|(
name|sc
operator|->
name|tx_mapzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|map
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|uma_zfree
argument_list|(
name|sc
operator|->
name|tx_mapzone
argument_list|,
name|map
argument_list|)
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|map
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tx_nmaps
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a transmission map  */
end_comment

begin_function
specifier|static
name|struct
name|patm_txmap
modifier|*
name|patm_txmap_get
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|patm_txmap
modifier|*
name|map
decl_stmt|;
if|if
condition|(
operator|(
name|map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|patm_txmaps_grow
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|tx_maps_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|map
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look whether we are in the process of updating the TST on the chip.  * If we are set the flag that we need another update.  * If we are not start the update.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|patm_tst_start
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|tst_state
operator|&
name|TST_PENDING
operator|)
condition|)
block|{
name|sc
operator|->
name|tst_state
operator||=
name|TST_PENDING
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|tst_state
operator|&
name|TST_WAIT
operator|)
condition|)
block|{
comment|/* timer not running */
name|patm_tst_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate TST entries to a CBR connection  */
end_comment

begin_function
specifier|static
name|void
name|patm_tst_alloc
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|u_int
name|slots
decl_stmt|;
name|u_int
name|qptr
decl_stmt|,
name|pptr
decl_stmt|;
name|u_int
name|qmax
decl_stmt|,
name|pmax
decl_stmt|;
name|u_int
name|pspc
decl_stmt|,
name|last
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
comment|/* compute the number of slots we need, make sure to get at least 	 * the specified PCR */
name|slots
operator|=
name|cbr2slots
argument_list|(
name|sc
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
name|vcc
operator|->
name|scd
operator|->
name|slots
operator|=
name|slots
expr_stmt|;
name|sc
operator|->
name|bwrem
operator|-=
name|slots2cr
argument_list|(
name|sc
argument_list|,
name|slots
argument_list|)
expr_stmt|;
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|TST
argument_list|,
literal|"tst_alloc: cbr=%u link=%u tst=%u slots=%u"
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|tparam
operator|.
name|pcr
argument_list|,
name|IFP2IFATM
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|->
name|mib
operator|.
name|pcr
argument_list|,
name|sc
operator|->
name|mmap
operator|->
name|tst_size
argument_list|,
name|slots
argument_list|)
expr_stmt|;
name|qmax
operator|=
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
expr_stmt|;
name|pmax
operator|=
name|qmax
operator|<<
literal|8
expr_stmt|;
name|pspc
operator|=
name|pmax
operator|/
name|slots
expr_stmt|;
name|pptr
operator|=
name|pspc
operator|>>
literal|1
expr_stmt|;
comment|/* starting point */
name|qptr
operator|=
name|pptr
operator|>>
literal|8
expr_stmt|;
name|last
operator|=
name|qptr
expr_stmt|;
while|while
condition|(
name|slots
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|qptr
operator|>=
name|qmax
condition|)
name|qptr
operator|-=
name|qmax
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tst_soft
index|[
name|qptr
index|]
operator|!=
name|IDT_TST_VBR
condition|)
block|{
comment|/* used - try next */
name|qptr
operator|++
expr_stmt|;
continue|continue;
block|}
name|patm_debug
argument_list|(
name|sc
argument_list|,
name|TST
argument_list|,
literal|"slot[%u] = %u.%u diff=%d"
argument_list|,
name|qptr
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|vpi
argument_list|,
name|vcc
operator|->
name|vcc
operator|.
name|vci
argument_list|,
operator|(
name|int
operator|)
name|qptr
operator|-
operator|(
name|int
operator|)
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|qptr
expr_stmt|;
name|sc
operator|->
name|tst_soft
index|[
name|qptr
index|]
operator|=
name|IDT_TST_CBR
operator||
name|vcc
operator|->
name|cid
operator||
name|TST_BOTH
expr_stmt|;
name|sc
operator|->
name|tst_free
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|pptr
operator|+=
name|pspc
operator|)
operator|>=
name|pmax
condition|)
name|pptr
operator|-=
name|pmax
expr_stmt|;
name|qptr
operator|=
name|pptr
operator|>>
literal|8
expr_stmt|;
name|slots
operator|--
expr_stmt|;
block|}
name|patm_tst_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a CBR connection's TST entries  */
end_comment

begin_function
specifier|static
name|void
name|patm_tst_free
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_vcc
modifier|*
name|vcc
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tst_soft
index|[
name|i
index|]
operator|&
name|IDT_TST_MASK
operator|)
operator|==
name|vcc
operator|->
name|cid
condition|)
block|{
name|sc
operator|->
name|tst_soft
index|[
name|i
index|]
operator|=
name|IDT_TST_VBR
operator||
name|TST_BOTH
expr_stmt|;
name|sc
operator|->
name|tst_free
operator|++
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|bwrem
operator|+=
name|slots2cr
argument_list|(
name|sc
argument_list|,
name|vcc
operator|->
name|scd
operator|->
name|slots
argument_list|)
expr_stmt|;
name|patm_tst_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the soft TST into the idle incore TST and start the wait timer.  * We assume that we hold the tst lock.  */
end_comment

begin_function
specifier|static
name|void
name|patm_tst_update
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int
name|flag
decl_stmt|;
comment|/* flag to clear from soft TST */
name|u_int
name|idle
decl_stmt|;
comment|/* the idle TST */
name|u_int
name|act
decl_stmt|;
comment|/* the active TST */
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tst_state
operator|&
name|TST_ACT1
condition|)
block|{
name|act
operator|=
literal|1
expr_stmt|;
name|idle
operator|=
literal|0
expr_stmt|;
name|flag
operator|=
name|TST_CH0
expr_stmt|;
block|}
else|else
block|{
name|act
operator|=
literal|0
expr_stmt|;
name|idle
operator|=
literal|1
expr_stmt|;
name|flag
operator|=
name|TST_CH1
expr_stmt|;
block|}
comment|/* update the idle one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|mmap
operator|->
name|tst_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|tst_soft
index|[
name|i
index|]
operator|&
name|flag
condition|)
block|{
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tst_base
index|[
name|idle
index|]
operator|+
name|i
argument_list|,
name|sc
operator|->
name|tst_soft
index|[
name|i
index|]
operator|&
operator|~
name|TST_BOTH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tst_soft
index|[
name|i
index|]
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
comment|/* the used one jump to the idle one */
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tst_jump
index|[
name|act
index|]
argument_list|,
name|IDT_TST_BR
operator||
operator|(
name|sc
operator|->
name|tst_base
index|[
name|idle
index|]
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* wait for the chip to jump */
name|sc
operator|->
name|tst_state
operator|&=
operator|~
name|TST_PENDING
expr_stmt|;
name|sc
operator|->
name|tst_state
operator||=
name|TST_WAIT
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tst_callout
argument_list|,
literal|1
argument_list|,
name|patm_tst_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timer for TST updates  */
end_comment

begin_function
specifier|static
name|void
name|patm_tst_timer
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|patm_softc
modifier|*
name|sc
init|=
name|p
decl_stmt|;
name|u_int
name|act
decl_stmt|;
comment|/* active TST */
name|u_int
name|now
decl_stmt|;
comment|/* current place in TST */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tst_state
operator|&
name|TST_WAIT
condition|)
block|{
comment|/* ignore the PENDING state while we are waiting for 		 * the chip to switch tables. Once the switch is done, 		 * we will again lock at PENDING */
name|act
operator|=
operator|(
name|sc
operator|->
name|tst_state
operator|&
name|TST_ACT1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|now
operator|=
name|patm_nor_read
argument_list|(
name|sc
argument_list|,
name|IDT_NOR_NOW
argument_list|)
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|now
operator|>=
name|sc
operator|->
name|tst_base
index|[
name|act
index|]
operator|&&
name|now
operator|<=
name|sc
operator|->
name|tst_jump
index|[
name|act
index|]
condition|)
block|{
comment|/* not yet */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tst_callout
argument_list|,
literal|1
argument_list|,
name|patm_tst_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sc
operator|->
name|tst_state
operator|&=
operator|~
name|TST_WAIT
expr_stmt|;
comment|/* change back jump */
name|patm_sram_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tst_jump
index|[
name|act
index|]
argument_list|,
name|IDT_TST_BR
operator||
operator|(
name|sc
operator|->
name|tst_base
index|[
name|act
index|]
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/* switch */
name|sc
operator|->
name|tst_state
operator|^=
name|TST_ACT1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|tst_state
operator|&
name|TST_PENDING
condition|)
comment|/* we got another update request while the timer was running. */
name|patm_tst_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|tst_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dump_scd
parameter_list|(
name|struct
name|patm_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|patm_scd
modifier|*
name|scd
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IDT_TSQE_TAG_SPACE
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"on_card[%u] = %p\n"
argument_list|,
name|i
argument_list|,
name|scd
operator|->
name|on_card
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"space=%u tag=%u num_on_card=%u last_tag=%u\n"
argument_list|,
name|scd
operator|->
name|space
argument_list|,
name|scd
operator|->
name|tag
argument_list|,
name|scd
operator|->
name|num_on_card
argument_list|,
name|scd
operator|->
name|last_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

end_unit

