begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: i82365.c,v 1.25 1999/10/15 06:07:27 haya Exp $	*/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997 Marc Horowitz.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Marc Horowitz.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* We shouldn't need to include the following, but sadly we do for now */
end_comment

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<dev/pccard/pccardreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pcic/i82365reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pcic/i82365var.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_define
define|#
directive|define
name|PCICDEBUG
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PCICDEBUG
end_ifdef

begin_decl_stmt
name|int
name|pcic_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|arg
parameter_list|)
value|if (pcic_debug) printf arg; else ;
end_define

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|arg
parameter_list|)
value|if (pcic_debug) device_printf arg; else ;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|arg
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VERBOSE
parameter_list|(
name|arg
parameter_list|)
value|if (bootverbose) printf arg; else ;
end_define

begin_define
define|#
directive|define
name|DETACH_FORCE
value|0x1
end_define

begin_define
define|#
directive|define
name|PCIC_VENDOR_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|PCIC_VENDOR_I82365SLR0
value|1
end_define

begin_define
define|#
directive|define
name|PCIC_VENDOR_I82365SLR1
value|2
end_define

begin_define
define|#
directive|define
name|PCIC_VENDOR_CIRRUS_PD6710
value|3
end_define

begin_define
define|#
directive|define
name|PCIC_VENDOR_CIRRUS_PD672X
value|4
end_define

begin_comment
comment|/*  * Individual drivers will allocate their own memory and io regions. Memory  * regions must be a multiple of 4k, aligned on a 4k boundary.  */
end_comment

begin_define
define|#
directive|define
name|PCIC_MEM_ALIGN
value|PCIC_MEM_PAGESIZE
end_define

begin_function_decl
specifier|static
name|void
name|pcic_init_socket
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_intr_socket
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcic_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_attach_card
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_detach_card
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_chip_do_mem_map
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_chip_do_io_map
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pcic_create_event_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pcic_event_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pcic_queue_event
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_wait_ready
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|st_pcic_read
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st_pcic_write
parameter_list|(
name|struct
name|pcic_handle
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX Should really be dynamic XXX */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pcic_handle
modifier|*
name|handles
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcic_handle
modifier|*
modifier|*
name|lasthandle
init|=
name|handles
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|pcic_handle
modifier|*
name|pcic_get_handle
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|==
name|child
condition|)
return|return
name|NULL
return|;
while|while
condition|(
name|child
operator|&&
name|device_get_parent
argument_list|(
name|child
argument_list|)
operator|!=
name|dev
condition|)
name|child
operator|=
name|device_get_parent
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
expr|struct
name|pcic_handle
operator|*
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_ident_ok
parameter_list|(
name|int
name|ident
parameter_list|)
block|{
comment|/* this is very empirical and heuristic */
if|if
condition|(
operator|(
name|ident
operator|==
literal|0
operator|)
operator|||
operator|(
name|ident
operator|==
literal|0xff
operator|)
operator|||
operator|(
name|ident
operator|&
name|PCIC_IDENT_ZERO
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|ident
operator|&
name|PCIC_IDENT_IFTYPE_MASK
operator|)
operator|!=
name|PCIC_IDENT_IFTYPE_MEM_AND_IO
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"pcic: does not support memory and I/O cards, "
literal|"ignored (ident=%0x)\n"
argument_list|,
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_vendor
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
comment|/* 	 * the chip_id of the cirrus toggles between 11 and 00 after a write. 	 * weird. 	 */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_CIRRUS_CHIP_INFO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|PCIC_CIRRUS_CHIP_INFO_CHIP_ID
operator|)
operator|==
name|PCIC_CIRRUS_CHIP_INFO_CHIP_ID
condition|)
block|{
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|PCIC_CIRRUS_CHIP_INFO_CHIP_ID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|&
name|PCIC_CIRRUS_CHIP_INFO_SLOTS
condition|)
return|return
operator|(
name|PCIC_VENDOR_CIRRUS_PD672X
operator|)
return|;
else|else
return|return
operator|(
name|PCIC_VENDOR_CIRRUS_PD6710
operator|)
return|;
block|}
block|}
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_IDENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|PCIC_IDENT_REV_MASK
operator|)
operator|==
name|PCIC_IDENT_REV_I82365SLR0
condition|)
return|return
operator|(
name|PCIC_VENDOR_I82365SLR0
operator|)
return|;
else|else
return|return
operator|(
name|PCIC_VENDOR_I82365SLR1
operator|)
return|;
return|return
operator|(
name|PCIC_VENDOR_UNKNOWN
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|pcic_vendor_to_string
parameter_list|(
name|int
name|vendor
parameter_list|)
block|{
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
name|PCIC_VENDOR_I82365SLR0
case|:
return|return
operator|(
literal|"Intel 82365SL Revision 0"
operator|)
return|;
case|case
name|PCIC_VENDOR_I82365SLR1
case|:
return|return
operator|(
literal|"Intel 82365SL Revision 1"
operator|)
return|;
case|case
name|PCIC_VENDOR_CIRRUS_PD6710
case|:
return|return
operator|(
literal|"Cirrus PD6710"
operator|)
return|;
case|case
name|PCIC_VENDOR_CIRRUS_PD672X
case|:
return|return
operator|(
literal|"Cirrus PD672X"
operator|)
return|;
block|}
return|return
operator|(
literal|"Unknown controller"
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcic_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pcic_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|->
name|port_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|PCIC_IOSIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|port_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ioport\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
block|{
name|sc
operator|->
name|irq
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_MISC
argument_list|,
name|pcic_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot setup intr\n"
argument_list|)
expr_stmt|;
name|pcic_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Polling not supported\n"
argument_list|)
expr_stmt|;
comment|/* XXX Do polling */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* XXX This might not be needed in future, get it directly from 	 * XXX parent */
name|sc
operator|->
name|mem_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mem_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
operator|<<
literal|13
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate mem\n"
argument_list|)
expr_stmt|;
name|pcic_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|iot
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ioh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
empty_stmt|;
name|sc
operator|->
name|memt
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|memh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcic_deactivate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mem_rid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|pcic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pcic_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|pcic_handle
modifier|*
name|h
decl_stmt|;
name|int
name|vendor
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|,
name|reg
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* Activate our resources */
if|if
condition|(
operator|(
name|error
operator|=
name|pcic_activate
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcic_attach (active) returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* now check for each controller/socket */
comment|/* 	 * this could be done with a loop, but it would violate the 	 * abstraction...  --- unknown 	 * so? I don't see the abstraction... --imp 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|VERBOSE
argument_list|(
operator|(
literal|"pcic ident regs:"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|sock
operator|=
name|C0SA
expr_stmt|;
comment|/* initialise pcic_read and pcic_write functions */
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|ph_read
operator|=
name|st_pcic_read
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|ph_write
operator|=
name|st_pcic_write
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|ph_bus_t
operator|=
name|sc
operator|->
name|iot
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|ph_bus_h
operator|=
name|sc
operator|->
name|ioh
expr_stmt|;
if|if
condition|(
name|pcic_ident_ok
argument_list|(
name|reg
operator|=
name|pcic_read
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|0
index|]
argument_list|,
name|PCIC_IDENT
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|flags
operator|=
name|PCIC_FLAG_SOCKETP
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|laststate
operator|=
name|PCIC_LASTSTATE_EMPTY
expr_stmt|;
name|VERBOSE
argument_list|(
operator|(
literal|" 0x%02x"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|sock
operator|=
name|C0SB
expr_stmt|;
comment|/* initialise pcic_read and pcic_write functions */
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|ph_read
operator|=
name|st_pcic_read
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|ph_write
operator|=
name|st_pcic_write
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|ph_bus_t
operator|=
name|sc
operator|->
name|iot
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|ph_bus_h
operator|=
name|sc
operator|->
name|ioh
expr_stmt|;
if|if
condition|(
name|pcic_ident_ok
argument_list|(
name|reg
operator|=
name|pcic_read
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|1
index|]
argument_list|,
name|PCIC_IDENT
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|flags
operator|=
name|PCIC_FLAG_SOCKETP
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|laststate
operator|=
name|PCIC_LASTSTATE_EMPTY
expr_stmt|;
name|VERBOSE
argument_list|(
operator|(
literal|" 0x%02x"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The CL-PD6729 has only one controller and always returns 0 	 * if you try to read from the second one. Maybe pcic_ident_ok 	 * shouldn't accept 0? 	 */
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|sock
operator|=
name|C1SA
expr_stmt|;
comment|/* initialise pcic_read and pcic_write functions */
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|ph_read
operator|=
name|st_pcic_read
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|ph_write
operator|=
name|st_pcic_write
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|ph_bus_t
operator|=
name|sc
operator|->
name|iot
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|ph_bus_h
operator|=
name|sc
operator|->
name|ioh
expr_stmt|;
if|if
condition|(
name|pcic_vendor
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|0
index|]
argument_list|)
operator|!=
name|PCIC_VENDOR_CIRRUS_PD672X
operator|||
name|pcic_read
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|2
index|]
argument_list|,
name|PCIC_IDENT
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pcic_ident_ok
argument_list|(
name|reg
operator|=
name|pcic_read
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|2
index|]
argument_list|,
name|PCIC_IDENT
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|=
name|PCIC_FLAG_SOCKETP
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|laststate
operator|=
name|PCIC_LASTSTATE_EMPTY
expr_stmt|;
name|VERBOSE
argument_list|(
operator|(
literal|" 0x%02x"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|sock
operator|=
name|C1SB
expr_stmt|;
comment|/* initialise pcic_read and pcic_write functions */
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|ph_read
operator|=
name|st_pcic_read
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|ph_write
operator|=
name|st_pcic_write
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|ph_bus_t
operator|=
name|sc
operator|->
name|iot
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|ph_bus_h
operator|=
name|sc
operator|->
name|ioh
expr_stmt|;
if|if
condition|(
name|pcic_ident_ok
argument_list|(
name|reg
operator|=
name|pcic_read
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|3
index|]
argument_list|,
name|PCIC_IDENT
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|flags
operator|=
name|PCIC_FLAG_SOCKETP
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|laststate
operator|=
name|PCIC_LASTSTATE_EMPTY
expr_stmt|;
name|VERBOSE
argument_list|(
operator|(
literal|" 0x%02x\n"
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pcic_attach: attach found no sockets"
argument_list|)
expr_stmt|;
comment|/* establish the interrupt */
comment|/* XXX block interrupts? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCIC_NSLOTS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * this should work, but w/o it, setting tty flags hangs at 		 * boot time. 		 */
if|if
condition|(
name|sc
operator|->
name|handle
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
name|i
index|]
operator|.
name|events
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
name|i
index|]
argument_list|,
name|PCIC_CSC_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_read
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
name|i
index|]
argument_list|,
name|PCIC_CSC
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
operator|||
operator|(
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
condition|)
block|{
name|vendor
operator|=
name|pcic_vendor
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"controller 0 (%s) has "
argument_list|,
name|pcic_vendor_to_string
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
condition|)
name|printf
argument_list|(
literal|"sockets A and B\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|printf
argument_list|(
literal|"socket A only\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"socket B only\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|sc
operator|->
name|handle
index|[
literal|0
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|sc
operator|->
name|handle
index|[
literal|1
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
operator|||
operator|(
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
condition|)
block|{
name|vendor
operator|=
name|pcic_vendor
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"controller 1 (%s) has "
argument_list|,
name|pcic_vendor_to_string
argument_list|(
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
operator|&&
operator|(
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
condition|)
name|printf
argument_list|(
literal|"sockets A and B\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|printf
argument_list|(
literal|"socket A only\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"socket B only\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|sc
operator|->
name|handle
index|[
literal|2
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|sc
operator|->
name|handle
index|[
literal|3
index|]
operator|.
name|vendor
operator|=
name|vendor
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCIC_NSLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|handle
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|h
operator|=
operator|&
name|sc
operator|->
name|handle
index|[
name|i
index|]
expr_stmt|;
comment|/* initialize the rest of the handle */
name|h
operator|->
name|shutdown
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|memalloc
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|ioalloc
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|ih_irq
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|h
operator|->
name|dev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pccard"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|h
operator|->
name|dev
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|pcic_init_socket
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Probe and attach any children as were configured above. 	 */
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|pcic_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|pcic_create_event_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|cs
decl_stmt|;
switch|switch
condition|(
name|h
operator|->
name|sock
condition|)
block|{
case|case
name|C0SA
case|:
name|cs
operator|=
literal|"0,0"
expr_stmt|;
break|break;
case|case
name|C0SB
case|:
name|cs
operator|=
literal|"0,1"
expr_stmt|;
break|break;
case|case
name|C1SA
case|:
name|cs
operator|=
literal|"1,0"
expr_stmt|;
break|break;
case|case
name|C1SB
case|:
name|cs
operator|=
literal|"1,1"
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"pcic_create_event_thread: unknown pcic socket"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kthread_create
argument_list|(
name|pcic_event_thread
argument_list|,
name|h
argument_list|,
operator|&
name|h
operator|->
name|event_thread
argument_list|,
literal|"%s,%s"
argument_list|,
name|device_get_name
argument_list|(
name|h
operator|->
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|cs
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|h
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"cannot create event thread for sock 0x%02x\n"
argument_list|,
name|h
operator|->
name|sock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"pcic_create_event_thread"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pcic_event_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|arg
decl_stmt|;
name|struct
name|pcic_event
modifier|*
name|pe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|h
operator|->
name|sc
decl_stmt|;
while|while
condition|(
name|h
operator|->
name|shutdown
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|PWAIT
argument_list|,
literal|"pcicev"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* sleep .25s to be enqueued chatterling interrupts */
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|pcic_event_thread
argument_list|,
name|PWAIT
argument_list|,
literal|"pcicss"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|STAILQ_REMOVE_HEAD_UNTIL
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|pe
argument_list|,
name|pe_q
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pe
operator|->
name|pe_type
condition|)
block|{
case|case
name|PCIC_EVENT_INSERTION
case|:
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|pcic_event
modifier|*
name|pe1
decl_stmt|,
modifier|*
name|pe2
decl_stmt|;
if|if
condition|(
operator|(
name|pe1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pe1
operator|->
name|pe_type
operator|!=
name|PCIC_EVENT_REMOVAL
condition|)
break|break;
if|if
condition|(
operator|(
name|pe2
operator|=
name|STAILQ_NEXT
argument_list|(
name|pe1
argument_list|,
name|pe_q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pe2
operator|->
name|pe_type
operator|==
name|PCIC_EVENT_INSERTION
condition|)
block|{
name|STAILQ_REMOVE_HEAD_UNTIL
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|pe1
argument_list|,
name|pe_q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pe1
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD_UNTIL
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|pe2
argument_list|,
name|pe_q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pe2
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"insertion event\n"
operator|)
argument_list|)
expr_stmt|;
name|pcic_attach_card
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCIC_EVENT_REMOVAL
case|:
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|pcic_event
modifier|*
name|pe1
decl_stmt|,
modifier|*
name|pe2
decl_stmt|;
if|if
condition|(
operator|(
name|pe1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pe1
operator|->
name|pe_type
operator|!=
name|PCIC_EVENT_INSERTION
condition|)
break|break;
if|if
condition|(
operator|(
name|pe2
operator|=
name|STAILQ_NEXT
argument_list|(
name|pe1
argument_list|,
name|pe_q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pe2
operator|->
name|pe_type
operator|==
name|PCIC_EVENT_REMOVAL
condition|)
block|{
name|STAILQ_REMOVE_HEAD_UNTIL
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|pe1
argument_list|,
name|pe_q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pe1
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD_UNTIL
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|pe2
argument_list|,
name|pe_q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pe2
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"removal event\n"
operator|)
argument_list|)
expr_stmt|;
name|pcic_detach_card
argument_list|(
name|h
argument_list|,
name|DETACH_FORCE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"pcic_event_thread: unknown event %d"
argument_list|,
name|pe
operator|->
name|pe_type
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pe
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|event_thread
operator|=
name|NULL
expr_stmt|;
comment|/* In case parent is waiting for us to exit. */
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcic_init_socket
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|h
operator|->
name|sc
decl_stmt|;
comment|/* 	 * queue creation of a kernel thread to handle insert/removal events. 	 */
operator|*
name|lasthandle
operator|++
operator|=
name|h
expr_stmt|;
comment|/* set up the card to interrupt on card detect */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_CSC_INTR
argument_list|,
operator|(
name|sc
operator|->
name|irq
operator|<<
name|PCIC_CSC_INTR_IRQ_SHIFT
operator|)
operator||
name|PCIC_CSC_INTR_CD_ENABLE
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_CSC
argument_list|)
expr_stmt|;
comment|/* unsleep the cirrus controller */
if|if
condition|(
operator|(
name|h
operator|->
name|vendor
operator|==
name|PCIC_VENDOR_CIRRUS_PD6710
operator|)
operator|||
operator|(
name|h
operator|->
name|vendor
operator|==
name|PCIC_VENDOR_CIRRUS_PD672X
operator|)
condition|)
block|{
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_CIRRUS_MISC_CTL_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|PCIC_CIRRUS_MISC_CTL_2_SUSPEND
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"socket %02x was suspended\n"
operator|,
name|h
operator|->
name|sock
operator|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PCIC_CIRRUS_MISC_CTL_2_SUSPEND
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_CIRRUS_MISC_CTL_2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
name|h
operator|->
name|laststate
operator|=
name|PCIC_LASTSTATE_EMPTY
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX */
comment|/*	Should do this later */
comment|/* maybe as part of interrupt routing verification */
block|if ((reg& PCIC_IF_STATUS_CARDDETECT_MASK) == 	    PCIC_IF_STATUS_CARDDETECT_PRESENT) { 		pcic_attach_card(h); 		h->laststate = PCIC_LASTSTATE_PRESENT; 	} else { 		h->laststate = PCIC_LASTSTATE_EMPTY; 	}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"intr\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCIC_NSLOTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|handle
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|PCIC_FLAG_SOCKETP
condition|)
name|pcic_intr_socket
argument_list|(
operator|&
name|sc
operator|->
name|handle
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_intr_socket
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|)
block|{
name|int
name|cscreg
decl_stmt|;
name|cscreg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_CSC
argument_list|)
expr_stmt|;
name|cscreg
operator|&=
operator|(
name|PCIC_CSC_GPI
operator||
name|PCIC_CSC_CD
operator||
name|PCIC_CSC_READY
operator||
name|PCIC_CSC_BATTWARN
operator||
name|PCIC_CSC_BATTDEAD
operator|)
expr_stmt|;
if|if
condition|(
name|cscreg
operator|&
name|PCIC_CSC_GPI
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"%02x GPI\n"
operator|,
name|h
operator|->
name|sock
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cscreg
operator|&
name|PCIC_CSC_CD
condition|)
block|{
name|int
name|statreg
decl_stmt|;
name|statreg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"%02x CD %x\n"
operator|,
name|h
operator|->
name|sock
operator|,
name|statreg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|statreg
operator|&
name|PCIC_IF_STATUS_CARDDETECT_MASK
operator|)
operator|==
name|PCIC_IF_STATUS_CARDDETECT_PRESENT
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|laststate
operator|!=
name|PCIC_LASTSTATE_PRESENT
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"enqueing INSERTION event\n"
operator|)
argument_list|)
expr_stmt|;
name|pcic_queue_event
argument_list|(
name|h
argument_list|,
name|PCIC_EVENT_INSERTION
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|laststate
operator|=
name|PCIC_LASTSTATE_PRESENT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|laststate
operator|==
name|PCIC_LASTSTATE_PRESENT
condition|)
block|{
comment|/* Deactivate the card now. */
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"detaching card\n"
operator|)
argument_list|)
expr_stmt|;
name|pcic_detach_card
argument_list|(
name|h
argument_list|,
name|DETACH_FORCE
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"enqueing REMOVAL event\n"
operator|)
argument_list|)
expr_stmt|;
name|pcic_queue_event
argument_list|(
name|h
argument_list|,
name|PCIC_EVENT_REMOVAL
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|laststate
operator|=
operator|(
operator|(
name|statreg
operator|&
name|PCIC_IF_STATUS_CARDDETECT_MASK
operator|)
operator|==
literal|0
operator|)
condition|?
name|PCIC_LASTSTATE_EMPTY
else|:
name|PCIC_LASTSTATE_HALF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cscreg
operator|&
name|PCIC_CSC_READY
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"%02x READY\n"
operator|,
name|h
operator|->
name|sock
operator|)
argument_list|)
expr_stmt|;
comment|/* shouldn't happen */
block|}
if|if
condition|(
name|cscreg
operator|&
name|PCIC_CSC_BATTWARN
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"%02x BATTWARN\n"
operator|,
name|h
operator|->
name|sock
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cscreg
operator|&
name|PCIC_CSC_BATTDEAD
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"%02x BATTDEAD\n"
operator|,
name|h
operator|->
name|sock
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pcic_queue_event
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|pcic_event
modifier|*
name|pe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|pe
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pe
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pe
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pcic_queue_event: can't allocate event"
argument_list|)
expr_stmt|;
name|pe
operator|->
name|pe_type
operator|=
name|event
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|,
name|pe
argument_list|,
name|pe_q
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|h
operator|->
name|events
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_attach_card
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_attach_card h %p h->dev %p %s %s\n"
operator|,
name|h
operator|,
name|h
operator|->
name|dev
operator|,
name|device_get_name
argument_list|(
name|h
operator|->
name|dev
argument_list|)
operator|,
name|device_get_name
argument_list|(
name|device_get_parent
argument_list|(
name|h
operator|->
name|dev
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|h
operator|->
name|flags
operator|&
name|PCIC_FLAG_CARDP
operator|)
condition|)
block|{
comment|/* call the MI attach function */
name|CARD_ATTACH_CARD
argument_list|(
name|h
operator|->
name|dev
argument_list|)
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|PCIC_FLAG_CARDP
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_attach_card: already attached"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_detach_card
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|h
operator|->
name|flags
operator|&
name|PCIC_FLAG_CARDP
condition|)
block|{
name|h
operator|->
name|flags
operator|&=
operator|~
name|PCIC_FLAG_CARDP
expr_stmt|;
comment|/* call the MI detach function */
name|CARD_DETACH_CARD
argument_list|(
name|h
operator|->
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_detach_card: already detached"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pcic_chip_mem_alloc
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|pccard_mem_handle
modifier|*
name|pcmhp
parameter_list|)
block|{
name|bus_space_handle_t
name|memh
decl_stmt|;
name|bus_addr_t
name|addr
decl_stmt|;
name|bus_size_t
name|sizepg
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|h
operator|->
name|sc
decl_stmt|;
comment|/* out of sc->memh, allocate as many pages as necessary */
comment|/* convert size to PCIC pages */
name|sizepg
operator|=
operator|(
name|size
operator|+
operator|(
name|PCIC_MEM_ALIGN
operator|-
literal|1
operator|)
operator|)
operator|/
name|PCIC_MEM_ALIGN
expr_stmt|;
if|if
condition|(
name|sizepg
operator|>
name|PCIC_MAX_MEM_PAGES
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|sizepg
operator|)
operator|-
literal|1
expr_stmt|;
name|addr
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|memh
operator|=
name|addr
expr_stmt|;
name|pcmhp
operator|->
name|memt
operator|=
name|sc
operator|->
name|memt
expr_stmt|;
name|pcmhp
operator|->
name|memh
operator|=
name|memh
expr_stmt|;
name|pcmhp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|pcmhp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pcmhp
operator|->
name|realsize
operator|=
name|sizepg
operator|*
name|PCIC_MEM_PAGESIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_chip_mem_free
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|struct
name|pccard_mem_handle
modifier|*
name|pcmhp
parameter_list|)
block|{ }
end_function

begin_struct
specifier|static
struct|struct
name|mem_map_index_st
block|{
name|int
name|sysmem_start_lsb
decl_stmt|;
name|int
name|sysmem_start_msb
decl_stmt|;
name|int
name|sysmem_stop_lsb
decl_stmt|;
name|int
name|sysmem_stop_msb
decl_stmt|;
name|int
name|cardmem_lsb
decl_stmt|;
name|int
name|cardmem_msb
decl_stmt|;
name|int
name|memenable
decl_stmt|;
block|}
name|mem_map_index
index|[]
init|=
block|{
block|{
name|PCIC_SYSMEM_ADDR0_START_LSB
block|,
name|PCIC_SYSMEM_ADDR0_START_MSB
block|,
name|PCIC_SYSMEM_ADDR0_STOP_LSB
block|,
name|PCIC_SYSMEM_ADDR0_STOP_MSB
block|,
name|PCIC_CARDMEM_ADDR0_LSB
block|,
name|PCIC_CARDMEM_ADDR0_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_MEM0
block|, 	}
block|,
block|{
name|PCIC_SYSMEM_ADDR1_START_LSB
block|,
name|PCIC_SYSMEM_ADDR1_START_MSB
block|,
name|PCIC_SYSMEM_ADDR1_STOP_LSB
block|,
name|PCIC_SYSMEM_ADDR1_STOP_MSB
block|,
name|PCIC_CARDMEM_ADDR1_LSB
block|,
name|PCIC_CARDMEM_ADDR1_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_MEM1
block|, 	}
block|,
block|{
name|PCIC_SYSMEM_ADDR2_START_LSB
block|,
name|PCIC_SYSMEM_ADDR2_START_MSB
block|,
name|PCIC_SYSMEM_ADDR2_STOP_LSB
block|,
name|PCIC_SYSMEM_ADDR2_STOP_MSB
block|,
name|PCIC_CARDMEM_ADDR2_LSB
block|,
name|PCIC_CARDMEM_ADDR2_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_MEM2
block|, 	}
block|,
block|{
name|PCIC_SYSMEM_ADDR3_START_LSB
block|,
name|PCIC_SYSMEM_ADDR3_START_MSB
block|,
name|PCIC_SYSMEM_ADDR3_STOP_LSB
block|,
name|PCIC_SYSMEM_ADDR3_STOP_MSB
block|,
name|PCIC_CARDMEM_ADDR3_LSB
block|,
name|PCIC_CARDMEM_ADDR3_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_MEM3
block|, 	}
block|,
block|{
name|PCIC_SYSMEM_ADDR4_START_LSB
block|,
name|PCIC_SYSMEM_ADDR4_START_MSB
block|,
name|PCIC_SYSMEM_ADDR4_STOP_LSB
block|,
name|PCIC_SYSMEM_ADDR4_STOP_MSB
block|,
name|PCIC_CARDMEM_ADDR4_LSB
block|,
name|PCIC_CARDMEM_ADDR4_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_MEM4
block|, 	}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|pcic_chip_do_mem_map
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|win
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_start_lsb
argument_list|,
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
operator|>>
name|PCIC_SYSMEM_ADDRX_SHIFT
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_start_msb
argument_list|,
operator|(
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
operator|>>
operator|(
name|PCIC_SYSMEM_ADDRX_SHIFT
operator|+
literal|8
operator|)
operator|)
operator|&
name|PCIC_SYSMEM_ADDRX_START_MSB_ADDR_MASK
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX do I want 16 bit all the time? */
block|PCIC_SYSMEM_ADDRX_START_MSB_DATASIZE_16BIT;
endif|#
directive|endif
name|pcic_write
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_stop_lsb
argument_list|,
operator|(
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
operator|+
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|size
operator|)
operator|>>
name|PCIC_SYSMEM_ADDRX_SHIFT
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_stop_msb
argument_list|,
operator|(
operator|(
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
operator|+
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|size
operator|)
operator|>>
operator|(
name|PCIC_SYSMEM_ADDRX_SHIFT
operator|+
literal|8
operator|)
operator|)
operator|&
name|PCIC_SYSMEM_ADDRX_STOP_MSB_ADDR_MASK
operator|)
operator||
name|PCIC_SYSMEM_ADDRX_STOP_MSB_WAIT2
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|cardmem_lsb
argument_list|,
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|>>
name|PCIC_CARDMEM_ADDRX_SHIFT
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|cardmem_msb
argument_list|,
operator|(
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|>>
operator|(
name|PCIC_CARDMEM_ADDRX_SHIFT
operator|+
literal|8
operator|)
operator|)
operator|&
name|PCIC_CARDMEM_ADDRX_MSB_ADDR_MASK
operator|)
operator||
operator|(
operator|(
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|kind
operator|==
name|PCCARD_MEM_ATTR
operator|)
condition|?
name|PCIC_CARDMEM_ADDRX_MSB_REGACTIVE_ATTR
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator||=
operator|(
name|mem_map_index
index|[
name|win
index|]
operator|.
name|memenable
operator||
name|PCIC_ADDRWIN_ENABLE_MEMCS16
operator|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCICDEBUG
block|{
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|r3
decl_stmt|,
name|r4
decl_stmt|,
name|r5
decl_stmt|,
name|r6
decl_stmt|;
name|r1
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_start_msb
argument_list|)
expr_stmt|;
name|r2
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_start_lsb
argument_list|)
expr_stmt|;
name|r3
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_stop_msb
argument_list|)
expr_stmt|;
name|r4
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|sysmem_stop_lsb
argument_list|)
expr_stmt|;
name|r5
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|cardmem_msb
argument_list|)
expr_stmt|;
name|r6
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|mem_map_index
index|[
name|win
index|]
operator|.
name|cardmem_lsb
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_do_mem_map window %d: %02x%02x %02x%02x "
literal|"%02x%02x\n"
operator|,
name|win
operator|,
name|r1
operator|,
name|r2
operator|,
name|r3
operator|,
name|r4
operator|,
name|r5
operator|,
name|r6
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|pcic_chip_mem_map
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|kind
parameter_list|,
name|bus_addr_t
name|card_addr
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|pccard_mem_handle
modifier|*
name|pcmhp
parameter_list|,
name|bus_addr_t
modifier|*
name|offsetp
parameter_list|,
name|int
modifier|*
name|windowp
parameter_list|)
block|{
name|bus_addr_t
name|busaddr
decl_stmt|;
name|long
name|card_offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|win
decl_stmt|;
name|win
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|mem_map_index
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mem_map_index
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|memalloc
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|win
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|memalloc
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|win
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|windowp
operator|=
name|win
expr_stmt|;
name|busaddr
operator|=
name|pcmhp
operator|->
name|addr
expr_stmt|;
comment|/* 	 * compute the address offset to the pccard address space for the 	 * pcic.  this is intentionally signed.  The masks and shifts below 	 * will cause TRT to happen in the pcic registers.  Deal with making 	 * sure the address is aligned, and return the alignment offset. 	 */
operator|*
name|offsetp
operator|=
name|card_addr
operator|%
name|PCIC_MEM_ALIGN
expr_stmt|;
name|card_addr
operator|-=
operator|*
name|offsetp
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_mem_map window %d bus %lx+%lx+%lx at card addr "
literal|"%lx\n"
operator|,
name|win
operator|,
operator|(
name|u_long
operator|)
name|busaddr
operator|,
operator|(
name|u_long
operator|)
operator|*
name|offsetp
operator|,
operator|(
name|u_long
operator|)
name|size
operator|,
operator|(
name|u_long
operator|)
name|card_addr
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * include the offset in the size, and decrement size by one, since 	 * the hw wants start/stop 	 */
name|size
operator|+=
operator|*
name|offsetp
operator|-
literal|1
expr_stmt|;
name|card_offset
operator|=
operator|(
operator|(
operator|(
name|long
operator|)
name|card_addr
operator|)
operator|-
operator|(
operator|(
name|long
operator|)
name|busaddr
operator|)
operator|)
expr_stmt|;
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|addr
operator|=
name|busaddr
expr_stmt|;
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|offset
operator|=
name|card_offset
expr_stmt|;
name|h
operator|->
name|mem
index|[
name|win
index|]
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|pcic_chip_do_mem_map
argument_list|(
name|h
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_chip_mem_unmap
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|window
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|window
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|mem_map_index
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mem_map_index
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"pcic_chip_mem_unmap: window out of range"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|mem_map_index
index|[
name|window
index|]
operator|.
name|memenable
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|h
operator|->
name|memalloc
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|window
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcic_chip_io_alloc
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|bus_addr_t
name|start
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|bus_size_t
name|align
parameter_list|,
name|struct
name|pccard_io_handle
modifier|*
name|pcihp
parameter_list|)
block|{
name|bus_space_tag_t
name|iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
decl_stmt|;
name|bus_addr_t
name|ioaddr
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|h
operator|->
name|sc
decl_stmt|;
comment|/* 	 * Allocate some arbitrary I/O space. 	 */
name|iot
operator|=
name|sc
operator|->
name|iot
expr_stmt|;
name|ioaddr
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|ioh
operator|=
name|start
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_io_alloc map port %lx+%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|PCCARD_IO_ALLOCATED
expr_stmt|;
name|ioh
operator|=
name|start
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_io_alloc alloc port %lx+%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
block|}
name|pcihp
operator|->
name|iot
operator|=
name|iot
expr_stmt|;
name|pcihp
operator|->
name|ioh
operator|=
name|ioh
expr_stmt|;
name|pcihp
operator|->
name|addr
operator|=
name|ioaddr
expr_stmt|;
name|pcihp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|pcihp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_chip_io_free
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|struct
name|pccard_io_handle
modifier|*
name|pcihp
parameter_list|)
block|{ }
end_function

begin_struct
specifier|static
struct|struct
name|io_map_index_st
block|{
name|int
name|start_lsb
decl_stmt|;
name|int
name|start_msb
decl_stmt|;
name|int
name|stop_lsb
decl_stmt|;
name|int
name|stop_msb
decl_stmt|;
name|int
name|ioenable
decl_stmt|;
name|int
name|ioctlmask
decl_stmt|;
name|int
name|ioctlbits
index|[
literal|3
index|]
decl_stmt|;
comment|/* indexed by PCCARD_WIDTH_* */
block|}
name|io_map_index
index|[]
init|=
block|{
block|{
name|PCIC_IOADDR0_START_LSB
block|,
name|PCIC_IOADDR0_START_MSB
block|,
name|PCIC_IOADDR0_STOP_LSB
block|,
name|PCIC_IOADDR0_STOP_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_IO0
block|,
name|PCIC_IOCTL_IO0_WAITSTATE
operator||
name|PCIC_IOCTL_IO0_ZEROWAIT
operator||
name|PCIC_IOCTL_IO0_IOCS16SRC_MASK
operator||
name|PCIC_IOCTL_IO0_DATASIZE_MASK
block|,
block|{
name|PCIC_IOCTL_IO0_IOCS16SRC_CARD
block|,
name|PCIC_IOCTL_IO0_IOCS16SRC_DATASIZE
operator||
name|PCIC_IOCTL_IO0_DATASIZE_8BIT
block|,
name|PCIC_IOCTL_IO0_IOCS16SRC_DATASIZE
operator||
name|PCIC_IOCTL_IO0_DATASIZE_16BIT
block|, 		}
block|, 	}
block|,
block|{
name|PCIC_IOADDR1_START_LSB
block|,
name|PCIC_IOADDR1_START_MSB
block|,
name|PCIC_IOADDR1_STOP_LSB
block|,
name|PCIC_IOADDR1_STOP_MSB
block|,
name|PCIC_ADDRWIN_ENABLE_IO1
block|,
name|PCIC_IOCTL_IO1_WAITSTATE
operator||
name|PCIC_IOCTL_IO1_ZEROWAIT
operator||
name|PCIC_IOCTL_IO1_IOCS16SRC_MASK
operator||
name|PCIC_IOCTL_IO1_DATASIZE_MASK
block|,
block|{
name|PCIC_IOCTL_IO1_IOCS16SRC_CARD
block|,
name|PCIC_IOCTL_IO1_IOCS16SRC_DATASIZE
operator||
name|PCIC_IOCTL_IO1_DATASIZE_8BIT
block|,
name|PCIC_IOCTL_IO1_IOCS16SRC_DATASIZE
operator||
name|PCIC_IOCTL_IO1_DATASIZE_16BIT
block|, 		}
block|, 	}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|pcic_chip_do_io_map
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|win
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_do_io_map win %d addr %lx size %lx width %d\n"
operator|,
name|win
operator|,
operator|(
name|long
operator|)
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|,
operator|(
name|long
operator|)
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|,
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|io_map_index
index|[
name|win
index|]
operator|.
name|start_lsb
argument_list|,
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|io_map_index
index|[
name|win
index|]
operator|.
name|start_msb
argument_list|,
operator|(
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|io_map_index
index|[
name|win
index|]
operator|.
name|stop_lsb
argument_list|,
operator|(
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|+
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|-
literal|1
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|io_map_index
index|[
name|win
index|]
operator|.
name|stop_msb
argument_list|,
operator|(
operator|(
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|+
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|-
literal|1
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_IOCTL
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|io_map_index
index|[
name|win
index|]
operator|.
name|ioctlmask
expr_stmt|;
name|reg
operator||=
name|io_map_index
index|[
name|win
index|]
operator|.
name|ioctlbits
index|[
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
index|]
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_IOCTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator||=
name|io_map_index
index|[
name|win
index|]
operator|.
name|ioenable
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcic_chip_io_map
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|width
parameter_list|,
name|bus_addr_t
name|offset
parameter_list|,
name|bus_size_t
name|size
parameter_list|,
name|struct
name|pccard_io_handle
modifier|*
name|pcihp
parameter_list|,
name|int
modifier|*
name|windowp
parameter_list|)
block|{
name|bus_addr_t
name|ioaddr
init|=
name|pcihp
operator|->
name|addr
operator|+
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|win
decl_stmt|;
ifdef|#
directive|ifdef
name|PCICDEBUG
specifier|static
name|char
modifier|*
name|width_names
index|[]
init|=
block|{
literal|"auto"
block|,
literal|"io8"
block|,
literal|"io16"
block|}
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|struct pcic_softc *sc = h->sc;
endif|#
directive|endif
comment|/* XXX Sanity check offset/size. */
name|win
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|io_map_index
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|io_map_index
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|ioalloc
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|win
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|ioalloc
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|win
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|*
name|windowp
operator|=
name|win
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX this is pretty gross */
block|if (sc->iot != pcihp->iot) 		panic("pcic_chip_io_map iot is bogus");
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_io_map window %d %s port %lx+%lx\n"
operator|,
name|win
operator|,
name|width_names
index|[
name|width
index|]
operator|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|,
operator|(
name|u_long
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX wtf is this doing here? */
name|printf
argument_list|(
literal|" port 0x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ioaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"-0x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ioaddr
operator|+
operator|(
name|u_long
operator|)
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|addr
operator|=
name|ioaddr
expr_stmt|;
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|io
index|[
name|win
index|]
operator|.
name|width
operator|=
name|width
expr_stmt|;
name|pcic_chip_do_io_map
argument_list|(
name|h
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_chip_io_unmap
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|window
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|window
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|io_map_index
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|io_map_index
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"pcic_chip_io_unmap: window out of range"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|io_map_index
index|[
name|window
index|]
operator|.
name|ioenable
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|h
operator|->
name|ioalloc
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|window
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_wait_ready
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
operator|&
name|PCIC_IF_STATUS_READY
condition|)
return|return;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PCICDEBUG
if|if
condition|(
name|pcic_debug
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|>
literal|5000
operator|)
operator|&&
operator|(
name|i
operator|%
literal|100
operator|==
literal|99
operator|)
condition|)
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"pcic_wait_ready: ready never happened, status = %02x\n"
argument_list|,
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|pcic_enable_socket
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|int
name|cardtype
decl_stmt|,
name|reg
decl_stmt|,
name|win
decl_stmt|;
comment|/* this bit is mostly stolen from pcic_attach_card */
comment|/* power down the socket to reset it, clear the card reset pin */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_PWRCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  	 * wait 300ms until power fails (Tpf).  Then, wait 100ms since 	 * we are changing Vcc (Toff). 	 */
name|DELAY
argument_list|(
operator|(
literal|300
operator|+
literal|100
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VADEM_POWER_HACK
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|iot
argument_list|,
name|sc
operator|->
name|ioh
argument_list|,
name|PCIC_REG_INDEX
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|iot
argument_list|,
name|sc
operator|->
name|ioh
argument_list|,
name|PCIC_REG_INDEX
argument_list|,
literal|0x37
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"prcr = %02x\n"
argument_list|,
name|pcic_read
argument_list|(
name|h
argument_list|,
literal|0x02
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cvsr = %02x\n"
argument_list|,
name|pcic_read
argument_list|(
name|h
argument_list|,
literal|0x2f
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DANGER WILL ROBINSON!  Changing voltage select!\n"
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
literal|0x2f
argument_list|,
name|pcic_read
argument_list|(
name|h
argument_list|,
literal|0x2f
argument_list|)
operator|&
operator|~
literal|0x03
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cvsr = %02x\n"
argument_list|,
name|pcic_read
argument_list|(
name|h
argument_list|,
literal|0x2f
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* power up the socket */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_PWRCTL
argument_list|,
name|PCIC_PWRCTL_DISABLE_RESETDRV
operator||
name|PCIC_PWRCTL_PWR_ENABLE
argument_list|)
expr_stmt|;
comment|/* 	 * wait 100ms until power raise (Tpr) and 20ms to become 	 * stable (Tsu(Vcc)). 	 * 	 * some machines require some more time to be settled 	 * (300ms is added here). 	 */
name|DELAY
argument_list|(
operator|(
literal|100
operator|+
literal|20
operator|+
literal|300
operator|)
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_PWRCTL
argument_list|,
name|PCIC_PWRCTL_DISABLE_RESETDRV
operator||
name|PCIC_PWRCTL_OE
operator||
name|PCIC_PWRCTL_PWR_ENABLE
argument_list|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * hold RESET at least 10us. 	 */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* clear the reset flag */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|,
name|PCIC_INTR_RESET
argument_list|)
expr_stmt|;
comment|/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* wait for the chip to finish initializing */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_IF_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|reg
operator|&
name|PCIC_IF_STATUS_POWERACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pcic_chip_socket_enable: status %x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pcic_wait_ready
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* zero out the address windows */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_ADDRWIN_ENABLE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set the card type */
name|CARD_GET_TYPE
argument_list|(
name|h
operator|->
name|dev
argument_list|,
operator|&
name|cardtype
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|PCIC_INTR_CARDTYPE_MASK
operator||
name|PCIC_INTR_IRQ_MASK
operator||
name|PCIC_INTR_ENABLE
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
operator|(
name|cardtype
operator|==
name|PCCARD_IFTYPE_IO
operator|)
condition|?
name|PCIC_INTR_CARDTYPE_IO
else|:
name|PCIC_INTR_CARDTYPE_MEM
operator|)
expr_stmt|;
name|reg
operator||=
name|h
operator|->
name|ih_irq
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|h
operator|->
name|dev
operator|,
literal|"pcic_chip_socket_enable cardtype %s %02x\n"
operator|,
operator|(
operator|(
name|cardtype
operator|==
name|PCCARD_IFTYPE_IO
operator|)
condition|?
literal|"io"
else|:
literal|"mem"
operator|)
operator|,
name|reg
operator|)
argument_list|)
expr_stmt|;
comment|/* reinstall all the memory and io mappings */
for|for
control|(
name|win
operator|=
literal|0
init|;
name|win
operator|<
name|PCIC_MEM_WINS
condition|;
name|win
operator|++
control|)
if|if
condition|(
name|h
operator|->
name|memalloc
operator|&
operator|(
literal|1
operator|<<
name|win
operator|)
condition|)
name|pcic_chip_do_mem_map
argument_list|(
name|h
argument_list|,
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|win
operator|=
literal|0
init|;
name|win
operator|<
name|PCIC_IO_WINS
condition|;
name|win
operator|++
control|)
if|if
condition|(
name|h
operator|->
name|ioalloc
operator|&
operator|(
literal|1
operator|<<
name|win
operator|)
condition|)
name|pcic_chip_do_io_map
argument_list|(
name|h
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pcic_disable_socket
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pcic_chip_socket_disable\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* power down the socket */
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_PWRCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * wait 300ms until power fails (Tpf). 	 */
name|DELAY
argument_list|(
literal|300
operator|*
literal|1000
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|st_pcic_read
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|h
operator|->
name|ph_bus_t
argument_list|,
name|h
operator|->
name|ph_bus_h
argument_list|,
name|PCIC_REG_INDEX
argument_list|,
name|h
operator|->
name|sock
operator|+
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
name|bus_space_read_1
argument_list|(
name|h
operator|->
name|ph_bus_t
argument_list|,
name|h
operator|->
name|ph_bus_h
argument_list|,
name|PCIC_REG_DATA
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|st_pcic_write
parameter_list|(
name|struct
name|pcic_handle
modifier|*
name|h
parameter_list|,
name|int
name|idx
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
name|bus_space_write_1
argument_list|(
name|h
operator|->
name|ph_bus_t
argument_list|,
name|h
operator|->
name|ph_bus_h
argument_list|,
name|PCIC_REG_INDEX
argument_list|,
name|h
operator|->
name|sock
operator|+
name|idx
argument_list|)
expr_stmt|;
block|}
name|bus_space_write_1
argument_list|(
name|h
operator|->
name|ph_bus_t
argument_list|,
name|h
operator|->
name|ph_bus_h
argument_list|,
name|PCIC_REG_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcic_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|win
decl_stmt|;
name|bus_addr_t
name|off
decl_stmt|;
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|sz
operator|=
name|rman_get_end
argument_list|(
name|r
argument_list|)
operator|-
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|win
operator|=
name|rid
expr_stmt|;
name|err
operator|=
name|pcic_chip_io_map
argument_list|(
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|,
operator|&
name|h
operator|->
name|io
index|[
name|rid
index|]
argument_list|,
operator|&
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pcic_chip_io_free
argument_list|(
name|h
argument_list|,
operator|&
name|h
operator|->
name|io
index|[
name|rid
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|err
operator|=
name|pcic_chip_mem_map
argument_list|(
name|h
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sz
argument_list|,
operator|&
name|h
operator|->
name|mem
index|[
name|rid
index|]
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pcic_chip_mem_free
argument_list|(
name|h
argument_list|,
operator|&
name|h
operator|->
name|mem
index|[
name|rid
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|err
operator|=
name|bus_generic_activate_resource
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|pcic_chip_io_unmap
argument_list|(
name|h
argument_list|,
name|rid
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|pcic_chip_mem_unmap
argument_list|(
name|h
argument_list|,
name|rid
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
name|err
operator|=
name|bus_generic_deactivate_resource
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irqres
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|bus_generic_setup_intr
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|irqres
argument_list|,
name|flags
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|irq
operator|=
name|rman_get_start
argument_list|(
name|irqres
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|PCIC_INTR_IRQ_MASK
operator||
name|PCIC_INTR_ENABLE
operator|)
expr_stmt|;
name|reg
operator||=
name|irq
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|h
operator|->
name|ih_irq
operator|=
name|irq
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"card irq %d\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pcic_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookiep
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|h
operator|->
name|ih_irq
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
name|pcic_read
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|PCIC_INTR_IRQ_MASK
operator||
name|PCIC_INTR_ENABLE
operator|)
expr_stmt|;
name|pcic_write
argument_list|(
name|h
argument_list|,
name|PCIC_INTR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_teardown_intr
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookiep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pcic_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|int
name|sz
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
comment|/* Nearly default */
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|start
operator|==
literal|0
operator|&&
name|end
operator|==
operator|~
literal|0
operator|&&
name|count
operator|!=
literal|1
condition|)
block|{
name|start
operator|=
literal|0xd0000
expr_stmt|;
comment|/* XXX */
name|end
operator|=
literal|0xdffff
expr_stmt|;
block|}
name|r
operator|=
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
name|r
return|;
name|sz
operator|=
name|rman_get_end
argument_list|(
name|r
argument_list|)
operator|-
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|err
operator|=
name|pcic_chip_io_alloc
argument_list|(
name|h
argument_list|,
name|rman_get_start
argument_list|(
name|r
argument_list|)
argument_list|,
name|sz
argument_list|,
literal|0
argument_list|,
operator|&
name|h
operator|->
name|io
index|[
operator|*
name|rid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|err
operator|=
name|pcic_chip_mem_alloc
argument_list|(
name|h
argument_list|,
name|r
argument_list|,
name|sz
argument_list|,
operator|&
name|h
operator|->
name|mem
index|[
operator|*
name|rid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|pcic_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|pcic_chip_io_free
argument_list|(
name|h
argument_list|,
operator|&
name|h
operator|->
name|io
index|[
name|rid
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|pcic_chip_mem_free
argument_list|(
name|h
argument_list|,
operator|&
name|h
operator|->
name|mem
index|[
name|rid
index|]
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
return|return
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* 	 * Do nothing for now, maybe in time do what FreeBSD's current  	 * pccard code does and detach my children.  That's the safest thing 	 * to do since we don't want to wake up and have different hardware 	 * in the slots. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pcic_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* Need to port pcic_power from newer netbsd versions of this file */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pcic_set_res_flags
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
name|h
init|=
name|pcic_get_handle
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%p %p %d %d %#x\n"
operator|,
name|dev
operator|,
name|child
operator|,
name|type
operator|,
name|rid
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|h
operator|->
name|mem
index|[
name|rid
index|]
operator|.
name|kind
operator|=
name|PCCARD_MEM_ATTR
expr_stmt|;
name|pcic_chip_do_mem_map
argument_list|(
name|h
argument_list|,
name|rid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pcic_set_memory_offset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_int32_t
name|offset
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_start_threads
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcic_handle
modifier|*
modifier|*
name|walker
decl_stmt|;
name|walker
operator|=
name|handles
expr_stmt|;
while|while
condition|(
operator|*
name|walker
condition|)
block|{
name|pcic_create_event_thread
argument_list|(
operator|*
name|walker
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pcic_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|pccarddev
decl_stmt|;
name|device_t
modifier|*
name|kids
decl_stmt|;
name|int
name|nkids
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|kids
argument_list|,
operator|&
name|nkids
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkids
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|device_delete_child
argument_list|(
name|pccarddev
argument_list|,
name|kids
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"delete of %s failed: %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|kids
index|[
name|i
index|]
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|kids
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|pcic
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|pcic_start_threads
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

