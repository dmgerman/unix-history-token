begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 Gardner Buchanan<gbuchanan@shl.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Gardner Buchanan.  * 4. The name of Gardner Buchanan may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This is a driver for SMC's 9000 series of Ethernet adapters.  *  * This FreeBSD driver is derived from the smc9194 Linux driver by  * Erik Stahlman and is Copyright (C) 1996 by Erik Stahlman.  * This driver also shamelessly borrows from the FreeBSD ep driver  * which is Copyright (C) 1994 Herb Peyerl<hpeyerl@novatel.ca>  * All rights reserved.  *  * It is set up for my SMC91C92 equipped Ampro LittleBoard embedded  * PC.  It is adapted from Erik Stahlman's Linux driver which worked  * with his EFA Info*Express SVC VLB adaptor.  According to SMC's databook,  * it will work for the entire SMC 9xxx series. (Ha Ha)  *  * "Features" of the SMC chip:  *   4608 byte packet memory. (for the 91C92.  Others have more)  *   EEPROM for configuration  *   AUI/TP selection  *  * Authors:  *      Erik Stahlman                   erik@vt.edu  *      Herb Peyerl                     hpeyerl@novatel.ca  *      Andres Vega Garcia              avega@sophia.inria.fr  *      Serge Babkin                    babkin@hq.icb.chel.su  *      Gardner Buchanan                gbuchanan@shl.com  *  * Sources:  *    o   SMC databook  *    o   "smc9194.c:v0.10(FIXED) 02/15/96 by Erik Stahlman (erik@vt.edu)"  *    o   "if_ep.c,v 1.19 1995/01/24 20:53:45 davidg Exp"  *  * Known Bugs:  *    o   Setting of the hardware address isn't supported.  *    o   Hardware padding isn't used.  */
end_comment

begin_comment
comment|/*  * Modifications for Megahertz X-Jack Ethernet Card (XJ-10BT)  *   * Copyright (c) 1996 by Tatsumi Hosokawa<hosokawa@jp.FreeBSD.org>  *                       BSD-nomads, Tokyo, Japan.  */
end_comment

begin_comment
comment|/*  * Multicast support by Kei TANAKA<kei@pal.xerox.com>  * Special thanks to itojun@itojun.org  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<dev/sn/if_snreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/sn/if_snvar.h>
end_include

begin_comment
comment|/* Exported variables */
end_comment

begin_decl_stmt
name|devclass_t
name|sn_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|snioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snresume
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sninit_locked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snstart_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sninit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snread
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snstart
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snstop
parameter_list|(
name|struct
name|sn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|snwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sn_setmcast
parameter_list|(
name|struct
name|sn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sn_getmcf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_char
modifier|*
name|mcf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* I (GB) have been unlucky getting the hardware padding  * to work properly.  */
end_comment

begin_define
define|#
directive|define
name|SW_PAD
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|chip_ids
index|[
literal|15
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
comment|/* 3 */
literal|"SMC91C90/91C92"
block|,
comment|/* 4 */
literal|"SMC91C94/91C96"
block|,
comment|/* 5 */
literal|"SMC91C95"
block|,
name|NULL
block|,
comment|/* 7 */
literal|"SMC91C100"
block|,
comment|/* 8 */
literal|"SMC91C100FD"
block|,
comment|/* 9 */
literal|"SMC91C110"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sn_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|rev
decl_stmt|;
name|uint16_t
name|address
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|SN_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pages_wanted
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|||
literal|1
condition|)
block|{
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|rev
operator|=
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|REVISION_REG_W
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|chip_ids
index|[
name|rev
index|]
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" %s "
argument_list|,
name|chip_ids
index|[
name|rev
index|]
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" unsupported chip"
argument_list|)
expr_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|CONFIG_REG_W
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|i
operator|&
name|CR_AUI_SELECT
condition|?
literal|"AUI"
else|:
literal|"UTP"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read the station address from the chip. The MAC address is bank 1, 	 * regs 4 - 9 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|eaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|address
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|IAR_ADDR0_REG_W
operator|+
name|i
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|address
operator|>>
literal|8
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|address
operator|&
literal|0xFF
expr_stmt|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|snstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|snioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|snwatchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|sninit
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Activate the interrupt so we can get card interrupts.  This 	 * needs to be done last so that we don't have/hold the lock 	 * during startup to avoid LORs in the network layer. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|sn_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sn_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sn_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|snstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sn_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|SN_LOCK_DESTORY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sninit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sninit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset and initialize the chip  */
end_comment

begin_function
specifier|static
name|void
name|sninit_locked
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|SN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * This resets the registers mostly to defaults, but doesn't affect 	 * EEPROM.  After the reset cycle, we pause briefly for the chip to 	 * be happy. 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RECV_CONTROL_REG_W
argument_list|,
name|RCR_SOFTRESET
argument_list|)
expr_stmt|;
name|SMC_DELAY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RECV_CONTROL_REG_W
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|SMC_DELAY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SMC_DELAY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|TXMIT_CONTROL_REG_W
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * Set the control register to automatically release succesfully 	 * transmitted packets (making the best use out of our limited 	 * memory) and to enable the EPH interrupt on certain TX errors. 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|CONTROL_REG_W
argument_list|,
operator|(
name|CTR_AUTO_RELEASE
operator||
name|CTR_TE_ENABLE
operator||
name|CTR_CR_ENABLE
operator||
name|CTR_LE_ENABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* Set squelch level to 240mV (default 480mV) */
name|flags
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|CONFIG_REG_W
argument_list|)
expr_stmt|;
name|flags
operator||=
name|CR_SET_SQLCH
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|CONFIG_REG_W
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the MMU and wait for it to be un-busy. 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_RESET
argument_list|)
expr_stmt|;
while|while
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|)
operator|&
name|MMUCR_BUSY
condition|)
comment|/* NOTHING */
empty_stmt|;
comment|/* 	 * Disable all interrupts 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|sn_setmcast
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Set the transmitter control.  We want it enabled. 	 */
name|flags
operator|=
name|TCR_ENABLE
expr_stmt|;
ifndef|#
directive|ifndef
name|SW_PAD
comment|/* 	 * I (GB) have been unlucky getting this to work. 	 */
name|flags
operator||=
name|TCR_PAD_ENABLE
expr_stmt|;
endif|#
directive|endif
comment|/* SW_PAD */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|TXMIT_CONTROL_REG_W
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Now, enable interrupts 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|mask
operator|=
name|IM_EPH_INT
operator||
name|IM_RX_OVRN_INT
operator||
name|IM_RCV_INT
operator||
name|IM_TX_INT
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_mask
operator|=
name|mask
expr_stmt|;
name|sc
operator|->
name|pages_wanted
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Mark the interface running but not active. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * Attempt to push out any waiting packets. 	 */
name|snstart_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|snstart_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snstart_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|numPages
decl_stmt|;
name|uint8_t
name|packet_no
decl_stmt|;
name|int
name|time_out
decl_stmt|;
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|SN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|pages_wanted
operator|!=
operator|-
literal|1
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"snstart() while memory allocation pending\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|startagain
label|:
comment|/* 	 * Sneak a peek at the next packet 	 */
name|m
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Compute the frame length and set pad to give an overall even 	 * number of bytes.  Below we assume that the packet length is even. 	 */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|top
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|pad
operator|=
operator|(
name|len
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* 	 * We drop packets that are too large. Perhaps we should truncate 	 * them instead? 	 */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"large packet discarded (A)\n"
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|readcheck
goto|;
block|}
ifdef|#
directive|ifdef
name|SW_PAD
comment|/* 	 * If HW padding is not turned on, then pad to ETHER_MIN_LEN. 	 */
if|if
condition|(
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
name|pad
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* SW_PAD */
name|length
operator|=
name|pad
operator|+
name|len
expr_stmt|;
comment|/* 	 * The MMU wants the number of pages to be the number of 256 byte 	 * 'pages', minus 1 (A packet can't ever have 0 pages. We also 	 * include space for the status word, byte count and control bytes in 	 * the allocation request. 	 */
name|numPages
operator|=
operator|(
name|length
operator|+
literal|6
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* 	 * Now, try to allocate the memory 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_ALLOC
operator||
name|numPages
argument_list|)
expr_stmt|;
comment|/* 	 * Wait a short amount of time to see if the allocation request 	 * completes.  Otherwise, I enable the interrupt and wait for 	 * completion asyncronously. 	 */
name|time_out
operator|=
name|MEMORY_WAIT_TIME
expr_stmt|;
do|do
block|{
if|if
condition|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_STAT_REG_B
argument_list|)
operator|&
name|IM_ALLOC_INT
condition|)
break|break;
block|}
do|while
condition|(
operator|--
name|time_out
condition|)
do|;
if|if
condition|(
operator|!
name|time_out
operator|||
name|junk
operator|>
literal|10
condition|)
block|{
comment|/* 		 * No memory now.  Oh well, wait until the chip finds memory 		 * later.   Remember how many pages we were asking for and 		 * enable the allocation completion interrupt. Also set a 		 * watchdog in case  we miss the interrupt. We mark the 		 * interface active since there is no point in attempting an 		 * snstart() until after the memory is available. 		 */
name|mask
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|)
operator||
name|IM_ALLOC_INT
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_mask
operator|=
name|mask
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|pages_wanted
operator|=
name|numPages
expr_stmt|;
return|return;
block|}
comment|/* 	 * The memory allocation completed.  Check the results. 	 */
name|packet_no
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|ALLOC_RESULT_REG_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_no
operator|&
name|ARR_FAILED
condition|)
block|{
if|if
condition|(
name|junk
operator|++
operator|>
literal|10
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Memory allocation failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|startagain
goto|;
block|}
comment|/* 	 * We have a packet number, so tell the card to use it. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|PACKET_NUM_REG_B
argument_list|,
name|packet_no
argument_list|)
expr_stmt|;
comment|/* 	 * Point to the beginning of the packet 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|POINTER_REG_W
argument_list|,
name|PTR_AUTOINC
operator||
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * Send the packet length (+6 for status, length and control byte) 	 * and the status word (set to zeros) 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
operator|(
name|length
operator|+
literal|6
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
operator|(
name|length
operator|+
literal|6
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Get the packet from the kernel.  This will include the Ethernet 	 * frame header, MAC Addresses etc. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Push out the data to the card. 	 */
for|for
control|(
name|top
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
comment|/* 		 * Push out words. 		 */
name|CSR_WRITE_MULTI_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint16_t
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * Push out remaining byte. 		 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Push out padding. 	 */
while|while
condition|(
name|pad
operator|>
literal|1
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pad
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Push out control byte and unused packet byte The control byte is 0 	 * meaning the packet is even lengthed and no special CRC handling is 	 * desired. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the interrupts and let the chipset deal with it Also set a 	 * watchdog in case we miss the interrupt. 	 */
name|mask
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|)
operator||
operator|(
name|IM_TX_INT
operator||
name|IM_TX_EMPTY_INT
operator|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_mask
operator|=
name|mask
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_ENQUEUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|readcheck
label|:
comment|/* 	 * Is another packet coming in?  We don't want to overflow the tiny 	 * RX FIFO.  If nothing has arrived then attempt to queue another 	 * transmit packet. 	 */
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FIFO_PORTS_REG_W
argument_list|)
operator|&
name|FIFO_REMPTY
condition|)
goto|goto
name|startagain
goto|;
return|return;
block|}
end_function

begin_comment
comment|/* Resume a packet transmit operation after a memory allocation  * has completed.  *  * This is basically a hacked up copy of snstart() which handles  * a completed memory allocation the same way snstart() does.  * It then passes control to snstart to handle any other queued  * packets.  */
end_comment

begin_function
specifier|static
name|void
name|snresume
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|numPages
decl_stmt|;
name|uint16_t
name|pages_wanted
decl_stmt|;
name|uint8_t
name|packet_no
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|pages_wanted
operator|<
literal|0
condition|)
return|return;
name|pages_wanted
operator|=
name|sc
operator|->
name|pages_wanted
expr_stmt|;
name|sc
operator|->
name|pages_wanted
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Sneak a peek at the next packet 	 */
name|m
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"snresume() with nothing to send\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Compute the frame length and set pad to give an overall even 	 * number of bytes.  Below we assume that the packet length is even. 	 */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|top
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|pad
operator|=
operator|(
name|len
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* 	 * We drop packets that are too large. Perhaps we should truncate 	 * them instead? 	 */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"large packet discarded (B)\n"
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SW_PAD
comment|/* 	 * If HW padding is not turned on, then pad to ETHER_MIN_LEN. 	 */
if|if
condition|(
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
name|pad
operator|=
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|len
expr_stmt|;
endif|#
directive|endif
comment|/* SW_PAD */
name|length
operator|=
name|pad
operator|+
name|len
expr_stmt|;
comment|/* 	 * The MMU wants the number of pages to be the number of 256 byte 	 * 'pages', minus 1 (A packet can't ever have 0 pages. We also 	 * include space for the status word, byte count and control bytes in 	 * the allocation request. 	 */
name|numPages
operator|=
operator|(
name|length
operator|+
literal|6
operator|)
operator|>>
literal|8
expr_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * The memory allocation completed.  Check the results. If it failed, 	 * we simply set a watchdog timer and hope for the best. 	 */
name|packet_no
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|ALLOC_RESULT_REG_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_no
operator|&
name|ARR_FAILED
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Memory allocation failed.  Weird.\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
goto|goto
name|try_start
goto|;
block|}
comment|/* 	 * We have a packet number, so tell the card to use it. 	 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|PACKET_NUM_REG_B
argument_list|,
name|packet_no
argument_list|)
expr_stmt|;
comment|/* 	 * Now, numPages should match the pages_wanted recorded when the 	 * memory allocation was initiated. 	 */
if|if
condition|(
name|pages_wanted
operator|!=
name|numPages
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"memory allocation wrong size.  Weird.\n"
argument_list|)
expr_stmt|;
comment|/* 		 * If the allocation was the wrong size we simply release the 		 * memory once it is granted. Wait for the MMU to be un-busy. 		 */
while|while
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|)
operator|&
name|MMUCR_BUSY
condition|)
comment|/* NOTHING */
empty_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_FREEPKT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Point to the beginning of the packet 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|POINTER_REG_W
argument_list|,
name|PTR_AUTOINC
operator||
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * Send the packet length (+6 for status, length and control byte) 	 * and the status word (set to zeros) 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
operator|(
name|length
operator|+
literal|6
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
operator|(
name|length
operator|+
literal|6
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Get the packet from the kernel.  This will include the Ethernet 	 * frame header, MAC Addresses etc. 	 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Push out the data to the card. 	 */
for|for
control|(
name|top
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
comment|/* 		 * Push out words. 		 */
name|CSR_WRITE_MULTI_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint16_t
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * Push out remaining byte. 		 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Push out padding. 	 */
while|while
condition|(
name|pad
operator|>
literal|1
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pad
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|pad
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Push out control byte and unused packet byte The control byte is 0 	 * meaning the packet is even lengthed and no special CRC handling is 	 * desired. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the interrupts and let the chipset deal with it Also set a 	 * watchdog in case we miss the interrupt. 	 */
name|mask
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|)
operator||
operator|(
name|IM_TX_INT
operator||
name|IM_TX_EMPTY_INT
operator|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_mask
operator|=
name|mask
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_ENQUEUE
argument_list|)
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|try_start
label|:
comment|/* 	 * Now pass control to snstart() to queue any additional packets 	 */
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|snstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * We've sent something, so we're active.  Set a watchdog in case the 	 * TX_EMPTY interrupt is lost. 	 */
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sn_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|interrupts
decl_stmt|;
name|struct
name|sn_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sn_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
comment|/* 	 * Chip state registers 	 */
name|uint8_t
name|mask
decl_stmt|;
name|uint8_t
name|packet_no
decl_stmt|;
name|uint16_t
name|tx_status
decl_stmt|;
name|uint16_t
name|card_stats
decl_stmt|;
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the watchdog. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Obtain the current interrupt mask and clear the hardware mask 	 * while servicing interrupts. 	 */
name|mask
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Get the set of interrupts which occurred and eliminate any which 	 * are masked. 	 */
name|interrupts
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_STAT_REG_B
argument_list|)
expr_stmt|;
name|status
operator|=
name|interrupts
operator|&
name|mask
expr_stmt|;
comment|/* 	 * Now, process each of the interrupt types. 	 */
comment|/* 	 * Receive Overrun. 	 */
if|if
condition|(
name|status
operator|&
name|IM_RX_OVRN_INT
condition|)
block|{
comment|/* 		 * Acknowlege Interrupt 		 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_ACK_REG_B
argument_list|,
name|IM_RX_OVRN_INT
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
block|}
comment|/* 	 * Got a packet. 	 */
if|if
condition|(
name|status
operator|&
name|IM_RCV_INT
condition|)
block|{
name|int
name|packet_number
decl_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|packet_number
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FIFO_PORTS_REG_W
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_number
operator|&
name|FIFO_REMPTY
condition|)
block|{
comment|/* 			 * we got called , but nothing was on the FIFO 			 */
name|printf
argument_list|(
literal|"sn: Receive interrupt with nothing on FIFO\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|snread
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * An on-card memory allocation came through. 	 */
if|if
condition|(
name|status
operator|&
name|IM_ALLOC_INT
condition|)
block|{
comment|/* 		 * Disable this interrupt. 		 */
name|mask
operator|&=
operator|~
name|IM_ALLOC_INT
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|snresume
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * TX Completion.  Handle a transmit error message. This will only be 	 * called when there is an error, because of the AUTO_RELEASE mode. 	 */
if|if
condition|(
name|status
operator|&
name|IM_TX_INT
condition|)
block|{
comment|/* 		 * Acknowlege Interrupt 		 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_ACK_REG_B
argument_list|,
name|IM_TX_INT
argument_list|)
expr_stmt|;
name|packet_no
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FIFO_PORTS_REG_W
argument_list|)
expr_stmt|;
name|packet_no
operator|&=
name|FIFO_TX_MASK
expr_stmt|;
comment|/* 		 * select this as the packet to read from 		 */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|PACKET_NUM_REG_B
argument_list|,
name|packet_no
argument_list|)
expr_stmt|;
comment|/* 		 * Position the pointer to the first word from this packet 		 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|POINTER_REG_W
argument_list|,
name|PTR_AUTOINC
operator||
name|PTR_READ
operator||
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 		 * Fetch the TX status word.  The value found here will be a 		 * copy of the EPH_STATUS_REG_W at the time the transmit 		 * failed. 		 */
name|tx_status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_status
operator|&
name|EPHSR_TX_SUC
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Successful packet caused interrupt\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
block|}
if|if
condition|(
name|tx_status
operator|&
name|EPHSR_LATCOL
condition|)
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_collisions
expr_stmt|;
comment|/* 		 * Some of these errors will have disabled transmit. 		 * Re-enable transmit now. 		 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SW_PAD
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|TXMIT_CONTROL_REG_W
argument_list|,
name|TCR_ENABLE
argument_list|)
expr_stmt|;
else|#
directive|else
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|TXMIT_CONTROL_REG_W
argument_list|,
name|TCR_ENABLE
operator||
name|TCR_PAD_ENABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SW_PAD */
comment|/* 		 * kill the failed packet. Wait for the MMU to be un-busy. 		 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|)
operator|&
name|MMUCR_BUSY
condition|)
comment|/* NOTHING */
empty_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_FREEPKT
argument_list|)
expr_stmt|;
comment|/* 		 * Attempt to queue more transmits. 		 */
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|snstart_locked
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Transmit underrun.  We use this opportunity to update transmit 	 * statistics from the card. 	 */
if|if
condition|(
name|status
operator|&
name|IM_TX_EMPTY_INT
condition|)
block|{
comment|/* 		 * Acknowlege Interrupt 		 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_ACK_REG_B
argument_list|,
name|IM_TX_EMPTY_INT
argument_list|)
expr_stmt|;
comment|/* 		 * Disable this interrupt. 		 */
name|mask
operator|&=
operator|~
name|IM_TX_EMPTY_INT
expr_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|card_stats
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|COUNTER_REG_W
argument_list|)
expr_stmt|;
comment|/* 		 * Single collisions 		 */
name|sc
operator|->
name|ifp
operator|->
name|if_collisions
operator|+=
name|card_stats
operator|&
name|ECR_COLN_MASK
expr_stmt|;
comment|/* 		 * Multiple collisions 		 */
name|sc
operator|->
name|ifp
operator|->
name|if_collisions
operator|+=
operator|(
name|card_stats
operator|&
name|ECR_MCOLN_MASK
operator|)
operator|>>
literal|4
expr_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * Attempt to enqueue some more stuff. 		 */
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|snstart_locked
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some other error.  Try to fix it by resetting the adapter. 	 */
if|if
condition|(
name|status
operator|&
name|IM_EPH_INT
condition|)
block|{
name|snstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sninit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* 	 * Handled all interrupt sources. 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Reestablish interrupts from mask which have not been deselected 	 * during this interrupt.  Note that the hardware mask, which was set 	 * to 0x00 at the start of this service routine, may have been 	 * updated by one or more of the interrupt handers and we must let 	 * those new interrupts stay enabled here. 	 */
name|mask
operator||=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_mask
operator|=
name|mask
expr_stmt|;
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snread
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|short
name|status
decl_stmt|;
name|int
name|packet_number
decl_stmt|;
name|uint16_t
name|packet_length
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|packet_number = CSR_READ_2(sc, FIFO_PORTS_REG_W);  	if (packet_number& FIFO_REMPTY) {
comment|/* 		 * we got called , but nothing was on the FIFO 		 */
block|printf("sn: Receive interrupt with nothing on FIFO\n"); 		return; 	}
endif|#
directive|endif
name|read_another
label|:
comment|/* 	 * Start reading from the start of the packet. Since PTR_RCV is set, 	 * packet number is found in FIFO_PORTS_REG_W, FIFO_RX_MASK. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|POINTER_REG_W
argument_list|,
name|PTR_READ
operator||
name|PTR_RCV
operator||
name|PTR_AUTOINC
operator||
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * First two words are status and packet_length 	 */
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|)
expr_stmt|;
name|packet_length
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|)
operator|&
name|RLEN_MASK
expr_stmt|;
comment|/* 	 * The packet length contains 3 extra words: status, length, and a 	 * extra word with the control byte. 	 */
name|packet_length
operator|-=
literal|6
expr_stmt|;
comment|/* 	 * Account for receive errors and discard. 	 */
if|if
condition|(
name|status
operator|&
name|RS_ERRORS
condition|)
block|{
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * A packet is received. 	 */
comment|/* 	 * Adjust for odd-length packet. 	 */
if|if
condition|(
name|status
operator|&
name|RS_ODDFRAME
condition|)
name|packet_length
operator|++
expr_stmt|;
comment|/* 	 * Allocate a header mbuf from the kernel. 	 */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|packet_length
expr_stmt|;
comment|/* 	 * Attach an mbuf cluster 	 */
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
comment|/* 	 * Insist on getting a cluster 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
name|printf
argument_list|(
literal|"sn: snread() kernel memory allocation problem\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Get packet, including link layer address, from interface. 	 */
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|eh
expr_stmt|;
name|CSR_READ_MULTI_2
argument_list|(
name|sc
argument_list|,
name|DATA_REG_W
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|data
argument_list|,
name|packet_length
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_length
operator|&
literal|1
condition|)
block|{
name|data
operator|+=
name|packet_length
operator|&
operator|~
literal|1
expr_stmt|;
operator|*
name|data
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|DATA_REG_B
argument_list|)
expr_stmt|;
block|}
operator|++
name|sc
operator|->
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
comment|/* 	 * Remove link layer addresses and whatnot. 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|packet_length
expr_stmt|;
comment|/* 	 * Drop locks before calling if_input() since it may re-enter 	 * snstart() in the netisr case.  This would result in a 	 * lock reversal.  Better performance might be obtained by 	 * chaining all packets received, dropping the lock, and then 	 * calling if_input() on each one. 	 */
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Error or good, tell the card to get rid of this packet Wait for 	 * the MMU to be un-busy. 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|)
operator|&
name|MMUCR_BUSY
condition|)
comment|/* NOTHING */
empty_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MMU_CMD_REG_W
argument_list|,
name|MMUCR_RELEASE
argument_list|)
expr_stmt|;
comment|/* 	 * Check whether another packet is ready 	 */
name|packet_number
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|FIFO_PORTS_REG_W
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_number
operator|&
name|FIFO_REMPTY
condition|)
block|{
return|return;
block|}
goto|goto
name|read_another
goto|;
block|}
end_function

begin_comment
comment|/*  * Handle IOCTLS.  This function is completely stolen from if_ep.c  * As with its progenitor, it does not handle hardware address  * changes.  */
end_comment

begin_function
specifier|static
name|int
name|snioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|snstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reinitialize card on any parameter change */
name|sninit_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|SIOCGHWADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCADDMULTI
case|:
comment|/* update multicast filter list. */
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sn_setmcast
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCDELMULTI
case|:
comment|/* update multicast filter list. */
name|SN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sn_setmcast
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|SN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|sn_intr
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 1. zero the interrupt mask  * 2. clear the enable receive flag  * 3. clear the enable xmit flags  */
end_comment

begin_function
specifier|static
name|void
name|snstop
parameter_list|(
name|struct
name|sn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
comment|/* 	 * Clear interrupt mask; disable all interrupts. 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|INTR_MASK_REG_B
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Disable transmitter and Receiver 	 */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RECV_CONTROL_REG_W
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|TXMIT_CONTROL_REG_W
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* 	 * Cancel watchdog. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sn_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|port_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|SMC_IO_EXTENT
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|port_res
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate ioport\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|irq_rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate irq\n"
argument_list|)
expr_stmt|;
name|sn_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|sc
operator|->
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sn_deactivate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intrhand
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|port_rid
argument_list|,
name|sc
operator|->
name|port_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irq_rid
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Function: sn_probe( device_t dev)  *  * Purpose:  *      Tests to see if a given ioaddr points to an SMC9xxx chip.  *      Tries to cause as little damage as possible if it's not a SMC chip.  *      Returns a 0 on success  *  * Algorithm:  *      (1) see if the high byte of BANK_SELECT is 0x33  *      (2) compare the ioaddr with the base register's address  *      (3) see if I recognize the chip ID in the appropriate register  *  *  */
end_comment

begin_function
name|int
name|sn_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint16_t
name|bank
decl_stmt|;
name|uint16_t
name|revision_register
decl_stmt|;
name|uint16_t
name|base_address_register
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sn_activate
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
comment|/* 	 * First, see if the high byte is 0x33 	 */
name|bank
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BANK_SELECT_REG_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bank
operator|&
name|BSR_DETECT_MASK
operator|)
operator|!=
name|BSR_DETECT_VALUE
condition|)
block|{
ifdef|#
directive|ifdef
name|SN_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"test1 failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
comment|/* 	 * The above MIGHT indicate a device, but I need to write to further 	 * test this.  Go to bank 0, then test that the register still 	 * reports the high byte is 0x33. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BANK_SELECT_REG_W
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|bank
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BANK_SELECT_REG_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bank
operator|&
name|BSR_DETECT_MASK
operator|)
operator|!=
name|BSR_DETECT_VALUE
condition|)
block|{
ifdef|#
directive|ifdef
name|SN_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"test2 failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
comment|/* 	 * well, we've already written once, so hopefully another time won't 	 * hurt.  This time, I need to switch the bank register to bank 1, so 	 * I can access the base address register.  The contents of the 	 * BASE_ADDR_REG_W register, after some jiggery pokery, is expected 	 * to match the I/O port address where the adapter is being probed. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BANK_SELECT_REG_W
argument_list|,
literal|0x0001
argument_list|)
expr_stmt|;
name|base_address_register
operator|=
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|BASE_ADDR_REG_W
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|0x3e0
expr_stmt|;
if|if
condition|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
operator|!=
name|base_address_register
condition|)
block|{
comment|/* 		 * Well, the base address register didn't match.  Must not 		 * have been a SMC chip after all. 		 */
ifdef|#
directive|ifdef
name|SN_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"test3 failed ioaddr = 0x%x, "
literal|"base_address_register = 0x%x\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|port_res
argument_list|)
argument_list|,
name|base_address_register
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Check if the revision register is something that I recognize. 	 * These might need to be added to later, as future revisions could 	 * be added. 	 */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|BANK_SELECT_REG_W
argument_list|,
literal|0x3
argument_list|)
expr_stmt|;
name|revision_register
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|REVISION_REG_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chip_ids
index|[
operator|(
name|revision_register
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
condition|)
block|{
comment|/* 		 * I don't regonize this chip, so... 		 */
ifdef|#
directive|ifdef
name|SN_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"test4 failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|error
goto|;
block|}
comment|/* 	 * at this point I'll assume that the chip is an SMC9xxx. It might be 	 * prudent to check a listing of MAC addresses against the hardware 	 * address, or do some other tests. 	 */
name|sn_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
name|sn_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MCFSZ
value|8
end_define

begin_function
specifier|static
name|void
name|sn_setmcast
parameter_list|(
name|struct
name|sn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|uint8_t
name|mcf
index|[
name|MCFSZ
index|]
decl_stmt|;
name|SN_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Set the receiver filter.  We want receive enabled and auto strip 	 * of CRC from received packet.  If we are promiscuous then set that 	 * bit too. 	 */
name|flags
operator|=
name|RCR_ENABLE
operator||
name|RCR_STRIP_CRC
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|flags
operator||=
name|RCR_PROMISC
operator||
name|RCR_ALMUL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|flags
operator||=
name|RCR_ALMUL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sn_getmcf
argument_list|(
name|ifp
argument_list|,
name|mcf
argument_list|)
condition|)
block|{
comment|/* set filter */
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MULTICAST1_REG_W
argument_list|,
operator|(
operator|(
name|uint16_t
operator|)
name|mcf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|mcf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MULTICAST2_REG_W
argument_list|,
operator|(
operator|(
name|uint16_t
operator|)
name|mcf
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|mcf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MULTICAST3_REG_W
argument_list|,
operator|(
operator|(
name|uint16_t
operator|)
name|mcf
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|mcf
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|MULTICAST4_REG_W
argument_list|,
operator|(
operator|(
name|uint16_t
operator|)
name|mcf
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator||
name|mcf
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|RCR_ALMUL
expr_stmt|;
block|}
block|}
name|SMC_SELECT_BANK
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|RECV_CONTROL_REG_W
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sn_getmcf
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint8_t
modifier|*
name|mcf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|index
decl_stmt|,
name|index2
decl_stmt|;
name|uint8_t
modifier|*
name|af
init|=
name|mcf
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|bzero
argument_list|(
name|mcf
argument_list|,
name|MCFSZ
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
return|return
literal|0
return|;
name|index
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|index2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|index2
operator|<<=
literal|1
expr_stmt|;
name|index2
operator||=
operator|(
name|index
operator|&
literal|0x01
operator|)
expr_stmt|;
name|index
operator|>>=
literal|1
expr_stmt|;
block|}
name|af
index|[
name|index2
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index2
operator|&
literal|7
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* use multicast filter */
block|}
end_function

end_unit

