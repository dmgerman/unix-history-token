begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2014 Thomas Skibo  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * A network interface driver for Cadence GEM Gigabit Ethernet  * interface such as the one used in Xilinx Zynq-7000 SoC.  *  * Reference: Zynq-7000 All Programmable SoC Technical Reference Manual.  * (v1.4) November 16, 2012.  Xilinx doc UG585.  GEM is covered in Ch. 16  * and register definitions are in appendix B.18.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/cadence/if_cgem_hw.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_define
define|#
directive|define
name|IF_CGEM_NAME
value|"cgem"
end_define

begin_define
define|#
directive|define
name|CGEM_NUM_RX_DESCS
value|256
end_define

begin_comment
comment|/* size of receive descriptor ring */
end_comment

begin_define
define|#
directive|define
name|CGEM_NUM_TX_DESCS
value|256
end_define

begin_comment
comment|/* size of transmit descriptor ring */
end_comment

begin_define
define|#
directive|define
name|MAX_DESC_RING_SIZE
value|(MAX(CGEM_NUM_RX_DESCS*sizeof(struct cgem_rx_desc),\ 				CGEM_NUM_TX_DESCS*sizeof(struct cgem_tx_desc)))
end_define

begin_comment
comment|/* Default for sysctl rxbufs.  Must be< CGEM_NUM_RX_DESCS of course. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_NUM_RX_BUFS
value|64
end_define

begin_comment
comment|/* number of receive bufs to queue. */
end_comment

begin_define
define|#
directive|define
name|TX_MAX_DMA_SEGS
value|4
end_define

begin_comment
comment|/* maximum segs in a tx mbuf dma */
end_comment

begin_define
define|#
directive|define
name|CGEM_CKSUM_ASSIST
value|(CSUM_IP | CSUM_TCP | CSUM_UDP | \ 				 CSUM_TCP_IPV6 | CSUM_UDP_IPV6)
end_define

begin_struct
struct|struct
name|cgem_softc
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|device_t
name|miibus
decl_stmt|;
name|int
name|if_old_flags
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|void
modifier|*
name|intrhand
decl_stmt|;
name|struct
name|callout
name|tick_ch
decl_stmt|;
name|uint32_t
name|net_ctl_shadow
decl_stmt|;
name|int
name|ref_clk_num
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|bus_dma_tag_t
name|desc_dma_tag
decl_stmt|;
name|bus_dma_tag_t
name|mbuf_dma_tag
decl_stmt|;
comment|/* receive descriptor ring */
name|struct
name|cgem_rx_desc
modifier|*
name|rxring
decl_stmt|;
name|bus_addr_t
name|rxring_physaddr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|rxring_m
index|[
name|CGEM_NUM_RX_DESCS
index|]
decl_stmt|;
name|bus_dmamap_t
name|rxring_m_dmamap
index|[
name|CGEM_NUM_RX_DESCS
index|]
decl_stmt|;
name|int
name|rxring_hd_ptr
decl_stmt|;
comment|/* where to put rcv bufs */
name|int
name|rxring_tl_ptr
decl_stmt|;
comment|/* where to get receives */
name|int
name|rxring_queued
decl_stmt|;
comment|/* how many rcv bufs queued */
name|bus_dmamap_t
name|rxring_dma_map
decl_stmt|;
name|int
name|rxbufs
decl_stmt|;
comment|/* tunable number rcv bufs */
name|int
name|rxoverruns
decl_stmt|;
comment|/* rx ring overruns */
comment|/* transmit descriptor ring */
name|struct
name|cgem_tx_desc
modifier|*
name|txring
decl_stmt|;
name|bus_addr_t
name|txring_physaddr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|txring_m
index|[
name|CGEM_NUM_TX_DESCS
index|]
decl_stmt|;
name|bus_dmamap_t
name|txring_m_dmamap
index|[
name|CGEM_NUM_TX_DESCS
index|]
decl_stmt|;
name|int
name|txring_hd_ptr
decl_stmt|;
comment|/* where to put next xmits */
name|int
name|txring_tl_ptr
decl_stmt|;
comment|/* next xmit mbuf to free */
name|int
name|txring_queued
decl_stmt|;
comment|/* num xmits segs queued */
name|bus_dmamap_t
name|txring_dma_map
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RD4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|)
value|(bus_read_4((sc)->mem_res, (off)))
end_define

begin_define
define|#
directive|define
name|WR4
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|val
parameter_list|)
value|(bus_write_4((sc)->mem_res, (off), (val)))
end_define

begin_define
define|#
directive|define
name|BARRIER
parameter_list|(
name|sc
parameter_list|,
name|off
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|)
define|\
value|(bus_barrier((sc)->mem_res, (off), (len), (flags))
end_define

begin_define
define|#
directive|define
name|CGEM_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CGEM_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CGEM_LOCK_INIT
parameter_list|(
name|sc
parameter_list|)
define|\
value|mtx_init(&(sc)->sc_mtx, device_get_nameunit((sc)->dev), \ 		 MTX_NETWORK_LOCK, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|CGEM_LOCK_DESTROY
parameter_list|(
name|sc
parameter_list|)
value|mtx_destroy(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CGEM_ASSERT_LOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->sc_mtx, MA_OWNED)
end_define

begin_comment
comment|/* Allow platforms to optionally provide a way to set the reference clock. */
end_comment

begin_function_decl
name|int
name|cgem_set_ref_clk
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|frequency
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|devclass_t
name|cgem_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|cgem_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cgem_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cgem_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgem_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cgem_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cgem_get_mac
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|eaddr
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|rnd
decl_stmt|;
comment|/* See if boot loader gave us a MAC address already. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|low
init|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_SPEC_ADDR_LOW
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|uint32_t
name|high
init|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_SPEC_ADDR_HI
argument_list|(
name|i
argument_list|)
argument_list|)
operator|&
literal|0xffff
decl_stmt|;
if|if
condition|(
name|low
operator|!=
literal|0
operator|||
name|high
operator|!=
literal|0
condition|)
block|{
name|eaddr
index|[
literal|0
index|]
operator|=
name|low
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
operator|(
name|low
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
operator|(
name|low
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|low
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|high
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
operator|(
name|high
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
block|}
block|}
comment|/* No MAC from boot loader?  Assign a random one. */
if|if
condition|(
name|i
operator|==
literal|4
condition|)
block|{
name|rnd
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
literal|'d'
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|rnd
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
operator|(
name|rnd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
name|rnd
operator|&
literal|0xff
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"no mac address found, assigning "
literal|"random: %02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|eaddr
index|[
literal|0
index|]
argument_list|,
name|eaddr
index|[
literal|1
index|]
argument_list|,
name|eaddr
index|[
literal|2
index|]
argument_list|,
name|eaddr
index|[
literal|3
index|]
argument_list|,
name|eaddr
index|[
literal|4
index|]
argument_list|,
name|eaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_SPEC_ADDR_LOW
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|eaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_SPEC_ADDR_HI
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|(
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|eaddr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* cgem_mac_hash():  map 48-bit address to a 6-bit hash.  * The 6-bit hash corresponds to a bit in a 64-bit hash  * register.  Setting that bit in the hash register enables  * reception of all frames with a destination address that hashes  * to that 6-bit value.  *  * The hash function is described in sec. 16.2.3 in the Zynq-7000 Tech  * Reference Manual.  Bits 0-5 in the hash are the exclusive-or of  * every sixth bit in the destination address.  */
end_comment

begin_function
specifier|static
name|int
name|cgem_mac_hash
parameter_list|(
name|u_char
name|eaddr
index|[]
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
literal|48
condition|;
name|j
operator|+=
literal|6
control|)
if|if
condition|(
operator|(
name|eaddr
index|[
name|j
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|&
literal|7
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|hash
operator|^=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* After any change in rx flags or multi-cast addresses, set up  * hash registers and net config register bits.  */
end_comment

begin_function
specifier|static
name|void
name|cgem_rx_filter
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|index
decl_stmt|;
name|uint32_t
name|hash_hi
decl_stmt|,
name|hash_lo
decl_stmt|;
name|uint32_t
name|net_cfg
decl_stmt|;
name|hash_hi
operator|=
literal|0
expr_stmt|;
name|hash_lo
operator|=
literal|0
expr_stmt|;
name|net_cfg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|)
expr_stmt|;
name|net_cfg
operator|&=
operator|~
operator|(
name|CGEM_NET_CFG_MULTI_HASH_EN
operator||
name|CGEM_NET_CFG_NO_BCAST
operator||
name|CGEM_NET_CFG_COPY_ALL
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|net_cfg
operator||=
name|CGEM_NET_CFG_COPY_ALL
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|==
literal|0
condition|)
name|net_cfg
operator||=
name|CGEM_NET_CFG_NO_BCAST
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|hash_hi
operator|=
literal|0xffffffff
expr_stmt|;
name|hash_lo
operator|=
literal|0xffffffff
expr_stmt|;
block|}
else|else
block|{
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|cgem_mac_hash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>
literal|31
condition|)
name|hash_hi
operator||=
operator|(
literal|1
operator|<<
operator|(
name|index
operator|-
literal|32
operator|)
operator|)
expr_stmt|;
else|else
name|hash_lo
operator||=
operator|(
literal|1
operator|<<
name|index
operator|)
expr_stmt|;
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hash_hi
operator|!=
literal|0
operator|||
name|hash_lo
operator|!=
literal|0
condition|)
name|net_cfg
operator||=
name|CGEM_NET_CFG_MULTI_HASH_EN
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_HASH_TOP
argument_list|,
name|hash_hi
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_HASH_BOT
argument_list|,
name|hash_lo
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
name|net_cfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For bus_dmamap_load() callback. */
end_comment

begin_function
specifier|static
name|void
name|cgem_getaddr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|nsegs
operator|!=
literal|1
operator|||
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create DMA'able descriptor rings. */
end_comment

begin_function
specifier|static
name|int
name|cgem_setup_descs
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|sc
operator|->
name|txring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|rxring
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate non-cached DMA space for RX and TX descriptors. 	 */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAX_DESC_RING_SIZE
argument_list|,
literal|1
argument_list|,
name|MAX_DESC_RING_SIZE
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
operator|&
name|sc
operator|->
name|desc_dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Set up a bus_dma_tag for mbufs. */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MCLBYTES
argument_list|,
name|TX_MAX_DMA_SEGS
argument_list|,
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
operator|&
name|sc
operator|->
name|mbuf_dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Allocate DMA memory in non-cacheable space. */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rxring
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|rxring_dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Load descriptor DMA memory. */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_dma_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|rxring
argument_list|,
name|CGEM_NUM_RX_DESCS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgem_rx_desc
argument_list|)
argument_list|,
name|cgem_getaddr
argument_list|,
operator|&
name|sc
operator|->
name|rxring_physaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Initialize RX descriptors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEM_NUM_RX_DESCS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rxring
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|CGEM_RXDESC_OWN
expr_stmt|;
name|sc
operator|->
name|rxring
index|[
name|i
index|]
operator|.
name|ctl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxring_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|sc
operator|->
name|rxring
index|[
name|CGEM_NUM_RX_DESCS
operator|-
literal|1
index|]
operator|.
name|addr
operator||=
name|CGEM_RXDESC_WRAP
expr_stmt|;
name|sc
operator|->
name|rxring_hd_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxring_tl_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxring_queued
operator|=
literal|0
expr_stmt|;
comment|/* Allocate DMA memory for TX descriptors in non-cacheable space. */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|txring
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|txring_dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Load TX descriptor DMA memory. */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
name|sc
operator|->
name|txring_dma_map
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|txring
argument_list|,
name|CGEM_NUM_TX_DESCS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgem_tx_desc
argument_list|)
argument_list|,
name|cgem_getaddr
argument_list|,
operator|&
name|sc
operator|->
name|txring_physaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Initialize TX descriptor ring. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEM_NUM_TX_DESCS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|txring
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txring
index|[
name|i
index|]
operator|.
name|ctl
operator|=
name|CGEM_TXDESC_USED
expr_stmt|;
name|sc
operator|->
name|txring_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|txring_m_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|sc
operator|->
name|txring
index|[
name|CGEM_NUM_TX_DESCS
operator|-
literal|1
index|]
operator|.
name|ctl
operator||=
name|CGEM_TXDESC_WRAP
expr_stmt|;
name|sc
operator|->
name|txring_hd_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txring_tl_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txring_queued
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fill receive descriptor ring with mbufs. */
end_comment

begin_function
specifier|static
name|void
name|cgem_fill_rqueue
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_DMA_SEGS
index|]
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|rxring_queued
operator|<
name|sc
operator|->
name|rxbufs
condition|)
block|{
comment|/* Get a cluster mbuf. */
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
comment|/* Load map and plug in physical address. */
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|sc
operator|->
name|rxring_hd_ptr
index|]
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
comment|/* XXX: warn? */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|rxring_m
index|[
name|sc
operator|->
name|rxring_hd_ptr
index|]
operator|=
name|m
expr_stmt|;
comment|/* Sync cache with receive buffer. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|sc
operator|->
name|rxring_hd_ptr
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Write rx descriptor and increment head pointer. */
name|sc
operator|->
name|rxring
index|[
name|sc
operator|->
name|rxring_hd_ptr
index|]
operator|.
name|ctl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxring_hd_ptr
operator|==
name|CGEM_NUM_RX_DESCS
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|rxring
index|[
name|sc
operator|->
name|rxring_hd_ptr
index|]
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator||
name|CGEM_RXDESC_WRAP
expr_stmt|;
name|sc
operator|->
name|rxring_hd_ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|rxring
index|[
name|sc
operator|->
name|rxring_hd_ptr
operator|++
index|]
operator|.
name|addr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
name|sc
operator|->
name|rxring_queued
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Pull received packets off of receive descriptor ring. */
end_comment

begin_function
specifier|static
name|void
name|cgem_recv
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Pick up all packets in which the OWN bit is set. */
while|while
condition|(
name|sc
operator|->
name|rxring_queued
operator|>
literal|0
operator|&&
operator|(
name|sc
operator|->
name|rxring
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
operator|.
name|addr
operator|&
name|CGEM_RXDESC_OWN
operator|)
operator|!=
literal|0
condition|)
block|{
name|ctl
operator|=
name|sc
operator|->
name|rxring
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
operator|.
name|ctl
expr_stmt|;
comment|/* Grab filled mbuf. */
name|m
operator|=
name|sc
operator|->
name|rxring_m
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
expr_stmt|;
name|sc
operator|->
name|rxring_m
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Sync cache with receive buffer. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Unload dmamap. */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
argument_list|)
expr_stmt|;
comment|/* Increment tail pointer. */
if|if
condition|(
operator|++
name|sc
operator|->
name|rxring_tl_ptr
operator|==
name|CGEM_NUM_RX_DESCS
condition|)
name|sc
operator|->
name|rxring_tl_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxring_queued
operator|--
expr_stmt|;
comment|/* Check FCS and make sure entire packet landed in one mbuf 		 * cluster (which is much bigger than the largest ethernet 		 * packet). 		 */
if|if
condition|(
operator|(
name|ctl
operator|&
name|CGEM_RXDESC_BAD_FCS
operator|)
operator|!=
literal|0
operator|||
operator|(
name|ctl
operator|&
operator|(
name|CGEM_RXDESC_SOF
operator||
name|CGEM_RXDESC_EOF
operator|)
operator|)
operator|!=
operator|(
name|CGEM_RXDESC_SOF
operator||
name|CGEM_RXDESC_EOF
operator|)
condition|)
block|{
comment|/* discard. */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Hand it off to upper layers. */
name|m
operator|->
name|m_data
operator|+=
name|ETHER_ALIGN
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
operator|(
name|ctl
operator|&
name|CGEM_RXDESC_LENGTH_MASK
operator|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
comment|/* Are we using hardware checksumming?  Check the 		 * status in the receive descriptor. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* TCP or UDP checks out, IP checks out too. */
if|if
condition|(
operator|(
name|ctl
operator|&
name|CGEM_RXDESC_CKSUM_STAT_MASK
operator|)
operator|==
name|CGEM_RXDESC_CKSUM_STAT_TCP_GOOD
operator|||
operator|(
name|ctl
operator|&
name|CGEM_RXDESC_CKSUM_STAT_MASK
operator|)
operator|==
name|CGEM_RXDESC_CKSUM_STAT_UDP_GOOD
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ctl
operator|&
name|CGEM_RXDESC_CKSUM_STAT_MASK
operator|)
operator|==
name|CGEM_RXDESC_CKSUM_STAT_IP_GOOD
condition|)
block|{
comment|/* Only IP checks out. */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find completed transmits and free their mbufs. */
end_comment

begin_function
specifier|static
name|void
name|cgem_clean_tx
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* free up finished transmits. */
while|while
condition|(
name|sc
operator|->
name|txring_queued
operator|>
literal|0
operator|&&
operator|(
operator|(
name|ctl
operator|=
name|sc
operator|->
name|txring
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
operator|.
name|ctl
operator|)
operator|&
name|CGEM_TXDESC_USED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Sync cache.  nop? */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Unload DMA map. */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
argument_list|)
expr_stmt|;
comment|/* Free up the mbuf. */
name|m
operator|=
name|sc
operator|->
name|txring_m
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
expr_stmt|;
name|sc
operator|->
name|txring_m
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Check the status. */
if|if
condition|(
operator|(
name|ctl
operator|&
name|CGEM_TXDESC_AHB_ERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Serious bus error. log to console. */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"cgem_clean_tx: Whoa! "
literal|"AHB error, addr=0x%x\n"
argument_list|,
name|sc
operator|->
name|txring
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ctl
operator|&
operator|(
name|CGEM_TXDESC_RETRY_ERR
operator||
name|CGEM_TXDESC_LATE_COLL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
comment|/* If the packet spanned more than one tx descriptor, 		 * skip descriptors until we find the end so that only 		 * start-of-frame descriptors are processed. 		 */
while|while
condition|(
operator|(
name|ctl
operator|&
name|CGEM_TXDESC_LAST_BUF
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ctl
operator|&
name|CGEM_TXDESC_WRAP
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|txring_tl_ptr
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|txring_tl_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|txring_queued
operator|--
expr_stmt|;
name|ctl
operator|=
name|sc
operator|->
name|txring
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
operator|.
name|ctl
expr_stmt|;
name|sc
operator|->
name|txring
index|[
name|sc
operator|->
name|txring_tl_ptr
index|]
operator|.
name|ctl
operator|=
name|ctl
operator||
name|CGEM_TXDESC_USED
expr_stmt|;
block|}
comment|/* Next descriptor. */
if|if
condition|(
operator|(
name|ctl
operator|&
name|CGEM_TXDESC_WRAP
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|txring_tl_ptr
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|txring_tl_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|txring_queued
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start transmits. */
end_comment

begin_function
specifier|static
name|void
name|cgem_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_DMA_SEGS
index|]
decl_stmt|;
name|uint32_t
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsegs
decl_stmt|,
name|wrap
decl_stmt|,
name|err
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Check that there is room in the descriptor ring. */
if|if
condition|(
name|sc
operator|->
name|txring_queued
operator|>=
name|CGEM_NUM_TX_DESCS
operator|-
name|TX_MAX_DMA_SEGS
operator|-
literal|1
condition|)
block|{
comment|/* Try to make room. */
name|cgem_clean_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Still no room? */
if|if
condition|(
name|sc
operator|->
name|txring_queued
operator|>=
name|CGEM_NUM_TX_DESCS
operator|-
name|TX_MAX_DMA_SEGS
operator|-
literal|1
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Grab next transmit packet. */
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* Load DMA map. */
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|sc
operator|->
name|txring_hd_ptr
index|]
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EFBIG
condition|)
block|{
comment|/* Too many segments!  defrag and try again. */
name|struct
name|mbuf
modifier|*
name|m2
init|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|m2
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|sc
operator|->
name|txring_hd_ptr
index|]
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* Give up. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|txring_m
index|[
name|sc
operator|->
name|txring_hd_ptr
index|]
operator|=
name|m
expr_stmt|;
comment|/* Sync tx buffer with cache. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|sc
operator|->
name|txring_hd_ptr
index|]
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Set wrap flag if next packet might run off end of ring. */
name|wrap
operator|=
name|sc
operator|->
name|txring_hd_ptr
operator|+
name|nsegs
operator|+
name|TX_MAX_DMA_SEGS
operator|>=
name|CGEM_NUM_TX_DESCS
expr_stmt|;
comment|/* Fill in the TX descriptors back to front so that USED 		 * bit in first descriptor is cleared last. 		 */
for|for
control|(
name|i
operator|=
name|nsegs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Descriptor address. */
name|sc
operator|->
name|txring
index|[
name|sc
operator|->
name|txring_hd_ptr
operator|+
name|i
index|]
operator|.
name|addr
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
comment|/* Descriptor control word. */
name|ctl
operator|=
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nsegs
operator|-
literal|1
condition|)
block|{
name|ctl
operator||=
name|CGEM_TXDESC_LAST_BUF
expr_stmt|;
if|if
condition|(
name|wrap
condition|)
name|ctl
operator||=
name|CGEM_TXDESC_WRAP
expr_stmt|;
block|}
name|sc
operator|->
name|txring
index|[
name|sc
operator|->
name|txring_hd_ptr
operator|+
name|i
index|]
operator|.
name|ctl
operator|=
name|ctl
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|sc
operator|->
name|txring_m
index|[
name|sc
operator|->
name|txring_hd_ptr
operator|+
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|wrap
condition|)
name|sc
operator|->
name|txring_hd_ptr
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|txring_hd_ptr
operator|+=
name|nsegs
expr_stmt|;
name|sc
operator|->
name|txring_queued
operator|+=
name|nsegs
expr_stmt|;
comment|/* Kick the transmitter. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CTRL
argument_list|,
name|sc
operator|->
name|net_ctl_shadow
operator||
name|CGEM_NET_CTRL_START_TX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cgem_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cgem_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cgem_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Poll the phy. */
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
block|}
comment|/* Next callout in one second. */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
name|hz
argument_list|,
name|cgem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interrupt handler. */
end_comment

begin_function
specifier|static
name|void
name|cgem_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|istatus
decl_stmt|;
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|istatus
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_INTR_STAT
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_INTR_STAT
argument_list|,
name|istatus
operator|&
operator|(
name|CGEM_INTR_RX_COMPLETE
operator||
name|CGEM_INTR_TX_USED_READ
operator||
name|CGEM_INTR_RX_OVERRUN
operator||
name|CGEM_INTR_HRESP_NOT_OK
operator|)
argument_list|)
expr_stmt|;
comment|/* Hresp not ok.  Something very bad with DMA.  Try to clear. */
if|if
condition|(
operator|(
name|istatus
operator|&
name|CGEM_INTR_HRESP_NOT_OK
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cgem_intr: hresp not okay! rx_status=0x%x\n"
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_RX_STAT
argument_list|)
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_RX_STAT
argument_list|,
name|CGEM_RX_STAT_HRESP_NOT_OK
argument_list|)
expr_stmt|;
block|}
comment|/* Transmitter has idled.  Free up any spent transmit buffers. */
if|if
condition|(
operator|(
name|istatus
operator|&
name|CGEM_INTR_TX_USED_READ
operator|)
operator|!=
literal|0
condition|)
name|cgem_clean_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Packets received or overflow. */
if|if
condition|(
operator|(
name|istatus
operator|&
operator|(
name|CGEM_INTR_RX_COMPLETE
operator||
name|CGEM_INTR_RX_OVERRUN
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cgem_recv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cgem_fill_rqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|istatus
operator|&
name|CGEM_INTR_RX_OVERRUN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clear rx status register. */
name|sc
operator|->
name|rxoverruns
operator|++
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_RX_STAT
argument_list|,
name|CGEM_RX_STAT_ALL
argument_list|)
expr_stmt|;
block|}
block|}
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset hardware. */
end_comment

begin_function
specifier|static
name|void
name|cgem_reset
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CTRL
argument_list|,
name|CGEM_NET_CTRL_CLR_STAT_REGS
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_TX_STAT
argument_list|,
name|CGEM_TX_STAT_ALL
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_RX_STAT
argument_list|,
name|CGEM_RX_STAT_ALL
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_INTR_DIS
argument_list|,
name|CGEM_INTR_ALL
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_HASH_BOT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_HASH_TOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_TX_QBAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* manual says do this. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_RX_QBAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get management port running even if interface is down. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
name|CGEM_NET_CFG_DBUS_WIDTH_32
operator||
name|CGEM_NET_CFG_MDC_CLK_DIV_64
argument_list|)
expr_stmt|;
name|sc
operator|->
name|net_ctl_shadow
operator|=
name|CGEM_NET_CTRL_MGMT_PORT_EN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CTRL
argument_list|,
name|sc
operator|->
name|net_ctl_shadow
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bring up the hardware. */
end_comment

begin_function
specifier|static
name|void
name|cgem_config
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|net_cfg
decl_stmt|;
name|uint32_t
name|dma_cfg
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program Net Config Register. */
name|net_cfg
operator|=
name|CGEM_NET_CFG_DBUS_WIDTH_32
operator||
name|CGEM_NET_CFG_MDC_CLK_DIV_64
operator||
name|CGEM_NET_CFG_FCS_REMOVE
operator||
name|CGEM_NET_CFG_RX_BUF_OFFSET
argument_list|(
name|ETHER_ALIGN
argument_list|)
operator||
name|CGEM_NET_CFG_GIGE_EN
operator||
name|CGEM_NET_CFG_FULL_DUPLEX
operator||
name|CGEM_NET_CFG_SPEED100
expr_stmt|;
comment|/* Enable receive checksum offloading? */
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|net_cfg
operator||=
name|CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
name|net_cfg
argument_list|)
expr_stmt|;
comment|/* Program DMA Config Register. */
name|dma_cfg
operator|=
name|CGEM_DMA_CFG_RX_BUF_SIZE
argument_list|(
name|MCLBYTES
argument_list|)
operator||
name|CGEM_DMA_CFG_RX_PKTBUF_MEMSZ_SEL_8K
operator||
name|CGEM_DMA_CFG_TX_PKTBUF_MEMSZ_SEL
operator||
name|CGEM_DMA_CFG_AHB_FIXED_BURST_LEN_16
expr_stmt|;
comment|/* Enable transmit checksum offloading? */
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
name|dma_cfg
operator||=
name|CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_DMA_CFG
argument_list|,
name|dma_cfg
argument_list|)
expr_stmt|;
comment|/* Write the rx and tx descriptor ring addresses to the QBAR regs. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_RX_QBAR
argument_list|,
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|rxring_physaddr
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_TX_QBAR
argument_list|,
operator|(
name|uint32_t
operator|)
name|sc
operator|->
name|txring_physaddr
argument_list|)
expr_stmt|;
comment|/* Enable rx and tx. */
name|sc
operator|->
name|net_ctl_shadow
operator||=
operator|(
name|CGEM_NET_CTRL_TX_EN
operator||
name|CGEM_NET_CTRL_RX_EN
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CTRL
argument_list|,
name|sc
operator|->
name|net_ctl_shadow
argument_list|)
expr_stmt|;
comment|/* Set up interrupts. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_INTR_EN
argument_list|,
name|CGEM_INTR_RX_COMPLETE
operator||
name|CGEM_INTR_TX_USED_READ
operator||
name|CGEM_INTR_RX_OVERRUN
operator||
name|CGEM_INTR_HRESP_NOT_OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn on interface and load up receive ring with buffers. */
end_comment

begin_function
specifier|static
name|void
name|cgem_init_locked
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
name|cgem_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cgem_fill_rqueue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|cgem_start_locked
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
name|hz
argument_list|,
name|cgem_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cgem_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cgem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Turn off interface.  Free up any buffers in transmit or receive queues. */
end_comment

begin_function
specifier|static
name|void
name|cgem_stop
parameter_list|(
name|struct
name|cgem_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CGEM_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
comment|/* Shut down hardware. */
name|cgem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Clear out transmit queue. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEM_NUM_TX_DESCS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|txring
index|[
name|i
index|]
operator|.
name|ctl
operator|=
name|CGEM_TXDESC_USED
expr_stmt|;
name|sc
operator|->
name|txring
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txring_m
index|[
name|i
index|]
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|txring_m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txring_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|txring
index|[
name|CGEM_NUM_TX_DESCS
operator|-
literal|1
index|]
operator|.
name|ctl
operator||=
name|CGEM_TXDESC_WRAP
expr_stmt|;
name|sc
operator|->
name|txring_hd_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txring_tl_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txring_queued
operator|=
literal|0
expr_stmt|;
comment|/* Clear out receive queue. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEM_NUM_RX_DESCS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|rxring
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|CGEM_RXDESC_OWN
expr_stmt|;
name|sc
operator|->
name|rxring
index|[
name|i
index|]
operator|.
name|ctl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|rxring_m
index|[
name|i
index|]
condition|)
block|{
comment|/* Unload dmamap. */
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|sc
operator|->
name|rxring_tl_ptr
index|]
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|rxring_m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxring_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|rxring
index|[
name|CGEM_NUM_RX_DESCS
operator|-
literal|1
index|]
operator|.
name|addr
operator||=
name|CGEM_RXDESC_WRAP
expr_stmt|;
name|sc
operator|->
name|rxring_hd_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxring_tl_ptr
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rxring_queued
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|mask
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|if_old_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cgem_rx_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|cgem_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|cgem_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|if_old_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* Set up multi-cast filters. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cgem_rx_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifp
operator|->
name|if_capenable
operator|^
name|ifr
operator|->
name|ifr_reqcap
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Turn on TX checksumming. */
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TXCSUM_IPV6
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CGEM_CKSUM_ASSIST
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_DMA_CFG
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_DMA_CFG
argument_list|)
operator||
name|CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off TX checksumming. */
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TXCSUM_IPV6
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CGEM_CKSUM_ASSIST
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_DMA_CFG
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_DMA_CFG
argument_list|)
operator|&
operator|~
name|CGEM_DMA_CFG_CHKSUM_GEN_OFFLOAD_EN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Turn on RX checksumming. */
name|ifp
operator|->
name|if_capenable
operator||=
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|)
operator||
name|CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn off RX checksumming. */
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|)
operator|&
operator|~
name|CGEM_NET_CFG_RX_CHKSUM_OFFLD_EN
argument_list|)
expr_stmt|;
block|}
block|}
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MII bus support routines.  */
end_comment

begin_function
specifier|static
name|void
name|cgem_child_detached
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|sc
operator|->
name|miibus
condition|)
name|sc
operator|->
name|miibus
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_ifmedia_upd
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cgem_ifmedia_sts
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cgem_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|tries
decl_stmt|,
name|val
decl_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_PHY_MAINT
argument_list|,
name|CGEM_PHY_MAINT_CLAUSE_22
operator||
name|CGEM_PHY_MAINT_MUST_10
operator||
name|CGEM_PHY_MAINT_OP_READ
operator||
operator|(
name|phy
operator|<<
name|CGEM_PHY_MAINT_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|CGEM_PHY_MAINT_REG_ADDR_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
name|tries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_STAT
argument_list|)
operator|&
name|CGEM_NET_STAT_PHY_MGMT_IDLE
operator|)
operator|==
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|tries
operator|>
literal|200
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"phy read timeout: %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_PHY_MAINT
argument_list|)
operator|&
name|CGEM_PHY_MAINT_DATA_MASK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_PHY_MAINT
argument_list|,
name|CGEM_PHY_MAINT_CLAUSE_22
operator||
name|CGEM_PHY_MAINT_MUST_10
operator||
name|CGEM_PHY_MAINT_OP_WRITE
operator||
operator|(
name|phy
operator|<<
name|CGEM_PHY_MAINT_PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|CGEM_PHY_MAINT_REG_ADDR_SHIFT
operator|)
operator||
operator|(
name|data
operator|&
name|CGEM_PHY_MAINT_DATA_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for completion. */
name|tries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_STAT
argument_list|)
operator|&
name|CGEM_NET_STAT_PHY_MGMT_IDLE
operator|)
operator|==
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|tries
operator|>
literal|200
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"phy write timeout: %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Overridable weak symbol cgem_set_ref_clk().  This allows platforms to  * provide a function to set the cgem's reference clock.  */
end_comment

begin_function
specifier|static
name|int
name|__used
name|cgem_default_set_ref_clk
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|frequency
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|__weak_reference
argument_list|(
name|cgem_default_set_ref_clk
argument_list|,
name|cgem_set_ref_clk
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cgem_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|net_cfg
decl_stmt|;
name|int
name|ref_clk_freq
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_AVALID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Update hardware to reflect phy status. */
name|net_cfg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|)
expr_stmt|;
name|net_cfg
operator|&=
operator|~
operator|(
name|CGEM_NET_CFG_SPEED100
operator||
name|CGEM_NET_CFG_GIGE_EN
operator||
name|CGEM_NET_CFG_FULL_DUPLEX
operator|)
expr_stmt|;
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_T
case|:
name|net_cfg
operator||=
operator|(
name|CGEM_NET_CFG_SPEED100
operator||
name|CGEM_NET_CFG_GIGE_EN
operator|)
expr_stmt|;
name|ref_clk_freq
operator|=
literal|125000000
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|net_cfg
operator||=
name|CGEM_NET_CFG_SPEED100
expr_stmt|;
name|ref_clk_freq
operator|=
literal|25000000
expr_stmt|;
break|break;
default|default:
name|ref_clk_freq
operator|=
literal|2500000
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_active
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|net_cfg
operator||=
name|CGEM_NET_CFG_FULL_DUPLEX
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|CGEM_NET_CFG
argument_list|,
name|net_cfg
argument_list|)
expr_stmt|;
comment|/* Set the reference clock if necessary. */
if|if
condition|(
name|cgem_set_ref_clk
argument_list|(
name|sc
operator|->
name|ref_clk_num
argument_list|,
name|ref_clk_freq
argument_list|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set ref clk%d to %d.\n"
argument_list|,
name|sc
operator|->
name|ref_clk_num
argument_list|,
name|ref_clk_freq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"cadence,gem"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cadence CGEM Gigabit Ethernet Interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|pcell_t
name|cell
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|err
decl_stmt|;
name|u_char
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|CGEM_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get reference clock number and base divider from fdt. */
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ref_clk_num
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"ref-clock-num"
argument_list|,
operator|&
name|cell
argument_list|,
sizeof|sizeof
argument_list|(
name|cell
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|sc
operator|->
name|ref_clk_num
operator|=
name|fdt32_to_cpu
argument_list|(
name|cell
argument_list|)
expr_stmt|;
comment|/* Get memory resource. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resources.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Get IRQ resource. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate interrupt resource.\n"
argument_list|)
expr_stmt|;
name|cgem_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
name|cgem_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset hardware. */
name|cgem_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Attach phy to mii bus. */
name|err
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|ifp
argument_list|,
name|cgem_ifmedia_upd
argument_list|,
name|cgem_ifmedia_sts
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"attaching PHYs failed\n"
argument_list|)
expr_stmt|;
name|cgem_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Set up TX and RX descriptor area. */
name|err
operator|=
name|cgem_setup_descs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set up dma mem for descs.\n"
argument_list|)
expr_stmt|;
name|cgem_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Get a MAC address. */
name|cgem_get_mac
argument_list|(
name|sc
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Start ticks. */
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up ifnet structure. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|IF_CGEM_NAME
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|cgem_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|cgem_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|cgem_init
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_HWCSUM
operator||
name|IFCAP_HWCSUM_IPV6
expr_stmt|;
comment|/* XXX: disable hw checksumming for now. */
name|ifp
operator|->
name|if_hwassist
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
operator|&
operator|~
operator|(
name|IFCAP_HWCSUM
operator||
name|IFCAP_HWCSUM_IPV6
operator|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|IFQ_MAXLEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|if_old_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|sc
operator|->
name|rxbufs
operator|=
name|DEFAULT_NUM_RX_BUFS
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
operator||
name|INTR_EXCL
argument_list|,
name|NULL
argument_list|,
name|cgem_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set interrupt handler.\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|cgem_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxbufs"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|rxbufs
argument_list|,
literal|0
argument_list|,
literal|"Number receive buffers to provide"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"_rxoverruns"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|rxoverruns
argument_list|,
literal|0
argument_list|,
literal|"Receive ring overrun events"
argument_list|)
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cgem_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|cgem_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|CGEM_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|cgem_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CGEM_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|miibus
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|miibus
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Release resrouces. */
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Release DMA resources. */
if|if
condition|(
name|sc
operator|->
name|rxring
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|rxring_physaddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_dma_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxring_physaddr
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
name|sc
operator|->
name|rxring
argument_list|,
name|sc
operator|->
name|rxring_dma_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxring
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEM_NUM_RX_DESCS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxring_m_dmamap
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|txring
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|txring_physaddr
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
name|sc
operator|->
name|txring_dma_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txring_physaddr
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|,
name|sc
operator|->
name|txring
argument_list|,
name|sc
operator|->
name|txring_dma_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txring
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CGEM_NUM_TX_DESCS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|txring_m_dmamap
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|,
name|sc
operator|->
name|txring_m_dmamap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txring_m_dmamap
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|desc_dma_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|desc_dma_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|desc_dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|mbuf_dma_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|mbuf_dma_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mbuf_dma_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|CGEM_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|cgem_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|cgem_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|cgem_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|cgem_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_child_detached
argument_list|,
name|cgem_child_detached
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|cgem_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|cgem_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|cgem_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|cgem_driver
init|=
block|{
literal|"cgem"
block|,
name|cgem_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|cgem_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|cgem
argument_list|,
name|simplebus
argument_list|,
name|cgem_driver
argument_list|,
name|cgem_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|cgem
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cgem
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cgem
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

