begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * $FreeBSD$  *  *  This driver and the associated header files support the ISA PC/Xem  *  Digiboards.  Its evolutionary roots are described below.  *  Jack O'Neill<jack@diamond.xtalwind.net>  *  *  Digiboard driver.  *  *  Stage 1. "Better than nothing".  *  Stage 2. "Gee, it works!".  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions of binary code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, in the accompanying documentation.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  Written by Sergey Babkin,  *      Joint Stock Commercial Bank "Chelindbank"  *      (Chelyabinsk, Russia)  *      babkin@freebsd.org  *  *  Assorted hacks to make it more functional and working under 3.0-current.  *  Fixed broken routines to prevent processes hanging on closed (thanks  *  to Bruce for his patience and assistance). Thanks also to Maxim Bolotin  *<max@run.net> for his patches which did most of the work to get this  *  running under 2.2/3.0-current.  *  Implemented ioctls: TIOCMSDTRWAIT, TIOCMGDTRWAIT, TIOCTIMESTAMP&  *  TIOCDCDTIMESTAMP.  *  Sysctl debug flag is now a bitflag, to filter noise during debugging.  *	David L. Nugent<davidn@blaze.net.au>  *  * New-busification by Brian Somers<brian@Awfulhak.org>  *  * There was a copyright confusion: I thought that having read the  * GLPed drivers makes me mentally contaminated but in fact it does  * not. Since the Linux driver by Troy De Jongh<troyd@digibd.com> or  *<troyd@skypoint.com> was used only to learn the Digi's interface,  * I've returned this driver to a BSD-style license. I tried to contact  * all the contributors and those who replied agreed with license  * change. If you did any contribution when the driver was GPLed and do  * not agree with the BSD-style re-licensing please contact me.  *  -SB  */
end_comment

begin_comment
comment|/* How often to run dgmpoll */
end_comment

begin_define
define|#
directive|define
name|POLLSPERSEC
value|25
end_define

begin_comment
comment|/* How many charactes can we write to input tty rawq */
end_comment

begin_define
define|#
directive|define
name|DGB_IBUFSIZE
value|(TTYHOG - 100)
end_define

begin_comment
comment|/* the overall number of ports controlled by this driver */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/dgb/dgmfep.h>
end_include

begin_include
include|#
directive|include
file|<dev/dgb/dgmbios.h>
end_include

begin_include
include|#
directive|include
file|<dev/dgb/dgmreg.h>
end_include

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x40000
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0xC0
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x80
end_define

begin_define
define|#
directive|define
name|UNIT_MASK
value|0x30000
end_define

begin_define
define|#
directive|define
name|PORT_MASK
value|0x3F
end_define

begin_define
define|#
directive|define
name|DEV_TO_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev)))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_UNIT
parameter_list|(
name|mynor
parameter_list|)
value|(((mynor)& UNIT_MASK)>> 16)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_PORT
parameter_list|(
name|mynor
parameter_list|)
value|((mynor)& PORT_MASK)
end_define

begin_define
define|#
directive|define
name|IO_SIZE
value|0x04
end_define

begin_define
define|#
directive|define
name|MEM_SIZE
value|0x8000
end_define

begin_struct_decl
struct_decl|struct
name|dgm_softc
struct_decl|;
end_struct_decl

begin_comment
comment|/* digiboard port structure */
end_comment

begin_struct
struct|struct
name|dgm_p
block|{
name|unsigned
name|enabled
range|:
literal|1
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
comment|/* parent softc */
name|u_char
name|pnum
decl_stmt|;
comment|/* port number */
name|u_char
name|omodem
decl_stmt|;
comment|/* FEP output modem status     */
name|u_char
name|imodem
decl_stmt|;
comment|/* FEP input modem status      */
name|u_char
name|modemfake
decl_stmt|;
comment|/* Modem values to be forced   */
name|u_char
name|modem
decl_stmt|;
comment|/* Force values                */
name|u_char
name|hflow
decl_stmt|;
name|u_char
name|dsr
decl_stmt|;
name|u_char
name|dcd
decl_stmt|;
name|u_char
name|stopc
decl_stmt|;
name|u_char
name|startc
decl_stmt|;
name|u_char
name|stopca
decl_stmt|;
name|u_char
name|startca
decl_stmt|;
name|u_char
name|fepstopc
decl_stmt|;
name|u_char
name|fepstartc
decl_stmt|;
name|u_char
name|fepstopca
decl_stmt|;
name|u_char
name|fepstartca
decl_stmt|;
name|u_char
name|txwin
decl_stmt|;
name|u_char
name|rxwin
decl_stmt|;
name|ushort
name|fepiflag
decl_stmt|;
name|ushort
name|fepcflag
decl_stmt|;
name|ushort
name|fepoflag
decl_stmt|;
name|ushort
name|txbufhead
decl_stmt|;
name|ushort
name|txbufsize
decl_stmt|;
name|ushort
name|rxbufhead
decl_stmt|;
name|ushort
name|rxbufsize
decl_stmt|;
name|int
name|close_delay
decl_stmt|;
name|u_char
modifier|*
name|txptr
decl_stmt|;
name|u_char
modifier|*
name|rxptr
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|brdchan
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|u_char
name|active_out
decl_stmt|;
comment|/* nonzero if the callout device is open */
name|u_int
name|wopeners
decl_stmt|;
comment|/* # processes waiting for DCD in open() */
comment|/* Initial state. */
name|struct
name|termios
name|it_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|it_out
decl_stmt|;
comment|/* Lock state. */
name|struct
name|termios
name|lt_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|lt_out
decl_stmt|;
name|unsigned
name|do_timestamp
range|:
literal|1
decl_stmt|;
name|unsigned
name|do_dcd_timestamp
range|:
literal|1
decl_stmt|;
name|struct
name|timeval
name|timestamp
decl_stmt|;
name|struct
name|timeval
name|dcd_timestamp
decl_stmt|;
comment|/* flags of state, are used in sleep() too */
name|u_char
name|closing
decl_stmt|;
comment|/* port is being closed now */
name|u_char
name|draining
decl_stmt|;
comment|/* port is being drained now */
name|u_char
name|used
decl_stmt|;
comment|/* port is being used now */
name|u_char
name|mustdrain
decl_stmt|;
comment|/* data must be waited to drain in dgmparam() */
block|}
struct|;
end_struct

begin_comment
comment|/* Digiboard per-board structure */
end_comment

begin_struct
struct|struct
name|dgm_softc
block|{
comment|/* struct board_info */
name|unsigned
name|enabled
range|:
literal|1
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
comment|/* unit number */
name|u_char
name|type
decl_stmt|;
comment|/* type of card: PCXE, PCXI, PCXEVE */
name|u_char
name|altpin
decl_stmt|;
comment|/* do we need alternate pin setting ? */
name|int
name|numports
decl_stmt|;
comment|/* number of ports on card */
name|u_long
name|port
decl_stmt|;
comment|/* I/O port */
name|u_char
modifier|*
name|vmem
decl_stmt|;
comment|/* virtual memory address */
name|u_long
name|pmem
decl_stmt|;
comment|/* physical memory address */
name|int
name|mem_seg
decl_stmt|;
comment|/* internal memory segment */
name|struct
name|dgm_p
modifier|*
name|ports
decl_stmt|;
comment|/* ptr to array of port descriptors */
name|struct
name|tty
modifier|*
name|ttys
decl_stmt|;
comment|/* ptr to array of TTY structures */
specifier|volatile
name|struct
name|global_data
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|resource
modifier|*
name|io_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|int
name|iorid
decl_stmt|;
name|int
name|mrid
decl_stmt|;
name|struct
name|callout_handle
name|toh
decl_stmt|;
comment|/* poll timeout handle */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|dgmpoll
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgmprobe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgmattach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgmdetach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgmshutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fepcmd
parameter_list|(
name|struct
name|dgm_p
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgmstart
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgmstop
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgmparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgmhardclose
parameter_list|(
name|struct
name|dgm_p
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgm_drain_or_flush
parameter_list|(
name|struct
name|dgm_p
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgmdrain
parameter_list|(
name|struct
name|dgm_p
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgm_pause
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wakeflush
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disc_optim
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|dgmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dgmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dgmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|dgmmethods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|dgmprobe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|dgmattach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|dgmdetach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|dgmshutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|dgmdriver
init|=
block|{
literal|"dgm"
block|,
name|dgmmethods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dgm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|dgmdevclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|101
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|dgm_cdevsw
init|=
block|{
comment|/* open */
name|dgmopen
block|,
comment|/* close */
name|dgmclose
block|,
comment|/* read */
name|ttyread
block|,
comment|/* write */
name|ttywrite
block|,
comment|/* ioctl */
name|dgmioctl
block|,
comment|/* poll */
name|ttypoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"dgm"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_TTY
operator||
name|D_KQFILTER
block|,
comment|/* bmaj */
operator|-
literal|1
block|,
comment|/* kqfilter */
name|ttykqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dgmmodhandler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|cdevsw_add
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|cdevsw_remove
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|dgm
argument_list|,
name|isa
argument_list|,
name|dgmdriver
argument_list|,
name|dgmdevclass
argument_list|,
name|dgmmodhandler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|speed_t
name|dgmdefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|dgmspeedtab
index|[]
init|=
block|{
block|{
literal|0
block|,
name|FEP_B0
block|}
block|,
comment|/* old (sysV-like) Bx codes */
block|{
literal|50
block|,
name|FEP_B50
block|}
block|,
block|{
literal|75
block|,
name|FEP_B75
block|}
block|,
block|{
literal|110
block|,
name|FEP_B110
block|}
block|,
block|{
literal|134
block|,
name|FEP_B134
block|}
block|,
block|{
literal|150
block|,
name|FEP_B150
block|}
block|,
block|{
literal|200
block|,
name|FEP_B200
block|}
block|,
block|{
literal|300
block|,
name|FEP_B300
block|}
block|,
block|{
literal|600
block|,
name|FEP_B600
block|}
block|,
block|{
literal|1200
block|,
name|FEP_B1200
block|}
block|,
block|{
literal|1800
block|,
name|FEP_B1800
block|}
block|,
block|{
literal|2400
block|,
name|FEP_B2400
block|}
block|,
block|{
literal|4800
block|,
name|FEP_B4800
block|}
block|,
block|{
literal|9600
block|,
name|FEP_B9600
block|}
block|,
block|{
literal|19200
block|,
name|FEP_B19200
block|}
block|,
block|{
literal|38400
block|,
name|FEP_B38400
block|}
block|,
block|{
literal|57600
block|,
operator|(
name|FEP_FASTBAUD
operator||
name|FEP_B50
operator|)
block|}
block|,
comment|/* B50& fast baud table */
block|{
literal|115200
block|,
operator|(
name|FEP_FASTBAUD
operator||
name|FEP_B110
operator|)
block|}
block|,
comment|/* B100& fast baud table */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|dbgflagtbl
block|{
name|tcflag_t
name|in_mask
decl_stmt|;
name|tcflag_t
name|in_val
decl_stmt|;
name|tcflag_t
name|out_val
decl_stmt|;
block|}
name|dgm_cflags
index|[]
init|=
block|{
block|{
name|PARODD
block|,
name|PARODD
block|,
name|FEP_PARODD
block|}
block|,
block|{
name|PARENB
block|,
name|PARENB
block|,
name|FEP_PARENB
block|}
block|,
block|{
name|CSTOPB
block|,
name|CSTOPB
block|,
name|FEP_CSTOPB
block|}
block|,
block|{
name|CSIZE
block|,
name|CS5
block|,
name|FEP_CS6
block|}
block|,
block|{
name|CSIZE
block|,
name|CS6
block|,
name|FEP_CS6
block|}
block|,
block|{
name|CSIZE
block|,
name|CS7
block|,
name|FEP_CS7
block|}
block|,
block|{
name|CSIZE
block|,
name|CS8
block|,
name|FEP_CS8
block|}
block|,
block|{
name|CLOCAL
block|,
name|CLOCAL
block|,
name|FEP_CLOCAL
block|}
block|,
block|{
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
block|}
block|}
struct|,
name|dgm_iflags
index|[]
init|=
block|{
block|{
name|IGNBRK
block|,
name|IGNBRK
block|,
name|FEP_IGNBRK
block|}
block|,
block|{
name|BRKINT
block|,
name|BRKINT
block|,
name|FEP_BRKINT
block|}
block|,
block|{
name|IGNPAR
block|,
name|IGNPAR
block|,
name|FEP_IGNPAR
block|}
block|,
block|{
name|PARMRK
block|,
name|PARMRK
block|,
name|FEP_PARMRK
block|}
block|,
block|{
name|INPCK
block|,
name|INPCK
block|,
name|FEP_INPCK
block|}
block|,
block|{
name|ISTRIP
block|,
name|ISTRIP
block|,
name|FEP_ISTRIP
block|}
block|,
block|{
name|IXON
block|,
name|IXON
block|,
name|FEP_IXON
block|}
block|,
block|{
name|IXOFF
block|,
name|IXOFF
block|,
name|FEP_IXOFF
block|}
block|,
block|{
name|IXANY
block|,
name|IXANY
block|,
name|FEP_IXANY
block|}
block|,
block|{
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
block|}
block|}
struct|,
name|dgm_flow
index|[]
init|=
block|{
block|{
name|CRTSCTS
block|,
name|CRTSCTS
block|,
name|CTS
operator||
name|RTS
block|}
block|,
block|{
name|CRTSCTS
block|,
name|CCTS_OFLOW
block|,
name|CTS
block|}
block|,
block|{
name|CRTSCTS
block|,
name|CRTS_IFLOW
block|,
name|RTS
block|}
block|,
block|{
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* xlat bsd termios flags to dgm sys-v style */
end_comment

begin_function
specifier|static
name|tcflag_t
name|dgmflags
parameter_list|(
name|struct
name|dbgflagtbl
modifier|*
name|tbl
parameter_list|,
name|tcflag_t
name|input
parameter_list|)
block|{
name|tcflag_t
name|output
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tbl
index|[
name|i
index|]
operator|.
name|in_mask
operator|!=
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|input
operator|&
name|tbl
index|[
name|i
index|]
operator|.
name|in_mask
operator|)
operator|==
name|tbl
index|[
name|i
index|]
operator|.
name|in_val
condition|)
name|output
operator||=
name|tbl
index|[
name|i
index|]
operator|.
name|out_val
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|dgmdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dgm_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dgmdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|int
name|setwin
parameter_list|(
name|struct
name|dgm_softc
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|hidewin
parameter_list|(
name|struct
name|dgm_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|towin
parameter_list|(
name|struct
name|dgm_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*Helg: to allow recursive dgm...() calls */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* If we were called and don't want to disturb we need: */
name|int
name|port
decl_stmt|;
comment|/* write to this port */
name|u_char
name|data
decl_stmt|;
comment|/* this data on exit */
comment|/* or DATA_WINOFF  to close memory window on entry */
block|}
name|BoardMemWinState
typedef|;
end_typedef

begin_comment
comment|/* so several channels and even boards can coexist */
end_comment

begin_define
define|#
directive|define
name|DATA_WINOFF
value|0
end_define

begin_decl_stmt
specifier|static
name|BoardMemWinState
name|bmws
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|validio
index|[]
init|=
block|{
literal|0x104
block|,
literal|0x114
block|,
literal|0x124
block|,
literal|0x204
block|,
literal|0x224
block|,
literal|0x304
block|,
literal|0x324
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|validmem
index|[]
init|=
block|{
literal|0x80000
block|,
literal|0x88000
block|,
literal|0x90000
block|,
literal|0x98000
block|,
literal|0xa0000
block|,
literal|0xa8000
block|,
literal|0xb0000
block|,
literal|0xb8000
block|,
literal|0xc0000
block|,
literal|0xc8000
block|,
literal|0xd0000
block|,
literal|0xd8000
block|,
literal|0xe0000
block|,
literal|0xe8000
block|,
literal|0xf0000
block|,
literal|0xf8000
block|,
literal|0xf0000000
block|,
literal|0xf1000000
block|,
literal|0xf2000000
block|,
literal|0xf3000000
block|,
literal|0xf4000000
block|,
literal|0xf5000000
block|,
literal|0xf6000000
block|,
literal|0xf7000000
block|,
literal|0xf8000000
block|,
literal|0xf9000000
block|,
literal|0xfa000000
block|,
literal|0xfb000000
block|,
literal|0xfc000000
block|,
literal|0xfd000000
block|,
literal|0xfe000000
block|,
literal|0xff000000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return current memory window state and close window */
end_comment

begin_function
specifier|static
name|BoardMemWinState
name|bmws_get
parameter_list|(
name|void
parameter_list|)
block|{
name|BoardMemWinState
name|bmwsRet
init|=
name|bmws
decl_stmt|;
if|if
condition|(
name|bmws
operator|.
name|data
operator|!=
name|DATA_WINOFF
condition|)
name|outb
argument_list|(
name|bmws
operator|.
name|port
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|DATA_WINOFF
argument_list|)
expr_stmt|;
return|return
name|bmwsRet
return|;
block|}
end_function

begin_comment
comment|/* restore memory window state */
end_comment

begin_function
specifier|static
name|void
name|bmws_set
parameter_list|(
name|BoardMemWinState
name|ws
parameter_list|)
block|{
if|if
condition|(
name|ws
operator|.
name|data
operator|!=
name|bmws
operator|.
name|data
operator|||
name|ws
operator|.
name|port
operator|!=
name|bmws
operator|.
name|port
condition|)
block|{
if|if
condition|(
name|bmws
operator|.
name|data
operator|!=
name|DATA_WINOFF
condition|)
name|outb
argument_list|(
name|bmws
operator|.
name|port
argument_list|,
name|DATA_WINOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|data
operator|!=
name|DATA_WINOFF
condition|)
name|outb
argument_list|(
name|ws
operator|.
name|port
argument_list|,
name|ws
operator|.
name|data
argument_list|)
expr_stmt|;
name|bmws
operator|=
name|ws
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|setwin
parameter_list|(
name|struct
name|dgm_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|)
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|15
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x7FFF
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hidewin
parameter_list|(
name|struct
name|dgm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bmws
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|towin
parameter_list|(
name|struct
name|dgm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|win
parameter_list|)
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgmprobe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dgm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|sc
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Check that we've got a valid i/o address */
if|if
condition|(
operator|(
name|sc
operator|->
name|port
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|validio
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|validio
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|sc
operator|->
name|port
operator|==
name|validio
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"0x%03lx: Invalid i/o address\n"
argument_list|,
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Ditto for our memory address */
if|if
condition|(
operator|(
name|sc
operator|->
name|pmem
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|validmem
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|validmem
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|sc
operator|->
name|pmem
operator|==
name|validmem
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"0x%lx: Invalid memory address\n"
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|pmem
operator|&
literal|0xFFFFFFul
operator|)
operator|!=
name|sc
operator|->
name|pmem
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"0x%lx: Memory address not supported\n"
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|vmem
operator|=
operator|(
name|u_char
operator|*
operator|)
name|sc
operator|->
name|pmem
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: port 0x%lx mem 0x%lx\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
comment|/* Temporarily map our io ports */
name|sc
operator|->
name|iorid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|io_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|iorid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|IO_SIZE
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|==
name|FEPRST
condition|)
block|{
name|sc
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgm%d: got reset after %d us\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|enabled
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgm%d: failed to respond\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* check type of card and get internal memory characteristics */
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|&
literal|0x1
operator|)
condition|)
block|{
name|int
name|second
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|second
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dgm%d: PC/Xem (type %d, %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|v
argument_list|,
name|second
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"dgm%d: PC/Xem (type %d)\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXEM
expr_stmt|;
name|sc
operator|->
name|mem_seg
operator|=
literal|0x8000
expr_stmt|;
comment|/* Temporarily map our memory too */
name|sc
operator|->
name|mrid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mrid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|MEM_SIZE
argument_list|,
name|RF_ALLOCATED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"0x%lx: Memory range is in use\n"
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
comment|/* drop RESET */
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Helg: to set initial bmws state */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|IO_SIZE
argument_list|)
expr_stmt|;
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|pmem
argument_list|,
name|MEM_SIZE
argument_list|)
expr_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: Probe returns 0\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgmattach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dgm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|u_char
modifier|*
name|mem
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|shrinkmem
decl_stmt|;
name|int
name|lowwater
decl_stmt|;
name|u_long
name|msize
decl_stmt|,
name|iosize
decl_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: attaching\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|port
argument_list|,
operator|&
name|iosize
argument_list|)
expr_stmt|;
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|pmem
argument_list|,
operator|&
name|msize
argument_list|)
expr_stmt|;
name|sc
operator|->
name|altpin
operator|=
operator|!
operator|!
operator|(
name|device_get_flags
argument_list|(
name|dev
argument_list|)
operator|&
name|DGBFLAG_ALTPIN
operator|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXEM
expr_stmt|;
name|sc
operator|->
name|mem_seg
operator|=
literal|0x8000
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXEM
expr_stmt|;
name|sc
operator|->
name|mem_seg
operator|=
literal|0x8000
expr_stmt|;
comment|/* Allocate resources (should have been verified in dgmprobe()) */
name|sc
operator|->
name|iorid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|io_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|iorid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|iosize
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|io_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|mrid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|mrid
argument_list|,
literal|0ul
argument_list|,
operator|~
literal|0ul
argument_list|,
name|msize
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"0x%lx: Memory range is in use\n"
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* map memory */
name|mem
operator|=
name|sc
operator|->
name|vmem
operator|=
name|pmap_mapdev
argument_list|(
name|sc
operator|->
name|pmem
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: internal memory segment 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|mem_seg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPRST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"1st reset failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: got reset after %d us\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|sc
operator|->
name|pmem
operator|>>
literal|8
expr_stmt|;
comment|/* disable windowing */
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
comment|/* very short memory test */
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: short memory test\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|BOTWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0xA55A3CC3
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0xA55A3CC3
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"1st memory test failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: 1st memory test ok\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|TOPWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"2nd memory test failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: 2nd memory test ok\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"3rd (BIOS) memory test failed\n"
argument_list|)
expr_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: 3rd memory test ok\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|mem
index|[
name|addr
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|BIOSOFFSET
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|mem
operator|+
name|msize
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcem_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|BIOSOFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|mem
operator|+
name|msize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
name|pcem_bios
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"Low BIOS load failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: pcem_bios seg 1 loaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|pcem_nbios
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcem_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
expr_stmt|;
for|for
control|(
name|i
operator|=
name|msize
operator|-
name|BIOSOFFSET
init|;
name|i
operator|<
name|pcem_nbios
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
name|pcem_bios
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"High BIOS load failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dbg%d: pcem_bios seg 2 loaded\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DigiBIOS loaded, initializing"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x0bf00401
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xc00
operator|)
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xc00
operator|)
operator|!=
literal|0x47
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3000
condition|)
block|{
name|printf
argument_list|(
literal|"\nBIOS initialize failed(1)\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xc01
operator|)
operator|!=
literal|0x44
condition|)
block|{
name|printf
argument_list|(
literal|"\nBIOS initialize failed(2)\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|", DigiBIOS running\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|BIOSOFFSET
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcem_ncook
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcem_cook
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|BIOSOFFSET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcem_ncook
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|++
operator|!=
name|pcem_cook
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"FEP/OS load failed\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FEP/OS loaded, initializing"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xd20
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xc34
operator|)
operator|=
literal|0xbfc01004
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xc30
operator|)
operator|=
literal|0x3L
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xd20
operator|)
operator|!=
literal|'O'
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|3000
condition|)
block|{
name|printf
argument_list|(
literal|"\nFEP/OS initialize failed(1)\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0xd21
operator|)
operator|!=
literal|'S'
condition|)
block|{
name|printf
argument_list|(
literal|"\nFEP/OS initialize failed(2)\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|", FEP/OS running\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|NPORT
argument_list|)
operator|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%d ports attached\n"
argument_list|,
name|sc
operator|->
name|numports
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|>
name|MAX_DGM_PORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: too many ports\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|enabled
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|MALLOC
argument_list|(
name|sc
operator|->
name|ports
argument_list|,
expr|struct
name|dgm_p
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|ports
argument_list|)
operator|*
name|sc
operator|->
name|numports
argument_list|,
name|M_TTYS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sc
operator|->
name|ttys
argument_list|,
expr|struct
name|tty
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|ttys
argument_list|)
operator|*
name|sc
operator|->
name|numports
argument_list|,
name|M_TTYS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: enable %d ports\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|numports
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|enabled
operator|=
literal|1
expr_stmt|;
comment|/* We should now init per-port structures */
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|=
operator|(
specifier|volatile
expr|struct
name|board_chan
operator|*
operator|)
operator|(
name|mem
operator|+
name|CHANSTRUCT
operator|)
expr_stmt|;
name|sc
operator|->
name|mailbox
operator|=
operator|(
specifier|volatile
expr|struct
name|global_data
operator|*
operator|)
operator|(
name|mem
operator|+
name|FEP_GLOBAL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|<
literal|3
condition|)
name|shrinkmem
operator|=
literal|1
expr_stmt|;
else|else
name|shrinkmem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
operator|,
name|bc
operator|++
control|)
block|{
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: Set up port %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|port
operator|->
name|tty
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|brdchan
operator|=
name|bc
expr_stmt|;
name|port
operator|->
name|dcd
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dsr
operator|=
name|DSR
expr_stmt|;
name|port
operator|->
name|pnum
operator|=
name|i
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: shrinkmem ?\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|shrinkmem
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: shrinking memory\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETBUFFER
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shrinkmem
operator|=
literal|0
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: assign ptrs\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|port
operator|->
name|txptr
operator|=
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|<<
literal|4
operator|)
operator|&
literal|0x7FFF
operator|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|<<
literal|4
operator|)
operator|&
literal|0x7FFF
operator|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|FEPWIN
operator||
operator|(
name|bc
operator|->
name|tseg
operator|>>
literal|11
operator|)
expr_stmt|;
name|port
operator|->
name|rxwin
operator|=
name|FEPWIN
operator||
operator|(
name|bc
operator|->
name|rseg
operator|>>
literal|11
operator|)
expr_stmt|;
name|port
operator|->
name|txbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|rxbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|txbufsize
operator|=
name|bc
operator|->
name|tmax
operator|+
literal|1
expr_stmt|;
name|port
operator|->
name|rxbufsize
operator|=
name|bc
operator|->
name|rmax
operator|+
literal|1
expr_stmt|;
name|lowwater
operator|=
operator|(
name|port
operator|->
name|txbufsize
operator|>=
literal|2000
operator|)
condition|?
literal|1024
else|:
operator|(
name|port
operator|->
name|txbufsize
operator|/
literal|2
operator|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: fepcmd STXLWATER %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|lowwater
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STXLWATER
argument_list|,
name|lowwater
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: fepcmd SRXLWATER %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|,
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXLWATER
argument_list|,
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: fepcmd SRXHWATER %d\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|,
literal|3
operator|*
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXHWATER
argument_list|,
literal|3
operator|*
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|edelay
operator|=
literal|100
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|startc
operator|=
name|bc
operator|->
name|startc
expr_stmt|;
name|port
operator|->
name|startca
operator|=
name|bc
operator|->
name|startca
expr_stmt|;
name|port
operator|->
name|stopc
operator|=
name|bc
operator|->
name|stopc
expr_stmt|;
name|port
operator|->
name|stopca
operator|=
name|bc
operator|->
name|stopca
expr_stmt|;
comment|/* port->close_delay = 50; */
name|port
operator|->
name|close_delay
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|port
operator|->
name|do_timestamp
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|do_dcd_timestamp
operator|=
literal|0
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: setup flags\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * We don't use all the flags from<sys/ttydefaults.h> since 		 * they are only relevant for logins.  It's important to have 		 * echo off initially so that the line doesn't start 		 * blathering before the echo flag can be turned off. 		 */
name|port
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|port
operator|->
name|it_in
argument_list|)
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|port
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|dgmdefaultrate
expr_stmt|;
name|port
operator|->
name|it_out
operator|=
name|port
operator|->
name|it_in
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d port %d: make devices\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|,
operator|(
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|)
operator|+
name|i
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyM%d%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
operator|+
literal|0xa0
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|64
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyiM%d%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
operator|+
literal|0xa0
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|128
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttylM%d%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
operator|+
literal|0xa0
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|262144
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuaM%d%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
operator|+
literal|0xa0
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|262208
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuaiM%d%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
operator|+
literal|0xa0
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgm_cdevsw
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|262272
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cualM%d%x"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|i
operator|+
literal|0xa0
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: %d device nodes created\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|numports
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* start the polling function */
name|sc
operator|->
name|toh
operator|=
name|timeout
argument_list|(
name|dgmpoll
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|int
operator|)
name|sc
operator|->
name|unit
argument_list|,
name|hz
operator|/
name|POLLSPERSEC
argument_list|)
expr_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: poll thread started\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgmdetach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dgm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|ttys
index|[
name|i
index|]
operator|.
name|t_state
operator|&
name|TS_ISOPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: detach\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
control|)
block|{
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|128
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|262144
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|262208
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|sc
operator|->
name|unit
operator|*
literal|65536
operator|+
name|i
operator|+
literal|262272
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|dgmpoll
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|int
operator|)
name|sc
operator|->
name|unit
argument_list|,
name|sc
operator|->
name|toh
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|toh
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|mrid
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|io_res
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sc
operator|->
name|ports
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sc
operator|->
name|ttys
argument_list|,
name|M_TTYS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dgmshutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|dgm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: shutdown\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dgmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cs
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgm%d: try to open a nonexisting card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: open\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|enabled
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgm%d: try to open a disabled card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|pnum
operator|>=
name|sc
operator|->
name|numports
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgm%d: try to open non-existing port %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
literal|0
return|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|dev
operator|->
name|si_tty
operator|=
name|tp
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|open_top
label|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|port
operator|->
name|closing
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|closing
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"dgocl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d: tsleep(dgocl)"
literal|" error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * The device is open, so everything has been initialized. 		 * Handle conflicts. 		 */
if|if
condition|(
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
block|{
if|if
condition|(
operator|!
name|port
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d:"
literal|" BUSY error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d:"
literal|" BUSY error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgmi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d: tsleep(dgmi)"
literal|" error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|open_top
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|suser
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it.  Initialization is done twice in many 		 * cases: to preempt sleeping callin opens if we are 		 * callout, and to complete a callin open after DCD rises. 		 */
name|tp
operator|->
name|t_oproc
operator|=
name|dgmstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|dgmparam
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|dgmstop
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
condition|?
name|port
operator|->
name|it_out
else|:
name|port
operator|->
name|it_in
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|bc
operator|->
name|mstat
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
comment|/* clear input queue */
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_BUFSIZE
name|printf
argument_list|(
literal|"dgm buffers tx = %x:%x rx = %x:%x\n"
argument_list|,
name|bc
operator|->
name|tseg
argument_list|,
name|bc
operator|->
name|tmax
argument_list|,
name|bc
operator|->
name|rseg
argument_list|,
name|bc
operator|->
name|rmax
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|port
operator|->
name|wopeners
operator|++
expr_stmt|;
name|error
operator|=
name|dgmparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|port
operator|->
name|wopeners
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d: dgmparam error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* handle fake DCD for callout devices */
comment|/* and initial DCD */
if|if
condition|(
operator|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dcd
operator|)
operator|||
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for DCD if necessary. 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
operator|++
name|port
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgdcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|port
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d: tsleep(dgdcd)"
literal|" error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
argument_list|(
name|dev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d: l_open error = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|port
operator|->
name|active_out
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|used
operator|=
literal|1
expr_stmt|;
comment|/* If any port is open (i.e. the open() call is completed for it) 	 * the device is busy 	 */
name|out
label|:
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|port
operator|->
name|wopeners
operator|==
literal|0
condition|)
name|dgmhardclose
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgm%d: port%d: open() returns %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dgmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
literal|0
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|port
operator|=
name|sc
operator|->
name|ports
operator|+
name|pnum
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: closing\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: draining port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgm_drain_or_flush
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: closing line disc\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: hard closing\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgmhardclose
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: closing tty\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|closing
argument_list|)
expr_stmt|;
name|port
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* mark the card idle when all ports are closed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: closed\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|port
operator|->
name|active_out
operator|=
literal|0
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgm%d: port%d: close exit\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgmhardclose
parameter_list|(
name|struct
name|dgm_p
modifier|*
name|port
parameter_list|)
block|{
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: dgmhardclose\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|port
operator|->
name|do_timestamp
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|tty
operator|->
name|t_cflag
operator|&
name|HUPCL
condition|)
block|{
name|port
operator|->
name|omodem
operator|&=
operator|~
operator|(
name|RTS
operator||
name|DTR
operator|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
literal|0
argument_list|,
name|DTR
operator||
name|RTS
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|dgm_pause
argument_list|,
operator|&
name|port
operator|->
name|brdchan
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|brdchan
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgclo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgm_pause
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgmpoll
parameter_list|(
name|void
modifier|*
name|unit_c
parameter_list|)
block|{
name|int
name|unit
init|=
operator|(
name|int
operator|)
name|unit_c
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u_char
modifier|*
name|eventbuf
decl_stmt|;
name|int
name|event
decl_stmt|,
name|mstat
decl_stmt|,
name|lstat
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rhead
decl_stmt|,
name|rtail
decl_stmt|;
name|int
name|whead
decl_stmt|,
name|wtail
decl_stmt|;
name|int
name|size
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|ocount
decl_stmt|;
name|int
name|ibuf_full
decl_stmt|,
name|obuf_full
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: poll\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|toh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|enabled
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: polling of disabled board stopped\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|ein
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|eout
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|head
operator|>=
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|||
name|tail
operator|>=
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|||
operator|(
name|head
operator||
name|tail
operator|)
operator|&
literal|03
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: event queue's head or tail is wrong!"
literal|" hd = %d, tl = %d\n"
argument_list|,
name|unit
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
break|break;
block|}
name|eventbuf
operator|=
name|sc
operator|->
name|vmem
operator|+
name|tail
operator|+
name|FEP_ISTART
expr_stmt|;
name|pnum
operator|=
name|eventbuf
index|[
literal|0
index|]
expr_stmt|;
name|event
operator|=
name|eventbuf
index|[
literal|1
index|]
expr_stmt|;
name|mstat
operator|=
name|eventbuf
index|[
literal|2
index|]
expr_stmt|;
name|lstat
operator|=
name|eventbuf
index|[
literal|3
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
if|if
condition|(
name|pnum
operator|>=
name|sc
operator|->
name|numports
operator|||
operator|!
name|port
operator|->
name|enabled
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: port%d: got event on nonexisting port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|used
operator|||
name|port
operator|->
name|wopeners
operator|>
literal|0
condition|)
block|{
name|int
name|wrapmask
init|=
name|port
operator|->
name|rxbufsize
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|ALL_IND
operator|)
condition|)
name|printf
argument_list|(
literal|"dgm%d: port%d: ? event 0x%x mstat 0x%x lstat 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|event
argument_list|,
name|mstat
argument_list|,
name|lstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|DATA_IND
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_DATA
argument_list|,
literal|"dgm%d: port%d: DATA_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|rhead
operator|=
name|bc
operator|->
name|rin
operator|&
name|wrapmask
expr_stmt|;
name|rtail
operator|=
name|bc
operator|->
name|rout
operator|&
name|wrapmask
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CREAD
operator|)
operator|||
operator|!
name|port
operator|->
name|used
condition|)
block|{
name|bc
operator|->
name|rout
operator|=
name|rhead
expr_stmt|;
goto|goto
name|end_of_data
goto|;
block|}
if|if
condition|(
name|bc
operator|->
name|orun
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: port%d: overrun\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|bc
operator|->
name|orun
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
goto|goto
name|end_of_data
goto|;
for|for
control|(
name|ibuf_full
operator|=
name|FALSE
init|;
name|rhead
operator|!=
name|rtail
operator|&&
operator|!
name|ibuf_full
condition|;
control|)
block|{
name|DPRINT5
argument_list|(
name|DB_RXDATA
argument_list|,
literal|"dgm%d: port%d:"
literal|" p rx head = %d tail = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|rhead
argument_list|,
name|rtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhead
operator|>
name|rtail
condition|)
name|size
operator|=
name|rhead
operator|-
name|rtail
expr_stmt|;
else|else
name|size
operator|=
name|port
operator|->
name|rxbufsize
operator|-
name|rtail
expr_stmt|;
name|ptr
operator|=
name|port
operator|->
name|rxptr
operator|+
name|rtail
expr_stmt|;
comment|/* Helg: */
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|size
operator|>
name|DGB_IBUFSIZE
condition|)
block|{
name|size
operator|=
name|DGB_IBUFSIZE
operator|-
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
expr_stmt|;
name|DPRINT1
argument_list|(
name|DB_RXDATA
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|ibuf_full
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_RXDATA
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|rxwin
argument_list|)
expr_stmt|;
name|tk_nin
operator|+=
name|size
expr_stmt|;
name|tk_rawcc
operator|+=
name|size
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|size
expr_stmt|;
name|b_to_q
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|size
decl_stmt|;
name|unsigned
name|char
name|chr
decl_stmt|;
do|do
block|{
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|rxwin
argument_list|)
expr_stmt|;
name|chr
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|chr
operator|,
name|tp
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|rtail
operator|=
operator|(
name|rtail
operator|+
name|size
operator|)
operator|&
name|wrapmask
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|rtail
expr_stmt|;
name|rhead
operator|=
name|bc
operator|->
name|rin
operator|&
name|wrapmask
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|end_of_data
label|:
empty_stmt|;
block|}
if|if
condition|(
name|event
operator|&
name|MODEMCHG_IND
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgm%d: port%d: "
literal|"MODEMCHG_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|mstat
expr_stmt|;
if|if
condition|(
name|mstat
operator|&
name|port
operator|->
name|dcd
condition|)
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|draining
condition|)
block|{
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|&
name|BREAK_IND
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IGNBRK
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_BREAK
argument_list|,
literal|"dgm%d: port%d:"
literal|" BREAK_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
argument_list|(
name|TTY_BI
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Helg: with output flow control */
if|if
condition|(
name|event
operator|&
operator|(
name|LOWTX_IND
operator||
name|EMPTYTX_IND
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_TXDATA
argument_list|,
literal|"dgm%d: port%d:"
literal|" LOWTX_IND or EMPTYTX_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|&
name|EMPTYTX_IND
operator|)
operator|&&
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
operator|&&
name|port
operator|->
name|draining
condition|)
block|{
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|wrapmask
init|=
name|port
operator|->
name|txbufsize
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|obuf_full
operator|=
name|FALSE
init|;
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
operator|&&
operator|!
name|obuf_full
condition|;
control|)
block|{
name|int
name|s
decl_stmt|;
comment|/* add "last-minute" data to write buffer */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
condition|)
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* selwakeup(&tp->t_wsel); */
block|}
endif|#
directive|endif
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|whead
operator|=
name|bc
operator|->
name|tin
operator|&
name|wrapmask
expr_stmt|;
name|wtail
operator|=
name|bc
operator|->
name|tout
operator|&
name|wrapmask
expr_stmt|;
if|if
condition|(
name|whead
operator|<
name|wtail
condition|)
name|size
operator|=
name|wtail
operator|-
name|whead
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|whead
expr_stmt|;
if|if
condition|(
name|wtail
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm: head = %d tail = %d size = %d full = %d\n"
argument_list|,
name|whead
argument_list|,
name|wtail
argument_list|,
name|size
argument_list|,
name|obuf_full
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|1
expr_stmt|;
name|obuf_full
operator|=
name|TRUE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|txwin
argument_list|)
expr_stmt|;
name|ocount
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|port
operator|->
name|txptr
operator|+
name|whead
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|whead
operator|+=
name|ocount
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|whead
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|whead
operator|&
name|wrapmask
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obuf_full
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_WR
argument_list|,
literal|" +BUSY\n"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
else|else
block|{
name|DPRINT1
argument_list|(
name|DB_WR
argument_list|,
literal|" -BUSY\n"
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
comment|/* should clear TS_BUSY before ttwwakeup */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
endif|#
directive|endif
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
comment|/* require event on incoming data */
block|}
else|else
block|{
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgm%d: port%d: got event 0x%x on closed port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
name|bc
operator|->
name|iempty
operator|=
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
block|}
name|tail
operator|=
operator|(
name|tail
operator|+
literal|4
operator|)
operator|&
operator|(
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|-
literal|4
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|mailbox
operator|->
name|eout
operator|=
name|tail
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|sc
operator|->
name|toh
operator|=
name|timeout
argument_list|(
name|dgmpoll
argument_list|,
name|unit_c
argument_list|,
name|hz
operator|/
name|POLLSPERSEC
argument_list|)
expr_stmt|;
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgm%d: poll done\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cs
decl_stmt|;
name|int
name|tiocm_xxx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|u_long
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|it_out
else|:
operator|&
name|port
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|lt_out
else|:
operator|&
name|port
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: dgmioctl-ISNOW c = 0x%x i = 0x%x l = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|term
operator|.
name|c_cflag
argument_list|,
name|term
operator|.
name|c_iflag
argument_list|,
name|term
operator|.
name|c_lflag
argument_list|)
expr_stmt|;
block|}
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|lt_out
else|:
operator|&
name|port
operator|->
name|lt_in
decl_stmt|;
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: dgmioctl-TOSET c = 0x%x i = 0x%x l = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|dt
operator|->
name|c_cflag
argument_list|,
name|dt
operator|->
name|c_iflag
argument_list|,
name|dt
operator|->
name|c_lflag
argument_list|)
expr_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSTOP
condition|)
block|{
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|PAUSETX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|TIOCSTART
condition|)
block|{
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|RESUMETX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
name|port
operator|->
name|mustdrain
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|port
operator|->
name|mustdrain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: dgmioctl-RES c = 0x%x i = 0x%x l = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|tp
operator|->
name|t_cflag
argument_list|,
name|tp
operator|->
name|t_iflag
argument_list|,
name|tp
operator|->
name|t_lflag
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
if|#
directive|if
literal|0
block|error = dgmdrain(port);  		if (error != 0) { 			splx(s); 			return error; 		}
endif|#
directive|endif
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* now it sends 400 millisecond break because I don't know */
comment|/* how to send an infinite break */
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SENDBREAK
argument_list|,
literal|400
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
comment|/* now it's empty */
break|break;
case|case
name|TIOCSDTR
case|:
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgm%d: port%d: set DTR\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bc
operator|->
name|mstat
operator|&
name|DTR
operator|)
condition|)
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgm%d: port%d: DTR is off\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgm%d: port%d: reset DTR\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|mstat
operator|&
name|DTR
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgm%d: port%d: DTR is on\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
else|else
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator||=
name|RTS
expr_stmt|;
else|else
name|port
operator|->
name|omodem
operator|&=
operator|~
name|RTS
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator||=
name|RTS
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator|&=
operator|~
name|RTS
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|bc
operator|->
name|mstat
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* XXX - always enabled while open */
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgm%d: port%d: modem stat -- "
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|DTR
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"DTR "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_DTR
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|RTS
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"RTS "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_RTS
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|CTS
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"CTS "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_CTS
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dcd
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"DCD "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_CD
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dsr
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"DSR "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_DSR
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|RI
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"RI "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_RI
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tiocm_xxx
expr_stmt|;
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"--\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
comment|/* must be root since the wait applies to following logins */
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|port
operator|->
name|close_delay
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|port
operator|->
name|close_delay
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|TIOCTIMESTAMP
case|:
name|port
operator|->
name|do_timestamp
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|port
operator|->
name|timestamp
expr_stmt|;
break|break;
case|case
name|TIOCDCDTIMESTAMP
case|:
name|port
operator|->
name|do_dcd_timestamp
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|port
operator|->
name|dcd_timestamp
expr_stmt|;
break|break;
default|default:
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wakeflush
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|dgm_p
modifier|*
name|port
init|=
name|p
decl_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wait for the output to drain */
end_comment

begin_function
specifier|static
name|int
name|dgmdrain
parameter_list|(
name|struct
name|dgm_p
modifier|*
name|port
parameter_list|)
block|{
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|head
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: drain: head = %d tail = %d\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|wakeflush
argument_list|,
name|port
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgdrn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: tsleep(dgdrn) error = %d\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
block|}
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: drain: head = %d tail = %d\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* wait for the output to drain */
end_comment

begin_comment
comment|/* or simply clear the buffer it it's stopped */
end_comment

begin_function
specifier|static
name|void
name|dgm_drain_or_flush
parameter_list|(
name|struct
name|dgm_p
modifier|*
name|port
parameter_list|)
block|{
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|port
operator|->
name|tty
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|lasttail
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lasttail
operator|=
operator|-
literal|1
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|head
comment|/*&& tail != lasttail */
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: flush: head = %d tail = %d\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* if there is no carrier simply clean the buffer */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|wakeflush
argument_list|,
name|port
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgfls"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: tsleep(dgfls)"
literal|" error = %d\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* silently clean the buffer */
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|lasttail
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: flush: head = %d tail = %d\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgmparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|int
name|unit
init|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pnum
init|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|int
name|cflag
decl_stmt|;
name|int
name|head
decl_stmt|;
name|int
name|mval
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|int
name|hflow
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: dgmparm c = 0x%x i = 0x%x l = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|,
name|t
operator|->
name|c_lflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|mustdrain
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: must call dgmdrain()\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgmdrain
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|cflag
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|dgmspeedtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
if|if
condition|(
name|cflag
operator|<
literal|0
comment|/* || cflag> 0&& t->c_ispeed != t->c_ospeed */
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: invalid cflag = 0%o\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|cflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
block|{
comment|/* hangup */
name|DPRINT3
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: hangup\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STOUT
argument_list|,
operator|(
name|unsigned
operator|)
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mval
operator|=
name|port
operator|->
name|omodem
operator|&
operator|~
operator|(
name|DTR
operator||
name|RTS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cflag
operator||=
name|dgmflags
argument_list|(
name|dgm_cflags
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|!=
name|port
operator|->
name|fepcflag
condition|)
block|{
name|port
operator|->
name|fepcflag
operator|=
name|cflag
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: set cflag = 0x%x c = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|cflag
argument_list|,
name|t
operator|->
name|c_cflag
operator|&
operator|~
name|CRTSCTS
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETCTRLFLAGS
argument_list|,
operator|(
name|unsigned
operator|)
name|cflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mval
operator|=
name|port
operator|->
name|omodem
operator||
operator|(
name|DTR
operator||
name|RTS
operator|)
expr_stmt|;
block|}
name|iflag
operator|=
name|dgmflags
argument_list|(
name|dgm_iflags
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
operator|!=
name|port
operator|->
name|fepiflag
condition|)
block|{
name|port
operator|->
name|fepiflag
operator|=
name|iflag
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: set iflag = 0x%x c = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|iflag
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETIFLAGS
argument_list|,
operator|(
name|unsigned
operator|)
name|iflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bc
operator|->
name|mint
operator|=
name|port
operator|->
name|dcd
expr_stmt|;
name|hflow
operator|=
name|dgmflags
argument_list|(
name|dgm_flow
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hflow
operator|!=
name|port
operator|->
name|hflow
condition|)
block|{
name|port
operator|->
name|hflow
operator|=
name|hflow
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: set hflow = 0x%x f = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|hflow
argument_list|,
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETHFLOW
argument_list|,
operator|(
name|unsigned
operator|)
name|hflow
argument_list|,
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|omodem
operator|!=
name|mval
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: setting modem parameters 0x%x was 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|mval
argument_list|,
name|port
operator|->
name|omodem
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator|=
name|mval
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
operator|(
name|unsigned
operator|)
name|mval
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|fepstartc
operator|!=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|||
name|port
operator|->
name|fepstopc
operator|!=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgm%d: port%d: set startc = %d, stopc = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|port
operator|->
name|fepstartc
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|port
operator|->
name|fepstopc
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SONOFFC
argument_list|,
name|port
operator|->
name|fepstartc
argument_list|,
name|port
operator|->
name|fepstopc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgmstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|size
decl_stmt|,
name|ocount
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|wmask
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|wmask
operator|=
name|port
operator|->
name|txbufsize
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|int
name|cs
decl_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*selwakeup(&tp->t_wsel);*/
block|}
endif|#
directive|endif
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
operator|&
name|wmask
expr_stmt|;
do|do
block|{
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
block|}
do|while
condition|(
name|tail
operator|!=
name|bc
operator|->
name|tout
condition|)
do|;
name|tail
operator|=
name|bc
operator|->
name|tout
operator|&
name|wmask
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: s tx head = %d tail = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAVE_FREE_CHARS
if|if
condition|(
name|tail
operator|>
name|head
condition|)
block|{
name|size
operator|=
name|tail
operator|-
name|head
operator|-
name|LEAVE_FREE_CHARS
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|head
expr_stmt|;
if|if
condition|(
name|tail
operator|+
name|port
operator|->
name|txbufsize
operator|<
name|head
condition|)
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|tail
operator|>
name|head
condition|)
name|size
operator|=
name|tail
operator|-
name|head
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|head
expr_stmt|;
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|txwin
argument_list|)
expr_stmt|;
name|ocount
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|port
operator|->
name|txptr
operator|+
name|head
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|head
operator|+=
name|ocount
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|port
operator|->
name|txbufsize
condition|)
name|head
operator|-=
name|port
operator|->
name|txbufsize
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|head
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: tx avail = %d count = %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|size
argument_list|,
name|ocount
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
modifier|&
init|=
operator|~
name|TS_BUSY
decl_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dgmstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgm_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgm_softc
modifier|*
name|sc
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|devclass_get_softc
argument_list|(
name|dgmdevclass
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_WR
argument_list|,
literal|"dgm%d: port%d: stop\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
comment|/* clear output queue */
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
comment|/* clear input queue */
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dgmstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fepcmd
parameter_list|(
name|struct
name|dgm_p
modifier|*
name|port
parameter_list|,
name|unsigned
name|cmd
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|op2
parameter_list|,
name|unsigned
name|ncmds
parameter_list|,
name|unsigned
name|bytecmd
parameter_list|)
block|{
name|u_char
modifier|*
name|mem
decl_stmt|;
name|unsigned
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|int
name|count
decl_stmt|,
name|n
decl_stmt|;
name|KASSERT
argument_list|(
name|port
operator|->
name|sc
argument_list|,
operator|(
literal|"Couldn't (re)obtain driver softc"
operator|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|port
operator|->
name|sc
operator|->
name|vmem
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|enabled
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: port%d: FEP command on disabled port\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* setwin(port->sc, 0); Require this to be set by caller */
name|head
operator|=
name|port
operator|->
name|sc
operator|->
name|mailbox
operator|->
name|cin
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|||
operator|(
name|head
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dgm%d: port%d: wrong pointer head of command queue : 0x%x\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
index|]
operator|=
name|cmd
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|1
index|]
operator|=
name|port
operator|->
name|pnum
expr_stmt|;
if|if
condition|(
name|bytecmd
condition|)
block|{
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
operator|=
name|op1
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
operator|=
name|op2
expr_stmt|;
block|}
else|else
block|{
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
operator|=
name|op1
operator|&
literal|0xff
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
operator|=
operator|(
name|op1
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|DPRINT7
argument_list|(
name|DB_FEP
argument_list|,
literal|"dgm%d: port%d: %s cmd = 0x%x op1 = 0x%x op2 = 0x%x\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
operator|(
name|bytecmd
operator|)
condition|?
literal|"byte"
else|:
literal|"word"
argument_list|,
name|cmd
argument_list|,
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
argument_list|,
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|4
operator|)
operator|&
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|-
literal|4
operator|)
expr_stmt|;
name|port
operator|->
name|sc
operator|->
name|mailbox
operator|->
name|cin
operator|=
name|head
expr_stmt|;
name|count
operator|=
name|FEPTIMEOUT
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|!=
literal|0
condition|)
block|{
name|head
operator|=
name|port
operator|->
name|sc
operator|->
name|mailbox
operator|->
name|cin
expr_stmt|;
name|tail
operator|=
name|port
operator|->
name|sc
operator|->
name|mailbox
operator|->
name|cout
expr_stmt|;
name|n
operator|=
operator|(
name|head
operator|-
name|tail
operator|)
operator|&
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
name|ncmds
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
operator|*
literal|4
operator|)
condition|)
return|return;
block|}
name|printf
argument_list|(
literal|"dgm%d(%d): timeout on FEP cmd = 0x%x\n"
argument_list|,
name|port
operator|->
name|sc
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disc_optim
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
block|}
end_function

end_unit

