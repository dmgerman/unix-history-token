begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  dgb.c $Id: dgb.c,v 1.2 1995/09/04 01:58:41 jkh Exp $  *  *  Digiboard driver.  *  *  Stage 1. "Better than nothing".  *  *  Based on sio driver by Bruce Evans and on Linux driver by Troy   *  De Jongh<troyd@digibd.com> or<troyd@skypoint.com>   *  which is under GNU General Public License version 2 so this driver   *  is forced to be under GPL 2 too.  *  *  Written by Serge Babkin,  *      Joint Stock Commercial Bank "Chelindbank"  *      (Chelyabinsk, Russia)  *      babkin@hq.icb.chel.su  */
end_comment

begin_include
include|#
directive|include
file|"dgb.h"
end_include

begin_if
if|#
directive|if
name|NDGB
operator|>
literal|0
end_if

begin_comment
comment|/* the overall number of ports controlled by this driver */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDGBPORTS
end_ifndef

begin_define
define|#
directive|define
name|NDGBPORTS
value|(NDGB*16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_define
define|#
directive|define
name|TTYDEFCHARS
end_define

begin_comment
comment|/* XXX TK2.0 */
end_comment

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_undef
undef|#
directive|undef
name|TTYDEFCHARS
end_undef

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_comment
comment|/* XXX just to get at `imen' */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|"dgreg.h"
end_include

begin_include
include|#
directive|include
file|"dgbios.h"
end_include

begin_include
include|#
directive|include
file|"dgfep.h"
end_include

begin_comment
comment|/*  * XXX temporary kludges for 2.0 (XXX TK2.0).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|<
literal|2
end_if

begin_define
define|#
directive|define
name|TS_RTS_IFLOW
value|0
end_define

begin_define
define|#
directive|define
name|TSA_CARR_ON
parameter_list|(
name|tp
parameter_list|)
value|((void *)&(tp)->t_rawq)
end_define

begin_define
define|#
directive|define
name|TSA_OCOMPLETE
parameter_list|(
name|tp
parameter_list|)
value|((void *)&(tp)->t_outq)
end_define

begin_define
define|#
directive|define
name|TSA_OLOWAT
parameter_list|(
name|tp
parameter_list|)
value|((void *)&(tp)->t_outq)
end_define

begin_define
define|#
directive|define
name|TTY_BI
value|TTY_FE
end_define

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|TTY_OE
value|TTY_PE
end_define

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|UNIT_MASK
value|0x30000
end_define

begin_define
define|#
directive|define
name|PORT_MASK
value|0x1F
end_define

begin_define
define|#
directive|define
name|DEV_TO_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev)))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_UNIT
parameter_list|(
name|mynor
parameter_list|)
value|(((mynor)& UNIT_MASK)>>16)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_PORT
parameter_list|(
name|mynor
parameter_list|)
value|((mynor)& PORT_MASK)
end_define

begin_comment
comment|/* types.  XXX - should be elsewhere */
end_comment

begin_typedef
typedef|typedef
name|u_int
name|Port_t
typedef|;
end_typedef

begin_comment
comment|/* hardware port */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_comment
comment|/* boolean */
end_comment

begin_comment
comment|/* digiboard port structure */
end_comment

begin_struct
struct|struct
name|dgb_p
block|{
name|bool_t
name|status
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
comment|/* board unit number */
name|u_char
name|pnum
decl_stmt|;
comment|/* port number */
name|u_char
name|omodem
decl_stmt|;
comment|/* FEP output modem status     */
name|u_char
name|imodem
decl_stmt|;
comment|/* FEP input modem status      */
name|u_char
name|modemfake
decl_stmt|;
comment|/* Modem values to be forced   */
name|u_char
name|modem
decl_stmt|;
comment|/* Force values                */
name|u_char
name|hflow
decl_stmt|;
name|u_char
name|dsr
decl_stmt|;
name|u_char
name|dcd
decl_stmt|;
name|u_char
name|stopc
decl_stmt|;
name|u_char
name|startc
decl_stmt|;
name|u_char
name|stopca
decl_stmt|;
name|u_char
name|startca
decl_stmt|;
name|u_char
name|fepstopc
decl_stmt|;
name|u_char
name|fepstartc
decl_stmt|;
name|u_char
name|fepstopca
decl_stmt|;
name|u_char
name|fepstartca
decl_stmt|;
name|u_char
name|txwin
decl_stmt|;
name|u_char
name|rxwin
decl_stmt|;
name|ushort
name|fepiflag
decl_stmt|;
name|ushort
name|fepcflag
decl_stmt|;
name|ushort
name|fepoflag
decl_stmt|;
name|ushort
name|txbufhead
decl_stmt|;
name|ushort
name|txbufsize
decl_stmt|;
name|ushort
name|rxbufhead
decl_stmt|;
name|ushort
name|rxbufsize
decl_stmt|;
name|int
name|close_delay
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|blocked_open
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|asyncflags
decl_stmt|;
name|u_long
name|statusflags
decl_stmt|;
name|u_char
modifier|*
name|txptr
decl_stmt|;
name|u_char
modifier|*
name|rxptr
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|brdchan
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|bool_t
name|active_out
decl_stmt|;
comment|/* nonzero if the callout device is open */
name|int
name|dtr_wait
decl_stmt|;
comment|/* time to hold DTR down on close (* 1/hz) */
name|u_int
name|wopeners
decl_stmt|;
comment|/* # processes waiting for DCD in open() */
comment|/* 	 * The high level of the driver never reads status registers directly 	 * because there would be too many side effects to handle conveniently. 	 * Instead, it reads copies of the registers stored here by the 	 * interrupt handler. 	 */
name|u_char
name|last_modem_status
decl_stmt|;
comment|/* last MSR read by intr handler */
name|u_char
name|prev_modem_status
decl_stmt|;
comment|/* last MSR handled by high level */
comment|/* Initial state. */
name|struct
name|termios
name|it_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|it_out
decl_stmt|;
comment|/* Lock state. */
name|struct
name|termios
name|lt_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|lt_out
decl_stmt|;
comment|/* flags of state, are used in sleep() too */
name|u_char
name|closing
decl_stmt|;
comment|/* port is being closed now */
name|u_char
name|draining
decl_stmt|;
comment|/* port is being drained now */
name|u_char
name|used
decl_stmt|;
comment|/* port is being used now */
name|u_char
name|mustdrain
decl_stmt|;
comment|/* data must be waited to drain in dgbparam() */
block|}
struct|;
end_struct

begin_comment
comment|/* Digiboard per-board structure */
end_comment

begin_struct
struct|struct
name|dgb_softc
block|{
comment|/* struct board_info */
name|u_char
name|status
decl_stmt|;
comment|/* status: DISABLED/ENABLED */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number */
name|u_char
name|type
decl_stmt|;
comment|/* type of card: PCXE, PCXI, PCXEVE */
name|u_char
name|altpin
decl_stmt|;
comment|/* do we need alternate pin setting ? */
name|ushort
name|numports
decl_stmt|;
comment|/* number of ports on card */
name|ushort
name|port
decl_stmt|;
comment|/* I/O port */
name|u_char
modifier|*
name|vmem
decl_stmt|;
comment|/* virtual memory address */
name|long
name|pmem
decl_stmt|;
comment|/* physical memory address */
name|int
name|mem_seg
decl_stmt|;
comment|/* internal memory segment */
name|struct
name|dgb_p
modifier|*
name|ports
decl_stmt|;
comment|/* pointer to array of port descriptors */
name|struct
name|tty
modifier|*
name|ttys
decl_stmt|;
comment|/* pointer to array of TTY structures */
specifier|volatile
name|struct
name|global_data
modifier|*
name|mailbox
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|dgb_softc
name|dgb_softc
index|[
name|NDGB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dgb_p
name|dgb_ports
index|[
name|NDGBPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tty
name|dgb_tty
index|[
name|NDGBPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The public functions in the com module ought to be declared in a com-driver  * system header.  */
end_comment

begin_comment
comment|/* Interrupt handling entry points. */
end_comment

begin_decl_stmt
name|void
name|dgbintr
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dgbpoll
name|__P
argument_list|(
operator|(
name|void
operator|*
name|unit_c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device switch entry points. */
end_comment

begin_decl_stmt
name|int
name|dgbopen
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|oflags
operator|,
name|int
name|devtype
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dgbclose
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|fflag
operator|,
name|int
name|devtype
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dgbread
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|ioflag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dgbwrite
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|ioflag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dgbioctl
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|,
name|int
name|fflag
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dgbstop
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|rw
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|dgbreset
value|noreset
end_define

begin_decl_stmt
name|int
name|dgbselect
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|rw
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|dgbmmap
value|nommap
end_define

begin_define
define|#
directive|define
name|dgbstrategy
value|nostrategy
end_define

begin_decl_stmt
specifier|static
name|int
name|dgbattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fepcmd
parameter_list|(
name|struct
name|dgb_p
modifier|*
name|port
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|int
name|ncmds
parameter_list|,
name|int
name|bytecmd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|dgbstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgbhardclose
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_p
operator|*
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgb_drain_or_flush
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_p
operator|*
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbdrain
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_p
operator|*
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgb_pause
name|__P
argument_list|(
operator|(
name|void
operator|*
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|dgbdriver
init|=
block|{
name|dgbprobe
block|,
name|dgbattach
block|,
literal|"dgb"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|speed_t
name|dgbdefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|dgb_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input chars + weighted output completions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dgbmajor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|dgbspeedtab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
comment|/* old (sysV-like) Bx codes */
literal|50
block|,
literal|1
block|,
literal|75
block|,
literal|2
block|,
literal|110
block|,
literal|3
block|,
literal|134
block|,
literal|4
block|,
literal|150
block|,
literal|5
block|,
literal|200
block|,
literal|6
block|,
literal|300
block|,
literal|7
block|,
literal|600
block|,
literal|8
block|,
literal|1200
block|,
literal|9
block|,
literal|1800
block|,
literal|10
block|,
literal|2400
block|,
literal|11
block|,
literal|4800
block|,
literal|12
block|,
literal|9600
block|,
literal|13
block|,
literal|19200
block|,
literal|14
block|,
literal|38400
block|,
literal|15
block|,
literal|57600
block|,
operator|(
literal|02000
operator||
literal|1
operator|)
block|,
comment|/* B50& fast baud table */
literal|115200
block|,
operator|(
literal|02000
operator||
literal|2
operator|)
block|,
comment|/* B100& fast baud table */
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|dgbdebug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|dgbdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|polltimeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|setwin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setinitwin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hidewin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|setwin
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|13
operator|)
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: switched to window 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|addr
operator|>>
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x1FFF
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|setinitwin
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|13
operator|)
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: switched to window 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|addr
operator|>>
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x1FFF
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator||
name|FEPMEM
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|hidewin
parameter_list|(
name|sc
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|towin
parameter_list|(
name|sc
parameter_list|,
name|win
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dgbprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|t
decl_stmt|;
name|u_long
name|win_size
decl_stmt|;
comment|/* size of vizible memory window */
name|u_char
modifier|*
name|mem
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|sc
operator|->
name|port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|&
name|DGBFLAG_ALTPIN
condition|)
name|sc
operator|->
name|altpin
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|altpin
operator|=
literal|0
expr_stmt|;
comment|/* left 24 bits only (ISA address) */
name|sc
operator|->
name|pmem
operator|=
operator|(
operator|(
name|long
operator|)
name|dev
operator|->
name|id_maddr
operator|&
literal|0xFFFFFF
operator|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port 0x%x mem 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|==
name|FEPRST
condition|)
block|{
name|sc
operator|->
name|status
operator|=
name|ENABLED
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: got reset after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dgb%d: failed to respond\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check type of card and get internal memory characteristics */
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x1
condition|)
block|{
switch|switch
condition|(
name|v
operator|&
literal|0x30
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xF000
expr_stmt|;
name|win_size
operator|=
literal|0x10000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 64K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xE000
expr_stmt|;
name|win_size
operator|=
literal|0x20000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 128K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xC000
expr_stmt|;
name|win_size
operator|=
literal|0x40000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 256K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* case 0x30: */
name|sc
operator|->
name|mem_seg
operator|=
literal|0x8000
expr_stmt|;
name|win_size
operator|=
literal|0x80000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 512K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|type
operator|=
name|PCXI
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x1
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: PC/Xm isn't supported\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|mem_seg
operator|=
literal|0xF000
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|==
name|DGBFLAG_NOWIN
operator|||
operator|(
name|v
operator|&
literal|0xC0
operator|)
operator|==
literal|0
condition|)
block|{
name|win_size
operator|=
literal|0x10000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xe 64K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXE
expr_stmt|;
block|}
else|else
block|{
name|win_size
operator|=
literal|0x2000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xe 64/8K (windowed)\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXEVE
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|&
operator|~
literal|0xFFE000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: warning: address 0x%x truncated to 0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|pmem
argument_list|,
operator|(
name|long
operator|)
name|sc
operator|->
name|pmem
operator|&
literal|0xFFE000
argument_list|)
expr_stmt|;
name|dev
operator|->
name|id_maddr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|sc
operator|->
name|pmem
operator|&
literal|0xFFE000
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* save size of vizible memory segment */
name|dev
operator|->
name|id_msize
operator|=
name|win_size
expr_stmt|;
comment|/* map memory */
name|dev
operator|->
name|id_maddr
operator|=
name|sc
operator|->
name|vmem
operator|=
name|pmap_mapdev
argument_list|(
name|sc
operator|->
name|pmem
argument_list|,
name|dev
operator|->
name|id_msize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
comment|/* drop RESET */
return|return
literal|4
return|;
comment|/* we need I/O space of 4 ports */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_dgb
index|[
name|NDGB
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"dgb"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"tty"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
literal|"DigiBoard multiport card"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dgbregisterdev
parameter_list|(
name|id
parameter_list|)
name|struct
name|isa_device
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
name|kdc_dgb
index|[
name|unit
index|]
operator|=
name|kdc_dgb
index|[
literal|0
index|]
expr_stmt|;
name|kdc_dgb
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc_dgb
index|[
name|unit
index|]
operator|.
name|kdc_isa
operator|=
name|id
expr_stmt|;
comment|/* now we assume that multiport is always 'open' for simplicity */
name|kdc_dgb
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_dgb
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgbattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|u_char
modifier|*
name|mem
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|struct
name|global_data
modifier|*
name|gd
decl_stmt|;
name|int
name|shrinkmem
decl_stmt|;
name|int
name|nfails
decl_stmt|;
name|ushort
modifier|*
name|pstat
decl_stmt|;
name|int
name|lowwater
decl_stmt|;
name|int
name|nports
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dbg%d: try to attach a disabled card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: internal memory segment 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|mem_seg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPRST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 1st reset failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: got reset after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* for PCXEVE set up interrupt and base address */
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|>>
literal|8
operator|)
operator|&
literal|0xFFE0
operator|)
operator||
literal|0x10
comment|/* enable windowing */
expr_stmt|;
comment|/* IRQ isn't used */
if|#
directive|if
literal|0
block|switch(dev->id_irq) { 		case IRQ3: 			t|=0x1; 			break; 		case IRQ5: 			t|=2; 			break; 		case IRQ7: 			t|=3; 			break; 		case IRQ10: 			t|=4; 			break; 		case IRQ11: 			t|=5; 			break; 		case IRQ12: 			t|=6; 			break; 		case IRQ15: 			t|=7; 			break; 		default: 			printf("dgb%d: wrong IRQ mask 0x%x\n",dev->id_unit,dev->id_irq); 			sc->status=DISABLED; 			return 0; 		}
endif|#
directive|endif
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|>>
literal|8
operator|)
operator|&
literal|0xFFE0
operator|)
comment|/* disable windowing */
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXI
operator|||
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
operator||
name|FEPMEM
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
operator|(
name|FEPRST
operator||
name|FEPMEM
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 2nd reset failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: got memory after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
comment|/* very short memory test */
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|BOTWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0xA55A3CC3
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0xA55A3CC3
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 1st memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|TOPWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 2nd memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 3rd (BIOS) memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|mem
index|[
name|addr
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXI
operator|||
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|addr
operator|=
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: BIOS local address=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
operator|*
name|ptr
operator|=
name|pcxx_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
name|nfails
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|!=
name|pcxx_bios
index|[
name|i
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: wrong code in BIOS at addr 0x%x : \ 0x%x instead of 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|ptr
operator|-
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|,
operator|*
name|ptr
argument_list|,
name|pcxx_bios
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nfails
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 4th memory test (BIOS load) fails\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPMEM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: BIOS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: reset dropped after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
operator|)
operator|==
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
operator|)
condition|)
goto|goto
name|load_fep
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dgb%d: BIOS download failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: code=0x%x must be 0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
operator|)
argument_list|,
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
comment|/* set window 7 */
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
operator|(
name|BIOSCODE
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcxx_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
operator|(
name|BIOSCODE
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|nfails
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|!=
name|pcxx_bios
index|[
name|i
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: wrong code in BIOS at addr 0x%x : \ 0x%x instead of 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|ptr
operator|-
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|,
operator|*
name|ptr
argument_list|,
name|pcxx_bios
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nfails
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 4th memory test (BIOS load) fails\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPCLR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: BIOS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: reset dropped after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|==
operator|*
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
condition|)
goto|goto
name|load_fep
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dgb%d: BIOS download failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|DPRINT5
argument_list|(
literal|"dgb%d: Error#(0x%x,0x%x) code=0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
literal|0xC12
operator|)
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
literal|0xC14
operator|)
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|load_fep
label|:
name|DPRINT2
argument_list|(
literal|"dgb%d: BIOS loaded\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPCODE
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_ncook
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcxx_cook
index|[
name|i
index|]
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MBOX
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0
operator|)
operator|=
literal|2
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|2
operator|)
operator|=
name|sc
operator|->
name|mem_seg
operator|+
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|6
operator|)
operator|=
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|8
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|10
operator|)
operator|=
name|pcxx_ncook
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
operator||
name|FEPINT
argument_list|)
expr_stmt|;
comment|/* send interrupt to BIOS */
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|200000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: FEP code download failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: code=0x%x must be 0\n"
argument_list|,
name|unit
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|DPRINT2
argument_list|(
literal|"dgb%d: FEP code loaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPSTAT
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MBOX
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0
operator|)
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|2
operator|)
operator|=
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0x4
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPINT
argument_list|)
expr_stmt|;
comment|/* send interrupt to BIOS */
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPSTAT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
operator|*
operator|(
name|ushort
operator|*
operator|)
literal|"OS"
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|200000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: FEP/OS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|DPRINT2
argument_list|(
literal|"dgb%d: FEP/OS started\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|NPORT
argument_list|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: %d ports\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|numports
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|>
name|MAX_DGB_PORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: too many ports\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nports
operator|+
name|sc
operator|->
name|numports
operator|>
name|NDGBPORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: only %d ports are usable\n"
argument_list|,
name|unit
argument_list|,
name|NDGBPORTS
operator|-
name|nports
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
name|NDGBPORTS
operator|-
name|nports
expr_stmt|;
block|}
comment|/* allocate port and tty structures */
name|sc
operator|->
name|ports
operator|=
operator|&
name|dgb_ports
index|[
name|nports
index|]
expr_stmt|;
name|sc
operator|->
name|ttys
operator|=
operator|&
name|dgb_tty
index|[
name|nports
index|]
expr_stmt|;
name|nports
operator|+=
name|sc
operator|->
name|numports
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|PORTBASE
argument_list|)
expr_stmt|;
name|pstat
operator|=
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
operator|&&
name|pstat
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pstat
index|[
name|i
index|]
condition|)
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|status
operator|=
name|ENABLED
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|status
operator|=
name|DISABLED
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: port %d is broken\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* We should now init per-port structures */
name|bc
operator|=
operator|(
expr|struct
name|board_chan
operator|*
operator|)
operator|(
name|mem
operator|+
name|CHANSTRUCT
operator|)
expr_stmt|;
name|sc
operator|->
name|mailbox
operator|=
operator|(
expr|struct
name|global_data
operator|*
operator|)
operator|(
name|mem
operator|+
name|FEP_GLOBAL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|<
literal|3
condition|)
name|shrinkmem
operator|=
literal|1
expr_stmt|;
else|else
name|shrinkmem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
operator|,
name|bc
operator|++
control|)
block|{
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|tty
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|port
operator|->
name|brdchan
operator|=
name|bc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|altpin
condition|)
block|{
name|port
operator|->
name|dsr
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dcd
operator|=
name|DSR
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|dcd
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dsr
operator|=
name|DSR
expr_stmt|;
block|}
name|port
operator|->
name|pnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shrinkmem
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dgb%d: shrinking memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETBUFFER
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shrinkmem
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|!=
name|PCXEVE
condition|)
block|{
name|port
operator|->
name|txptr
operator|=
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|port
operator|->
name|rxwin
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|txptr
operator|=
name|mem
operator|+
operator|(
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
name|mem
operator|+
operator|(
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|FEPWIN
operator||
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
name|port
operator|->
name|rxwin
operator|=
name|FEPWIN
operator||
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
block|}
name|port
operator|->
name|txbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|rxbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|txbufsize
operator|=
name|bc
operator|->
name|tmax
operator|+
literal|1
expr_stmt|;
name|port
operator|->
name|rxbufsize
operator|=
name|bc
operator|->
name|rmax
operator|+
literal|1
expr_stmt|;
name|lowwater
operator|=
operator|(
name|port
operator|->
name|txbufsize
operator|>=
literal|2000
operator|)
condition|?
literal|1024
else|:
operator|(
name|port
operator|->
name|txbufsize
operator|/
literal|2
operator|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STXLWATER
argument_list|,
name|lowwater
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXLWATER
argument_list|,
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXHWATER
argument_list|,
literal|3
operator|*
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|edelay
operator|=
literal|100
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|startc
operator|=
name|bc
operator|->
name|startc
expr_stmt|;
name|port
operator|->
name|startca
operator|=
name|bc
operator|->
name|startca
expr_stmt|;
name|port
operator|->
name|stopc
operator|=
name|bc
operator|->
name|stopc
expr_stmt|;
name|port
operator|->
name|stopca
operator|=
name|bc
operator|->
name|stopca
expr_stmt|;
name|port
operator|->
name|close_delay
operator|=
literal|50
expr_stmt|;
comment|/* 		 * We don't use all the flags from<sys/ttydefaults.h> since they 		 * are only relevant for logins.  It's important to have echo off 		 * initially so that the line doesn't start blathering before the 		 * echo flag can be turned off. 		 */
name|port
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|port
operator|->
name|it_in
argument_list|)
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|port
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|dgbdefaultrate
expr_stmt|;
name|port
operator|->
name|it_out
operator|=
name|port
operator|->
name|it_in
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* register the polling function */
name|timeout
argument_list|(
name|dgbpoll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|unit
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dgbopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDGB
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dgb%d: try to open a nonexisting card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dgb%d: try to open a disabled card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|pnum
operator|>=
name|sc
operator|->
name|numports
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: try to open non-existing port %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
literal|0
return|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|open_top
label|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|port
operator|->
name|closing
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|closing
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"dgocl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: tsleep(dgocl) error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * The device is open, so everything has been initialized. 		 * Handle conflicts. 		 */
if|if
condition|(
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
block|{
if|if
condition|(
operator|!
name|port
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: BUSY error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|port
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: BUSY error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgbi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: tsleep(dgbi) error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it.  Initialization is done twice in many 		 * cases: to preempt sleeping callin opens if we are 		 * callout, and to complete a callin open after DCD rises. 		 */
name|tp
operator|->
name|t_oproc
operator|=
name|dgbstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|dgbparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
condition|?
name|port
operator|->
name|it_out
else|:
name|port
operator|->
name|it_in
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|bc
operator|->
name|mstat
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
comment|/* clear input queue */
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|wopeners
operator|++
expr_stmt|;
name|error
operator|=
name|dgbparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|port
operator|->
name|wopeners
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: dgbparam error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* handle fake DCD for callout devices */
comment|/* and initial DCD */
if|if
condition|(
operator|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dcd
operator|)
operator|||
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for DCD if necessary. 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
operator|++
name|port
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgdcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|port
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: tsleep(dgdcd) error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
argument_list|(
name|dev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: l_open error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|port
operator|->
name|active_out
operator|=
name|TRUE
expr_stmt|;
name|port
operator|->
name|used
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|port
operator|->
name|wopeners
operator|==
literal|0
condition|)
name|dgbhardclose
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: open() returns %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|dgbclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|s
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|port
operator|=
name|sc
operator|->
name|ports
operator|+
name|pnum
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
literal|0
return|;
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: closing\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|dgb_drain_or_flush
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|dgbhardclose
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|closing
argument_list|)
expr_stmt|;
name|port
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|port
operator|->
name|active_out
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgbhardclose
parameter_list|(
name|port
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|s
decl_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|tty
operator|->
name|t_cflag
operator|&
name|HUPCL
condition|)
block|{
name|port
operator|->
name|omodem
operator|&=
operator|~
operator|(
name|RTS
operator||
name|DTR
operator|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
literal|0
argument_list|,
name|DTR
operator||
name|RTS
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|dgb_pause
argument_list|,
operator|&
name|port
operator|->
name|brdchan
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|brdchan
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgclo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgb_pause
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dgbread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
operator|.
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: read() returns %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|dgbwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
operator|.
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: write() returns %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|dgbpoll
parameter_list|(
name|unit_c
parameter_list|)
name|void
modifier|*
name|unit_c
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|int
operator|)
name|unit_c
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u_char
modifier|*
name|eventbuf
decl_stmt|;
name|int
name|event
decl_stmt|,
name|mstat
decl_stmt|,
name|lstat
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rhead
decl_stmt|,
name|rtail
decl_stmt|;
name|int
name|whead
decl_stmt|,
name|wtail
decl_stmt|;
name|int
name|wrapmask
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|ocount
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|==
name|DISABLED
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: polling of disabled board stopped\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|ein
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|eout
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|head
operator|>=
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|||
name|tail
operator|>=
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|||
operator|(
name|head
operator||
name|tail
operator|)
operator|&
literal|03
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: event queue's head or tail is wrong!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
name|eventbuf
operator|=
name|sc
operator|->
name|vmem
operator|+
name|tail
operator|+
name|FEP_ISTART
expr_stmt|;
name|pnum
operator|=
name|eventbuf
index|[
literal|0
index|]
expr_stmt|;
name|event
operator|=
name|eventbuf
index|[
literal|1
index|]
expr_stmt|;
name|mstat
operator|=
name|eventbuf
index|[
literal|2
index|]
expr_stmt|;
name|lstat
operator|=
name|eventbuf
index|[
literal|3
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
if|if
condition|(
name|pnum
operator|>=
name|sc
operator|->
name|numports
operator|||
name|port
operator|->
name|status
operator|==
name|DISABLED
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: port %d: got event on nonexisting port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|used
operator|||
name|port
operator|->
name|wopeners
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|ALL_IND
operator|)
condition|)
name|printf
argument_list|(
literal|"dgb%d: port%d: ? event 0x%x mstat 0x%x lstat 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|event
argument_list|,
name|mstat
argument_list|,
name|lstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|DATA_IND
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: DATA_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|wrapmask
operator|=
name|port
operator|->
name|rxbufsize
operator|-
literal|1
expr_stmt|;
name|rhead
operator|=
name|bc
operator|->
name|rin
operator|&
name|wrapmask
expr_stmt|;
name|rtail
operator|=
name|bc
operator|->
name|rout
operator|&
name|wrapmask
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CREAD
operator|)
operator|||
operator|!
name|port
operator|->
name|used
condition|)
block|{
name|bc
operator|->
name|rout
operator|=
name|rhead
expr_stmt|;
goto|goto
name|end_of_data
goto|;
block|}
if|if
condition|(
name|bc
operator|->
name|orun
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: port%d: overrun\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|bc
operator|->
name|orun
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|rhead
operator|!=
name|rtail
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: port %d: p rx head=%d tail=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|rhead
argument_list|,
name|rtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhead
operator|>
name|rtail
condition|)
name|size
operator|=
name|rhead
operator|-
name|rtail
expr_stmt|;
else|else
name|size
operator|=
name|port
operator|->
name|rxbufsize
operator|-
name|rtail
expr_stmt|;
name|ptr
operator|=
name|port
operator|->
name|rxptr
operator|+
name|rtail
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|size
condition|;
name|c
operator|++
control|)
block|{
name|int
name|chr
decl_stmt|;
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|rxwin
argument_list|)
expr_stmt|;
name|chr
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|if(chr>=' '&& chr<127) 							DPRINT4("dgb%d: port %d: got char '%c'\n", 								unit,pnum,chr); 						else 							DPRINT4("dgb%d: port %d: got char 0x%x\n", 								unit,pnum,chr);
endif|#
directive|endif
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
argument_list|(
name|chr
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtail
operator|=
operator|(
name|rtail
operator|+
name|size
operator|)
operator|&
name|wrapmask
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|rtail
expr_stmt|;
name|rhead
operator|=
name|bc
operator|->
name|rin
operator|&
name|wrapmask
expr_stmt|;
block|}
name|end_of_data
label|:
block|}
if|if
condition|(
name|event
operator|&
name|MODEMCHG_IND
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: MODEMCHG_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|mstat
expr_stmt|;
if|if
condition|(
name|mstat
operator|&
name|port
operator|->
name|dcd
condition|)
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|draining
condition|)
block|{
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|&
name|BREAK_IND
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: BREAK_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
argument_list|(
name|TTY_BI
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event
operator|&
operator|(
name|LOWTX_IND
operator||
name|EMPTYTX_IND
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: LOWTX_IND or EMPTYTX_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|&
name|EMPTYTX_IND
operator|)
operator|&&
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
operator|&&
name|port
operator|->
name|draining
condition|)
block|{
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
block|}
name|wrapmask
operator|=
name|port
operator|->
name|txbufsize
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|whead
operator|=
name|bc
operator|->
name|tin
operator|&
name|wrapmask
expr_stmt|;
name|wtail
operator|=
name|bc
operator|->
name|tout
operator|&
name|wrapmask
expr_stmt|;
name|DPRINT5
argument_list|(
literal|"dgb%d: port%d: p tx head=%d tail=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|whead
argument_list|,
name|wtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|whead
operator|<
name|wtail
condition|)
name|size
operator|=
name|wtail
operator|-
name|whead
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|whead
expr_stmt|;
if|if
condition|(
name|wtail
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|1
expr_stmt|;
goto|goto
name|end_of_buffer
goto|;
block|}
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|txwin
argument_list|)
expr_stmt|;
name|ocount
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|port
operator|->
name|txptr
operator|+
name|whead
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|whead
operator|+=
name|ocount
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|whead
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
endif|#
directive|endif
name|end_of_buffer
label|:
block|}
block|}
else|else
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: got event 0x%x on closed port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
name|bc
operator|->
name|iempty
operator|=
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
block|}
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
operator|(
name|tail
operator|+
literal|4
operator|)
operator|&
operator|(
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|-
literal|4
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|mailbox
operator|->
name|eout
operator|=
name|tail
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|dgbpoll
argument_list|,
name|unit_c
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dgbintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|dgbioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|tiocm_xxx
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|it_out
else|:
operator|&
name|port
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|lt_out
else|:
operator|&
name|port
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|lt_out
else|:
operator|&
name|port
operator|->
name|lt_in
decl_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSTOP
condition|)
block|{
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|PAUSETX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|TIOCSTART
condition|)
block|{
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|RESUMETX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
name|port
operator|->
name|mustdrain
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|port
operator|->
name|mustdrain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
name|error
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|error
operator|=
name|dgbdrain
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* now it sends 250 millisecond break because I don't know */
comment|/* how to send an infinite break */
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SENDBREAK
argument_list|,
literal|250
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
comment|/* now it's empty */
break|break;
case|case
name|TIOCSDTR
case|:
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: set DTR\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bc
operator|->
name|mstat
operator|&
name|DTR
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: DTR is off\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: reset DTR\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|mstat
operator|&
name|DTR
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: DTR is on\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
else|else
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator||=
name|RTS
expr_stmt|;
else|else
name|port
operator|->
name|omodem
operator|&=
operator|~
name|RTS
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator||=
name|RTS
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator|&=
operator|~
name|RTS
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|bc
operator|->
name|mstat
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* XXX - always enabled while open */
name|DPRINT3
argument_list|(
literal|"dgb%d: port %d: modem stat -- "
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|DTR
condition|)
block|{
name|DPRINT1
argument_list|(
literal|"DTR "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_DTR
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|RTS
condition|)
block|{
name|DPRINT1
argument_list|(
literal|"RTS "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_RTS
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|CTS
condition|)
block|{
name|DPRINT1
argument_list|(
literal|"CTS "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_CTS
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dcd
condition|)
block|{
name|DPRINT1
argument_list|(
literal|"DCD "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_CD
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dsr
condition|)
block|{
name|DPRINT1
argument_list|(
literal|"DSR "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_DSR
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|RI
condition|)
block|{
name|DPRINT1
argument_list|(
literal|"RI "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_RI
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tiocm_xxx
expr_stmt|;
name|DPRINT1
argument_list|(
literal|"--\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wakeflush
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|dgb_p
modifier|*
name|port
init|=
name|p
decl_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wait for the output to drain */
end_comment

begin_function
specifier|static
name|int
name|dgbdrain
parameter_list|(
name|port
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|port
operator|->
name|tty
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|head
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: port %d: drain: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|wakeflush
argument_list|,
name|port
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgdrn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: tsleep(dgdrn) error=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
block|}
name|DPRINT5
argument_list|(
literal|"dgb%d: port %d: drain: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* wait for the output to drain */
end_comment

begin_comment
comment|/* or simply clear the buffer it it's stopped */
end_comment

begin_function
specifier|static
name|void
name|dgb_drain_or_flush
parameter_list|(
name|port
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|port
operator|->
name|tty
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|lasttail
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lasttail
operator|=
operator|-
literal|1
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|head
comment|/*&& tail!=lasttail */
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: port %d: flush: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* if there is no carrier simply clean the buffer */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|wakeflush
argument_list|,
name|port
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgfls"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: tsleep(dgfls) error=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* silently clean the buffer */
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|lasttail
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
block|}
name|DPRINT5
argument_list|(
literal|"dgb%d: port %d: flush: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgbparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|dev
init|=
name|tp
operator|->
name|t_dev
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|MINOR_TO_UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|pnum
init|=
name|MINOR_TO_PORT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
init|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|cflag
decl_stmt|;
name|int
name|head
decl_stmt|;
name|int
name|mval
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|int
name|hflow
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: setting parameters\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|mustdrain
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: must call dgbdrain()\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgbdrain
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|cflag
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|dgbspeedtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
if|if
condition|(
name|cflag
operator|<
literal|0
operator|||
name|cflag
operator|>
literal|0
operator|&&
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
block|{
comment|/* hangup */
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: hangup\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STOUT
argument_list|,
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mval
operator|=
name|port
operator|->
name|omodem
operator|&
operator|~
operator|(
name|DTR
operator||
name|RTS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port%d: CBAUD=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|cflag
argument_list|)
expr_stmt|;
comment|/* convert flags to sysV-style values */
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|PARODD
condition|)
name|cflag
operator||=
literal|01000
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|PARENB
condition|)
name|cflag
operator||=
literal|00400
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSTOPB
condition|)
name|cflag
operator||=
literal|00100
expr_stmt|;
name|cflag
operator||=
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CSIZE
operator|)
operator|>>
literal|4
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port%d: CFLAG=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|cflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|!=
name|port
operator|->
name|fepcflag
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: set cflag\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|fepcflag
operator|=
name|cflag
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETCTRLFLAGS
argument_list|,
operator|(
name|unsigned
operator|)
name|cflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mval
operator|=
name|port
operator|->
name|omodem
operator||
operator|(
name|DTR
operator||
name|RTS
operator|)
expr_stmt|;
block|}
name|iflag
operator|=
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNBRK
operator||
name|BRKINT
operator||
name|IGNPAR
operator||
name|PARMRK
operator||
name|INPCK
operator||
name|ISTRIP
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|IXON
condition|)
name|cflag
operator||=
literal|002000
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|IXANY
condition|)
name|cflag
operator||=
literal|004000
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|IXOFF
condition|)
name|cflag
operator||=
literal|010000
expr_stmt|;
if|if
condition|(
name|iflag
operator|!=
name|port
operator|->
name|fepiflag
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: set iflag\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|fepiflag
operator|=
name|iflag
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETIFLAGS
argument_list|,
operator|(
name|unsigned
operator|)
name|iflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bc
operator|->
name|mint
operator|=
name|port
operator|->
name|dcd
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
condition|)
name|hflow
operator|=
operator|(
name|CTS
operator||
name|RTS
operator|)
expr_stmt|;
else|else
name|hflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hflow
operator|!=
name|port
operator|->
name|hflow
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: set hflow\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|hflow
operator|=
name|hflow
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETHFLOW
argument_list|,
operator|(
name|unsigned
operator|)
name|hflow
argument_list|,
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|omodem
operator|!=
name|mval
condition|)
block|{
name|DPRINT4
argument_list|(
literal|"dgb%d: port %d: setting modem parameters 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|mval
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator|=
name|mval
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
operator|(
name|unsigned
operator|)
name|mval
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|fepstartc
operator|!=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|||
name|port
operator|->
name|fepstopc
operator|!=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
condition|)
block|{
name|DPRINT3
argument_list|(
literal|"dgb%d: port%d: set startc, stopc\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|fepstartc
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|port
operator|->
name|fepstopc
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SONOFFC
argument_list|,
name|port
operator|->
name|fepstartc
argument_list|,
name|port
operator|->
name|fepstopc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgbstart
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|size
decl_stmt|,
name|ocount
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|wmask
decl_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|wmask
operator|=
name|port
operator|->
name|txbufsize
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
operator|&
name|wmask
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
operator|&
name|wmask
expr_stmt|;
name|DPRINT5
argument_list|(
literal|"dgb%d: port%d: s tx head=%d tail=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|>
name|head
condition|)
name|size
operator|=
name|tail
operator|-
name|head
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|head
expr_stmt|;
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|1
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|txwin
argument_list|)
expr_stmt|;
name|ocount
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|port
operator|->
name|txptr
operator|+
name|head
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|head
operator|+=
name|ocount
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|head
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
endif|#
directive|endif
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dgbstop
parameter_list|(
name|tp
parameter_list|,
name|rw
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|dgbselect
parameter_list|(
name|dev
parameter_list|,
name|rw
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|rw
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ti
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|port
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
comment|/* get index in the tty table */
name|ti
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|port
index|]
operator|-
name|dgb_tty
expr_stmt|;
return|return
operator|(
name|ttselect
argument_list|(
name|ti
argument_list|,
name|rw
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fepcmd
parameter_list|(
name|port
parameter_list|,
name|cmd
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|ncmds
parameter_list|,
name|bytecmd
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|ncmds
decl_stmt|,
name|bytecmd
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|mem
init|=
name|sc
operator|->
name|vmem
decl_stmt|;
name|unsigned
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|int
name|count
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|status
operator|==
name|DISABLED
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d(%d): FEP command on disabled port\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|)
expr_stmt|;
return|return;
block|}
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|cin
expr_stmt|;
if|if
condition|(
name|head
operator|>=
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|)
operator|||
operator|(
name|head
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d(%d): wrong pointer head of command queue : 0x%x\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bytecmd
condition|)
block|{
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|1
index|]
operator|=
name|port
operator|->
name|pnum
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
operator|=
name|op1
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
operator|=
name|op2
expr_stmt|;
block|}
else|else
block|{
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|1
index|]
operator|=
name|port
operator|->
name|pnum
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
operator|)
operator|=
name|op1
expr_stmt|;
block|}
name|head
operator|=
operator|(
name|head
operator|+
literal|4
operator|)
operator|&
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|-
literal|4
operator|)
expr_stmt|;
name|sc
operator|->
name|mailbox
operator|->
name|cin
operator|=
name|head
expr_stmt|;
for|for
control|(
name|count
operator|=
name|FEPTIMEOUT
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|cin
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|cout
expr_stmt|;
name|n
operator|=
operator|(
name|head
operator|-
name|tail
operator|)
operator|&
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
name|ncmds
operator|*
literal|4
condition|)
return|return;
block|}
name|printf
argument_list|(
literal|"dgb%d(%d): timeout on FEP command\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NDGB> 0 */
end_comment

end_unit

