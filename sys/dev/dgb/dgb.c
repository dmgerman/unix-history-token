begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  dgb.c $FreeBSD$  *  *  Digiboard driver.  *  *  Stage 1. "Better than nothing".  *  Stage 2. "Gee, it works!".  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions of binary code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification, in the accompanying documentation.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *  Written by Sergey Babkin,  *      Joint Stock Commercial Bank "Chelindbank"  *      (Chelyabinsk, Russia)  *      babkin@freebsd.org  *  *  Assorted hacks to make it more functional and working under 3.0-current.  *  Fixed broken routines to prevent processes hanging on closed (thanks  *  to Bruce for his patience and assistance). Thanks also to Maxim Bolotin  *<max@run.net> for his patches which did most of the work to get this  *  running under 2.2/3.0-current.  *  Implemented ioctls: TIOCMSDTRWAIT, TIOCMGDTRWAIT, TIOCTIMESTAMP&  *  TIOCDCDTIMESTAMP.  *  Sysctl debug flag is now a bitflag, to filter noise during debugging.  *	David L. Nugent<davidn@blaze.net.au>  *  * There was a copyright confusion: I thought that having read the  * GLPed drivers makes me mentally contaminated but in fact it does  * not. Since the Linux driver by Troy De Jongh<troyd@digibd.com> or   *<troyd@skypoint.com> was used unly to learn the Digi's interface,  * I've returned this driver to a BSD-style license. I tried to contact  * all the contributors and those who replied agreed with license  * change. If you did any contribution when the driver was GPLed and do   * not agree with the BSD-style re-licensing please contact me.  *  -SB  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_dgb.h"
end_include

begin_include
include|#
directive|include
file|"dgb.h"
end_include

begin_comment
comment|/* Helg: i.e.25 times per sec board will be polled */
end_comment

begin_define
define|#
directive|define
name|POLLSPERSEC
value|25
end_define

begin_comment
comment|/* How many charactes can we write to input tty rawq */
end_comment

begin_define
define|#
directive|define
name|DGB_IBUFSIZE
value|(TTYHOG-100)
end_define

begin_comment
comment|/* the overall number of ports controlled by this driver */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDGBPORTS
end_ifndef

begin_define
define|#
directive|define
name|NDGBPORTS
value|(NDGB*16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDISA
end_ifndef

begin_error
error|#
directive|error
literal|"The dgb device requires the old isa compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/dgb/dgbios.h>
end_include

begin_include
include|#
directive|include
file|<dev/dgb/dgfep.h>
end_include

begin_define
define|#
directive|define
name|DGB_DEBUG
end_define

begin_comment
comment|/* Enable debugging info via sysctl */
end_comment

begin_include
include|#
directive|include
file|<dev/dgb/dgreg.h>
end_include

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|UNIT_MASK
value|0x30000
end_define

begin_define
define|#
directive|define
name|PORT_MASK
value|0x1F
end_define

begin_define
define|#
directive|define
name|DEV_TO_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev)))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_UNIT
parameter_list|(
name|mynor
parameter_list|)
value|(((mynor)& UNIT_MASK)>>16)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_PORT
parameter_list|(
name|mynor
parameter_list|)
value|((mynor)& PORT_MASK)
end_define

begin_comment
comment|/* types.  XXX - should be elsewhere */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_comment
comment|/* boolean */
end_comment

begin_comment
comment|/* digiboard port structure */
end_comment

begin_struct
struct|struct
name|dgb_p
block|{
name|bool_t
name|status
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
comment|/* board unit number */
name|u_char
name|pnum
decl_stmt|;
comment|/* port number */
name|u_char
name|omodem
decl_stmt|;
comment|/* FEP output modem status     */
name|u_char
name|imodem
decl_stmt|;
comment|/* FEP input modem status      */
name|u_char
name|modemfake
decl_stmt|;
comment|/* Modem values to be forced   */
name|u_char
name|modem
decl_stmt|;
comment|/* Force values                */
name|u_char
name|hflow
decl_stmt|;
name|u_char
name|dsr
decl_stmt|;
name|u_char
name|dcd
decl_stmt|;
name|u_char
name|stopc
decl_stmt|;
name|u_char
name|startc
decl_stmt|;
name|u_char
name|stopca
decl_stmt|;
name|u_char
name|startca
decl_stmt|;
name|u_char
name|fepstopc
decl_stmt|;
name|u_char
name|fepstartc
decl_stmt|;
name|u_char
name|fepstopca
decl_stmt|;
name|u_char
name|fepstartca
decl_stmt|;
name|u_char
name|txwin
decl_stmt|;
name|u_char
name|rxwin
decl_stmt|;
name|ushort
name|fepiflag
decl_stmt|;
name|ushort
name|fepcflag
decl_stmt|;
name|ushort
name|fepoflag
decl_stmt|;
name|ushort
name|txbufhead
decl_stmt|;
name|ushort
name|txbufsize
decl_stmt|;
name|ushort
name|rxbufhead
decl_stmt|;
name|ushort
name|rxbufsize
decl_stmt|;
name|int
name|close_delay
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|blocked_open
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|asyncflags
decl_stmt|;
name|u_long
name|statusflags
decl_stmt|;
name|u_char
modifier|*
name|txptr
decl_stmt|;
name|u_char
modifier|*
name|rxptr
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|brdchan
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|bool_t
name|active_out
decl_stmt|;
comment|/* nonzero if the callout device is open */
name|u_int
name|wopeners
decl_stmt|;
comment|/* # processes waiting for DCD in open() */
comment|/* Initial state. */
name|struct
name|termios
name|it_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|it_out
decl_stmt|;
comment|/* Lock state. */
name|struct
name|termios
name|lt_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|lt_out
decl_stmt|;
name|bool_t
name|do_timestamp
decl_stmt|;
name|bool_t
name|do_dcd_timestamp
decl_stmt|;
name|struct
name|timeval
name|timestamp
decl_stmt|;
name|struct
name|timeval
name|dcd_timestamp
decl_stmt|;
comment|/* flags of state, are used in sleep() too */
name|u_char
name|closing
decl_stmt|;
comment|/* port is being closed now */
name|u_char
name|draining
decl_stmt|;
comment|/* port is being drained now */
name|u_char
name|used
decl_stmt|;
comment|/* port is being used now */
name|u_char
name|mustdrain
decl_stmt|;
comment|/* data must be waited to drain in dgbparam() */
block|}
struct|;
end_struct

begin_comment
comment|/* Digiboard per-board structure */
end_comment

begin_struct
struct|struct
name|dgb_softc
block|{
comment|/* struct board_info */
name|u_char
name|status
decl_stmt|;
comment|/* status: DISABLED/ENABLED */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number */
name|u_char
name|type
decl_stmt|;
comment|/* type of card: PCXE, PCXI, PCXEVE */
name|u_char
name|altpin
decl_stmt|;
comment|/* do we need alternate pin setting ? */
name|int
name|numports
decl_stmt|;
comment|/* number of ports on card */
name|int
name|port
decl_stmt|;
comment|/* I/O port */
name|u_char
modifier|*
name|vmem
decl_stmt|;
comment|/* virtual memory address */
name|long
name|pmem
decl_stmt|;
comment|/* physical memory address */
name|int
name|mem_seg
decl_stmt|;
comment|/* internal memory segment */
name|struct
name|dgb_p
modifier|*
name|ports
decl_stmt|;
comment|/* pointer to array of port descriptors */
name|struct
name|tty
modifier|*
name|ttys
decl_stmt|;
comment|/* pointer to array of TTY structures */
specifier|volatile
name|struct
name|global_data
modifier|*
name|mailbox
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dgb_softc
name|dgb_softc
index|[
name|NDGB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dgb_p
name|dgb_ports
index|[
name|NDGBPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tty
name|dgb_tty
index|[
name|NDGBPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The public functions in the com module ought to be declared in a com-driver  * system header.  */
end_comment

begin_comment
comment|/* Interrupt handling entry points. */
end_comment

begin_function_decl
specifier|static
name|void
name|dgbpoll
parameter_list|(
name|void
modifier|*
name|unit_c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Device switch entry points. */
end_comment

begin_define
define|#
directive|define
name|dgbreset
value|noreset
end_define

begin_define
define|#
directive|define
name|dgbmmap
value|nommap
end_define

begin_define
define|#
directive|define
name|dgbstrategy
value|nostrategy
end_define

begin_function_decl
specifier|static
name|int
name|dgbattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgbprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fepcmd
parameter_list|(
name|struct
name|dgb_p
modifier|*
name|port
parameter_list|,
name|unsigned
name|cmd
parameter_list|,
name|unsigned
name|op1
parameter_list|,
name|unsigned
name|op2
parameter_list|,
name|unsigned
name|ncmds
parameter_list|,
name|unsigned
name|bytecmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgbstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgbstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgbparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgbhardclose
parameter_list|(
name|struct
name|dgb_p
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgb_drain_or_flush
parameter_list|(
name|struct
name|dgb_p
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dgbdrain
parameter_list|(
name|struct
name|dgb_p
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dgb_pause
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wakeflush
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disc_optim
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|dgbdriver
init|=
block|{
name|INTR_TYPE_TTY
block|,
name|dgbprobe
block|,
name|dgbattach
block|,
literal|"dgb"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_ISA_DRIVER
argument_list|(
name|dgb
argument_list|,
name|dgbdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|dgbopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dgbclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dgbioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|58
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|dgb_cdevsw
init|=
block|{
comment|/* open */
name|dgbopen
block|,
comment|/* close */
name|dgbclose
block|,
comment|/* read */
name|ttyread
block|,
comment|/* write */
name|ttywrite
block|,
comment|/* ioctl */
name|dgbioctl
block|,
comment|/* poll */
name|ttypoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"dgb"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_TTY
operator||
name|D_KQFILTER
block|,
comment|/* kqfilter */
name|ttykqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|speed_t
name|dgbdefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|dgbspeedtab
index|[]
init|=
block|{
block|{
literal|0
block|,
name|FEP_B0
block|}
block|,
comment|/* old (sysV-like) Bx codes */
block|{
literal|50
block|,
name|FEP_B50
block|}
block|,
block|{
literal|75
block|,
name|FEP_B75
block|}
block|,
block|{
literal|110
block|,
name|FEP_B110
block|}
block|,
block|{
literal|134
block|,
name|FEP_B134
block|}
block|,
block|{
literal|150
block|,
name|FEP_B150
block|}
block|,
block|{
literal|200
block|,
name|FEP_B200
block|}
block|,
block|{
literal|300
block|,
name|FEP_B300
block|}
block|,
block|{
literal|600
block|,
name|FEP_B600
block|}
block|,
block|{
literal|1200
block|,
name|FEP_B1200
block|}
block|,
block|{
literal|1800
block|,
name|FEP_B1800
block|}
block|,
block|{
literal|2400
block|,
name|FEP_B2400
block|}
block|,
block|{
literal|4800
block|,
name|FEP_B4800
block|}
block|,
block|{
literal|9600
block|,
name|FEP_B9600
block|}
block|,
block|{
literal|19200
block|,
name|FEP_B19200
block|}
block|,
block|{
literal|38400
block|,
name|FEP_B38400
block|}
block|,
block|{
literal|57600
block|,
operator|(
name|FEP_FASTBAUD
operator||
name|FEP_B50
operator|)
block|}
block|,
comment|/* B50& fast baud table */
block|{
literal|115200
block|,
operator|(
name|FEP_FASTBAUD
operator||
name|FEP_B110
operator|)
block|}
block|,
comment|/* B100& fast baud table */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|dbgflagtbl
block|{
name|tcflag_t
name|in_mask
decl_stmt|;
name|tcflag_t
name|in_val
decl_stmt|;
name|tcflag_t
name|out_val
decl_stmt|;
block|}
name|dgb_cflags
index|[]
init|=
block|{
block|{
name|PARODD
block|,
name|PARODD
block|,
name|FEP_PARODD
block|}
block|,
block|{
name|PARENB
block|,
name|PARENB
block|,
name|FEP_PARENB
block|}
block|,
block|{
name|CSTOPB
block|,
name|CSTOPB
block|,
name|FEP_CSTOPB
block|}
block|,
block|{
name|CSIZE
block|,
name|CS5
block|,
name|FEP_CS6
block|}
block|,
block|{
name|CSIZE
block|,
name|CS6
block|,
name|FEP_CS6
block|}
block|,
block|{
name|CSIZE
block|,
name|CS7
block|,
name|FEP_CS7
block|}
block|,
block|{
name|CSIZE
block|,
name|CS8
block|,
name|FEP_CS8
block|}
block|,
block|{
name|CLOCAL
block|,
name|CLOCAL
block|,
name|FEP_CLOCAL
block|}
block|,
block|{
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
block|}
block|}
struct|,
name|dgb_iflags
index|[]
init|=
block|{
block|{
name|IGNBRK
block|,
name|IGNBRK
block|,
name|FEP_IGNBRK
block|}
block|,
block|{
name|BRKINT
block|,
name|BRKINT
block|,
name|FEP_BRKINT
block|}
block|,
block|{
name|IGNPAR
block|,
name|IGNPAR
block|,
name|FEP_IGNPAR
block|}
block|,
block|{
name|PARMRK
block|,
name|PARMRK
block|,
name|FEP_PARMRK
block|}
block|,
block|{
name|INPCK
block|,
name|INPCK
block|,
name|FEP_INPCK
block|}
block|,
block|{
name|ISTRIP
block|,
name|ISTRIP
block|,
name|FEP_ISTRIP
block|}
block|,
block|{
name|IXON
block|,
name|IXON
block|,
name|FEP_IXON
block|}
block|,
block|{
name|IXOFF
block|,
name|IXOFF
block|,
name|FEP_IXOFF
block|}
block|,
block|{
name|IXANY
block|,
name|IXANY
block|,
name|FEP_IXANY
block|}
block|,
block|{
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
block|}
block|}
struct|,
name|dgb_flow
index|[]
init|=
block|{
block|{
name|CRTSCTS
block|,
name|CRTSCTS
block|,
name|CTS
operator||
name|RTS
block|}
block|,
block|{
name|CRTSCTS
block|,
name|CCTS_OFLOW
block|,
name|CTS
block|}
block|,
block|{
name|CRTSCTS
block|,
name|CRTS_IFLOW
block|,
name|RTS
block|}
block|,
block|{
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* xlat bsd termios flags to dgb sys-v style */
end_comment

begin_function
specifier|static
name|tcflag_t
name|dgbflags
parameter_list|(
name|struct
name|dbgflagtbl
modifier|*
name|tbl
parameter_list|,
name|tcflag_t
name|input
parameter_list|)
block|{
name|tcflag_t
name|output
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tbl
index|[
name|i
index|]
operator|.
name|in_mask
operator|!=
operator|(
name|tcflag_t
operator|)
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|input
operator|&
name|tbl
index|[
name|i
index|]
operator|.
name|in_mask
operator|)
operator|==
name|tbl
index|[
name|i
index|]
operator|.
name|in_val
condition|)
name|output
operator||=
name|tbl
index|[
name|i
index|]
operator|.
name|out_val
expr_stmt|;
block|}
return|return
name|output
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DGB_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|dgbdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dgb_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dgbdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|__inline
name|int
name|setwin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|setinitwin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|hidewin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|towin
parameter_list|(
name|struct
name|dgb_softc
modifier|*
name|sc
parameter_list|,
name|int
name|win
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*Helg: to allow recursive dgb...() calls */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* If we were called and don't want to disturb we need: */
name|int
name|port
decl_stmt|;
comment|/* write to this port */
name|u_char
name|data
decl_stmt|;
comment|/* this data on exit */
comment|/* or DATA_WINOFF  to close memory window on entry */
block|}
name|BoardMemWinState
typedef|;
end_typedef

begin_comment
comment|/* so several channels and even boards can coexist */
end_comment

begin_define
define|#
directive|define
name|DATA_WINOFF
value|0
end_define

begin_decl_stmt
specifier|static
name|BoardMemWinState
name|bmws
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return current memory window state and close window */
end_comment

begin_function
specifier|static
name|BoardMemWinState
name|bmws_get
parameter_list|(
name|void
parameter_list|)
block|{
name|BoardMemWinState
name|bmwsRet
init|=
name|bmws
decl_stmt|;
if|if
condition|(
name|bmws
operator|.
name|data
operator|!=
name|DATA_WINOFF
condition|)
name|outb
argument_list|(
name|bmws
operator|.
name|port
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|DATA_WINOFF
argument_list|)
expr_stmt|;
return|return
name|bmwsRet
return|;
block|}
end_function

begin_comment
comment|/* restore memory window state */
end_comment

begin_function
specifier|static
name|void
name|bmws_set
parameter_list|(
name|BoardMemWinState
name|ws
parameter_list|)
block|{
if|if
condition|(
name|ws
operator|.
name|data
operator|!=
name|bmws
operator|.
name|data
operator|||
name|ws
operator|.
name|port
operator|!=
name|bmws
operator|.
name|port
condition|)
block|{
if|if
condition|(
name|bmws
operator|.
name|data
operator|!=
name|DATA_WINOFF
condition|)
name|outb
argument_list|(
name|bmws
operator|.
name|port
argument_list|,
name|DATA_WINOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|data
operator|!=
name|DATA_WINOFF
condition|)
name|outb
argument_list|(
name|ws
operator|.
name|port
argument_list|,
name|ws
operator|.
name|data
argument_list|)
expr_stmt|;
name|bmws
operator|=
name|ws
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|setwin
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|13
operator|)
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_WIN
argument_list|,
literal|"dgb%d: switched to window 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|addr
operator|>>
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x1FFF
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|FEPMEM
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|setinitwin
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|13
operator|)
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_WIN
argument_list|,
literal|"dgb%d: switched to window 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|addr
operator|>>
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x1FFF
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator||
name|FEPMEM
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|hidewin
parameter_list|(
name|sc
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bmws
operator|.
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
argument_list|,
name|bmws
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|towin
parameter_list|(
name|sc
parameter_list|,
name|win
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|bmws
operator|.
name|port
operator|=
name|sc
operator|->
name|port
argument_list|,
name|bmws
operator|.
name|data
operator|=
name|FEPMEM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dgbprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|;
name|u_long
name|win_size
decl_stmt|;
comment|/* size of vizible memory window */
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|sc
operator|->
name|port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|&
name|DGBFLAG_ALTPIN
condition|)
name|sc
operator|->
name|altpin
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|altpin
operator|=
literal|0
expr_stmt|;
comment|/* left 24 bits only (ISA address) */
name|sc
operator|->
name|pmem
operator|=
operator|(
operator|(
name|intptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|dev
operator|->
name|id_maddr
operator|&
literal|0xFFFFFF
operator|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: port 0x%x mem 0x%lx\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|==
name|FEPRST
condition|)
block|{
name|sc
operator|->
name|status
operator|=
name|ENABLED
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: got reset after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: failed to respond\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check type of card and get internal memory characteristics */
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x1
condition|)
block|{
switch|switch
condition|(
name|v
operator|&
literal|0x30
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xF000
expr_stmt|;
name|win_size
operator|=
literal|0x10000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 64K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xE000
expr_stmt|;
name|win_size
operator|=
literal|0x20000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 128K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xC000
expr_stmt|;
name|win_size
operator|=
literal|0x40000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 256K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* case 0x30: */
name|sc
operator|->
name|mem_seg
operator|=
literal|0x8000
expr_stmt|;
name|win_size
operator|=
literal|0x80000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 512K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|type
operator|=
name|PCXI
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x1
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: PC/Xm isn't supported\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|mem_seg
operator|=
literal|0xF000
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|==
name|DGBFLAG_NOWIN
operator|||
operator|(
name|v
operator|&
literal|0xC0
operator|)
operator|==
literal|0
condition|)
block|{
name|win_size
operator|=
literal|0x10000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xe 64K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXE
expr_stmt|;
block|}
else|else
block|{
name|win_size
operator|=
literal|0x2000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xe 64/8K (windowed)\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXEVE
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|&
operator|~
literal|0xFFE000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: warning: address 0x%lx truncated to 0x%lx\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|pmem
argument_list|,
name|sc
operator|->
name|pmem
operator|&
literal|0xFFE000
argument_list|)
expr_stmt|;
name|dev
operator|->
name|id_maddr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
call|(
name|intptr_t
call|)
argument_list|(
name|sc
operator|->
name|pmem
operator|&
literal|0xFFE000
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* save size of vizible memory segment */
name|dev
operator|->
name|id_msize
operator|=
name|win_size
expr_stmt|;
comment|/* map memory */
name|dev
operator|->
name|id_maddr
operator|=
name|sc
operator|->
name|vmem
operator|=
name|pmap_mapdev
argument_list|(
name|sc
operator|->
name|pmem
argument_list|,
name|dev
operator|->
name|id_msize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
comment|/* drop RESET */
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Helg: to set initial bmws state */
return|return
literal|4
return|;
comment|/* we need I/O space of 4 ports */
block|}
end_function

begin_function
specifier|static
name|int
name|dgbattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|u_char
specifier|volatile
modifier|*
name|mem
decl_stmt|;
name|u_char
specifier|volatile
modifier|*
name|ptr
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|shrinkmem
decl_stmt|;
name|int
name|nfails
decl_stmt|;
specifier|volatile
name|ushort
modifier|*
name|pstat
decl_stmt|;
name|int
name|lowwater
decl_stmt|;
specifier|static
name|int
name|nports
init|=
literal|0
decl_stmt|;
name|char
name|suffix
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dbg%d: try to attach a disabled card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: internal memory segment 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|mem_seg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPRST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 1st reset failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: got reset after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* for PCXEVE set up interrupt and base address */
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|>>
literal|8
operator|)
operator|&
literal|0xFFE0
operator|)
operator||
literal|0x10
comment|/* enable windowing */
expr_stmt|;
comment|/* IRQ isn't used */
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|>>
literal|8
operator|)
operator|&
literal|0xFFE0
operator|)
comment|/* disable windowing */
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXI
operator|||
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
operator||
name|FEPMEM
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
operator|(
name|FEPRST
operator||
name|FEPMEM
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 2nd reset failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: got memory after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
comment|/* very short memory test */
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|BOTWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0xA55A3CC3
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0xA55A3CC3
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 1st memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|TOPWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 2nd memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 3rd (BIOS) memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|mem
index|[
name|addr
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXI
operator|||
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|addr
operator|=
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: BIOS local address=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
operator|*
name|ptr
operator|=
name|pcxx_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
name|nfails
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|!=
name|pcxx_bios
index|[
name|i
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: wrong code in BIOS at addr 0x%x : \ 0x%x instead of 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|ptr
operator|-
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|,
operator|*
name|ptr
argument_list|,
name|pcxx_bios
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nfails
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 4th memory test (BIOS load) fails\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPMEM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: BIOS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: reset dropped after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
operator|)
operator|==
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
operator|)
condition|)
goto|goto
name|load_fep
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dgb%d: BIOS download failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: code=0x%x must be 0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
operator|)
argument_list|,
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
comment|/* set window 7 */
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
operator|(
name|BIOSCODE
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcxx_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
operator|(
name|BIOSCODE
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|nfails
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|!=
name|pcxx_bios
index|[
name|i
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: wrong code in BIOS at addr 0x%x : \ 0x%x instead of 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|ptr
operator|-
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|,
operator|*
name|ptr
argument_list|,
name|pcxx_bios
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nfails
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 4th memory test (BIOS load) fails\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPCLR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: BIOS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: reset dropped after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|==
operator|*
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
condition|)
goto|goto
name|load_fep
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dgb%d: BIOS download failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: Error#(0x%x,0x%x) code=0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
literal|0xC12
operator|)
argument_list|,
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
literal|0xC14
operator|)
argument_list|,
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|load_fep
label|:
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: BIOS loaded\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPCODE
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_ncook
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcxx_cook
index|[
name|i
index|]
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MBOX
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0
operator|)
operator|=
literal|2
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|2
operator|)
operator|=
name|sc
operator|->
name|mem_seg
operator|+
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|6
operator|)
operator|=
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|8
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|10
operator|)
operator|=
name|pcxx_ncook
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
operator||
name|FEPINT
argument_list|)
expr_stmt|;
comment|/* send interrupt to BIOS */
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|200000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: FEP code download failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: code=0x%x must be 0\n"
argument_list|,
name|unit
argument_list|,
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: FEP code loaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPSTAT
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MBOX
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0
operator|)
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|2
operator|)
operator|=
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0x4
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPINT
argument_list|)
expr_stmt|;
comment|/* send interrupt to BIOS */
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPSTAT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
operator|*
operator|(
name|ushort
operator|*
operator|)
literal|"OS"
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|200000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: FEP/OS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: FEP/OS started\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
operator|*
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|NPORT
argument_list|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: %d ports\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|numports
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|>
name|MAX_DGB_PORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: too many ports\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nports
operator|+
name|sc
operator|->
name|numports
operator|>
name|NDGBPORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: only %d ports are usable\n"
argument_list|,
name|unit
argument_list|,
name|NDGBPORTS
operator|-
name|nports
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
name|NDGBPORTS
operator|-
name|nports
expr_stmt|;
block|}
comment|/* allocate port and tty structures */
name|sc
operator|->
name|ports
operator|=
operator|&
name|dgb_ports
index|[
name|nports
index|]
expr_stmt|;
name|sc
operator|->
name|ttys
operator|=
operator|&
name|dgb_tty
index|[
name|nports
index|]
expr_stmt|;
name|nports
operator|+=
name|sc
operator|->
name|numports
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|PORTBASE
argument_list|)
expr_stmt|;
name|pstat
operator|=
operator|(
name|ushort
specifier|volatile
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
operator|&&
name|pstat
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pstat
index|[
name|i
index|]
condition|)
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|status
operator|=
name|ENABLED
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|status
operator|=
name|DISABLED
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: port%d is broken\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* We should now init per-port structures */
name|bc
operator|=
operator|(
specifier|volatile
expr|struct
name|board_chan
operator|*
operator|)
operator|(
name|mem
operator|+
name|CHANSTRUCT
operator|)
expr_stmt|;
name|sc
operator|->
name|mailbox
operator|=
operator|(
specifier|volatile
expr|struct
name|global_data
operator|*
operator|)
operator|(
name|mem
operator|+
name|FEP_GLOBAL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|<
literal|3
condition|)
name|shrinkmem
operator|=
literal|1
expr_stmt|;
else|else
name|shrinkmem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
operator|,
name|bc
operator|++
control|)
block|{
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|tty
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|port
operator|->
name|brdchan
operator|=
name|bc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|altpin
condition|)
block|{
name|port
operator|->
name|dsr
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dcd
operator|=
name|DSR
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|dcd
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dsr
operator|=
name|DSR
expr_stmt|;
block|}
name|port
operator|->
name|pnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shrinkmem
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_INFO
argument_list|,
literal|"dgb%d: shrinking memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETBUFFER
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shrinkmem
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|!=
name|PCXEVE
condition|)
block|{
name|port
operator|->
name|txptr
operator|=
operator|(
name|u_char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
argument_list|(
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
operator|(
name|u_char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
argument_list|(
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|port
operator|->
name|rxwin
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|txptr
operator|=
operator|(
name|u_char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
argument_list|(
name|mem
operator|+
operator|(
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0x1FFF
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
operator|(
name|u_char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
specifier|volatile
name|void
operator|*
argument_list|)
argument_list|(
name|mem
operator|+
operator|(
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0x1FFF
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|FEPWIN
operator||
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
name|port
operator|->
name|rxwin
operator|=
name|FEPWIN
operator||
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
block|}
name|port
operator|->
name|txbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|rxbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|txbufsize
operator|=
name|bc
operator|->
name|tmax
operator|+
literal|1
expr_stmt|;
name|port
operator|->
name|rxbufsize
operator|=
name|bc
operator|->
name|rmax
operator|+
literal|1
expr_stmt|;
name|lowwater
operator|=
operator|(
name|port
operator|->
name|txbufsize
operator|>=
literal|2000
operator|)
condition|?
literal|1024
else|:
operator|(
name|port
operator|->
name|txbufsize
operator|/
literal|2
operator|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STXLWATER
argument_list|,
name|lowwater
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXLWATER
argument_list|,
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXHWATER
argument_list|,
literal|3
operator|*
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|edelay
operator|=
literal|100
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|startc
operator|=
name|bc
operator|->
name|startc
expr_stmt|;
name|port
operator|->
name|startca
operator|=
name|bc
operator|->
name|startca
expr_stmt|;
name|port
operator|->
name|stopc
operator|=
name|bc
operator|->
name|stopc
expr_stmt|;
name|port
operator|->
name|stopca
operator|=
name|bc
operator|->
name|stopca
expr_stmt|;
comment|/*port->close_delay=50;*/
name|port
operator|->
name|close_delay
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|port
operator|->
name|do_timestamp
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|do_dcd_timestamp
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We don't use all the flags from<sys/ttydefaults.h> since they 		 * are only relevant for logins.  It's important to have echo off 		 * initially so that the line doesn't start blathering before the 		 * echo flag can be turned off. 		 */
name|port
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|port
operator|->
name|it_in
argument_list|)
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|port
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|dgbdefaultrate
expr_stmt|;
name|port
operator|->
name|it_out
operator|=
name|port
operator|->
name|it_in
expr_stmt|;
comment|/* MAX_DGB_PORTS is 32 => [0-9a-v] */
name|suffix
operator|=
name|i
operator|<
literal|10
condition|?
literal|'0'
operator|+
name|i
else|:
literal|'a'
operator|+
name|i
operator|-
literal|10
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyD%d%c"
argument_list|,
name|unit
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
operator|+
literal|32
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyiD%d%c"
argument_list|,
name|unit
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
operator|+
literal|64
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttylD%d%c"
argument_list|,
name|unit
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
operator|+
literal|128
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuaD%d%c"
argument_list|,
name|unit
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
operator|+
literal|160
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cuaiD%d%c"
argument_list|,
name|unit
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
operator|+
literal|192
argument_list|,
name|UID_UUCP
argument_list|,
name|GID_DIALER
argument_list|,
literal|0660
argument_list|,
literal|"cualD%d%c"
argument_list|,
name|unit
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* register the polling function */
name|timeout
argument_list|(
name|dgbpoll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|unit
argument_list|,
name|hz
operator|/
name|POLLSPERSEC
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dgbopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cs
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NDGB
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: try to open a nonexisting card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: try to open a disabled card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|pnum
operator|>=
name|sc
operator|->
name|numports
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: try to open non-existing port %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
literal|0
return|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|dev
operator|->
name|si_tty
operator|=
name|tp
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|open_top
label|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|port
operator|->
name|closing
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|closing
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"dgocl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: tsleep(dgocl) error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * The device is open, so everything has been initialized. 		 * Handle conflicts. 		 */
if|if
condition|(
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
block|{
if|if
condition|(
operator|!
name|port
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: BUSY error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|port
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: BUSY error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgbi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: tsleep(dgbi) error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|suser
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it.  Initialization is done twice in many 		 * cases: to preempt sleeping callin opens if we are 		 * callout, and to complete a callin open after DCD rises. 		 */
name|tp
operator|->
name|t_oproc
operator|=
name|dgbstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|dgbparam
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|dgbstop
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
condition|?
name|port
operator|->
name|it_out
else|:
name|port
operator|->
name|it_in
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|bc
operator|->
name|mstat
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
comment|/* clear input queue */
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PRINT_BUFSIZE
name|printf
argument_list|(
literal|"dgb buffers tx=%x:%x rx=%x:%x\n"
argument_list|,
name|bc
operator|->
name|tseg
argument_list|,
name|bc
operator|->
name|tmax
argument_list|,
name|bc
operator|->
name|rseg
argument_list|,
name|bc
operator|->
name|rmax
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|port
operator|->
name|wopeners
operator|++
expr_stmt|;
name|error
operator|=
name|dgbparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|port
operator|->
name|wopeners
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: dgbparam error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* handle fake DCD for callout devices */
comment|/* and initial DCD */
if|if
condition|(
operator|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dcd
operator|)
operator|||
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for DCD if necessary. 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|mynor
operator|&
name|CALLOUT_MASK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
operator|++
name|port
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgdcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|port
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: tsleep(dgdcd) error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
argument_list|(
name|dev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: l_open error=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|mynor
operator|&
name|CALLOUT_MASK
condition|)
name|port
operator|->
name|active_out
operator|=
name|TRUE
expr_stmt|;
name|port
operator|->
name|used
operator|=
literal|1
expr_stmt|;
comment|/* If any port is open (i.e. the open() call is completed for it)  	 * the device is busy 	 */
name|out
label|:
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|port
operator|->
name|wopeners
operator|==
literal|0
condition|)
name|dgbhardclose
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_OPEN
argument_list|,
literal|"dgb%d: port%d: open() returns %d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dgbclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
return|return
literal|0
return|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|port
operator|=
name|sc
operator|->
name|ports
operator|+
name|pnum
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: closing\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: draining port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgb_drain_or_flush
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: closing line disc\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
argument_list|(
name|tp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: hard closing\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgbhardclose
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: closing tty\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|port
operator|->
name|closing
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|closing
argument_list|)
expr_stmt|;
name|port
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* mark the card idle when all ports are closed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: closed\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|port
operator|->
name|active_out
operator|=
literal|0
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_CLOSE
argument_list|,
literal|"dgb%d: port%d: close exit\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgbhardclose
parameter_list|(
name|port
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|port
operator|->
name|do_timestamp
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|tty
operator|->
name|t_cflag
operator|&
name|HUPCL
condition|)
block|{
name|port
operator|->
name|omodem
operator|&=
operator|~
operator|(
name|RTS
operator||
name|DTR
operator|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
literal|0
argument_list|,
name|DTR
operator||
name|RTS
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|dgb_pause
argument_list|,
operator|&
name|port
operator|->
name|brdchan
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|brdchan
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgclo"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgb_pause
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgbpoll
parameter_list|(
name|unit_c
parameter_list|)
name|void
modifier|*
name|unit_c
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|int
operator|)
name|unit_c
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u_char
modifier|*
name|eventbuf
decl_stmt|;
name|int
name|event
decl_stmt|,
name|mstat
decl_stmt|,
name|lstat
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rhead
decl_stmt|,
name|rtail
decl_stmt|;
name|int
name|whead
decl_stmt|,
name|wtail
decl_stmt|;
name|int
name|size
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|ocount
decl_stmt|;
name|int
name|ibuf_full
decl_stmt|,
name|obuf_full
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|==
name|DISABLED
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: polling of disabled board stopped\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|ein
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|eout
expr_stmt|;
while|while
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|head
operator|>=
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|||
name|tail
operator|>=
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|||
operator|(
name|head
operator||
name|tail
operator|)
operator|&
literal|03
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: event queue's head or tail is wrong! hd=%d,tl=%d\n"
argument_list|,
name|unit
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
break|break;
block|}
name|eventbuf
operator|=
name|sc
operator|->
name|vmem
operator|+
name|tail
operator|+
name|FEP_ISTART
expr_stmt|;
name|pnum
operator|=
name|eventbuf
index|[
literal|0
index|]
expr_stmt|;
name|event
operator|=
name|eventbuf
index|[
literal|1
index|]
expr_stmt|;
name|mstat
operator|=
name|eventbuf
index|[
literal|2
index|]
expr_stmt|;
name|lstat
operator|=
name|eventbuf
index|[
literal|3
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
if|if
condition|(
name|pnum
operator|>=
name|sc
operator|->
name|numports
operator|||
name|port
operator|->
name|status
operator|==
name|DISABLED
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: port%d: got event on nonexisting port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|used
operator|||
name|port
operator|->
name|wopeners
operator|>
literal|0
condition|)
block|{
name|int
name|wrapmask
init|=
name|port
operator|->
name|rxbufsize
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|event
operator|&
name|ALL_IND
operator|)
condition|)
name|printf
argument_list|(
literal|"dgb%d: port%d: ? event 0x%x mstat 0x%x lstat 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|event
argument_list|,
name|mstat
argument_list|,
name|lstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|&
name|DATA_IND
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_DATA
argument_list|,
literal|"dgb%d: port%d: DATA_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|rhead
operator|=
name|bc
operator|->
name|rin
operator|&
name|wrapmask
expr_stmt|;
name|rtail
operator|=
name|bc
operator|->
name|rout
operator|&
name|wrapmask
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CREAD
operator|)
operator|||
operator|!
name|port
operator|->
name|used
condition|)
block|{
name|bc
operator|->
name|rout
operator|=
name|rhead
expr_stmt|;
goto|goto
name|end_of_data
goto|;
block|}
if|if
condition|(
name|bc
operator|->
name|orun
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: port%d: overrun\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|bc
operator|->
name|orun
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
goto|goto
name|end_of_data
goto|;
for|for
control|(
name|ibuf_full
operator|=
name|FALSE
init|;
name|rhead
operator|!=
name|rtail
operator|&&
operator|!
name|ibuf_full
condition|;
control|)
block|{
name|DPRINT5
argument_list|(
name|DB_RXDATA
argument_list|,
literal|"dgb%d: port%d: p rx head=%d tail=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|rhead
argument_list|,
name|rtail
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhead
operator|>
name|rtail
condition|)
name|size
operator|=
name|rhead
operator|-
name|rtail
expr_stmt|;
else|else
name|size
operator|=
name|port
operator|->
name|rxbufsize
operator|-
name|rtail
expr_stmt|;
name|ptr
operator|=
name|port
operator|->
name|rxptr
operator|+
name|rtail
expr_stmt|;
comment|/* Helg: */
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|size
operator|>
name|DGB_IBUFSIZE
condition|)
block|{
name|size
operator|=
name|DGB_IBUFSIZE
operator|-
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
expr_stmt|;
name|DPRINT1
argument_list|(
name|DB_RXDATA
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|ibuf_full
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_RXDATA
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|rxwin
argument_list|)
expr_stmt|;
name|tk_nin
operator|+=
name|size
expr_stmt|;
name|tk_rawcc
operator|+=
name|size
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|size
expr_stmt|;
name|b_to_q
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|size
decl_stmt|;
name|unsigned
name|char
name|chr
decl_stmt|;
do|do
block|{
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|rxwin
argument_list|)
expr_stmt|;
name|chr
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|chr
operator|,
name|tp
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|rtail
operator|=
operator|(
name|rtail
operator|+
name|size
operator|)
operator|&
name|wrapmask
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|rtail
expr_stmt|;
name|rhead
operator|=
name|bc
operator|->
name|rin
operator|&
name|wrapmask
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|end_of_data
label|:
empty_stmt|;
block|}
if|if
condition|(
name|event
operator|&
name|MODEMCHG_IND
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgb%d: port%d: MODEMCHG_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|mstat
expr_stmt|;
if|if
condition|(
name|mstat
operator|&
name|port
operator|->
name|dcd
condition|)
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|draining
condition|)
block|{
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|event
operator|&
name|BREAK_IND
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IGNBRK
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_BREAK
argument_list|,
literal|"dgb%d: port%d: BREAK_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
argument_list|(
name|TTY_BI
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Helg: with output flow control */
if|if
condition|(
name|event
operator|&
operator|(
name|LOWTX_IND
operator||
name|EMPTYTX_IND
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_TXDATA
argument_list|,
literal|"dgb%d: port%d: LOWTX_IND or EMPTYTX_IND\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|&
name|EMPTYTX_IND
operator|)
operator|&&
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
operator|&&
name|port
operator|->
name|draining
condition|)
block|{
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|wrapmask
init|=
name|port
operator|->
name|txbufsize
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|obuf_full
operator|=
name|FALSE
init|;
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
operator|&&
operator|!
name|obuf_full
condition|;
control|)
block|{
name|int
name|s
decl_stmt|;
comment|/* add "last-minute" data to write buffer */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
condition|)
block|{
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* selwakeup(&tp->t_wsel); */
block|}
endif|#
directive|endif
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|whead
operator|=
name|bc
operator|->
name|tin
operator|&
name|wrapmask
expr_stmt|;
name|wtail
operator|=
name|bc
operator|->
name|tout
operator|&
name|wrapmask
expr_stmt|;
if|if
condition|(
name|whead
operator|<
name|wtail
condition|)
name|size
operator|=
name|wtail
operator|-
name|whead
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|whead
expr_stmt|;
if|if
condition|(
name|wtail
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb: head=%d tail=%d size=%d full=%d\n"
argument_list|,
name|whead
argument_list|,
name|wtail
argument_list|,
name|size
argument_list|,
name|obuf_full
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|1
expr_stmt|;
name|obuf_full
operator|=
name|TRUE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|txwin
argument_list|)
expr_stmt|;
name|ocount
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|port
operator|->
name|txptr
operator|+
name|whead
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|whead
operator|+=
name|ocount
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|whead
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|whead
operator|&
name|wrapmask
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|obuf_full
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_WR
argument_list|,
literal|" +BUSY\n"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
else|else
block|{
name|DPRINT1
argument_list|(
name|DB_WR
argument_list|,
literal|" -BUSY\n"
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
comment|/* should clear TS_BUSY before ttwwakeup */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
endif|#
directive|endif
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
comment|/* require event on incoming data */
block|}
else|else
block|{
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|DPRINT4
argument_list|(
name|DB_EXCEPT
argument_list|,
literal|"dgb%d: port%d: got event 0x%x on closed port\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
name|bc
operator|->
name|iempty
operator|=
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
block|}
name|tail
operator|=
operator|(
name|tail
operator|+
literal|4
operator|)
operator|&
operator|(
name|FEP_IMAX
operator|-
name|FEP_ISTART
operator|-
literal|4
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|mailbox
operator|->
name|eout
operator|=
name|tail
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|dgbpoll
argument_list|,
name|unit_c
argument_list|,
name|hz
operator|/
name|POLLSPERSEC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgbioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|td
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cs
decl_stmt|;
name|int
name|tiocm_xxx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|u_long
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|mynor
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
if|if
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|mynor
operator|&
name|CONTROL_MASK
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|it_out
else|:
operator|&
name|port
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|lt_out
else|:
operator|&
name|port
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: dgbioctl-ISNOW c=0x%x i=0x%x l=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|term
operator|.
name|c_cflag
argument_list|,
name|term
operator|.
name|c_iflag
argument_list|,
name|term
operator|.
name|c_lflag
argument_list|)
expr_stmt|;
block|}
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|mynor
operator|&
name|CALLOUT_MASK
condition|?
operator|&
name|port
operator|->
name|lt_out
else|:
operator|&
name|port
operator|->
name|lt_in
decl_stmt|;
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: dgbioctl-TOSET c=0x%x i=0x%x l=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|dt
operator|->
name|c_cflag
argument_list|,
name|dt
operator|->
name|c_iflag
argument_list|,
name|dt
operator|->
name|c_lflag
argument_list|)
expr_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSTOP
condition|)
block|{
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|PAUSETX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|TIOCSTART
condition|)
block|{
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|RESUMETX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
name|port
operator|->
name|mustdrain
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
name|error
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|port
operator|->
name|mustdrain
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: dgbioctl-RES c=0x%x i=0x%x l=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|tp
operator|->
name|t_cflag
argument_list|,
name|tp
operator|->
name|t_iflag
argument_list|,
name|tp
operator|->
name|t_lflag
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
comment|/* Helg: commented */
comment|/*		error=dgbdrain(port);*/
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* now it sends 250 millisecond break because I don't know */
comment|/* how to send an infinite break */
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SENDBREAK
argument_list|,
literal|250
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
comment|/* now it's empty */
break|break;
case|case
name|TIOCSDTR
case|:
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgb%d: port%d: set DTR\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bc
operator|->
name|mstat
operator|&
name|DTR
operator|)
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgb%d: port%d: DTR is off\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgb%d: port%d: reset DTR\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|mstat
operator|&
name|DTR
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgb%d: port%d: DTR is on\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
else|else
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator||=
name|RTS
expr_stmt|;
else|else
name|port
operator|->
name|omodem
operator|&=
operator|~
name|RTS
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator||=
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator||=
name|RTS
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|port
operator|->
name|omodem
operator|&=
operator|~
name|DTR
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|port
operator|->
name|omodem
operator|&=
operator|~
name|RTS
expr_stmt|;
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
name|port
operator|->
name|omodem
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|imodem
operator|=
name|bc
operator|->
name|mstat
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* XXX - always enabled while open */
name|DPRINT3
argument_list|(
name|DB_MODEM
argument_list|,
literal|"dgb%d: port%d: modem stat -- "
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|DTR
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"DTR "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_DTR
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|RTS
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"RTS "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_RTS
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|CTS
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"CTS "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_CTS
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dcd
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"DCD "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_CD
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|port
operator|->
name|dsr
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"DSR "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_DSR
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|imodem
operator|&
name|RI
condition|)
block|{
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"RI "
argument_list|)
expr_stmt|;
name|tiocm_xxx
operator||=
name|TIOCM_RI
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tiocm_xxx
expr_stmt|;
name|DPRINT1
argument_list|(
name|DB_MODEM
argument_list|,
literal|"--\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
comment|/* must be root since the wait applies to following logins */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|port
operator|->
name|close_delay
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|port
operator|->
name|close_delay
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|TIOCTIMESTAMP
case|:
name|port
operator|->
name|do_timestamp
operator|=
name|TRUE
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|port
operator|->
name|timestamp
expr_stmt|;
break|break;
case|case
name|TIOCDCDTIMESTAMP
case|:
name|port
operator|->
name|do_dcd_timestamp
operator|=
name|TRUE
expr_stmt|;
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|=
name|port
operator|->
name|dcd_timestamp
expr_stmt|;
break|break;
default|default:
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wakeflush
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|dgb_p
modifier|*
name|port
init|=
name|p
decl_stmt|;
name|wakeup
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* wait for the output to drain */
end_comment

begin_function
specifier|static
name|int
name|dgbdrain
parameter_list|(
name|port
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|head
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: drain: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|wakeflush
argument_list|,
name|port
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgdrn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: tsleep(dgdrn) error=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
block|}
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: drain: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* wait for the output to drain */
end_comment

begin_comment
comment|/* or simply clear the buffer it it's stopped */
end_comment

begin_function
specifier|static
name|void
name|dgb_drain_or_flush
parameter_list|(
name|port
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|port
operator|->
name|tty
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|lasttail
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lasttail
operator|=
operator|-
literal|1
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|head
comment|/*&& tail!=lasttail */
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: flush: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
comment|/* if there is no carrier simply clean the buffer */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|wakeflush
argument_list|,
name|port
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|port
operator|->
name|draining
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"dgfls"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|->
name|draining
operator|=
literal|0
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: tsleep(dgfls) error=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* silently clean the buffer */
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|lasttail
operator|=
name|tail
expr_stmt|;
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: flush: head=%d tail=%d\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgbparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|unit
init|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pnum
init|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
init|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
init|=
name|port
operator|->
name|brdchan
decl_stmt|;
name|int
name|cflag
decl_stmt|;
name|int
name|head
decl_stmt|;
name|int
name|mval
decl_stmt|;
name|int
name|iflag
decl_stmt|;
name|int
name|hflow
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|DPRINT6
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: dgbparm c=0x%x i=0x%x l=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|,
name|t
operator|->
name|c_lflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|mustdrain
condition|)
block|{
name|DPRINT3
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: must call dgbdrain()\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|dgbdrain
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|cflag
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|dgbspeedtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
if|if
condition|(
name|cflag
operator|<
literal|0
comment|/* || cflag> 0&& t->c_ispeed != t->c_ospeed */
condition|)
block|{
name|DPRINT4
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: invalid cflag=0%o\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|cflag
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|==
literal|0
condition|)
block|{
comment|/* hangup */
name|DPRINT3
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: hangup\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|)
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|rout
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STOUT
argument_list|,
operator|(
name|unsigned
operator|)
name|head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mval
operator|=
name|port
operator|->
name|omodem
operator|&
operator|~
operator|(
name|DTR
operator||
name|RTS
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cflag
operator||=
name|dgbflags
argument_list|(
name|dgb_cflags
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|!=
name|port
operator|->
name|fepcflag
condition|)
block|{
name|port
operator|->
name|fepcflag
operator|=
name|cflag
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: set cflag=0x%x c=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|cflag
argument_list|,
name|t
operator|->
name|c_cflag
operator|&
operator|~
name|CRTSCTS
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETCTRLFLAGS
argument_list|,
operator|(
name|unsigned
operator|)
name|cflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mval
operator|=
name|port
operator|->
name|omodem
operator||
operator|(
name|DTR
operator||
name|RTS
operator|)
expr_stmt|;
block|}
name|iflag
operator|=
name|dgbflags
argument_list|(
name|dgb_iflags
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
operator|!=
name|port
operator|->
name|fepiflag
condition|)
block|{
name|port
operator|->
name|fepiflag
operator|=
name|iflag
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: set iflag=0x%x c=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|iflag
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETIFLAGS
argument_list|,
operator|(
name|unsigned
operator|)
name|iflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bc
operator|->
name|mint
operator|=
name|port
operator|->
name|dcd
expr_stmt|;
name|hflow
operator|=
name|dgbflags
argument_list|(
name|dgb_flow
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hflow
operator|!=
name|port
operator|->
name|hflow
condition|)
block|{
name|port
operator|->
name|hflow
operator|=
name|hflow
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: set hflow=0x%x f=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|hflow
argument_list|,
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETHFLOW
argument_list|,
operator|(
name|unsigned
operator|)
name|hflow
argument_list|,
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|omodem
operator|!=
name|mval
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: setting modem parameters 0x%x was 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|mval
argument_list|,
name|port
operator|->
name|omodem
argument_list|)
expr_stmt|;
name|port
operator|->
name|omodem
operator|=
name|mval
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETMODEM
argument_list|,
operator|(
name|unsigned
operator|)
name|mval
argument_list|,
name|RTS
operator||
name|DTR
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
operator|->
name|fepstartc
operator|!=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|||
name|port
operator|->
name|fepstopc
operator|!=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
name|DB_PARAM
argument_list|,
literal|"dgb%d: port%d: set startc=%d, stopc=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|port
operator|->
name|fepstartc
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|port
operator|->
name|fepstopc
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SONOFFC
argument_list|,
name|port
operator|->
name|fepstartc
argument_list|,
name|port
operator|->
name|fepstopc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dgbstart
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|size
decl_stmt|,
name|ocount
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|wmask
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|wmask
operator|=
name|port
operator|->
name|txbufsize
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|int
name|cs
decl_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*selwakeup(&tp->t_wsel);*/
block|}
endif|#
directive|endif
name|cs
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|=
name|bc
operator|->
name|tin
operator|&
name|wmask
expr_stmt|;
do|do
block|{
name|tail
operator|=
name|bc
operator|->
name|tout
expr_stmt|;
block|}
do|while
condition|(
name|tail
operator|!=
name|bc
operator|->
name|tout
condition|)
do|;
name|tail
operator|=
name|bc
operator|->
name|tout
operator|&
name|wmask
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: s tx head=%d tail=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|head
argument_list|,
name|tail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAVE_FREE_CHARS
if|if
condition|(
name|tail
operator|>
name|head
condition|)
block|{
name|size
operator|=
name|tail
operator|-
name|head
operator|-
name|LEAVE_FREE_CHARS
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|size
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|head
expr_stmt|;
if|if
condition|(
name|tail
operator|+
name|port
operator|->
name|txbufsize
operator|<
name|head
condition|)
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
if|if
condition|(
name|tail
operator|>
name|head
condition|)
name|size
operator|=
name|tail
operator|-
name|head
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|size
operator|=
name|port
operator|->
name|txbufsize
operator|-
name|head
comment|/*-1*/
expr_stmt|;
if|if
condition|(
name|tail
operator|==
literal|0
condition|)
name|size
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|bc
operator|->
name|iempty
operator|=
literal|1
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|towin
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|txwin
argument_list|)
expr_stmt|;
name|ocount
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|port
operator|->
name|txptr
operator|+
name|head
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|head
operator|+=
name|ocount
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|port
operator|->
name|txbufsize
condition|)
name|head
operator|-=
name|port
operator|->
name|txbufsize
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|tin
operator|=
name|head
expr_stmt|;
name|DPRINT5
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: tx avail=%d count=%d\n"
argument_list|,
name|unit
argument_list|,
name|pnum
argument_list|,
name|size
argument_list|,
name|ocount
argument_list|)
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dgbstop
parameter_list|(
name|tp
parameter_list|,
name|rw
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|int
name|pnum
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
specifier|volatile
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|BoardMemWinState
name|ws
init|=
name|bmws_get
argument_list|()
decl_stmt|;
name|unit
operator|=
name|MINOR_TO_UNIT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|pnum
operator|=
name|MINOR_TO_PORT
argument_list|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|dgb_softc
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|pnum
index|]
expr_stmt|;
name|bc
operator|=
name|port
operator|->
name|brdchan
expr_stmt|;
name|DPRINT3
argument_list|(
name|DB_WR
argument_list|,
literal|"dgb%d: port%d: stop\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
comment|/* clear output queue */
name|bc
operator|->
name|tout
operator|=
name|bc
operator|->
name|tin
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|ilow
operator|=
literal|0
expr_stmt|;
name|bc
operator|->
name|iempty
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
comment|/* clear input queue */
name|bc
operator|->
name|rout
operator|=
name|bc
operator|->
name|rin
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
block|}
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bmws_set
argument_list|(
name|ws
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dgbstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fepcmd
parameter_list|(
name|port
parameter_list|,
name|cmd
parameter_list|,
name|op1
parameter_list|,
name|op2
parameter_list|,
name|ncmds
parameter_list|,
name|bytecmd
parameter_list|)
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|unsigned
name|cmd
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|,
name|ncmds
decl_stmt|,
name|bytecmd
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|port
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|mem
init|=
name|sc
operator|->
name|vmem
decl_stmt|;
name|unsigned
name|tail
decl_stmt|,
name|head
decl_stmt|;
name|int
name|count
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|status
operator|==
name|DISABLED
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: port%d: FEP command on disabled port\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* setwin(sc,0); Require this to be set by caller */
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|cin
expr_stmt|;
if|if
condition|(
name|head
operator|>=
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|)
operator|||
operator|(
name|head
operator|&
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: port%d: wrong pointer head of command queue : 0x%x\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|1
index|]
operator|=
name|port
operator|->
name|pnum
expr_stmt|;
if|if
condition|(
name|bytecmd
condition|)
block|{
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
operator|=
name|op1
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
operator|=
name|op2
expr_stmt|;
block|}
else|else
block|{
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
operator|=
name|op1
operator|&
literal|0xff
expr_stmt|;
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
operator|=
operator|(
name|op1
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|DPRINT7
argument_list|(
name|DB_FEP
argument_list|,
literal|"dgb%d: port%d: %s cmd=0x%x op1=0x%x op2=0x%x\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
operator|(
name|bytecmd
operator|)
condition|?
literal|"byte"
else|:
literal|"word"
argument_list|,
name|cmd
argument_list|,
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|2
index|]
argument_list|,
name|mem
index|[
name|head
operator|+
name|FEP_CSTART
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|4
operator|)
operator|&
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|-
literal|4
operator|)
expr_stmt|;
name|sc
operator|->
name|mailbox
operator|->
name|cin
operator|=
name|head
expr_stmt|;
name|count
operator|=
name|FEPTIMEOUT
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|!=
literal|0
condition|)
block|{
name|head
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|cin
expr_stmt|;
name|tail
operator|=
name|sc
operator|->
name|mailbox
operator|->
name|cout
expr_stmt|;
name|n
operator|=
operator|(
name|head
operator|-
name|tail
operator|)
operator|&
operator|(
name|FEP_CMAX
operator|-
name|FEP_CSTART
operator|-
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
name|ncmds
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|ushort
argument_list|)
operator|*
literal|4
operator|)
condition|)
return|return;
block|}
name|printf
argument_list|(
literal|"dgb%d(%d): timeout on FEP cmd=0x%x\n"
argument_list|,
name|port
operator|->
name|unit
argument_list|,
name|port
operator|->
name|pnum
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disc_optim
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
block|}
end_function

end_unit

