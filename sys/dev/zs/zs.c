begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Gordon W. Ross  * Copyright (c) 1992, 1993  *      The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      @(#)zs.c        8.1 (Berkeley) 7/19/93  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003 Jake Burkholder.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Zilog Z8530 Dual UART driver.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_comconsole.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<dev/zs/z8530reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/zs/z8530var.h>
end_include

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|182
end_define

begin_define
define|#
directive|define
name|ZS_READ
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
define|\
value|bus_space_read_1((sc)->sc_bt, (r), 0)
end_define

begin_define
define|#
directive|define
name|ZS_WRITE
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_space_write_1((sc)->sc_bt, (r), 0, (v))
end_define

begin_define
define|#
directive|define
name|ZS_READ_REG
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|)
value|({ \ 	ZS_WRITE((sc), (sc)->sc_csr, (r)); \ 	ZS_READ((sc), (sc)->sc_csr); \ })
end_define

begin_define
define|#
directive|define
name|ZS_WRITE_REG
parameter_list|(
name|sc
parameter_list|,
name|r
parameter_list|,
name|v
parameter_list|)
value|({ \ 	ZS_WRITE((sc), (sc)->sc_csr, (r)); \ 	ZS_WRITE((sc), (sc)->sc_csr, (v)); \ })
end_define

begin_define
define|#
directive|define
name|ZSTTY_LOCK
parameter_list|(
name|sz
parameter_list|)
value|mtx_lock_spin(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|ZSTTY_UNLOCK
parameter_list|(
name|sz
parameter_list|)
value|mtx_unlock_spin(&(sc)->sc_mtx)
end_define

begin_function_decl
specifier|static
name|void
name|zs_softintr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zs_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zstty_intr
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rr3
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|zstty_softintr
argument_list|(
expr|struct
name|zstty_softc
operator|*
name|sc
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zstty_mdmctrl
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zstty_param
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|zstty_flush
argument_list|(
expr|struct
name|zstty_softc
operator|*
name|sc
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zstty_speed
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zstty_load_regs
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|cn_probe_t
name|zs_cnprobe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_init_t
name|zs_cninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_term_t
name|zs_cnterm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_getc_t
name|zs_cngetc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_checkc_t
name|zs_cncheckc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_putc_t
name|zs_cnputc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_dbctl_t
name|zs_cndbctl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zstty_cngetc
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zstty_cncheckc
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zstty_cnputc
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|zsttyopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|zsttyclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|zsttyioctl
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|zsttystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zsttystop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zsttyparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|zstty_cdevsw
init|=
block|{
comment|/* open */
name|zsttyopen
block|,
comment|/* close */
name|zsttyclose
block|,
comment|/* read */
name|ttyread
block|,
comment|/* write */
name|ttywrite
block|,
comment|/* ioctl */
name|zsttyioctl
block|,
comment|/* poll */
name|ttypoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"zstty"
block|,
comment|/* major */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_TTY
operator||
name|D_KQFILTER
block|,
comment|/* kqfilter */
name|ttykqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|zstty_softc
modifier|*
name|zstty_cons
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CONS_DRIVER
argument_list|(
name|zs
argument_list|,
name|zs_cnprobe
argument_list|,
name|zs_cninit
argument_list|,
name|zs_cnterm
argument_list|,
name|zs_cngetc
argument_list|,
name|zs_cncheckc
argument_list|,
name|zs_cnputc
argument_list|,
name|zs_cndbctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|zs_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Zilog Z8530"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zs_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|device
modifier|*
name|child
index|[
name|ZS_NCHAN
index|]
decl_stmt|;
name|struct
name|zs_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZS_NCHAN
condition|;
name|i
operator|++
control|)
name|child
index|[
name|i
index|]
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"zstty"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZS_NCHAN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_child
index|[
name|i
index|]
operator|=
name|device_get_softc
argument_list|(
name|child
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|swi_add
argument_list|(
operator|&
name|tty_ithd
argument_list|,
literal|"tty:zs"
argument_list|,
name|zs_softintr
argument_list|,
name|sc
argument_list|,
name|SWI_TTY
argument_list|,
name|INTR_TYPE_TTY
argument_list|,
operator|&
name|sc
operator|->
name|sc_softih
argument_list|)
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
operator|->
name|sc_creg
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
argument_list|,
literal|9
argument_list|,
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
operator|->
name|sc_creg
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zstty_cons
operator|!=
name|NULL
condition|)
block|{
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
name|cninit
argument_list|()
expr_stmt|;
block|}
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|zs_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zs_intr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|zs_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|int
name|needsoft
decl_stmt|;
name|uint8_t
name|rr3
decl_stmt|;
comment|/* 	 * There is only one status register, which is on channel a.  In order 	 * to avoid needing to know which channel we're on in the tty interrupt 	 * handler we shift the channel a status bits into the channel b 	 * bit positions and always test the channel b bits. 	 */
name|needsoft
operator|=
literal|0
expr_stmt|;
name|rr3
operator|=
name|ZS_READ_REG
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rr3
operator|&
operator|(
name|ZSRR3_IP_A_RX
operator||
name|ZSRR3_IP_A_TX
operator||
name|ZSRR3_IP_A_STAT
operator|)
operator|)
operator|!=
literal|0
condition|)
name|needsoft
operator||=
name|zstty_intr
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
argument_list|,
name|rr3
operator|>>
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rr3
operator|&
operator|(
name|ZSRR3_IP_B_RX
operator||
name|ZSRR3_IP_B_TX
operator||
name|ZSRR3_IP_B_STAT
operator|)
operator|)
operator|!=
literal|0
condition|)
name|needsoft
operator||=
name|zstty_intr
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|1
index|]
argument_list|,
name|rr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsoft
condition|)
name|swi_sched
argument_list|(
name|sc
operator|->
name|sc_softih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zs_softintr
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|zs_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|zstty_softintr
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|zstty_softintr
argument_list|(
name|sc
operator|->
name|sc_child
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zs_shutdown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|zstty_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zstty_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|char
name|mode
index|[
literal|32
index|]
decl_stmt|;
name|int
name|reset
decl_stmt|;
name|int
name|baud
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|char
name|parity
decl_stmt|;
name|int
name|stop
decl_stmt|;
name|char
name|c
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"zstty"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_iput
operator|=
name|sc
operator|->
name|sc_iget
operator|=
name|sc
operator|->
name|sc_ibuf
expr_stmt|;
name|sc
operator|->
name|sc_oget
operator|=
name|sc
operator|->
name|sc_obuf
expr_stmt|;
name|tp
operator|=
name|ttymalloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_si
operator|=
name|make_dev
argument_list|(
operator|&
name|zstty_cdevsw
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"%s"
argument_list|,
name|device_get_desc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_si
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_si
operator|->
name|si_tty
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|sc
operator|->
name|sc_si
expr_stmt|;
name|sc
operator|->
name|sc_tty
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|zsttystart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|zsttyparam
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|zsttystop
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CREAD
operator||
name|CLOCAL
operator||
name|CS8
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
if|if
condition|(
name|zstty_console
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* format: 9600,8,n,1,- */
if|if
condition|(
name|sscanf
argument_list|(
name|mode
argument_list|,
literal|"%d,%d,%c,%d,%c"
argument_list|,
operator|&
name|baud
argument_list|,
operator|&
name|clen
argument_list|,
operator|&
name|parity
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|c
argument_list|)
operator|==
literal|5
condition|)
block|{
name|tp
operator|->
name|t_ospeed
operator|=
name|baud
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|baud
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CREAD
operator||
name|CLOCAL
expr_stmt|;
switch|switch
condition|(
name|clen
condition|)
block|{
case|case
literal|5
case|:
name|tp
operator|->
name|t_cflag
operator||=
name|CS5
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|tp
operator|->
name|t_cflag
operator||=
name|CS6
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|tp
operator|->
name|t_cflag
operator||=
name|CS7
expr_stmt|;
break|break;
case|case
literal|8
case|:
default|default:
name|tp
operator|->
name|t_cflag
operator||=
name|CS8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|parity
operator|==
literal|'e'
condition|)
name|tp
operator|->
name|t_cflag
operator||=
name|PARENB
expr_stmt|;
elseif|else
if|if
condition|(
name|parity
operator|==
literal|'o'
condition|)
name|tp
operator|->
name|t_cflag
operator||=
name|PARENB
operator||
name|PARODD
expr_stmt|;
if|if
condition|(
name|stop
operator|==
literal|2
condition|)
name|tp
operator|->
name|t_cflag
operator||=
name|CSTOPB
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"console %s\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_console
operator|=
literal|1
expr_stmt|;
name|zstty_cons
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|reset
operator|=
name|ZSWR9_A_RESET
expr_stmt|;
else|else
name|reset
operator|=
name|ZSWR9_B_RESET
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|9
argument_list|,
name|reset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that the rr3 value is shifted so the channel a status bits are in the  * channel b bit positions, which makes the bit positions uniform for both  * channels.  */
end_comment

begin_function
specifier|static
name|int
name|zstty_intr
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|rr3
parameter_list|)
block|{
name|int
name|needsoft
decl_stmt|;
name|uint8_t
name|rr0
decl_stmt|;
name|uint8_t
name|rr1
decl_stmt|;
name|uint8_t
name|c
decl_stmt|;
name|int
name|brk
decl_stmt|;
name|ZSTTY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|,
name|ZSWR0_CLR_INTR
argument_list|)
expr_stmt|;
name|brk
operator|=
literal|0
expr_stmt|;
name|needsoft
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rr3
operator|&
name|ZSRR3_IP_B_RX
operator|)
operator|!=
literal|0
condition|)
block|{
name|needsoft
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* 			 * First read the status, because reading the received 			 * char destroys the status of this char. 			 */
name|rr1
operator|=
name|ZS_READ_REG
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rr1
operator|&
operator|(
name|ZSRR1_FE
operator||
name|ZSRR1_DO
operator||
name|ZSRR1_PE
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|,
name|ZSWR0_RESET_ERRORS
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|&&
name|defined
argument_list|(
name|ALT_BREAK_TO_DEBUGGER
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_console
operator|!=
literal|0
condition|)
name|brk
operator|=
name|db_alt_break
argument_list|(
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_alt_break_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|sc
operator|->
name|sc_iput
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_iput
operator|++
operator|=
name|rr1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_iput
operator|==
name|sc
operator|->
name|sc_ibuf
operator|+
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
condition|)
name|sc
operator|->
name|sc_iput
operator|=
name|sc
operator|->
name|sc_ibuf
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
operator|&
name|ZSRR0_RX_READY
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
if|if
condition|(
operator|(
name|rr3
operator|&
name|ZSRR3_IP_B_STAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|rr0
operator|=
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|,
name|ZSWR0_RESET_STATUS
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DDB
argument_list|)
operator|&&
name|defined
argument_list|(
name|BREAK_TO_DEBUGGER
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_console
operator|!=
literal|0
operator|&&
operator|(
name|rr0
operator|&
name|ZSRR0_BREAK
operator|)
operator|!=
literal|0
condition|)
name|brk
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* XXX do something about flow control */
block|}
if|if
condition|(
operator|(
name|rr3
operator|&
name|ZSRR3_IP_B_TX
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we've delayed a paramter change, do it now. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_preg_held
condition|)
block|{
name|sc
operator|->
name|sc_preg_held
operator|=
literal|0
expr_stmt|;
name|zstty_load_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ocnt
operator|>
literal|0
condition|)
block|{
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|,
operator|*
name|sc
operator|->
name|sc_oget
operator|++
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ocnt
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Disable transmit completion interrupts if 			 * necessary. 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
operator|&
name|ZSWR1_TIE
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
operator|&=
operator|~
name|ZSWR1_TIE
expr_stmt|;
name|sc
operator|->
name|sc_creg
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_tx_done
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_tx_busy
operator|=
literal|0
expr_stmt|;
name|needsoft
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ZSTTY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|brk
operator|!=
literal|0
condition|)
name|breakpoint
argument_list|()
expr_stmt|;
return|return
operator|(
name|needsoft
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zstty_softintr
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|sc
operator|->
name|sc_tty
decl_stmt|;
name|int
name|data
decl_stmt|;
name|int
name|stat
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
return|return;
while|while
condition|(
name|sc
operator|->
name|sc_iget
operator|!=
name|sc
operator|->
name|sc_iput
condition|)
block|{
name|data
operator|=
operator|*
name|sc
operator|->
name|sc_iget
operator|++
expr_stmt|;
name|stat
operator|=
operator|*
name|sc
operator|->
name|sc_iget
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|ZSRR1_PE
operator|)
operator|!=
literal|0
condition|)
name|data
operator||=
name|TTY_PE
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|ZSRR1_FE
operator|)
operator|!=
literal|0
condition|)
name|data
operator||=
name|TTY_FE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_iget
operator|==
name|sc
operator|->
name|sc_ibuf
operator|+
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ibuf
argument_list|)
condition|)
name|sc
operator|->
name|sc_iget
operator|=
name|sc
operator|->
name|sc_ibuf
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|data
operator|,
name|tp
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_tx_done
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_tx_done
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zsttyopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|tp
operator|=
name|dev
operator|->
name|si_tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|suser
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|termios
name|t
decl_stmt|;
comment|/* 		 * Enable receive and status interrupts in zstty_param. 		 */
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
operator||=
name|ZSWR1_RIE
operator||
name|ZSWR1_SIE
expr_stmt|;
name|sc
operator|->
name|sc_iput
operator|=
name|sc
operator|->
name|sc_iget
operator|=
name|sc
operator|->
name|sc_ibuf
expr_stmt|;
comment|/* 		 * Initialize the termios status to the defaults.  Add in the 		 * sticky bits from TIOCSFLAGS. 		 */
name|t
operator|.
name|c_ispeed
operator|=
literal|0
expr_stmt|;
name|t
operator|.
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|t
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
comment|/* Make sure zstty_param() will do something. */
name|tp
operator|->
name|t_ospeed
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|zstty_param
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* XXX turn on DTR */
comment|/* XXX handle initial DCD */
block|}
name|error
operator|=
name|ttyopen
argument_list|(
name|dev
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zsttyclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|dev
operator|->
name|si_tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flags
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zsttyioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|tp
operator|=
name|dev
operator|->
name|si_tty
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flags
operator|,
name|td
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|ZS_READ_REG
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
operator||
name|ZSWR5_BREAK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|ZS_READ_REG
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|)
operator|&
operator|~
name|ZSWR5_BREAK
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
name|TIOCM_DTR
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|,
name|DMBIS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|,
name|DMBIC
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|DMGET
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|,
name|DMSET
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zsttystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
name|c
decl_stmt|;
name|sc
operator|=
name|tp
operator|->
name|t_dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|!=
literal|0
condition|)
comment|/* XXX clear RTS */
empty_stmt|;
else|else
comment|/* XXX set RTS */
empty_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_BUSY
operator||
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_olowat
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_SO_OLOWAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_SO_OLOWAT
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_BUSY
operator||
name|TS_SO_OCOMPLETE
operator|)
operator|)
operator|==
name|TS_SO_OCOMPLETE
operator|&&
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_SO_OCOMPLETE
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OCOMPLETE
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
name|sc
operator|->
name|sc_ocnt
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|sc
operator|->
name|sc_obuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_obuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ocnt
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|sc
operator|->
name|sc_obuf
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sc_oget
operator|=
name|sc
operator|->
name|sc_obuf
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_ocnt
operator|--
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|sc
operator|->
name|sc_tx_busy
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Enable transmit interrupts if necessary and send the first 	 * character to start up the transmitter. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
operator|&
name|ZSWR1_TIE
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
operator||=
name|ZSWR1_TIE
expr_stmt|;
name|sc
operator|->
name|sc_creg
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_preg
index|[
literal|1
index|]
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zsttystop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|tp
operator|->
name|t_dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FREAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX stop reading, anything to do? */
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX do what? */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_FLUSH
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zsttyparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|tp
operator|->
name|t_dev
operator|->
name|si_drv1
expr_stmt|;
return|return
operator|(
name|zstty_param
argument_list|(
name|sc
argument_list|,
name|tp
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zstty_mdmctrl
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|int
name|bits
parameter_list|,
name|int
name|how
parameter_list|)
block|{
comment|/* XXX implement! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zstty_param
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|tcflag_t
name|cflag
decl_stmt|;
name|uint8_t
name|wr3
decl_stmt|;
name|uint8_t
name|wr4
decl_stmt|;
name|uint8_t
name|wr5
decl_stmt|;
name|int
name|ospeed
decl_stmt|;
name|ospeed
operator|=
name|zstty_speed
argument_list|(
name|sc
argument_list|,
name|t
operator|->
name|c_ospeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
operator|(
name|t
operator|->
name|c_ispeed
operator|&&
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If there were no changes, don't do anything.  This avoids dropping 	 * input and improves performance when all we did was frob things like 	 * VMIN and VTIME. 	 */
if|if
condition|(
name|tp
operator|->
name|t_ospeed
operator|==
name|t
operator|->
name|c_ospeed
operator|&&
name|tp
operator|->
name|t_cflag
operator|==
name|t
operator|->
name|c_cflag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zstty_mdmctrl
argument_list|(
name|sc
argument_list|,
name|TIOCM_DTR
argument_list|,
operator|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
operator|)
condition|?
name|DMBIC
else|:
name|DMBIS
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_console
operator|!=
literal|0
condition|)
block|{
name|cflag
operator||=
name|CLOCAL
expr_stmt|;
name|cflag
operator|&=
operator|~
name|HUPCL
expr_stmt|;
block|}
name|wr3
operator|=
name|ZSWR3_RX_ENABLE
expr_stmt|;
name|wr5
operator|=
name|ZSWR5_TX_ENABLE
operator||
name|ZSWR5_DTR
operator||
name|ZSWR5_RTS
expr_stmt|;
switch|switch
condition|(
name|cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|wr3
operator||=
name|ZSWR3_RX_5
expr_stmt|;
name|wr5
operator||=
name|ZSWR5_TX_5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|wr3
operator||=
name|ZSWR3_RX_6
expr_stmt|;
name|wr5
operator||=
name|ZSWR5_TX_6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|wr3
operator||=
name|ZSWR3_RX_7
expr_stmt|;
name|wr5
operator||=
name|ZSWR5_TX_7
expr_stmt|;
break|break;
case|case
name|CS8
case|:
default|default:
name|wr3
operator||=
name|ZSWR3_RX_8
expr_stmt|;
name|wr5
operator||=
name|ZSWR5_TX_8
expr_stmt|;
break|break;
block|}
name|wr4
operator|=
name|ZSWR4_CLK_X16
operator||
operator|(
name|cflag
operator|&
name|CSTOPB
condition|?
name|ZSWR4_TWOSB
else|:
name|ZSWR4_ONESB
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|PARODD
operator|)
operator|==
literal|0
condition|)
name|wr4
operator||=
name|ZSWR4_EVENP
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
name|wr4
operator||=
name|ZSWR4_PARENB
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ZSTTY_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_preg
index|[
literal|3
index|]
operator|=
name|wr3
expr_stmt|;
name|sc
operator|->
name|sc_preg
index|[
literal|4
index|]
operator|=
name|wr4
expr_stmt|;
name|sc
operator|->
name|sc_preg
index|[
literal|5
index|]
operator|=
name|wr5
expr_stmt|;
name|zstty_set_speed
argument_list|(
name|sc
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CRTSCTS
condition|)
name|sc
operator|->
name|sc_preg
index|[
literal|15
index|]
operator||=
name|ZSWR15_CTS_IE
expr_stmt|;
else|else
name|sc
operator|->
name|sc_preg
index|[
literal|15
index|]
operator|&=
operator|~
name|ZSWR15_CTS_IE
expr_stmt|;
name|zstty_load_regs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ZSTTY_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zstty_flush
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|rr0
decl_stmt|;
name|uint8_t
name|rr1
decl_stmt|;
name|uint8_t
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rr0
operator|=
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rr0
operator|&
name|ZSRR0_RX_READY
operator|)
operator|==
literal|0
condition|)
break|break;
name|rr1
operator|=
name|ZS_READ_REG
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|rr1
operator|&
operator|(
name|ZSRR1_FE
operator||
name|ZSRR1_DO
operator||
name|ZSRR1_PE
operator|)
condition|)
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|,
name|ZSWR0_RESET_ERRORS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zstty_load_regs
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * If the transmitter may be active, just hold the change and do it 	 * in the tx interrupt handler.  Changing the registers while tx is 	 * active may hang the chip. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_tx_busy
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_preg_held
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* If the regs are the same do nothing. */
if|if
condition|(
name|bcmp
argument_list|(
name|sc
operator|->
name|sc_preg
argument_list|,
name|sc
operator|->
name|sc_creg
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_preg
argument_list|,
name|sc
operator|->
name|sc_creg
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* XXX: reset error condition */
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|,
name|ZSM_RESET_ERR
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|1
index|]
operator|&
operator|~
name|ZSWR1_IMASK
argument_list|)
expr_stmt|;
comment|/* baud clock divisor, stop bits, parity */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* misc. TX/RX control bits */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
comment|/* char size, enable (RX/TX) */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|3
index|]
operator|&
operator|~
name|ZSWR3_RX_ENABLE
argument_list|)
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|5
index|]
operator|&
operator|~
name|ZSWR5_TX_ENABLE
argument_list|)
expr_stmt|;
comment|/* Shut down the BRG */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|14
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|14
index|]
operator|&
operator|~
name|ZSWR14_BAUD_ENA
argument_list|)
expr_stmt|;
comment|/* clock mode control */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|11
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|11
index|]
argument_list|)
expr_stmt|;
comment|/* baud rate (lo/hi) */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|12
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|13
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|13
index|]
argument_list|)
expr_stmt|;
comment|/* Misc. control bits */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|14
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|14
index|]
argument_list|)
expr_stmt|;
comment|/* which lines cause status interrupts */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|15
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Zilog docs recommend resetting external status twice at this 	 * point. Mainly as the status bits are latched, and the first 	 * interrupt clear might unlatch them to new values, generating 	 * a second interrupt request. 	 */
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|,
name|ZSM_RESET_STINT
argument_list|)
expr_stmt|;
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|,
name|ZSM_RESET_STINT
argument_list|)
expr_stmt|;
comment|/* char size, enable (RX/TX)*/
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|3
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|5
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* interrupt enables: RX, TX, STATUS */
name|ZS_WRITE_REG
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|sc_creg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zstty_speed
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|tconst
decl_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tconst
operator|=
name|BPS_TO_TCONST
argument_list|(
name|sc
operator|->
name|sc_brg_clk
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|tconst
operator|<
literal|0
operator|||
name|TCONST_TO_BPS
argument_list|(
name|sc
operator|->
name|sc_brg_clk
argument_list|,
name|tconst
argument_list|)
operator|!=
name|rate
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|tconst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zs_cnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cn
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
init|=
name|zstty_cons
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
name|cn
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
else|else
block|{
name|cn
operator|->
name|cn_pri
operator|=
name|CN_REMOTE
expr_stmt|;
name|cn
operator|->
name|cn_dev
operator|=
name|sc
operator|->
name|sc_si
expr_stmt|;
name|cn
operator|->
name|cn_tp
operator|=
name|sc
operator|->
name|sc_tty
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zs_cninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cn
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|zs_cnterm
parameter_list|(
name|struct
name|consdev
modifier|*
name|cn
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|zs_cngetc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
init|=
name|zstty_cons
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|zstty_cngetc
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zs_cncheckc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
init|=
name|zstty_cons
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|zstty_cncheckc
argument_list|(
name|sc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zs_cnputc
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|struct
name|zstty_softc
modifier|*
name|sc
init|=
name|zstty_cons
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|zstty_cnputc
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zs_cndbctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|zstty_cnopen
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|zstty_cnclose
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|zstty_cngetc
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
name|zstty_cnopen
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
operator|&
name|ZSRR0_RX_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|c
operator|=
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
name|zstty_cnclose
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zstty_cncheckc
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|c
decl_stmt|;
name|c
operator|=
operator|-
literal|1
expr_stmt|;
name|zstty_cnopen
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
operator|&
name|ZSRR0_RX_READY
operator|)
operator|!=
literal|0
condition|)
name|c
operator|=
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
name|zstty_cnclose
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zstty_cnputc
parameter_list|(
name|struct
name|zstty_softc
modifier|*
name|sc
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|zstty_cnopen
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ZS_READ
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_csr
argument_list|)
operator|&
name|ZSRR0_TX_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|ZS_WRITE
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|zstty_cnclose
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

