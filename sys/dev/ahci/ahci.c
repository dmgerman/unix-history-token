begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"ahci.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_comment
comment|/* local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|ahci_setup_interrupt
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_intr_one
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ctlr_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_begin_transaction
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_execute_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_timeout
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_end_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|ahci_err_type
name|et
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_setup_fis
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_start
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_clo
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_start_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_stop_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_sata_connect
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|quick
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_issue_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_process_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahciaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahcipoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AHCI
argument_list|,
literal|"AHCI driver"
argument_list|,
literal|"AHCI driver data buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
block|{
name|uint32_t
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|quirks
decl_stmt|;
define|#
directive|define
name|AHCI_Q_NOFORCE
value|1
define|#
directive|define
name|AHCI_Q_NOPMP
value|2
define|#
directive|define
name|AHCI_Q_NONCQ
value|4
define|#
directive|define
name|AHCI_Q_1CH
value|8
define|#
directive|define
name|AHCI_Q_2CH
value|16
define|#
directive|define
name|AHCI_Q_4CH
value|32
define|#
directive|define
name|AHCI_Q_EDGEIS
value|64
block|}
name|ahci_ids
index|[]
init|=
block|{
block|{
literal|0x43801002
block|,
literal|"ATI IXP600"
block|,
literal|0
block|}
block|,
block|{
literal|0x43901002
block|,
literal|"ATI IXP700"
block|,
literal|0
block|}
block|,
block|{
literal|0x43911002
block|,
literal|"ATI IXP700"
block|,
literal|0
block|}
block|,
block|{
literal|0x43921002
block|,
literal|"ATI IXP700"
block|,
literal|0
block|}
block|,
block|{
literal|0x43931002
block|,
literal|"ATI IXP700"
block|,
literal|0
block|}
block|,
block|{
literal|0x43941002
block|,
literal|"ATI IXP800"
block|,
literal|0
block|}
block|,
block|{
literal|0x43951002
block|,
literal|"ATI IXP800"
block|,
literal|0
block|}
block|,
block|{
literal|0x26528086
block|,
literal|"Intel ICH6"
block|,
literal|0
block|}
block|,
block|{
literal|0x26538086
block|,
literal|"Intel ICH6M"
block|,
literal|0
block|}
block|,
block|{
literal|0x26818086
block|,
literal|"Intel ESB2"
block|,
literal|0
block|}
block|,
block|{
literal|0x26828086
block|,
literal|"Intel ESB2"
block|,
literal|0
block|}
block|,
block|{
literal|0x26838086
block|,
literal|"Intel ESB2"
block|,
literal|0
block|}
block|,
block|{
literal|0x27c18086
block|,
literal|"Intel ICH7"
block|,
literal|0
block|}
block|,
block|{
literal|0x27c38086
block|,
literal|"Intel ICH7"
block|,
literal|0
block|}
block|,
block|{
literal|0x27c58086
block|,
literal|"Intel ICH7M"
block|,
literal|0
block|}
block|,
block|{
literal|0x27c68086
block|,
literal|"Intel ICH7M"
block|,
literal|0
block|}
block|,
block|{
literal|0x28218086
block|,
literal|"Intel ICH8"
block|,
literal|0
block|}
block|,
block|{
literal|0x28228086
block|,
literal|"Intel ICH8"
block|,
literal|0
block|}
block|,
block|{
literal|0x28248086
block|,
literal|"Intel ICH8"
block|,
literal|0
block|}
block|,
block|{
literal|0x28298086
block|,
literal|"Intel ICH8M"
block|,
literal|0
block|}
block|,
block|{
literal|0x282a8086
block|,
literal|"Intel ICH8M"
block|,
literal|0
block|}
block|,
block|{
literal|0x29228086
block|,
literal|"Intel ICH9"
block|,
literal|0
block|}
block|,
block|{
literal|0x29238086
block|,
literal|"Intel ICH9"
block|,
literal|0
block|}
block|,
block|{
literal|0x29248086
block|,
literal|"Intel ICH9"
block|,
literal|0
block|}
block|,
block|{
literal|0x29258086
block|,
literal|"Intel ICH9"
block|,
literal|0
block|}
block|,
block|{
literal|0x29278086
block|,
literal|"Intel ICH9"
block|,
literal|0
block|}
block|,
block|{
literal|0x29298086
block|,
literal|"Intel ICH9M"
block|,
literal|0
block|}
block|,
block|{
literal|0x292a8086
block|,
literal|"Intel ICH9M"
block|,
literal|0
block|}
block|,
block|{
literal|0x292b8086
block|,
literal|"Intel ICH9M"
block|,
literal|0
block|}
block|,
block|{
literal|0x292c8086
block|,
literal|"Intel ICH9M"
block|,
literal|0
block|}
block|,
block|{
literal|0x292f8086
block|,
literal|"Intel ICH9M"
block|,
literal|0
block|}
block|,
block|{
literal|0x294d8086
block|,
literal|"Intel ICH9"
block|,
literal|0
block|}
block|,
block|{
literal|0x294e8086
block|,
literal|"Intel ICH9M"
block|,
literal|0
block|}
block|,
block|{
literal|0x3a058086
block|,
literal|"Intel ICH10"
block|,
literal|0
block|}
block|,
block|{
literal|0x3a228086
block|,
literal|"Intel ICH10"
block|,
literal|0
block|}
block|,
block|{
literal|0x3a258086
block|,
literal|"Intel ICH10"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b228086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b238086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b248086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b258086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b298086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b2b8086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b2c8086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x3b2f8086
block|,
literal|"Intel PCH"
block|,
literal|0
block|}
block|,
block|{
literal|0x2361197b
block|,
literal|"JMicron JMB361"
block|,
name|AHCI_Q_NOFORCE
block|}
block|,
block|{
literal|0x2363197b
block|,
literal|"JMicron JMB363"
block|,
name|AHCI_Q_NOFORCE
block|}
block|,
block|{
literal|0x2365197b
block|,
literal|"JMicron JMB365"
block|,
name|AHCI_Q_NOFORCE
block|}
block|,
block|{
literal|0x2366197b
block|,
literal|"JMicron JMB366"
block|,
name|AHCI_Q_NOFORCE
block|}
block|,
block|{
literal|0x2368197b
block|,
literal|"JMicron JMB368"
block|,
name|AHCI_Q_NOFORCE
block|}
block|,
block|{
literal|0x611111ab
block|,
literal|"Marvell 88SX6111"
block|,
name|AHCI_Q_NOFORCE
operator||
name|AHCI_Q_1CH
operator||
name|AHCI_Q_EDGEIS
block|}
block|,
block|{
literal|0x612111ab
block|,
literal|"Marvell 88SX6121"
block|,
name|AHCI_Q_NOFORCE
operator||
name|AHCI_Q_2CH
operator||
name|AHCI_Q_EDGEIS
block|}
block|,
block|{
literal|0x614111ab
block|,
literal|"Marvell 88SX6141"
block|,
name|AHCI_Q_NOFORCE
operator||
name|AHCI_Q_4CH
operator||
name|AHCI_Q_EDGEIS
block|}
block|,
block|{
literal|0x614511ab
block|,
literal|"Marvell 88SX6145"
block|,
name|AHCI_Q_NOFORCE
operator||
name|AHCI_Q_4CH
operator||
name|AHCI_Q_EDGEIS
block|}
block|,
block|{
literal|0x044c10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x044d10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x044e10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x044f10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x045c10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x045d10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x045e10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x045f10de
block|,
literal|"NVIDIA MCP65"
block|,
literal|0
block|}
block|,
block|{
literal|0x055010de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055110de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055210de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055310de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055410de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055510de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055610de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055710de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055810de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055910de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055A10de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x055B10de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x058410de
block|,
literal|"NVIDIA MCP67"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f010de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f110de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f210de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f310de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f410de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f510de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f610de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f710de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f810de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07f910de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07fa10de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x07fb10de
block|,
literal|"NVIDIA MCP73"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad010de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad110de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad210de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad310de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad410de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad510de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad610de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad710de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad810de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ad910de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ada10de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0adb10de
block|,
literal|"NVIDIA MCP77"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ab410de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ab510de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ab610de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ab710de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ab810de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0ab910de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0aba10de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0abb10de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0abc10de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0abd10de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0abe10de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0abf10de
block|,
literal|"NVIDIA MCP79"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8410de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8510de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8610de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8710de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8810de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8910de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8a10de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8b10de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8c10de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8d10de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8e10de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x0d8f10de
block|,
literal|"NVIDIA MCP89"
block|,
literal|0
block|}
block|,
block|{
literal|0x33491106
block|,
literal|"VIA VT8251"
block|,
literal|0
block|}
block|,
block|{
literal|0x62871106
block|,
literal|"VIA VT8251"
block|,
literal|0
block|}
block|,
block|{
literal|0x11841039
block|,
literal|"SiS 966"
block|,
literal|0
block|}
block|,
block|{
literal|0x11851039
block|,
literal|"SiS 968"
block|,
literal|0
block|}
block|,
block|{
literal|0x01861039
block|,
literal|"SiS 968"
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|ahci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|valid
init|=
literal|0
decl_stmt|;
name|uint32_t
name|devid
init|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Is this a possible AHCI candidate? */
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIC_STORAGE
operator|&&
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIS_STORAGE_SATA
operator|&&
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|==
name|PCIP_STORAGE_SATA_AHCI_1_0
condition|)
name|valid
operator|=
literal|1
expr_stmt|;
comment|/* Is this a known AHCI chip? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ahci_ids
index|[
name|i
index|]
operator|.
name|id
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ahci_ids
index|[
name|i
index|]
operator|.
name|id
operator|==
name|devid
operator|&&
operator|(
name|valid
operator|||
operator|!
operator|(
name|ahci_ids
index|[
name|i
index|]
operator|.
name|quirks
operator|&
name|AHCI_Q_NOFORCE
operator|)
operator|)
condition|)
block|{
comment|/* Do not attach JMicrons with single PCI function. */
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x197b
operator|&&
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0xdf
argument_list|,
literal|1
argument_list|)
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s AHCI SATA controller"
argument_list|,
name|ahci_ids
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_VENDOR
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|valid
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"AHCI SATA controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_VENDOR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ata_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|devid
init|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Is this a known AHCI chip? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ahci_ids
index|[
name|i
index|]
operator|.
name|id
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ahci_ids
index|[
name|i
index|]
operator|.
name|id
operator|==
name|devid
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s AHCI SATA controller"
argument_list|,
name|ahci_ids
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_VENDOR
operator|)
return|;
block|}
block|}
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"AHCI SATA controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_VENDOR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|,
name|speed
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|devid
init|=
name|pci_get_devid
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|version
decl_stmt|;
name|ctlr
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ahci_ids
index|[
name|i
index|]
operator|.
name|id
operator|!=
literal|0
operator|&&
name|ahci_ids
index|[
name|i
index|]
operator|.
name|id
operator|!=
name|devid
condition|)
name|i
operator|++
expr_stmt|;
name|ctlr
operator|->
name|quirks
operator|=
name|ahci_ids
index|[
name|i
index|]
operator|.
name|quirks
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"ccc"
argument_list|,
operator|&
name|ctlr
operator|->
name|ccc
argument_list|)
expr_stmt|;
comment|/* if we have a memory BAR(5) we are likely on an AHCI part */
name|ctlr
operator|->
name|r_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|ctlr
operator|->
name|r_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Setup our own memory management for channels. */
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_descr
operator|=
literal|"I/O memory addresses"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|,
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Reset controller */
if|if
condition|(
operator|(
name|error
operator|=
name|ahci_ctlr_reset
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
empty_stmt|;
comment|/* Get the HW capabilities */
name|version
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_VS
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|caps
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
literal|0x00010020
condition|)
name|ctlr
operator|->
name|caps2
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP2
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_1CH
condition|)
block|{
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_NPMASK
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|&=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_2CH
condition|)
block|{
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_NPMASK
expr_stmt|;
name|ctlr
operator|->
name|caps
operator||=
literal|1
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|&=
literal|0x03
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_4CH
condition|)
block|{
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_NPMASK
expr_stmt|;
name|ctlr
operator|->
name|caps
operator||=
literal|3
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|&=
literal|0x0f
expr_stmt|;
block|}
name|ctlr
operator|->
name|channels
operator|=
name|MAX
argument_list|(
name|flsl
argument_list|(
name|ctlr
operator|->
name|ichannels
argument_list|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_NOPMP
condition|)
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_SPM
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_NONCQ
condition|)
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_SNCQ
expr_stmt|;
comment|/* Setup interrupts. */
if|if
condition|(
name|ahci_setup_interrupt
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Announce HW capabilities. */
name|speed
operator|=
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_ISS
operator|)
operator|>>
name|AHCI_CAP_ISS_SHIFT
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI v%x.%02x with %d %sGbps ports, Port Multiplier %s\n"
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|20
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
operator|(
name|version
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
name|version
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|"supported"
else|:
literal|"not supported"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps:%s%s%s%s%s%s%s%s %sGbps"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_64BIT
operator|)
condition|?
literal|" 64bit"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
operator|)
condition|?
literal|" NCQ"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
operator|)
condition|?
literal|" SNTF"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SMPS
operator|)
condition|?
literal|" MPS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSS
operator|)
condition|?
literal|" SS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SALP
operator|)
condition|?
literal|" ALP"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SAL
operator|)
condition|?
literal|" AL"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SCLO
operator|)
condition|?
literal|" CLO"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s%s%s%s%s %dcmd%s%s%s %dports\n"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SAM
operator|)
condition|?
literal|" AM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|" PM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_FBSS
operator|)
condition|?
literal|" FBS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_PMD
operator|)
condition|?
literal|" PMD"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSC
operator|)
condition|?
literal|" SSC"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_PSC
operator|)
condition|?
literal|" PSC"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NCS
operator|)
operator|>>
name|AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_CCCS
operator|)
condition|?
literal|" CCC"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_EMS
operator|)
condition|?
literal|" EM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SXS
operator|)
condition|?
literal|" eSATA"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|version
operator|>=
literal|0x00010020
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps2:%s%s%s\n"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_APST
operator|)
condition|?
literal|" APST"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_NVMP
operator|)
condition|?
literal|" NVMP"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_BOH
operator|)
condition|?
literal|" BOH"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Attach all channels on this controller */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|ctlr
operator|->
name|channels
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ctlr
operator|->
name|ichannels
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ahcich"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add channel device\n"
argument_list|)
expr_stmt|;
else|else
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|unit
argument_list|)
expr_stmt|;
block|}
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|nchildren
decl_stmt|,
name|i
decl_stmt|;
comment|/* Detach& delete all children */
if|if
condition|(
operator|!
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nchildren
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* Free interrupts. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlr
operator|->
name|numirqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free memory. */
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|r_mem
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ctlr_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x00
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x28298086
operator|&&
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x92
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xfe
operator|)
operator|==
literal|0x04
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x92
argument_list|,
literal|0x01
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* Reset AHCI controller */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
operator||
name|AHCI_GHC_HR
argument_list|)
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|1000
init|;
name|timeout
operator|>
literal|0
condition|;
name|timeout
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
name|AHCI_GHC_HR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI controller reset failure\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Reenable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* Clear interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure CCC */
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCP
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCC
argument_list|,
operator|(
name|ctlr
operator|->
name|ccc
operator|<<
name|AHCI_CCCC_TV_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|AHCI_CCCC_CC_SHIFT
operator|)
operator||
name|AHCI_CCCC_EN
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|cccv
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCC
argument_list|)
operator|&
name|AHCI_CCCC_INT_MASK
operator|)
operator|>>
name|AHCI_CCCC_INT_SHIFT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CCC with %dms/4cmd enabled on vector %d\n"
argument_list|,
name|ctlr
operator|->
name|ccc
argument_list|,
name|ctlr
operator|->
name|cccv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable AHCI interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator||
name|AHCI_GHC_IE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable interupts, so the state change(s) doesn't trigger */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
operator|(
operator|~
name|AHCI_GHC_IE
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|ahci_ctlr_reset
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|res
operator|)
return|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_interrupt
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|msi
init|=
literal|1
decl_stmt|;
comment|/* Process hints. */
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"msi"
argument_list|,
operator|&
name|msi
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|<
literal|0
condition|)
name|msi
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|msi
operator|==
literal|1
condition|)
name|msi
operator|=
name|min
argument_list|(
literal|1
argument_list|,
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msi
operator|>
literal|1
condition|)
name|msi
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate MSI if needed/present. */
if|if
condition|(
name|msi
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msi
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctlr
operator|->
name|numirqs
operator|=
name|msi
expr_stmt|;
block|}
else|else
block|{
name|msi
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for single MSI vector fallback. */
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|>
literal|1
operator|&&
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
name|AHCI_GHC_MRSM
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Falling back to one MSI\n"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Allocate all IRQs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlr
operator|->
name|numirqs
condition|;
name|i
operator|++
control|)
block|{
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
operator|=
name|i
operator|+
operator|(
name|msi
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|==
literal|1
operator|||
name|i
operator|>=
name|ctlr
operator|->
name|channels
operator|||
operator|(
name|ctlr
operator|->
name|ccc
operator|&&
name|i
operator|==
name|ctlr
operator|->
name|cccv
operator|)
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|ctlr
operator|->
name|numirqs
operator|-
literal|1
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_AFTER
expr_stmt|;
else|else
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ONE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
operator|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|AHCI_IRQ_MODE_ONE
operator|)
condition|?
name|ahci_intr_one
else|:
name|ahci_intr
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
operator|)
condition|)
block|{
comment|/* SOS XXX release r_irq */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to setup interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common case interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ahci_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|u_int32_t
name|is
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|irq
operator|->
name|mode
operator|==
name|AHCI_IRQ_MODE_ALL
condition|)
block|{
name|unit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
name|is
operator|=
name|ctlr
operator|->
name|ichannels
expr_stmt|;
else|else
name|is
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* AHCI_IRQ_MODE_AFTER */
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
name|is
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|unit
operator|<
name|ctlr
operator|->
name|channels
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|is
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_EDGEIS
condition|)
block|{
comment|/* Some controller have edge triggered IS. */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
literal|1
operator|<<
name|unit
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* but AHCI declares level triggered IS. */
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
literal|1
operator|<<
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Simplified interrupt handler for multivector MSI mode.  */
end_comment

begin_function
specifier|static
name|void
name|ahci_intr_one
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|ahci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|device_get_softc
argument_list|(
name|child
argument_list|)
operator|)
operator|->
name|unit
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
name|AHCI_OFFSET
operator|+
operator|(
name|unit
operator|<<
literal|7
operator|)
decl_stmt|;
name|long
name|st
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
name|st
operator|=
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|,
name|st
operator|+
name|offset
argument_list|,
name|st
operator|+
name|offset
operator|+
literal|127
argument_list|,
literal|128
argument_list|,
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|bus_space_subregion
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|offset
argument_list|,
literal|128
argument_list|,
operator|&
name|bsh
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|res
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|res
argument_list|,
name|bst
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
operator|*
name|rid
operator|==
name|ATA_IRQ_RID
condition|)
name|res
operator|=
name|ctlr
operator|->
name|irqs
index|[
literal|0
index|]
operator|.
name|r_irq
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
name|rman_release_resource
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
name|rid
operator|!=
name|ATA_IRQ_RID
condition|)
return|return
name|ENOENT
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|driver_intr_t
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|argument
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahci.c: we cannot use a filter here\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|=
name|argument
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
operator|=
name|NULL
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at channel %d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|ahci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ahci_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ahci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ahci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ahci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ahci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ahci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ahci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ahci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ahci_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahci_driver
init|=
block|{
literal|"ahci"
block|,
name|ahci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_controller
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahci
argument_list|,
name|pci
argument_list|,
name|ahci_driver
argument_list|,
name|ahci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ahci_ata_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahci_ata_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ahci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ahci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ahci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ahci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ahci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ahci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ahci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ahci_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahci_ata_driver
init|=
block|{
literal|"ahci"
block|,
name|ahci_ata_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_controller
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahci
argument_list|,
name|atapci
argument_list|,
name|ahci_ata_driver
argument_list|,
name|ahci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ahci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahci
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ahci_ch_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"AHCI channel"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sata_rev
init|=
literal|0
decl_stmt|;
name|ch
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ch
operator|->
name|unit
operator|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|caps
operator|=
name|ctlr
operator|->
name|caps
expr_stmt|;
name|ch
operator|->
name|caps2
operator|=
name|ctlr
operator|->
name|caps2
expr_stmt|;
name|ch
operator|->
name|quirks
operator|=
name|ctlr
operator|->
name|quirks
expr_stmt|;
name|ch
operator|->
name|numslots
operator|=
operator|(
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_NCS
operator|)
operator|>>
name|AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
operator|,
name|mtx_init
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|"AHCI channel lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"pm_level"
argument_list|,
operator|&
name|ch
operator|->
name|pm_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_init_mtx
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Limit speed for my onboard JMicron external port. 	 * It is not eSATA really. */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
operator|==
literal|0x2363197b
operator|&&
name|pci_get_subvendor
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
operator|==
literal|0x1043
operator|&&
name|pci_get_subdevice
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
operator|==
literal|0x81e4
operator|&&
name|ch
operator|->
name|unit
operator|==
literal|0
condition|)
name|sata_rev
operator|=
literal|1
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sata_rev"
argument_list|,
operator|&
name|sata_rev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|revision
operator|=
name|sata_rev
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|bytecount
operator|=
literal|8192
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|tags
operator|=
name|ch
operator|->
name|numslots
expr_stmt|;
name|ch
operator|->
name|curr
index|[
name|i
index|]
operator|=
name|ch
operator|->
name|user
index|[
name|i
index|]
expr_stmt|;
block|}
name|rid
operator|=
name|ch
operator|->
name|unit
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ahci_dmainit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_slotsalloc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_ch_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ATA_IRQ_RID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
name|ahci_ch_intr_locked
argument_list|,
name|dev
argument_list|,
operator|&
name|ch
operator|->
name|ih
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to setup interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Create the device queue for our SIM. */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ch
operator|->
name|numslots
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate simq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Construct SIM entry */
name|ch
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahciaction
argument_list|,
name|ahcipoll
argument_list|,
literal|"ahcich"
argument_list|,
name|ch
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|min
argument_list|(
literal|2
argument_list|,
name|ch
operator|->
name|numslots
argument_list|)
argument_list|,
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
operator|)
condition|?
name|ch
operator|->
name|numslots
else|:
literal|0
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate sim\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to register xpt bus\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ch
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create path\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|,
name|ahci_ch_pm
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err3
label|:
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|err2
label|:
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|err1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ch
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_drain
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ch
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|ahci_ch_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_slotsfree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Disable port interrupts. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset command register. */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_stop_fr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow everything, including partial and slumber modes. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Request slumber mode transition and give some time to get there. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|AHCI_P_CMD_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Disable PHY. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_DISABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint64_t
name|work
decl_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup work areas */
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|AHCI_CL_OFFSET
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CLB
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CLBU
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FB
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBU
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
comment|/* Activate the channel and power/spin up device */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
operator|(
name|AHCI_P_CMD_ACTIVE
operator||
name|AHCI_P_CMD_POD
operator||
name|AHCI_P_CMD_SUD
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|2
operator|||
name|ch
operator|->
name|pm_level
operator|==
literal|3
operator|)
condition|?
name|AHCI_P_CMD_ALPE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|2
operator|)
condition|?
name|AHCI_P_CMD_ASP
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ahci_start_fr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|ahcich_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ahcich_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahci_ch_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahci_ch_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ahci_ch_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ahci_ch_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ahci_ch_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahcich_driver
init|=
block|{
literal|"ahcich"
block|,
name|ahcich_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_channel
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahcich
argument_list|,
name|ahci
argument_list|,
name|ahcich_driver
argument_list|,
name|ahcich_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ahci_dc_cb_args
block|{
name|bus_addr_t
name|maddr
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_dc_cb_args
name|dcba
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_64BIT
condition|)
name|ch
operator|->
name|dma
operator|.
name|max_address
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|ch
operator|->
name|dma
operator|.
name|max_address
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
comment|/* Command area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1024
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|max_address
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
literal|1
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
name|ahci_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* FIS receive area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|max_address
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
literal|1
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
literal|4096
argument_list|,
name|ahci_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* Data area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|max_address
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AHCI_SG_ENTRIES
operator|*
name|PAGE_SIZE
operator|*
name|ch
operator|->
name|numslots
argument_list|,
name|AHCI_SG_ENTRIES
argument_list|,
name|AHCI_PRD_MAX
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return;
name|error
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING - DMA initialization failed\n"
argument_list|)
expr_stmt|;
name|ahci_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahci_dc_cb_args
modifier|*
name|dcba
init|=
operator|(
expr|struct
name|ahci_dc_cb_args
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dcba
operator|->
name|error
operator|=
name|error
operator|)
condition|)
name|dcba
operator|->
name|maddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|data_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis_map
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_map
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Alloc and setup command/dma slots */
name|bzero
argument_list|(
name|ch
operator|->
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|slot
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|slot
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|slot
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"FAILURE - create data_map\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Free all dma slots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|dma
operator|.
name|data_map
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|data_map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_phy_check_events
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|serr
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|serr
operator|&
name|ATA_SE_PHY_CHANGED
operator|)
operator|&&
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|)
block|{
name|u_int32_t
name|status
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_SPD_MASK
operator|)
operator|!=
name|ATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_IPM_MASK
operator|)
operator|==
name|ATA_SS_IPM_ACTIVE
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CONNECT requested\n"
argument_list|)
expr_stmt|;
name|ahci_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DISCONNECT requested\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_notify_events
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
name|status
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|dpath
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SNTF
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SNTF 0x%04x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|dpath
argument_list|,
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ch
operator|->
name|path
argument_list|)
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_SCSI_AEN
argument_list|,
name|dpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|dpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|data
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ahci_ch_intr
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|work
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return;
name|work
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
condition|)
name|work
operator||=
name|AHCI_P_CMD_PARTIAL
expr_stmt|;
else|else
name|work
operator||=
name|AHCI_P_CMD_SLUMBER
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|data
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|istatus
decl_stmt|,
name|sstatus
decl_stmt|,
name|cstatus
decl_stmt|,
name|serr
init|=
literal|0
decl_stmt|,
name|sntf
init|=
literal|0
decl_stmt|,
name|ok
decl_stmt|,
name|err
decl_stmt|;
name|enum
name|ahci_err_type
name|et
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ccs
decl_stmt|,
name|ncq_err
init|=
literal|0
decl_stmt|;
comment|/* Read and clear interrupt statuses. */
name|istatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
expr_stmt|;
if|if
condition|(
name|istatus
operator|==
literal|0
condition|)
return|return;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
comment|/* Read command statuses. */
name|sstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
expr_stmt|;
name|cstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|istatus
operator|&
name|AHCI_P_IX_SDB
operator|)
operator|&&
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
operator|)
condition|)
name|sntf
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SNTF
argument_list|)
expr_stmt|;
comment|/* Process PHY events */
if|if
condition|(
name|istatus
operator|&
operator|(
name|AHCI_P_IX_PC
operator||
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_OF
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_TFE
operator|)
condition|)
block|{
name|serr
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|serr
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
name|serr
argument_list|)
expr_stmt|;
name|ahci_phy_check_events
argument_list|(
name|dev
argument_list|,
name|serr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process command errors */
if|if
condition|(
name|istatus
operator|&
operator|(
name|AHCI_P_IX_OF
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_TFE
operator|)
condition|)
block|{
comment|//device_printf(dev, "%s ERROR is %08x cs %08x ss %08x rs %08x tfd %02x serr %08x\n",
comment|//    __func__, istatus, cstatus, sstatus, ch->rslots, ATA_INL(ch->r_mem, AHCI_P_TFD),
comment|//    serr);
name|ccs
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CCS_MASK
operator|)
operator|>>
name|AHCI_P_CMD_CCS_SHIFT
expr_stmt|;
name|err
operator|=
name|ch
operator|->
name|rslots
operator|&
operator|(
name|cstatus
operator||
name|sstatus
operator|)
expr_stmt|;
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccs
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Complete all successfull commands. */
name|ok
operator|=
name|ch
operator|->
name|rslots
operator|&
operator|~
operator|(
name|cstatus
operator||
name|sstatus
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ok
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* On error, complete the rest of commands with error statuses. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX: reqests in loading state. */
if|if
condition|(
operator|(
operator|(
name|err
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|istatus
operator|&
name|AHCI_P_IX_TFE
condition|)
block|{
comment|/* Task File Error */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|==
literal|0
condition|)
block|{
comment|/* Untagged operation. */
if|if
condition|(
name|i
operator|==
name|ccs
condition|)
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
else|else
name|et
operator|=
name|AHCI_ERR_INNOCENT
expr_stmt|;
block|}
else|else
block|{
comment|/* Tagged operation. */
name|et
operator|=
name|AHCI_ERR_NCQ
expr_stmt|;
name|ncq_err
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|istatus
operator|&
name|AHCI_P_IX_IF
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|==
literal|0
operator|&&
name|i
operator|!=
name|ccs
condition|)
name|et
operator|=
name|AHCI_ERR_INNOCENT
expr_stmt|;
else|else
name|et
operator|=
name|AHCI_ERR_SATA
expr_stmt|;
block|}
else|else
name|et
operator|=
name|AHCI_ERR_INVALID
expr_stmt|;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ncq_err
condition|)
name|ahci_issue_read_log
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Process NOTIFY events */
if|if
condition|(
name|sntf
condition|)
name|ahci_notify_events
argument_list|(
name|dev
argument_list|,
name|sntf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|int
name|ahci_check_collision
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
comment|/* Tagged command while untagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslots
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Tagged command while tagged to other target is active. */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|taggedtarget
operator|!=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Tagged command while we have no supported tag free. */
if|if
condition|(
operator|(
operator|(
operator|~
name|ch
operator|->
name|oslots
operator|)
operator|&
operator|(
literal|0xffffffff
operator|>>
operator|(
literal|32
operator|-
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|tags
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Untagged command while tagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
operator|)
condition|)
block|{
comment|/* Atomic command while anything active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We have some atomic command running. */
if|if
condition|(
name|ch
operator|->
name|aslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_begin_transaction
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_slot
modifier|*
name|slot
decl_stmt|;
name|int
name|tag
decl_stmt|,
name|tags
decl_stmt|;
comment|/* Choose empty slot. */
name|tags
operator|=
name|ch
operator|->
name|numslots
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
name|tags
operator|=
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|tags
expr_stmt|;
name|tag
operator|=
name|ch
operator|->
name|lastslot
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|tag
operator|>=
name|tags
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|tag
index|]
operator|.
name|state
operator|==
name|AHCI_SLOT_EMPTY
condition|)
break|break;
name|tag
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|ch
operator|->
name|lastslot
operator|=
name|tag
expr_stmt|;
comment|/* Occupy chosen slot. */
name|slot
operator|=
operator|&
name|ch
operator|->
name|slot
index|[
name|tag
index|]
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* Stop PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|oslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|numrslots
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ch
operator|->
name|numtslots
operator|++
expr_stmt|;
name|ch
operator|->
name|taggedtarget
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
operator|)
condition|)
name|ch
operator|->
name|aslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|nsegs
operator|=
literal|0
expr_stmt|;
comment|/* If request moves data, setup and load SG list */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_LOADING
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|buf
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
name|size
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|ahci_dmasetprd
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|ahci_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locked by busdma engine. */
end_comment

begin_function
specifier|static
name|void
name|ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|slot
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ahci_dma_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|slot
operator|->
name|dev
argument_list|,
literal|"DMA load error\n"
argument_list|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|AHCI_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|AHCI_SG_ENTRIES
argument_list|,
operator|(
literal|"too many DMA segment entries\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Fill S/G table */
name|prd
operator|=
operator|&
name|ctp
operator|->
name|prd_tab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|prd
index|[
name|i
index|]
operator|.
name|dba
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|dbc
operator|=
name|htole32
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
literal|1
operator|)
operator|&
name|AHCI_PRD_MASK
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|dma
operator|.
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
operator|(
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
operator|)
argument_list|)
expr_stmt|;
name|ahci_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_execute_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ahci_cmd_list
modifier|*
name|clp
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|int
name|port
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
decl_stmt|;
name|int
name|fis_size
decl_stmt|;
comment|/* Get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Setup the FIS for this request */
if|if
condition|(
operator|!
operator|(
name|fis_size
operator|=
name|ahci_setup_fis
argument_list|(
name|dev
argument_list|,
name|ctp
argument_list|,
name|ccb
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Setting up SATA FIS failed\n"
argument_list|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|AHCI_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup the command list entry */
name|clp
operator|=
operator|(
expr|struct
name|ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CL_OFFSET
operator|+
operator|(
name|AHCI_CL_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
name|clp
operator|->
name|prd_length
operator|=
name|slot
operator|->
name|dma
operator|.
name|nsegs
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
condition|?
name|AHCI_CMD_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|?
operator|(
name|AHCI_CMD_ATAPI
operator||
name|AHCI_CMD_PREFETCH
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|fis_size
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator||
operator|(
name|port
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* Special handling for Soft Reset command. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
operator|)
condition|)
block|{
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_clo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator||=
name|AHCI_CMD_RESET
operator||
name|AHCI_CMD_CLR_BUSY
expr_stmt|;
block|}
name|clp
operator|->
name|bytecount
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|cmd_table_phys
operator|=
name|htole64
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Set ACTIVE bit for NCQ commands. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|,
literal|1
operator|<<
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* Issue command to the controller. */
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_RUNNING
expr_stmt|;
name|ch
operator|->
name|rslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|,
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
argument_list|)
expr_stmt|;
comment|/* Device reset commands doesn't interrupt. Poll them. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
operator|==
name|ATA_DEVICE_RESET
operator|||
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|,
name|timeout
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
decl_stmt|;
name|enum
name|ahci_err_type
name|et
init|=
name|AHCI_ERR_NONE
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|timeout
condition|;
name|count
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
operator|&
name|ATA_S_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Poll error on slot %d, TFD: %04x\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
break|break;
block|}
comment|/* Workaround for ATI SB600/SB700 chipsets. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|15
operator|&&
name|pci_get_vendor
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
literal|0x1002
operator|&&
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
operator|&
name|AHCI_P_IX_IPM
operator|)
condition|)
block|{
name|et
operator|=
name|AHCI_ERR_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|timeout
operator|&&
operator|(
name|count
operator|>=
name|timeout
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Poll timeout on slot %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
name|et
operator|=
name|AHCI_ERR_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|et
operator|!=
name|AHCI_ERR_NONE
condition|)
block|{
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|et
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Start command execution timeout */
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|(
name|int
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|2000
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ahci_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Locked by callout mechanism. */
end_comment

begin_function
specifier|static
name|void
name|ahci_timeout
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|sstatus
decl_stmt|;
name|int
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for stale timeout. */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
return|return;
comment|/* Check if slot was not being executed last time we checked. */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|AHCI_SLOT_EXECUTING
condition|)
block|{
comment|/* Check if slot started executing. */
name|sstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
expr_stmt|;
name|ccs
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CCS_MASK
operator|)
operator|>>
name|AHCI_P_CMD_CCS_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|sstatus
operator|&
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
operator|!=
literal|0
operator|||
name|ccs
operator|==
name|slot
operator|->
name|slot
condition|)
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EXECUTING
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|(
name|int
operator|)
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|2000
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ahci_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timeout on slot %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"is %08x cs %08x ss %08x rs %08x tfd %02x serr %08x\n"
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
argument_list|,
name|ch
operator|->
name|rslots
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
comment|/* Handle frozen command. */
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
comment|/* Handle command with timeout. */
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|slot
operator|->
name|slot
index|]
argument_list|,
name|AHCI_ERR_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Handle the rest of commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_end_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|ahci_err_type
name|et
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Read result registers to the result struct 	 * May be incorrect if several commands finished same time, 	 * so read only when sure or have to. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|struct
name|ata_res
modifier|*
name|res
init|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|et
operator|==
name|AHCI_ERR_TFE
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_NEEDRESULT
operator|)
condition|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|+
literal|0x40
decl_stmt|;
name|uint16_t
name|tfd
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|tfd
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|tfd
operator|>>
literal|8
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|fis
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|fis
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|fis
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|fis
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|fis
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|fis
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|fis
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|fis
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|fis
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
block|}
comment|/* In case of error, freeze device for proper recovery. */
if|if
condition|(
operator|(
name|et
operator|!=
name|AHCI_ERR_NONE
operator|)
operator|&&
operator|(
operator|!
name|ch
operator|->
name|readlog
operator|)
operator|&&
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
comment|/* Set proper result status. */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|AHCI_ERR_NONE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_INVALID
case|:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_INNOCENT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_TFE
case|:
case|case
name|AHCI_ERR_NCQ
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_ATA_STATUS_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|AHCI_ERR_SATA
case|:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|readlog
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_TIMEOUT
case|:
comment|/* Do no treat soft-reset timeout as fatal here. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_ATA_IO
operator|||
operator|!
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
condition|)
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|readlog
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
default|default:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
comment|/* Free slot. */
name|ch
operator|->
name|oslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|rslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|aslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|numrslots
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ch
operator|->
name|numtslots
operator|--
expr_stmt|;
block|}
comment|/* If it was first request of reset sequence and there is no error, 	 * proceed to second request. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
operator|)
operator|&&
name|et
operator|==
name|AHCI_ERR_NONE
condition|)
block|{
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&=
operator|~
name|ATA_A_RESET
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it was our READ LOG command - process it. */
if|if
condition|(
name|ch
operator|->
name|readlog
condition|)
block|{
name|ahci_process_read_log
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* If it was NCQ command error, put result on hold. */
block|}
elseif|else
if|if
condition|(
name|et
operator|==
name|AHCI_ERR_NCQ
condition|)
block|{
name|ch
operator|->
name|hold
index|[
name|slot
operator|->
name|slot
index|]
operator|=
name|ccb
expr_stmt|;
block|}
else|else
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* Unfreeze frozen command. */
if|if
condition|(
name|ch
operator|->
name|frozen
operator|&&
operator|!
name|ahci_check_collision
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|frozen
argument_list|)
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* If we have no other active commands, ... */
if|if
condition|(
name|ch
operator|->
name|rslots
operator|==
literal|0
condition|)
block|{
comment|/* if there was fatal error - reset port. */
if|if
condition|(
name|ch
operator|->
name|fatalerr
condition|)
block|{
name|ahci_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Start PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_issue_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_ataio
modifier|*
name|ataio
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|readlog
operator|=
literal|1
expr_stmt|;
comment|/* Find some holden command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
break|break;
block|}
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable allocate READ LOG command"
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX */
block|}
name|ccb
operator|->
name|ccb_h
operator|=
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
expr_stmt|;
comment|/* Reuse old header. */
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ATA_IO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|1000
expr_stmt|;
comment|/* 1s should be enough. */
name|ataio
operator|=
operator|&
name|ccb
operator|->
name|ataio
expr_stmt|;
name|ataio
operator|->
name|data_ptr
operator|=
name|malloc
argument_list|(
literal|512
argument_list|,
name|M_AHCI
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ataio
operator|->
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable allocate memory for READ LOG command"
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX */
block|}
name|ataio
operator|->
name|dxfer_len
operator|=
literal|512
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ataio
operator|->
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ataio
operator|->
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|flags
operator|=
name|CAM_ATAIO_48BIT
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|command
operator|=
literal|0x2F
expr_stmt|;
comment|/* READ LOG EXT */
name|ataio
operator|->
name|cmd
operator|.
name|sector_count
operator|=
literal|1
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|sector_count_exp
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_low
operator|=
literal|0x10
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid_exp
operator|=
literal|0
expr_stmt|;
comment|/* Freeze SIM while doing READ LOG EXT. */
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_process_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ata_res
modifier|*
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|readlog
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x1F
operator|)
operator|==
name|i
condition|)
block|{
name|res
operator|=
operator|&
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ataio
operator|.
name|res
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|data
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|data
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|data
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|data
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|data
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|data
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error while READ LOG EXT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Non-queued command error in READ LOG EXT\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
argument_list|,
name|M_AHCI
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_start
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Clear any interrupts pending on this channel */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Start operations on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator||
name|AHCI_P_CMD_ST
operator||
operator|(
name|ch
operator|->
name|pm_present
condition|?
name|AHCI_P_CMD_PMA
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Kill all activity on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator|&
operator|~
name|AHCI_P_CMD_ST
argument_list|)
expr_stmt|;
comment|/* Wait for activity stop. */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_clo
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Issue Command List Override if supported */
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SCLO
condition|)
block|{
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|AHCI_P_CMD_CLO
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"executing CLO failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CLO
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_stop_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Kill all FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator|&
operator|~
name|AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
comment|/* Wait for FIS reception stop. */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI FR engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_FR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_start_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
comment|/* Start FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator||
name|AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_wait_ready
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
operator|)
operator|&
operator|(
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
name|t
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port is not ready (timeout %dms) "
literal|"tfd = %08x\n"
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ready wait time=%dms\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset...\n"
argument_list|)
expr_stmt|;
comment|/* Requeue freezed command. */
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
comment|/* Kill the engine and requeue all running commands. */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
comment|/* XXX; Commands in loading state. */
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|ch
operator|->
name|fatalerr
operator|=
literal|0
expr_stmt|;
comment|/* Tell the XPT about the event */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset and reconnect PHY, */
if|if
condition|(
operator|!
name|ahci_sata_phy_reset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset done: phy reset found no device\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
comment|/* Enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
operator|(
name|AHCI_P_IX_CPD
operator||
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_PC
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait for clearing busy status. */
if|if
condition|(
name|ahci_wait_ready
argument_list|(
name|dev
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"device ready timeout\n"
argument_list|)
expr_stmt|;
name|ahci_clo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|1
expr_stmt|;
comment|/* Enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
operator|(
name|AHCI_P_IX_CPD
operator||
name|AHCI_P_IX_TFE
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_OF
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|?
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_PC
else|:
literal|0
operator|)
operator||
name|AHCI_P_IX_DP
operator||
name|AHCI_P_IX_UF
operator||
operator|(
name|ctlr
operator|->
name|ccc
condition|?
literal|0
else|:
name|AHCI_P_IX_SDB
operator|)
operator||
name|AHCI_P_IX_DS
operator||
name|AHCI_P_IX_PS
operator||
operator|(
name|ctlr
operator|->
name|ccc
condition|?
literal|0
else|:
name|AHCI_P_IX_DHR
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset done: device found\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_fis
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int8_t
modifier|*
name|fis
init|=
operator|&
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
decl_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|fis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|fis
index|[
literal|1
index|]
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ATA_PACKET_CMD
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|&&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|mode
operator|>=
name|ATA_DMA
condition|)
name|fis
index|[
literal|3
index|]
operator|=
name|ATA_F_DMA
expr_stmt|;
else|else
block|{
name|fis
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>>
literal|8
expr_stmt|;
block|}
name|fis
index|[
literal|7
index|]
operator|=
name|ATA_D_LBA
expr_stmt|;
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|acmd
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|ctp
operator|->
name|acmd
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|==
literal|0
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
expr_stmt|;
name|fis
index|[
literal|3
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features
expr_stmt|;
name|fis
index|[
literal|4
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low
expr_stmt|;
name|fis
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high
expr_stmt|;
name|fis
index|[
literal|7
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|device
expr_stmt|;
name|fis
index|[
literal|8
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low_exp
expr_stmt|;
name|fis
index|[
literal|9
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid_exp
expr_stmt|;
name|fis
index|[
literal|10
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high_exp
expr_stmt|;
name|fis
index|[
literal|11
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features_exp
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|fis
index|[
literal|12
index|]
operator|=
name|tag
operator|<<
literal|3
expr_stmt|;
name|fis
index|[
literal|13
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fis
index|[
literal|12
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count
expr_stmt|;
name|fis
index|[
literal|13
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count_exp
expr_stmt|;
block|}
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
block|}
else|else
block|{
name|fis
index|[
literal|15
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
expr_stmt|;
block|}
return|return
operator|(
literal|20
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_sata_connect
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Wait up to 100ms for "connect well" */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|100
condition|;
name|timeout
operator|++
control|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_SPD_MASK
operator|)
operator|!=
name|ATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_IPM_MASK
operator|)
operator|==
name|ATA_SS_IPM_ACTIVE
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_OFFLINE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA offline status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>=
literal|100
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect timeout status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect time=%dms status=%08x\n"
argument_list|,
name|timeout
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|quick
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|sata_rev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|quick
condition|)
block|{
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|ATA_SC_DET_MASK
operator|)
operator|==
name|ATA_SC_DET_IDLE
condition|)
return|return
operator|(
name|ahci_sata_connect
argument_list|(
name|ch
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hardware reset ...\n"
argument_list|)
expr_stmt|;
name|sata_rev
operator|=
name|ch
operator|->
name|user
index|[
name|ch
operator|->
name|pm_present
condition|?
literal|15
else|:
literal|0
index|]
operator|.
name|revision
expr_stmt|;
if|if
condition|(
name|sata_rev
operator|==
literal|1
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN1
expr_stmt|;
elseif|else
if|if
condition|(
name|sata_rev
operator|==
literal|2
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN2
expr_stmt|;
elseif|else
if|if
condition|(
name|sata_rev
operator|==
literal|3
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN3
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_RESET
operator||
name|val
operator||
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_IDLE
operator||
name|val
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahci_sata_connect
argument_list|(
name|ch
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahciaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahciaction func_code=%x\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ch
operator|->
name|dev
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ATA_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
name|ch
operator|->
name|devices
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check for command collision. */
if|if
condition|(
name|ahci_check_collision
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
comment|/* Freeze command. */
name|ch
operator|->
name|frozen
operator|=
name|ccb
expr_stmt|;
comment|/* We have only one frozen slot, so freeze simq also. */
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ahci_device
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|d
operator|=
operator|&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_REVISION
condition|)
name|d
operator|->
name|revision
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_MODE
condition|)
name|d
operator|->
name|mode
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_BYTECOUNT
condition|)
name|d
operator|->
name|bytecount
operator|=
name|min
argument_list|(
literal|8192
argument_list|,
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bytecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_TAGS
condition|)
name|d
operator|->
name|tags
operator|=
name|min
argument_list|(
name|ch
operator|->
name|numslots
argument_list|,
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_PM
condition|)
name|ch
operator|->
name|pm_present
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ahci_device
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|d
operator|=
operator|&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|15
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|0
operator|&&
operator|!
name|ch
operator|->
name|pm_present
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
operator|&
name|ATA_SS_SPD_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0f0
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
operator|=
operator|(
name|status
operator|&
literal|0x0f0
operator|)
operator|>>
literal|4
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
block|}
block|}
else|else
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
operator|=
name|d
operator|->
name|revision
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
block|}
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|mode
operator|=
name|d
operator|->
name|mode
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_MODE
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bytecount
operator|=
name|d
operator|->
name|bytecount
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_BYTECOUNT
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
operator|=
name|ch
operator|->
name|pm_present
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_PM
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|tags
operator|=
name|d
operator|->
name|tags
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_TAGS
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|case XPT_CALC_GEOMETRY: 	{ 		struct	  ccb_calc_geometry *ccg; 		uint32_t size_mb; 		uint32_t secs_per_cylinder;  		ccg =&ccb->ccg; 		size_mb = ccg->volume_size 			/ ((1024L * 1024L) / ccg->block_size); 		if (size_mb>= 1024&& (aha->extended_trans != 0)) { 			if (size_mb>= 2048) { 				ccg->heads = 255; 				ccg->secs_per_track = 63; 			} else { 				ccg->heads = 128; 				ccg->secs_per_track = 32; 			} 		} else { 			ccg->heads = 64; 			ccg->secs_per_track = 32; 		} 		secs_per_cylinder = ccg->heads * ccg->secs_per_track; 		ccg->cylinders = ccg->volume_size / secs_per_cylinder; 		ccb->ccb_h.status = CAM_REQ_CMP; 		xpt_done(ccb); 		break; 	}
endif|#
directive|endif
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
name|ahci_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_SATAPM
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_SEQSCAN
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
condition|)
name|cpi
operator|->
name|max_target
operator|=
literal|15
expr_stmt|;
else|else
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"AHCI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
comment|/* ATI SB600 can't handle 256 sectors with FPDMA (NCQ). */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
literal|0x43801002
condition|)
name|cpi
operator|->
name|maxio
operator|=
name|min
argument_list|(
name|cpi
operator|->
name|maxio
argument_list|,
literal|128
operator|*
literal|512
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahcipoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|ahci_ch_intr
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

