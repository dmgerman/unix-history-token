begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|"ahci.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_periph.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_comment
comment|/* local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|ahci_setup_interrupt
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_intr_one
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ctlr_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_begin_transaction
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_execute_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_timeout
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_end_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|ahci_err_type
name|et
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_setup_fis
parameter_list|(
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_start
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_clo
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_start_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_stop_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_sata_connect
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|quick
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_issue_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_process_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahciaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahcipoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AHCI
argument_list|,
literal|"AHCI driver"
argument_list|,
literal|"AHCI driver data buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * AHCI v1.x compliant SATA chipset support functions  */
end_comment

begin_function
specifier|static
name|int
name|ahci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* is this a possible AHCI candidate ? */
if|if
condition|(
name|pci_get_class
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIC_STORAGE
operator|||
name|pci_get_subclass
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIS_STORAGE_SATA
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* is this PCI device flagged as an AHCI compliant chip ? */
if|if
condition|(
name|pci_get_progif
argument_list|(
name|dev
argument_list|)
operator|!=
name|PCIP_STORAGE_SATA_AHCI_1_0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"AHCI controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_VENDOR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|,
name|speed
decl_stmt|;
name|u_int32_t
name|version
decl_stmt|;
name|ctlr
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"ccc"
argument_list|,
operator|&
name|ctlr
operator|->
name|ccc
argument_list|)
expr_stmt|;
comment|/* if we have a memory BAR(5) we are likely on an AHCI part */
name|ctlr
operator|->
name|r_rid
operator|=
name|PCIR_BAR
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|ctlr
operator|->
name|r_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/* Setup our own memory management for channels. */
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_descr
operator|=
literal|"I/O memory addresses"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|,
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Reset controller */
if|if
condition|(
operator|(
name|error
operator|=
name|ahci_ctlr_reset
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
empty_stmt|;
comment|/* Get the number of HW channels */
name|ctlr
operator|->
name|ichannels
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|channels
operator|=
name|MAX
argument_list|(
name|flsl
argument_list|(
name|ctlr
operator|->
name|ichannels
argument_list|)
argument_list|,
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|)
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup interrupts. */
if|if
condition|(
name|ahci_setup_interrupt
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Announce HW capabilities. */
name|version
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_VS
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|caps
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
literal|0x00010020
condition|)
name|ctlr
operator|->
name|caps2
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP2
argument_list|)
expr_stmt|;
name|speed
operator|=
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_ISS
operator|)
operator|>>
name|AHCI_CAP_ISS_SHIFT
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI v%x.%02x with %d %sGbps ports, Port Multiplier %s\n"
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|20
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
operator|(
name|version
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
name|version
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|"supported"
else|:
literal|"not supported"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps:%s%s%s%s%s%s%s%s %sGbps"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_64BIT
operator|)
condition|?
literal|" 64bit"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
operator|)
condition|?
literal|" NCQ"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
operator|)
condition|?
literal|" SNTF"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SMPS
operator|)
condition|?
literal|" MPS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSS
operator|)
condition|?
literal|" SS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SALP
operator|)
condition|?
literal|" ALP"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SAL
operator|)
condition|?
literal|" AL"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SCLO
operator|)
condition|?
literal|" CLO"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s%s%s%s%s %dcmd%s%s%s %dports\n"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SAM
operator|)
condition|?
literal|" AM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|" PM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_FBSS
operator|)
condition|?
literal|" FBS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_PMD
operator|)
condition|?
literal|" PMD"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSC
operator|)
condition|?
literal|" SSC"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_PSC
operator|)
condition|?
literal|" PSC"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NCS
operator|)
operator|>>
name|AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_CCCS
operator|)
condition|?
literal|" CCC"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_EMS
operator|)
condition|?
literal|" EM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SXS
operator|)
condition|?
literal|" eSATA"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|version
operator|>=
literal|0x00010020
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps2:%s%s%s\n"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_APST
operator|)
condition|?
literal|" APST"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_NVMP
operator|)
condition|?
literal|" NVMP"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_BOH
operator|)
condition|?
literal|" BOH"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Attach all channels on this controller */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|ctlr
operator|->
name|channels
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ctlr
operator|->
name|ichannels
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ahcich"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add channel device\n"
argument_list|)
expr_stmt|;
else|else
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|unit
argument_list|)
expr_stmt|;
block|}
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|nchildren
decl_stmt|,
name|i
decl_stmt|;
comment|/* Detach& delete all children */
if|if
condition|(
operator|!
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nchildren
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchildren
condition|;
name|i
operator|++
control|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|children
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* Free interrupts. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlr
operator|->
name|numirqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|)
expr_stmt|;
block|}
block|}
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free memory. */
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|r_mem
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ctlr_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x00
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x28298086
operator|&&
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
literal|0x92
argument_list|,
literal|1
argument_list|)
operator|&
literal|0xfe
operator|)
operator|==
literal|0x04
condition|)
name|pci_write_config
argument_list|(
name|dev
argument_list|,
literal|0x92
argument_list|,
literal|0x01
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* Reset AHCI controller */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
operator||
name|AHCI_GHC_HR
argument_list|)
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|1000
init|;
name|timeout
operator|>
literal|0
condition|;
name|timeout
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
name|AHCI_GHC_HR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI controller reset failure\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* Reenable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* Clear interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure CCC */
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCP
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCC
argument_list|,
operator|(
name|ctlr
operator|->
name|ccc
operator|<<
name|AHCI_CCCC_TV_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|AHCI_CCCC_CC_SHIFT
operator|)
operator||
name|AHCI_CCCC_EN
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|cccv
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCC
argument_list|)
operator|&
name|AHCI_CCCC_INT_MASK
operator|)
operator|>>
name|AHCI_CCCC_INT_SHIFT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CCC with %dms/4cmd enabled on vector %d\n"
argument_list|,
name|ctlr
operator|->
name|ccc
argument_list|,
name|ctlr
operator|->
name|cccv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable AHCI interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator||
name|AHCI_GHC_IE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Disable interupts, so the state change(s) doesn't trigger */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
operator|(
operator|~
name|AHCI_GHC_IE
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|ahci_ctlr_reset
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|res
operator|)
return|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_interrupt
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|msi
init|=
literal|1
decl_stmt|;
comment|/* Process hints. */
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"msi"
argument_list|,
operator|&
name|msi
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|<
literal|0
condition|)
name|msi
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|msi
operator|==
literal|1
condition|)
name|msi
operator|=
name|min
argument_list|(
literal|1
argument_list|,
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msi
operator|>
literal|1
condition|)
name|msi
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate MSI if needed/present. */
if|if
condition|(
name|msi
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msi
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ctlr
operator|->
name|numirqs
operator|=
name|msi
expr_stmt|;
block|}
else|else
block|{
name|msi
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check for single MSI vector fallback. */
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|>
literal|1
operator|&&
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
name|AHCI_GHC_MRSM
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Falling back to one MSI\n"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Allocate all IRQs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlr
operator|->
name|numirqs
condition|;
name|i
operator|++
control|)
block|{
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
operator|=
name|i
operator|+
operator|(
name|msi
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|==
literal|1
operator|||
name|i
operator|>=
name|ctlr
operator|->
name|channels
operator|||
operator|(
name|ctlr
operator|->
name|ccc
operator|&&
name|i
operator|==
name|ctlr
operator|->
name|cccv
operator|)
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|ctlr
operator|->
name|numirqs
operator|-
literal|1
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_AFTER
expr_stmt|;
else|else
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ONE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
operator|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|AHCI_IRQ_MODE_ONE
operator|)
condition|?
name|ahci_intr_one
else|:
name|ahci_intr
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
operator|)
condition|)
block|{
comment|/* SOS XXX release r_irq */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to setup interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common case interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ahci_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|u_int32_t
name|is
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|irq
operator|->
name|mode
operator|==
name|AHCI_IRQ_MODE_ALL
condition|)
block|{
name|unit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
name|is
operator|=
name|ctlr
operator|->
name|ichannels
expr_stmt|;
else|else
name|is
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* AHCI_IRQ_MODE_AFTER */
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
name|is
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|unit
operator|<
name|ctlr
operator|->
name|channels
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|is
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
block|{
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
literal|1
operator|<<
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Simplified interrupt handler for multivector MSI mode.  */
end_comment

begin_function
specifier|static
name|void
name|ahci_intr_one
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|ahci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|device_get_softc
argument_list|(
name|child
argument_list|)
operator|)
operator|->
name|unit
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|int
name|offset
init|=
name|AHCI_OFFSET
operator|+
operator|(
name|unit
operator|<<
literal|7
operator|)
decl_stmt|;
name|long
name|st
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
name|st
operator|=
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|,
name|st
operator|+
name|offset
argument_list|,
name|st
operator|+
name|offset
operator|+
literal|127
argument_list|,
literal|128
argument_list|,
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|bus_space_subregion
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|offset
argument_list|,
literal|128
argument_list|,
operator|&
name|bsh
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|res
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|res
argument_list|,
name|bst
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
operator|*
name|rid
operator|==
name|ATA_IRQ_RID
condition|)
name|res
operator|=
name|ctlr
operator|->
name|irqs
index|[
literal|0
index|]
operator|.
name|r_irq
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
name|rman_release_resource
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
name|rid
operator|!=
name|ATA_IRQ_RID
condition|)
return|return
name|ENOENT
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|driver_intr_t
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|argument
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahci.c: we cannot use a filter here\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|=
name|argument
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
operator|=
name|NULL
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at channel %d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|ahci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ahci_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ahci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ahci_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ahci_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ahci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ahci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ahci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ahci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ahci_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahci_driver
init|=
block|{
literal|"ahci"
block|,
name|ahci_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_controller
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahci
argument_list|,
name|pci
argument_list|,
name|ahci_driver
argument_list|,
name|ahci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ahci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahci
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ahci_ch_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"AHCI channel"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|;
name|ch
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ch
operator|->
name|unit
operator|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|caps
operator|=
name|ctlr
operator|->
name|caps
expr_stmt|;
name|ch
operator|->
name|caps2
operator|=
name|ctlr
operator|->
name|caps2
expr_stmt|;
name|ch
operator|->
name|numslots
operator|=
operator|(
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_NCS
operator|)
operator|>>
name|AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
operator|,
name|mtx_init
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|"AHCI channel lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"pm_level"
argument_list|,
operator|&
name|ch
operator|->
name|pm_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_init_mtx
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Limit speed for my onboard JMicron external port. 	 * It is not eSATA really. */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
operator|==
literal|0x2363197b
operator|&&
name|pci_get_subvendor
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
operator|==
literal|0x1043
operator|&&
name|pci_get_subdevice
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
operator|==
literal|0x81e4
operator|&&
name|ch
operator|->
name|unit
operator|==
literal|0
condition|)
name|ch
operator|->
name|sata_rev
operator|=
literal|1
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sata_rev"
argument_list|,
operator|&
name|ch
operator|->
name|sata_rev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ch
operator|->
name|unit
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ahci_dmainit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_slotsalloc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_ch_resume
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ATA_IRQ_RID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
name|ahci_ch_intr_locked
argument_list|,
name|dev
argument_list|,
operator|&
name|ch
operator|->
name|ih
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to setup interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Create the device queue for our SIM. */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ch
operator|->
name|numslots
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate simq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Construct SIM entry */
name|ch
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahciaction
argument_list|,
name|ahcipoll
argument_list|,
literal|"ahcich"
argument_list|,
name|ch
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|ch
operator|->
name|numslots
argument_list|,
literal|0
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate sim\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to register xpt bus\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ch
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create path\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|,
name|ahci_ch_pm
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err3
label|:
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|err2
label|:
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|err1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|ch
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_drain
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ch
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|ahci_ch_suspend
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_slotsfree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Disable port interrupts. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset command register. */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_stop_fr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow everything, including partial and slumber modes. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Request slumber mode transition and give some time to get there. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|AHCI_P_CMD_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Disable PHY. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_DISABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint64_t
name|work
decl_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup work areas */
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|AHCI_CL_OFFSET
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CLB
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CLBU
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FB
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBU
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
comment|/* Activate the channel and power/spin up device */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
operator|(
name|AHCI_P_CMD_ACTIVE
operator||
name|AHCI_P_CMD_POD
operator||
name|AHCI_P_CMD_SUD
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|2
operator|||
name|ch
operator|->
name|pm_level
operator|==
literal|3
operator|)
condition|?
name|AHCI_P_CMD_ALPE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|2
operator|)
condition|?
name|AHCI_P_CMD_ASP
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ahci_start_fr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|ahcich_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ahcich_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahci_ch_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahci_ch_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ahci_ch_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ahci_ch_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ahci_ch_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahcich_driver
init|=
block|{
literal|"ahcich"
block|,
name|ahcich_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_channel
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahcich
argument_list|,
name|ahci
argument_list|,
name|ahcich_driver
argument_list|,
name|ahci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ahci_dc_cb_args
block|{
name|bus_addr_t
name|maddr
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_dc_cb_args
name|dcba
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_64BIT
condition|)
name|ch
operator|->
name|dma
operator|.
name|max_address
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|ch
operator|->
name|dma
operator|.
name|max_address
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
comment|/* Command area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1024
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|max_address
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
literal|1
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
name|ahci_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* FIS receive area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|max_address
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|4096
argument_list|,
literal|1
argument_list|,
literal|4096
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
literal|4096
argument_list|,
name|ahci_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* Data area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|max_address
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AHCI_SG_ENTRIES
operator|*
name|PAGE_SIZE
operator|*
name|ch
operator|->
name|numslots
argument_list|,
name|AHCI_SG_ENTRIES
argument_list|,
name|AHCI_PRD_MAX
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return;
name|error
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING - DMA initialization failed\n"
argument_list|)
expr_stmt|;
name|ahci_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahci_dc_cb_args
modifier|*
name|dcba
init|=
operator|(
expr|struct
name|ahci_dc_cb_args
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dcba
operator|->
name|error
operator|=
name|error
operator|)
condition|)
name|dcba
operator|->
name|maddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|data_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis_map
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_map
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Alloc and setup command/dma slots */
name|bzero
argument_list|(
name|ch
operator|->
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|slot
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|slot
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|slot
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"FAILURE - create data_map\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Free all dma slots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|dma
operator|.
name|data_map
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|data_map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_phy_check_events
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|error
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|)
decl_stmt|;
comment|/* Clear error bits/interrupt */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* If we have a connection event, deal with it */
if|if
condition|(
operator|(
name|error
operator|&
name|ATA_SE_PHY_CHANGED
operator|)
operator|&&
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|)
block|{
name|u_int32_t
name|status
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_SPD_MASK
operator|)
operator|!=
name|ATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_IPM_MASK
operator|)
operator|==
name|ATA_SS_IPM_ACTIVE
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CONNECT requested\n"
argument_list|)
expr_stmt|;
name|ahci_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DISCONNECT requested\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_notify_events
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_path
modifier|*
name|dpath
decl_stmt|;
name|u_int32_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SNTF
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SNTF
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SNTF 0x%04x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|dpath
argument_list|,
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ch
operator|->
name|path
argument_list|)
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_SCSI_AEN
argument_list|,
name|dpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|dpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr_locked
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|data
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ahci_ch_intr
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|arg
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|work
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return;
name|work
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
condition|)
name|work
operator||=
name|AHCI_P_CMD_PARTIAL
expr_stmt|;
else|else
name|work
operator||=
name|AHCI_P_CMD_SLUMBER
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|device_t
name|dev
init|=
operator|(
name|device_t
operator|)
name|data
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|istatus
decl_stmt|,
name|cstatus
decl_stmt|,
name|sstatus
decl_stmt|,
name|ok
decl_stmt|,
name|err
decl_stmt|;
name|enum
name|ahci_err_type
name|et
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ccs
decl_stmt|,
name|ncq_err
init|=
literal|0
decl_stmt|;
comment|/* Read and clear interrupt statuses. */
name|istatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
expr_stmt|;
if|if
condition|(
name|istatus
operator|==
literal|0
condition|)
return|return;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
comment|/* Read command statuses. */
name|cstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
expr_stmt|;
name|sstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
expr_stmt|;
comment|/* Process PHY events */
if|if
condition|(
name|istatus
operator|&
operator|(
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_PC
operator|)
condition|)
name|ahci_phy_check_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Process command errors */
if|if
condition|(
name|istatus
operator|&
operator|(
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_TFE
operator||
name|AHCI_P_IX_OF
operator|)
condition|)
block|{
comment|//device_printf(dev, "%s ERROR is %08x cs %08x ss %08x rs %08x tfd %02x serr %08x\n",
comment|//    __func__, istatus, cstatus, sstatus, ch->rslots, ATA_INL(ch->r_mem, AHCI_P_TFD),
comment|//    ATA_INL(ch->r_mem, AHCI_P_SERR));
name|ccs
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CCS_MASK
operator|)
operator|>>
name|AHCI_P_CMD_CCS_SHIFT
expr_stmt|;
name|err
operator|=
name|ch
operator|->
name|rslots
operator|&
operator|(
name|cstatus
operator||
name|sstatus
operator|)
expr_stmt|;
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ccs
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Complete all successfull commands. */
name|ok
operator|=
name|ch
operator|->
name|rslots
operator|&
operator|~
operator|(
name|cstatus
operator||
name|sstatus
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ok
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* On error, complete the rest of commands with error statuses. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|readlog
condition|)
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|ch
operator|->
name|numrslots
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX: reqests in loading state. */
if|if
condition|(
operator|(
operator|(
name|err
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|istatus
operator|&
name|AHCI_P_IX_TFE
condition|)
block|{
comment|/* Task File Error */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|==
literal|0
condition|)
block|{
comment|/* Untagged operation. */
if|if
condition|(
name|i
operator|==
name|ccs
condition|)
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
else|else
name|et
operator|=
name|AHCI_ERR_INNOCENT
expr_stmt|;
block|}
else|else
block|{
comment|/* Tagged operation. */
name|et
operator|=
name|AHCI_ERR_NCQ
expr_stmt|;
name|ncq_err
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|istatus
operator|&
name|AHCI_P_IX_IF
condition|)
block|{
comment|/* SATA error */
name|et
operator|=
name|AHCI_ERR_SATA
expr_stmt|;
block|}
else|else
name|et
operator|=
name|AHCI_ERR_INVALID
expr_stmt|;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ncq_err
condition|)
name|ahci_issue_read_log
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Process NOTIFY events */
if|if
condition|(
operator|(
name|istatus
operator|&
name|AHCI_P_IX_SDB
operator|)
operator|&&
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
operator|)
condition|)
name|ahci_notify_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|int
name|ahci_check_collision
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
comment|/* Tagged command while untagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslots
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Tagged command while tagged to other target is active. */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|taggedtarget
operator|!=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Untagged command while tagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
operator|)
condition|)
block|{
comment|/* Atomic command while anything active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We have some atomic command running. */
if|if
condition|(
name|ch
operator|->
name|aslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_begin_transaction
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_slot
modifier|*
name|slot
decl_stmt|;
name|int
name|tag
decl_stmt|;
comment|/* Choose empty slot. */
name|tag
operator|=
name|ch
operator|->
name|lastslot
expr_stmt|;
while|while
condition|(
name|ch
operator|->
name|slot
index|[
name|tag
index|]
operator|.
name|state
operator|!=
name|AHCI_SLOT_EMPTY
condition|)
block|{
if|if
condition|(
operator|++
name|tag
operator|>=
name|ch
operator|->
name|numslots
condition|)
name|tag
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|tag
operator|!=
name|ch
operator|->
name|lastslot
argument_list|,
operator|(
literal|"ahci: ALL SLOTS BUSY!"
operator|)
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|lastslot
operator|=
name|tag
expr_stmt|;
comment|/* Occupy chosen slot. */
name|slot
operator|=
operator|&
name|ch
operator|->
name|slot
index|[
name|tag
index|]
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* Stop PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|numrslots
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ch
operator|->
name|numtslots
operator|++
expr_stmt|;
name|ch
operator|->
name|taggedtarget
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
operator|)
condition|)
name|ch
operator|->
name|aslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|nsegs
operator|=
literal|0
expr_stmt|;
comment|/* If request moves data, setup and load SG list */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|bus_size_t
name|size
decl_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_LOADING
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|buf
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
name|size
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|ccb
operator|->
name|csio
operator|.
name|data_ptr
expr_stmt|;
name|size
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
block|}
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|ahci_dmasetprd
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|ahci_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locked by busdma engine. */
end_comment

begin_function
specifier|static
name|void
name|ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|slot
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ahci_dma_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|slot
operator|->
name|dev
argument_list|,
literal|"DMA load error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|readlog
condition|)
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|AHCI_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|AHCI_SG_ENTRIES
argument_list|,
operator|(
literal|"too many DMA segment entries\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Fill S/G table */
name|prd
operator|=
operator|&
name|ctp
operator|->
name|prd_tab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|prd
index|[
name|i
index|]
operator|.
name|dba
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|dbc
operator|=
name|htole32
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
literal|1
operator|)
operator|&
name|AHCI_PRD_MASK
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|dma
operator|.
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
operator|(
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
operator|)
argument_list|)
expr_stmt|;
name|ahci_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_execute_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ahci_cmd_list
modifier|*
name|clp
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|int
name|port
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
decl_stmt|;
name|int
name|fis_size
decl_stmt|;
comment|/* Get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Setup the FIS for this request */
if|if
condition|(
operator|!
operator|(
name|fis_size
operator|=
name|ahci_setup_fis
argument_list|(
name|ctp
argument_list|,
name|ccb
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Setting up SATA FIS failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|readlog
condition|)
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|AHCI_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup the command list entry */
name|clp
operator|=
operator|(
expr|struct
name|ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CL_OFFSET
operator|+
operator|(
name|AHCI_CL_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
name|clp
operator|->
name|prd_length
operator|=
name|slot
operator|->
name|dma
operator|.
name|nsegs
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
condition|?
name|AHCI_CMD_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|?
operator|(
name|AHCI_CMD_ATAPI
operator||
name|AHCI_CMD_PREFETCH
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|fis_size
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator||
operator|(
name|port
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* Special handling for Soft Reset command. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
operator|)
condition|)
block|{
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_clo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator||=
name|AHCI_CMD_RESET
operator||
name|AHCI_CMD_CLR_BUSY
expr_stmt|;
block|}
name|clp
operator|->
name|bytecount
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|cmd_table_phys
operator|=
name|htole64
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Set ACTIVE bit for NCQ commands. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|,
literal|1
operator|<<
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* Issue command to the controller. */
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_RUNNING
expr_stmt|;
name|ch
operator|->
name|rslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|,
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
argument_list|)
expr_stmt|;
comment|/* Device reset commands doesn't interrupt. Poll them. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
operator|==
name|ATA_DEVICE_RESET
operator|||
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|,
name|timeout
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
decl_stmt|;
name|enum
name|ahci_err_type
name|et
init|=
name|AHCI_ERR_NONE
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|timeout
condition|;
name|count
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
operator|&
name|ATA_S_ERROR
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Poll error on slot %d, TFD: %04x\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|timeout
operator|&&
operator|(
name|count
operator|>=
name|timeout
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Poll timeout on slot %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
name|et
operator|=
name|AHCI_ERR_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|et
operator|!=
name|AHCI_ERR_NONE
condition|)
block|{
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|et
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Start command execution timeout */
name|callout_reset
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|(
name|int
operator|)
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
name|hz
operator|/
literal|1000
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ahci_timeout
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Locked by callout mechanism. */
end_comment

begin_function
specifier|static
name|void
name|ahci_timeout
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for stale timeout. */
if|if
condition|(
name|slot
operator|->
name|state
operator|!=
name|AHCI_SLOT_RUNNING
condition|)
return|return;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timeout on slot %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
comment|/* Kick controller into sane state. */
name|ahci_stop
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|readlog
condition|)
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|ch
operator|->
name|numrslots
argument_list|)
expr_stmt|;
comment|/* Handle command with timeout. */
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|slot
operator|->
name|slot
index|]
argument_list|,
name|AHCI_ERR_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Handle the rest of commands. */
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_end_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|ahci_err_type
name|et
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|slot
operator|->
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* Read result registers to the result struct 	 * May be incorrect if several commands finished same time, 	 * so read only when sure or have to. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|struct
name|ata_res
modifier|*
name|res
init|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|et
operator|==
name|AHCI_ERR_TFE
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_NEEDRESULT
operator|)
condition|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|+
literal|0x40
decl_stmt|;
name|uint16_t
name|tfd
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|tfd
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|tfd
operator|>>
literal|8
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|fis
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|fis
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|fis
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|fis
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|fis
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|fis
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|fis
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|fis
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|fis
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
block|}
comment|/* Set proper result status. */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|et
operator|!=
name|AHCI_ERR_NONE
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|AHCI_ERR_NONE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_INVALID
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_INNOCENT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_TFE
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_ATA_STATUS_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|AHCI_ERR_SATA
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_TIMEOUT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_NCQ
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_ATA_STATUS_ERROR
expr_stmt|;
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
comment|/* Free slot. */
name|ch
operator|->
name|rslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|aslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|numrslots
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ch
operator|->
name|numtslots
operator|--
expr_stmt|;
block|}
comment|/* If it was first request of reset sequence and there is no error, 	 * proceed to second request. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
operator|)
operator|&&
name|et
operator|==
name|AHCI_ERR_NONE
condition|)
block|{
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&=
operator|~
name|ATA_A_RESET
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it was NCQ command error, put result on hold. */
if|if
condition|(
name|et
operator|==
name|AHCI_ERR_NCQ
condition|)
block|{
name|ch
operator|->
name|hold
index|[
name|slot
operator|->
name|slot
index|]
operator|=
name|ccb
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|readlog
condition|)
comment|/* If it was our READ LOG command - process it. */
name|ahci_process_read_log
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
else|else
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* Unfreeze frozen command. */
if|if
condition|(
name|ch
operator|->
name|frozen
operator|&&
name|ch
operator|->
name|numrslots
operator|==
literal|0
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Start PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_issue_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_ataio
modifier|*
name|ataio
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|readlog
operator|=
literal|1
expr_stmt|;
comment|/* Find some holden command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
break|break;
block|}
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable allocate READ LOG command"
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX */
block|}
name|ccb
operator|->
name|ccb_h
operator|=
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
expr_stmt|;
comment|/* Reuse old header. */
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ATA_IO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|1000
expr_stmt|;
comment|/* 1s should be enough. */
name|ataio
operator|=
operator|&
name|ccb
operator|->
name|ataio
expr_stmt|;
name|ataio
operator|->
name|data_ptr
operator|=
name|malloc
argument_list|(
literal|512
argument_list|,
name|M_AHCI
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ataio
operator|->
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable allocate memory for READ LOG command"
argument_list|)
expr_stmt|;
return|return;
comment|/* XXX */
block|}
name|ataio
operator|->
name|dxfer_len
operator|=
literal|512
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ataio
operator|->
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ataio
operator|->
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|flags
operator|=
name|CAM_ATAIO_48BIT
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|command
operator|=
literal|0x2F
expr_stmt|;
comment|/* READ LOG EXT */
name|ataio
operator|->
name|cmd
operator|.
name|sector_count
operator|=
literal|1
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|sector_count_exp
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_low
operator|=
literal|0x10
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid_exp
operator|=
literal|0
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_process_read_log
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ata_res
modifier|*
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|readlog
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x1F
operator|)
operator|==
name|i
condition|)
block|{
name|res
operator|=
operator|&
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ataio
operator|.
name|res
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|data
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|data
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|data
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|data
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|data
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|data
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error while READ LOG EXT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Non-queued command error in READ LOG EXT\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
name|xpt_done
argument_list|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
argument_list|,
name|M_AHCI
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_start
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Clear any interrupts pending on this channel */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Start operations on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator||
name|AHCI_P_CMD_ST
operator||
operator|(
name|ch
operator|->
name|pm_present
condition|?
name|AHCI_P_CMD_PMA
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_stop
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Kill all activity on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator|&
operator|~
name|AHCI_P_CMD_ST
argument_list|)
expr_stmt|;
comment|/* Wait for activity stop. */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_clo
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Issue Command List Override if supported */
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SCLO
condition|)
block|{
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|AHCI_P_CMD_CLO
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"executing CLO failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CLO
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_stop_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Kill all FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator|&
operator|~
name|AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
comment|/* Wait for FIS reception stop. */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|1000
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"stopping AHCI FR engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_FR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_start_fr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
comment|/* Start FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator||
name|AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_wait_ready
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
operator|)
operator|&
operator|(
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
name|t
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"port is not ready (timeout %dms) "
literal|"tfd = %08x\n"
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ready wait time=%dms\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset...\n"
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|ch
operator|->
name|numrslots
argument_list|)
expr_stmt|;
comment|/* Requeue freezed command. */
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
name|xpt_done
argument_list|(
name|fccb
argument_list|)
expr_stmt|;
block|}
comment|/* Kill the engine and requeue all running commands. */
name|ahci_stop
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
comment|/* XXX; Commands in loading state. */
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset and reconnect PHY, */
if|if
condition|(
operator|!
name|ahci_sata_phy_reset
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset done: phy reset found no device\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
comment|/* Enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
operator|(
name|AHCI_P_IX_CPD
operator||
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_PC
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait for clearing busy status. */
if|if
condition|(
name|ahci_wait_ready
argument_list|(
name|dev
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"device ready timeout\n"
argument_list|)
expr_stmt|;
name|ahci_clo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|ahci_start
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|1
expr_stmt|;
comment|/* Enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
operator|(
name|AHCI_P_IX_CPD
operator||
name|AHCI_P_IX_TFE
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_OF
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|?
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_PC
else|:
literal|0
operator|)
operator||
name|AHCI_P_IX_DP
operator||
name|AHCI_P_IX_UF
operator||
operator|(
name|ctlr
operator|->
name|ccc
condition|?
literal|0
else|:
name|AHCI_P_IX_SDB
operator|)
operator||
name|AHCI_P_IX_DS
operator||
name|AHCI_P_IX_PS
operator||
operator|(
name|ctlr
operator|->
name|ccc
condition|?
literal|0
else|:
name|AHCI_P_IX_DHR
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI reset done: device found\n"
argument_list|)
expr_stmt|;
comment|/* Tell the XPT about the event */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_fis
parameter_list|(
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
operator|&
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
decl_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|cfis
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|fis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|fis
index|[
literal|1
index|]
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ATA_PACKET_CMD
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
name|fis
index|[
literal|3
index|]
operator|=
name|ATA_F_DMA
expr_stmt|;
else|else
block|{
name|fis
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>>
literal|8
expr_stmt|;
block|}
name|fis
index|[
literal|7
index|]
operator|=
name|ATA_D_LBA
expr_stmt|;
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|acmd
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|ctp
operator|->
name|acmd
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|==
literal|0
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
expr_stmt|;
name|fis
index|[
literal|3
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features
expr_stmt|;
name|fis
index|[
literal|4
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low
expr_stmt|;
name|fis
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high
expr_stmt|;
name|fis
index|[
literal|7
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|device
expr_stmt|;
name|fis
index|[
literal|8
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low_exp
expr_stmt|;
name|fis
index|[
literal|9
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid_exp
expr_stmt|;
name|fis
index|[
literal|10
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high_exp
expr_stmt|;
name|fis
index|[
literal|11
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features_exp
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|fis
index|[
literal|12
index|]
operator|=
name|tag
operator|<<
literal|3
expr_stmt|;
name|fis
index|[
literal|13
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fis
index|[
literal|12
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count
expr_stmt|;
name|fis
index|[
literal|13
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count_exp
expr_stmt|;
block|}
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
block|}
else|else
block|{
name|fis
index|[
literal|15
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
expr_stmt|;
block|}
return|return
operator|(
literal|20
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_sata_connect
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Wait up to 100ms for "connect well" */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|100
condition|;
name|timeout
operator|++
control|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_SPD_MASK
operator|)
operator|!=
name|ATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_IPM_MASK
operator|)
operator|==
name|ATA_SS_IPM_ACTIVE
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_OFFLINE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA offline status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>=
literal|100
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect timeout status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect time=%dms status=%08x\n"
argument_list|,
name|timeout
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_sata_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|quick
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|quick
condition|)
block|{
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|ATA_SC_DET_MASK
operator|)
operator|==
name|ATA_SC_DET_IDLE
condition|)
return|return
operator|(
name|ahci_sata_connect
argument_list|(
name|ch
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"hardware reset ...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sata_rev
operator|==
literal|1
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN1
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|sata_rev
operator|==
literal|2
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN2
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|sata_rev
operator|==
literal|3
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN3
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_RESET
operator||
name|val
operator||
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_IDLE
operator||
name|val
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
return|return
operator|(
name|ahci_sata_connect
argument_list|(
name|ch
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahciaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahciaction func_code=%x\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ch
operator|->
name|dev
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ATA_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
name|ch
operator|->
name|devices
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Check for command collision. */
if|if
condition|(
name|ahci_check_collision
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
comment|/* Freeze command. */
name|ch
operator|->
name|frozen
operator|=
name|ccb
expr_stmt|;
comment|/* We have only one frozen slot, so freeze simq also. */
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahci_begin_transaction
argument_list|(
name|dev
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_EN_LUN
case|:
comment|/* Enable LUN as a target */
case|case
name|XPT_TARGET_IO
case|:
comment|/* Execute target I/O request */
case|case
name|XPT_ACCEPT_TARGET_IO
case|:
comment|/* Accept Host Target Mode CDB */
case|case
name|XPT_CONT_TARGET_IO
case|:
comment|/* Continue Host Target I/O Connection*/
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_PM
condition|)
block|{
name|ch
operator|->
name|pm_present
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
operator|&
name|ATA_SS_SPD_MASK
expr_stmt|;
else|else
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|)
operator|&
name|ATA_SC_SPD_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ATA_SS_SPD_GEN3
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bitrate
operator|=
literal|600000
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_SPEED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|ATA_SS_SPD_GEN2
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bitrate
operator|=
literal|300000
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_SPEED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|ATA_SS_SPD_GEN1
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bitrate
operator|=
literal|150000
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_SPEED
expr_stmt|;
block|}
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_PMA
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
operator|=
name|ch
operator|->
name|pm_present
expr_stmt|;
block|}
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_PM
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|case XPT_CALC_GEOMETRY: 	{ 		struct	  ccb_calc_geometry *ccg; 		uint32_t size_mb; 		uint32_t secs_per_cylinder;  		ccg =&ccb->ccg; 		size_mb = ccg->volume_size 			/ ((1024L * 1024L) / ccg->block_size); 		if (size_mb>= 1024&& (aha->extended_trans != 0)) { 			if (size_mb>= 2048) { 				ccg->heads = 255; 				ccg->secs_per_track = 63; 			} else { 				ccg->heads = 128; 				ccg->secs_per_track = 32; 			} 		} else { 			ccg->heads = 64; 			ccg->secs_per_track = 32; 		} 		secs_per_cylinder = ccg->heads * ccg->secs_per_track; 		ccg->cylinders = ccg->volume_size / secs_per_cylinder; 		ccb->ccb_h.status = CAM_REQ_CMP; 		xpt_done(ccb); 		break; 	}
endif|#
directive|endif
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
name|ahci_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
operator||
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_SATAPM
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_SEQSCAN
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
condition|)
name|cpi
operator|->
name|max_target
operator|=
literal|14
expr_stmt|;
else|else
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"AHCI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
comment|/* ATI SB600 can't handle 256 sectors with FPDMA (NCQ). */
if|if
condition|(
name|pci_get_devid
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|==
literal|0x43801002
condition|)
name|cpi
operator|->
name|maxio
operator|=
name|min
argument_list|(
name|cpi
operator|->
name|maxio
argument_list|,
literal|255
operator|*
literal|512
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahcipoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|ahci_ch_intr
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

