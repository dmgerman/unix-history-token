begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2012 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|"ahci.h"
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_xpt_sim.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_comment
comment|/* local prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|ahci_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_intr_one
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_intr_one_edge
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_deinit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr_direct
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_ch_intr_main
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|istatus
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_begin_transaction
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_execute_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_timeout
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_end_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|ahci_err_type
name|et
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_setup_fis
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_reset
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_start
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|int
name|fbs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_stop
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_clo
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_start_fr
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_stop_fr
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_sata_connect
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_sata_phy_reset
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ahci_wait_ready
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|t0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_issue_recovery
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_process_read_log
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahci_process_request_sense
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahciaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ahcipoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_AHCI
argument_list|,
literal|"AHCI driver"
argument_list|,
literal|"AHCI driver data buffers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|recovery_type
value|spriv_field0
end_define

begin_define
define|#
directive|define
name|RECOVERY_NONE
value|0
end_define

begin_define
define|#
directive|define
name|RECOVERY_READ_LOG
value|1
end_define

begin_define
define|#
directive|define
name|RECOVERY_REQUEST_SENSE
value|2
end_define

begin_define
define|#
directive|define
name|recovery_slot
value|spriv_field1
end_define

begin_function
name|int
name|ahci_ctlr_setup
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Clear interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure CCC */
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCP
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCC
argument_list|,
operator|(
name|ctlr
operator|->
name|ccc
operator|<<
name|AHCI_CCCC_TV_SHIFT
operator|)
operator||
operator|(
literal|4
operator|<<
name|AHCI_CCCC_CC_SHIFT
operator|)
operator||
name|AHCI_CCCC_EN
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|cccv
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CCCC
argument_list|)
operator|&
name|AHCI_CCCC_INT_MASK
operator|)
operator|>>
name|AHCI_CCCC_INT_SHIFT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CCC with %dms/4cmd enabled on vector %d\n"
argument_list|,
name|ctlr
operator|->
name|ccc
argument_list|,
name|ctlr
operator|->
name|cccv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable AHCI interrupts */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator||
name|AHCI_GHC_IE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_ctlr_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Enable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
argument_list|)
expr_stmt|;
comment|/* Reset AHCI controller */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
operator||
name|AHCI_GHC_HR
argument_list|)
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|1000
init|;
name|timeout
operator|>
literal|0
condition|;
name|timeout
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
name|AHCI_GHC_HR
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI controller reset failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Reenable AHCI mode */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|,
name|AHCI_GHC_AE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_RESTORE_CAP
condition|)
block|{
comment|/* 		 * Restore capability field. 		 * This is write to a read-only register to restore its state. 		 * On fully standard-compliant hardware this is not needed and 		 * this operation shall not take place. See ahci_pci.c for 		 * platforms using this quirk. 		 */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|,
name|ctlr
operator|->
name|caps
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|speed
decl_stmt|,
name|unit
decl_stmt|;
name|uint32_t
name|u
decl_stmt|,
name|version
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|ctlr
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ctlr
operator|->
name|ccc
operator|=
literal|0
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"ccc"
argument_list|,
operator|&
name|ctlr
operator|->
name|ccc
argument_list|)
expr_stmt|;
comment|/* Setup our own memory management for channels. */
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_start
operator|=
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_end
operator|=
name|rman_get_end
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|ctlr
operator|->
name|sc_iomem
operator|.
name|rm_descr
operator|=
literal|"I/O memory addresses"
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rman_init
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahci_free_mem
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|rman_manage_region
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|,
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
argument_list|,
name|rman_get_end
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahci_free_mem
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get the HW capabilities */
name|version
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_VS
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|caps
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
literal|0x00010200
condition|)
name|ctlr
operator|->
name|caps2
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_EMS
condition|)
name|ctlr
operator|->
name|capsem
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_EM_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_FORCE_PI
condition|)
block|{
comment|/* 		 * Enable ports.  		 * The spec says that BIOS sets up bits corresponding to 		 * available ports. On platforms where this information 		 * is missing, the driver can define available ports on its own. 		 */
name|int
name|nports
init|=
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
decl_stmt|;
name|int
name|nmask
init|=
operator|(
literal|1
operator|<<
name|nports
operator|)
operator|-
literal|1
decl_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|,
name|nmask
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Forcing PI to %d ports (mask = %x)\n"
argument_list|,
name|nports
argument_list|,
name|nmask
argument_list|)
expr_stmt|;
block|}
name|ctlr
operator|->
name|ichannels
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
expr_stmt|;
comment|/* Identify and set separate quirks for HBA and RAID f/w Marvells. */
if|if
condition|(
operator|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_ALTSIG
operator|)
operator|&&
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
operator|==
literal|0
condition|)
name|ctlr
operator|->
name|quirks
operator||=
name|AHCI_Q_NOBSYRES
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_1CH
condition|)
block|{
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_NPMASK
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|&=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_2CH
condition|)
block|{
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_NPMASK
expr_stmt|;
name|ctlr
operator|->
name|caps
operator||=
literal|1
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|&=
literal|0x03
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_4CH
condition|)
block|{
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_NPMASK
expr_stmt|;
name|ctlr
operator|->
name|caps
operator||=
literal|3
expr_stmt|;
name|ctlr
operator|->
name|ichannels
operator|&=
literal|0x0f
expr_stmt|;
block|}
name|ctlr
operator|->
name|channels
operator|=
name|MAX
argument_list|(
name|flsl
argument_list|(
name|ctlr
operator|->
name|ichannels
argument_list|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_NOPMP
condition|)
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_SPM
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_NONCQ
condition|)
name|ctlr
operator|->
name|caps
operator|&=
operator|~
name|AHCI_CAP_SNCQ
expr_stmt|;
if|if
condition|(
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_CCCS
operator|)
operator|==
literal|0
condition|)
name|ctlr
operator|->
name|ccc
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|emloc
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_EM_LOC
argument_list|)
expr_stmt|;
comment|/* Create controller-wide DMA tag. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_64BIT
operator|)
condition|?
name|BUS_SPACE_MAXADDR
else|:
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|BUS_SPACE_UNRESTRICTED
argument_list|,
name|BUS_SPACE_MAXSIZE
argument_list|,
name|ctlr
operator|->
name|dma_coherent
condition|?
name|BUS_DMA_COHERENT
else|:
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctlr
operator|->
name|dma_tag
argument_list|)
condition|)
block|{
name|ahci_free_mem
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ahci_ctlr_setup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Setup interrupts. */
if|if
condition|(
operator|(
name|error
operator|=
name|ahci_setup_interrupt
argument_list|(
name|dev
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ctlr
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|ahci_free_mem
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
name|ctlr
operator|->
name|ichannels
init|;
name|u
operator|!=
literal|0
condition|;
name|u
operator|>>=
literal|1
control|)
name|i
operator|+=
operator|(
name|u
operator|&
literal|1
operator|)
expr_stmt|;
name|ctlr
operator|->
name|direct
operator|=
operator|(
name|ctlr
operator|->
name|msi
operator|&&
operator|(
name|ctlr
operator|->
name|numirqs
operator|>
literal|1
operator|||
name|i
operator|<=
literal|3
operator|)
operator|)
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"direct"
argument_list|,
operator|&
name|ctlr
operator|->
name|direct
argument_list|)
expr_stmt|;
comment|/* Announce HW capabilities. */
name|speed
operator|=
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_ISS
operator|)
operator|>>
name|AHCI_CAP_ISS_SHIFT
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHCI v%x.%02x with %d %sGbps ports, Port Multiplier %s%s\n"
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|20
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
operator|(
name|version
operator|>>
literal|16
operator|)
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
operator|(
name|version
operator|>>
literal|4
operator|)
operator|&
literal|0xf0
operator|)
operator|+
operator|(
name|version
operator|&
literal|0x0f
operator|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|"supported"
else|:
literal|"not supported"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_FBSS
operator|)
condition|?
literal|" with FBS"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"quirks=0x%b\n"
argument_list|,
name|ctlr
operator|->
name|quirks
argument_list|,
name|AHCI_Q_BIT_STRING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps:%s%s%s%s%s%s%s%s %sGbps"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_64BIT
operator|)
condition|?
literal|" 64bit"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
operator|)
condition|?
literal|" NCQ"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
operator|)
condition|?
literal|" SNTF"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SMPS
operator|)
condition|?
literal|" MPS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSS
operator|)
condition|?
literal|" SS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SALP
operator|)
condition|?
literal|" ALP"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SAL
operator|)
condition|?
literal|" AL"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SCLO
operator|)
condition|?
literal|" CLO"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|speed
operator|==
literal|1
operator|)
condition|?
literal|"1.5"
else|:
operator|(
operator|(
name|speed
operator|==
literal|2
operator|)
condition|?
literal|"3"
else|:
operator|(
operator|(
name|speed
operator|==
literal|3
operator|)
condition|?
literal|"6"
else|:
literal|"?"
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s%s%s%s%s %dcmd%s%s%s %dports\n"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SAM
operator|)
condition|?
literal|" AM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|" PM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_FBSS
operator|)
condition|?
literal|" FBS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_PMD
operator|)
condition|?
literal|" PMD"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SSC
operator|)
condition|?
literal|" SSC"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_PSC
operator|)
condition|?
literal|" PSC"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NCS
operator|)
operator|>>
name|AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_CCCS
operator|)
condition|?
literal|" CCC"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_EMS
operator|)
condition|?
literal|" EM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_SXS
operator|)
condition|?
literal|" eSATA"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_NPMASK
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|version
operator|>=
literal|0x00010200
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps2:%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_DESO
operator|)
condition|?
literal|" DESO"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_SADM
operator|)
condition|?
literal|" SADM"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_SDS
operator|)
condition|?
literal|" SDS"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_APST
operator|)
condition|?
literal|" APST"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_NVMP
operator|)
condition|?
literal|" NVMP"
else|:
literal|""
argument_list|,
operator|(
name|ctlr
operator|->
name|caps2
operator|&
name|AHCI_CAP2_BOH
operator|)
condition|?
literal|" BOH"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
comment|/* Attach all channels on this controller */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|ctlr
operator|->
name|channels
condition|;
name|unit
operator|++
control|)
block|{
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ahcich"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add channel device\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctlr
operator|->
name|ichannels
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|==
literal|0
condition|)
name|device_disable
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_EMS
condition|)
block|{
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ahciem"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add enclosure device\n"
argument_list|)
expr_stmt|;
else|else
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Detach& delete all children */
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Free interrupts. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlr
operator|->
name|numirqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|)
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|ctlr
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
comment|/* Free memory. */
name|rman_fini
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|)
expr_stmt|;
name|ahci_free_mem
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahci_free_mem
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Release memory resources */
if|if
condition|(
name|ctlr
operator|->
name|r_mem
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|r_msix_table
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_msix_tab_rid
argument_list|,
name|ctlr
operator|->
name|r_msix_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|r_msix_pba
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_msix_pba_rid
argument_list|,
name|ctlr
operator|->
name|r_msix_pba
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|r_msix_pba
operator|=
name|ctlr
operator|->
name|r_mem
operator|=
name|ctlr
operator|->
name|r_msix_table
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ahci_setup_interrupt
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for single MSI vector fallback. */
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|>
literal|1
operator|&&
operator|(
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_GHC
argument_list|)
operator|&
name|AHCI_GHC_MRSM
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Falling back to one MSI\n"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ensure we don't overrun irqs. */
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|>
name|AHCI_MAX_IRQS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Too many irqs %d> %d (clamping)\n"
argument_list|,
name|ctlr
operator|->
name|numirqs
argument_list|,
name|AHCI_MAX_IRQS
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
name|AHCI_MAX_IRQS
expr_stmt|;
block|}
comment|/* Allocate all IRQs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctlr
operator|->
name|numirqs
condition|;
name|i
operator|++
control|)
block|{
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
operator|=
name|i
operator|+
operator|(
name|ctlr
operator|->
name|msi
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|channels
operator|==
literal|1
operator|&&
operator|!
name|ctlr
operator|->
name|ccc
operator|&&
name|ctlr
operator|->
name|msi
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ONE
expr_stmt|;
elseif|else
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|==
literal|1
operator|||
name|i
operator|>=
name|ctlr
operator|->
name|channels
operator|||
operator|(
name|ctlr
operator|->
name|ccc
operator|&&
name|i
operator|==
name|ctlr
operator|->
name|cccv
operator|)
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ALL
expr_stmt|;
elseif|else
if|if
condition|(
name|ctlr
operator|->
name|channels
operator|>
name|ctlr
operator|->
name|numirqs
operator|&&
name|i
operator|==
name|ctlr
operator|->
name|numirqs
operator|-
literal|1
condition|)
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_AFTER
expr_stmt|;
else|else
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|AHCI_IRQ_MODE_ONE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq_rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to map interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
operator|(
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|!=
name|AHCI_IRQ_MODE_ONE
operator|)
condition|?
name|ahci_intr
else|:
operator|(
operator|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_EDGEIS
operator|)
condition|?
name|ahci_intr_one_edge
else|:
name|ahci_intr_one
operator|)
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
argument_list|,
operator|&
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|)
operator|)
condition|)
block|{
comment|/* SOS XXX release r_irq */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to setup interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ctlr
operator|->
name|numirqs
operator|>
literal|1
condition|)
block|{
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|r_irq
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|handle
argument_list|,
name|ctlr
operator|->
name|irqs
index|[
name|i
index|]
operator|.
name|mode
operator|==
name|AHCI_IRQ_MODE_ONE
condition|?
literal|"ch%d"
else|:
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common case interrupt handler.  */
end_comment

begin_function
specifier|static
name|void
name|ahci_intr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|u_int32_t
name|is
decl_stmt|,
name|ise
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
if|if
condition|(
name|irq
operator|->
name|mode
operator|==
name|AHCI_IRQ_MODE_ALL
condition|)
block|{
name|unit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
name|is
operator|=
name|ctlr
operator|->
name|ichannels
expr_stmt|;
else|else
name|is
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* AHCI_IRQ_MODE_AFTER */
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
name|is
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
name|is
operator|&=
operator|(
literal|0xffffffff
operator|<<
name|unit
operator|)
expr_stmt|;
block|}
comment|/* CCC interrupt is edge triggered. */
if|if
condition|(
name|ctlr
operator|->
name|ccc
condition|)
name|ise
operator|=
literal|1
operator|<<
name|ctlr
operator|->
name|cccv
expr_stmt|;
comment|/* Some controllers have edge triggered IS. */
if|if
condition|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_EDGEIS
condition|)
name|ise
operator||=
name|is
expr_stmt|;
if|if
condition|(
name|ise
operator|!=
literal|0
condition|)
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
name|ise
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|unit
operator|<
name|ctlr
operator|->
name|channels
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|is
operator|&
operator|(
literal|1
operator|<<
name|unit
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
block|{
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* AHCI declares level triggered IS. */
if|if
condition|(
operator|!
operator|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_EDGEIS
operator|)
condition|)
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
name|is
argument_list|)
expr_stmt|;
name|ATA_RBL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simplified interrupt handler for multivector MSI mode.  */
end_comment

begin_function
specifier|static
name|void
name|ahci_intr_one
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* AHCI declares level triggered IS. */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
literal|1
operator|<<
name|unit
argument_list|)
expr_stmt|;
name|ATA_RBL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_intr_one_edge
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ahci_controller_irq
modifier|*
name|irq
init|=
name|data
decl_stmt|;
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|irq
operator|->
name|ctlr
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|irq
operator|->
name|r_irq_rid
operator|-
literal|1
expr_stmt|;
comment|/* Some controllers have edge triggered IS. */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|,
literal|1
operator|<<
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|)
condition|)
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ATA_RBL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_IS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|ahci_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|rman_res_t
name|st
decl_stmt|;
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|unit
decl_stmt|;
name|unit
operator|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|res
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
name|offset
operator|=
name|AHCI_OFFSET
operator|+
operator|(
name|unit
operator|<<
literal|7
operator|)
expr_stmt|;
name|size
operator|=
literal|128
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|AHCI_EM_CTL
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
operator|(
name|ctlr
operator|->
name|emloc
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|14
expr_stmt|;
name|size
operator|=
operator|(
name|ctlr
operator|->
name|emloc
operator|&
literal|0x0000ffff
operator|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|rid
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|rid
operator|==
literal|2
operator|&&
operator|(
name|ctlr
operator|->
name|capsem
operator|&
operator|(
name|AHCI_EM_XMT
operator||
name|AHCI_EM_SMB
operator|)
operator|)
operator|==
literal|0
condition|)
name|offset
operator|+=
name|size
expr_stmt|;
else|else
break|break;
block|}
block|}
name|st
operator|=
name|rman_get_start
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|res
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|ctlr
operator|->
name|sc_iomem
argument_list|,
name|st
operator|+
name|offset
argument_list|,
name|st
operator|+
name|offset
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
argument_list|,
name|RF_ACTIVE
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|bus_space_subregion
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|offset
argument_list|,
literal|128
argument_list|,
operator|&
name|bsh
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|res
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|res
argument_list|,
name|bst
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
operator|*
name|rid
operator|==
name|ATA_IRQ_RID
condition|)
name|res
operator|=
name|ctlr
operator|->
name|irqs
index|[
literal|0
index|]
operator|.
name|r_irq
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
name|rman_release_resource
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SYS_RES_IRQ
case|:
if|if
condition|(
name|rid
operator|!=
name|ATA_IRQ_RID
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|driver_intr_t
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|argument
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
if|if
condition|(
name|filter
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ahci.c: we cannot use a filter here\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
operator|=
name|function
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|=
name|argument
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|function
operator|=
name|NULL
expr_stmt|;
name|ctlr
operator|->
name|interrupt
index|[
name|unit
index|]
operator|.
name|argument
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|channel
decl_stmt|;
name|retval
operator|=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|channel
operator|=
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
literal|0
condition|)
name|retval
operator|+=
name|printf
argument_list|(
literal|" at channel %d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|bus_print_child_footer
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ahci_child_location_str
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|channel
decl_stmt|;
name|channel
operator|=
operator|(
name|int
operator|)
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|>=
literal|0
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
literal|"channel=%d"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bus_dma_tag_t
name|ahci_get_dma_tag
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|ctlr
operator|->
name|dma_tag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"AHCI channel"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cam_devq
modifier|*
name|devq
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sata_rev
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|version
decl_stmt|;
name|ch
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ch
operator|->
name|unit
operator|=
operator|(
name|intptr_t
operator|)
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ch
operator|->
name|caps
operator|=
name|ctlr
operator|->
name|caps
expr_stmt|;
name|ch
operator|->
name|caps2
operator|=
name|ctlr
operator|->
name|caps2
expr_stmt|;
name|ch
operator|->
name|start
operator|=
name|ctlr
operator|->
name|ch_start
expr_stmt|;
name|ch
operator|->
name|quirks
operator|=
name|ctlr
operator|->
name|quirks
expr_stmt|;
name|ch
operator|->
name|vendorid
operator|=
name|ctlr
operator|->
name|vendorid
expr_stmt|;
name|ch
operator|->
name|deviceid
operator|=
name|ctlr
operator|->
name|deviceid
expr_stmt|;
name|ch
operator|->
name|subvendorid
operator|=
name|ctlr
operator|->
name|subvendorid
expr_stmt|;
name|ch
operator|->
name|subdeviceid
operator|=
name|ctlr
operator|->
name|subdeviceid
expr_stmt|;
name|ch
operator|->
name|numslots
operator|=
operator|(
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_NCS
operator|)
operator|>>
name|AHCI_CAP_NCS_SHIFT
operator|)
operator|+
literal|1
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|"AHCI channel lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ch
operator|->
name|pm_level
operator|=
literal|0
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"pm_level"
argument_list|,
operator|&
name|ch
operator|->
name|pm_level
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ch
operator|->
name|doneq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_init_mtx
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* JMicron external ports (0) sometimes limited */
if|if
condition|(
operator|(
name|ctlr
operator|->
name|quirks
operator|&
name|AHCI_Q_SATA1_UNIT0
operator|)
operator|&&
name|ch
operator|->
name|unit
operator|==
literal|0
condition|)
name|sata_rev
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_SATA2
condition|)
name|sata_rev
operator|=
literal|2
expr_stmt|;
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"sata_rev"
argument_list|,
operator|&
name|sata_rev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|revision
operator|=
name|sata_rev
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|bytecount
operator|=
literal|8192
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|tags
operator|=
name|ch
operator|->
name|numslots
expr_stmt|;
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|caps
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|curr
index|[
name|i
index|]
operator|=
name|ch
operator|->
name|user
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
condition|)
block|{
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|caps
operator|=
name|CTS_SATA_CAPS_H_PMREQ
operator||
name|CTS_SATA_CAPS_H_APST
operator||
name|CTS_SATA_CAPS_D_PMREQ
operator||
name|CTS_SATA_CAPS_D_APST
expr_stmt|;
block|}
name|ch
operator|->
name|user
index|[
name|i
index|]
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_DMAAA
operator||
name|CTS_SATA_CAPS_H_AN
expr_stmt|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ch
operator|->
name|chcaps
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|version
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_VS
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
literal|0x00010200
operator|&&
operator|(
name|ctlr
operator|->
name|caps
operator|&
name|AHCI_CAP_FBSS
operator|)
condition|)
name|ch
operator|->
name|chcaps
operator||=
name|AHCI_P_CMD_FBSCP
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps2
operator|&
name|AHCI_CAP2_SDS
condition|)
name|ch
operator|->
name|chscaps
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_DEVSLP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Caps:%s%s%s%s%s%s\n"
argument_list|,
operator|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_HPCP
operator|)
condition|?
literal|" HPCP"
else|:
literal|""
argument_list|,
operator|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_MPSP
operator|)
condition|?
literal|" MPSP"
else|:
literal|""
argument_list|,
operator|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_CPD
operator|)
condition|?
literal|" CPD"
else|:
literal|""
argument_list|,
operator|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_ESP
operator|)
condition|?
literal|" ESP"
else|:
literal|""
argument_list|,
operator|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_FBSCP
operator|)
condition|?
literal|" FBSCP"
else|:
literal|""
argument_list|,
operator|(
name|ch
operator|->
name|chscaps
operator|&
name|AHCI_P_DEVSLP_DSP
operator|)
condition|?
literal|" DSP"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|ahci_dmainit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_slotsalloc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ahci_ch_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ATA_IRQ_RID
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|r_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err0
goto|;
block|}
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ATA_INTR_FLAGS
argument_list|,
name|NULL
argument_list|,
name|ctlr
operator|->
name|direct
condition|?
name|ahci_ch_intr_direct
else|:
name|ahci_ch_intr
argument_list|,
name|ch
argument_list|,
operator|&
name|ch
operator|->
name|ih
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to setup interrupt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Create the device queue for our SIM. */
name|devq
operator|=
name|cam_simq_alloc
argument_list|(
name|ch
operator|->
name|numslots
argument_list|)
expr_stmt|;
if|if
condition|(
name|devq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate simq\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* Construct SIM entry */
name|ch
operator|->
name|sim
operator|=
name|cam_sim_alloc
argument_list|(
name|ahciaction
argument_list|,
name|ahcipoll
argument_list|,
literal|"ahcich"
argument_list|,
name|ch
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
expr|struct
name|mtx
operator|*
operator|)
operator|&
name|ch
operator|->
name|mtx
argument_list|,
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOCCS
operator|)
condition|?
literal|1
else|:
name|min
argument_list|(
literal|2
argument_list|,
name|ch
operator|->
name|numslots
argument_list|)
argument_list|,
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
operator|)
condition|?
name|ch
operator|->
name|numslots
else|:
literal|0
argument_list|,
name|devq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|sim
operator|==
name|NULL
condition|)
block|{
name|cam_simq_free
argument_list|(
name|devq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to allocate sim\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
if|if
condition|(
name|xpt_bus_register
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|!=
name|CAM_SUCCESS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to register xpt bus\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ch
operator|->
name|path
argument_list|,
comment|/*periph*/
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unable to create path\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|,
name|ahci_ch_pm
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err3
label|:
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|err2
label|:
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|err1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|err0
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_async
argument_list|(
name|AC_LOST_DEVICE
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Forget about reset. */
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|xpt_free_path
argument_list|(
name|ch
operator|->
name|path
argument_list|)
expr_stmt|;
name|xpt_bus_deregister
argument_list|(
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|)
expr_stmt|;
name|cam_sim_free
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
comment|/*free_devq*/
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_drain
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|,
name|ch
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|ATA_IRQ_RID
argument_list|,
name|ch
operator|->
name|r_irq
argument_list|)
expr_stmt|;
name|ahci_ch_deinit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_slotsfree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ch
operator|->
name|unit
argument_list|,
name|ch
operator|->
name|r_mem
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint64_t
name|work
decl_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup work areas */
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|AHCI_CL_OFFSET
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CLB
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CLBU
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|work
operator|=
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FB
argument_list|,
name|work
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBU
argument_list|,
name|work
operator|>>
literal|32
argument_list|)
expr_stmt|;
comment|/* Activate the channel and power/spin up device */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
operator|(
name|AHCI_P_CMD_ACTIVE
operator||
name|AHCI_P_CMD_POD
operator||
name|AHCI_P_CMD_SUD
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|2
operator|||
name|ch
operator|->
name|pm_level
operator|==
literal|3
operator|)
condition|?
name|AHCI_P_CMD_ALPE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|2
operator|)
condition|?
name|AHCI_P_CMD_ASP
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ahci_start_fr
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_deinit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Disable port interrupts. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset command register. */
name|ahci_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_stop_fr
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allow everything, including partial and slumber modes. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Request slumber mode transition and give some time to get there. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|AHCI_P_CMD_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Disable PHY. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_DISABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Forget about reset. */
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ch
operator|->
name|oslots
condition|)
name|msleep
argument_list|(
name|ch
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahcisusp"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|ahci_ch_deinit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_ch_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ahci_ch_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ahci_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|devclass_t
name|ahcich_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ahcich_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ahci_ch_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ahci_ch_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ahci_ch_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ahci_ch_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ahci_ch_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahcich_driver
init|=
block|{
literal|"ahcich"
block|,
name|ahcich_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_channel
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahcich
argument_list|,
name|ahci
argument_list|,
name|ahcich_driver
argument_list|,
name|ahcich_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ahci_dc_cb_args
block|{
name|bus_addr_t
name|maddr
decl_stmt|;
name|int
name|error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|ahci_dmainit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ahci_dc_cb_args
name|dcba
decl_stmt|;
name|size_t
name|rfsize
decl_stmt|;
comment|/* Command area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1024
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
literal|1
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|AHCI_WORK_SIZE
argument_list|,
name|ahci_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* FIS receive area. */
if|if
condition|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_FBSCP
condition|)
name|rfsize
operator|=
literal|4096
expr_stmt|;
else|else
name|rfsize
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
name|rfsize
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rfsize
argument_list|,
literal|1
argument_list|,
name|rfsize
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
literal|0
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|rfsize
argument_list|,
name|ahci_dmasetupc_cb
argument_list|,
operator|&
name|dcba
argument_list|,
literal|0
argument_list|)
operator|||
name|dcba
operator|.
name|error
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
operator|=
name|dcba
operator|.
name|maddr
expr_stmt|;
comment|/* Data area. */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|AHCI_SG_ENTRIES
operator|*
name|PAGE_SIZE
operator|*
name|ch
operator|->
name|numslots
argument_list|,
name|AHCI_SG_ENTRIES
argument_list|,
name|AHCI_PRD_MAX
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
operator|&
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
return|return;
name|error
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING - DMA initialization failed\n"
argument_list|)
expr_stmt|;
name|ahci_dmafini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_dmasetupc_cb
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahci_dc_cb_args
modifier|*
name|dcba
init|=
operator|(
expr|struct
name|ahci_dc_cb_args
operator|*
operator|)
name|xsc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dcba
operator|->
name|error
operator|=
name|error
operator|)
condition|)
name|dcba
operator|->
name|maddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_dmafini
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|data_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|)
expr_stmt|;
name|ch
operator|->
name|dma
operator|.
name|work_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_slotsalloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Alloc and setup command/dma slots */
name|bzero
argument_list|(
name|ch
operator|->
name|slot
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|->
name|slot
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|slot
operator|->
name|ch
operator|=
name|ch
expr_stmt|;
name|slot
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
operator|&
name|ch
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"FAILURE - create data_map\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_slotsfree
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Free all dma slots */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|dma
operator|.
name|data_map
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
name|slot
operator|->
name|dma
operator|.
name|data_map
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_phy_check_events
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|u_int32_t
name|serr
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
operator|&&
operator|(
name|serr
operator|&
name|ATA_SE_PHY_CHANGED
operator|)
operator|)
operator|||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|!=
literal|0
operator|||
name|ch
operator|->
name|listening
operator|)
operator|&&
operator|(
name|serr
operator|&
name|ATA_SE_EXCHANGED
operator|)
operator|)
condition|)
block|{
name|u_int32_t
name|status
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|!=
name|ATA_SS_DET_NO_DEVICE
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"CONNECT requested\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"DISCONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
name|ahci_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_cpd_check_events
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
condition|)
return|return;
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|AHCI_P_CMD_CPD
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|dev
operator|=
name|ch
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AHCI_P_CMD_CPS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"COLD CONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"COLD DISCONNECT requested\n"
argument_list|)
expr_stmt|;
block|}
name|ahci_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|NULL
argument_list|,
name|cam_sim_path
argument_list|(
name|ch
operator|->
name|sim
argument_list|)
argument_list|,
name|CAM_TARGET_WILDCARD
argument_list|,
name|CAM_LUN_WILDCARD
argument_list|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|xpt_rescan
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_notify_events
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|u_int32_t
name|status
parameter_list|)
block|{
name|struct
name|cam_path
modifier|*
name|dpath
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
condition|)
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SNTF
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SNTF 0x%04x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|xpt_create_path
argument_list|(
operator|&
name|dpath
argument_list|,
name|NULL
argument_list|,
name|xpt_path_path_id
argument_list|(
name|ch
operator|->
name|path
argument_list|)
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|xpt_async
argument_list|(
name|AC_SCSI_AEN
argument_list|,
name|dpath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xpt_free_path
argument_list|(
name|dpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_done
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|&
name|XPT_FC_QUEUED
operator|)
operator|==
literal|0
operator|||
name|ch
operator|->
name|batch
operator|==
literal|0
condition|)
block|{
name|xpt_done
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ch
operator|->
name|doneq
argument_list|,
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|istatus
decl_stmt|;
comment|/* Read interrupt statuses. */
name|istatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ahci_ch_intr_main
argument_list|(
name|ch
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr_direct
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ccb_hdr
modifier|*
name|ccb_h
decl_stmt|;
name|uint32_t
name|istatus
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ccb_hdr
argument_list|)
name|tmp_doneq
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|tmp_doneq
argument_list|)
expr_stmt|;
comment|/* Read interrupt statuses. */
name|istatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ch
operator|->
name|batch
operator|=
literal|1
expr_stmt|;
name|ahci_ch_intr_main
argument_list|(
name|ch
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
name|ch
operator|->
name|batch
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Prevent the possibility of issues caused by processing the queue 	 * while unlocked below by moving the contents to a local queue. 	 */
name|STAILQ_CONCAT
argument_list|(
operator|&
name|tmp_doneq
argument_list|,
operator|&
name|ch
operator|->
name|doneq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ccb_h
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|tmp_doneq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|tmp_doneq
argument_list|,
name|sim_links
operator|.
name|stqe
argument_list|)
expr_stmt|;
name|xpt_done_direct
argument_list|(
operator|(
expr|union
name|ccb
operator|*
operator|)
name|ccb_h
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_pm
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|work
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return;
name|work
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
condition|)
name|work
operator||=
name|AHCI_P_CMD_PARTIAL
expr_stmt|;
else|else
name|work
operator||=
name|AHCI_P_CMD_SLUMBER
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_ch_intr_main
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|istatus
parameter_list|)
block|{
name|uint32_t
name|cstatus
decl_stmt|,
name|serr
init|=
literal|0
decl_stmt|,
name|sntf
init|=
literal|0
decl_stmt|,
name|ok
decl_stmt|,
name|err
decl_stmt|;
name|enum
name|ahci_err_type
name|et
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ccs
decl_stmt|,
name|port
decl_stmt|,
name|reset
init|=
literal|0
decl_stmt|;
comment|/* Clear interrupt statuses. */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
comment|/* Read command statuses. */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
condition|)
name|cstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
expr_stmt|;
else|else
name|cstatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
name|ch
operator|->
name|numtslots
condition|)
name|cstatus
operator||=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
expr_stmt|;
comment|/* Read SNTF in one of possible ways. */
if|if
condition|(
operator|(
name|istatus
operator|&
name|AHCI_P_IX_SDB
operator|)
operator|&&
operator|(
name|ch
operator|->
name|pm_present
operator|||
name|ch
operator|->
name|curr
index|[
literal|0
index|]
operator|.
name|atapi
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SSNTF
condition|)
name|sntf
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SNTF
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|+
literal|0x58
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fis
index|[
literal|1
index|]
operator|&
literal|0x80
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
name|sntf
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
name|fis
operator|+=
literal|256
expr_stmt|;
block|}
block|}
else|else
block|{
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|+
literal|0x58
decl_stmt|;
if|if
condition|(
name|fis
index|[
literal|1
index|]
operator|&
literal|0x80
condition|)
name|sntf
operator|=
operator|(
literal|1
operator|<<
operator|(
name|fis
index|[
literal|1
index|]
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
block|}
block|}
comment|/* Process PHY events */
if|if
condition|(
name|istatus
operator|&
operator|(
name|AHCI_P_IX_PC
operator||
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_OF
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_TFE
operator|)
condition|)
block|{
name|serr
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|serr
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
name|serr
argument_list|)
expr_stmt|;
name|reset
operator|=
name|ahci_phy_check_events
argument_list|(
name|ch
argument_list|,
name|serr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Process cold presence detection events */
if|if
condition|(
operator|(
name|istatus
operator|&
name|AHCI_P_IX_CPD
operator|)
operator|&&
operator|!
name|reset
condition|)
name|ahci_cpd_check_events
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Process command errors */
if|if
condition|(
name|istatus
operator|&
operator|(
name|AHCI_P_IX_OF
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_TFE
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOCCS
condition|)
block|{
comment|/* 			 * ASMedia chips sometimes report failed commands as 			 * completed.  Count all running commands as failed. 			 */
name|cstatus
operator||=
name|ch
operator|->
name|rslots
expr_stmt|;
comment|/* They also report wrong CCS, so try to guess one. */
name|ccs
operator|=
name|powerof2
argument_list|(
name|cstatus
argument_list|)
condition|?
name|ffs
argument_list|(
name|cstatus
argument_list|)
operator|-
literal|1
else|:
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ccs
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CCS_MASK
operator|)
operator|>>
name|AHCI_P_CMD_CCS_SHIFT
expr_stmt|;
block|}
comment|//device_printf(dev, "%s ERROR is %08x cs %08x ss %08x rs %08x tfd %02x serr %08x fbs %08x ccs %d\n",
comment|//    __func__, istatus, cstatus, sstatus, ch->rslots, ATA_INL(ch->r_mem, AHCI_P_TFD),
comment|//    serr, ATA_INL(ch->r_mem, AHCI_P_FBS), ccs);
name|port
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
name|uint32_t
name|fbs
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBS
argument_list|)
decl_stmt|;
if|if
condition|(
name|fbs
operator|&
name|AHCI_P_FBS_SDE
condition|)
block|{
name|port
operator|=
operator|(
name|fbs
operator|&
name|AHCI_P_FBS_DWE
operator|)
operator|>>
name|AHCI_P_FBS_DWE_SHIFT
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|numrslotspd
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
name|port
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|port
operator|!=
name|i
condition|)
block|{
name|port
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|err
operator|=
name|ch
operator|->
name|rslots
operator|&
name|cstatus
expr_stmt|;
block|}
else|else
block|{
name|ccs
operator|=
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Complete all successful commands. */
name|ok
operator|=
name|ch
operator|->
name|rslots
operator|&
operator|~
name|cstatus
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ok
operator|>>
name|i
operator|)
operator|&
literal|1
condition|)
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_NONE
argument_list|)
expr_stmt|;
block|}
comment|/* On error, complete the rest of commands with error statuses. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* XXX: reqests in loading state. */
if|if
condition|(
operator|(
operator|(
name|err
operator|>>
name|i
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|port
operator|>=
literal|0
operator|&&
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|!=
name|port
condition|)
continue|continue;
if|if
condition|(
name|istatus
operator|&
name|AHCI_P_IX_TFE
condition|)
block|{
if|if
condition|(
name|port
operator|!=
operator|-
literal|2
condition|)
block|{
comment|/* Task File Error */
if|if
condition|(
name|ch
operator|->
name|numtslotspd
index|[
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Untagged operation. */
if|if
condition|(
name|i
operator|==
name|ccs
condition|)
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
else|else
name|et
operator|=
name|AHCI_ERR_INNOCENT
expr_stmt|;
block|}
else|else
block|{
comment|/* Tagged operation. */
name|et
operator|=
name|AHCI_ERR_NCQ
expr_stmt|;
block|}
block|}
else|else
block|{
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|istatus
operator|&
name|AHCI_P_IX_IF
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|==
literal|0
operator|&&
name|i
operator|!=
name|ccs
operator|&&
name|port
operator|!=
operator|-
literal|2
condition|)
name|et
operator|=
name|AHCI_ERR_INNOCENT
expr_stmt|;
else|else
name|et
operator|=
name|AHCI_ERR_SATA
expr_stmt|;
block|}
else|else
name|et
operator|=
name|AHCI_ERR_INVALID
expr_stmt|;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|et
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We can't reinit port if there are some other 		 * commands active, use resume to complete them. 		 */
if|if
condition|(
name|ch
operator|->
name|rslots
operator|!=
literal|0
operator|&&
operator|!
name|ch
operator|->
name|recoverycmd
condition|)
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBS
argument_list|,
name|AHCI_P_FBS_EN
operator||
name|AHCI_P_FBS_DEC
argument_list|)
expr_stmt|;
block|}
comment|/* Process NOTIFY events */
if|if
condition|(
name|sntf
condition|)
name|ahci_notify_events
argument_list|(
name|ch
argument_list|,
name|sntf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|int
name|ahci_check_collision
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|t
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
comment|/* Tagged command while we have no supported tag free. */
if|if
condition|(
operator|(
operator|(
operator|~
name|ch
operator|->
name|oslots
operator|)
operator|&
operator|(
literal|0xffffffff
operator|>>
operator|(
literal|32
operator|-
name|ch
operator|->
name|curr
index|[
name|t
index|]
operator|.
name|tags
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* If we have FBS */
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
comment|/* Tagged command while untagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslotspd
index|[
name|t
index|]
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslotspd
index|[
name|t
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Tagged command while untagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslots
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Tagged command while tagged to other target is active. */
if|if
condition|(
name|ch
operator|->
name|numtslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|taggedtarget
operator|!=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* If we have FBS */
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
comment|/* Untagged command while tagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslotspd
index|[
name|t
index|]
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslotspd
index|[
name|t
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* Untagged command while tagged are active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
operator|&&
name|ch
operator|->
name|numtslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
operator|)
condition|)
block|{
comment|/* Atomic command while anything active. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* We have some atomic command running. */
if|if
condition|(
name|ch
operator|->
name|aslots
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_begin_transaction
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
decl_stmt|;
name|int
name|tag
decl_stmt|,
name|tags
decl_stmt|;
comment|/* Choose empty slot. */
name|tags
operator|=
name|ch
operator|->
name|numslots
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
name|tags
operator|=
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|tags
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|lastslot
operator|+
literal|1
operator|<
name|tags
condition|)
name|tag
operator|=
name|ffs
argument_list|(
operator|~
operator|(
name|ch
operator|->
name|oslots
operator|>>
operator|(
name|ch
operator|->
name|lastslot
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0
operator|||
name|tag
operator|+
name|ch
operator|->
name|lastslot
operator|>=
name|tags
condition|)
name|tag
operator|=
name|ffs
argument_list|(
operator|~
name|ch
operator|->
name|oslots
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|tag
operator|+=
name|ch
operator|->
name|lastslot
expr_stmt|;
name|ch
operator|->
name|lastslot
operator|=
name|tag
expr_stmt|;
comment|/* Occupy chosen slot. */
name|slot
operator|=
operator|&
name|ch
operator|->
name|slot
index|[
name|tag
index|]
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|ccb
expr_stmt|;
comment|/* Stop PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
condition|)
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|)
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|oslots
operator||=
operator|(
literal|1
operator|<<
name|tag
operator|)
expr_stmt|;
name|ch
operator|->
name|numrslots
operator|++
expr_stmt|;
name|ch
operator|->
name|numrslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ch
operator|->
name|numtslots
operator|++
expr_stmt|;
name|ch
operator|->
name|numtslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|++
expr_stmt|;
name|ch
operator|->
name|taggedtarget
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
operator|(
name|CAM_ATAIO_CONTROL
operator||
name|CAM_ATAIO_NEEDRESULT
operator|)
operator|)
condition|)
name|ch
operator|->
name|aslots
operator||=
operator|(
literal|1
operator|<<
name|tag
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_LOADING
expr_stmt|;
name|bus_dmamap_load_ccb
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
name|ccb
argument_list|,
name|ahci_dmasetprd
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slot
operator|->
name|dma
operator|.
name|nsegs
operator|=
literal|0
expr_stmt|;
name|ahci_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Locked by busdma engine. */
end_comment

begin_function
specifier|static
name|void
name|ahci_dmasetprd
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
name|arg
decl_stmt|;
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|slot
operator|->
name|ch
decl_stmt|;
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ahci_dma_prd
modifier|*
name|prd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"DMA load error\n"
argument_list|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|AHCI_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|AHCI_SG_ENTRIES
argument_list|,
operator|(
literal|"too many DMA segment entries\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Fill S/G table */
name|prd
operator|=
operator|&
name|ctp
operator|->
name|prd_tab
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|prd
index|[
name|i
index|]
operator|.
name|dba
operator|=
name|htole64
argument_list|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|prd
index|[
name|i
index|]
operator|.
name|dbc
operator|=
name|htole32
argument_list|(
operator|(
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
literal|1
operator|)
operator|&
name|AHCI_PRD_MASK
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|dma
operator|.
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
operator|(
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
operator|)
argument_list|)
expr_stmt|;
name|ahci_execute_transaction
argument_list|(
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_execute_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|slot
operator|->
name|ch
decl_stmt|;
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
decl_stmt|;
name|struct
name|ahci_cmd_list
modifier|*
name|clp
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|int
name|port
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
decl_stmt|;
name|int
name|fis_size
decl_stmt|,
name|i
decl_stmt|,
name|softreset
decl_stmt|;
name|uint8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|+
literal|0x40
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
comment|/* Get a piece of the workspace for this request */
name|ctp
operator|=
operator|(
expr|struct
name|ahci_cmd_tab
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Setup the FIS for this request */
if|if
condition|(
operator|!
operator|(
name|fis_size
operator|=
name|ahci_setup_fis
argument_list|(
name|ch
argument_list|,
name|ctp
argument_list|,
name|ccb
argument_list|,
name|slot
operator|->
name|slot
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Setting up SATA FIS failed\n"
argument_list|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|AHCI_ERR_INVALID
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup the command list entry */
name|clp
operator|=
operator|(
expr|struct
name|ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CL_OFFSET
operator|+
operator|(
name|AHCI_CL_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator|=
name|htole16
argument_list|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_OUT
condition|?
name|AHCI_CMD_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|?
operator|(
name|AHCI_CMD_ATAPI
operator||
name|AHCI_CMD_PREFETCH
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|fis_size
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator||
operator|(
name|port
operator|<<
literal|12
operator|)
argument_list|)
expr_stmt|;
name|clp
operator|->
name|prd_length
operator|=
name|htole16
argument_list|(
name|slot
operator|->
name|dma
operator|.
name|nsegs
argument_list|)
expr_stmt|;
comment|/* Special handling for Soft Reset command. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
condition|)
block|{
name|softreset
operator|=
literal|1
expr_stmt|;
comment|/* Kick controller into sane state */
name|ahci_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_clo
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clp
operator|->
name|cmd_flags
operator||=
name|AHCI_CMD_RESET
operator||
name|AHCI_CMD_CLR_BUSY
expr_stmt|;
block|}
else|else
block|{
name|softreset
operator|=
literal|2
expr_stmt|;
comment|/* Prepare FIS receive area for check. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
name|fis
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
else|else
name|softreset
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|bytecount
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|cmd_table_phys
operator|=
name|htole64
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_bus
operator|+
name|AHCI_CT_OFFSET
operator|+
operator|(
name|AHCI_CT_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
comment|/* Set ACTIVE bit for NCQ commands. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|,
literal|1
operator|<<
name|slot
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* If FBS is enabled, set PMP port. */
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBS
argument_list|,
name|AHCI_P_FBS_EN
operator||
operator|(
name|port
operator|<<
name|AHCI_P_FBS_DEV_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Issue command to the controller. */
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_RUNNING
expr_stmt|;
name|ch
operator|->
name|rslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|,
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
argument_list|)
expr_stmt|;
comment|/* Device reset commands doesn't interrupt. Poll them. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
operator|==
name|ATA_DEVICE_RESET
operator|||
name|softreset
operator|)
condition|)
block|{
name|int
name|count
decl_stmt|,
name|timeout
init|=
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|*
literal|100
decl_stmt|;
name|enum
name|ahci_err_type
name|et
init|=
name|AHCI_ERR_NONE
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|timeout
condition|;
name|count
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
operator|&
name|ATA_S_ERROR
operator|)
operator|&&
name|softreset
operator|!=
literal|1
condition|)
block|{
if|#
directive|if
literal|0
block|device_printf(ch->dev, 				    "Poll error on slot %d, TFD: %04x\n", 				    slot->slot, ATA_INL(ch->r_mem, AHCI_P_TFD));
endif|#
directive|endif
name|et
operator|=
name|AHCI_ERR_TFE
expr_stmt|;
break|break;
block|}
comment|/* Workaround for ATI SB600/SB700 chipsets. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|15
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_ATI_PMP_BUG
operator|)
operator|&&
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
operator|&
name|AHCI_P_IX_IPM
operator|)
condition|)
block|{
name|et
operator|=
name|AHCI_ERR_TIMEOUT
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Some Marvell controllers require additional time 		 * after soft reset to work properly. Setup delay 		 * to 50ms after soft reset. 		 */
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_MRVL_SR_DEL
condition|)
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* 		 * Marvell HBAs with non-RAID firmware do not wait for 		 * readiness after soft reset, so we have to wait here. 		 * Marvell RAIDs do not have this problem, but instead 		 * sometimes forget to update FIS receive area, breaking 		 * this wait. 		 */
if|if
condition|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOBSYRES
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_ATI_PMP_BUG
operator|)
operator|==
literal|0
operator|&&
name|softreset
operator|==
literal|2
operator|&&
name|et
operator|==
name|AHCI_ERR_NONE
condition|)
block|{
for|for
control|(
init|;
name|count
operator|<
name|timeout
condition|;
name|count
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|val
operator|=
name|fis
index|[
literal|2
index|]
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|ATA_S_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeout
operator|&&
operator|(
name|count
operator|>=
name|timeout
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Poll timeout on slot %d port %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"is %08x cs %08x ss %08x "
literal|"rs %08x tfd %02x serr %08x cmd %08x\n"
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
argument_list|,
name|ch
operator|->
name|rslots
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
argument_list|)
expr_stmt|;
name|et
operator|=
name|AHCI_ERR_TIMEOUT
expr_stmt|;
block|}
comment|/* Kick controller into sane state and enable FBS. */
if|if
condition|(
name|softreset
operator|==
literal|2
condition|)
name|ch
operator|->
name|eslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ahci_end_transaction
argument_list|(
name|slot
argument_list|,
name|et
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Start command execution timeout */
name|callout_reset_sbt
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
name|SBT_1MS
operator|*
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ahci_timeout
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_process_timeout
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Handle the rest of commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_rearm_timeout
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ch
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ahci_slot
modifier|*
name|slot
init|=
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
decl_stmt|;
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ch
operator|->
name|toslots
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|callout_reset_sbt
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
name|SBT_1MS
operator|*
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ahci_timeout
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Locked by callout mechanism. */
end_comment

begin_function
specifier|static
name|void
name|ahci_timeout
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|slot
operator|->
name|ch
decl_stmt|;
name|device_t
name|dev
init|=
name|ch
operator|->
name|dev
decl_stmt|;
name|uint32_t
name|sstatus
decl_stmt|;
name|int
name|ccs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for stale timeout. */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
return|return;
comment|/* Check if slot was not being executed last time we checked. */
if|if
condition|(
name|slot
operator|->
name|state
operator|<
name|AHCI_SLOT_EXECUTING
condition|)
block|{
comment|/* Check if slot started executing. */
name|sstatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
expr_stmt|;
name|ccs
operator|=
operator|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CCS_MASK
operator|)
operator|>>
name|AHCI_P_CMD_CCS_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|sstatus
operator|&
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
operator|!=
literal|0
operator|||
name|ccs
operator|==
name|slot
operator|->
name|slot
operator|||
name|ch
operator|->
name|fbs_enabled
operator|||
name|ch
operator|->
name|wrongccs
condition|)
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EXECUTING
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|->
name|rslots
operator|&
operator|(
literal|1
operator|<<
name|ccs
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ch
operator|->
name|wrongccs
operator|=
literal|1
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EXECUTING
expr_stmt|;
block|}
name|callout_reset_sbt
argument_list|(
operator|&
name|slot
operator|->
name|timeout
argument_list|,
name|SBT_1MS
operator|*
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|/
literal|2
argument_list|,
literal|0
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|ahci_timeout
argument_list|,
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timeout on slot %d port %d\n"
argument_list|,
name|slot
operator|->
name|slot
argument_list|,
name|slot
operator|->
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"is %08x cs %08x ss %08x rs %08x tfd %02x "
literal|"serr %08x cmd %08x\n"
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CI
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SACT
argument_list|)
argument_list|,
name|ch
operator|->
name|rslots
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|)
argument_list|,
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle frozen command. */
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ch
operator|->
name|fbs_enabled
operator|&&
operator|!
name|ch
operator|->
name|wrongccs
condition|)
block|{
comment|/* Without FBS we know real timeout source. */
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
comment|/* Handle command with timeout. */
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|slot
operator|->
name|slot
index|]
argument_list|,
name|AHCI_ERR_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* Handle the rest of commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* With FBS we wait for other commands timeout and pray. */
if|if
condition|(
name|ch
operator|->
name|toslots
operator|==
literal|0
condition|)
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|rslots
operator|&
operator|~
name|ch
operator|->
name|toslots
operator|)
operator|==
literal|0
condition|)
name|ahci_process_timeout
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|" ... waiting for slots %08x\n"
argument_list|,
name|ch
operator|->
name|rslots
operator|&
operator|~
name|ch
operator|->
name|toslots
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Must be called with channel locked. */
end_comment

begin_function
specifier|static
name|void
name|ahci_end_transaction
parameter_list|(
name|struct
name|ahci_slot
modifier|*
name|slot
parameter_list|,
name|enum
name|ahci_err_type
name|et
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|slot
operator|->
name|ch
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
init|=
name|slot
operator|->
name|ccb
decl_stmt|;
name|struct
name|ahci_cmd_list
modifier|*
name|clp
decl_stmt|;
name|int
name|lastto
decl_stmt|;
name|uint32_t
name|sig
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|work_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|work_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|clp
operator|=
operator|(
expr|struct
name|ahci_cmd_list
operator|*
operator|)
operator|(
name|ch
operator|->
name|dma
operator|.
name|work
operator|+
name|AHCI_CL_OFFSET
operator|+
operator|(
name|AHCI_CL_SIZE
operator|*
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
comment|/* Read result registers to the result struct 	 * May be incorrect if several commands finished same time, 	 * so read only when sure or have to. 	 */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
name|struct
name|ata_res
modifier|*
name|res
init|=
operator|&
name|ccb
operator|->
name|ataio
operator|.
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|et
operator|==
name|AHCI_ERR_TFE
operator|)
operator|||
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_NEEDRESULT
operator|)
condition|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
name|ch
operator|->
name|dma
operator|.
name|rfis
operator|+
literal|0x40
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|rfis_tag
argument_list|,
name|ch
operator|->
name|dma
operator|.
name|rfis_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|fbs_enabled
condition|)
block|{
name|fis
operator|+=
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|*
literal|256
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|fis
index|[
literal|2
index|]
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|fis
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|uint16_t
name|tfd
init|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
decl_stmt|;
name|res
operator|->
name|status
operator|=
name|tfd
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|tfd
operator|>>
literal|8
expr_stmt|;
block|}
name|res
operator|->
name|lba_low
operator|=
name|fis
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|fis
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|fis
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|fis
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|fis
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|fis
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|fis
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|fis
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|fis
index|[
literal|13
index|]
expr_stmt|;
comment|/* 			 * Some weird controllers do not return signature in 			 * FIS receive area. Read it from PxSIG register. 			 */
if|if
condition|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_ALTSIG
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
operator|)
operator|==
literal|0
condition|)
block|{
name|sig
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SIG
argument_list|)
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|sig
operator|>>
literal|24
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|sig
operator|>>
literal|16
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|sig
operator|>>
literal|8
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|sig
expr_stmt|;
block|}
block|}
else|else
name|bzero
argument_list|(
name|res
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOCOUNT
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|ataio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|dxfer_len
operator|-
name|le32toh
argument_list|(
name|clp
operator|->
name|bytecount
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOCOUNT
operator|)
operator|==
literal|0
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|-
name|le32toh
argument_list|(
name|clp
operator|->
name|bytecount
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|,
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_IN
operator|)
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ch
operator|->
name|dma
operator|.
name|data_tag
argument_list|,
name|slot
operator|->
name|dma
operator|.
name|data_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|et
operator|!=
name|AHCI_ERR_NONE
condition|)
name|ch
operator|->
name|eslots
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
comment|/* In case of error, freeze device for proper recovery. */
if|if
condition|(
operator|(
name|et
operator|!=
name|AHCI_ERR_NONE
operator|)
operator|&&
operator|(
operator|!
name|ch
operator|->
name|recoverycmd
operator|)
operator|&&
operator|!
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
comment|/* Set proper result status. */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|et
condition|)
block|{
case|case
name|AHCI_ERR_NONE
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_OK
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_INVALID
case|:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_INNOCENT
case|:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_TFE
case|:
case|case
name|AHCI_ERR_NCQ
case|:
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_SCSI_STATUS_ERROR
expr_stmt|;
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
operator|=
name|SCSI_STATUS_CHECK_COND
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_ATA_STATUS_ERROR
expr_stmt|;
block|}
break|break;
case|case
name|AHCI_ERR_SATA
case|:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ch
operator|->
name|recoverycmd
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_UNCOR_PARITY
expr_stmt|;
break|break;
case|case
name|AHCI_ERR_TIMEOUT
case|:
if|if
condition|(
operator|!
name|ch
operator|->
name|recoverycmd
condition|)
block|{
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RELEASE_SIMQ
expr_stmt|;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_CMD_TIMEOUT
expr_stmt|;
break|break;
default|default:
name|ch
operator|->
name|fatalerr
operator|=
literal|1
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQ_CMP_ERR
expr_stmt|;
block|}
comment|/* Free slot. */
name|ch
operator|->
name|oslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|rslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|ch
operator|->
name|aslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
name|slot
operator|->
name|state
operator|=
name|AHCI_SLOT_EMPTY
expr_stmt|;
name|slot
operator|->
name|ccb
operator|=
name|NULL
expr_stmt|;
comment|/* Update channel stats. */
name|ch
operator|->
name|numrslots
operator|--
expr_stmt|;
name|ch
operator|->
name|numrslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
operator|)
condition|)
block|{
name|ch
operator|->
name|numtslots
operator|--
expr_stmt|;
name|ch
operator|->
name|numtslotspd
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|--
expr_stmt|;
block|}
comment|/* Cancel timeout state if request completed normally. */
if|if
condition|(
name|et
operator|!=
name|AHCI_ERR_TIMEOUT
condition|)
block|{
name|lastto
operator|=
operator|(
name|ch
operator|->
name|toslots
operator|==
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
operator|)
expr_stmt|;
name|ch
operator|->
name|toslots
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|slot
operator|->
name|slot
operator|)
expr_stmt|;
if|if
condition|(
name|lastto
condition|)
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* If it was first request of reset sequence and there is no error, 	 * proceed to second request. */
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&
name|ATA_A_RESET
operator|)
operator|&&
name|et
operator|==
name|AHCI_ERR_NONE
condition|)
block|{
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
operator|&=
operator|~
name|ATA_A_RESET
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it was our READ LOG command - process it. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|==
name|RECOVERY_READ_LOG
condition|)
block|{
name|ahci_process_read_log
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* If it was our REQUEST SENSE command - process it. */
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|==
name|RECOVERY_REQUEST_SENSE
condition|)
block|{
name|ahci_process_request_sense
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* If it was NCQ or ATAPI command error, put result on hold. */
block|}
elseif|else
if|if
condition|(
name|et
operator|==
name|AHCI_ERR_NCQ
operator|||
operator|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_SCSI_STATUS_ERROR
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIS_AUTOSENSE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ch
operator|->
name|hold
index|[
name|slot
operator|->
name|slot
index|]
operator|=
name|ccb
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|++
expr_stmt|;
block|}
else|else
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* If we have no other active commands, ... */
if|if
condition|(
name|ch
operator|->
name|rslots
operator|==
literal|0
condition|)
block|{
comment|/* if there was fatal error - reset port. */
if|if
condition|(
name|ch
operator|->
name|toslots
operator|!=
literal|0
operator|||
name|ch
operator|->
name|fatalerr
condition|)
block|{
name|ahci_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if we have slots in error, we can reinit port. */
if|if
condition|(
name|ch
operator|->
name|eslots
operator|!=
literal|0
condition|)
block|{
name|ahci_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_clo
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* if there commands on hold, we can do READ LOG. */
if|if
condition|(
operator|!
name|ch
operator|->
name|recoverycmd
operator|&&
name|ch
operator|->
name|numhslots
condition|)
name|ahci_issue_recovery
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* If all the rest of commands are in timeout - give them chance. */
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|->
name|rslots
operator|&
operator|~
name|ch
operator|->
name|toslots
operator|)
operator|==
literal|0
operator|&&
name|et
operator|!=
name|AHCI_ERR_TIMEOUT
condition|)
name|ahci_rearm_timeout
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Unfreeze frozen command. */
if|if
condition|(
name|ch
operator|->
name|frozen
operator|&&
operator|!
name|ahci_check_collision
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|frozen
argument_list|)
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|ch
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Start PM timer. */
if|if
condition|(
name|ch
operator|->
name|numrslots
operator|==
literal|0
operator|&&
name|ch
operator|->
name|pm_level
operator|>
literal|3
operator|&&
operator|(
name|ch
operator|->
name|curr
index|[
name|ch
operator|->
name|pm_present
condition|?
literal|15
else|:
literal|0
index|]
operator|.
name|caps
operator|&
name|CTS_SATA_CAPS_D_PMREQ
operator|)
condition|)
block|{
name|callout_schedule
argument_list|(
operator|&
name|ch
operator|->
name|pm_timer
argument_list|,
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|4
operator|)
condition|?
name|hz
operator|/
literal|1000
else|:
name|hz
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_issue_recovery
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|ccb_ataio
modifier|*
name|ataio
decl_stmt|;
name|struct
name|ccb_scsiio
modifier|*
name|csio
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find some held command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
break|break;
block|}
name|ccb
operator|=
name|xpt_alloc_ccb_nowait
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Unable to allocate recovery command\n"
argument_list|)
expr_stmt|;
name|completeall
label|:
comment|/* We can't do anything -- complete held commands. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_RESRC_UNAVAIL
expr_stmt|;
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
name|ahci_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return;
block|}
name|ccb
operator|->
name|ccb_h
operator|=
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
expr_stmt|;
comment|/* Reuse old header. */
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_ATA_IO
condition|)
block|{
comment|/* READ LOG */
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|=
name|RECOVERY_READ_LOG
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_ATA_IO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|1000
expr_stmt|;
comment|/* 1s should be enough. */
name|ataio
operator|=
operator|&
name|ccb
operator|->
name|ataio
expr_stmt|;
name|ataio
operator|->
name|data_ptr
operator|=
name|malloc
argument_list|(
literal|512
argument_list|,
name|M_AHCI
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ataio
operator|->
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Unable to allocate memory for READ LOG command\n"
argument_list|)
expr_stmt|;
goto|goto
name|completeall
goto|;
block|}
name|ataio
operator|->
name|dxfer_len
operator|=
literal|512
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ataio
operator|->
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|ataio
operator|->
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|flags
operator|=
name|CAM_ATAIO_48BIT
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|command
operator|=
literal|0x2F
expr_stmt|;
comment|/* READ LOG EXT */
name|ataio
operator|->
name|cmd
operator|.
name|sector_count
operator|=
literal|1
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|sector_count_exp
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_low
operator|=
literal|0x10
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid
operator|=
literal|0
expr_stmt|;
name|ataio
operator|->
name|cmd
operator|.
name|lba_mid_exp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* REQUEST SENSE */
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|=
name|RECOVERY_REQUEST_SENSE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_slot
operator|=
name|i
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_SCSI_IO
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_IN
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|timeout
operator|=
literal|1000
expr_stmt|;
comment|/* 1s should be enough. */
name|csio
operator|=
operator|&
name|ccb
operator|->
name|csio
expr_stmt|;
name|csio
operator|->
name|data_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|csio
operator|.
name|sense_data
expr_stmt|;
name|csio
operator|->
name|dxfer_len
operator|=
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|csio
operator|.
name|sense_len
expr_stmt|;
name|csio
operator|->
name|cdb_len
operator|=
literal|6
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|csio
operator|->
name|cdb_io
argument_list|,
sizeof|sizeof
argument_list|(
name|csio
operator|->
name|cdb_io
argument_list|)
argument_list|)
expr_stmt|;
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|0
index|]
operator|=
literal|0x03
expr_stmt|;
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
index|[
literal|4
index|]
operator|=
name|csio
operator|->
name|dxfer_len
expr_stmt|;
block|}
comment|/* Freeze SIM while doing recovery. */
name|ch
operator|->
name|recoverycmd
operator|=
literal|1
expr_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ahci_begin_transaction
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_process_read_log
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|struct
name|ata_res
modifier|*
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|recoverycmd
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
operator|&&
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_ATA_IO
condition|)
continue|continue;
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x1F
operator|)
operator|==
name|i
condition|)
block|{
name|res
operator|=
operator|&
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ataio
operator|.
name|res
expr_stmt|;
name|res
operator|->
name|status
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|res
operator|->
name|error
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|res
operator|->
name|lba_low
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
name|res
operator|->
name|lba_high
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
name|res
operator|->
name|device
operator|=
name|data
index|[
literal|7
index|]
expr_stmt|;
name|res
operator|->
name|lba_low_exp
operator|=
name|data
index|[
literal|8
index|]
expr_stmt|;
name|res
operator|->
name|lba_mid_exp
operator|=
name|data
index|[
literal|9
index|]
expr_stmt|;
name|res
operator|->
name|lba_high_exp
operator|=
name|data
index|[
literal|10
index|]
expr_stmt|;
name|res
operator|->
name|sector_count
operator|=
name|data
index|[
literal|12
index|]
expr_stmt|;
name|res
operator|->
name|sector_count_exp
operator|=
name|data
index|[
literal|13
index|]
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_REQUEUE_REQ
expr_stmt|;
block|}
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Error while READ LOG EXT\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"Non-queued command error in READ LOG EXT\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|func_code
operator|!=
name|XPT_ATA_IO
condition|)
continue|continue;
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ccb
operator|->
name|ataio
operator|.
name|data_ptr
argument_list|,
name|M_AHCI
argument_list|)
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_process_request_sense
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ch
operator|->
name|recoverycmd
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_slot
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|==
name|CAM_REQ_CMP
condition|)
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSNS_VALID
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator|&=
operator|~
name|CAM_STATUS_MASK
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_AUTOSENSE_FAIL
expr_stmt|;
block|}
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
name|xpt_free_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_start
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|int
name|fbs
parameter_list|)
block|{
name|u_int32_t
name|cmd
decl_stmt|;
comment|/* Run the channel start callback, if any. */
if|if
condition|(
name|ch
operator|->
name|start
condition|)
name|ch
operator|->
name|start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Clear any interrupts pending on this channel */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Configure FIS-based switching if supported. */
if|if
condition|(
name|ch
operator|->
name|chcaps
operator|&
name|AHCI_P_CMD_FBSCP
condition|)
block|{
name|ch
operator|->
name|fbs_enabled
operator|=
operator|(
name|fbs
operator|&&
name|ch
operator|->
name|pm_present
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_FBS
argument_list|,
name|ch
operator|->
name|fbs_enabled
condition|?
name|AHCI_P_FBS_EN
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Start operations on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|cmd
operator|&=
operator|~
name|AHCI_P_CMD_PMA
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator||
name|AHCI_P_CMD_ST
operator||
operator|(
name|ch
operator|->
name|pm_present
condition|?
name|AHCI_P_CMD_PMA
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_stop
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Kill all activity on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator|&
operator|~
name|AHCI_P_CMD_ST
argument_list|)
expr_stmt|;
comment|/* Wait for activity stop. */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|50000
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"stopping AHCI engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CR
condition|)
do|;
name|ch
operator|->
name|eslots
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_clo
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Issue Command List Override if supported */
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SCLO
condition|)
block|{
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|AHCI_P_CMD_CLO
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|50000
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"executing CLO failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_CLO
condition|)
do|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_stop_fr
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|cmd
decl_stmt|;
name|int
name|timeout
decl_stmt|;
comment|/* Kill all FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator|&
operator|~
name|AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
comment|/* Wait for FIS reception stop. */
name|timeout
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|++
operator|>
literal|50000
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"stopping AHCI FR engine failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
operator|&
name|AHCI_P_CMD_FR
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_start_fr
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|cmd
decl_stmt|;
comment|/* Start FIS reception on this channel */
name|cmd
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|cmd
operator||
name|AHCI_P_CMD_FRE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_wait_ready
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|t0
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_TFD
argument_list|)
operator|)
operator|&
operator|(
name|ATA_S_BUSY
operator||
name|ATA_S_DRQ
operator|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|>
name|t
condition|)
block|{
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"AHCI reset: device not ready after %dms "
literal|"(tfd = %08x)\n"
argument_list|,
name|MAX
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|+
name|t0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|timeout
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"AHCI reset: device ready after %dms\n"
argument_list|,
name|timeout
operator|+
name|t0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_reset_to
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|resetting
operator|==
literal|0
condition|)
return|return;
name|ch
operator|->
name|resetting
operator|--
expr_stmt|;
if|if
condition|(
name|ahci_wait_ready
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|resetting
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
operator|(
literal|310
operator|-
name|ch
operator|->
name|resetting
operator|)
operator|*
literal|100
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ch
operator|->
name|resetting
operator|==
literal|0
condition|)
block|{
name|ahci_clo
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ahci_start
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|callout_schedule
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahci_reset
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|ch
operator|->
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"AHCI reset...\n"
argument_list|)
expr_stmt|;
comment|/* Forget about previous reset. */
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
block|{
name|ch
operator|->
name|resetting
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* Requeue freezed command. */
if|if
condition|(
name|ch
operator|->
name|frozen
condition|)
block|{
name|union
name|ccb
modifier|*
name|fccb
init|=
name|ch
operator|->
name|frozen
decl_stmt|;
name|ch
operator|->
name|frozen
operator|=
name|NULL
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQUEUE_REQ
operator||
name|CAM_RELEASE_SIMQ
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_DEV_QFRZN
operator|)
condition|)
block|{
name|xpt_freeze_devq
argument_list|(
name|fccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fccb
operator|->
name|ccb_h
operator|.
name|status
operator||=
name|CAM_DEV_QFRZN
expr_stmt|;
block|}
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|fccb
argument_list|)
expr_stmt|;
block|}
comment|/* Kill the engine and requeue all running commands. */
name|ahci_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
comment|/* Do we have a running request on slot? */
if|if
condition|(
name|ch
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|state
operator|<
name|AHCI_SLOT_RUNNING
condition|)
continue|continue;
comment|/* XXX; Commands in loading state. */
name|ahci_end_transaction
argument_list|(
operator|&
name|ch
operator|->
name|slot
index|[
name|i
index|]
argument_list|,
name|AHCI_ERR_INNOCENT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ch
operator|->
name|numslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ch
operator|->
name|hold
index|[
name|i
index|]
condition|)
continue|continue;
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ch
operator|->
name|hold
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ch
operator|->
name|hold
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ch
operator|->
name|numhslots
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|toslots
operator|!=
literal|0
condition|)
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|ch
operator|->
name|eslots
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|toslots
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|wrongccs
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|fatalerr
operator|=
literal|0
expr_stmt|;
comment|/* Tell the XPT about the event */
name|xpt_async
argument_list|(
name|AC_BUS_RESET
argument_list|,
name|ch
operator|->
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Disable port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset and reconnect PHY, */
if|if
condition|(
operator|!
name|ahci_sata_phy_reset
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"AHCI reset: device not found\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
comment|/* Enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
operator|(
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|!=
literal|0
operator|)
condition|?
name|AHCI_P_IX_CPD
operator||
name|AHCI_P_IX_MP
else|:
literal|0
operator|)
operator||
name|AHCI_P_IX_PRC
operator||
name|AHCI_P_IX_PC
operator|)
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"AHCI reset: device found\n"
argument_list|)
expr_stmt|;
comment|/* Wait for clearing busy status. */
if|if
condition|(
name|ahci_wait_ready
argument_list|(
name|ch
argument_list|,
name|dumping
condition|?
literal|31000
else|:
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|dumping
condition|)
name|ahci_clo
argument_list|(
name|ch
argument_list|)
expr_stmt|;
else|else
name|ch
operator|->
name|resetting
operator|=
literal|310
expr_stmt|;
block|}
name|ch
operator|->
name|devices
operator|=
literal|1
expr_stmt|;
comment|/* Enable wanted port interrupts */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IE
argument_list|,
operator|(
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|!=
literal|0
operator|)
condition|?
name|AHCI_P_IX_CPD
operator||
name|AHCI_P_IX_MP
else|:
literal|0
operator|)
operator||
name|AHCI_P_IX_TFE
operator||
name|AHCI_P_IX_HBF
operator||
name|AHCI_P_IX_HBD
operator||
name|AHCI_P_IX_IF
operator||
name|AHCI_P_IX_OF
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|==
literal|0
operator|)
condition|?
name|AHCI_P_IX_PRC
else|:
literal|0
operator|)
operator||
name|AHCI_P_IX_PC
operator||
name|AHCI_P_IX_DP
operator||
name|AHCI_P_IX_UF
operator||
operator|(
name|ctlr
operator|->
name|ccc
condition|?
literal|0
else|:
name|AHCI_P_IX_SDB
operator|)
operator||
name|AHCI_P_IX_DS
operator||
name|AHCI_P_IX_PS
operator||
operator|(
name|ctlr
operator|->
name|ccc
condition|?
literal|0
else|:
name|AHCI_P_IX_DHR
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|resetting
condition|)
name|callout_reset
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|,
name|hz
operator|/
literal|10
argument_list|,
name|ahci_reset_to
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
name|ahci_start
argument_list|(
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xpt_release_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_setup_fis
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|struct
name|ahci_cmd_tab
modifier|*
name|ctp
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|fis
init|=
operator|&
name|ctp
operator|->
name|cfis
index|[
literal|0
index|]
decl_stmt|;
name|bzero
argument_list|(
name|fis
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|fis
index|[
literal|0
index|]
operator|=
literal|0x27
expr_stmt|;
comment|/* host to device */
name|fis
index|[
literal|1
index|]
operator|=
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|==
name|XPT_SCSI_IO
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ATA_PACKET_CMD
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_DIR_MASK
operator|)
operator|!=
name|CAM_DIR_NONE
operator|&&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|mode
operator|>=
name|ATA_DMA
condition|)
name|fis
index|[
literal|3
index|]
operator|=
name|ATA_F_DMA
expr_stmt|;
else|else
block|{
name|fis
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>>
literal|8
expr_stmt|;
block|}
name|fis
index|[
literal|7
index|]
operator|=
name|ATA_D_LBA
expr_stmt|;
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|&
name|CAM_CDB_POINTER
operator|)
condition|?
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_ptr
else|:
name|ccb
operator|->
name|csio
operator|.
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|ctp
operator|->
name|acmd
argument_list|,
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ctp
operator|->
name|acmd
operator|+
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|,
literal|32
operator|-
name|ccb
operator|->
name|csio
operator|.
name|cdb_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_CONTROL
operator|)
operator|==
literal|0
condition|)
block|{
name|fis
index|[
literal|1
index|]
operator||=
literal|0x80
expr_stmt|;
name|fis
index|[
literal|2
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|command
expr_stmt|;
name|fis
index|[
literal|3
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features
expr_stmt|;
name|fis
index|[
literal|4
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low
expr_stmt|;
name|fis
index|[
literal|5
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid
expr_stmt|;
name|fis
index|[
literal|6
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high
expr_stmt|;
name|fis
index|[
literal|7
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|device
expr_stmt|;
name|fis
index|[
literal|8
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_low_exp
expr_stmt|;
name|fis
index|[
literal|9
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_mid_exp
expr_stmt|;
name|fis
index|[
literal|10
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|lba_high_exp
expr_stmt|;
name|fis
index|[
literal|11
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|features_exp
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|flags
operator|&
name|CAM_ATAIO_FPDMA
condition|)
block|{
name|fis
index|[
literal|12
index|]
operator|=
name|tag
operator|<<
literal|3
expr_stmt|;
block|}
else|else
block|{
name|fis
index|[
literal|12
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count
expr_stmt|;
block|}
name|fis
index|[
literal|13
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|sector_count_exp
expr_stmt|;
name|fis
index|[
literal|15
index|]
operator|=
name|ATA_A_4BIT
expr_stmt|;
block|}
else|else
block|{
name|fis
index|[
literal|15
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|cmd
operator|.
name|control
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ataio
operator|.
name|ata_flags
operator|&
name|ATA_FLAG_AUX
condition|)
block|{
name|fis
index|[
literal|16
index|]
operator|=
name|ccb
operator|->
name|ataio
operator|.
name|aux
operator|&
literal|0xff
expr_stmt|;
name|fis
index|[
literal|17
index|]
operator|=
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|aux
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fis
index|[
literal|18
index|]
operator|=
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|aux
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|fis
index|[
literal|19
index|]
operator|=
operator|(
name|ccb
operator|->
name|ataio
operator|.
name|aux
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
literal|20
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_sata_connect
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|u_int32_t
name|status
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
comment|/* Wait up to 100ms for "connect well" */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|1000
condition|;
name|timeout
operator|++
control|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|!=
name|ATA_SS_DET_NO_DEVICE
condition|)
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_ONLINE
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_SPD_MASK
operator|)
operator|!=
name|ATA_SS_SPD_NO_SPEED
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ATA_SS_IPM_MASK
operator|)
operator|==
name|ATA_SS_IPM_ACTIVE
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
name|ATA_SS_DET_MASK
operator|)
operator|==
name|ATA_SS_DET_PHY_OFFLINE
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA offline status=%08x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
operator|&&
name|timeout
operator|>=
literal|100
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>=
literal|1000
operator|||
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect timeout time=%dus status=%08x\n"
argument_list|,
name|timeout
operator|*
literal|100
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|ch
operator|->
name|dev
argument_list|,
literal|"SATA connect time=%dus status=%08x\n"
argument_list|,
name|timeout
operator|*
literal|100
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* Clear SATA error register */
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SERR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_sata_phy_reset
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|)
block|{
name|int
name|sata_rev
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|listening
condition|)
block|{
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|val
operator||=
name|AHCI_P_CMD_SUD
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ch
operator|->
name|listening
operator|=
literal|0
expr_stmt|;
block|}
name|sata_rev
operator|=
name|ch
operator|->
name|user
index|[
name|ch
operator|->
name|pm_present
condition|?
literal|15
else|:
literal|0
index|]
operator|.
name|revision
expr_stmt|;
if|if
condition|(
name|sata_rev
operator|==
literal|1
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN1
expr_stmt|;
elseif|else
if|if
condition|(
name|sata_rev
operator|==
literal|2
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN2
expr_stmt|;
elseif|else
if|if
condition|(
name|sata_rev
operator|==
literal|3
condition|)
name|val
operator|=
name|ATA_SC_SPD_SPEED_GEN3
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_RESET
operator||
name|val
operator||
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_IDLE
operator||
name|val
operator||
operator|(
operator|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|ATA_SC_IPM_DIS_PARTIAL
operator||
name|ATA_SC_IPM_DIS_SLUMBER
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahci_sata_connect
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SSS
condition|)
block|{
name|val
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AHCI_P_CMD_SUD
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_CMD
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|ch
operator|->
name|listening
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|pm_level
operator|>
literal|0
condition|)
name|ATA_OUTL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SCTL
argument_list|,
name|ATA_SC_DET_DISABLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahci_check_ids
parameter_list|(
name|struct
name|ahci_channel
modifier|*
name|ch
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
operator|(
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
operator|)
condition|?
literal|15
else|:
literal|0
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_TID_INVALID
expr_stmt|;
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_LUN_INVALID
expr_stmt|;
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahciaction
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
decl_stmt|;
name|CAM_DEBUG
argument_list|(
name|ccb
operator|->
name|ccb_h
operator|.
name|path
argument_list|,
name|CAM_DEBUG_TRACE
argument_list|,
operator|(
literal|"ahciaction func_code=%x\n"
operator|,
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|)
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
condition|)
block|{
comment|/* Common cases first */
case|case
name|XPT_ATA_IO
case|:
comment|/* Execute the requested I/O operation */
case|case
name|XPT_SCSI_IO
case|:
if|if
condition|(
name|ahci_check_ids
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ch
operator|->
name|devices
operator|==
literal|0
operator|||
operator|(
name|ch
operator|->
name|pm_present
operator|==
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|>
literal|0
operator|&&
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|<
literal|15
operator|)
condition|)
block|{
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_SEL_TIMEOUT
expr_stmt|;
break|break;
block|}
name|ccb
operator|->
name|ccb_h
operator|.
name|recovery_type
operator|=
name|RECOVERY_NONE
expr_stmt|;
comment|/* Check for command collision. */
if|if
condition|(
name|ahci_check_collision
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
comment|/* Freeze command. */
name|ch
operator|->
name|frozen
operator|=
name|ccb
expr_stmt|;
comment|/* We have only one frozen slot, so freeze simq also. */
name|xpt_freeze_simq
argument_list|(
name|ch
operator|->
name|sim
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahci_begin_transaction
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|XPT_ABORT
case|:
comment|/* Abort the specified CCB */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|XPT_SET_TRAN_SETTINGS
case|:
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ahci_device
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|ahci_check_ids
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|d
operator|=
operator|&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_REVISION
condition|)
name|d
operator|->
name|revision
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_MODE
condition|)
name|d
operator|->
name|mode
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|mode
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_BYTECOUNT
condition|)
name|d
operator|->
name|bytecount
operator|=
name|min
argument_list|(
literal|8192
argument_list|,
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bytecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_TAGS
condition|)
name|d
operator|->
name|tags
operator|=
name|min
argument_list|(
name|ch
operator|->
name|numslots
argument_list|,
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|tags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_PM
condition|)
name|ch
operator|->
name|pm_present
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_ATAPI
condition|)
name|d
operator|->
name|atapi
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|atapi
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|&
name|CTS_SATA_VALID_CAPS
condition|)
name|d
operator|->
name|caps
operator|=
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_GET_TRAN_SETTINGS
case|:
comment|/* Get default/user set transfer settings for the target */
block|{
name|struct
name|ccb_trans_settings
modifier|*
name|cts
init|=
operator|&
name|ccb
operator|->
name|cts
decl_stmt|;
name|struct
name|ahci_device
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|ahci_check_ids
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
condition|)
return|return;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
condition|)
name|d
operator|=
operator|&
name|ch
operator|->
name|curr
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
else|else
name|d
operator|=
operator|&
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
expr_stmt|;
name|cts
operator|->
name|protocol
operator|=
name|PROTO_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cts
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cts
operator|->
name|proto_specific
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cts
operator|->
name|type
operator|==
name|CTS_TYPE_CURRENT_SETTINGS
operator|&&
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|15
operator|||
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|==
literal|0
operator|&&
operator|!
name|ch
operator|->
name|pm_present
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_SSTS
argument_list|)
operator|&
name|ATA_SS_SPD_MASK
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x0f0
condition|)
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
operator|=
operator|(
name|status
operator|&
literal|0x0f0
operator|)
operator|>>
literal|4
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
block|}
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|=
name|d
operator|->
name|caps
operator|&
name|CTS_SATA_CAPS_D
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|pm_level
condition|)
block|{
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
operator|(
name|AHCI_CAP_PSC
operator||
name|AHCI_CAP_SSC
operator|)
condition|)
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_PMREQ
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps2
operator|&
name|AHCI_CAP2_APST
condition|)
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_APST
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
operator|)
operator|&&
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOAA
operator|)
operator|==
literal|0
condition|)
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_DMAAA
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator||=
name|CTS_SATA_CAPS_H_AN
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|&=
name|ch
operator|->
name|user
index|[
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
index|]
operator|.
name|caps
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_CAPS
expr_stmt|;
block|}
else|else
block|{
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|revision
operator|=
name|d
operator|->
name|revision
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_REVISION
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|caps
operator|=
name|d
operator|->
name|caps
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_CAPS
expr_stmt|;
block|}
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|mode
operator|=
name|d
operator|->
name|mode
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_MODE
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|bytecount
operator|=
name|d
operator|->
name|bytecount
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_BYTECOUNT
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|pm_present
operator|=
name|ch
operator|->
name|pm_present
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_PM
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|tags
operator|=
name|d
operator|->
name|tags
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_TAGS
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|atapi
operator|=
name|d
operator|->
name|atapi
expr_stmt|;
name|cts
operator|->
name|xport_specific
operator|.
name|sata
operator|.
name|valid
operator||=
name|CTS_SATA_VALID_ATAPI
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
case|case
name|XPT_RESET_BUS
case|:
comment|/* Reset the specified SCSI bus */
case|case
name|XPT_RESET_DEV
case|:
comment|/* Bus Device Reset the specified SCSI device */
name|ahci_reset
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
case|case
name|XPT_TERM_IO
case|:
comment|/* Terminate the I/O process */
comment|/* XXX Implement */
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
case|case
name|XPT_PATH_INQ
case|:
comment|/* Path routing inquiry */
block|{
name|struct
name|ccb_pathinq
modifier|*
name|cpi
init|=
operator|&
name|ccb
operator|->
name|cpi
decl_stmt|;
name|cpi
operator|->
name|version_num
operator|=
literal|1
expr_stmt|;
comment|/* XXX??? */
name|cpi
operator|->
name|hba_inquiry
operator|=
name|PI_SDTR_ABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SNCQ
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_TAG_ABLE
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
condition|)
name|cpi
operator|->
name|hba_inquiry
operator||=
name|PI_SATAPM
expr_stmt|;
name|cpi
operator|->
name|target_sprt
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|hba_misc
operator|=
name|PIM_SEQSCAN
operator||
name|PIM_UNMAPPED
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_NOAUX
operator|)
operator|==
literal|0
condition|)
name|cpi
operator|->
name|hba_misc
operator||=
name|PIM_ATA_EXT
expr_stmt|;
name|cpi
operator|->
name|hba_eng_cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|caps
operator|&
name|AHCI_CAP_SPM
condition|)
name|cpi
operator|->
name|max_target
operator|=
literal|15
expr_stmt|;
else|else
name|cpi
operator|->
name|max_target
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|max_lun
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|initiator_id
operator|=
literal|0
expr_stmt|;
name|cpi
operator|->
name|bus_id
operator|=
name|cam_sim_bus
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|base_transfer_speed
operator|=
literal|150000
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|sim_vid
argument_list|,
literal|"FreeBSD"
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|hba_vid
argument_list|,
literal|"AHCI"
argument_list|,
name|HBA_IDLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|cpi
operator|->
name|dev_name
argument_list|,
name|cam_sim_name
argument_list|(
name|sim
argument_list|)
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|unit_number
operator|=
name|cam_sim_unit
argument_list|(
name|sim
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|transport
operator|=
name|XPORT_SATA
expr_stmt|;
name|cpi
operator|->
name|transport_version
operator|=
name|XPORT_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|protocol
operator|=
name|PROTO_ATA
expr_stmt|;
name|cpi
operator|->
name|protocol_version
operator|=
name|PROTO_VERSION_UNSPECIFIED
expr_stmt|;
name|cpi
operator|->
name|maxio
operator|=
name|MAXPHYS
expr_stmt|;
comment|/* ATI SB600 can't handle 256 sectors with FPDMA (NCQ). */
if|if
condition|(
name|ch
operator|->
name|quirks
operator|&
name|AHCI_Q_MAXIO_64K
condition|)
name|cpi
operator|->
name|maxio
operator|=
name|min
argument_list|(
name|cpi
operator|->
name|maxio
argument_list|,
literal|128
operator|*
literal|512
argument_list|)
expr_stmt|;
name|cpi
operator|->
name|hba_vendor
operator|=
name|ch
operator|->
name|vendorid
expr_stmt|;
name|cpi
operator|->
name|hba_device
operator|=
name|ch
operator|->
name|deviceid
expr_stmt|;
name|cpi
operator|->
name|hba_subvendor
operator|=
name|ch
operator|->
name|subvendorid
expr_stmt|;
name|cpi
operator|->
name|hba_subdevice
operator|=
name|ch
operator|->
name|subdeviceid
expr_stmt|;
name|cpi
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_CMP
expr_stmt|;
break|break;
block|}
default|default:
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|=
name|CAM_REQ_INVALID
expr_stmt|;
break|break;
block|}
name|ahci_done
argument_list|(
name|ch
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcipoll
parameter_list|(
name|struct
name|cam_sim
modifier|*
name|sim
parameter_list|)
block|{
name|struct
name|ahci_channel
modifier|*
name|ch
init|=
operator|(
expr|struct
name|ahci_channel
operator|*
operator|)
name|cam_sim_softc
argument_list|(
name|sim
argument_list|)
decl_stmt|;
name|uint32_t
name|istatus
decl_stmt|;
comment|/* Read interrupt statuses and process if any. */
name|istatus
operator|=
name|ATA_INL
argument_list|(
name|ch
operator|->
name|r_mem
argument_list|,
name|AHCI_P_IS
argument_list|)
expr_stmt|;
if|if
condition|(
name|istatus
operator|!=
literal|0
condition|)
name|ahci_ch_intr_main
argument_list|(
name|ch
argument_list|,
name|istatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|resetting
operator|!=
literal|0
operator|&&
operator|(
operator|--
name|ch
operator|->
name|resetpolldiv
operator|<=
literal|0
operator|||
operator|!
name|callout_pending
argument_list|(
operator|&
name|ch
operator|->
name|reset_timer
argument_list|)
operator|)
condition|)
block|{
name|ch
operator|->
name|resetpolldiv
operator|=
literal|1000
expr_stmt|;
name|ahci_reset_to
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ahci
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ahci
argument_list|,
name|cam
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

