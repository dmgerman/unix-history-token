begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: atk0110.c,v 1.4 2010/02/11 06:54:57 cnst Exp $	*/
end_comment

begin_comment
comment|/*	$OpenBSD: atk0110.c,v 1.1 2009/07/23 01:38:16 cnst Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2009, 2010 Constantine A. Murenin<cnst++@FreeBSD.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * ASUSTeK AI Booster (ACPI ASOC ATK0110).  *  * This code was originally written for OpenBSD after the techniques  * described in the Linux's asus_atk0110.c and FreeBSD's Takanori Watanabe's  * acpi_aiboost.c were verified to be accurate on the actual hardware kindly  * provided by Sam Fourman Jr.  It was subsequently ported from OpenBSD to  * DragonFly BSD, to NetBSD's sysmon_envsys(9) and to FreeBSD's sysctl(9).  *  *				  -- Constantine A. Murenin<http://cnst.su/>  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_OEM
end_define

begin_expr_stmt
name|ACPI_MODULE_NAME
argument_list|(
literal|"aibs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|aibs
argument_list|,
literal|"aibs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AIBS_MORE_SENSORS
end_define

begin_define
define|#
directive|define
name|AIBS_VERBOSE
end_define

begin_enum
enum|enum
name|aibs_type
block|{
name|AIBS_VOLT
block|,
name|AIBS_TEMP
block|,
name|AIBS_FAN
block|}
enum|;
end_enum

begin_struct
struct|struct
name|aibs_sensor
block|{
name|ACPI_INTEGER
name|v
decl_stmt|;
name|ACPI_INTEGER
name|i
decl_stmt|;
name|ACPI_INTEGER
name|l
decl_stmt|;
name|ACPI_INTEGER
name|h
decl_stmt|;
name|enum
name|aibs_type
name|t
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aibs_softc
block|{
name|struct
name|device
modifier|*
name|sc_dev
decl_stmt|;
name|ACPI_HANDLE
name|sc_ah
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_volt
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_temp
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_fan
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|aibs_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aibs_attach_sif
parameter_list|(
name|struct
name|aibs_softc
modifier|*
parameter_list|,
name|enum
name|aibs_type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|aibs_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|aibs_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|aibs_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|aibs_detach
argument_list|)
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|aibs_driver
init|=
block|{
literal|"aibs"
block|,
name|aibs_methods
block|,
expr|sizeof
operator|(
expr|struct
name|aibs_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|aibs_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|aibs
argument_list|,
name|acpi
argument_list|,
name|aibs_driver
argument_list|,
name|aibs_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aibs_hids
index|[]
init|=
block|{
literal|"ATK0110"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|aibs_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"aibs"
argument_list|)
operator|||
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|aibs_hids
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ASUSTeK AI Booster (ACPI ASOC ATK0110)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_ah
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|aibs_attach_sif
argument_list|(
name|sc
argument_list|,
name|AIBS_VOLT
argument_list|)
expr_stmt|;
name|aibs_attach_sif
argument_list|(
name|sc
argument_list|,
name|AIBS_TEMP
argument_list|)
expr_stmt|;
name|aibs_attach_sif
argument_list|(
name|sc
argument_list|,
name|AIBS_FAN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aibs_attach_sif
parameter_list|(
name|struct
name|aibs_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|aibs_type
name|st
parameter_list|)
block|{
name|ACPI_STATUS
name|s
decl_stmt|;
name|ACPI_BUFFER
name|b
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|bp
decl_stmt|,
modifier|*
name|o
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|node
decl_stmt|;
name|char
name|name
index|[]
init|=
literal|"?SIF"
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|as
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|so
decl_stmt|;
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|AIBS_VOLT
case|:
name|node
operator|=
literal|"volt"
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'V'
expr_stmt|;
break|break;
case|case
name|AIBS_TEMP
case|:
name|node
operator|=
literal|"temp"
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'T'
expr_stmt|;
break|break;
case|case
name|AIBS_FAN
case|:
name|node
operator|=
literal|"fan"
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'F'
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|b
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|s
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|b
argument_list|,
name|ACPI_TYPE_PACKAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|=
name|b
operator|.
name|Pointer
expr_stmt|;
name|o
operator|=
name|bp
operator|->
name|Package
operator|.
name|Elements
expr_stmt|;
if|if
condition|(
name|o
index|[
literal|0
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s[0]: invalid type\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|o
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
operator|<
name|n
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid package\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
operator|>
name|n
condition|)
block|{
name|int
name|on
init|=
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|AIBS_MORE_SENSORS
name|n
operator|=
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: malformed package: %i/%i"
literal|", assume %i\n"
argument_list|,
name|name
argument_list|,
name|on
argument_list|,
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: no members in the package\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return;
block|}
name|as
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|as
argument_list|)
operator|*
name|n
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: malloc fail\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|AIBS_VOLT
case|:
name|sc
operator|->
name|sc_asens_volt
operator|=
name|as
expr_stmt|;
break|break;
case|case
name|AIBS_TEMP
case|:
name|sc
operator|->
name|sc_asens_temp
operator|=
name|as
expr_stmt|;
break|break;
case|case
name|AIBS_FAN
case|:
name|sc
operator|->
name|sc_asens_fan
operator|=
name|as
expr_stmt|;
break|break;
block|}
comment|/* sysctl subtree for sensors of this type */
name|so
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
argument_list|,
name|st
argument_list|,
name|node
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|o
operator|++
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|o
operator|++
control|)
block|{
name|ACPI_OBJECT
modifier|*
name|oi
decl_stmt|;
name|char
name|si
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* acpica5 automatically evaluates the referenced package */
if|if
condition|(
name|o
index|[
literal|0
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %i: not a package: %i type\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|,
name|o
index|[
literal|0
index|]
operator|.
name|Type
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|oi
operator|=
name|o
index|[
literal|0
index|]
operator|.
name|Package
operator|.
name|Elements
expr_stmt|;
if|if
condition|(
name|o
index|[
literal|0
index|]
operator|.
name|Package
operator|.
name|Count
operator|!=
literal|5
operator|||
name|oi
index|[
literal|0
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|oi
index|[
literal|1
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_STRING
operator|||
name|oi
index|[
literal|2
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|oi
index|[
literal|3
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|oi
index|[
literal|4
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %i: invalid package\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|as
index|[
name|i
index|]
operator|.
name|i
operator|=
name|oi
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
name|desc
operator|=
name|oi
index|[
literal|1
index|]
operator|.
name|String
operator|.
name|Pointer
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|l
operator|=
name|oi
index|[
literal|2
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|h
operator|=
name|oi
index|[
literal|3
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
name|as
index|[
name|i
index|]
operator|.
name|t
operator|=
name|st
expr_stmt|;
ifdef|#
directive|ifdef
name|AIBS_VERBOSE
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%c%i: "
literal|"0x%08"
name|PRIx64
literal|" %20s %5"
name|PRIi64
literal|" / %5"
name|PRIi64
literal|"  "
literal|"0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|name
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|as
index|[
name|i
index|]
operator|.
name|i
argument_list|,
name|desc
argument_list|,
operator|(
name|int64_t
operator|)
name|as
index|[
name|i
index|]
operator|.
name|l
argument_list|,
operator|(
name|int64_t
operator|)
name|as
index|[
name|i
index|]
operator|.
name|h
argument_list|,
name|oi
index|[
literal|4
index|]
operator|.
name|Integer
operator|.
name|Value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|snprintf
argument_list|(
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
literal|"%i"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|so
argument_list|)
argument_list|,
name|i
argument_list|,
name|si
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|st
argument_list|,
name|aibs_sysctl
argument_list|,
name|st
operator|==
name|AIBS_TEMP
condition|?
literal|"IK"
else|:
literal|"I"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_volt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_volt
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_temp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_temp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_fan
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_fan
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AIBS_VERBOSE
end_ifdef

begin_define
define|#
directive|define
name|ddevice_printf
parameter_list|(
name|x
modifier|...
parameter_list|)
value|device_printf(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ddevice_printf
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|aibs_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|enum
name|aibs_type
name|st
init|=
name|arg2
decl_stmt|;
name|int
name|i
init|=
name|oidp
operator|->
name|oid_number
decl_stmt|;
name|ACPI_STATUS
name|rs
decl_stmt|;
name|ACPI_OBJECT
name|p
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|ACPI_OBJECT_LIST
name|mp
decl_stmt|;
name|ACPI_BUFFER
name|b
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|as
decl_stmt|;
name|ACPI_INTEGER
name|v
decl_stmt|,
name|l
decl_stmt|,
name|h
decl_stmt|;
name|int
name|so
index|[
literal|3
index|]
decl_stmt|;
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|AIBS_VOLT
case|:
name|name
operator|=
literal|"RVLT"
expr_stmt|;
name|as
operator|=
name|sc
operator|->
name|sc_asens_volt
expr_stmt|;
break|break;
case|case
name|AIBS_TEMP
case|:
name|name
operator|=
literal|"RTMP"
expr_stmt|;
name|as
operator|=
name|sc
operator|->
name|sc_asens_temp
expr_stmt|;
break|break;
case|case
name|AIBS_FAN
case|:
name|name
operator|=
literal|"RFAN"
expr_stmt|;
name|as
operator|=
name|sc
operator|->
name|sc_asens_fan
expr_stmt|;
break|break;
default|default:
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
name|as
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
name|l
operator|=
name|as
index|[
name|i
index|]
operator|.
name|l
expr_stmt|;
name|h
operator|=
name|as
index|[
name|i
index|]
operator|.
name|h
expr_stmt|;
name|p
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|p
operator|.
name|Integer
operator|.
name|Value
operator|=
name|as
index|[
name|i
index|]
operator|.
name|i
expr_stmt|;
name|mp
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|mp
operator|.
name|Pointer
operator|=
operator|&
name|p
expr_stmt|;
name|b
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|name
argument_list|,
operator|&
name|mp
argument_list|,
operator|&
name|b
argument_list|,
name|ACPI_TYPE_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|rs
argument_list|)
condition|)
block|{
name|ddevice_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %i: evaluation failed\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
name|bp
operator|=
name|b
operator|.
name|Pointer
expr_stmt|;
name|v
operator|=
name|bp
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|AIBS_VOLT
case|:
break|break;
case|case
name|AIBS_TEMP
case|:
name|v
operator|+=
literal|2732
expr_stmt|;
name|l
operator|+=
literal|2732
expr_stmt|;
name|h
operator|+=
literal|2732
expr_stmt|;
break|break;
case|case
name|AIBS_FAN
case|:
break|break;
block|}
name|so
index|[
literal|0
index|]
operator|=
name|v
expr_stmt|;
name|so
index|[
literal|1
index|]
operator|=
name|l
expr_stmt|;
name|so
index|[
literal|2
index|]
operator|=
name|h
expr_stmt|;
return|return
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

end_unit

