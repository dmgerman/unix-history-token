begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: atk0110.c,v 1.4 2010/02/11 06:54:57 cnst Exp $	*/
end_comment

begin_comment
comment|/*	$OpenBSD: atk0110.c,v 1.1 2009/07/23 01:38:16 cnst Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2009, 2010 Constantine A. Murenin<cnst++@FreeBSD.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_comment
comment|/*  * ASUSTeK AI Booster (ACPI ASOC ATK0110).  *  * This code was originally written for OpenBSD after the techniques  * described in the Linux's asus_atk0110.c and FreeBSD's Takanori Watanabe's  * acpi_aiboost.c were verified to be accurate on the actual hardware kindly  * provided by Sam Fourman Jr.  It was subsequently ported from OpenBSD to  * DragonFly BSD, to NetBSD's sysmon_envsys(9) and to FreeBSD's sysctl(9).  *  *				  -- Constantine A. Murenin<http://cnst.su/>  */
end_comment

begin_define
define|#
directive|define
name|_COMPONENT
value|ACPI_OEM
end_define

begin_expr_stmt
name|ACPI_MODULE_NAME
argument_list|(
literal|"aibs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ACPI_SERIAL_DECL
argument_list|(
name|aibs
argument_list|,
literal|"aibs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AIBS_MORE_SENSORS
end_define

begin_define
define|#
directive|define
name|AIBS_VERBOSE
end_define

begin_define
define|#
directive|define
name|AIBS_GROUP_SENSORS
value|0x06
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 16)& 0xff)
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE_VOLT
value|2
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE_TEMP
value|3
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE_FAN
value|4
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE_VOLT_NAME
value|"volt"
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE_VOLT_TEMP
value|"temp"
end_define

begin_define
define|#
directive|define
name|AIBS_SENS_TYPE_VOLT_FAN
value|"fan"
end_define

begin_struct
struct|struct
name|aibs_sensor
block|{
name|ACPI_INTEGER
name|v
decl_stmt|;
name|ACPI_INTEGER
name|i
decl_stmt|;
name|ACPI_INTEGER
name|l
decl_stmt|;
name|ACPI_INTEGER
name|h
decl_stmt|;
name|int
name|t
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aibs_softc
block|{
name|struct
name|device
modifier|*
name|sc_dev
decl_stmt|;
name|ACPI_HANDLE
name|sc_ah
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_volt
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_temp
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_fan
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sc_asens_all
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sc_volt_sysctl
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sc_temp_sysctl
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sc_fan_sysctl
decl_stmt|;
name|bool
name|sc_ggrp_method
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|aibs_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_sysctl_ggrp
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_attach_ggrp
parameter_list|(
name|struct
name|aibs_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|aibs_attach_sif
parameter_list|(
name|struct
name|aibs_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|aibs_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|aibs_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|aibs_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|aibs_detach
argument_list|)
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|aibs_driver
init|=
block|{
literal|"aibs"
block|,
name|aibs_methods
block|,
expr|sizeof
operator|(
expr|struct
name|aibs_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|aibs_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|aibs
argument_list|,
name|acpi
argument_list|,
name|aibs_driver
argument_list|,
name|aibs_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|aibs
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|aibs_hids
index|[]
init|=
block|{
literal|"ATK0110"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|aibs_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"aibs"
argument_list|)
operator|||
name|ACPI_ID_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|aibs_hids
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ASUSTeK AI Booster (ACPI ASOC ATK0110)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_ah
operator|=
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ggrp_method
operator|=
name|false
expr_stmt|;
name|err
operator|=
name|aibs_attach_sif
argument_list|(
name|sc
argument_list|,
name|AIBS_SENS_TYPE_VOLT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|aibs_attach_sif
argument_list|(
name|sc
argument_list|,
name|AIBS_SENS_TYPE_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|aibs_attach_sif
argument_list|(
name|sc
argument_list|,
name|AIBS_SENS_TYPE_FAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Clean up whatever was allocated earlier. */
if|if
condition|(
name|sc
operator|->
name|sc_volt_sysctl
operator|!=
name|NULL
condition|)
name|sysctl_remove_oid
argument_list|(
name|sc
operator|->
name|sc_volt_sysctl
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_temp_sysctl
operator|!=
name|NULL
condition|)
name|sysctl_remove_oid
argument_list|(
name|sc
operator|->
name|sc_temp_sysctl
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_fan_sysctl
operator|!=
name|NULL
condition|)
name|sysctl_remove_oid
argument_list|(
name|sc
operator|->
name|sc_fan_sysctl
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|aibs_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ggrp_method
operator|=
name|true
expr_stmt|;
name|err
operator|=
name|aibs_attach_ggrp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_add_sensor
parameter_list|(
name|struct
name|aibs_softc
modifier|*
name|sc
parameter_list|,
name|ACPI_OBJECT
modifier|*
name|o
parameter_list|,
name|struct
name|aibs_sensor
modifier|*
name|sensor
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|descr
parameter_list|)
block|{
name|int
name|off
decl_stmt|;
comment|/* 	 * Packages for the old and new methods are quite 	 * similar except that the new package has two 	 * new (unknown / unused) fields after the name field. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_ggrp_method
condition|)
name|off
operator|=
literal|4
expr_stmt|;
else|else
name|off
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|Type
operator|!=
name|ACPI_TYPE_PACKAGE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"sensor object is not a package: %i type\n"
argument_list|,
name|o
operator|->
name|Type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|o
index|[
literal|0
index|]
operator|.
name|Package
operator|.
name|Count
operator|!=
operator|(
name|off
operator|+
literal|3
operator|)
operator|||
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
literal|1
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_STRING
operator|||
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
name|off
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
name|off
operator|+
literal|1
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
operator|||
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
name|off
operator|+
literal|2
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected package content\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sensor
operator|->
name|i
operator|=
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
operator|*
name|descr
operator|=
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
literal|1
index|]
operator|.
name|String
operator|.
name|Pointer
expr_stmt|;
name|sensor
operator|->
name|l
operator|=
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
name|off
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
name|sensor
operator|->
name|h
operator|=
name|o
operator|->
name|Package
operator|.
name|Elements
index|[
name|off
operator|+
literal|1
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
comment|/* For the new method the second value is a range size. */
if|if
condition|(
name|sc
operator|->
name|sc_ggrp_method
condition|)
name|sensor
operator|->
name|h
operator|+=
name|sensor
operator|->
name|l
expr_stmt|;
name|sensor
operator|->
name|t
operator|=
name|AIBS_SENS_TYPE
argument_list|(
name|sensor
operator|->
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sensor
operator|->
name|t
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
case|case
name|AIBS_SENS_TYPE_FAN
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown sensor type 0x%x"
argument_list|,
name|sensor
operator|->
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aibs_sensor_added
parameter_list|(
name|struct
name|aibs_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sysctl_oid
modifier|*
name|so
parameter_list|,
specifier|const
name|char
modifier|*
name|type_name
parameter_list|,
name|int
name|idx
parameter_list|,
name|struct
name|aibs_sensor
modifier|*
name|sensor
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|)
block|{
name|char
name|sysctl_name
index|[
literal|8
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|sysctl_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sysctl_name
argument_list|)
argument_list|,
literal|"%i"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AIBS_VERBOSE
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%c%i: 0x%08jx %20s %5jd / %5jd\n"
argument_list|,
name|type_name
index|[
literal|0
index|]
argument_list|,
name|idx
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sensor
operator|->
name|i
argument_list|,
name|descr
argument_list|,
operator|(
name|intmax_t
operator|)
name|sensor
operator|->
name|l
argument_list|,
operator|(
name|intmax_t
operator|)
name|sensor
operator|->
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|so
argument_list|)
argument_list|,
name|idx
argument_list|,
name|sysctl_name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sensor
argument_list|,
name|sc
operator|->
name|sc_ggrp_method
condition|?
name|aibs_sysctl_ggrp
else|:
name|aibs_sysctl
argument_list|,
name|sensor
operator|->
name|t
operator|==
name|AIBS_SENS_TYPE_TEMP
condition|?
literal|"IK"
else|:
literal|"I"
argument_list|,
name|descr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_attach_ggrp
parameter_list|(
name|struct
name|aibs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|ACPI_STATUS
name|s
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_HANDLE
name|h
decl_stmt|;
name|ACPI_OBJECT
name|id
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|bp
decl_stmt|;
name|ACPI_OBJECT_LIST
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|t
decl_stmt|,
name|v
decl_stmt|,
name|f
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
modifier|*
name|s_idx
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|descr
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sensor
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
modifier|*
name|so
decl_stmt|;
comment|/* First see if GITM is available. */
name|s
operator|=
name|AcpiGetHandle
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|"GITM"
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"GITM not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Now call GGRP with the appropriate argument to list sensors. 	 * The method lists different groups of entities depending on 	 * the argument. 	 */
name|id
operator|.
name|Integer
operator|.
name|Value
operator|=
name|AIBS_GROUP_SENSORS
expr_stmt|;
name|id
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|arg
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|arg
operator|.
name|Pointer
operator|=
operator|&
name|id
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|s
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|"GGRP"
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|buf
argument_list|,
name|ACPI_TYPE_PACKAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"GGRP not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bp
operator|=
name|buf
operator|.
name|Pointer
expr_stmt|;
name|sc
operator|->
name|sc_asens_all
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_asens_all
argument_list|)
operator|*
name|bp
operator|->
name|Package
operator|.
name|Count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|v
operator|=
name|t
operator|=
name|f
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|Package
operator|.
name|Count
condition|;
name|i
operator|++
control|)
block|{
name|sensor
operator|=
operator|&
name|sc
operator|->
name|sc_asens_all
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|aibs_add_sensor
argument_list|(
name|sc
argument_list|,
operator|&
name|bp
operator|->
name|Package
operator|.
name|Elements
index|[
name|i
index|]
argument_list|,
name|sensor
argument_list|,
operator|&
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|sensor
operator|->
name|t
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
name|name
operator|=
literal|"volt"
expr_stmt|;
name|so
operator|=
operator|&
name|sc
operator|->
name|sc_volt_sysctl
expr_stmt|;
name|s_idx
operator|=
operator|&
name|v
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
name|name
operator|=
literal|"temp"
expr_stmt|;
name|so
operator|=
operator|&
name|sc
operator|->
name|sc_temp_sysctl
expr_stmt|;
name|s_idx
operator|=
operator|&
name|t
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_FAN
case|:
name|name
operator|=
literal|"fan"
expr_stmt|;
name|so
operator|=
operator|&
name|sc
operator|->
name|sc_fan_sysctl
expr_stmt|;
name|s_idx
operator|=
operator|&
name|f
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"add_sensor succeeded for unknown sensor type %d"
argument_list|,
name|sensor
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|so
operator|==
name|NULL
condition|)
block|{
comment|/* sysctl subtree for sensors of this type */
operator|*
name|so
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
argument_list|,
name|sensor
operator|->
name|t
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|aibs_sensor_added
argument_list|(
name|sc
argument_list|,
operator|*
name|so
argument_list|,
name|name
argument_list|,
operator|*
name|s_idx
argument_list|,
name|sensor
argument_list|,
name|descr
argument_list|)
expr_stmt|;
operator|*
name|s_idx
operator|+=
literal|1
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_attach_sif
parameter_list|(
name|struct
name|aibs_softc
modifier|*
name|sc
parameter_list|,
name|int
name|st
parameter_list|)
block|{
name|char
name|name
index|[]
init|=
literal|"?SIF"
decl_stmt|;
name|ACPI_STATUS
name|s
decl_stmt|;
name|ACPI_BUFFER
name|b
decl_stmt|;
name|ACPI_OBJECT
modifier|*
name|bp
decl_stmt|,
modifier|*
name|o
decl_stmt|;
specifier|const
name|char
modifier|*
name|node
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|as
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
modifier|*
name|so
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
name|node
operator|=
literal|"volt"
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'V'
expr_stmt|;
name|so
operator|=
operator|&
name|sc
operator|->
name|sc_volt_sysctl
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
name|node
operator|=
literal|"temp"
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'T'
expr_stmt|;
name|so
operator|=
operator|&
name|sc
operator|->
name|sc_temp_sysctl
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_FAN
case|:
name|node
operator|=
literal|"fan"
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'F'
expr_stmt|;
name|so
operator|=
operator|&
name|sc
operator|->
name|sc_fan_sysctl
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unsupported sensor type %d"
argument_list|,
name|st
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|s
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
operator|&
name|b
argument_list|,
name|ACPI_TYPE_PACKAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bp
operator|=
name|b
operator|.
name|Pointer
expr_stmt|;
name|o
operator|=
name|bp
operator|->
name|Package
operator|.
name|Elements
expr_stmt|;
if|if
condition|(
name|o
index|[
literal|0
index|]
operator|.
name|Type
operator|!=
name|ACPI_TYPE_INTEGER
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s[0]: invalid type\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|n
operator|=
name|o
index|[
literal|0
index|]
operator|.
name|Integer
operator|.
name|Value
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
operator|<
name|n
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: invalid package\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
operator|>
name|n
condition|)
block|{
name|int
name|on
init|=
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|AIBS_MORE_SENSORS
name|n
operator|=
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: malformed package: %i/%i"
literal|", assume %i\n"
argument_list|,
name|name
argument_list|,
name|on
argument_list|,
name|bp
operator|->
name|Package
operator|.
name|Count
operator|-
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: no members in the package\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|as
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|as
argument_list|)
operator|*
name|n
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
name|sc
operator|->
name|sc_asens_volt
operator|=
name|as
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
name|sc
operator|->
name|sc_asens_temp
operator|=
name|as
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_FAN
case|:
name|sc
operator|->
name|sc_asens_fan
operator|=
name|as
expr_stmt|;
break|break;
block|}
comment|/* sysctl subtree for sensors of this type */
operator|*
name|so
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
argument_list|,
name|st
argument_list|,
name|node
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|o
operator|++
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|o
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|descr
decl_stmt|;
name|err
operator|=
name|aibs_add_sensor
argument_list|(
name|sc
argument_list|,
name|o
argument_list|,
operator|&
name|as
index|[
name|i
index|]
argument_list|,
operator|&
name|descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|aibs_sensor_added
argument_list|(
name|sc
argument_list|,
operator|*
name|so
argument_list|,
name|node
argument_list|,
name|i
argument_list|,
operator|&
name|as
index|[
name|i
index|]
argument_list|,
name|descr
argument_list|)
expr_stmt|;
block|}
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_volt
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_volt
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_temp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_temp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_fan
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_fan
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_asens_all
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|sc_asens_all
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AIBS_VERBOSE
end_ifdef

begin_define
define|#
directive|define
name|ddevice_printf
parameter_list|(
name|x
modifier|...
parameter_list|)
value|device_printf(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ddevice_printf
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|aibs_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sensor
init|=
operator|(
name|void
operator|*
operator|)
name|arg2
decl_stmt|;
name|int
name|i
init|=
name|oidp
operator|->
name|oid_number
decl_stmt|;
name|ACPI_STATUS
name|rs
decl_stmt|;
name|ACPI_OBJECT
name|p
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|ACPI_OBJECT_LIST
name|mp
decl_stmt|;
name|ACPI_BUFFER
name|b
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|ACPI_INTEGER
name|v
decl_stmt|,
name|l
decl_stmt|,
name|h
decl_stmt|;
name|int
name|so
index|[
literal|3
index|]
decl_stmt|;
switch|switch
condition|(
name|sensor
operator|->
name|t
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
name|name
operator|=
literal|"RVLT"
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
name|name
operator|=
literal|"RTMP"
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_FAN
case|:
name|name
operator|=
literal|"RFAN"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|l
operator|=
name|sensor
operator|->
name|l
expr_stmt|;
name|h
operator|=
name|sensor
operator|->
name|h
expr_stmt|;
name|p
operator|.
name|Type
operator|=
name|ACPI_TYPE_INTEGER
expr_stmt|;
name|p
operator|.
name|Integer
operator|.
name|Value
operator|=
name|sensor
operator|->
name|i
expr_stmt|;
name|mp
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|mp
operator|.
name|Pointer
operator|=
operator|&
name|p
expr_stmt|;
name|b
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
name|name
argument_list|,
operator|&
name|mp
argument_list|,
operator|&
name|b
argument_list|,
name|ACPI_TYPE_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|rs
argument_list|)
condition|)
block|{
name|ddevice_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: %i: evaluation failed\n"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|bp
operator|=
name|b
operator|.
name|Pointer
expr_stmt|;
name|v
operator|=
name|bp
operator|->
name|Integer
operator|.
name|Value
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|b
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sensor
operator|->
name|t
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
break|break;
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
name|v
operator|+=
literal|2732
expr_stmt|;
name|l
operator|+=
literal|2732
expr_stmt|;
name|h
operator|+=
literal|2732
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_FAN
case|:
break|break;
block|}
name|so
index|[
literal|0
index|]
operator|=
name|v
expr_stmt|;
name|so
index|[
literal|1
index|]
operator|=
name|l
expr_stmt|;
name|so
index|[
literal|2
index|]
operator|=
name|h
expr_stmt|;
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aibs_sysctl_ggrp
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|aibs_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|struct
name|aibs_sensor
modifier|*
name|sensor
init|=
operator|(
name|void
operator|*
operator|)
name|arg2
decl_stmt|;
name|ACPI_STATUS
name|rs
decl_stmt|;
name|ACPI_OBJECT
name|p
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|ACPI_OBJECT_LIST
name|arg
decl_stmt|;
name|ACPI_BUFFER
name|buf
decl_stmt|;
name|ACPI_INTEGER
name|v
decl_stmt|,
name|l
decl_stmt|,
name|h
decl_stmt|;
name|int
name|so
index|[
literal|3
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|ret
decl_stmt|;
name|uint32_t
name|cmd
index|[
literal|3
index|]
decl_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|sensor
operator|->
name|i
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|Type
operator|=
name|ACPI_TYPE_BUFFER
expr_stmt|;
name|p
operator|.
name|Buffer
operator|.
name|Pointer
operator|=
operator|(
name|void
operator|*
operator|)
name|cmd
expr_stmt|;
name|p
operator|.
name|Buffer
operator|.
name|Length
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|arg
operator|.
name|Count
operator|=
literal|1
expr_stmt|;
name|arg
operator|.
name|Pointer
operator|=
operator|&
name|p
expr_stmt|;
name|buf
operator|.
name|Pointer
operator|=
name|NULL
expr_stmt|;
name|buf
operator|.
name|Length
operator|=
name|ACPI_ALLOCATE_BUFFER
expr_stmt|;
name|ACPI_SERIAL_BEGIN
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
name|rs
operator|=
name|AcpiEvaluateObjectTyped
argument_list|(
name|sc
operator|->
name|sc_ah
argument_list|,
literal|"GITM"
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|buf
argument_list|,
name|ACPI_TYPE_BUFFER
argument_list|)
expr_stmt|;
name|ACPI_SERIAL_END
argument_list|(
name|aibs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|rs
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"GITM evaluation failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|bp
operator|=
name|buf
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|Buffer
operator|.
name|Length
operator|<
literal|8
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"GITM returned short buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ret
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|bp
operator|->
name|Buffer
operator|.
name|Pointer
expr_stmt|;
if|if
condition|(
name|ret
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"GITM returned error status\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|v
operator|=
name|ret
index|[
literal|1
index|]
expr_stmt|;
name|AcpiOsFree
argument_list|(
name|buf
operator|.
name|Pointer
argument_list|)
expr_stmt|;
name|l
operator|=
name|sensor
operator|->
name|l
expr_stmt|;
name|h
operator|=
name|sensor
operator|->
name|h
expr_stmt|;
switch|switch
condition|(
name|sensor
operator|->
name|t
condition|)
block|{
case|case
name|AIBS_SENS_TYPE_VOLT
case|:
break|break;
case|case
name|AIBS_SENS_TYPE_TEMP
case|:
name|v
operator|+=
literal|2731
expr_stmt|;
name|l
operator|+=
literal|2731
expr_stmt|;
name|h
operator|+=
literal|2731
expr_stmt|;
break|break;
case|case
name|AIBS_SENS_TYPE_FAN
case|:
break|break;
block|}
name|so
index|[
literal|0
index|]
operator|=
name|v
expr_stmt|;
name|so
index|[
literal|1
index|]
operator|=
name|l
expr_stmt|;
name|so
index|[
literal|2
index|]
operator|=
name|h
expr_stmt|;
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|so
argument_list|,
sizeof|sizeof
argument_list|(
name|so
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

