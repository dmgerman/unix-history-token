begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: vesagtf.c,v 1.2 2013/09/15 15:56:07 martin Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006 Itronix Inc.  * All rights reserved.  *  * Written by Garrett D'Amore for Itronix Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of Itronix Inc. may not be used to endorse  *    or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This was derived from a userland GTF program supplied by NVIDIA.  * NVIDIA's original boilerplate follows.   *  * Note that I have heavily modified the program for use in the EDID  * kernel code for NetBSD, including removing the use of floating  * point operations and making significant adjustments to minimize  * error propagation while operating with integer only math.  *  * This has required the use of 64-bit integers in a few places, but  * the upshot is that for a calculation of 1920x1200x85 (as an  * example), the error deviates by only ~.004% relative to the  * floating point version.  This error is *well* within VESA  * tolerances.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001, Andy Ritger  aritger@nvidia.com  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   * o Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * o Redistributions in binary form must reproduce the above copyright  *   notice, this list of conditions and the following disclaimer  *   in the documentation and/or other materials provided with the  *   distribution.  * o Neither the name of NVIDIA nor the names of its contributors  *   may be used to endorse or promote products derived from this  *   software without specific prior written permission.  *  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT  * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND  * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  *   *  * This program is based on the Generalized Timing Formula(GTF TM)  * Standard Version: 1.0, Revision: 1.0  *  * The GTF Document contains the following Copyright information:  *  * Copyright (c) 1994, 1995, 1996 - Video Electronics Standards  * Association. Duplication of this document within VESA member  * companies for review purposes is permitted. All other rights  * reserved.  *  * While every precaution has been taken in the preparation  * of this standard, the Video Electronics Standards Association and  * its contributors assume no responsibility for errors or omissions,  * and make no warranties, expressed or implied, of functionality  * of suitability for any purpose. The sample code contained within  * this standard may be used without restriction.  *  *   *  * The GTF EXCEL(TM) SPREADSHEET, a sample (and the definitive)  * implementation of the GTF Timing Standard, is available at:  *  * ftp://ftp.vesa.org/pub/GTF/GTF_V1R1.xls  *  *  *  * This program takes a desired resolution and vertical refresh rate,  * and computes mode timings according to the GTF Timing Standard.  * These mode timings can then be formatted as an XFree86 modeline  * or a mode description for use by fbset(8).  *  *  *  * NOTES:  *  * The GTF allows for computation of "margins" (the visible border  * surrounding the addressable video); on most non-overscan type  * systems, the margin period is zero.  I've implemented the margin  * computations but not enabled it because 1) I don't really have  * any experience with this, and 2) neither XFree86 modelines nor  * fbset fb.modes provide an obvious way for margin timings to be  * included in their mode descriptions (needs more investigation).  *   * The GTF provides for computation of interlaced mode timings;  * I've implemented the computations but not enabled them, yet.  * I should probably enable and test this at some point.  *  *   *  * TODO:  *  * o Add support for interlaced modes.  *  * o Implement the other portions of the GTF: compute mode timings  *   given either the desired pixel clock or the desired horizontal  *   frequency.  *  * o It would be nice if this were more general purpose to do things  *   outside the scope of the GTF: like generate double scan mode  *   timings, for example.  *     * o Printing digits to the right of the decimal point when the  *   digits are 0 annoys me.  *  * o Error checking.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/videomode.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/vesagtf.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"videomode.h"
end_include

begin_include
include|#
directive|include
file|"vesagtf.h"
end_include

begin_function_decl
name|void
name|print_xf86_mode
parameter_list|(
name|struct
name|videomode
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CELL_GRAN
value|8
end_define

begin_comment
comment|/* assumed character cell granularity        */
end_comment

begin_comment
comment|/* C' and M' are part of the Blanking Duty Cycle computation */
end_comment

begin_comment
comment|/*  * #define C_PRIME           (((C - J) * K/256.0) + J)  * #define M_PRIME           (K/256.0 * M)  */
end_comment

begin_comment
comment|/*  * C' and M' multiplied by 256 to give integer math.  Make sure to  * scale results using these back down, appropriately.  */
end_comment

begin_define
define|#
directive|define
name|C_PRIME256
parameter_list|(
name|p
parameter_list|)
value|(((p->C - p->J) * p->K) + (p->J * 256))
end_define

begin_define
define|#
directive|define
name|M_PRIME256
parameter_list|(
name|p
parameter_list|)
value|(p->K * p->M)
end_define

begin_define
define|#
directive|define
name|DIVIDE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + ((y) / 2)) / (y))
end_define

begin_comment
comment|/*  * print_value() - print the result of the named computation; this is  * useful when comparing against the GTF EXCEL spreadsheet.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GTFDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|print_value
parameter_list|(
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|val
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%2d: %-27s: %u\n"
argument_list|,
name|n
argument_list|,
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print_value
parameter_list|(
name|n
parameter_list|,
name|name
parameter_list|,
name|val
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * vert_refresh() - as defined by the GTF Timing Standard, compute the  * Stage 1 Parameters using the vertical refresh frequency.  In other  * words: input a desired resolution and desired refresh rate, and  * output the GTF mode timings.  *  * XXX All the code is in place to compute interlaced modes, but I don't  * feel like testing it right now.  *  * XXX margin computations are implemented but not tested (nor used by  * XFree86 of fbset mode descriptions, from what I can tell).  */
end_comment

begin_function
name|void
name|vesagtf_mode_params
parameter_list|(
name|unsigned
name|h_pixels
parameter_list|,
name|unsigned
name|v_lines
parameter_list|,
name|unsigned
name|freq
parameter_list|,
name|struct
name|vesagtf_params
modifier|*
name|params
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|videomode
modifier|*
name|vmp
parameter_list|)
block|{
name|unsigned
name|v_field_rqd
decl_stmt|;
name|unsigned
name|top_margin
decl_stmt|;
name|unsigned
name|bottom_margin
decl_stmt|;
name|unsigned
name|interlace
decl_stmt|;
name|uint64_t
name|h_period_est
decl_stmt|;
name|unsigned
name|vsync_plus_bp
decl_stmt|;
name|unsigned
name|v_back_porch
name|__unused
decl_stmt|;
name|unsigned
name|total_v_lines
decl_stmt|;
name|uint64_t
name|v_field_est
decl_stmt|;
name|uint64_t
name|h_period
decl_stmt|;
name|unsigned
name|v_field_rate
decl_stmt|;
name|unsigned
name|v_frame_rate
name|__unused
decl_stmt|;
name|unsigned
name|left_margin
decl_stmt|;
name|unsigned
name|right_margin
decl_stmt|;
name|unsigned
name|total_active_pixels
decl_stmt|;
name|uint64_t
name|ideal_duty_cycle
decl_stmt|;
name|unsigned
name|h_blank
decl_stmt|;
name|unsigned
name|total_pixels
decl_stmt|;
name|unsigned
name|pixel_freq
decl_stmt|;
name|unsigned
name|h_sync
decl_stmt|;
name|unsigned
name|h_front_porch
decl_stmt|;
name|unsigned
name|v_odd_front_porch_lines
decl_stmt|;
ifdef|#
directive|ifdef
name|GTFDEBUG
name|unsigned
name|h_freq
decl_stmt|;
endif|#
directive|endif
comment|/*  1. In order to give correct results, the number of horizontal      *  pixels requested is first processed to ensure that it is divisible      *  by the character size, by rounding it to the nearest character      *  cell boundary:      *      *  [H PIXELS RND] = ((ROUND([H PIXELS]/[CELL GRAN RND],0))*[CELLGRAN RND])      */
name|h_pixels
operator|=
name|DIVIDE
argument_list|(
name|h_pixels
argument_list|,
name|CELL_GRAN
argument_list|)
operator|*
name|CELL_GRAN
expr_stmt|;
name|print_value
argument_list|(
literal|1
argument_list|,
literal|"[H PIXELS RND]"
argument_list|,
name|h_pixels
argument_list|)
expr_stmt|;
comment|/*  2. If interlace is requested, the number of vertical lines assumed      *  by the calculation must be halved, as the computation calculates      *  the number of vertical lines per field. In either case, the      *  number of lines is rounded to the nearest integer.      *         *  [V LINES RND] = IF([INT RQD?]="y", ROUND([V LINES]/2,0),      *                                     ROUND([V LINES],0))      */
name|v_lines
operator|=
operator|(
name|flags
operator|&
name|VESAGTF_FLAG_ILACE
operator|)
condition|?
name|DIVIDE
argument_list|(
name|v_lines
argument_list|,
literal|2
argument_list|)
else|:
name|v_lines
expr_stmt|;
name|print_value
argument_list|(
literal|2
argument_list|,
literal|"[V LINES RND]"
argument_list|,
name|v_lines
argument_list|)
expr_stmt|;
comment|/*  3. Find the frame rate required:      *      *  [V FIELD RATE RQD] = IF([INT RQD?]="y", [I/P FREQ RQD]*2,      *                                          [I/P FREQ RQD])      */
name|v_field_rqd
operator|=
operator|(
name|flags
operator|&
name|VESAGTF_FLAG_ILACE
operator|)
condition|?
operator|(
name|freq
operator|*
literal|2
operator|)
else|:
operator|(
name|freq
operator|)
expr_stmt|;
name|print_value
argument_list|(
literal|3
argument_list|,
literal|"[V FIELD RATE RQD]"
argument_list|,
name|v_field_rqd
argument_list|)
expr_stmt|;
comment|/*  4. Find number of lines in Top margin:      *  5. Find number of lines in Bottom margin:      *      *  [TOP MARGIN (LINES)] = IF([MARGINS RQD?]="Y",      *          ROUND(([MARGIN%]/100*[V LINES RND]),0),      *          0)      *      *  Ditto for bottom margin.  Note that instead of %, we use PPT, which      *  is parts per thousand.  This helps us with integer math.      */
name|top_margin
operator|=
name|bottom_margin
operator|=
operator|(
name|flags
operator|&
name|VESAGTF_FLAG_MARGINS
operator|)
condition|?
name|DIVIDE
argument_list|(
name|v_lines
operator|*
name|params
operator|->
name|margin_ppt
argument_list|,
literal|1000
argument_list|)
else|:
literal|0
expr_stmt|;
name|print_value
argument_list|(
literal|4
argument_list|,
literal|"[TOP MARGIN (LINES)]"
argument_list|,
name|top_margin
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|5
argument_list|,
literal|"[BOT MARGIN (LINES)]"
argument_list|,
name|bottom_margin
argument_list|)
expr_stmt|;
comment|/*  6. If interlace is required, then set variable [INTERLACE]=0.5:      *         *  [INTERLACE]=(IF([INT RQD?]="y",0.5,0))      *      *  To make this integer friendly, we use some special hacks in step      *  7 below.  Please read those comments to understand why I am using      *  a whole number of 1.0 instead of 0.5 here.      */
name|interlace
operator|=
operator|(
name|flags
operator|&
name|VESAGTF_FLAG_ILACE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|print_value
argument_list|(
literal|6
argument_list|,
literal|"[2*INTERLACE]"
argument_list|,
name|interlace
argument_list|)
expr_stmt|;
comment|/*  7. Estimate the Horizontal period      *      *  [H PERIOD EST] = ((1/[V FIELD RATE RQD]) - [MIN VSYNC+BP]/1000000) /      *                    ([V LINES RND] + (2*[TOP MARGIN (LINES)]) +      *                     [MIN PORCH RND]+[INTERLACE]) * 1000000      *      *  To make it integer friendly, we pre-multiply the 1000000 to get to      *  usec.  This gives us:      *      *  [H PERIOD EST] = ((1000000/[V FIELD RATE RQD]) - [MIN VSYNC+BP]) /      *			([V LINES RND] + (2 * [TOP MARGIN (LINES)]) +      *			 [MIN PORCH RND]+[INTERLACE])      *      *  The other problem is that the interlace value is wrong.  To get      *  the interlace to a whole number, we multiply both the numerator and      *  divisor by 2, so we can use a value of either 1 or 0 for the interlace      *  factor.      *      * This gives us:      *      * [H PERIOD EST] = ((2*((1000000/[V FIELD RATE RQD]) - [MIN VSYNC+BP])) /      *			 (2*([V LINES RND] + (2*[TOP MARGIN (LINES)]) +      *			  [MIN PORCH RND]) + [2*INTERLACE]))      *      * Finally we multiply by another 1000, to get value in picosec.      * Why picosec?  To minimize rounding errors.  Gotta love integer      * math and error propagation.      */
name|h_period_est
operator|=
name|DIVIDE
argument_list|(
operator|(
operator|(
name|DIVIDE
argument_list|(
literal|2000000000000ULL
argument_list|,
name|v_field_rqd
argument_list|)
operator|)
operator|-
operator|(
literal|2000000
operator|*
name|params
operator|->
name|min_vsbp
operator|)
operator|)
argument_list|,
operator|(
operator|(
literal|2
operator|*
operator|(
name|v_lines
operator|+
operator|(
literal|2
operator|*
name|top_margin
operator|)
operator|+
name|params
operator|->
name|min_porch
operator|)
operator|)
operator|+
name|interlace
operator|)
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|7
argument_list|,
literal|"[H PERIOD EST (ps)]"
argument_list|,
name|h_period_est
argument_list|)
expr_stmt|;
comment|/*  8. Find the number of lines in V sync + back porch:      *      *  [V SYNC+BP] = ROUND(([MIN VSYNC+BP]/[H PERIOD EST]),0)      *      *  But recall that h_period_est is in psec. So multiply by 1000000.      */
name|vsync_plus_bp
operator|=
name|DIVIDE
argument_list|(
name|params
operator|->
name|min_vsbp
operator|*
literal|1000000
argument_list|,
name|h_period_est
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|8
argument_list|,
literal|"[V SYNC+BP]"
argument_list|,
name|vsync_plus_bp
argument_list|)
expr_stmt|;
comment|/*  9. Find the number of lines in V back porch alone:      *      *  [V BACK PORCH] = [V SYNC+BP] - [V SYNC RND]      *      *  XXX is "[V SYNC RND]" a typo? should be [V SYNC RQD]?      */
name|v_back_porch
operator|=
name|vsync_plus_bp
operator|-
name|params
operator|->
name|vsync_rqd
expr_stmt|;
name|print_value
argument_list|(
literal|9
argument_list|,
literal|"[V BACK PORCH]"
argument_list|,
name|v_back_porch
argument_list|)
expr_stmt|;
comment|/*  10. Find the total number of lines in Vertical field period:      *      *  [TOTAL V LINES] = [V LINES RND] + [TOP MARGIN (LINES)] +      *                    [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] +      *                    [MIN PORCH RND]      */
name|total_v_lines
operator|=
name|v_lines
operator|+
name|top_margin
operator|+
name|bottom_margin
operator|+
name|vsync_plus_bp
operator|+
name|interlace
operator|+
name|params
operator|->
name|min_porch
expr_stmt|;
name|print_value
argument_list|(
literal|10
argument_list|,
literal|"[TOTAL V LINES]"
argument_list|,
name|total_v_lines
argument_list|)
expr_stmt|;
comment|/*  11. Estimate the Vertical field frequency:      *      *  [V FIELD RATE EST] = 1 / [H PERIOD EST] / [TOTAL V LINES] * 1000000      *      *  Again, we want to pre multiply by 10^9 to convert for nsec, thereby      *  making it usable in integer math.      *      *  So we get:      *      *  [V FIELD RATE EST] = 1000000000 / [H PERIOD EST] / [TOTAL V LINES]      *      *  This is all scaled to get the result in uHz.  Again, we're trying to      *  minimize error propagation.      */
name|v_field_est
operator|=
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
literal|1000000000000000ULL
argument_list|,
name|h_period_est
argument_list|)
argument_list|,
name|total_v_lines
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|11
argument_list|,
literal|"[V FIELD RATE EST(uHz)]"
argument_list|,
name|v_field_est
argument_list|)
expr_stmt|;
comment|/*  12. Find the actual horizontal period:      *      *  [H PERIOD] = [H PERIOD EST] / ([V FIELD RATE RQD] / [V FIELD RATE EST])      */
name|h_period
operator|=
name|DIVIDE
argument_list|(
name|h_period_est
operator|*
name|v_field_est
argument_list|,
name|v_field_rqd
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|12
argument_list|,
literal|"[H PERIOD(ps)]"
argument_list|,
name|h_period
argument_list|)
expr_stmt|;
comment|/*  13. Find the actual Vertical field frequency:      *      *  [V FIELD RATE] = 1 / [H PERIOD] / [TOTAL V LINES] * 1000000      *      *  And again, we convert to nsec ahead of time, giving us:      *      *  [V FIELD RATE] = 1000000 / [H PERIOD] / [TOTAL V LINES]      *      *  And another rescaling back to mHz.  Gotta love it.      */
name|v_field_rate
operator|=
name|DIVIDE
argument_list|(
literal|1000000000000ULL
argument_list|,
name|h_period
operator|*
name|total_v_lines
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|13
argument_list|,
literal|"[V FIELD RATE]"
argument_list|,
name|v_field_rate
argument_list|)
expr_stmt|;
comment|/*  14. Find the Vertical frame frequency:      *      *  [V FRAME RATE] = (IF([INT RQD?]="y", [V FIELD RATE]/2, [V FIELD RATE]))      *      *  N.B. that the result here is in mHz.      */
name|v_frame_rate
operator|=
operator|(
name|flags
operator|&
name|VESAGTF_FLAG_ILACE
operator|)
condition|?
name|v_field_rate
operator|/
literal|2
else|:
name|v_field_rate
expr_stmt|;
name|print_value
argument_list|(
literal|14
argument_list|,
literal|"[V FRAME RATE]"
argument_list|,
name|v_frame_rate
argument_list|)
expr_stmt|;
comment|/*  15. Find number of pixels in left margin:      *  16. Find number of pixels in right margin:      *      *  [LEFT MARGIN (PIXELS)] = (IF( [MARGINS RQD?]="Y",      *          (ROUND( ([H PIXELS RND] * [MARGIN%] / 100 /      *                   [CELL GRAN RND]),0)) * [CELL GRAN RND],      *          0))      *      *  Again, we deal with margin percentages as PPT (parts per thousand).      *  And the calculations for left and right are the same.      */
name|left_margin
operator|=
name|right_margin
operator|=
operator|(
name|flags
operator|&
name|VESAGTF_FLAG_MARGINS
operator|)
condition|?
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|h_pixels
operator|*
name|params
operator|->
name|margin_ppt
argument_list|,
literal|1000
argument_list|)
argument_list|,
name|CELL_GRAN
argument_list|)
operator|*
name|CELL_GRAN
else|:
literal|0
expr_stmt|;
name|print_value
argument_list|(
literal|15
argument_list|,
literal|"[LEFT MARGIN (PIXELS)]"
argument_list|,
name|left_margin
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|16
argument_list|,
literal|"[RIGHT MARGIN (PIXELS)]"
argument_list|,
name|right_margin
argument_list|)
expr_stmt|;
comment|/*  17. Find total number of active pixels in image and left and right      *  margins:      *      *  [TOTAL ACTIVE PIXELS] = [H PIXELS RND] + [LEFT MARGIN (PIXELS)] +      *                          [RIGHT MARGIN (PIXELS)]      */
name|total_active_pixels
operator|=
name|h_pixels
operator|+
name|left_margin
operator|+
name|right_margin
expr_stmt|;
name|print_value
argument_list|(
literal|17
argument_list|,
literal|"[TOTAL ACTIVE PIXELS]"
argument_list|,
name|total_active_pixels
argument_list|)
expr_stmt|;
comment|/*  18. Find the ideal blanking duty cycle from the blanking duty cycle      *  equation:      *      *  [IDEAL DUTY CYCLE] = [C'] - ([M']*[H PERIOD]/1000)      *      *  However, we have modified values for [C'] as [256*C'] and      *  [M'] as [256*M'].  Again the idea here is to get good scaling.      *  We use 256 as the factor to make the math fast.      *      *  Note that this means that we have to scale it appropriately in      *  later calculations.      *      *  The ending result is that our ideal_duty_cycle is 256000x larger      *  than the duty cycle used by VESA.  But again, this reduces error      *  propagation.      */
name|ideal_duty_cycle
operator|=
operator|(
operator|(
name|C_PRIME256
argument_list|(
name|params
argument_list|)
operator|*
literal|1000
operator|)
operator|-
operator|(
name|M_PRIME256
argument_list|(
name|params
argument_list|)
operator|*
name|h_period
operator|/
literal|1000000
operator|)
operator|)
expr_stmt|;
name|print_value
argument_list|(
literal|18
argument_list|,
literal|"[IDEAL DUTY CYCLE]"
argument_list|,
name|ideal_duty_cycle
argument_list|)
expr_stmt|;
comment|/*  19. Find the number of pixels in the blanking time to the nearest      *  double character cell:      *      *  [H BLANK (PIXELS)] = (ROUND(([TOTAL ACTIVE PIXELS] *      *                               [IDEAL DUTY CYCLE] /      *                               (100-[IDEAL DUTY CYCLE]) /      *                               (2*[CELL GRAN RND])), 0))      *                       * (2*[CELL GRAN RND])      *      *  Of course, we adjust to make this rounding work in integer math.      */
name|h_blank
operator|=
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|total_active_pixels
operator|*
name|ideal_duty_cycle
argument_list|,
operator|(
literal|256000
operator|*
literal|100ULL
operator|)
operator|-
name|ideal_duty_cycle
argument_list|)
argument_list|,
literal|2
operator|*
name|CELL_GRAN
argument_list|)
operator|*
operator|(
literal|2
operator|*
name|CELL_GRAN
operator|)
expr_stmt|;
name|print_value
argument_list|(
literal|19
argument_list|,
literal|"[H BLANK (PIXELS)]"
argument_list|,
name|h_blank
argument_list|)
expr_stmt|;
comment|/*  20. Find total number of pixels:      *      *  [TOTAL PIXELS] = [TOTAL ACTIVE PIXELS] + [H BLANK (PIXELS)]      */
name|total_pixels
operator|=
name|total_active_pixels
operator|+
name|h_blank
expr_stmt|;
name|print_value
argument_list|(
literal|20
argument_list|,
literal|"[TOTAL PIXELS]"
argument_list|,
name|total_pixels
argument_list|)
expr_stmt|;
comment|/*  21. Find pixel clock frequency:      *      *  [PIXEL FREQ] = [TOTAL PIXELS] / [H PERIOD]      *      *  We calculate this in Hz rather than MHz, to get a value that      *  is usable with integer math.  Recall that the [H PERIOD] is in      *  nsec.      */
name|pixel_freq
operator|=
name|DIVIDE
argument_list|(
name|total_pixels
operator|*
literal|1000000
argument_list|,
name|DIVIDE
argument_list|(
name|h_period
argument_list|,
literal|1000
argument_list|)
argument_list|)
expr_stmt|;
name|print_value
argument_list|(
literal|21
argument_list|,
literal|"[PIXEL FREQ]"
argument_list|,
name|pixel_freq
argument_list|)
expr_stmt|;
comment|/*  22. Find horizontal frequency:      *      *  [H FREQ] = 1000 / [H PERIOD]      *      *  I've ifdef'd this out, because we don't need it for any of      *  our calculations.      *  We calculate this in Hz rather than kHz, to avoid rounding      *  errors.  Recall that the [H PERIOD] is in usec.      */
ifdef|#
directive|ifdef
name|GTFDEBUG
name|h_freq
operator|=
literal|1000000000
operator|/
name|h_period
expr_stmt|;
name|print_value
argument_list|(
literal|22
argument_list|,
literal|"[H FREQ]"
argument_list|,
name|h_freq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Stage 1 computations are now complete; I should really pass        the results to another function and do the Stage 2        computations, but I only need a few more values so I'll just        append the computations here for now */
comment|/*  17. Find the number of pixels in the horizontal sync period:      *      *  [H SYNC (PIXELS)] =(ROUND(([H SYNC%] / 100 * [TOTAL PIXELS] /      *                             [CELL GRAN RND]),0))*[CELL GRAN RND]      *      *  Rewriting for integer math:      *      *  [H SYNC (PIXELS)]=(ROUND((H SYNC%] * [TOTAL PIXELS] / 100 /      *				   [CELL GRAN RND),0))*[CELL GRAN RND]      */
name|h_sync
operator|=
name|DIVIDE
argument_list|(
operator|(
operator|(
name|params
operator|->
name|hsync_pct
operator|*
name|total_pixels
operator|)
operator|/
literal|100
operator|)
argument_list|,
name|CELL_GRAN
argument_list|)
operator|*
name|CELL_GRAN
expr_stmt|;
name|print_value
argument_list|(
literal|17
argument_list|,
literal|"[H SYNC (PIXELS)]"
argument_list|,
name|h_sync
argument_list|)
expr_stmt|;
comment|/*  18. Find the number of pixels in the horizontal front porch period:      *      *  [H FRONT PORCH (PIXELS)] = ([H BLANK (PIXELS)]/2)-[H SYNC (PIXELS)]      *      *  Note that h_blank is always an even number of characters (i.e.      *  h_blank % (CELL_GRAN * 2) == 0)      */
name|h_front_porch
operator|=
operator|(
name|h_blank
operator|/
literal|2
operator|)
operator|-
name|h_sync
expr_stmt|;
name|print_value
argument_list|(
literal|18
argument_list|,
literal|"[H FRONT PORCH (PIXELS)]"
argument_list|,
name|h_front_porch
argument_list|)
expr_stmt|;
comment|/*  36. Find the number of lines in the odd front porch period:      *      *  [V ODD FRONT PORCH(LINES)]=([MIN PORCH RND]+[INTERLACE])      *      *  Adjusting for the fact that the interlace is scaled:      *      *  [V ODD FRONT PORCH(LINES)]=(([MIN PORCH RND] * 2) + [2*INTERLACE]) / 2      */
name|v_odd_front_porch_lines
operator|=
operator|(
operator|(
literal|2
operator|*
name|params
operator|->
name|min_porch
operator|)
operator|+
name|interlace
operator|)
operator|/
literal|2
expr_stmt|;
name|print_value
argument_list|(
literal|36
argument_list|,
literal|"[V ODD FRONT PORCH(LINES)]"
argument_list|,
name|v_odd_front_porch_lines
argument_list|)
expr_stmt|;
comment|/* finally, pack the results in the mode struct */
name|vmp
operator|->
name|hsync_start
operator|=
name|h_pixels
operator|+
name|h_front_porch
expr_stmt|;
name|vmp
operator|->
name|hsync_end
operator|=
name|vmp
operator|->
name|hsync_start
operator|+
name|h_sync
expr_stmt|;
name|vmp
operator|->
name|htotal
operator|=
name|total_pixels
expr_stmt|;
name|vmp
operator|->
name|hdisplay
operator|=
name|h_pixels
expr_stmt|;
name|vmp
operator|->
name|vsync_start
operator|=
name|v_lines
operator|+
name|v_odd_front_porch_lines
expr_stmt|;
name|vmp
operator|->
name|vsync_end
operator|=
name|vmp
operator|->
name|vsync_start
operator|+
name|params
operator|->
name|vsync_rqd
expr_stmt|;
name|vmp
operator|->
name|vtotal
operator|=
name|total_v_lines
expr_stmt|;
name|vmp
operator|->
name|vdisplay
operator|=
name|v_lines
expr_stmt|;
name|vmp
operator|->
name|dot_clock
operator|=
name|pixel_freq
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vesagtf_mode
parameter_list|(
name|unsigned
name|x
parameter_list|,
name|unsigned
name|y
parameter_list|,
name|unsigned
name|refresh
parameter_list|,
name|struct
name|videomode
modifier|*
name|vmp
parameter_list|)
block|{
name|struct
name|vesagtf_params
name|params
decl_stmt|;
name|params
operator|.
name|margin_ppt
operator|=
name|VESAGTF_MARGIN_PPT
expr_stmt|;
name|params
operator|.
name|min_porch
operator|=
name|VESAGTF_MIN_PORCH
expr_stmt|;
name|params
operator|.
name|vsync_rqd
operator|=
name|VESAGTF_VSYNC_RQD
expr_stmt|;
name|params
operator|.
name|hsync_pct
operator|=
name|VESAGTF_HSYNC_PCT
expr_stmt|;
name|params
operator|.
name|min_vsbp
operator|=
name|VESAGTF_MIN_VSBP
expr_stmt|;
name|params
operator|.
name|M
operator|=
name|VESAGTF_M
expr_stmt|;
name|params
operator|.
name|C
operator|=
name|VESAGTF_C
expr_stmt|;
name|params
operator|.
name|K
operator|=
name|VESAGTF_K
expr_stmt|;
name|params
operator|.
name|J
operator|=
name|VESAGTF_J
expr_stmt|;
name|vesagtf_mode_params
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|refresh
argument_list|,
operator|&
name|params
argument_list|,
literal|0
argument_list|,
name|vmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The tidbit here is so that you can compile this file as a  * standalone user program to generate X11 modelines using VESA GTF.  * This also allows for testing of the code itself, without  * necessitating a full kernel recompile.  */
end_comment

begin_comment
comment|/* print_xf86_mode() - print the XFree86 modeline, given mode timings. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
name|void
name|print_xf86_mode
parameter_list|(
name|struct
name|videomode
modifier|*
name|vmp
parameter_list|)
block|{
name|float
name|vf
decl_stmt|,
name|hf
decl_stmt|;
name|hf
operator|=
literal|1000.0
operator|*
name|vmp
operator|->
name|dot_clock
operator|/
name|vmp
operator|->
name|htotal
expr_stmt|;
name|vf
operator|=
literal|1.0
operator|*
name|hf
operator|/
name|vmp
operator|->
name|vtotal
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  # %dx%d @ %.2f Hz (GTF) hsync: %.2f kHz; pclk: %.2f MHz\n"
argument_list|,
name|vmp
operator|->
name|hdisplay
argument_list|,
name|vmp
operator|->
name|vdisplay
argument_list|,
name|vf
argument_list|,
name|hf
argument_list|,
name|vmp
operator|->
name|dot_clock
operator|/
literal|1000.0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Modeline \"%dx%d_%.2f\"  %.2f"
literal|"  %d %d %d %d"
literal|"  %d %d %d %d"
literal|"  -HSync +Vsync\n\n"
argument_list|,
name|vmp
operator|->
name|hdisplay
argument_list|,
name|vmp
operator|->
name|vdisplay
argument_list|,
name|vf
argument_list|,
operator|(
name|vmp
operator|->
name|dot_clock
operator|/
literal|1000.0
operator|)
argument_list|,
name|vmp
operator|->
name|hdisplay
argument_list|,
name|vmp
operator|->
name|hsync_start
argument_list|,
name|vmp
operator|->
name|hsync_end
argument_list|,
name|vmp
operator|->
name|htotal
argument_list|,
name|vmp
operator|->
name|vdisplay
argument_list|,
name|vmp
operator|->
name|vsync_start
argument_list|,
name|vmp
operator|->
name|vsync_end
argument_list|,
name|vmp
operator|->
name|vtotal
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|videomode
name|m
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"usage: %s x y refresh\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|vesagtf_mode
argument_list|(
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|atoi
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|atoi
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|print_xf86_mode
argument_list|(
operator|&
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

