begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: edid.c,v 1.12 2013/02/08 16:35:10 skrll Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006 Itronix Inc.  * All rights reserved.  *  * Written by Garrett D'Amore for Itronix Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of Itronix Inc. may not be used to endorse  *    or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/videomode.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/ediddevs.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/edidreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/edidvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/vesagtf.h>
end_include

begin_define
define|#
directive|define
name|EDIDVERBOSE
value|1
end_define

begin_define
define|#
directive|define
name|DIVIDE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + ((y) / 2)) / (y))
end_define

begin_comment
comment|/* These are reversed established timing order */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|_edid_modes
index|[]
init|=
block|{
literal|"1280x1024x75"
block|,
literal|"1024x768x75"
block|,
literal|"1024x768x70"
block|,
literal|"1024x768x60"
block|,
literal|"1024x768x87i"
block|,
literal|"832x624x74"
block|,
comment|/* rounding error, 74.55 Hz aka "832x624x75" */
literal|"800x600x75"
block|,
literal|"800x600x72"
block|,
literal|"800x600x60"
block|,
literal|"800x600x56"
block|,
literal|"640x480x75"
block|,
literal|"640x480x72"
block|,
literal|"640x480x67"
block|,
literal|"640x480x60"
block|,
literal|"720x400x87"
block|,
comment|/* rounding error, 87.85 Hz aka "720x400x88" */
literal|"720x400x70"
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EDIDVERBOSE
end_ifdef

begin_struct
struct|struct
name|edid_vendor
block|{
specifier|const
name|char
modifier|*
name|vendor
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|edid_product
block|{
specifier|const
name|char
modifier|*
name|vendor
decl_stmt|;
name|uint16_t
name|product
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|<dev/videomode/ediddevs_data.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EDIDVERBOSE */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|edid_findvendor
parameter_list|(
specifier|const
name|char
modifier|*
name|vendor
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EDIDVERBOSE
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|edid_nvendors
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|edid_vendors
index|[
name|n
index|]
operator|.
name|vendor
argument_list|,
name|vendor
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|edid_vendors
index|[
name|n
index|]
operator|.
name|name
return|;
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|edid_findproduct
parameter_list|(
specifier|const
name|char
modifier|*
name|vendor
parameter_list|,
name|uint16_t
name|product
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EDIDVERBOSE
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|edid_nproducts
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|edid_products
index|[
name|n
index|]
operator|.
name|product
operator|==
name|product
operator|&&
name|memcmp
argument_list|(
name|edid_products
index|[
name|n
index|]
operator|.
name|vendor
argument_list|,
name|vendor
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|edid_products
index|[
name|n
index|]
operator|.
name|name
return|;
endif|#
directive|endif
comment|/* EDIDVERBOSE */
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|edid_strchomp
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|'\0'
case|:
return|return;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|ptr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|edid_is_valid
parameter_list|(
name|uint8_t
modifier|*
name|d
parameter_list|)
block|{
name|int
name|sum
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|sig
index|[
literal|8
index|]
init|=
name|EDID_SIGNATURE
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|d
argument_list|,
name|sig
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|d
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sum
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|edid_print
parameter_list|(
name|struct
name|edid_info
modifier|*
name|edid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|edid
operator|==
name|NULL
condition|)
return|return;
name|printf
argument_list|(
literal|"Vendor: [%s] %s\n"
argument_list|,
name|edid
operator|->
name|edid_vendor
argument_list|,
name|edid
operator|->
name|edid_vendorname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Product: [%04X] %s\n"
argument_list|,
name|edid
operator|->
name|edid_product
argument_list|,
name|edid
operator|->
name|edid_productname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Serial number: %s\n"
argument_list|,
name|edid
operator|->
name|edid_serial
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Manufactured %d Week %d\n"
argument_list|,
name|edid
operator|->
name|edid_year
argument_list|,
name|edid
operator|->
name|edid_week
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EDID Version %d.%d\n"
argument_list|,
name|edid
operator|->
name|edid_version
argument_list|,
name|edid
operator|->
name|edid_revision
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"EDID Comment: %s\n"
argument_list|,
name|edid
operator|->
name|edid_comment
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Video Input: %x\n"
argument_list|,
name|edid
operator|->
name|edid_video_input
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_DIGITAL
condition|)
block|{
name|printf
argument_list|(
literal|"\tDigital"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_DFP1_COMPAT
condition|)
name|printf
argument_list|(
literal|" (DFP 1.x compatible)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\tAnalog\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EDID_VIDEO_INPUT_LEVEL
argument_list|(
name|edid
operator|->
name|edid_video_input
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"\t-0.7, 0.3V\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|"\t-0.714, 0.286V\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"\t-1.0, 0.4V\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf
argument_list|(
literal|"\t-0.7, 0.0V\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_BLANK_TO_BLACK
condition|)
name|printf
argument_list|(
literal|"\tBlank-to-black setup\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_SEPARATE_SYNCS
condition|)
name|printf
argument_list|(
literal|"\tSeperate syncs\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_COMPOSITE_SYNC
condition|)
name|printf
argument_list|(
literal|"\tComposite sync\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_SYNC_ON_GRN
condition|)
name|printf
argument_list|(
literal|"\tSync on green\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_video_input
operator|&
name|EDID_VIDEO_INPUT_SERRATION
condition|)
name|printf
argument_list|(
literal|"\tSerration vsync\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Gamma: %d.%02d\n"
argument_list|,
name|edid
operator|->
name|edid_gamma
operator|/
literal|100
argument_list|,
name|edid
operator|->
name|edid_gamma
operator|%
literal|100
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Max Size: %d cm x %d cm\n"
argument_list|,
name|edid
operator|->
name|edid_max_hsize
argument_list|,
name|edid
operator|->
name|edid_max_vsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Features: %x\n"
argument_list|,
name|edid
operator|->
name|edid_features
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_features
operator|&
name|EDID_FEATURES_STANDBY
condition|)
name|printf
argument_list|(
literal|"\tDPMS standby\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_features
operator|&
name|EDID_FEATURES_SUSPEND
condition|)
name|printf
argument_list|(
literal|"\tDPMS suspend\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_features
operator|&
name|EDID_FEATURES_ACTIVE_OFF
condition|)
name|printf
argument_list|(
literal|"\tDPMS active-off\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EDID_FEATURES_DISP_TYPE
argument_list|(
name|edid
operator|->
name|edid_features
argument_list|)
condition|)
block|{
case|case
name|EDID_FEATURES_DISP_TYPE_MONO
case|:
name|printf
argument_list|(
literal|"\tMonochrome\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDID_FEATURES_DISP_TYPE_RGB
case|:
name|printf
argument_list|(
literal|"\tRGB\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDID_FEATURES_DISP_TYPE_NON_RGB
case|:
name|printf
argument_list|(
literal|"\tMulticolor\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDID_FEATURES_DISP_TYPE_UNDEFINED
case|:
name|printf
argument_list|(
literal|"\tUndefined monitor type\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|edid
operator|->
name|edid_features
operator|&
name|EDID_FEATURES_STD_COLOR
condition|)
name|printf
argument_list|(
literal|"\tStandard color space\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_features
operator|&
name|EDID_FEATURES_PREFERRED_TIMING
condition|)
name|printf
argument_list|(
literal|"\tPreferred timing\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_features
operator|&
name|EDID_FEATURES_DEFAULT_GTF
condition|)
name|printf
argument_list|(
literal|"\tDefault GTF supported\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Chroma Info:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tRed X: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_redx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tRed Y: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_redy
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tGrn X: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_greenx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tGrn Y: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_greeny
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tBlu X: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_bluex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tBlu Y: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_bluey
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tWht X: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_whitex
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tWht Y: 0.%03d\n"
argument_list|,
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_whitey
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_have_range
condition|)
block|{
name|printf
argument_list|(
literal|"Range:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tHorizontal: %d - %d kHz\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_min_hfreq
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_max_hfreq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tVertical: %d - %d Hz\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_min_vfreq
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_max_vfreq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tMax Dot Clock: %d MHz\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_max_clock
argument_list|)
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_range
operator|.
name|er_have_gtf2
condition|)
block|{
name|printf
argument_list|(
literal|"\tGTF2 hfreq: %d\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_hfreq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tGTF2 C: %d\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_c
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tGTF2 M: %d\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tGTF2 J: %d\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tGTF2 K: %d\n"
argument_list|,
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_k
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Video modes:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edid
operator|->
name|edid_nmodes
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t%dx%d @ %dHz"
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|hdisplay
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vdisplay
argument_list|,
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
operator|*
literal|1000
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|htotal
argument_list|)
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (%d %d %d %d %d %d %d"
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|hsync_start
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|hsync_end
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|htotal
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vsync_start
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vsync_end
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s%sH %s%sV)\n"
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|VID_PHSYNC
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|VID_NHSYNC
condition|?
literal|"-"
else|:
literal|""
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|VID_PVSYNC
condition|?
literal|"+"
else|:
literal|""
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|VID_NVSYNC
condition|?
literal|"-"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|edid
operator|->
name|edid_preferred_mode
condition|)
name|printf
argument_list|(
literal|"Preferred mode: %dx%d @ %dHz\n"
argument_list|,
name|edid
operator|->
name|edid_preferred_mode
operator|->
name|hdisplay
argument_list|,
name|edid
operator|->
name|edid_preferred_mode
operator|->
name|vdisplay
argument_list|,
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|edid
operator|->
name|edid_preferred_mode
operator|->
name|dot_clock
operator|*
literal|1000
argument_list|,
name|edid
operator|->
name|edid_preferred_mode
operator|->
name|htotal
argument_list|)
argument_list|,
name|edid
operator|->
name|edid_preferred_mode
operator|->
name|vtotal
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Number of extension blocks: %d\n"
argument_list|,
name|edid
operator|->
name|edid_ext_block_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|videomode
modifier|*
name|edid_mode_lookup_list
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|videomode_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|videomode_list
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|videomode_list
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|videomode
modifier|*
name|edid_search_mode
parameter_list|(
name|struct
name|edid_info
modifier|*
name|edid
parameter_list|,
specifier|const
name|struct
name|videomode
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|refresh
decl_stmt|,
name|i
decl_stmt|;
name|refresh
operator|=
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|mode
operator|->
name|dot_clock
operator|*
literal|1000
argument_list|,
name|mode
operator|->
name|htotal
argument_list|)
argument_list|,
name|mode
operator|->
name|vtotal
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edid
operator|->
name|edid_nmodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode
operator|->
name|hdisplay
operator|==
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|&&
name|mode
operator|->
name|vdisplay
operator|==
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vdisplay
operator|&&
name|refresh
operator|==
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
operator|*
literal|1000
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|htotal
argument_list|)
argument_list|,
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
condition|)
block|{
return|return
operator|&
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|edid_std_timing
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
name|struct
name|videomode
modifier|*
name|vmp
parameter_list|)
block|{
name|unsigned
name|x
decl_stmt|,
name|y
decl_stmt|,
name|f
decl_stmt|;
specifier|const
name|struct
name|videomode
modifier|*
name|lookup
decl_stmt|;
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|data
index|[
literal|1
index|]
operator|==
literal|1
operator|)
operator|||
operator|(
name|data
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|data
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|data
index|[
literal|0
index|]
operator|==
literal|0x20
operator|&&
name|data
index|[
literal|1
index|]
operator|==
literal|0x20
operator|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|EDID_STD_TIMING_HRES
argument_list|(
name|data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|EDID_STD_TIMING_RATIO
argument_list|(
name|data
argument_list|)
condition|)
block|{
case|case
name|EDID_STD_TIMING_RATIO_16_10
case|:
name|y
operator|=
name|x
operator|*
literal|10
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|EDID_STD_TIMING_RATIO_4_3
case|:
name|y
operator|=
name|x
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
break|break;
case|case
name|EDID_STD_TIMING_RATIO_5_4
case|:
name|y
operator|=
name|x
operator|*
literal|4
operator|/
literal|5
expr_stmt|;
break|break;
case|case
name|EDID_STD_TIMING_RATIO_16_9
case|:
default|default:
name|y
operator|=
name|x
operator|*
literal|9
operator|/
literal|16
expr_stmt|;
break|break;
block|}
name|f
operator|=
name|EDID_STD_TIMING_VFREQ
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* first try to lookup the mode as a DMT timing */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%dx%dx%d"
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lookup
operator|=
name|edid_mode_lookup_list
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|vmp
operator|=
operator|*
name|lookup
expr_stmt|;
block|}
else|else
block|{
comment|/* failing that, calculate it using gtf */
comment|/* 		 * Hmm. I'm not using alternate GTF timings, which 		 * could, in theory, be present. 		 */
name|vesagtf_mode
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|f
argument_list|,
name|vmp
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|edid_det_timing
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
name|struct
name|videomode
modifier|*
name|vmp
parameter_list|)
block|{
name|unsigned
name|hactive
decl_stmt|,
name|hblank
decl_stmt|,
name|hsyncwid
decl_stmt|,
name|hsyncoff
decl_stmt|;
name|unsigned
name|vactive
decl_stmt|,
name|vblank
decl_stmt|,
name|vsyncwid
decl_stmt|,
name|vsyncoff
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|flags
operator|=
name|EDID_DET_TIMING_FLAGS
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* we don't support stereo modes (for now) */
if|if
condition|(
name|flags
operator|&
operator|(
name|EDID_DET_TIMING_FLAG_STEREO
operator||
name|EDID_DET_TIMING_FLAG_STEREO_MODE
operator|)
condition|)
return|return
literal|0
return|;
name|vmp
operator|->
name|dot_clock
operator|=
name|EDID_DET_TIMING_DOT_CLOCK
argument_list|(
name|data
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|hactive
operator|=
name|EDID_DET_TIMING_HACTIVE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|hblank
operator|=
name|EDID_DET_TIMING_HBLANK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|hsyncwid
operator|=
name|EDID_DET_TIMING_HSYNC_WIDTH
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|hsyncoff
operator|=
name|EDID_DET_TIMING_HSYNC_OFFSET
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|vactive
operator|=
name|EDID_DET_TIMING_VACTIVE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|vblank
operator|=
name|EDID_DET_TIMING_VBLANK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|vsyncwid
operator|=
name|EDID_DET_TIMING_VSYNC_WIDTH
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|vsyncoff
operator|=
name|EDID_DET_TIMING_VSYNC_OFFSET
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Borders are contained within the blank areas. */
name|vmp
operator|->
name|hdisplay
operator|=
name|hactive
expr_stmt|;
name|vmp
operator|->
name|htotal
operator|=
name|hactive
operator|+
name|hblank
expr_stmt|;
name|vmp
operator|->
name|hsync_start
operator|=
name|hactive
operator|+
name|hsyncoff
expr_stmt|;
name|vmp
operator|->
name|hsync_end
operator|=
name|vmp
operator|->
name|hsync_start
operator|+
name|hsyncwid
expr_stmt|;
name|vmp
operator|->
name|vdisplay
operator|=
name|vactive
expr_stmt|;
name|vmp
operator|->
name|vtotal
operator|=
name|vactive
operator|+
name|vblank
expr_stmt|;
name|vmp
operator|->
name|vsync_start
operator|=
name|vactive
operator|+
name|vsyncoff
expr_stmt|;
name|vmp
operator|->
name|vsync_end
operator|=
name|vmp
operator|->
name|vsync_start
operator|+
name|vsyncwid
expr_stmt|;
name|vmp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EDID_DET_TIMING_FLAG_INTERLACE
condition|)
name|vmp
operator|->
name|flags
operator||=
name|VID_INTERLACE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EDID_DET_TIMING_FLAG_HSYNC_POSITIVE
condition|)
name|vmp
operator|->
name|flags
operator||=
name|VID_PHSYNC
expr_stmt|;
else|else
name|vmp
operator|->
name|flags
operator||=
name|VID_NHSYNC
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|EDID_DET_TIMING_FLAG_VSYNC_POSITIVE
condition|)
name|vmp
operator|->
name|flags
operator||=
name|VID_PVSYNC
expr_stmt|;
else|else
name|vmp
operator|->
name|flags
operator||=
name|VID_NVSYNC
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|edid_block
parameter_list|(
name|struct
name|edid_info
modifier|*
name|edid
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|videomode
name|mode
decl_stmt|,
modifier|*
name|exist_mode
decl_stmt|;
if|if
condition|(
name|EDID_BLOCK_IS_DET_TIMING
argument_list|(
name|data
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|edid_det_timing
argument_list|(
name|data
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
return|return;
comment|/* Does this mode already exist? */
name|exist_mode
operator|=
name|edid_search_mode
argument_list|(
name|edid
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|exist_mode
operator|!=
name|NULL
condition|)
block|{
operator|*
name|exist_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_preferred_mode
operator|==
name|NULL
condition|)
name|edid
operator|->
name|edid_preferred_mode
operator|=
name|exist_mode
expr_stmt|;
block|}
else|else
block|{
name|edid
operator|->
name|edid_modes
index|[
name|edid
operator|->
name|edid_nmodes
index|]
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_preferred_mode
operator|==
name|NULL
condition|)
name|edid
operator|->
name|edid_preferred_mode
operator|=
operator|&
name|edid
operator|->
name|edid_modes
index|[
name|edid
operator|->
name|edid_nmodes
index|]
expr_stmt|;
name|edid
operator|->
name|edid_nmodes
operator|++
expr_stmt|;
block|}
return|return;
block|}
switch|switch
condition|(
name|EDID_BLOCK_TYPE
argument_list|(
name|data
argument_list|)
condition|)
block|{
case|case
name|EDID_DESC_BLOCK_TYPE_SERIAL
case|:
name|memcpy
argument_list|(
name|edid
operator|->
name|edid_serial
argument_list|,
name|data
operator|+
name|EDID_DESC_ASCII_DATA_OFFSET
argument_list|,
name|EDID_DESC_ASCII_DATA_LEN
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_serial
index|[
sizeof|sizeof
argument_list|(
name|edid
operator|->
name|edid_serial
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EDID_DESC_BLOCK_TYPE_ASCII
case|:
name|memcpy
argument_list|(
name|edid
operator|->
name|edid_comment
argument_list|,
name|data
operator|+
name|EDID_DESC_ASCII_DATA_OFFSET
argument_list|,
name|EDID_DESC_ASCII_DATA_LEN
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_comment
index|[
sizeof|sizeof
argument_list|(
name|edid
operator|->
name|edid_comment
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EDID_DESC_BLOCK_TYPE_RANGE
case|:
name|edid
operator|->
name|edid_have_range
operator|=
literal|1
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_min_vfreq
operator|=
name|EDID_DESC_RANGE_MIN_VFREQ
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_max_vfreq
operator|=
name|EDID_DESC_RANGE_MAX_VFREQ
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_min_hfreq
operator|=
name|EDID_DESC_RANGE_MIN_HFREQ
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_max_hfreq
operator|=
name|EDID_DESC_RANGE_MAX_HFREQ
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_max_clock
operator|=
name|EDID_DESC_RANGE_MAX_CLOCK
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EDID_DESC_RANGE_HAVE_GTF2
argument_list|(
name|data
argument_list|)
condition|)
break|break;
name|edid
operator|->
name|edid_range
operator|.
name|er_have_gtf2
operator|=
literal|1
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_hfreq
operator|=
name|EDID_DESC_RANGE_GTF2_HFREQ
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_c
operator|=
name|EDID_DESC_RANGE_GTF2_C
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_m
operator|=
name|EDID_DESC_RANGE_GTF2_M
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_j
operator|=
name|EDID_DESC_RANGE_GTF2_J
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_range
operator|.
name|er_gtf2_k
operator|=
name|EDID_DESC_RANGE_GTF2_K
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDID_DESC_BLOCK_TYPE_NAME
case|:
comment|/* copy the product name into place */
name|memcpy
argument_list|(
name|edid
operator|->
name|edid_productname
argument_list|,
name|data
operator|+
name|EDID_DESC_ASCII_DATA_OFFSET
argument_list|,
name|EDID_DESC_ASCII_DATA_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|EDID_DESC_BLOCK_TYPE_STD_TIMING
case|:
name|data
operator|+=
name|EDID_DESC_STD_TIMING_START
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_DESC_STD_TIMING_COUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|edid_std_timing
argument_list|(
name|data
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
block|{
comment|/* Does this mode already exist? */
name|exist_mode
operator|=
name|edid_search_mode
argument_list|(
name|edid
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|exist_mode
operator|==
name|NULL
condition|)
block|{
name|edid
operator|->
name|edid_modes
index|[
name|edid
operator|->
name|edid_nmodes
index|]
operator|=
name|mode
expr_stmt|;
name|edid
operator|->
name|edid_nmodes
operator|++
expr_stmt|;
block|}
block|}
name|data
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|EDID_DESC_BLOCK_TYPE_COLOR_POINT
case|:
comment|/* XXX: not implemented yet */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Gets EDID version in BCD, e.g. EDID v1.3  returned as 0x0103  */
end_comment

begin_function
name|int
name|edid_parse
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
name|struct
name|edid_info
modifier|*
name|edid
parameter_list|)
block|{
name|uint16_t
name|manfid
decl_stmt|,
name|estmodes
decl_stmt|;
specifier|const
name|struct
name|videomode
modifier|*
name|vmp
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|max_dotclock
init|=
literal|0
decl_stmt|;
name|int
name|mhz
decl_stmt|;
if|if
condition|(
name|edid_is_valid
argument_list|(
name|data
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* get product identification */
name|manfid
operator|=
name|EDID_VENDOR_ID
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_vendor
index|[
literal|0
index|]
operator|=
name|EDID_MANFID_0
argument_list|(
name|manfid
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_vendor
index|[
literal|1
index|]
operator|=
name|EDID_MANFID_1
argument_list|(
name|manfid
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_vendor
index|[
literal|2
index|]
operator|=
name|EDID_MANFID_2
argument_list|(
name|manfid
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_vendor
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* null terminate for convenience */
name|edid
operator|->
name|edid_product
operator|=
name|data
index|[
name|EDID_OFFSET_PRODUCT_ID
index|]
operator|+
operator|(
name|data
index|[
name|EDID_OFFSET_PRODUCT_ID
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|name
operator|=
name|edid_findvendor
argument_list|(
name|edid
operator|->
name|edid_vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|edid
operator|->
name|edid_vendorname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|edid
operator|->
name|edid_vendorname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|edid
operator|->
name|edid_vendorname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|edid_findproduct
argument_list|(
name|edid
operator|->
name|edid_vendor
argument_list|,
name|edid
operator|->
name|edid_product
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|edid
operator|->
name|edid_productname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|edid
operator|->
name|edid_productname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|edid
operator|->
name|edid_productname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|snprintf
argument_list|(
name|edid
operator|->
name|edid_serial
argument_list|,
sizeof|sizeof
argument_list|(
name|edid
operator|->
name|edid_serial
argument_list|)
argument_list|,
literal|"%08x"
argument_list|,
name|EDID_SERIAL_NUMBER
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_week
operator|=
name|EDID_WEEK
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_year
operator|=
name|EDID_YEAR
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* get edid revision */
name|edid
operator|->
name|edid_version
operator|=
name|EDID_VERSION
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_revision
operator|=
name|EDID_REVISION
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_video_input
operator|=
name|EDID_VIDEO_INPUT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_max_hsize
operator|=
name|EDID_MAX_HSIZE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_max_vsize
operator|=
name|EDID_MAX_VSIZE
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_gamma
operator|=
name|EDID_GAMMA
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_features
operator|=
name|EDID_FEATURES
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_redx
operator|=
name|EDID_CHROMA_REDX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_redy
operator|=
name|EDID_CHROMA_REDX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_greenx
operator|=
name|EDID_CHROMA_GREENX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_greeny
operator|=
name|EDID_CHROMA_GREENY
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_bluex
operator|=
name|EDID_CHROMA_BLUEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_bluey
operator|=
name|EDID_CHROMA_BLUEY
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_whitex
operator|=
name|EDID_CHROMA_WHITEX
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_chroma
operator|.
name|ec_whitey
operator|=
name|EDID_CHROMA_WHITEY
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|edid
operator|->
name|edid_ext_block_count
operator|=
name|EDID_EXT_BLOCK_COUNT
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* lookup established modes */
name|edid
operator|->
name|edid_nmodes
operator|=
literal|0
expr_stmt|;
name|edid
operator|->
name|edid_preferred_mode
operator|=
name|NULL
expr_stmt|;
name|estmodes
operator|=
name|EDID_EST_TIMING
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Iterate in esztablished timing order */
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|estmodes
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|vmp
operator|=
name|edid_mode_lookup_list
argument_list|(
name|_edid_modes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmp
operator|!=
name|NULL
condition|)
block|{
name|edid
operator|->
name|edid_modes
index|[
name|edid
operator|->
name|edid_nmodes
index|]
operator|=
operator|*
name|vmp
expr_stmt|;
name|edid
operator|->
name|edid_nmodes
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
else|else
name|printf
argument_list|(
literal|"no data for est. mode %s\n"
argument_list|,
name|_edid_modes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* do standard timing section */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_STD_TIMING_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|videomode
name|mode
decl_stmt|,
modifier|*
name|exist_mode
decl_stmt|;
if|if
condition|(
name|edid_std_timing
argument_list|(
name|data
operator|+
name|EDID_OFFSET_STD_TIMING
operator|+
name|i
operator|*
literal|2
argument_list|,
operator|&
name|mode
argument_list|)
condition|)
block|{
comment|/* Does this mode already exist? */
name|exist_mode
operator|=
name|edid_search_mode
argument_list|(
name|edid
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|exist_mode
operator|==
name|NULL
condition|)
block|{
name|edid
operator|->
name|edid_modes
index|[
name|edid
operator|->
name|edid_nmodes
index|]
operator|=
name|mode
expr_stmt|;
name|edid
operator|->
name|edid_nmodes
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* do detailed timings and descriptors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EDID_BLOCK_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|edid_block
argument_list|(
name|edid
argument_list|,
name|data
operator|+
name|EDID_OFFSET_DESC_BLOCK
operator|+
name|i
operator|*
name|EDID_BLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
name|edid_strchomp
argument_list|(
name|edid
operator|->
name|edid_vendorname
argument_list|)
expr_stmt|;
name|edid_strchomp
argument_list|(
name|edid
operator|->
name|edid_productname
argument_list|)
expr_stmt|;
name|edid_strchomp
argument_list|(
name|edid
operator|->
name|edid_serial
argument_list|)
expr_stmt|;
name|edid_strchomp
argument_list|(
name|edid
operator|->
name|edid_comment
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * some monitors lie about their maximum supported dot clock 	 * by claiming to support modes which need a higher dot clock 	 * than the stated maximum. 	 * For sanity's sake we bump it to the highest dot clock we find 	 * in the list of supported modes 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|edid
operator|->
name|edid_nmodes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
operator|>
name|max_dotclock
condition|)
name|max_dotclock
operator|=
name|edid
operator|->
name|edid_modes
index|[
name|i
index|]
operator|.
name|dot_clock
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"edid: max_dotclock according to supported modes: %d\n"
argument_list|,
name|max_dotclock
argument_list|)
expr_stmt|;
block|}
name|mhz
operator|=
operator|(
name|max_dotclock
operator|+
literal|999
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|edid
operator|->
name|edid_have_range
condition|)
block|{
if|if
condition|(
name|mhz
operator|>
name|edid
operator|->
name|edid_range
operator|.
name|er_max_clock
condition|)
name|edid
operator|->
name|edid_range
operator|.
name|er_max_clock
operator|=
name|mhz
expr_stmt|;
block|}
else|else
name|edid
operator|->
name|edid_range
operator|.
name|er_max_clock
operator|=
name|mhz
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

