begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: pickmode.c,v 1.3 2011/04/09 18:22:31 jdc Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2006 The NetBSD Foundation  * All rights reserved.  *  * this code was contributed to The NetBSD Foundation by Michael Lorenz  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE NETBSD FOUNDATION BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<dev/videomode/videomode.h>
end_include

begin_include
include|#
directive|include
file|"opt_videomode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PICKMODE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
value|printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
value|while (0) printf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|struct
name|videomode
modifier|*
name|pick_mode_by_dotclock
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|dotclock
parameter_list|)
block|{
specifier|const
name|struct
name|videomode
modifier|*
name|this
decl_stmt|,
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s: looking for %d x %d at up to %d kHz\n"
argument_list|,
name|__func__
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|dotclock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|videomode_count
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|=
operator|&
name|videomode_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|hdisplay
operator|!=
name|width
operator|)
operator|||
operator|(
name|this
operator|->
name|vdisplay
operator|!=
name|height
operator|)
operator|||
operator|(
name|this
operator|->
name|dot_clock
operator|>
name|dotclock
operator|)
condition|)
continue|continue;
if|if
condition|(
name|best
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|this
operator|->
name|dot_clock
operator|>
name|best
operator|->
name|dot_clock
condition|)
name|best
operator|=
name|this
expr_stmt|;
block|}
else|else
name|best
operator|=
name|this
expr_stmt|;
block|}
if|if
condition|(
name|best
operator|!=
name|NULL
condition|)
name|DPRINTF
argument_list|(
literal|"found %s\n"
argument_list|,
name|best
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|best
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|videomode
modifier|*
name|pick_mode_by_ref
parameter_list|(
name|int
name|width
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|refresh
parameter_list|)
block|{
specifier|const
name|struct
name|videomode
modifier|*
name|this
decl_stmt|,
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|int
name|mref
decl_stmt|,
name|closest
init|=
literal|1000
decl_stmt|,
name|i
decl_stmt|,
name|diff
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"%s: looking for %d x %d at up to %d Hz\n"
argument_list|,
name|__func__
argument_list|,
name|width
argument_list|,
name|height
argument_list|,
name|refresh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|videomode_count
condition|;
name|i
operator|++
control|)
block|{
name|this
operator|=
operator|&
name|videomode_list
index|[
name|i
index|]
expr_stmt|;
name|mref
operator|=
name|this
operator|->
name|dot_clock
operator|*
literal|1000
operator|/
operator|(
name|this
operator|->
name|htotal
operator|*
name|this
operator|->
name|vtotal
operator|)
expr_stmt|;
name|diff
operator|=
name|abs
argument_list|(
name|mref
operator|-
name|refresh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this
operator|->
name|hdisplay
operator|!=
name|width
operator|)
operator|||
operator|(
name|this
operator|->
name|vdisplay
operator|!=
name|height
operator|)
condition|)
continue|continue;
name|DPRINTF
argument_list|(
literal|"%s in %d hz, diff %d\n"
argument_list|,
name|this
operator|->
name|name
argument_list|,
name|mref
argument_list|,
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|best
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|diff
operator|<
name|closest
condition|)
block|{
name|best
operator|=
name|this
expr_stmt|;
name|closest
operator|=
name|diff
expr_stmt|;
block|}
block|}
else|else
block|{
name|best
operator|=
name|this
expr_stmt|;
name|closest
operator|=
name|diff
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best
operator|!=
name|NULL
condition|)
name|DPRINTF
argument_list|(
literal|"found %s %d\n"
argument_list|,
name|best
operator|->
name|name
argument_list|,
name|best
operator|->
name|dot_clock
argument_list|)
expr_stmt|;
return|return
name|best
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|swap_modes
parameter_list|(
name|struct
name|videomode
modifier|*
name|left
parameter_list|,
name|struct
name|videomode
modifier|*
name|right
parameter_list|)
block|{
name|struct
name|videomode
name|temp
decl_stmt|;
name|temp
operator|=
operator|*
name|left
expr_stmt|;
operator|*
name|left
operator|=
operator|*
name|right
expr_stmt|;
operator|*
name|right
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sort modes by refresh rate, aspect ratio (*), then resolution.  * Preferred mode or largest mode is first in the list and other modes  * are sorted on closest match to that mode.  * (*) Note that the aspect ratio calculation treats "close" aspect ratios  * (within 12.5%) as the same for this purpose.  */
end_comment

begin_define
define|#
directive|define
name|DIVIDE
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + ((y) / 2)) / (y))
end_define

begin_function
name|void
name|sort_modes
parameter_list|(
name|struct
name|videomode
modifier|*
name|modes
parameter_list|,
name|struct
name|videomode
modifier|*
modifier|*
name|preferred
parameter_list|,
name|int
name|nmodes
parameter_list|)
block|{
name|int
name|aspect
decl_stmt|,
name|refresh
decl_stmt|,
name|hbest
decl_stmt|,
name|vbest
decl_stmt|,
name|abest
decl_stmt|,
name|atemp
decl_stmt|,
name|rbest
decl_stmt|,
name|rtemp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|videomode
modifier|*
name|mtemp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|nmodes
operator|<
literal|2
condition|)
return|return;
if|if
condition|(
operator|*
name|preferred
operator|!=
name|NULL
condition|)
block|{
comment|/* Put the preferred mode first in the list */
name|aspect
operator|=
operator|(
operator|*
name|preferred
operator|)
operator|->
name|hdisplay
operator|*
literal|100
operator|/
operator|(
operator|*
name|preferred
operator|)
operator|->
name|vdisplay
expr_stmt|;
name|refresh
operator|=
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
operator|(
operator|*
name|preferred
operator|)
operator|->
name|dot_clock
operator|*
literal|1000
argument_list|,
operator|(
operator|*
name|preferred
operator|)
operator|->
name|htotal
argument_list|)
argument_list|,
operator|(
operator|*
name|preferred
operator|)
operator|->
name|vtotal
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|preferred
operator|!=
name|modes
condition|)
block|{
name|swap_modes
argument_list|(
operator|*
name|preferred
argument_list|,
name|modes
argument_list|)
expr_stmt|;
operator|*
name|preferred
operator|=
name|modes
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Find the largest horizontal and vertical mode and put that 		 * first in the list.  Preferred refresh rate is taken from 		 * the first mode of this size. 		 */
name|hbest
operator|=
literal|0
expr_stmt|;
name|vbest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|>
name|hbest
condition|)
block|{
name|hbest
operator|=
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
expr_stmt|;
name|vbest
operator|=
name|modes
index|[
name|i
index|]
operator|.
name|vdisplay
expr_stmt|;
name|mtemp
operator|=
operator|&
name|modes
index|[
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|==
name|hbest
operator|&&
name|modes
index|[
name|i
index|]
operator|.
name|vdisplay
operator|>
name|vbest
condition|)
block|{
name|vbest
operator|=
name|modes
index|[
name|i
index|]
operator|.
name|vdisplay
expr_stmt|;
name|mtemp
operator|=
operator|&
name|modes
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|aspect
operator|=
name|mtemp
operator|->
name|hdisplay
operator|*
literal|100
operator|/
name|mtemp
operator|->
name|vdisplay
expr_stmt|;
name|refresh
operator|=
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|mtemp
operator|->
name|dot_clock
operator|*
literal|1000
argument_list|,
name|mtemp
operator|->
name|htotal
argument_list|)
argument_list|,
name|mtemp
operator|->
name|vtotal
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtemp
operator|!=
name|modes
condition|)
name|swap_modes
argument_list|(
name|mtemp
argument_list|,
name|modes
argument_list|)
expr_stmt|;
block|}
comment|/* Sort other modes by refresh rate, aspect ratio, then resolution */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nmodes
operator|-
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|rbest
operator|=
literal|1000
expr_stmt|;
name|abest
operator|=
literal|1000
expr_stmt|;
name|hbest
operator|=
literal|0
expr_stmt|;
name|vbest
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|nmodes
condition|;
name|i
operator|++
control|)
block|{
name|rtemp
operator|=
name|abs
argument_list|(
name|refresh
operator|-
name|DIVIDE
argument_list|(
name|DIVIDE
argument_list|(
name|modes
index|[
name|i
index|]
operator|.
name|dot_clock
operator|*
literal|1000
argument_list|,
name|modes
index|[
name|i
index|]
operator|.
name|htotal
argument_list|)
argument_list|,
name|modes
index|[
name|i
index|]
operator|.
name|vtotal
argument_list|)
argument_list|)
expr_stmt|;
name|atemp
operator|=
operator|(
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|*
literal|100
operator|/
name|modes
index|[
name|i
index|]
operator|.
name|vdisplay
operator|)
expr_stmt|;
if|if
condition|(
name|rtemp
operator|<
name|rbest
condition|)
block|{
name|rbest
operator|=
name|rtemp
expr_stmt|;
name|mtemp
operator|=
operator|&
name|modes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rtemp
operator|==
name|rbest
condition|)
block|{
comment|/* Treat "close" aspect ratios as identical */
if|if
condition|(
name|abs
argument_list|(
name|abest
operator|-
name|atemp
argument_list|)
operator|>
operator|(
name|abest
operator|/
literal|8
operator|)
operator|&&
name|abs
argument_list|(
name|aspect
operator|-
name|atemp
argument_list|)
operator|<
name|abs
argument_list|(
name|aspect
operator|-
name|abest
argument_list|)
condition|)
block|{
name|abest
operator|=
name|atemp
expr_stmt|;
name|mtemp
operator|=
operator|&
name|modes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|atemp
operator|==
name|abest
operator|||
name|abs
argument_list|(
name|abest
operator|-
name|atemp
argument_list|)
operator|<=
operator|(
name|abest
operator|/
literal|8
operator|)
condition|)
block|{
if|if
condition|(
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|>
name|hbest
condition|)
block|{
name|hbest
operator|=
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
expr_stmt|;
name|mtemp
operator|=
operator|&
name|modes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|modes
index|[
name|i
index|]
operator|.
name|hdisplay
operator|==
name|hbest
operator|&&
name|modes
index|[
name|i
index|]
operator|.
name|vdisplay
operator|>
name|vbest
condition|)
block|{
name|vbest
operator|=
name|modes
index|[
name|i
index|]
operator|.
name|vdisplay
expr_stmt|;
name|mtemp
operator|=
operator|&
name|modes
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mtemp
operator|!=
operator|&
name|modes
index|[
name|j
index|]
condition|)
name|swap_modes
argument_list|(
name|mtemp
argument_list|,
operator|&
name|modes
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

