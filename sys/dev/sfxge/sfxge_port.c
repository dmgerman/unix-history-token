begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Solarflare Communications, Inc.  * All rights reserved.  *  * This software was developed in part by Philip Paeps under contract for  * Solarflare Communications, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|"common/efx.h"
end_include

begin_include
include|#
directive|include
file|"sfxge.h"
end_include

begin_function
specifier|static
name|int
name|sfxge_mac_stat_update
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
init|=
operator|&
name|sc
operator|->
name|port
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
init|=
operator|&
operator|(
name|port
operator|->
name|mac_stats
operator|.
name|dma_buf
operator|)
decl_stmt|;
name|clock_t
name|now
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_state
operator|!=
name|SFXGE_PORT_STARTED
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|now
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|port
operator|->
name|mac_stats
operator|.
name|update_time
operator|<
name|hz
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|port
operator|->
name|mac_stats
operator|.
name|update_time
operator|=
name|now
expr_stmt|;
comment|/* If we're unlucky enough to read statistics wduring the DMA, wait 	 * up to 10ms for it to finish (typically takes<500us) */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|100
condition|;
operator|++
name|count
control|)
block|{
name|EFSYS_PROBE1
argument_list|(
argument|wait
argument_list|,
argument|unsigned int
argument_list|,
argument|count
argument_list|)
empty_stmt|;
comment|/* Synchronize the DMA memory for reading */
name|bus_dmamap_sync
argument_list|(
name|esmp
operator|->
name|esm_tag
argument_list|,
name|esmp
operator|->
name|esm_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Try to update the cached counters */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_stats_update
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|esmp
argument_list|,
name|port
operator|->
name|mac_stats
operator|.
name|decode_buf
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|EAGAIN
condition|)
goto|goto
name|out
goto|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|ETIMEDOUT
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_mac_stat_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|id
init|=
name|arg2
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_mac_stat_update
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
name|sc
operator|->
name|port
operator|.
name|mac_stats
operator|.
name|decode_buf
operator|+
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_mac_stat_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|stats_node
argument_list|)
expr_stmt|;
comment|/* Initialise the named stats */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|EFX_MAC_NSTATS
condition|;
name|id
operator|++
control|)
block|{
name|name
operator|=
name|efx_mac_stat_name
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|id
argument_list|,
name|sfxge_mac_stat_handler
argument_list|,
literal|"Q"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SFXGE_HAVE_PAUSE_MEDIAOPTS
end_ifdef

begin_function
specifier|static
name|unsigned
name|int
name|sfxge_port_wanted_fc
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifmedia_entry
modifier|*
name|ifm
init|=
name|sc
operator|->
name|media
operator|.
name|ifm_cur
decl_stmt|;
if|if
condition|(
name|ifm
operator|->
name|ifm_media
operator|==
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
condition|)
return|return
operator|(
name|EFX_FCNTL_RESPOND
operator||
name|EFX_FCNTL_GENERATE
operator|)
return|;
return|return
operator|(
operator|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_ETH_RXPAUSE
operator|)
condition|?
name|EFX_FCNTL_RESPOND
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ifm
operator|->
name|ifm_media
operator|&
name|IFM_ETH_TXPAUSE
operator|)
condition|?
name|EFX_FCNTL_GENERATE
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|sfxge_port_link_fc_ifm
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|int
name|wanted_fc
decl_stmt|,
name|link_fc
decl_stmt|;
name|efx_mac_fcntl_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
operator|&
name|wanted_fc
argument_list|,
operator|&
name|link_fc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|link_fc
operator|&
name|EFX_FCNTL_RESPOND
operator|)
condition|?
name|IFM_ETH_RXPAUSE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|link_fc
operator|&
name|EFX_FCNTL_GENERATE
operator|)
condition|?
name|IFM_ETH_TXPAUSE
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SFXGE_HAVE_PAUSE_MEDIAOPTS */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|sfxge_port_wanted_fc
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|port
operator|.
name|wanted_fc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|sfxge_port_link_fc_ifm
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_port_wanted_fc_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|unsigned
name|int
name|fcntl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|fcntl
argument_list|,
sizeof|sizeof
argument_list|(
name|fcntl
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|port
operator|->
name|wanted_fc
operator|==
name|fcntl
condition|)
goto|goto
name|out
goto|;
name|port
operator|->
name|wanted_fc
operator|=
name|fcntl
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_state
operator|!=
name|SFXGE_PORT_STARTED
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|efx_mac_fcntl_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|port
operator|->
name|wanted_fc
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|port
operator|->
name|wanted_fc
argument_list|,
sizeof|sizeof
argument_list|(
name|port
operator|->
name|wanted_fc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_port_link_fc_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|unsigned
name|int
name|wanted_fc
decl_stmt|,
name|link_fc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_state
operator|==
name|SFXGE_PORT_STARTED
operator|&&
name|SFXGE_LINK_UP
argument_list|(
name|sc
argument_list|)
condition|)
name|efx_mac_fcntl_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
operator|&
name|wanted_fc
argument_list|,
operator|&
name|link_fc
argument_list|)
expr_stmt|;
else|else
name|link_fc
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|link_fc
argument_list|,
sizeof|sizeof
argument_list|(
name|link_fc
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SFXGE_HAVE_PAUSE_MEDIAOPTS */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint64_t
name|sfxge_link_baudrate
index|[
name|EFX_LINK_NMODES
index|]
init|=
block|{
index|[
name|EFX_LINK_10HDX
index|]
operator|=
name|IF_Mbps
argument_list|(
literal|10
argument_list|)
block|,
index|[
name|EFX_LINK_10FDX
index|]
operator|=
name|IF_Mbps
argument_list|(
literal|10
argument_list|)
block|,
index|[
name|EFX_LINK_100HDX
index|]
operator|=
name|IF_Mbps
argument_list|(
literal|100
argument_list|)
block|,
index|[
name|EFX_LINK_100FDX
index|]
operator|=
name|IF_Mbps
argument_list|(
literal|100
argument_list|)
block|,
index|[
name|EFX_LINK_1000HDX
index|]
operator|=
name|IF_Gbps
argument_list|(
literal|1
argument_list|)
block|,
index|[
name|EFX_LINK_1000FDX
index|]
operator|=
name|IF_Gbps
argument_list|(
literal|1
argument_list|)
block|,
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sfxge_mac_link_update
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|efx_link_mode_t
name|mode
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|int
name|link_state
decl_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|link_mode
operator|==
name|mode
condition|)
return|return;
name|port
operator|->
name|link_mode
operator|=
name|mode
expr_stmt|;
comment|/* Push link state update to the OS */
name|link_state
operator|=
operator|(
name|port
operator|->
name|link_mode
operator|!=
name|EFX_LINK_DOWN
condition|?
name|LINK_STATE_UP
else|:
name|LINK_STATE_DOWN
operator|)
expr_stmt|;
name|sc
operator|->
name|ifnet
operator|->
name|if_baudrate
operator|=
name|sfxge_link_baudrate
index|[
name|port
operator|->
name|link_mode
index|]
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifnet
argument_list|,
name|link_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_mac_poll_work
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|efx_nic_t
modifier|*
name|enp
decl_stmt|;
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|efx_link_mode_t
name|mode
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sfxge_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|enp
operator|=
name|sc
operator|->
name|enp
expr_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_state
operator|!=
name|SFXGE_PORT_STARTED
condition|)
goto|goto
name|done
goto|;
comment|/* This may sleep waiting for MCDI completion */
operator|(
name|void
operator|)
name|efx_port_poll
argument_list|(
name|enp
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
name|sfxge_mac_link_update
argument_list|(
name|sc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_mac_filter_set_locked
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|int
name|bucket
index|[
name|EFX_MAC_HASH_BITS
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifnet
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sa
decl_stmt|;
name|efx_nic_t
modifier|*
name|enp
init|=
name|sc
operator|->
name|enp
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Set promisc-unicast and broadcast filter bits */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_filter_set
argument_list|(
name|enp
argument_list|,
operator|!
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Set multicast hash filter */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|EFX_MAC_HASH_BITS
condition|;
name|index
operator|++
control|)
name|bucket
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Broadcast frames also go through the multicast 		 * filter, and the broadcast address hashes to 		 * 0xff. */
name|bucket
index|[
literal|0xff
index|]
operator|=
literal|1
expr_stmt|;
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
expr_stmt|;
name|index
operator|=
name|ether_crc32_le
argument_list|(
name|LLADDR
argument_list|(
name|sa
argument_list|)
argument_list|,
literal|6
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|bucket
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|efx_mac_hash_set
argument_list|(
name|enp
argument_list|,
name|bucket
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sfxge_mac_filter_set
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
init|=
operator|&
name|sc
operator|->
name|port
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * The function may be called without softc_lock held in the 	 * case of SIOCADDMULTI and SIOCDELMULTI ioctls. ioctl handler 	 * checks IFF_DRV_RUNNING flag which implies port started, but 	 * it is not guaranteed to remain. softc_lock shared lock can't 	 * be held in the case of these ioctls processing, since it 	 * results in failure where kernel complains that non-sleepable 	 * lock is held in sleeping thread. Both problems are repeatable 	 * on LAG with LACP proto bring up. 	 */
if|if
condition|(
name|port
operator|->
name|init_state
operator|==
name|SFXGE_PORT_STARTED
condition|)
name|rc
operator|=
name|sfxge_mac_filter_set_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sfxge_port_stop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|efx_nic_t
modifier|*
name|enp
decl_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|enp
operator|=
name|sc
operator|->
name|enp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|port
operator|->
name|init_state
operator|==
name|SFXGE_PORT_STARTED
argument_list|,
operator|(
literal|"port not started"
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|init_state
operator|=
name|SFXGE_PORT_INITIALIZED
expr_stmt|;
name|port
operator|->
name|mac_stats
operator|.
name|update_time
operator|=
literal|0
expr_stmt|;
comment|/* This may call MCDI */
operator|(
name|void
operator|)
name|efx_mac_drain
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mac_stats_periodic
argument_list|(
name|enp
argument_list|,
operator|&
name|port
operator|->
name|mac_stats
operator|.
name|dma_buf
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|port
operator|->
name|link_mode
operator|=
name|EFX_LINK_UNKNOWN
expr_stmt|;
comment|/* Destroy the common code port object. */
name|efx_port_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_port_start
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|mac_addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifnet
decl_stmt|;
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|efx_nic_t
modifier|*
name|enp
decl_stmt|;
name|size_t
name|pdu
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|enp
operator|=
name|sc
operator|->
name|enp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|port
operator|->
name|init_state
operator|==
name|SFXGE_PORT_INITIALIZED
argument_list|,
operator|(
literal|"port not initialized"
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize the port object in the common code. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_port_init
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Set the SDU */
name|pdu
operator|=
name|EFX_MAC_PDU
argument_list|(
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_pdu_set
argument_list|(
name|enp
argument_list|,
name|pdu
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_fcntl_set
argument_list|(
name|enp
argument_list|,
name|sfxge_port_wanted_fc
argument_list|(
name|sc
argument_list|)
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* Set the unicast address */
name|if_addr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifp
operator|->
name|if_addr
operator|->
name|ifa_addr
argument_list|)
argument_list|,
name|mac_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|mac_addr
argument_list|)
argument_list|)
expr_stmt|;
name|if_addr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_addr_set
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|sfxge_mac_filter_set_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Update MAC stats by DMA every second */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_stats_periodic
argument_list|(
name|enp
argument_list|,
operator|&
name|port
operator|->
name|mac_stats
operator|.
name|dma_buf
argument_list|,
literal|1000
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mac_drain
argument_list|(
name|enp
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_phy_adv_cap_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|sc
operator|->
name|media
operator|.
name|ifm_cur
operator|->
name|ifm_data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|port
operator|->
name|init_state
operator|=
name|SFXGE_PORT_STARTED
expr_stmt|;
comment|/* Single poll in case there were missing initial events */
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sfxge_mac_poll_work
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
operator|(
name|void
operator|)
name|efx_mac_drain
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|fail3
label|:
operator|(
name|void
operator|)
name|efx_mac_stats_periodic
argument_list|(
name|enp
argument_list|,
operator|&
name|port
operator|->
name|mac_stats
operator|.
name|dma_buf
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|fail2
label|:
name|efx_port_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|fail
label|:
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_phy_stat_update
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
init|=
operator|&
name|sc
operator|->
name|port
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
init|=
operator|&
name|port
operator|->
name|phy_stats
operator|.
name|dma_buf
decl_stmt|;
name|clock_t
name|now
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|init_state
operator|!=
name|SFXGE_PORT_STARTED
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|now
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|port
operator|->
name|phy_stats
operator|.
name|update_time
operator|<
name|hz
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|port
operator|->
name|phy_stats
operator|.
name|update_time
operator|=
name|now
expr_stmt|;
comment|/* If we're unlucky enough to read statistics wduring the DMA, wait 	 * up to 10ms for it to finish (typically takes<500us) */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|100
condition|;
operator|++
name|count
control|)
block|{
name|EFSYS_PROBE1
argument_list|(
argument|wait
argument_list|,
argument|unsigned int
argument_list|,
argument|count
argument_list|)
empty_stmt|;
comment|/* Synchronize the DMA memory for reading */
name|bus_dmamap_sync
argument_list|(
name|esmp
operator|->
name|esm_tag
argument_list|,
name|esmp
operator|->
name|esm_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
comment|/* Try to update the cached counters */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_phy_stats_update
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|esmp
argument_list|,
name|port
operator|->
name|phy_stats
operator|.
name|decode_buf
argument_list|)
operator|)
operator|!=
name|EAGAIN
condition|)
goto|goto
name|out
goto|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|ETIMEDOUT
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_phy_stat_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|id
init|=
name|arg2
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_phy_stat_update
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|port
operator|.
name|phy_stats
operator|.
name|decode_buf
operator|+
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_phy_stat_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|stat_mask
init|=
name|efx_nic_cfg_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|->
name|enc_phy_stat_mask
decl_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|stats_node
argument_list|)
expr_stmt|;
comment|/* Initialise the named stats */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|EFX_PHY_NSTATS
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|stat_mask
operator|&
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
name|id
operator|)
operator|)
condition|)
continue|continue;
name|name
operator|=
name|efx_phy_stat_name
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|id
argument_list|,
name|sfxge_phy_stat_handler
argument_list|,
name|id
operator|==
name|EFX_PHY_STAT_OUI
condition|?
literal|"IX"
else|:
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sfxge_port_fini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|esmp
operator|=
operator|&
name|port
operator|->
name|mac_stats
operator|.
name|dma_buf
expr_stmt|;
name|KASSERT
argument_list|(
name|port
operator|->
name|init_state
operator|==
name|SFXGE_PORT_INITIALIZED
argument_list|,
operator|(
literal|"Port not initialized"
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|init_state
operator|=
name|SFXGE_PORT_UNINITIALIZED
expr_stmt|;
name|port
operator|->
name|link_mode
operator|=
name|EFX_LINK_UNKNOWN
expr_stmt|;
comment|/* Finish with PHY DMA memory */
name|sfxge_dma_free
argument_list|(
operator|&
name|port
operator|->
name|phy_stats
operator|.
name|dma_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|phy_stats
operator|.
name|decode_buf
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|sfxge_dma_free
argument_list|(
name|esmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|port
operator|->
name|mac_stats
operator|.
name|decode_buf
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|port
operator|->
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_port_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_port
modifier|*
name|port
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|sysctl_ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|sysctl_tree
decl_stmt|;
name|efsys_mem_t
modifier|*
name|mac_stats_buf
decl_stmt|,
modifier|*
name|phy_stats_buf
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|port
operator|=
operator|&
name|sc
operator|->
name|port
expr_stmt|;
name|mac_stats_buf
operator|=
operator|&
name|port
operator|->
name|mac_stats
operator|.
name|dma_buf
expr_stmt|;
name|phy_stats_buf
operator|=
operator|&
name|port
operator|->
name|phy_stats
operator|.
name|dma_buf
expr_stmt|;
name|KASSERT
argument_list|(
name|port
operator|->
name|init_state
operator|==
name|SFXGE_PORT_UNINITIALIZED
argument_list|,
operator|(
literal|"Port already initialized"
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|,
literal|"sfxge_port"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|port
operator|->
name|phy_stats
operator|.
name|decode_buf
operator|=
name|malloc
argument_list|(
name|EFX_PHY_NSTATS
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_PHY_STATS_SIZE
argument_list|,
name|phy_stats_buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|bzero
argument_list|(
name|phy_stats_buf
operator|->
name|esm_base
argument_list|,
name|phy_stats_buf
operator|->
name|esm_size
argument_list|)
expr_stmt|;
name|sfxge_phy_stat_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sysctl_ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sysctl_tree
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SFXGE_HAVE_PAUSE_MEDIAOPTS
comment|/* If flow control cannot be configured or reported through 	 * ifmedia, provide sysctls for it. */
name|port
operator|->
name|wanted_fc
operator|=
name|EFX_FCNTL_RESPOND
operator||
name|EFX_FCNTL_GENERATE
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"wanted_fc"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sfxge_port_wanted_fc_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"wanted flow control mode"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_fc"
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|sfxge_port_link_fc_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"link flow control mode"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|port
operator|->
name|mac_stats
operator|.
name|decode_buf
operator|=
name|malloc
argument_list|(
name|EFX_MAC_NSTATS
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_MAC_STATS_SIZE
argument_list|,
name|mac_stats_buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
name|bzero
argument_list|(
name|mac_stats_buf
operator|->
name|esm_base
argument_list|,
name|mac_stats_buf
operator|->
name|esm_size
argument_list|)
expr_stmt|;
name|sfxge_mac_stat_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|port
operator|->
name|init_state
operator|=
name|SFXGE_PORT_INITIALIZED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|free
argument_list|(
name|port
operator|->
name|mac_stats
operator|.
name|decode_buf
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|sfxge_dma_free
argument_list|(
name|phy_stats_buf
argument_list|)
expr_stmt|;
name|fail
label|:
name|free
argument_list|(
name|port
operator|->
name|phy_stats
operator|.
name|decode_buf
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mtx_destroy
argument_list|(
operator|&
name|port
operator|->
name|lock
argument_list|)
expr_stmt|;
name|port
operator|->
name|sc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sfxge_link_mode
index|[
name|EFX_PHY_MEDIA_NTYPES
index|]
index|[
name|EFX_LINK_NMODES
index|]
init|=
block|{
index|[
name|EFX_PHY_MEDIA_CX4
index|]
operator|=
block|{
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_10G_CX4
block|, 	}
block|,
index|[
name|EFX_PHY_MEDIA_KX4
index|]
operator|=
block|{
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_10G_KX4
block|, 	}
block|,
index|[
name|EFX_PHY_MEDIA_XFP
index|]
operator|=
block|{
comment|/* Don't know the module type, but assume SR for now. */
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_10G_SR
block|, 	}
block|,
index|[
name|EFX_PHY_MEDIA_SFP_PLUS
index|]
operator|=
block|{
comment|/* Don't know the module type, but assume SX/SR for now. */
index|[
name|EFX_LINK_1000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_1000_SX
block|,
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_10G_SR
block|, 	}
block|,
index|[
name|EFX_PHY_MEDIA_BASE_T
index|]
operator|=
block|{
index|[
name|EFX_LINK_10HDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_HDX
operator||
name|IFM_10_T
block|,
index|[
name|EFX_LINK_10FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_10_T
block|,
index|[
name|EFX_LINK_100HDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_HDX
operator||
name|IFM_100_TX
block|,
index|[
name|EFX_LINK_100FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_100_TX
block|,
index|[
name|EFX_LINK_1000HDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_HDX
operator||
name|IFM_1000_T
block|,
index|[
name|EFX_LINK_1000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_1000_T
block|,
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|IFM_ETHER
operator||
name|IFM_FDX
operator||
name|IFM_10G_T
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sfxge_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|efx_phy_media_type_t
name|medium_type
decl_stmt|;
name|efx_link_mode_t
name|mode
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|softc_lock
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
expr_stmt|;
if|if
condition|(
name|SFXGE_RUNNING
argument_list|(
name|sc
argument_list|)
operator|&&
name|SFXGE_LINK_UP
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|efx_phy_media_type_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
operator|&
name|medium_type
argument_list|)
expr_stmt|;
name|mode
operator|=
name|sc
operator|->
name|port
operator|.
name|link_mode
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|sfxge_link_mode
index|[
name|medium_type
index|]
index|[
name|mode
index|]
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|sfxge_port_link_fc_ifm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|softc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|ifm
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifm
operator|=
name|sc
operator|->
name|media
operator|.
name|ifm_cur
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|softc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SFXGE_RUNNING
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rc
operator|=
name|efx_mac_fcntl_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|sfxge_port_wanted_fc
argument_list|(
name|sc
argument_list|)
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|rc
operator|=
name|efx_phy_adv_cap_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|ifm
operator|->
name|ifm_data
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|softc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sfxge_port_ifmedia_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|efx_phy_media_type_t
name|medium_type
decl_stmt|;
name|uint32_t
name|cap_mask
decl_stmt|,
name|mode_cap_mask
decl_stmt|;
name|efx_link_mode_t
name|mode
decl_stmt|;
name|int
name|mode_ifm
decl_stmt|,
name|best_mode_ifm
init|=
literal|0
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* We need port state to initialise the ifmedia list. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_init
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_port_init
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out2
goto|;
comment|/* 	 * Register ifconfig callbacks for querying and setting the 	 * link mode and link status. 	 */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|IFM_IMASK
argument_list|,
name|sfxge_media_change
argument_list|,
name|sfxge_media_status
argument_list|)
expr_stmt|;
comment|/* 	 * Map firmware medium type and capabilities to ifmedia types. 	 * ifmedia does not distinguish between forcing the link mode 	 * and disabling auto-negotiation.  1000BASE-T and 10GBASE-T 	 * require AN even if only one link mode is enabled, and for 	 * 100BASE-TX it is useful even if the link mode is forced. 	 * Therefore we never disable auto-negotiation. 	 * 	 * Also enable and advertise flow control by default. 	 */
name|efx_phy_media_type_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
operator|&
name|medium_type
argument_list|)
expr_stmt|;
name|efx_phy_adv_cap_get
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|EFX_PHY_CAP_PERM
argument_list|,
operator|&
name|cap_mask
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_10HDX
operator|==
name|EFX_PHY_CAP_10HDX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_10FDX
operator|==
name|EFX_PHY_CAP_10FDX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_100HDX
operator|==
name|EFX_PHY_CAP_100HDX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_100FDX
operator|==
name|EFX_PHY_CAP_100FDX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_1000HDX
operator|==
name|EFX_PHY_CAP_1000HDX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_1000FDX
operator|==
name|EFX_PHY_CAP_1000FDX
operator|+
literal|1
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_LINK_10000FDX
operator|==
name|EFX_PHY_CAP_10000FDX
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|EFX_LINK_10HDX
init|;
name|mode
operator|<=
name|EFX_LINK_10000FDX
condition|;
name|mode
operator|++
control|)
block|{
name|mode_cap_mask
operator|=
literal|1
operator|<<
operator|(
name|mode
operator|-
literal|1
operator|)
expr_stmt|;
name|mode_ifm
operator|=
name|sfxge_link_mode
index|[
name|medium_type
index|]
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cap_mask
operator|&
name|mode_cap_mask
operator|)
operator|&&
name|mode_ifm
condition|)
block|{
name|mode_cap_mask
operator||=
name|cap_mask
operator|&
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_AN
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SFXGE_HAVE_PAUSE_MEDIAOPTS
comment|/* No flow-control */
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|mode_ifm
argument_list|,
name|mode_cap_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Respond-only.  If using AN, we implicitly 			 * offer symmetric as well, but that doesn't 			 * mean we *have* to generate pause frames. 			 */
name|mode_cap_mask
operator||=
name|cap_mask
operator|&
operator|(
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_PAUSE
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_ASYM
operator|)
operator|)
expr_stmt|;
name|mode_ifm
operator||=
name|IFM_ETH_RXPAUSE
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|mode_ifm
argument_list|,
name|mode_cap_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Symmetric */
name|mode_cap_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_ASYM
operator|)
expr_stmt|;
name|mode_ifm
operator||=
name|IFM_ETH_TXPAUSE
expr_stmt|;
else|#
directive|else
comment|/* !SFXGE_HAVE_PAUSE_MEDIAOPTS */
name|mode_cap_mask
operator||=
name|cap_mask
operator|&
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_PAUSE
operator|)
expr_stmt|;
endif|#
directive|endif
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|mode_ifm
argument_list|,
name|mode_cap_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Link modes are numbered in order of speed, 			 * so assume the last one available is the best. 			 */
name|best_mode_ifm
operator|=
name|mode_ifm
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cap_mask
operator|&
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_AN
operator|)
condition|)
block|{
comment|/* Add autoselect mode. */
name|mode_ifm
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|mode_ifm
argument_list|,
name|cap_mask
operator|&
operator|~
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_ASYM
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|best_mode_ifm
operator|=
name|mode_ifm
expr_stmt|;
block|}
if|if
condition|(
name|best_mode_ifm
operator|!=
literal|0
condition|)
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|best_mode_ifm
argument_list|)
expr_stmt|;
comment|/* Now discard port state until interface is started. */
name|efx_port_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|out2
label|:
name|efx_nic_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

