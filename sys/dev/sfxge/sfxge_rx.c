begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Solarflare Communications, Inc.  * All rights reserved.  *  * This software was developed in part by Philip Paeps under contract for  * Solarflare Communications, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|"common/efx.h"
end_include

begin_include
include|#
directive|include
file|"sfxge.h"
end_include

begin_include
include|#
directive|include
file|"sfxge_rx.h"
end_include

begin_define
define|#
directive|define
name|RX_REFILL_THRESHOLD
value|(EFX_RXQ_LIMIT(SFXGE_NDESCS) * 9 / 10)
end_define

begin_define
define|#
directive|define
name|RX_REFILL_THRESHOLD_2
value|(RX_REFILL_THRESHOLD / 2)
end_define

begin_comment
comment|/* Size of the LRO hash table.  Must be a power of 2.  A larger table  * means we can accelerate a larger number of streams.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|lro_table_size
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum length of a hash chain.  If chains get too long then the lookup  * time increases and may exceed the benefit of LRO.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|lro_chain_max
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum time (in ticks) that a connection can be idle before it's LRO  * state is discarded.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|lro_idle_ticks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialised in sfxge_rx_init() */
end_comment

begin_comment
comment|/* Number of packets with payload that must arrive in-order before a  * connection is eligible for LRO.  The idea is we should avoid coalescing  * segments when the sender is in slow-start because reducing the ACK rate  * can damage performance.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lro_slow_start_packets
init|=
literal|2000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of packets with payload that must arrive in-order following loss  * before a connection is eligible for LRO.  The idea is we should avoid  * coalescing segments when the sender is recovering from loss, because  * reducing the ACK rate can damage performance.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lro_loss_packets
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags for sfxge_lro_conn::l2_id; must not collide with EVL_VLID_MASK */
end_comment

begin_define
define|#
directive|define
name|SFXGE_LRO_L2_ID_VLAN
value|0x4000
end_define

begin_define
define|#
directive|define
name|SFXGE_LRO_L2_ID_IPV6
value|0x8000
end_define

begin_define
define|#
directive|define
name|SFXGE_LRO_CONN_IS_VLAN_ENCAP
parameter_list|(
name|c
parameter_list|)
value|((c)->l2_id& SFXGE_LRO_L2_ID_VLAN)
end_define

begin_define
define|#
directive|define
name|SFXGE_LRO_CONN_IS_TCPIPV4
parameter_list|(
name|c
parameter_list|)
value|(!((c)->l2_id& SFXGE_LRO_L2_ID_IPV6))
end_define

begin_comment
comment|/* Compare IPv6 addresses, avoiding conditional branches */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|long
name|ipv6_addr_cmp
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|left
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|right
parameter_list|)
block|{
if|#
directive|if
name|LONG_BIT
operator|==
literal|64
specifier|const
name|uint64_t
modifier|*
name|left64
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|left
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|right64
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|right
decl_stmt|;
return|return
operator|(
name|left64
index|[
literal|0
index|]
operator|-
name|right64
index|[
literal|0
index|]
operator|)
operator||
operator|(
name|left64
index|[
literal|1
index|]
operator|-
name|right64
index|[
literal|1
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|left
operator|->
name|s6_addr32
index|[
literal|0
index|]
operator|-
name|right
operator|->
name|s6_addr32
index|[
literal|0
index|]
operator|)
operator||
operator|(
name|left
operator|->
name|s6_addr32
index|[
literal|1
index|]
operator|-
name|right
operator|->
name|s6_addr32
index|[
literal|1
index|]
operator|)
operator||
operator|(
name|left
operator|->
name|s6_addr32
index|[
literal|2
index|]
operator|-
name|right
operator|->
name|s6_addr32
index|[
literal|2
index|]
operator|)
operator||
operator|(
name|left
operator|->
name|s6_addr32
index|[
literal|3
index|]
operator|-
name|right
operator|->
name|s6_addr32
index|[
literal|3
index|]
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sfxge_rx_qflush_done
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|rxq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_rx_qflush_failed
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|rxq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_FAILED
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint8_t
name|toep_key
index|[]
init|=
block|{
literal|0x6d
block|,
literal|0x5a
block|,
literal|0x56
block|,
literal|0xda
block|,
literal|0x25
block|,
literal|0x5b
block|,
literal|0x0e
block|,
literal|0xc2
block|,
literal|0x41
block|,
literal|0x67
block|,
literal|0x25
block|,
literal|0x3d
block|,
literal|0x43
block|,
literal|0xa3
block|,
literal|0x8f
block|,
literal|0xb0
block|,
literal|0xd0
block|,
literal|0xca
block|,
literal|0x2b
block|,
literal|0xcb
block|,
literal|0xae
block|,
literal|0x7b
block|,
literal|0x30
block|,
literal|0xb4
block|,
literal|0x77
block|,
literal|0xcb
block|,
literal|0x2d
block|,
literal|0xa3
block|,
literal|0x80
block|,
literal|0x30
block|,
literal|0xf2
block|,
literal|0x0c
block|,
literal|0x6a
block|,
literal|0x42
block|,
literal|0xb7
block|,
literal|0x3b
block|,
literal|0xbe
block|,
literal|0xac
block|,
literal|0x01
block|,
literal|0xfa
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sfxge_rx_post_refill
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sfxge_rxq
modifier|*
name|rxq
init|=
name|arg
decl_stmt|;
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|uint16_t
name|magic
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|sc
expr_stmt|;
name|index
operator|=
name|rxq
operator|->
name|index
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|index
index|]
expr_stmt|;
name|magic
operator|=
name|SFXGE_MAGIC_RX_QREFILL
operator||
name|index
expr_stmt|;
comment|/* This is guaranteed due to the start/stop order of rx and ev */
name|KASSERT
argument_list|(
name|evq
operator|->
name|init_state
operator|==
name|SFXGE_EVQ_STARTED
argument_list|,
operator|(
literal|"evq not started"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|init_state
operator|==
name|SFXGE_RXQ_STARTED
argument_list|,
operator|(
literal|"rxq not started"
operator|)
argument_list|)
expr_stmt|;
name|efx_ev_qpost
argument_list|(
name|evq
operator|->
name|common
argument_list|,
name|magic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_rx_schedule_refill
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|boolean_t
name|retrying
parameter_list|)
block|{
comment|/* Initially retry after 100 ms, but back off in case of 	 * repeated failures as we probably have to wait for the 	 * administrator to raise the pool limit. */
if|if
condition|(
name|retrying
condition|)
name|rxq
operator|->
name|refill_delay
operator|=
name|min
argument_list|(
name|rxq
operator|->
name|refill_delay
operator|*
literal|2
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
else|else
name|rxq
operator|->
name|refill_delay
operator|=
name|hz
operator|/
literal|10
expr_stmt|;
name|callout_reset_curcpu
argument_list|(
operator|&
name|rxq
operator|->
name|refill_callout
argument_list|,
name|rxq
operator|->
name|refill_delay
argument_list|,
name|sfxge_rx_post_refill
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mbuf
modifier|*
name|sfxge_rx_alloc_mbuf
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mb_args
name|args
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* Allocate mbuf structure */
name|args
operator|.
name|flags
operator|=
name|M_PKTHDR
expr_stmt|;
name|args
operator|.
name|type
operator|=
name|MT_DATA
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|uma_zalloc_arg
argument_list|(
name|zone_mbuf
argument_list|,
operator|&
name|args
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* Allocate (and attach) packet buffer */
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|!
name|uma_zalloc_arg
argument_list|(
name|sc
operator|->
name|rx_buffer_zone
argument_list|,
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|zone_mbuf
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SFXGE_REFILL_BATCH
value|64
end_define

begin_function
specifier|static
name|void
name|sfxge_rx_qfill
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|unsigned
name|int
name|target
parameter_list|,
name|boolean_t
name|retrying
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|batch
decl_stmt|;
name|unsigned
name|int
name|rxfill
decl_stmt|;
name|unsigned
name|int
name|mblksize
decl_stmt|;
name|int
name|ntodo
decl_stmt|;
name|efsys_dma_addr_t
name|addr
index|[
name|SFXGE_REFILL_BATCH
index|]
decl_stmt|;
name|sc
operator|=
name|rxq
operator|->
name|sc
expr_stmt|;
name|index
operator|=
name|rxq
operator|->
name|index
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|index
index|]
expr_stmt|;
name|prefetch_read_many
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
name|prefetch_read_many
argument_list|(
name|rxq
operator|->
name|common
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|init_state
operator|!=
name|SFXGE_RXQ_STARTED
condition|)
return|return;
name|rxfill
operator|=
name|rxq
operator|->
name|added
operator|-
name|rxq
operator|->
name|completed
expr_stmt|;
name|KASSERT
argument_list|(
name|rxfill
operator|<=
name|EFX_RXQ_LIMIT
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
operator|(
literal|"rxfill> EFX_RXQ_LIMIT(SFXGE_NDESCS)"
operator|)
argument_list|)
expr_stmt|;
name|ntodo
operator|=
name|min
argument_list|(
name|EFX_RXQ_LIMIT
argument_list|(
name|SFXGE_NDESCS
argument_list|)
operator|-
name|rxfill
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ntodo
operator|<=
name|EFX_RXQ_LIMIT
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
operator|(
literal|"ntodo> EFX_RQX_LIMIT(SFXGE_NDESCS)"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntodo
operator|==
literal|0
condition|)
return|return;
name|batch
operator|=
literal|0
expr_stmt|;
name|mblksize
operator|=
name|sc
operator|->
name|rx_buffer_size
expr_stmt|;
while|while
condition|(
name|ntodo
operator|--
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|id
decl_stmt|;
name|struct
name|sfxge_rx_sw_desc
modifier|*
name|rx_desc
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|id
operator|=
operator|(
name|rxq
operator|->
name|added
operator|+
name|batch
operator|)
operator|&
operator|(
name|SFXGE_NDESCS
operator|-
literal|1
operator|)
expr_stmt|;
name|rx_desc
operator|=
operator|&
name|rxq
operator|->
name|queue
index|[
name|id
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rx_desc
operator|->
name|mbuf
operator|==
name|NULL
argument_list|,
operator|(
literal|"rx_desc->mbuf != NULL"
operator|)
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|flags
operator|=
name|EFX_DISCARD
expr_stmt|;
name|m
operator|=
name|rx_desc
operator|->
name|mbuf
operator|=
name|sfxge_rx_alloc_mbuf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|sfxge_map_mbuf_fast
argument_list|(
name|rxq
operator|->
name|mem
operator|.
name|esm_tag
argument_list|,
name|rxq
operator|->
name|mem
operator|.
name|esm_map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|)
expr_stmt|;
name|addr
index|[
name|batch
operator|++
index|]
operator|=
name|seg
operator|.
name|ds_addr
expr_stmt|;
if|if
condition|(
name|batch
operator|==
name|SFXGE_REFILL_BATCH
condition|)
block|{
name|efx_rx_qpost
argument_list|(
name|rxq
operator|->
name|common
argument_list|,
name|addr
argument_list|,
name|mblksize
argument_list|,
name|batch
argument_list|,
name|rxq
operator|->
name|completed
argument_list|,
name|rxq
operator|->
name|added
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|added
operator|+=
name|batch
expr_stmt|;
name|batch
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ntodo
operator|!=
literal|0
condition|)
name|sfxge_rx_schedule_refill
argument_list|(
name|rxq
argument_list|,
name|retrying
argument_list|)
expr_stmt|;
if|if
condition|(
name|batch
operator|!=
literal|0
condition|)
block|{
name|efx_rx_qpost
argument_list|(
name|rxq
operator|->
name|common
argument_list|,
name|addr
argument_list|,
name|mblksize
argument_list|,
name|batch
argument_list|,
name|rxq
operator|->
name|completed
argument_list|,
name|rxq
operator|->
name|added
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|added
operator|+=
name|batch
expr_stmt|;
block|}
comment|/* Make the descriptors visible to the hardware */
name|bus_dmamap_sync
argument_list|(
name|rxq
operator|->
name|mem
operator|.
name|esm_tag
argument_list|,
name|rxq
operator|->
name|mem
operator|.
name|esm_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|efx_rx_qpush
argument_list|(
name|rxq
operator|->
name|common
argument_list|,
name|rxq
operator|->
name|added
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_rx_qrefill
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
if|if
condition|(
name|rxq
operator|->
name|init_state
operator|!=
name|SFXGE_RXQ_STARTED
condition|)
return|return;
comment|/* Make sure the queue is full */
name|sfxge_rx_qfill
argument_list|(
name|rxq
argument_list|,
name|EFX_RXQ_LIMIT
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__sfxge_rx_deliver
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifnet
decl_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|ifp
operator|->
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_rx_deliver
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|sfxge_rx_sw_desc
modifier|*
name|rx_desc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|rx_desc
operator|->
name|mbuf
decl_stmt|;
name|int
name|csum_flags
decl_stmt|;
comment|/* Convert checksum flags */
name|csum_flags
operator|=
operator|(
name|rx_desc
operator|->
name|flags
operator|&
name|EFX_CKSUM_IPV4
operator|)
condition|?
operator|(
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|rx_desc
operator|->
name|flags
operator|&
name|EFX_CKSUM_TCPUDP
condition|)
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
comment|/* The hash covers a 4-tuple for TCP only */
if|if
condition|(
name|rx_desc
operator|->
name|flags
operator|&
name|EFX_PKT_TCP
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|EFX_RX_HASH_VALUE
argument_list|(
name|EFX_RX_HASHALG_TOEPLITZ
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_data
operator|+=
name|sc
operator|->
name|rx_prefix_size
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|rx_desc
operator|->
name|size
operator|-
name|sc
operator|->
name|rx_prefix_size
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|csum_flags
expr_stmt|;
name|__sfxge_rx_deliver
argument_list|(
name|sc
argument_list|,
name|rx_desc
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|flags
operator|=
name|EFX_DISCARD
expr_stmt|;
name|rx_desc
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_deliver
parameter_list|(
name|struct
name|sfxge_lro_state
modifier|*
name|st
parameter_list|,
name|struct
name|sfxge_lro_conn
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|st
operator|->
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|c
operator|->
name|mbuf
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|c_th
decl_stmt|;
name|int
name|csum_flags
decl_stmt|;
name|KASSERT
argument_list|(
name|m
argument_list|,
operator|(
literal|"no mbuf to deliver"
operator|)
argument_list|)
expr_stmt|;
operator|++
name|st
operator|->
name|n_bursts
expr_stmt|;
comment|/* Finish off packet munging and recalculate IP header checksum. */
if|if
condition|(
name|SFXGE_LRO_CONN_IS_TCPIPV4
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|iph
init|=
name|c
operator|->
name|nh
decl_stmt|;
name|iph
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|iph
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|iph
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|iph
argument_list|)
expr_stmt|;
name|c_th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
name|csum_flags
operator|=
operator|(
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
operator||
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|iph
init|=
name|c
operator|->
name|nh
decl_stmt|;
name|iph
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|iph
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|c_th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
name|csum_flags
operator|=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
block|}
name|c_th
operator|->
name|th_win
operator|=
name|c
operator|->
name|th_last
operator|->
name|th_win
expr_stmt|;
name|c_th
operator|->
name|th_ack
operator|=
name|c
operator|->
name|th_last
operator|->
name|th_ack
expr_stmt|;
if|if
condition|(
name|c_th
operator|->
name|th_off
operator|==
name|c
operator|->
name|th_last
operator|->
name|th_off
condition|)
block|{
comment|/* Copy TCP options (take care to avoid going negative). */
name|int
name|optlen
init|=
operator|(
operator|(
name|c_th
operator|->
name|th_off
operator|-
literal|5
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|2u
decl_stmt|;
name|memcpy
argument_list|(
name|c_th
operator|+
literal|1
argument_list|,
name|c
operator|->
name|th_last
operator|+
literal|1
argument_list|,
name|optlen
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SFXGE_HAVE_MQ
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|c
operator|->
name|conn_hash
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|csum_flags
expr_stmt|;
name|__sfxge_rx_deliver
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|c
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|delivered
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Drop the given connection, and add it to the free list. */
end_comment

begin_function
specifier|static
name|void
name|sfxge_lro_drop
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|sfxge_lro_conn
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|bucket
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|c
operator|->
name|mbuf
argument_list|,
operator|(
literal|"found orphaned mbuf"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next_buf
operator|.
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|sfxge_rx_deliver
argument_list|(
name|rxq
operator|->
name|sc
argument_list|,
operator|&
name|c
operator|->
name|next_buf
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|c
argument_list|,
name|active_link
argument_list|)
expr_stmt|;
block|}
name|bucket
operator|=
name|c
operator|->
name|conn_hash
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns_mask
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|lro
operator|.
name|conns_n
index|[
name|bucket
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"LRO: bucket fill level wrong"
operator|)
argument_list|)
expr_stmt|;
operator|--
name|rxq
operator|->
name|lro
operator|.
name|conns_n
index|[
name|bucket
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns
index|[
name|bucket
index|]
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|free_conns
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop tracking connections that have gone idle in order to keep hash  * chains short.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_lro_purge_idle
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|unsigned
name|now
parameter_list|)
block|{
name|struct
name|sfxge_lro_conn
modifier|*
name|c
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|active_conns
argument_list|)
argument_list|,
operator|(
literal|"found active connections"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|lro
operator|.
name|last_purge_ticks
operator|=
name|now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|rxq
operator|->
name|lro
operator|.
name|conns_mask
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|c
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns
index|[
name|i
index|]
argument_list|,
name|sfxge_lro_tailq
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|c
operator|->
name|last_pkt_ticks
operator|>
name|lro_idle_ticks
condition|)
block|{
operator|++
name|rxq
operator|->
name|lro
operator|.
name|n_drop_idle
expr_stmt|;
name|sfxge_lro_drop
argument_list|(
name|rxq
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_merge
parameter_list|(
name|struct
name|sfxge_lro_state
modifier|*
name|st
parameter_list|,
name|struct
name|sfxge_lro_conn
modifier|*
name|c
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|struct
name|tcphdr
modifier|*
name|c_th
decl_stmt|;
comment|/* Tack the new mbuf onto the chain. */
name|KASSERT
argument_list|(
operator|!
name|mbuf
operator|->
name|m_next
argument_list|,
operator|(
literal|"mbuf already chained"
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mbuf_tail
operator|->
name|m_next
operator|=
name|mbuf
expr_stmt|;
name|c
operator|->
name|mbuf_tail
operator|=
name|mbuf
expr_stmt|;
comment|/* Increase length appropriately */
name|c
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mbuf
operator|->
name|m_len
expr_stmt|;
comment|/* Update the connection state flags */
if|if
condition|(
name|SFXGE_LRO_CONN_IS_TCPIPV4
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|iph
init|=
name|c
operator|->
name|nh
decl_stmt|;
name|iph
operator|->
name|ip_len
operator|+=
name|mbuf
operator|->
name|m_len
expr_stmt|;
name|c_th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|iph
init|=
name|c
operator|->
name|nh
decl_stmt|;
name|iph
operator|->
name|ip6_plen
operator|+=
name|mbuf
operator|->
name|m_len
expr_stmt|;
name|c_th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|c_th
operator|->
name|th_flags
operator||=
operator|(
name|th
operator|->
name|th_flags
operator|&
name|TH_PUSH
operator|)
expr_stmt|;
name|c
operator|->
name|th_last
operator|=
name|th
expr_stmt|;
operator|++
name|st
operator|->
name|n_merges
expr_stmt|;
comment|/* Pass packet up now if another segment could overflow the IP 	 * length. 	 */
if|if
condition|(
name|c
operator|->
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
literal|65536
operator|-
literal|9200
condition|)
name|sfxge_lro_deliver
argument_list|(
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_start
parameter_list|(
name|struct
name|sfxge_lro_state
modifier|*
name|st
parameter_list|,
name|struct
name|sfxge_lro_conn
modifier|*
name|c
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mbuf
parameter_list|,
name|void
modifier|*
name|nh
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
comment|/* Start the chain */
name|c
operator|->
name|mbuf
operator|=
name|mbuf
expr_stmt|;
name|c
operator|->
name|mbuf_tail
operator|=
name|c
operator|->
name|mbuf
expr_stmt|;
name|c
operator|->
name|nh
operator|=
name|nh
expr_stmt|;
name|c
operator|->
name|th_last
operator|=
name|th
expr_stmt|;
name|mbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mbuf
operator|->
name|m_len
expr_stmt|;
comment|/* Mangle header fields for later processing */
if|if
condition|(
name|SFXGE_LRO_CONN_IS_TCPIPV4
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|iph
init|=
name|nh
decl_stmt|;
name|iph
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|iph
init|=
name|nh
decl_stmt|;
name|iph
operator|->
name|ip6_plen
operator|=
name|ntohs
argument_list|(
name|iph
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to merge or otherwise hold or deliver (as appropriate) the  * packet buffered for this connection (c->next_buf).  Return a flag  * indicating whether the connection is still active for LRO purposes.  */
end_comment

begin_function
specifier|static
name|int
name|sfxge_lro_try_merge
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|sfxge_lro_conn
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|sfxge_rx_sw_desc
modifier|*
name|rx_buf
init|=
operator|&
name|c
operator|->
name|next_buf
decl_stmt|;
name|char
modifier|*
name|eh
init|=
name|c
operator|->
name|next_eh
decl_stmt|;
name|int
name|data_length
decl_stmt|,
name|hdr_length
decl_stmt|,
name|dont_merge
decl_stmt|;
name|unsigned
name|th_seq
decl_stmt|,
name|pkt_length
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|unsigned
name|now
decl_stmt|;
if|if
condition|(
name|SFXGE_LRO_CONN_IS_TCPIPV4
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|iph
init|=
name|c
operator|->
name|next_nh
decl_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
name|pkt_length
operator|=
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
operator|+
operator|(
name|char
operator|*
operator|)
name|iph
operator|-
name|eh
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|iph
init|=
name|c
operator|->
name|next_nh
decl_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
name|pkt_length
operator|=
name|ntohs
argument_list|(
name|iph
operator|->
name|ip6_plen
argument_list|)
operator|+
operator|(
name|char
operator|*
operator|)
name|th
operator|-
name|eh
expr_stmt|;
block|}
name|hdr_length
operator|=
operator|(
name|char
operator|*
operator|)
name|th
operator|+
name|th
operator|->
name|th_off
operator|*
literal|4
operator|-
name|eh
expr_stmt|;
name|data_length
operator|=
operator|(
name|min
argument_list|(
name|pkt_length
argument_list|,
name|rx_buf
operator|->
name|size
operator|-
name|rxq
operator|->
name|sc
operator|->
name|rx_prefix_size
argument_list|)
operator|-
name|hdr_length
operator|)
expr_stmt|;
name|th_seq
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|dont_merge
operator|=
operator|(
operator|(
name|data_length
operator|<=
literal|0
operator|)
operator||
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_URG
operator||
name|TH_SYN
operator||
name|TH_RST
operator||
name|TH_FIN
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Check for options other than aligned timestamp. */
if|if
condition|(
name|th
operator|->
name|th_off
operator|!=
literal|5
condition|)
block|{
specifier|const
name|uint32_t
modifier|*
name|opt_ptr
init|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|th
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|th
operator|->
name|th_off
operator|==
literal|8
operator|&&
name|opt_ptr
index|[
literal|0
index|]
operator|==
name|ntohl
argument_list|(
operator|(
name|TCPOPT_NOP
operator|<<
literal|24
operator|)
operator||
operator|(
name|TCPOPT_NOP
operator|<<
literal|16
operator|)
operator||
operator|(
name|TCPOPT_TIMESTAMP
operator|<<
literal|8
operator|)
operator||
name|TCPOLEN_TIMESTAMP
argument_list|)
condition|)
block|{
comment|/* timestamp option -- okay */
block|}
else|else
block|{
name|dont_merge
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|th_seq
operator|!=
name|c
operator|->
name|next_seq
argument_list|)
condition|)
block|{
comment|/* Out-of-order, so start counting again. */
if|if
condition|(
name|c
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
name|sfxge_lro_deliver
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|n_in_order_pkts
operator|-=
name|lro_loss_packets
expr_stmt|;
name|c
operator|->
name|next_seq
operator|=
name|th_seq
operator|+
name|data_length
expr_stmt|;
operator|++
name|rxq
operator|->
name|lro
operator|.
name|n_misorder
expr_stmt|;
goto|goto
name|deliver_buf_out
goto|;
block|}
name|c
operator|->
name|next_seq
operator|=
name|th_seq
operator|+
name|data_length
expr_stmt|;
name|now
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|c
operator|->
name|last_pkt_ticks
operator|>
name|lro_idle_ticks
condition|)
block|{
operator|++
name|rxq
operator|->
name|lro
operator|.
name|n_drop_idle
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
name|sfxge_lro_deliver
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sfxge_lro_drop
argument_list|(
name|rxq
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|->
name|last_pkt_ticks
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|n_in_order_pkts
operator|<
name|lro_slow_start_packets
condition|)
block|{
comment|/* May be in slow-start, so don't merge. */
operator|++
name|rxq
operator|->
name|lro
operator|.
name|n_slow_start
expr_stmt|;
operator|++
name|c
operator|->
name|n_in_order_pkts
expr_stmt|;
goto|goto
name|deliver_buf_out
goto|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|dont_merge
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
name|sfxge_lro_deliver
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_FIN
operator||
name|TH_RST
operator|)
condition|)
block|{
operator|++
name|rxq
operator|->
name|lro
operator|.
name|n_drop_closed
expr_stmt|;
name|sfxge_lro_drop
argument_list|(
name|rxq
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|deliver_buf_out
goto|;
block|}
name|rx_buf
operator|->
name|mbuf
operator|->
name|m_data
operator|+=
name|rxq
operator|->
name|sc
operator|->
name|rx_prefix_size
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|c
operator|->
name|mbuf
operator|!=
name|NULL
argument_list|)
condition|)
block|{
comment|/* Remove headers and any padding */
name|rx_buf
operator|->
name|mbuf
operator|->
name|m_data
operator|+=
name|hdr_length
expr_stmt|;
name|rx_buf
operator|->
name|mbuf
operator|->
name|m_len
operator|=
name|data_length
expr_stmt|;
name|sfxge_lro_merge
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|c
argument_list|,
name|rx_buf
operator|->
name|mbuf
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remove any padding */
name|rx_buf
operator|->
name|mbuf
operator|->
name|m_len
operator|=
name|pkt_length
expr_stmt|;
name|sfxge_lro_start
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|c
argument_list|,
name|rx_buf
operator|->
name|mbuf
argument_list|,
name|c
operator|->
name|next_nh
argument_list|,
name|th
argument_list|)
expr_stmt|;
block|}
name|rx_buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|deliver_buf_out
label|:
name|sfxge_rx_deliver
argument_list|(
name|rxq
operator|->
name|sc
argument_list|,
name|rx_buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_new_conn
parameter_list|(
name|struct
name|sfxge_lro_state
modifier|*
name|st
parameter_list|,
name|uint32_t
name|conn_hash
parameter_list|,
name|uint16_t
name|l2_id
parameter_list|,
name|void
modifier|*
name|nh
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|unsigned
name|bucket
init|=
name|conn_hash
operator|&
name|st
operator|->
name|conns_mask
decl_stmt|;
name|struct
name|sfxge_lro_conn
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|conns_n
index|[
name|bucket
index|]
operator|>=
name|lro_chain_max
condition|)
block|{
operator|++
name|st
operator|->
name|n_too_many
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|)
condition|)
block|{
name|c
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
return|return;
name|c
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|next_buf
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Create the connection tracking data */
operator|++
name|st
operator|->
name|conns_n
index|[
name|bucket
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|st
operator|->
name|conns
index|[
name|bucket
index|]
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|c
operator|->
name|l2_id
operator|=
name|l2_id
expr_stmt|;
name|c
operator|->
name|conn_hash
operator|=
name|conn_hash
expr_stmt|;
name|c
operator|->
name|source
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|c
operator|->
name|dest
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
name|c
operator|->
name|n_in_order_pkts
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|last_pkt_ticks
operator|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
operator|&
name|ticks
expr_stmt|;
name|c
operator|->
name|delivered
operator|=
literal|0
expr_stmt|;
operator|++
name|st
operator|->
name|n_new_stream
expr_stmt|;
comment|/* NB. We don't initialise c->next_seq, and it doesn't matter what 	 * value it has.  Most likely the next packet received for this 	 * connection will not match -- no harm done. 	 */
block|}
end_function

begin_comment
comment|/* Process mbuf and decide whether to dispatch it to the stack now or  * later.  */
end_comment

begin_function
specifier|static
name|void
name|sfxge_lro
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|struct
name|sfxge_rx_sw_desc
modifier|*
name|rx_buf
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|rxq
operator|->
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|rx_buf
operator|->
name|mbuf
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|sfxge_lro_conn
modifier|*
name|c
decl_stmt|;
name|uint16_t
name|l2_id
decl_stmt|;
name|uint16_t
name|l3_proto
decl_stmt|;
name|void
modifier|*
name|nh
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|uint32_t
name|conn_hash
decl_stmt|;
name|unsigned
name|bucket
decl_stmt|;
comment|/* Get the hardware hash */
name|conn_hash
operator|=
name|EFX_RX_HASH_VALUE
argument_list|(
name|EFX_RX_HASHALG_TOEPLITZ
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|sc
operator|->
name|rx_prefix_size
operator|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|veh
init|=
operator|(
expr|struct
name|ether_vlan_header
operator|*
operator|)
name|eh
decl_stmt|;
name|l2_id
operator|=
name|EVL_VLANOFTAG
argument_list|(
name|ntohs
argument_list|(
name|veh
operator|->
name|evl_tag
argument_list|)
argument_list|)
operator||
name|SFXGE_LRO_L2_ID_VLAN
expr_stmt|;
name|l3_proto
operator|=
name|veh
operator|->
name|evl_proto
expr_stmt|;
name|nh
operator|=
name|veh
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l2_id
operator|=
literal|0
expr_stmt|;
name|l3_proto
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|nh
operator|=
name|eh
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Check whether this is a suitable packet (unfragmented 	 * TCP/IPv4 or TCP/IPv6).  If so, find the TCP header and 	 * length, and compute a hash if necessary.  If not, return. 	 */
if|if
condition|(
name|l3_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|iph
init|=
name|nh
decl_stmt|;
if|if
condition|(
operator|(
name|iph
operator|->
name|ip_p
operator|-
name|IPPROTO_TCP
operator|)
operator||
operator|(
name|iph
operator|->
name|ip_hl
operator|-
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|iph
argument_list|)
operator|>>
literal|2u
operator|)
operator|)
operator||
operator|(
name|iph
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
operator|)
condition|)
goto|goto
name|deliver_now
goto|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l3_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|iph
init|=
name|nh
decl_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
condition|)
goto|goto
name|deliver_now
goto|;
name|l2_id
operator||=
name|SFXGE_LRO_L2_ID_IPV6
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|iph
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|deliver_now
goto|;
block|}
name|bucket
operator|=
name|conn_hash
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns_mask
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|c
argument_list|,
argument|&rxq->lro.conns[bucket]
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|->
name|l2_id
operator|-
name|l2_id
operator|)
operator||
operator|(
name|c
operator|->
name|conn_hash
operator|-
name|conn_hash
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|c
operator|->
name|source
operator|-
name|th
operator|->
name|th_sport
operator|)
operator||
operator|(
name|c
operator|->
name|dest
operator|-
name|th
operator|->
name|th_dport
operator|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SFXGE_LRO_CONN_IS_TCPIPV4
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|struct
name|ip
modifier|*
name|c_iph
decl_stmt|,
modifier|*
name|iph
init|=
name|nh
decl_stmt|;
name|c_iph
operator|=
name|c
operator|->
name|nh
expr_stmt|;
if|if
condition|(
operator|(
name|c_iph
operator|->
name|ip_src
operator|.
name|s_addr
operator|-
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
operator|)
operator||
operator|(
name|c_iph
operator|->
name|ip_dst
operator|.
name|s_addr
operator|-
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
operator|)
condition|)
continue|continue;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|c_iph
decl_stmt|,
modifier|*
name|iph
init|=
name|nh
decl_stmt|;
name|c_iph
operator|=
name|c
operator|->
name|nh
expr_stmt|;
if|if
condition|(
name|ipv6_addr_cmp
argument_list|(
operator|&
name|c_iph
operator|->
name|ip6_src
argument_list|,
operator|&
name|iph
operator|->
name|ip6_src
argument_list|)
operator||
name|ipv6_addr_cmp
argument_list|(
operator|&
name|c_iph
operator|->
name|ip6_dst
argument_list|,
operator|&
name|iph
operator|->
name|ip6_dst
argument_list|)
condition|)
continue|continue;
block|}
block|}
comment|/* Re-insert at head of list to reduce lookup time. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns
index|[
name|bucket
index|]
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|conns
index|[
name|bucket
index|]
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|next_buf
operator|.
name|mbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|sfxge_lro_try_merge
argument_list|(
name|rxq
argument_list|,
name|c
argument_list|)
condition|)
goto|goto
name|deliver_now
goto|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|rxq
operator|->
name|lro
operator|.
name|active_conns
argument_list|,
name|c
argument_list|,
name|active_link
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|next_buf
operator|=
operator|*
name|rx_buf
expr_stmt|;
name|c
operator|->
name|next_eh
operator|=
name|eh
expr_stmt|;
name|c
operator|->
name|next_nh
operator|=
name|nh
expr_stmt|;
name|rx_buf
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
name|rx_buf
operator|->
name|flags
operator|=
name|EFX_DISCARD
expr_stmt|;
return|return;
block|}
name|sfxge_lro_new_conn
argument_list|(
operator|&
name|rxq
operator|->
name|lro
argument_list|,
name|conn_hash
argument_list|,
name|l2_id
argument_list|,
name|nh
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|deliver_now
label|:
name|sfxge_rx_deliver
argument_list|(
name|sc
argument_list|,
name|rx_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_end_of_burst
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|sfxge_lro_state
modifier|*
name|st
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
name|struct
name|sfxge_lro_conn
modifier|*
name|c
decl_stmt|;
name|unsigned
name|t
decl_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|st
operator|->
name|active_conns
argument_list|)
condition|)
block|{
name|c
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|st
operator|->
name|active_conns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|delivered
operator|&&
name|c
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
name|sfxge_lro_deliver
argument_list|(
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfxge_lro_try_merge
argument_list|(
name|rxq
argument_list|,
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
name|sfxge_lro_deliver
argument_list|(
name|st
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|c
argument_list|,
name|active_link
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|delivered
operator|=
literal|0
expr_stmt|;
block|}
name|t
operator|=
operator|*
operator|(
specifier|volatile
name|int
operator|*
operator|)
operator|&
name|ticks
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|t
operator|!=
name|st
operator|->
name|last_purge_ticks
argument_list|)
condition|)
name|sfxge_lro_purge_idle
argument_list|(
name|rxq
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sfxge_rx_qcomplete
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|,
name|boolean_t
name|eop
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|rxq
operator|->
name|sc
decl_stmt|;
name|int
name|lro_enabled
init|=
name|sc
operator|->
name|ifnet
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|completed
decl_stmt|;
name|unsigned
name|int
name|level
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sfxge_rx_sw_desc
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|index
operator|=
name|rxq
operator|->
name|index
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|index
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|completed
operator|=
name|rxq
operator|->
name|completed
expr_stmt|;
while|while
condition|(
name|completed
operator|!=
name|rxq
operator|->
name|pending
condition|)
block|{
name|unsigned
name|int
name|id
decl_stmt|;
name|struct
name|sfxge_rx_sw_desc
modifier|*
name|rx_desc
decl_stmt|;
name|id
operator|=
name|completed
operator|++
operator|&
operator|(
name|SFXGE_NDESCS
operator|-
literal|1
operator|)
expr_stmt|;
name|rx_desc
operator|=
operator|&
name|rxq
operator|->
name|queue
index|[
name|id
index|]
expr_stmt|;
name|m
operator|=
name|rx_desc
operator|->
name|mbuf
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|init_state
operator|!=
name|SFXGE_RXQ_STARTED
condition|)
goto|goto
name|discard
goto|;
if|if
condition|(
name|rx_desc
operator|->
name|flags
operator|&
operator|(
name|EFX_ADDR_MISMATCH
operator||
name|EFX_DISCARD
operator|)
condition|)
goto|goto
name|discard
goto|;
name|prefetch_read_many
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for loopback packets */
if|if
condition|(
operator|!
operator|(
name|rx_desc
operator|->
name|flags
operator|&
name|EFX_PKT_IPV4
operator|)
operator|&&
operator|!
operator|(
name|rx_desc
operator|->
name|flags
operator|&
name|EFX_PKT_IPV6
operator|)
condition|)
block|{
name|struct
name|ether_header
modifier|*
name|etherhp
decl_stmt|;
comment|/*LINTED*/
name|etherhp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|etherhp
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|SFXGE_ETHERTYPE_LOOPBACK
argument_list|)
condition|)
block|{
name|EFSYS_PROBE
argument_list|(
name|loopback
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|loopback
operator|++
expr_stmt|;
goto|goto
name|discard
goto|;
block|}
block|}
comment|/* Pass packet up the stack or into LRO (pipelined) */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lro_enabled
condition|)
name|sfxge_lro
argument_list|(
name|rxq
argument_list|,
name|prev
argument_list|)
expr_stmt|;
else|else
name|sfxge_rx_deliver
argument_list|(
name|sc
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|rx_desc
expr_stmt|;
continue|continue;
name|discard
label|:
comment|/* Return the packet to the pool */
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|rxq
operator|->
name|completed
operator|=
name|completed
expr_stmt|;
name|level
operator|=
name|rxq
operator|->
name|added
operator|-
name|rxq
operator|->
name|completed
expr_stmt|;
comment|/* Pass last packet up the stack or into LRO */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|lro_enabled
condition|)
name|sfxge_lro
argument_list|(
name|rxq
argument_list|,
name|prev
argument_list|)
expr_stmt|;
else|else
name|sfxge_rx_deliver
argument_list|(
name|sc
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are any pending flows and this is the end of the 	 * poll then they must be completed. 	 */
if|if
condition|(
name|eop
condition|)
name|sfxge_lro_end_of_burst
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
comment|/* Top up the queue if necessary */
if|if
condition|(
name|level
operator|<
name|RX_REFILL_THRESHOLD
condition|)
name|sfxge_rx_qfill
argument_list|(
name|rxq
argument_list|,
name|EFX_RXQ_LIMIT
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_rx_qstop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rxq
operator|=
name|sc
operator|->
name|rxq
index|[
name|index
index|]
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|index
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|init_state
operator|==
name|SFXGE_RXQ_STARTED
argument_list|,
operator|(
literal|"rxq not started"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|init_state
operator|=
name|SFXGE_RXQ_INITIALIZED
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|rxq
operator|->
name|refill_callout
argument_list|)
expr_stmt|;
name|again
label|:
name|rxq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_PENDING
expr_stmt|;
comment|/* Flush the receive queue */
name|efx_rx_qflush
argument_list|(
name|rxq
operator|->
name|common
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Spin for 100 ms */
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|flush_state
operator|!=
name|SFXGE_FLUSH_PENDING
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|count
operator|<
literal|20
condition|)
do|;
name|mtx_lock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxq
operator|->
name|flush_state
operator|==
name|SFXGE_FLUSH_FAILED
condition|)
goto|goto
name|again
goto|;
name|rxq
operator|->
name|flush_state
operator|=
name|SFXGE_FLUSH_DONE
expr_stmt|;
name|rxq
operator|->
name|pending
operator|=
name|rxq
operator|->
name|added
expr_stmt|;
name|sfxge_rx_qcomplete
argument_list|(
name|rxq
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|completed
operator|==
name|rxq
operator|->
name|pending
argument_list|,
operator|(
literal|"rxq->completed != rxq->pending"
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|completed
operator|=
literal|0
expr_stmt|;
name|rxq
operator|->
name|loopback
operator|=
literal|0
expr_stmt|;
comment|/* Destroy the common code receive queue. */
name|efx_rx_qdestroy
argument_list|(
name|rxq
operator|->
name|common
argument_list|)
expr_stmt|;
name|efx_sram_buf_tbl_clear
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|rxq
operator|->
name|buf_base_id
argument_list|,
name|EFX_RXQ_NBUFS
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_rx_qstart
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_rxq
modifier|*
name|rxq
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rxq
operator|=
name|sc
operator|->
name|rxq
index|[
name|index
index|]
expr_stmt|;
name|esmp
operator|=
operator|&
name|rxq
operator|->
name|mem
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|index
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|init_state
operator|==
name|SFXGE_RXQ_INITIALIZED
argument_list|,
operator|(
literal|"rxq->init_state != SFXGE_RXQ_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|evq
operator|->
name|init_state
operator|==
name|SFXGE_EVQ_STARTED
argument_list|,
operator|(
literal|"evq->init_state != SFXGE_EVQ_STARTED"
operator|)
argument_list|)
expr_stmt|;
comment|/* Program the buffer table. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_sram_buf_tbl_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|rxq
operator|->
name|buf_base_id
argument_list|,
name|esmp
argument_list|,
name|EFX_RXQ_NBUFS
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
comment|/* Create the common code receive queue. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_rx_qcreate
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|index
argument_list|,
name|index
argument_list|,
name|EFX_RXQ_TYPE_DEFAULT
argument_list|,
name|esmp
argument_list|,
name|SFXGE_NDESCS
argument_list|,
name|rxq
operator|->
name|buf_base_id
argument_list|,
name|evq
operator|->
name|common
argument_list|,
operator|&
name|rxq
operator|->
name|common
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|mtx_lock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Enable the receive queue. */
name|efx_rx_qenable
argument_list|(
name|rxq
operator|->
name|common
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|init_state
operator|=
name|SFXGE_RXQ_STARTED
expr_stmt|;
comment|/* Try to fill the queue from the pool. */
name|sfxge_rx_qfill
argument_list|(
name|rxq
argument_list|,
name|EFX_RXQ_LIMIT
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|evq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|efx_sram_buf_tbl_clear
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|rxq
operator|->
name|buf_base_id
argument_list|,
name|EFX_RXQ_NBUFS
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|sfxge_rx_stop
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_intr
modifier|*
name|intr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|intr
operator|=
operator|&
name|sc
operator|->
name|intr
expr_stmt|;
comment|/* Stop the receive queue(s) */
name|index
operator|=
name|intr
operator|->
name|n_alloc
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_rx_qstop
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx_prefix_size
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rx_buffer_size
operator|=
literal|0
expr_stmt|;
name|efx_rx_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_rx_start
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_intr
modifier|*
name|intr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|intr
operator|=
operator|&
name|sc
operator|->
name|intr
expr_stmt|;
comment|/* Initialize the common code receive module. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_rx_init
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Calculate the receive packet buffer size. */
name|sc
operator|->
name|rx_prefix_size
operator|=
name|EFX_RX_PREFIX_SIZE
expr_stmt|;
name|sc
operator|->
name|rx_buffer_size
operator|=
operator|(
name|EFX_MAC_PDU
argument_list|(
name|sc
operator|->
name|ifnet
operator|->
name|if_mtu
argument_list|)
operator|+
name|sc
operator|->
name|rx_prefix_size
operator|)
expr_stmt|;
comment|/* Select zone for packet buffers */
if|if
condition|(
name|sc
operator|->
name|rx_buffer_size
operator|<=
name|MCLBYTES
condition|)
name|sc
operator|->
name|rx_buffer_zone
operator|=
name|zone_clust
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|rx_buffer_size
operator|<=
name|MJUMPAGESIZE
condition|)
name|sc
operator|->
name|rx_buffer_zone
operator|=
name|zone_jumbop
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|rx_buffer_size
operator|<=
name|MJUM9BYTES
condition|)
name|sc
operator|->
name|rx_buffer_zone
operator|=
name|zone_jumbo9
expr_stmt|;
else|else
name|sc
operator|->
name|rx_buffer_zone
operator|=
name|zone_jumbo16
expr_stmt|;
comment|/* 	 * Set up the scale table.  Enable all hash types and hash insertion. 	 */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|SFXGE_RX_SCALE_MAX
condition|;
name|index
operator|++
control|)
name|sc
operator|->
name|rx_indir_table
index|[
name|index
index|]
operator|=
name|index
operator|%
name|sc
operator|->
name|intr
operator|.
name|n_alloc
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_rx_scale_tbl_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|sc
operator|->
name|rx_indir_table
argument_list|,
name|SFXGE_RX_SCALE_MAX
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
operator|(
name|void
operator|)
name|efx_rx_scale_mode_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|EFX_RX_HASHALG_TOEPLITZ
argument_list|,
operator|(
literal|1
operator|<<
name|EFX_RX_HASH_IPV4
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_RX_HASH_TCPIPV4
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_RX_HASH_IPV6
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_RX_HASH_TCPIPV6
operator|)
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_rx_scale_toeplitz_ipv4_key_set
argument_list|(
name|sc
operator|->
name|enp
argument_list|,
name|toep_key
argument_list|,
sizeof|sizeof
argument_list|(
name|toep_key
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Start the receive queue(s). */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|intr
operator|->
name|n_alloc
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_rx_qstart
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_rx_qstop
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|fail
label|:
name|efx_rx_fini
argument_list|(
name|sc
operator|->
name|enp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_init
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|sfxge_lro_state
modifier|*
name|st
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|st
operator|->
name|conns_mask
operator|=
name|lro_table_size
operator|-
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
operator|(
name|st
operator|->
name|conns_mask
operator|+
literal|1
operator|)
operator|&
name|st
operator|->
name|conns_mask
operator|)
argument_list|,
operator|(
literal|"lro_table_size must be a power of 2"
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|sc
operator|=
name|rxq
operator|->
name|sc
expr_stmt|;
name|st
operator|->
name|conns
operator|=
name|malloc
argument_list|(
operator|(
name|st
operator|->
name|conns_mask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|st
operator|->
name|conns
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|st
operator|->
name|conns_n
operator|=
name|malloc
argument_list|(
operator|(
name|st
operator|->
name|conns_mask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|st
operator|->
name|conns_n
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|st
operator|->
name|conns_mask
condition|;
operator|++
name|i
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|st
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|st
operator|->
name|conns_n
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|st
operator|->
name|active_conns
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_lro_fini
parameter_list|(
name|struct
name|sfxge_rxq
modifier|*
name|rxq
parameter_list|)
block|{
name|struct
name|sfxge_lro_state
modifier|*
name|st
init|=
operator|&
name|rxq
operator|->
name|lro
decl_stmt|;
name|struct
name|sfxge_lro_conn
modifier|*
name|c
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Return cleanly if sfxge_lro_init() has not been called. */
if|if
condition|(
name|st
operator|->
name|conns
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|st
operator|->
name|active_conns
argument_list|)
argument_list|,
operator|(
literal|"found active connections"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|st
operator|->
name|conns_mask
condition|;
operator|++
name|i
control|)
block|{
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|st
operator|->
name|conns
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|c
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|st
operator|->
name|conns
index|[
name|i
index|]
argument_list|,
name|sfxge_lro_tailq
argument_list|)
expr_stmt|;
name|sfxge_lro_drop
argument_list|(
name|rxq
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|)
condition|)
block|{
name|c
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|free_conns
argument_list|,
name|c
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|c
operator|->
name|mbuf
argument_list|,
operator|(
literal|"found orphaned mbuf"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|st
operator|->
name|conns_n
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st
operator|->
name|conns
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|st
operator|->
name|conns
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_rx_qfini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_rxq
modifier|*
name|rxq
decl_stmt|;
name|rxq
operator|=
name|sc
operator|->
name|rxq
index|[
name|index
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|rxq
operator|->
name|init_state
operator|==
name|SFXGE_RXQ_INITIALIZED
argument_list|,
operator|(
literal|"rxq->init_state != SFXGE_RXQ_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
comment|/* Free the context array and the flow table. */
name|free
argument_list|(
name|rxq
operator|->
name|queue
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
name|sfxge_lro_fini
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
comment|/* Release DMA memory. */
name|sfxge_dma_free
argument_list|(
operator|&
name|rxq
operator|->
name|mem
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rxq
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|rxq
argument_list|,
name|M_SFXGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sfxge_rx_qinit
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|struct
name|sfxge_rxq
modifier|*
name|rxq
decl_stmt|;
name|struct
name|sfxge_evq
modifier|*
name|evq
decl_stmt|;
name|efsys_mem_t
modifier|*
name|esmp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|KASSERT
argument_list|(
name|index
operator|<
name|sc
operator|->
name|intr
operator|.
name|n_alloc
argument_list|,
operator|(
literal|"index>= %d"
operator|,
name|sc
operator|->
name|intr
operator|.
name|n_alloc
operator|)
argument_list|)
expr_stmt|;
name|rxq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfxge_rxq
argument_list|)
argument_list|,
name|M_SFXGE
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
name|rxq
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|sc
operator|->
name|rxq
index|[
name|index
index|]
operator|=
name|rxq
expr_stmt|;
name|esmp
operator|=
operator|&
name|rxq
operator|->
name|mem
expr_stmt|;
name|evq
operator|=
name|sc
operator|->
name|evq
index|[
name|index
index|]
expr_stmt|;
comment|/* Allocate and zero DMA space. */
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_dma_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_RXQ_SIZE
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
name|esmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|esmp
operator|->
name|esm_base
argument_list|,
literal|0
argument_list|,
name|EFX_RXQ_SIZE
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate buffer table entries. */
name|sfxge_sram_buf_tbl_alloc
argument_list|(
name|sc
argument_list|,
name|EFX_RXQ_NBUFS
argument_list|(
name|SFXGE_NDESCS
argument_list|)
argument_list|,
operator|&
name|rxq
operator|->
name|buf_base_id
argument_list|)
expr_stmt|;
comment|/* Allocate the context array and the flow table. */
name|rxq
operator|->
name|queue
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sfxge_rx_sw_desc
argument_list|)
operator|*
name|SFXGE_NDESCS
argument_list|,
name|M_SFXGE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sfxge_lro_init
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|rxq
operator|->
name|refill_callout
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|init_state
operator|=
name|SFXGE_RXQ_INITIALIZED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
block|}
name|sfxge_rx_stats
index|[]
init|=
block|{
define|#
directive|define
name|SFXGE_RX_STAT
parameter_list|(
name|name
parameter_list|,
name|member
parameter_list|)
define|\
value|{ #name, offsetof(struct sfxge_rxq, member) }
name|SFXGE_RX_STAT
argument_list|(
name|lro_merges
argument_list|,
name|lro
operator|.
name|n_merges
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
name|lro_bursts
argument_list|,
name|lro
operator|.
name|n_bursts
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
name|lro_slow_start
argument_list|,
name|lro
operator|.
name|n_slow_start
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
name|lro_misorder
argument_list|,
name|lro
operator|.
name|n_misorder
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
name|lro_too_many
argument_list|,
name|lro
operator|.
name|n_too_many
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
name|lro_new_stream
argument_list|,
name|lro
operator|.
name|n_new_stream
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
name|lro_drop_idle
argument_list|,
name|lro
operator|.
name|n_drop_idle
argument_list|)
block|,
name|SFXGE_RX_STAT
argument_list|(
argument|lro_drop_closed
argument_list|,
argument|lro.n_drop_closed
argument_list|)
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|sfxge_rx_stat_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfxge_softc
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|unsigned
name|int
name|id
init|=
name|arg2
decl_stmt|;
name|unsigned
name|int
name|sum
decl_stmt|,
name|index
decl_stmt|;
comment|/* Sum across all RX queues */
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|sc
operator|->
name|intr
operator|.
name|n_alloc
condition|;
name|index
operator|++
control|)
name|sum
operator|+=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|rxq
index|[
name|index
index|]
operator|+
name|sfxge_rx_stats
index|[
name|id
index|]
operator|.
name|offset
operator|)
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|sum
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sfxge_rx_stat_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|stat_list
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|stat_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|stats_node
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
sizeof|sizeof
argument_list|(
name|sfxge_rx_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sfxge_rx_stats
index|[
literal|0
index|]
argument_list|)
condition|;
name|id
operator|++
control|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|stat_list
argument_list|,
name|OID_AUTO
argument_list|,
name|sfxge_rx_stats
index|[
name|id
index|]
operator|.
name|name
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
name|id
argument_list|,
name|sfxge_rx_stat_handler
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sfxge_rx_fini
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_intr
modifier|*
name|intr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|intr
operator|=
operator|&
name|sc
operator|->
name|intr
expr_stmt|;
name|index
operator|=
name|intr
operator|->
name|n_alloc
expr_stmt|;
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_rx_qfini
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sfxge_rx_init
parameter_list|(
name|struct
name|sfxge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sfxge_intr
modifier|*
name|intr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|lro_idle_ticks
operator|==
literal|0
condition|)
name|lro_idle_ticks
operator|=
name|hz
operator|/
literal|10
operator|+
literal|1
expr_stmt|;
comment|/* 100 ms */
name|intr
operator|=
operator|&
name|sc
operator|->
name|intr
expr_stmt|;
name|KASSERT
argument_list|(
name|intr
operator|->
name|state
operator|==
name|SFXGE_INTR_INITIALIZED
argument_list|,
operator|(
literal|"intr->state != SFXGE_INTR_INITIALIZED"
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize the receive queue(s) - one per interrupt. */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|intr
operator|->
name|n_alloc
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|sfxge_rx_qinit
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
name|sfxge_rx_stat_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* Tear down the receive queue(s). */
while|while
condition|(
operator|--
name|index
operator|>=
literal|0
condition|)
name|sfxge_rx_qfini
argument_list|(
name|sc
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

