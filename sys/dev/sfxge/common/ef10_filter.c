begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2016 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_FILTER
end_if

begin_define
define|#
directive|define
name|EFE_SPEC
parameter_list|(
name|eftp
parameter_list|,
name|index
parameter_list|)
value|((eftp)->eft_entry[(index)].efe_spec)
end_define

begin_function
specifier|static
name|efx_filter_spec_t
modifier|*
name|ef10_filter_entry_spec
parameter_list|(
name|__in
specifier|const
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
return|return
operator|(
operator|(
name|efx_filter_spec_t
operator|*
operator|)
operator|(
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|&
operator|~
operator|(
name|uintptr_t
operator|)
name|EFX_EF10_FILTER_FLAGS
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ef10_filter_entry_is_busy
parameter_list|(
name|__in
specifier|const
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|&
name|EFX_EF10_FILTER_FLAG_BUSY
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|ef10_filter_entry_is_auto_old
parameter_list|(
name|__in
specifier|const
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|&
name|EFX_EF10_FILTER_FLAG_AUTO_OLD
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
else|else
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_filter_set_entry
parameter_list|(
name|__inout
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|,
name|__in_opt
specifier|const
name|efx_filter_spec_t
modifier|*
name|efsp
parameter_list|)
block|{
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|=
operator|(
name|uintptr_t
operator|)
name|efsp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_filter_set_entry_busy
parameter_list|(
name|__inout
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator||=
operator|(
name|uintptr_t
operator|)
name|EFX_EF10_FILTER_FLAG_BUSY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_filter_set_entry_not_busy
parameter_list|(
name|__inout
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|&=
operator|~
operator|(
name|uintptr_t
operator|)
name|EFX_EF10_FILTER_FLAG_BUSY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_filter_set_entry_auto_old
parameter_list|(
name|__inout
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|EFSYS_ASSERT
argument_list|(
name|ef10_filter_entry_spec
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator||=
operator|(
name|uintptr_t
operator|)
name|EFX_EF10_FILTER_FLAG_AUTO_OLD
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_filter_set_entry_not_auto_old
parameter_list|(
name|__inout
name|ef10_filter_table_t
modifier|*
name|eftp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|)
block|{
name|EFE_SPEC
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|&=
operator|~
operator|(
name|uintptr_t
operator|)
name|EFX_EF10_FILTER_FLAG_AUTO_OLD
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|ef10_filter_entry_spec
argument_list|(
name|eftp
argument_list|,
name|index
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_filter_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|ef10_filter_table_t
modifier|*
name|eftp
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
define|#
directive|define
name|MATCH_MASK
parameter_list|(
name|match
parameter_list|)
value|(EFX_MASK32(match)<< EFX_LOW_BIT(match))
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_REM_HOST
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_SRC_IP
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_LOC_HOST
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_DST_IP
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_REM_MAC
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_SRC_MAC
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_REM_PORT
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_SRC_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_LOC_MAC
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_DST_MAC
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_LOC_PORT
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_DST_PORT
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_ETHER_TYPE
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_ETHER_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_INNER_VID
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_INNER_VLAN
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_OUTER_VID
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_OUTER_VLAN
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_IP_PROTO
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_IP_PROTO
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_FILTER_MATCH_UNKNOWN_MCAST_DST
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_UNKNOWN_MCAST_DST
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
operator|(
name|uint32_t
operator|)
name|EFX_FILTER_MATCH_UNKNOWN_UCAST_DST
operator|==
name|MATCH_MASK
argument_list|(
name|MC_CMD_FILTER_OP_IN_MATCH_UNKNOWN_UCAST_DST
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|MATCH_MASK
name|EFSYS_KMEM_ALLOC
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
name|ef10_filter_table_t
argument_list|)
argument_list|,
name|eftp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eftp
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
operator|=
name|eftp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ef10_filter_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
operator|!=
name|NULL
condition|)
block|{
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
name|ef10_filter_table_t
argument_list|)
argument_list|,
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_filter_op_add
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|,
name|__in
name|unsigned
name|int
name|filter_op
parameter_list|,
name|__inout
name|ef10_filter_handle_t
modifier|*
name|handle
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_FILTER_OP_IN_LEN
argument_list|,
name|MC_CMD_FILTER_OP_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FILTER_OP
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_FILTER_OP_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_FILTER_OP_OUT_LEN
expr_stmt|;
switch|switch
condition|(
name|filter_op
condition|)
block|{
case|case
name|MC_CMD_FILTER_OP_IN_OP_REPLACE
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_HANDLE_LO
argument_list|,
name|handle
operator|->
name|efh_lo
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_HANDLE_HI
argument_list|,
name|handle
operator|->
name|efh_hi
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
name|MC_CMD_FILTER_OP_IN_OP_INSERT
case|:
case|case
name|MC_CMD_FILTER_OP_IN_OP_SUBSCRIBE
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_OP
argument_list|,
name|filter_op
argument_list|)
expr_stmt|;
break|break;
default|default:
name|EFSYS_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_PORT_ID
argument_list|,
name|EVB_PORT_ID_ASSIGNED
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_MATCH_FIELDS
argument_list|,
name|spec
operator|->
name|efs_match_flags
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_RX_DEST
argument_list|,
name|MC_CMD_FILTER_OP_IN_RX_DEST_HOST
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_RX_QUEUE
argument_list|,
name|spec
operator|->
name|efs_dmaq_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|efs_flags
operator|&
name|EFX_FILTER_FLAG_RX_RSS
condition|)
block|{
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_RX_CONTEXT
argument_list|,
name|spec
operator|->
name|efs_rss_context
argument_list|)
expr_stmt|;
block|}
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_RX_MODE
argument_list|,
name|spec
operator|->
name|efs_flags
operator|&
name|EFX_FILTER_FLAG_RX_RSS
condition|?
name|MC_CMD_FILTER_OP_IN_RX_MODE_RSS
else|:
name|MC_CMD_FILTER_OP_IN_RX_MODE_SIMPLE
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_TX_DEST
argument_list|,
name|MC_CMD_FILTER_OP_IN_TX_DEST_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter_op
operator|!=
name|MC_CMD_FILTER_OP_IN_OP_REPLACE
condition|)
block|{
comment|/* 		 * NOTE: Unlike most MCDI requests, the filter fields 		 * are presented in network (big endian) byte order. 		 */
name|memcpy
argument_list|(
name|MCDI_IN2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|FILTER_OP_IN_SRC_MAC
argument_list|)
argument_list|,
name|spec
operator|->
name|efs_rem_mac
argument_list|,
name|EFX_MAC_ADDR_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|MCDI_IN2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|FILTER_OP_IN_DST_MAC
argument_list|)
argument_list|,
name|spec
operator|->
name|efs_loc_mac
argument_list|,
name|EFX_MAC_ADDR_LEN
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_WORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_SRC_PORT
argument_list|,
name|__CPU_TO_BE_16
argument_list|(
name|spec
operator|->
name|efs_rem_port
argument_list|)
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_WORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_DST_PORT
argument_list|,
name|__CPU_TO_BE_16
argument_list|(
name|spec
operator|->
name|efs_loc_port
argument_list|)
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_WORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_ETHER_TYPE
argument_list|,
name|__CPU_TO_BE_16
argument_list|(
name|spec
operator|->
name|efs_ether_type
argument_list|)
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_WORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_INNER_VLAN
argument_list|,
name|__CPU_TO_BE_16
argument_list|(
name|spec
operator|->
name|efs_inner_vid
argument_list|)
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_WORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_OUTER_VLAN
argument_list|,
name|__CPU_TO_BE_16
argument_list|(
name|spec
operator|->
name|efs_outer_vid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* IP protocol (in low byte, high byte is zero) */
name|MCDI_IN_SET_BYTE
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_IP_PROTO
argument_list|,
name|spec
operator|->
name|efs_ip_proto
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|spec
operator|->
name|efs_rem_host
argument_list|)
operator|==
name|MC_CMD_FILTER_OP_IN_SRC_IP_LEN
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|spec
operator|->
name|efs_loc_host
argument_list|)
operator|==
name|MC_CMD_FILTER_OP_IN_DST_IP_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|MCDI_IN2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|FILTER_OP_IN_SRC_IP
argument_list|)
argument_list|,
operator|&
name|spec
operator|->
name|efs_rem_host
operator|.
name|eo_byte
index|[
literal|0
index|]
argument_list|,
name|MC_CMD_FILTER_OP_IN_SRC_IP_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|MCDI_IN2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|FILTER_OP_IN_DST_IP
argument_list|)
argument_list|,
operator|&
name|spec
operator|->
name|efs_loc_host
operator|.
name|eo_byte
index|[
literal|0
index|]
argument_list|,
name|MC_CMD_FILTER_OP_IN_DST_IP_LEN
argument_list|)
expr_stmt|;
block|}
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_FILTER_OP_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|handle
operator|->
name|efh_lo
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_OUT_HANDLE_LO
argument_list|)
expr_stmt|;
name|handle
operator|->
name|efh_hi
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_OUT_HANDLE_HI
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_filter_op_delete
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|filter_op
parameter_list|,
name|__inout
name|ef10_filter_handle_t
modifier|*
name|handle
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_FILTER_OP_IN_LEN
argument_list|,
name|MC_CMD_FILTER_OP_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FILTER_OP
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_FILTER_OP_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_FILTER_OP_OUT_LEN
expr_stmt|;
switch|switch
condition|(
name|filter_op
condition|)
block|{
case|case
name|MC_CMD_FILTER_OP_IN_OP_REMOVE
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_OP
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_REMOVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE
case|:
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_OP
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|EFSYS_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_HANDLE_LO
argument_list|,
name|handle
operator|->
name|efh_lo
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FILTER_OP_IN_HANDLE_HI
argument_list|,
name|handle
operator|->
name|efh_hi
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_FILTER_OP_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_filter_equal
parameter_list|(
name|__in
specifier|const
name|efx_filter_spec_t
modifier|*
name|left
parameter_list|,
name|__in
specifier|const
name|efx_filter_spec_t
modifier|*
name|right
parameter_list|)
block|{
comment|/* FIXME: Consider rx vs tx filters (look at efs_flags) */
if|if
condition|(
name|left
operator|->
name|efs_match_flags
operator|!=
name|right
operator|->
name|efs_match_flags
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|EFX_OWORD_IS_EQUAL
argument_list|(
name|left
operator|->
name|efs_rem_host
argument_list|,
name|right
operator|->
name|efs_rem_host
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|EFX_OWORD_IS_EQUAL
argument_list|(
name|left
operator|->
name|efs_loc_host
argument_list|,
name|right
operator|->
name|efs_loc_host
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|left
operator|->
name|efs_rem_mac
argument_list|,
name|right
operator|->
name|efs_rem_mac
argument_list|,
name|EFX_MAC_ADDR_LEN
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|left
operator|->
name|efs_loc_mac
argument_list|,
name|right
operator|->
name|efs_loc_mac
argument_list|,
name|EFX_MAC_ADDR_LEN
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|left
operator|->
name|efs_rem_port
operator|!=
name|right
operator|->
name|efs_rem_port
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|left
operator|->
name|efs_loc_port
operator|!=
name|right
operator|->
name|efs_loc_port
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|left
operator|->
name|efs_inner_vid
operator|!=
name|right
operator|->
name|efs_inner_vid
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|left
operator|->
name|efs_outer_vid
operator|!=
name|right
operator|->
name|efs_outer_vid
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|left
operator|->
name|efs_ether_type
operator|!=
name|right
operator|->
name|efs_ether_type
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|left
operator|->
name|efs_ip_proto
operator|!=
name|right
operator|->
name|efs_ip_proto
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_filter_same_dest
parameter_list|(
name|__in
specifier|const
name|efx_filter_spec_t
modifier|*
name|left
parameter_list|,
name|__in
specifier|const
name|efx_filter_spec_t
modifier|*
name|right
parameter_list|)
block|{
if|if
condition|(
operator|(
name|left
operator|->
name|efs_flags
operator|&
name|EFX_FILTER_FLAG_RX_RSS
operator|)
operator|&&
operator|(
name|right
operator|->
name|efs_flags
operator|&
name|EFX_FILTER_FLAG_RX_RSS
operator|)
condition|)
block|{
if|if
condition|(
name|left
operator|->
name|efs_rss_context
operator|==
name|right
operator|->
name|efs_rss_context
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|~
operator|(
name|left
operator|->
name|efs_flags
operator|)
operator|&
name|EFX_FILTER_FLAG_RX_RSS
operator|)
operator|&&
operator|(
operator|~
operator|(
name|right
operator|->
name|efs_flags
operator|)
operator|&
name|EFX_FILTER_FLAG_RX_RSS
operator|)
condition|)
block|{
if|if
condition|(
name|left
operator|->
name|efs_dmaq_id
operator|==
name|right
operator|->
name|efs_dmaq_id
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|uint32_t
name|ef10_filter_hash
parameter_list|(
name|__in
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|)
block|{
name|EFX_STATIC_ASSERT
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|efx_filter_spec_t
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
operator|(
name|EFX_FIELD_OFFSET
argument_list|(
name|efx_filter_spec_t
argument_list|,
name|efs_outer_vid
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * As the area of the efx_filter_spec_t we need to hash is DWORD 	 * aligned and an exact number of DWORDs in size we can use the 	 * optimised efx_hash_dwords() rather than efx_hash_bytes() 	 */
return|return
operator|(
name|efx_hash_dwords
argument_list|(
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|efs_outer_vid
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|efx_filter_spec_t
argument_list|)
operator|-
name|EFX_FIELD_OFFSET
argument_list|(
name|efx_filter_spec_t
argument_list|,
name|efs_outer_vid
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide whether a filter should be exclusive or else should allow  * delivery to additional recipients.  Currently we decide that  * filters for specific local unicast MAC and IP addresses are  * exclusive.  */
end_comment

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_filter_is_exclusive
parameter_list|(
name|__in
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|)
block|{
if|if
condition|(
operator|(
name|spec
operator|->
name|efs_match_flags
operator|&
name|EFX_FILTER_MATCH_LOC_MAC
operator|)
operator|&&
operator|!
name|EFX_MAC_ADDR_IS_MULTICAST
argument_list|(
name|spec
operator|->
name|efs_loc_mac
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|spec
operator|->
name|efs_match_flags
operator|&
operator|(
name|EFX_FILTER_MATCH_ETHER_TYPE
operator||
name|EFX_FILTER_MATCH_LOC_HOST
operator|)
operator|)
operator|==
operator|(
name|EFX_FILTER_MATCH_ETHER_TYPE
operator||
name|EFX_FILTER_MATCH_LOC_HOST
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|spec
operator|->
name|efs_ether_type
operator|==
name|EFX_ETHER_TYPE_IPV4
operator|)
operator|&&
operator|(
operator|(
name|spec
operator|->
name|efs_loc_host
operator|.
name|eo_u8
index|[
literal|0
index|]
operator|&
literal|0xf
operator|)
operator|!=
literal|0xe
operator|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|spec
operator|->
name|efs_ether_type
operator|==
name|EFX_ETHER_TYPE_IPV6
operator|)
operator|&&
operator|(
name|spec
operator|->
name|efs_loc_host
operator|.
name|eo_u8
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_filter_restore
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|int
name|tbl_id
decl_stmt|;
name|efx_filter_spec_t
modifier|*
name|spec
decl_stmt|;
name|ef10_filter_table_t
modifier|*
name|eftp
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|boolean_t
name|restoring
decl_stmt|;
name|int
name|state
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
for|for
control|(
name|tbl_id
operator|=
literal|0
init|;
name|tbl_id
operator|<
name|EFX_EF10_FILTER_TBL_ROWS
condition|;
name|tbl_id
operator|++
control|)
block|{
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|spec
operator|=
name|ef10_filter_entry_spec
argument_list|(
name|eftp
argument_list|,
name|tbl_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
name|restoring
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ef10_filter_entry_is_busy
argument_list|(
name|eftp
argument_list|,
name|tbl_id
argument_list|)
condition|)
block|{
comment|/* Ignore busy entries. */
name|restoring
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
name|ef10_filter_set_entry_busy
argument_list|(
name|eftp
argument_list|,
name|tbl_id
argument_list|)
expr_stmt|;
name|restoring
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|restoring
operator|==
name|B_FALSE
condition|)
continue|continue;
if|if
condition|(
name|ef10_filter_is_exclusive
argument_list|(
name|spec
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_add
argument_list|(
name|enp
argument_list|,
name|spec
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_INSERT
argument_list|,
operator|&
name|eftp
operator|->
name|eft_entry
index|[
name|tbl_id
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_add
argument_list|(
name|enp
argument_list|,
name|spec
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_SUBSCRIBE
argument_list|,
operator|&
name|eftp
operator|->
name|eft_entry
index|[
name|tbl_id
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ef10_filter_set_entry_not_busy
argument_list|(
name|eftp
argument_list|,
name|tbl_id
argument_list|)
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * An arbitrary search limit for the software hash table. As per the linux net  * driver.  */
end_comment

begin_define
define|#
directive|define
name|EF10_FILTER_SEARCH_LIMIT
value|200
end_define

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_add_internal
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__inout
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|,
name|__in
name|boolean_t
name|may_replace
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|filter_id
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|ef10_filter_table_t
modifier|*
name|eftp
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
modifier|*
name|saved_spec
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|unsigned
name|int
name|depth
decl_stmt|;
name|int
name|ins_index
decl_stmt|;
name|boolean_t
name|replacing
init|=
name|B_FALSE
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|state
decl_stmt|;
name|boolean_t
name|locked
init|=
name|B_FALSE
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_RX_SCALE
name|spec
operator|->
name|efs_rss_context
operator|=
name|enp
operator|->
name|en_rss_context
expr_stmt|;
endif|#
directive|endif
name|hash
operator|=
name|ef10_filter_hash
argument_list|(
name|spec
argument_list|)
expr_stmt|;
comment|/* 	 * FIXME: Add support for inserting filters of different priorities 	 * and removing lower priority multicast filters (bug 42378) 	 */
comment|/* 	 * Find any existing filters with the same match tuple or 	 * else a free slot to insert at.  If any of them are busy, 	 * we have to wait and retry. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ins_index
operator|=
operator|-
literal|1
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
operator|(
name|hash
operator|+
name|depth
operator|)
operator|&
operator|(
name|EFX_EF10_FILTER_TBL_ROWS
operator|-
literal|1
operator|)
expr_stmt|;
name|saved_spec
operator|=
name|ef10_filter_entry_spec
argument_list|(
name|eftp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|saved_spec
condition|)
block|{
if|if
condition|(
name|ins_index
operator|<
literal|0
condition|)
block|{
name|ins_index
operator|=
name|i
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ef10_filter_equal
argument_list|(
name|spec
argument_list|,
name|saved_spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|ef10_filter_entry_is_busy
argument_list|(
name|eftp
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|saved_spec
operator|->
name|efs_priority
operator|==
name|EFX_FILTER_PRI_AUTO
condition|)
block|{
name|ins_index
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
elseif|else
if|if
condition|(
name|ef10_filter_is_exclusive
argument_list|(
name|spec
argument_list|)
condition|)
block|{
if|if
condition|(
name|may_replace
condition|)
block|{
name|ins_index
operator|=
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
block|{
name|rc
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
block|}
comment|/* Leave existing */
block|}
comment|/* 			 * Once we reach the maximum search depth, use 			 * the first suitable slot or return EBUSY if 			 * there was none. 			 */
if|if
condition|(
name|depth
operator|==
name|EF10_FILTER_SEARCH_LIMIT
condition|)
block|{
if|if
condition|(
name|ins_index
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
goto|goto
name|found
goto|;
block|}
name|depth
operator|++
expr_stmt|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|found
label|:
comment|/* 	 * Create a software table entry if necessary, and mark it 	 * busy.  We might yet fail to insert, but any attempt to 	 * insert a conflicting filter while we're waiting for the 	 * firmware must find the busy entry. 	 */
name|saved_spec
operator|=
name|ef10_filter_entry_spec
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_spec
condition|)
block|{
if|if
condition|(
name|saved_spec
operator|->
name|efs_priority
operator|==
name|EFX_FILTER_PRI_AUTO
condition|)
block|{
comment|/* This is a filter we are refreshing */
name|ef10_filter_set_entry_not_auto_old
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|)
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|replacing
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|EFSYS_KMEM_ALLOC
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spec
argument_list|)
argument_list|,
name|saved_spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|saved_spec
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
operator|*
name|saved_spec
operator|=
operator|*
name|spec
expr_stmt|;
name|ef10_filter_set_entry
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|,
name|saved_spec
argument_list|)
expr_stmt|;
block|}
name|ef10_filter_set_entry_busy
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|)
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 	 * On replacing the filter handle may change after after a successful 	 * replace operation. 	 */
if|if
condition|(
name|replacing
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_add
argument_list|(
name|enp
argument_list|,
name|spec
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_REPLACE
argument_list|,
operator|&
name|eftp
operator|->
name|eft_entry
index|[
name|ins_index
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ef10_filter_is_exclusive
argument_list|(
name|spec
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_add
argument_list|(
name|enp
argument_list|,
name|spec
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_INSERT
argument_list|,
operator|&
name|eftp
operator|->
name|eft_entry
index|[
name|ins_index
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_add
argument_list|(
name|enp
argument_list|,
name|spec
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_SUBSCRIBE
argument_list|,
operator|&
name|eftp
operator|->
name|eft_entry
index|[
name|ins_index
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|replacing
condition|)
block|{
comment|/* Update the fields that may differ */
name|saved_spec
operator|->
name|efs_priority
operator|=
name|spec
operator|->
name|efs_priority
expr_stmt|;
name|saved_spec
operator|->
name|efs_flags
operator|=
name|spec
operator|->
name|efs_flags
expr_stmt|;
name|saved_spec
operator|->
name|efs_rss_context
operator|=
name|spec
operator|->
name|efs_rss_context
expr_stmt|;
name|saved_spec
operator|->
name|efs_dmaq_id
operator|=
name|spec
operator|->
name|efs_dmaq_id
expr_stmt|;
block|}
name|ef10_filter_set_entry_not_busy
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|)
expr_stmt|;
name|out_unlock
label|:
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|filter_id
condition|)
operator|*
name|filter_id
operator|=
name|ins_index
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|replacing
condition|)
block|{
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spec
argument_list|)
argument_list|,
name|saved_spec
argument_list|)
expr_stmt|;
name|saved_spec
operator|=
name|NULL
expr_stmt|;
block|}
name|ef10_filter_set_entry_not_busy
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|)
expr_stmt|;
name|ef10_filter_set_entry
argument_list|(
name|eftp
argument_list|,
name|ins_index
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_filter_add
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__inout
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|,
name|__in
name|boolean_t
name|may_replace
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|rc
operator|=
name|ef10_filter_add_internal
argument_list|(
name|enp
argument_list|,
name|spec
argument_list|,
name|may_replace
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_delete_internal
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|filter_id
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
modifier|*
name|spec
decl_stmt|;
name|int
name|state
decl_stmt|;
name|uint32_t
name|filter_idx
init|=
name|filter_id
operator|%
name|EFX_EF10_FILTER_TBL_ROWS
decl_stmt|;
comment|/* 	 * Find the software table entry and mark it busy.  Don't 	 * remove it yet; any attempt to update while we're waiting 	 * for the firmware must find the busy entry. 	 * 	 * FIXME: What if the busy flag is never cleared? 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
while|while
condition|(
name|ef10_filter_entry_is_busy
argument_list|(
name|table
argument_list|,
name|filter_idx
argument_list|)
condition|)
block|{
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|EFSYS_SPIN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spec
operator|=
name|ef10_filter_entry_spec
argument_list|(
name|table
argument_list|,
name|filter_idx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ef10_filter_set_entry_busy
argument_list|(
name|table
argument_list|,
name|filter_idx
argument_list|)
expr_stmt|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* 	 * Try to remove the hardware filter. This may fail if the MC has 	 * rebooted (which frees all hardware filter resources). 	 */
if|if
condition|(
name|ef10_filter_is_exclusive
argument_list|(
name|spec
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_delete
argument_list|(
name|enp
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_REMOVE
argument_list|,
operator|&
name|table
operator|->
name|eft_entry
index|[
name|filter_idx
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_filter_op_delete
argument_list|(
name|enp
argument_list|,
name|MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE
argument_list|,
operator|&
name|table
operator|->
name|eft_entry
index|[
name|filter_idx
index|]
operator|.
name|efe_handle
argument_list|)
expr_stmt|;
block|}
comment|/* Free the software table entry */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ef10_filter_set_entry_not_busy
argument_list|(
name|table
argument_list|,
name|filter_idx
argument_list|)
expr_stmt|;
name|ef10_filter_set_entry
argument_list|(
name|table
argument_list|,
name|filter_idx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|spec
argument_list|)
argument_list|,
name|spec
argument_list|)
expr_stmt|;
comment|/* Check result of hardware filter removal */
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_filter_delete
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__inout
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
modifier|*
name|saved_spec
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|unsigned
name|int
name|depth
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|state
decl_stmt|;
name|boolean_t
name|locked
init|=
name|B_FALSE
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
name|hash
operator|=
name|ef10_filter_hash
argument_list|(
name|spec
argument_list|)
expr_stmt|;
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
operator|(
name|hash
operator|+
name|depth
operator|)
operator|&
operator|(
name|EFX_EF10_FILTER_TBL_ROWS
operator|-
literal|1
operator|)
expr_stmt|;
name|saved_spec
operator|=
name|ef10_filter_entry_spec
argument_list|(
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_spec
operator|&&
name|ef10_filter_equal
argument_list|(
name|spec
argument_list|,
name|saved_spec
argument_list|)
operator|&&
name|ef10_filter_same_dest
argument_list|(
name|spec
argument_list|,
name|saved_spec
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|depth
operator|==
name|EF10_FILTER_SEARCH_LIMIT
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|depth
operator|++
expr_stmt|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_FALSE
expr_stmt|;
name|rc
operator|=
name|ef10_filter_delete_internal
argument_list|(
name|enp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_parser_disp_info
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount
argument_list|(
argument|buffer_length
argument_list|)
name|uint32_t
operator|*
name|buffer
argument_list|,
name|__in
name|size_t
name|buffer_length
argument_list|,
name|__out
name|size_t
operator|*
name|list_lengthp
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PARSER_DISP_INFO_IN_LEN
argument_list|,
name|MC_CMD_GET_PARSER_DISP_INFO_OUT_LENMAX
argument_list|)
index|]
decl_stmt|;
name|size_t
name|matches_count
decl_stmt|;
name|size_t
name|list_size
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PARSER_DISP_INFO
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PARSER_DISP_INFO_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PARSER_DISP_INFO_OUT_LENMAX
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PARSER_DISP_INFO_OUT_OP
argument_list|,
name|MC_CMD_GET_PARSER_DISP_INFO_IN_OP_GET_SUPPORTED_RX_MATCHES
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|matches_count
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PARSER_DISP_INFO_OUT_NUM_SUPPORTED_MATCHES
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PARSER_DISP_INFO_OUT_LEN
argument_list|(
name|matches_count
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|list_lengthp
operator|=
name|matches_count
expr_stmt|;
if|if
condition|(
name|buffer_length
operator|<
name|matches_count
condition|)
block|{
name|rc
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
comment|/* 	 * Check that the elements in the list in the MCDI response are the size 	 * we expect, so we can just copy them directly. Any conversion of the 	 * flags is handled by the caller. 	 */
name|EFX_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|==
name|MC_CMD_GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES_LEN
argument_list|)
expr_stmt|;
name|list_size
operator|=
name|matches_count
operator|*
name|MC_CMD_GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES_LEN
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint32_t
argument_list|,
name|GET_PARSER_DISP_INFO_OUT_SUPPORTED_MATCHES
argument_list|)
argument_list|,
name|list_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|ef10_filter_supported_filters
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount
argument_list|(
argument|buffer_length
argument_list|)
name|uint32_t
operator|*
name|buffer
argument_list|,
name|__in
name|size_t
name|buffer_length
argument_list|,
name|__out
name|size_t
operator|*
name|list_lengthp
argument_list|)
block|{
name|size_t
name|mcdi_list_length
decl_stmt|;
name|size_t
name|list_length
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|uint32_t
name|all_filter_flags
init|=
operator|(
name|EFX_FILTER_MATCH_REM_HOST
operator||
name|EFX_FILTER_MATCH_LOC_HOST
operator||
name|EFX_FILTER_MATCH_REM_MAC
operator||
name|EFX_FILTER_MATCH_REM_PORT
operator||
name|EFX_FILTER_MATCH_LOC_MAC
operator||
name|EFX_FILTER_MATCH_LOC_PORT
operator||
name|EFX_FILTER_MATCH_ETHER_TYPE
operator||
name|EFX_FILTER_MATCH_INNER_VID
operator||
name|EFX_FILTER_MATCH_OUTER_VID
operator||
name|EFX_FILTER_MATCH_IP_PROTO
operator||
name|EFX_FILTER_MATCH_UNKNOWN_MCAST_DST
operator||
name|EFX_FILTER_MATCH_UNKNOWN_UCAST_DST
operator|)
decl_stmt|;
name|rc
operator|=
name|efx_mcdi_get_parser_disp_info
argument_list|(
name|enp
argument_list|,
name|buffer
argument_list|,
name|buffer_length
argument_list|,
operator|&
name|mcdi_list_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|ENOSPC
condition|)
block|{
comment|/* Pass through mcdi_list_length for the list length */
operator|*
name|list_lengthp
operator|=
name|mcdi_list_length
expr_stmt|;
block|}
goto|goto
name|fail1
goto|;
block|}
comment|/* 	 * The static assertions in ef10_filter_init() ensure that the values of 	 * the EFX_FILTER_MATCH flags match those used by MCDI, so they don't 	 * need to be converted. 	 * 	 * In case support is added to MCDI for additional flags, remove any 	 * matches from the list which include flags we don't support. The order 	 * of the matches is preserved as they are ordered from highest to 	 * lowest priority. 	 */
name|EFSYS_ASSERT
argument_list|(
name|mcdi_list_length
operator|<=
name|buffer_length
argument_list|)
expr_stmt|;
name|list_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcdi_list_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|buffer
index|[
name|i
index|]
operator|&
operator|~
name|all_filter_flags
operator|)
operator|==
literal|0
condition|)
block|{
name|buffer
index|[
name|list_length
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|list_length
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|list_lengthp
operator|=
name|list_length
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_insert_unicast
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in_ecount
argument_list|(
literal|6
argument_list|)
name|uint8_t
specifier|const
operator|*
name|addr
argument_list|,
name|__in
name|efx_filter_flags_t
name|filter_flags
argument_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|eftp
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
name|spec
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* Insert the filter for the local station address */
name|efx_filter_spec_init_rx
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_PRI_AUTO
argument_list|,
name|filter_flags
argument_list|,
name|eftp
operator|->
name|eft_default_rxq
argument_list|)
expr_stmt|;
name|efx_filter_spec_set_eth_local
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_SPEC_VID_UNSPEC
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ef10_filter_add_internal
argument_list|(
name|enp
argument_list|,
operator|&
name|spec
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|eftp
operator|->
name|eft_unicst_filter_indexes
index|[
name|eftp
operator|->
name|eft_unicst_filter_count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|eftp
operator|->
name|eft_unicst_filter_count
operator|++
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eftp
operator|->
name|eft_unicst_filter_count
operator|<=
name|EFX_EF10_FILTER_UNICAST_FILTERS_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_insert_all_unicast
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_flags_t
name|filter_flags
parameter_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|eftp
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
name|spec
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* Insert the unknown unicast filter */
name|efx_filter_spec_init_rx
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_PRI_AUTO
argument_list|,
name|filter_flags
argument_list|,
name|eftp
operator|->
name|eft_default_rxq
argument_list|)
expr_stmt|;
name|efx_filter_spec_set_uc_def
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ef10_filter_add_internal
argument_list|(
name|enp
argument_list|,
operator|&
name|spec
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|eftp
operator|->
name|eft_unicst_filter_indexes
index|[
name|eftp
operator|->
name|eft_unicst_filter_count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|eftp
operator|->
name|eft_unicst_filter_count
operator|++
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eftp
operator|->
name|eft_unicst_filter_count
operator|<=
name|EFX_EF10_FILTER_UNICAST_FILTERS_MAX
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_insert_multicast_list
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|boolean_t
name|mulcst
argument_list|,
name|__in
name|boolean_t
name|brdcst
argument_list|,
name|__in_ecount
argument_list|(
literal|6
argument|*count
argument_list|)
name|uint8_t
specifier|const
operator|*
name|addrs
argument_list|,
name|__in
name|uint32_t
name|count
argument_list|,
name|__in
name|efx_filter_flags_t
name|filter_flags
argument_list|,
name|__in
name|boolean_t
name|rollback
argument_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|eftp
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
name|spec
decl_stmt|;
name|uint8_t
name|addr
index|[
literal|6
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|filter_index
decl_stmt|;
name|uint32_t
name|filter_count
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|mulcst
operator|==
name|B_FALSE
condition|)
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count
operator|+
operator|(
name|brdcst
condition|?
literal|1
else|:
literal|0
operator|)
operator|>
name|EFX_ARRAY_SIZE
argument_list|(
name|eftp
operator|->
name|eft_mulcst_filter_indexes
argument_list|)
condition|)
block|{
comment|/* Too many MAC addresses */
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Insert/renew multicast address list filters */
name|filter_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|efx_filter_spec_init_rx
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_PRI_AUTO
argument_list|,
name|filter_flags
argument_list|,
name|eftp
operator|->
name|eft_default_rxq
argument_list|)
expr_stmt|;
name|efx_filter_spec_set_eth_local
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_SPEC_VID_UNSPEC
argument_list|,
operator|&
name|addrs
index|[
name|i
operator|*
name|EFX_MAC_ADDR_LEN
index|]
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ef10_filter_add_internal
argument_list|(
name|enp
argument_list|,
operator|&
name|spec
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|filter_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|eftp
operator|->
name|eft_mulcst_filter_indexes
index|[
name|filter_count
index|]
operator|=
name|filter_index
expr_stmt|;
name|filter_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rollback
operator|==
name|B_TRUE
condition|)
block|{
comment|/* Only stop upon failure if told to rollback */
goto|goto
name|rollback
goto|;
block|}
block|}
if|if
condition|(
name|brdcst
operator|==
name|B_TRUE
condition|)
block|{
comment|/* Insert/renew broadcast address filter */
name|efx_filter_spec_init_rx
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_PRI_AUTO
argument_list|,
name|filter_flags
argument_list|,
name|eftp
operator|->
name|eft_default_rxq
argument_list|)
expr_stmt|;
name|EFX_MAC_BROADCAST_ADDR_SET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|efx_filter_spec_set_eth_local
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_SPEC_VID_UNSPEC
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ef10_filter_add_internal
argument_list|(
name|enp
argument_list|,
operator|&
name|spec
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|filter_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|eftp
operator|->
name|eft_mulcst_filter_indexes
index|[
name|filter_count
index|]
operator|=
name|filter_index
expr_stmt|;
name|filter_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rollback
operator|==
name|B_TRUE
condition|)
block|{
comment|/* Only stop upon failure if told to rollback */
goto|goto
name|rollback
goto|;
block|}
block|}
name|eftp
operator|->
name|eft_mulcst_filter_count
operator|=
name|filter_count
expr_stmt|;
name|eftp
operator|->
name|eft_using_all_mulcst
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|rollback
label|:
comment|/* Remove any filters we have inserted */
name|i
operator|=
name|filter_count
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|ef10_filter_delete_internal
argument_list|(
name|enp
argument_list|,
name|eftp
operator|->
name|eft_mulcst_filter_indexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|eftp
operator|->
name|eft_mulcst_filter_count
operator|=
literal|0
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_insert_all_multicast
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_flags_t
name|filter_flags
parameter_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|eftp
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_spec_t
name|spec
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* Insert the unknown multicast filter */
name|efx_filter_spec_init_rx
argument_list|(
operator|&
name|spec
argument_list|,
name|EFX_FILTER_PRI_AUTO
argument_list|,
name|filter_flags
argument_list|,
name|eftp
operator|->
name|eft_default_rxq
argument_list|)
expr_stmt|;
name|efx_filter_spec_set_mc_def
argument_list|(
operator|&
name|spec
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ef10_filter_add_internal
argument_list|(
name|enp
argument_list|,
operator|&
name|spec
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|eftp
operator|->
name|eft_mulcst_filter_indexes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|eftp
operator|->
name|eft_mulcst_filter_count
operator|=
literal|1
expr_stmt|;
name|eftp
operator|->
name|eft_using_all_mulcst
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * FIXME: If brdcst == B_FALSE, add a filter to drop broadcast traffic. 	 */
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_filter_remove_old
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|table
operator|->
name|eft_entry
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ef10_filter_entry_is_auto_old
argument_list|(
name|table
argument_list|,
name|i
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ef10_filter_delete_internal
argument_list|(
name|enp
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|ef10_filter_get_workarounds
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
name|enp
operator|->
name|en_nic_cfg
decl_stmt|;
name|uint32_t
name|implemented
init|=
literal|0
decl_stmt|;
name|uint32_t
name|enabled
init|=
literal|0
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|rc
operator|=
name|efx_mcdi_get_workarounds
argument_list|(
name|enp
argument_list|,
operator|&
name|implemented
argument_list|,
operator|&
name|enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* Check if chained multicast filter support is enabled */
if|if
condition|(
name|implemented
operator|&
name|enabled
operator|&
name|MC_CMD_GET_WORKAROUNDS_OUT_BUG26807
condition|)
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|ENOTSUP
condition|)
block|{
comment|/* 		 * Firmware is too old to support GET_WORKAROUNDS, and support 		 * for this workaround was implemented later. 		 */
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconfigure all filters.  * If all_unicst and/or all mulcst filters cannot be applied then  * return ENOTSUP (Note the filters for the specified addresses are  * still applied in this case).  */
end_comment

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|ef10_filter_reconfigure
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in_ecount
argument_list|(
literal|6
argument_list|)
name|uint8_t
specifier|const
operator|*
name|mac_addr
argument_list|,
name|__in
name|boolean_t
name|all_unicst
argument_list|,
name|__in
name|boolean_t
name|mulcst
argument_list|,
name|__in
name|boolean_t
name|all_mulcst
argument_list|,
name|__in
name|boolean_t
name|brdcst
argument_list|,
name|__in_ecount
argument_list|(
literal|6
argument|*count
argument_list|)
name|uint8_t
specifier|const
operator|*
name|addrs
argument_list|,
name|__in
name|uint32_t
name|count
argument_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
name|enp
operator|->
name|en_nic_cfg
decl_stmt|;
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|efx_filter_flags_t
name|filter_flags
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|all_unicst_rc
init|=
literal|0
decl_stmt|;
name|efx_rc_t
name|all_mulcst_rc
init|=
literal|0
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|eft_default_rxq
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Filters direct traffic to the default RXQ, and so cannot be 		 * inserted until it is available. Any currently configured 		 * filters must be removed (ignore errors in case the MC 		 * has rebooted, which removes hardware filters). 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|eft_unicst_filter_count
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ef10_filter_delete_internal
argument_list|(
name|enp
argument_list|,
name|table
operator|->
name|eft_unicst_filter_indexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|eft_unicst_filter_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|eft_mulcst_filter_count
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|ef10_filter_delete_internal
argument_list|(
name|enp
argument_list|,
name|table
operator|->
name|eft_mulcst_filter_indexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|eft_mulcst_filter_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|table
operator|->
name|eft_using_rss
condition|)
name|filter_flags
operator|=
name|EFX_FILTER_FLAG_RX_RSS
expr_stmt|;
else|else
name|filter_flags
operator|=
literal|0
expr_stmt|;
comment|/* Mark old filters which may need to be removed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|eft_unicst_filter_count
condition|;
name|i
operator|++
control|)
block|{
name|ef10_filter_set_entry_auto_old
argument_list|(
name|table
argument_list|,
name|table
operator|->
name|eft_unicst_filter_indexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|eft_mulcst_filter_count
condition|;
name|i
operator|++
control|)
block|{
name|ef10_filter_set_entry_auto_old
argument_list|(
name|table
argument_list|,
name|table
operator|->
name|eft_mulcst_filter_indexes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert or renew unicast filters. 	 * 	 * Frimware does not perform chaining on unicast filters. As traffic is 	 * therefore only delivered to the first matching filter, we should 	 * always insert the specific filter for our MAC address, to try and 	 * ensure we get that traffic. 	 * 	 * (If the filter for our MAC address has already been inserted by 	 * another function, we won't receive traffic sent to us, even if we 	 * insert a unicast mismatch filter. To prevent traffic stealing, this 	 * therefore relies on the privilege model only allowing functions to 	 * insert filters for their own MAC address unless explicitly given 	 * additional privileges by the user. This also means that, even on a 	 * priviliged function, inserting a unicast mismatch filter may not 	 * catch all traffic in multi PCI function scenarios.) 	 */
name|table
operator|->
name|eft_unicst_filter_count
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|ef10_filter_insert_unicast
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|,
name|filter_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_unicst
operator|||
operator|(
name|rc
operator|!=
literal|0
operator|)
condition|)
block|{
name|all_unicst_rc
operator|=
name|ef10_filter_insert_all_unicast
argument_list|(
name|enp
argument_list|,
name|filter_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|all_unicst_rc
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail1
goto|;
block|}
comment|/* 	 * WORKAROUND_BUG26807 controls firmware support for chained multicast 	 * filters, and can only be enabled or disabled when the hardware filter 	 * table is empty. 	 * 	 * Chained multicast filters require support from the datapath firmware, 	 * and may not be available (e.g. low-latency variants or old Huntington 	 * firmware). 	 * 	 * Firmware will reset (FLR) functions which have inserted filters in 	 * the hardware filter table when the workaround is enabled/disabled. 	 * Functions without any hardware filters are not reset. 	 * 	 * Re-check if the workaround is enabled after adding unicast hardware 	 * filters. This ensures that encp->enc_bug26807_workaround matches the 	 * firmware state, and that later changes to enable/disable the 	 * workaround will result in this function seeing a reset (FLR). 	 * 	 * In common-code drivers, we only support multiple PCI function 	 * scenarios with firmware that supports multicast chaining, so we can 	 * assume it is enabled for such cases and hence simplify the filter 	 * insertion logic. Firmware that does not support multicast chaining 	 * does not support multiple PCI function configurations either, so 	 * filter insertion is much simpler and the same strategies can still be 	 * used. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_filter_get_workarounds
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|table
operator|->
name|eft_using_all_mulcst
operator|!=
name|all_mulcst
operator|)
operator|&&
operator|(
name|encp
operator|->
name|enc_bug26807_workaround
operator|==
name|B_TRUE
operator|)
condition|)
block|{
comment|/* 		 * Multicast filter chaining is enabled, so traffic that matches 		 * more than one multicast filter will be replicated and 		 * delivered to multiple recipients.  To avoid this duplicate 		 * delivery, remove old multicast filters before inserting new 		 * multicast filters. 		 */
name|ef10_filter_remove_old
argument_list|(
name|enp
argument_list|)
expr_stmt|;
block|}
comment|/* Insert or renew multicast filters */
if|if
condition|(
name|all_mulcst
operator|==
name|B_TRUE
condition|)
block|{
comment|/* 		 * Insert the all multicast filter. If that fails, try to insert 		 * all of our multicast filters (but without rollback on 		 * failure). 		 */
name|all_mulcst_rc
operator|=
name|ef10_filter_insert_all_multicast
argument_list|(
name|enp
argument_list|,
name|filter_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_mulcst_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|ef10_filter_insert_multicast_list
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|,
name|brdcst
argument_list|,
name|addrs
argument_list|,
name|count
argument_list|,
name|filter_flags
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Insert filters for multicast addresses. 		 * If any insertion fails, then rollback and try to insert the 		 * all multicast filter instead. 		 * If that also fails, try to insert all of the multicast 		 * filters (but without rollback on failure). 		 */
name|rc
operator|=
name|ef10_filter_insert_multicast_list
argument_list|(
name|enp
argument_list|,
name|mulcst
argument_list|,
name|brdcst
argument_list|,
name|addrs
argument_list|,
name|count
argument_list|,
name|filter_flags
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|table
operator|->
name|eft_using_all_mulcst
operator|==
name|B_FALSE
operator|)
operator|&&
operator|(
name|encp
operator|->
name|enc_bug26807_workaround
operator|==
name|B_TRUE
operator|)
condition|)
block|{
comment|/* 				 * Multicast filter chaining is on, so remove 				 * old filters before inserting the multicast 				 * all filter to avoid duplicate delivery caused 				 * by packets matching multiple filters. 				 */
name|ef10_filter_remove_old
argument_list|(
name|enp
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|ef10_filter_insert_all_multicast
argument_list|(
name|enp
argument_list|,
name|filter_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|ef10_filter_insert_multicast_list
argument_list|(
name|enp
argument_list|,
name|mulcst
argument_list|,
name|brdcst
argument_list|,
name|addrs
argument_list|,
name|count
argument_list|,
name|filter_flags
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
block|}
block|}
block|}
comment|/* Remove old filters which were not renewed */
name|ef10_filter_remove_old
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* report if any optional flags were rejected */
if|if
condition|(
operator|(
operator|(
name|all_unicst
operator|!=
name|B_FALSE
operator|)
operator|&&
operator|(
name|all_unicst_rc
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|all_mulcst
operator|!=
name|B_FALSE
operator|)
operator|&&
operator|(
name|all_mulcst_rc
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* Clear auto old flags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|table
operator|->
name|eft_entry
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ef10_filter_entry_is_auto_old
argument_list|(
name|table
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|ef10_filter_set_entry_not_auto_old
argument_list|(
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|void
name|ef10_filter_get_default_rxq
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|efx_rxq_t
modifier|*
modifier|*
name|erpp
parameter_list|,
name|__out
name|boolean_t
modifier|*
name|using_rss
parameter_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
operator|*
name|erpp
operator|=
name|table
operator|->
name|eft_default_rxq
expr_stmt|;
operator|*
name|using_rss
operator|=
name|table
operator|->
name|eft_using_rss
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ef10_filter_default_rxq_set
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_rxq_t
modifier|*
name|erp
parameter_list|,
name|__in
name|boolean_t
name|using_rss
parameter_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_RX_SCALE
name|EFSYS_ASSERT
argument_list|(
operator|(
name|using_rss
operator|==
name|B_FALSE
operator|)
operator|||
operator|(
name|enp
operator|->
name|en_rss_context
operator|!=
name|EF10_RSS_CONTEXT_INVALID
operator|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|eft_using_rss
operator|=
name|using_rss
expr_stmt|;
else|#
directive|else
name|EFSYS_ASSERT
argument_list|(
name|using_rss
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|table
operator|->
name|eft_using_rss
operator|=
name|B_FALSE
expr_stmt|;
endif|#
directive|endif
name|table
operator|->
name|eft_default_rxq
operator|=
name|erp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ef10_filter_default_rxq_clear
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|ef10_filter_table_t
modifier|*
name|table
init|=
name|enp
operator|->
name|en_filter
operator|.
name|ef_ef10_filter_table
decl_stmt|;
name|table
operator|->
name|eft_default_rxq
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|eft_using_rss
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_FILTER */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

end_unit

