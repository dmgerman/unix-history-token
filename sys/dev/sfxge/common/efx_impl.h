begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2007-2009 Solarflare Communications Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_EFX_IMPL_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_EFX_IMPL_H
end_define

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_regs.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_FALCON
end_if

begin_include
include|#
directive|include
file|"falcon_impl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_FALCON */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_SIENA
end_if

begin_include
include|#
directive|include
file|"siena_impl.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_SIENA */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|EFX_MOD_MCDI
value|0x00000001
define|#
directive|define
name|EFX_MOD_PROBE
value|0x00000002
define|#
directive|define
name|EFX_MOD_NVRAM
value|0x00000004
define|#
directive|define
name|EFX_MOD_VPD
value|0x00000008
define|#
directive|define
name|EFX_MOD_NIC
value|0x00000010
define|#
directive|define
name|EFX_MOD_INTR
value|0x00000020
define|#
directive|define
name|EFX_MOD_EV
value|0x00000040
define|#
directive|define
name|EFX_MOD_RX
value|0x00000080
define|#
directive|define
name|EFX_MOD_TX
value|0x00000100
define|#
directive|define
name|EFX_MOD_PORT
value|0x00000200
define|#
directive|define
name|EFX_MOD_MON
value|0x00000400
define|#
directive|define
name|EFX_MOD_WOL
value|0x00000800
define|#
directive|define
name|EFX_MOD_FILTER
value|0x00001000
define|#
directive|define
name|EFX_RESET_MAC
value|0x00000001
define|#
directive|define
name|EFX_RESET_PHY
value|0x00000002
typedef|typedef
enum|enum
name|efx_mac_type_e
block|{
name|EFX_MAC_INVALID
init|=
literal|0
block|,
name|EFX_MAC_FALCON_GMAC
block|,
name|EFX_MAC_FALCON_XMAC
block|,
name|EFX_MAC_SIENA
block|,
name|EFX_MAC_NTYPES
block|}
name|efx_mac_type_t
typedef|;
typedef|typedef
struct|struct
name|efx_mac_ops_s
block|{
name|int
function_decl|(
modifier|*
name|emo_reset
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
comment|/* optional */
name|int
function_decl|(
modifier|*
name|emo_poll
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_link_mode_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|emo_up
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|boolean_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|emo_reconfigure
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|int
function_decl|(
modifier|*
name|emo_loopback_set
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_link_mode_t
parameter_list|,
name|efx_loopback_type_t
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_LOOPBACK */
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
name|int
function_decl|(
modifier|*
name|emo_stats_upload
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efsys_mem_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|emo_stats_periodic
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efsys_mem_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|emo_stats_update
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efsys_mem_t
modifier|*
parameter_list|,
name|efsys_stat_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MAC_STATS */
block|}
name|efx_mac_ops_t
typedef|;
typedef|typedef
struct|struct
name|efx_phy_ops_s
block|{
name|int
function_decl|(
modifier|*
name|epo_power
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
comment|/* optional */
name|int
function_decl|(
modifier|*
name|epo_reset
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|epo_reconfigure
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|epo_verify
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|epo_uplink_check
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|boolean_t
modifier|*
parameter_list|)
function_decl|;
comment|/* optional */
name|int
function_decl|(
modifier|*
name|epo_downlink_check
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_link_mode_t
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|epo_oui_get
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|EFSYS_OPT_PHY_STATS
name|int
function_decl|(
modifier|*
name|epo_stats_update
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efsys_mem_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_STATS */
if|#
directive|if
name|EFSYS_OPT_PHY_PROPS
if|#
directive|if
name|EFSYS_OPT_NAMES
specifier|const
name|char
name|__cs
modifier|*
function_decl|(
modifier|*
name|epo_prop_name
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_PROPS */
name|int
function_decl|(
modifier|*
name|epo_prop_get
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|epo_prop_set
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_PROPS */
if|#
directive|if
name|EFSYS_OPT_PHY_BIST
name|int
function_decl|(
modifier|*
name|epo_bist_start
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_phy_bist_type_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|epo_bist_poll
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_phy_bist_type_t
parameter_list|,
name|efx_phy_bist_result_t
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|epo_bist_stop
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_phy_bist_type_t
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_BIST */
block|}
name|efx_phy_ops_t
typedef|;
typedef|typedef
struct|struct
name|efx_port_s
block|{
name|efx_mac_type_t
name|ep_mac_type
decl_stmt|;
name|uint32_t
name|ep_phy_type
decl_stmt|;
name|uint8_t
name|ep_port
decl_stmt|;
name|uint32_t
name|ep_mac_pdu
decl_stmt|;
name|uint8_t
name|ep_mac_addr
index|[
literal|6
index|]
decl_stmt|;
name|efx_link_mode_t
name|ep_link_mode
decl_stmt|;
name|boolean_t
name|ep_unicst
decl_stmt|;
name|boolean_t
name|ep_brdcst
decl_stmt|;
name|unsigned
name|int
name|ep_fcntl
decl_stmt|;
name|boolean_t
name|ep_fcntl_autoneg
decl_stmt|;
name|efx_oword_t
name|ep_multicst_hash
index|[
literal|2
index|]
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|efx_loopback_type_t
name|ep_loopback_type
decl_stmt|;
name|efx_link_mode_t
name|ep_loopback_link_mode
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_LOOPBACK */
if|#
directive|if
name|EFSYS_OPT_PHY_FLAGS
name|uint32_t
name|ep_phy_flags
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_FLAGS */
if|#
directive|if
name|EFSYS_OPT_PHY_LED_CONTROL
name|efx_phy_led_mode_t
name|ep_phy_led_mode
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_LED_CONTROL */
name|efx_phy_media_type_t
name|ep_fixed_port_type
decl_stmt|;
name|efx_phy_media_type_t
name|ep_module_type
decl_stmt|;
name|uint32_t
name|ep_adv_cap_mask
decl_stmt|;
name|uint32_t
name|ep_lp_cap_mask
decl_stmt|;
name|uint32_t
name|ep_default_adv_cap_mask
decl_stmt|;
name|uint32_t
name|ep_phy_cap_mask
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_TXC43128
operator|||
name|EFSYS_OPT_PHY_QT2025C
union|union
block|{
struct|struct
block|{
name|unsigned
name|int
name|bug10934_count
decl_stmt|;
block|}
name|ep_txc43128
struct|;
struct|struct
block|{
name|unsigned
name|int
name|bug17190_count
decl_stmt|;
block|}
name|ep_qt2025c
struct|;
block|}
union|;
endif|#
directive|endif
name|boolean_t
name|ep_mac_poll_needed
decl_stmt|;
comment|/* falcon only */
name|boolean_t
name|ep_mac_up
decl_stmt|;
comment|/* falcon only */
name|uint32_t
name|ep_fwver
decl_stmt|;
comment|/* falcon only */
name|boolean_t
name|ep_mac_drain
decl_stmt|;
name|boolean_t
name|ep_mac_stats_pending
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_BIST
name|efx_phy_bist_type_t
name|ep_current_bist
decl_stmt|;
endif|#
directive|endif
name|efx_mac_ops_t
modifier|*
name|ep_emop
decl_stmt|;
name|efx_phy_ops_t
modifier|*
name|ep_epop
decl_stmt|;
block|}
name|efx_port_t
typedef|;
typedef|typedef
struct|struct
name|efx_mon_ops_s
block|{
name|int
function_decl|(
modifier|*
name|emo_reset
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|emo_reconfigure
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|int
function_decl|(
modifier|*
name|emo_stats_update
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efsys_mem_t
modifier|*
parameter_list|,
name|efx_mon_stat_value_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MON_STATS */
block|}
name|efx_mon_ops_t
typedef|;
typedef|typedef
struct|struct
name|efx_mon_s
block|{
name|efx_mon_type_t
name|em_type
decl_stmt|;
name|efx_mon_ops_t
modifier|*
name|em_emop
decl_stmt|;
block|}
name|efx_mon_t
typedef|;
typedef|typedef
struct|struct
name|efx_intr_s
block|{
name|efx_intr_type_t
name|ei_type
decl_stmt|;
name|efsys_mem_t
modifier|*
name|ei_esmp
decl_stmt|;
name|unsigned
name|int
name|ei_level
decl_stmt|;
block|}
name|efx_intr_t
typedef|;
typedef|typedef
struct|struct
name|efx_nic_ops_s
block|{
name|int
function_decl|(
modifier|*
name|eno_probe
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|eno_reset
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|eno_init
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|EFSYS_OPT_DIAG
name|int
function_decl|(
modifier|*
name|eno_sram_test
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_sram_pattern_fn_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|eno_register_test
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_DIAG */
name|void
function_decl|(
modifier|*
name|eno_fini
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|eno_unprobe
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
block|}
name|efx_nic_ops_t
typedef|;
ifndef|#
directive|ifndef
name|EFX_TXQ_LIMIT_TARGET
define|#
directive|define
name|EFX_TXQ_LIMIT_TARGET
value|259
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EFX_RXQ_LIMIT_TARGET
define|#
directive|define
name|EFX_RXQ_LIMIT_TARGET
value|768
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EFX_TXQ_DC_SIZE
define|#
directive|define
name|EFX_TXQ_DC_SIZE
value|1
comment|/* 16 descriptors */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EFX_RXQ_DC_SIZE
define|#
directive|define
name|EFX_RXQ_DC_SIZE
value|3
comment|/* 64 descriptors */
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_FILTER
typedef|typedef
enum|enum
name|efx_filter_type_e
block|{
name|EFX_FILTER_RX_TCP_FULL
block|,
comment|/* TCP/IPv4 4-tuple {dIP,dTCP,sIP,sTCP} */
name|EFX_FILTER_RX_TCP_WILD
block|,
comment|/* TCP/IPv4 dest    {dIP,dTCP,  -,   -} */
name|EFX_FILTER_RX_UDP_FULL
block|,
comment|/* UDP/IPv4 4-tuple {dIP,dUDP,sIP,sUDP} */
name|EFX_FILTER_RX_UDP_WILD
block|,
comment|/* UDP/IPv4 dest    {dIP,dUDP,  -,   -} */
if|#
directive|if
name|EFSYS_OPT_SIENA
name|EFX_FILTER_RX_MAC_FULL
block|,
comment|/* Ethernet {dMAC,VLAN} */
name|EFX_FILTER_RX_MAC_WILD
block|,
comment|/* Ethernet {dMAC,   -} */
name|EFX_FILTER_TX_TCP_FULL
block|,
comment|/* TCP/IPv4 {dIP,dTCP,sIP,sTCP} */
name|EFX_FILTER_TX_TCP_WILD
block|,
comment|/* TCP/IPv4 {  -,   -,sIP,sTCP} */
name|EFX_FILTER_TX_UDP_FULL
block|,
comment|/* UDP/IPv4 {dIP,dTCP,sIP,sTCP} */
name|EFX_FILTER_TX_UDP_WILD
block|,
comment|/* UDP/IPv4 source (host, port) */
name|EFX_FILTER_TX_MAC_FULL
block|,
comment|/* Ethernet source (MAC address, VLAN ID) */
name|EFX_FILTER_TX_MAC_WILD
block|,
comment|/* Ethernet source (MAC address) */
endif|#
directive|endif
comment|/* EFSYS_OPT_SIENA */
name|EFX_FILTER_NTYPES
block|}
name|efx_filter_type_t
typedef|;
typedef|typedef
enum|enum
name|efx_filter_tbl_id_e
block|{
name|EFX_FILTER_TBL_RX_IP
init|=
literal|0
block|,
name|EFX_FILTER_TBL_RX_MAC
block|,
name|EFX_FILTER_TBL_TX_IP
block|,
name|EFX_FILTER_TBL_TX_MAC
block|,
name|EFX_FILTER_NTBLS
block|}
name|efx_filter_tbl_id_t
typedef|;
typedef|typedef
struct|struct
name|efx_filter_tbl_s
block|{
name|int
name|eft_size
decl_stmt|;
comment|/* number of entries */
name|int
name|eft_used
decl_stmt|;
comment|/* active count */
name|uint32_t
modifier|*
name|eft_bitmap
decl_stmt|;
comment|/* active bitmap */
name|efx_filter_spec_t
modifier|*
name|eft_spec
decl_stmt|;
comment|/* array of saved specs */
block|}
name|efx_filter_tbl_t
typedef|;
typedef|typedef
struct|struct
name|efx_filter_s
block|{
name|efx_filter_tbl_t
name|ef_tbl
index|[
name|EFX_FILTER_NTBLS
index|]
decl_stmt|;
name|unsigned
name|int
name|ef_depth
index|[
name|EFX_FILTER_NTYPES
index|]
decl_stmt|;
block|}
name|efx_filter_t
typedef|;
specifier|extern
name|__checkReturn
name|int
name|efx_filter_insert_filter
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|,
name|__in
name|boolean_t
name|replace
parameter_list|)
function_decl|;
specifier|extern
name|__checkReturn
name|int
name|efx_filter_remove_filter
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_spec_t
modifier|*
name|spec
parameter_list|)
function_decl|;
specifier|extern
name|void
name|efx_filter_remove_index
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_type_t
name|type
parameter_list|,
name|__in
name|int
name|filter_idx
parameter_list|)
function_decl|;
specifier|extern
name|void
name|efx_filter_redirect_index
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_type_t
name|type
parameter_list|,
name|__in
name|int
name|filter_index
parameter_list|,
name|__in
name|int
name|rxq_index
parameter_list|)
function_decl|;
specifier|extern
name|__checkReturn
name|int
name|efx_filter_clear_tbl
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_filter_tbl_id_t
name|tbl
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_FILTER */
if|#
directive|if
name|EFSYS_OPT_NVRAM
typedef|typedef
struct|struct
name|efx_nvram_ops_s
block|{
if|#
directive|if
name|EFSYS_OPT_DIAG
name|int
function_decl|(
modifier|*
name|envo_test
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_DIAG */
name|int
function_decl|(
modifier|*
name|envo_size
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|envo_get_version
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|envo_rw_start
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|envo_read_chunk
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|envo_erase
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|envo_write_chunk
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|envo_rw_finish
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|envo_set_version
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|efx_nvram_type_t
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
block|}
name|efx_nvram_ops_t
typedef|;
endif|#
directive|endif
comment|/* EFSYS_OPT_NVRAM */
if|#
directive|if
name|EFSYS_OPT_VPD
typedef|typedef
struct|struct
name|efx_vpd_ops_s
block|{
name|int
function_decl|(
modifier|*
name|evpdo_init
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_size
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_read
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_verify
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_reinit
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_get
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|,
name|efx_vpd_value_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_set
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|,
name|efx_vpd_value_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_next
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|,
name|efx_vpd_value_t
modifier|*
parameter_list|,
name|unsigned
name|int
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|evpdo_write
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|evpdo_fini
function_decl|)
parameter_list|(
name|efx_nic_t
modifier|*
parameter_list|)
function_decl|;
block|}
name|efx_vpd_ops_t
typedef|;
endif|#
directive|endif
comment|/* EFSYS_OPT_VPD */
struct|struct
name|efx_nic_s
block|{
name|uint32_t
name|en_magic
decl_stmt|;
name|efx_family_t
name|en_family
decl_stmt|;
name|uint32_t
name|en_features
decl_stmt|;
name|efsys_identifier_t
modifier|*
name|en_esip
decl_stmt|;
name|efsys_lock_t
modifier|*
name|en_eslp
decl_stmt|;
name|efsys_bar_t
modifier|*
name|en_esbp
decl_stmt|;
name|unsigned
name|int
name|en_mod_flags
decl_stmt|;
name|unsigned
name|int
name|en_reset_flags
decl_stmt|;
name|efx_nic_cfg_t
name|en_nic_cfg
decl_stmt|;
name|efx_port_t
name|en_port
decl_stmt|;
name|efx_mon_t
name|en_mon
decl_stmt|;
name|efx_intr_t
name|en_intr
decl_stmt|;
name|uint32_t
name|en_ev_qcount
decl_stmt|;
name|uint32_t
name|en_rx_qcount
decl_stmt|;
name|uint32_t
name|en_tx_qcount
decl_stmt|;
name|efx_nic_ops_t
modifier|*
name|en_enop
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_FILTER
name|efx_filter_t
name|en_filter
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_FILTER */
if|#
directive|if
name|EFSYS_OPT_NVRAM
name|efx_nvram_type_t
name|en_nvram_locked
decl_stmt|;
name|efx_nvram_ops_t
modifier|*
name|en_envop
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_NVRAM */
if|#
directive|if
name|EFSYS_OPT_VPD
name|efx_vpd_ops_t
modifier|*
name|en_evpdop
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_VPD */
union|union
block|{
if|#
directive|if
name|EFSYS_OPT_FALCON
struct|struct
block|{
name|falcon_spi_dev_t
name|enu_fsd
index|[
name|FALCON_SPI_NTYPES
index|]
decl_stmt|;
name|falcon_i2c_t
name|enu_fip
decl_stmt|;
name|boolean_t
name|enu_i2c_locked
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_FALCON_NIC_CFG_OVERRIDE
specifier|const
name|uint8_t
modifier|*
name|enu_forced_cfg
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_FALCON_NIC_CFG_OVERRIDE */
name|uint8_t
name|enu_mon_devid
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_PCIE_TUNE
name|unsigned
name|int
name|enu_nlanes
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PCIE_TUNE */
name|uint16_t
name|enu_board_rev
decl_stmt|;
name|boolean_t
name|enu_internal_sram
decl_stmt|;
name|uint8_t
name|enu_sram_num_bank
decl_stmt|;
name|uint8_t
name|enu_sram_bank_size
decl_stmt|;
block|}
name|falcon
struct|;
endif|#
directive|endif
comment|/* EFSYS_OPT_FALCON */
if|#
directive|if
name|EFSYS_OPT_SIENA
struct|struct
block|{
if|#
directive|if
name|EFSYS_OPT_MCDI
name|efx_mcdi_iface_t
name|enu_mip
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI */
if|#
directive|if
name|EFSYS_OPT_NVRAM
operator|||
name|EFSYS_OPT_VPD
name|unsigned
name|int
name|enu_partn_mask
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_NVRAM || EFSYS_OPT_VPD */
if|#
directive|if
name|EFSYS_OPT_VPD
name|caddr_t
name|enu_svpd
decl_stmt|;
name|size_t
name|enu_svpd_length
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_VPD */
block|}
name|siena
struct|;
endif|#
directive|endif
comment|/* EFSYS_OPT_SIENA */
block|}
name|en_u
union|;
block|}
struct|;
define|#
directive|define
name|EFX_NIC_MAGIC
value|0x02121996
typedef|typedef
name|boolean_t
function_decl|(
modifier|*
name|efx_ev_handler_t
function_decl|)
parameter_list|(
name|efx_evq_t
modifier|*
parameter_list|,
name|efx_qword_t
modifier|*
parameter_list|,
specifier|const
name|efx_ev_callbacks_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
struct|struct
name|efx_evq_s
block|{
name|uint32_t
name|ee_magic
decl_stmt|;
name|efx_nic_t
modifier|*
name|ee_enp
decl_stmt|;
name|unsigned
name|int
name|ee_index
decl_stmt|;
name|unsigned
name|int
name|ee_mask
decl_stmt|;
name|efsys_mem_t
modifier|*
name|ee_esmp
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_QSTATS
name|uint32_t
name|ee_stat
index|[
name|EV_NQSTATS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_QSTATS */
name|efx_ev_handler_t
name|ee_handler
index|[
literal|1
operator|<<
name|FSF_AZ_EV_CODE_WIDTH
index|]
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|EFX_EVQ_MAGIC
value|0x08081997
define|#
directive|define
name|EFX_EVQ_FALCON_TIMER_QUANTUM_NS
value|4968
comment|/* 621 cycles */
define|#
directive|define
name|EFX_EVQ_SIENA_TIMER_QUANTUM_NS
value|6144
comment|/* 768 cycles */
struct|struct
name|efx_rxq_s
block|{
name|uint32_t
name|er_magic
decl_stmt|;
name|efx_nic_t
modifier|*
name|er_enp
decl_stmt|;
name|unsigned
name|int
name|er_index
decl_stmt|;
name|unsigned
name|int
name|er_mask
decl_stmt|;
name|efsys_mem_t
modifier|*
name|er_esmp
decl_stmt|;
block|}
struct|;
define|#
directive|define
name|EFX_RXQ_MAGIC
value|0x15022005
struct|struct
name|efx_txq_s
block|{
name|uint32_t
name|et_magic
decl_stmt|;
name|efx_nic_t
modifier|*
name|et_enp
decl_stmt|;
name|unsigned
name|int
name|et_index
decl_stmt|;
name|unsigned
name|int
name|et_mask
decl_stmt|;
name|efsys_mem_t
modifier|*
name|et_esmp
decl_stmt|;
if|#
directive|if
name|EFSYS_OPT_QSTATS
name|uint32_t
name|et_stat
index|[
name|TX_NQSTATS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_QSTATS */
block|}
struct|;
define|#
directive|define
name|EFX_TXQ_MAGIC
value|0x05092005
define|#
directive|define
name|EFX_MAC_ADDR_COPY
parameter_list|(
name|_dst
parameter_list|,
name|_src
parameter_list|)
define|\
value|do {								\ 		(_dst)[0] = (_src)[0];					\ 		(_dst)[1] = (_src)[1];					\ 		(_dst)[2] = (_src)[2];					\ 		(_dst)[3] = (_src)[3];					\ 		(_dst)[4] = (_src)[4];					\ 		(_dst)[5] = (_src)[5];					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
if|#
directive|if
name|EFSYS_OPT_CHECK_REG
define|#
directive|define
name|EFX_CHECK_REG
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|)
define|\
value|do {								\ 		const char __cs *name = #_reg;				\ 		char min = name[4];					\ 		char max = name[5];					\ 		char rev;						\ 									\ 		switch ((_enp)->en_family) {				\ 		case EFX_FAMILY_FALCON:					\ 			rev = 'B';					\ 			break;						\ 									\ 		case EFX_FAMILY_SIENA:					\ 			rev = 'C';					\ 			break;						\ 									\ 		default:						\ 			rev = '?';					\ 			break;						\ 		}							\ 									\ 		EFSYS_ASSERT3S(rev,>=, min);				\ 		EFSYS_ASSERT3S(rev,<=, max);				\ 									\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
else|#
directive|else
define|#
directive|define
name|EFX_CHECK_REG
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|)
value|do {					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while(B_FALSE)
endif|#
directive|endif
define|#
directive|define
name|EFX_BAR_READD
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_edp
parameter_list|,
name|_lock
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_BAR_READD((_enp)->en_esbp, _reg ## _OFST,		\ 		    (_edp), (_lock));					\ 		EFSYS_PROBE3(efx_bar_readd, const char *, #_reg,	\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_edp)->ed_u32[0]);			\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_WRITED
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_edp
parameter_list|,
name|_lock
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE3(efx_bar_writed, const char *, #_reg,	\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_edp)->ed_u32[0]);			\ 		EFSYS_BAR_WRITED((_enp)->en_esbp, _reg ## _OFST,	\ 		    (_edp), (_lock));					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_READQ
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_eqp
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_BAR_READQ((_enp)->en_esbp, _reg ## _OFST,		\ 		    (_eqp));						\ 		EFSYS_PROBE4(efx_bar_readq, const char *, #_reg,	\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eqp)->eq_u32[1],			\ 		    uint32_t, (_eqp)->eq_u32[0]);			\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_WRITEQ
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_eqp
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE4(efx_bar_writeq, const char *, #_reg,	\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eqp)->eq_u32[1],			\ 		    uint32_t, (_eqp)->eq_u32[0]);			\ 		EFSYS_BAR_WRITEQ((_enp)->en_esbp, _reg ## _OFST,	\ 		    (_eqp));						\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_READO
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_eop
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_BAR_READO((_enp)->en_esbp, _reg ## _OFST,		\ 		    (_eop), B_TRUE);					\ 		EFSYS_PROBE6(efx_bar_reado, const char *, #_reg,	\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eop)->eo_u32[3],			\ 		    uint32_t, (_eop)->eo_u32[2],			\ 		    uint32_t, (_eop)->eo_u32[1],			\ 		    uint32_t, (_eop)->eo_u32[0]);			\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_WRITEO
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_eop
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE6(efx_bar_writeo, const char *, #_reg,	\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eop)->eo_u32[3],			\ 		    uint32_t, (_eop)->eo_u32[2],			\ 		    uint32_t, (_eop)->eo_u32[1],			\ 		    uint32_t, (_eop)->eo_u32[0]);			\ 		EFSYS_BAR_WRITEO((_enp)->en_esbp, _reg ## _OFST,	\ 		    (_eop), B_TRUE);					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_READD
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_edp
parameter_list|,
name|_lock
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_BAR_READD((_enp)->en_esbp,			\ 		    (_reg ## _OFST + ((_index) * _reg ## _STEP)),	\ 		    (_edp), (_lock));					\ 		EFSYS_PROBE4(efx_bar_tbl_readd, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_edp)->ed_u32[0]);			\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_WRITED
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_edp
parameter_list|,
name|_lock
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE4(efx_bar_tbl_writed, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_edp)->ed_u32[0]);			\ 		EFSYS_BAR_WRITED((_enp)->en_esbp,			\ 		    (_reg ## _OFST + ((_index) * _reg ## _STEP)),	\ 		    (_edp), (_lock));					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_WRITED3
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_edp
parameter_list|,
name|_lock
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE4(efx_bar_tbl_writed, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_edp)->ed_u32[0]);			\ 		EFSYS_BAR_WRITED((_enp)->en_esbp,			\ 		    (_reg ## _OFST +					\ 		    (3 * sizeof (efx_dword_t)) + 			\ 		    ((_index) * _reg ## _STEP)),			\ 		    (_edp), (_lock));					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_READQ
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_eqp
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_BAR_READQ((_enp)->en_esbp,			\ 		    (_reg ## _OFST + ((_index) * _reg ## _STEP)),	\ 		    (_eqp));						\ 		EFSYS_PROBE5(efx_bar_tbl_readq, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eqp)->eq_u32[1],			\ 		    uint32_t, (_eqp)->eq_u32[0]);			\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_WRITEQ
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_eqp
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE5(efx_bar_tbl_writeq, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eqp)->eq_u32[1],			\ 		    uint32_t, (_eqp)->eq_u32[0]);			\ 		EFSYS_BAR_WRITEQ((_enp)->en_esbp,			\ 		    (_reg ## _OFST + ((_index) * _reg ## _STEP)),	\ 		    (_eqp));						\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_READO
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_eop
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_BAR_READO((_enp)->en_esbp,			\ 		    (_reg ## _OFST + ((_index) * _reg ## _STEP)),	\ 		    (_eop), B_TRUE);					\ 		EFSYS_PROBE7(efx_bar_tbl_reado, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eop)->eo_u32[3],			\ 		    uint32_t, (_eop)->eo_u32[2],			\ 		    uint32_t, (_eop)->eo_u32[1],			\ 		    uint32_t, (_eop)->eo_u32[0]);			\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
define|#
directive|define
name|EFX_BAR_TBL_WRITEO
parameter_list|(
name|_enp
parameter_list|,
name|_reg
parameter_list|,
name|_index
parameter_list|,
name|_eop
parameter_list|)
define|\
value|do {								\ 		EFX_CHECK_REG((_enp), (_reg));				\ 		EFSYS_PROBE7(efx_bar_tbl_writeo, const char *, #_reg,	\ 		    uint32_t, (_index),					\ 		    uint32_t, _reg ## _OFST,				\ 		    uint32_t, (_eop)->eo_u32[3],			\ 		    uint32_t, (_eop)->eo_u32[2],			\ 		    uint32_t, (_eop)->eo_u32[1],			\ 		    uint32_t, (_eop)->eo_u32[0]);			\ 		EFSYS_BAR_WRITEO((_enp)->en_esbp,			\ 		    (_reg ## _OFST + ((_index) * _reg ## _STEP)),	\ 		    (_eop), B_TRUE);					\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
specifier|extern
name|__checkReturn
name|int
name|efx_mac_select
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
function_decl|;
specifier|extern
name|__checkReturn
name|int
name|efx_phy_probe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|efx_phy_unprobe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
function_decl|;
if|#
directive|if
name|EFSYS_OPT_VPD
comment|/* VPD utility functions */
specifier|extern
name|__checkReturn
name|int
name|efx_vpd_hunk_length
argument_list|(
name|__in_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|,
name|__out
name|size_t
operator|*
name|lengthp
argument_list|)
decl_stmt|;
specifier|extern
name|__checkReturn
name|int
name|efx_vpd_hunk_verify
argument_list|(
name|__in_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|,
name|__out_opt
name|boolean_t
operator|*
name|cksummedp
argument_list|)
decl_stmt|;
specifier|extern
name|__checkReturn
name|int
name|efx_vpd_hunk_reinit
parameter_list|(
name|__in
name|caddr_t
name|data
parameter_list|,
name|__in
name|size_t
name|size
parameter_list|,
name|__in
name|boolean_t
name|wantpid
parameter_list|)
function_decl|;
specifier|extern
name|__checkReturn
name|int
name|efx_vpd_hunk_get
argument_list|(
name|__in_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|,
name|__in
name|efx_vpd_tag_t
name|tag
argument_list|,
name|__in
name|efx_vpd_keyword_t
name|keyword
argument_list|,
name|__out
name|unsigned
name|int
operator|*
name|payloadp
argument_list|,
name|__out
name|uint8_t
operator|*
name|paylenp
argument_list|)
decl_stmt|;
specifier|extern
name|__checkReturn
name|int
name|efx_vpd_hunk_next
argument_list|(
name|__in_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|,
name|__out
name|efx_vpd_tag_t
operator|*
name|tagp
argument_list|,
name|__out
name|efx_vpd_keyword_t
operator|*
name|keyword
argument_list|,
name|__out_bcount_opt
argument_list|(
argument|*paylenp
argument_list|)
name|unsigned
name|int
operator|*
name|payloadp
argument_list|,
name|__out_opt
name|uint8_t
operator|*
name|paylenp
argument_list|,
name|__inout
name|unsigned
name|int
operator|*
name|contp
argument_list|)
decl_stmt|;
specifier|extern
name|__checkReturn
name|int
name|efx_vpd_hunk_set
argument_list|(
name|__in_bcount
argument_list|(
argument|size
argument_list|)
name|caddr_t
name|data
argument_list|,
name|__in
name|size_t
name|size
argument_list|,
name|__in
name|efx_vpd_value_t
operator|*
name|evvp
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_VPD */
if|#
directive|if
name|EFSYS_OPT_DIAG
specifier|extern
name|efx_sram_pattern_fn_t
name|__cs
name|__efx_sram_pattern_fns
index|[]
decl_stmt|;
typedef|typedef
struct|struct
name|efx_register_set_s
block|{
name|unsigned
name|int
name|address
decl_stmt|;
name|unsigned
name|int
name|step
decl_stmt|;
name|unsigned
name|int
name|rows
decl_stmt|;
name|efx_oword_t
name|mask
decl_stmt|;
block|}
name|efx_register_set_t
typedef|;
specifier|extern
name|__checkReturn
name|int
name|efx_nic_test_registers
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_register_set_t
modifier|*
name|rsp
parameter_list|,
name|__in
name|size_t
name|count
parameter_list|)
function_decl|;
specifier|extern
name|__checkReturn
name|int
name|efx_nic_test_tables
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_register_set_t
modifier|*
name|rsp
parameter_list|,
name|__in
name|efx_pattern_type_t
name|pattern
parameter_list|,
name|__in
name|size_t
name|count
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* EFSYS_OPT_DIAG */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_EFX_IMPL_H */
end_comment

end_unit

