begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2016 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MON_STATS
end_if

begin_include
include|#
directive|include
file|"mcdi_mon.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_QSTATS
end_if

begin_define
define|#
directive|define
name|EFX_EV_QSTAT_INCR
parameter_list|(
name|_eep
parameter_list|,
name|_stat
parameter_list|)
define|\
value|do {								\ 		(_eep)->ee_stat[_stat]++;				\ 	_NOTE(CONSTANTCONDITION)					\ 	} while (B_FALSE)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EFX_EV_QSTAT_INCR
parameter_list|(
name|_eep
parameter_list|,
name|_stat
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_rx
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_tx
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_driver
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_drv_gen
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_mcdi
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_init_evq
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|instance
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|size_t
name|nevs
parameter_list|,
name|__in
name|uint32_t
name|irq
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_INIT_EVQ_IN_LEN
argument_list|(
name|EFX_EVQ_NBUFS
argument_list|(
name|EFX_EVQ_MAXNEVS
argument_list|)
argument_list|)
argument_list|,
name|MC_CMD_INIT_EVQ_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_qword_t
modifier|*
name|dma_addr
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|supports_rx_batching
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|npages
operator|=
name|EFX_EVQ_NBUFS
argument_list|(
name|nevs
argument_list|)
expr_stmt|;
if|if
condition|(
name|MC_CMD_INIT_EVQ_IN_LEN
argument_list|(
name|npages
argument_list|)
operator|>
name|MC_CMD_INIT_EVQ_IN_LENMAX
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_INIT_EVQ
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_INIT_EVQ_IN_LEN
argument_list|(
name|npages
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_INIT_EVQ_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_SIZE
argument_list|,
name|nevs
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_INSTANCE
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_IRQ_NUM
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* 	 * On Huntington RX and TX event batching can only be requested 	 * together (even if the datapath firmware doesn't actually support RX 	 * batching). 	 * Cut through is incompatible with RX batching and so enabling cut 	 * through disables RX batching (but it does not affect TX batching). 	 * 	 * So always enable RX and TX event batching, and enable cut through 	 * if RX event batching isn't supported (i.e. on low latency firmware). 	 */
name|supports_rx_batching
operator|=
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_rx_batching_enabled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_6
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_FLAGS
argument_list|,
name|INIT_EVQ_IN_FLAG_INTERRUPTING
argument_list|,
literal|1
argument_list|,
name|INIT_EVQ_IN_FLAG_RPTR_DOS
argument_list|,
literal|0
argument_list|,
name|INIT_EVQ_IN_FLAG_INT_ARMD
argument_list|,
literal|0
argument_list|,
name|INIT_EVQ_IN_FLAG_CUT_THRU
argument_list|,
operator|!
name|supports_rx_batching
argument_list|,
name|INIT_EVQ_IN_FLAG_RX_MERGE
argument_list|,
literal|1
argument_list|,
name|INIT_EVQ_IN_FLAG_TX_MERGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_TMR_MODE
argument_list|,
name|MC_CMD_INIT_EVQ_IN_TMR_MODE_DIS
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_TMR_LOAD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_TMR_RELOAD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_COUNT_MODE
argument_list|,
name|MC_CMD_INIT_EVQ_IN_COUNT_MODE_DIS
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|INIT_EVQ_IN_COUNT_THRSHLD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dma_addr
operator|=
name|MCDI_IN2
argument_list|(
name|req
argument_list|,
name|efx_qword_t
argument_list|,
name|INIT_EVQ_IN_DMA_ADDR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|EFSYS_MEM_ADDR
argument_list|(
name|esmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|EFX_POPULATE_QWORD_2
argument_list|(
operator|*
name|dma_addr
argument_list|,
name|EFX_DWORD_1
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
literal|32
argument_list|)
argument_list|,
name|EFX_DWORD_0
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|&
literal|0xffffffff
argument_list|)
argument_list|)
expr_stmt|;
name|dma_addr
operator|++
expr_stmt|;
name|addr
operator|+=
name|EFX_BUF_SIZE
expr_stmt|;
block|}
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_INIT_EVQ_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
comment|/* NOTE: ignore the returned IRQ param as firmware does not set it. */
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_fini_evq
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|instance
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_FINI_EVQ_IN_LEN
argument_list|,
name|MC_CMD_FINI_EVQ_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FINI_EVQ
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_FINI_EVQ_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_FINI_EVQ_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FINI_EVQ_IN_INSTANCE
argument_list|,
name|instance
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_ev_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ef10_ev_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_ev_qcreate
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|index
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|size_t
name|n
parameter_list|,
name|__in
name|uint32_t
name|id
parameter_list|,
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint32_t
name|irq
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|_NOTE
argument_list|(
argument|ARGUNUSED(id)
argument_list|)
comment|/* buftbl id managed by MC */
name|EFX_STATIC_ASSERT
argument_list|(
name|ISP2
argument_list|(
name|EFX_EVQ_MAXNEVS
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|ISP2
argument_list|(
name|EFX_EVQ_MINNEVS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISP2
argument_list|(
name|n
argument_list|)
operator|||
operator|(
name|n
operator|<
name|EFX_EVQ_MINNEVS
operator|)
operator|||
operator|(
name|n
operator|>
name|EFX_EVQ_MAXNEVS
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|index
operator|>=
name|encp
operator|->
name|enc_evq_limit
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
comment|/* Set up the handler table */
name|eep
operator|->
name|ee_rx
operator|=
name|ef10_ev_rx
expr_stmt|;
name|eep
operator|->
name|ee_tx
operator|=
name|ef10_ev_tx
expr_stmt|;
name|eep
operator|->
name|ee_driver
operator|=
name|ef10_ev_driver
expr_stmt|;
name|eep
operator|->
name|ee_drv_gen
operator|=
name|ef10_ev_drv_gen
expr_stmt|;
name|eep
operator|->
name|ee_mcdi
operator|=
name|ef10_ev_mcdi
expr_stmt|;
comment|/* Set up the event queue */
name|irq
operator|=
name|index
expr_stmt|;
comment|/* INIT_EVQ expects function-relative vector number */
comment|/* 	 * Interrupts may be raised for events immediately after the queue is 	 * created. See bug58606. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_init_evq
argument_list|(
name|enp
argument_list|,
name|index
argument_list|,
name|esmp
argument_list|,
name|n
argument_list|,
name|irq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ef10_ev_qdestroy
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_fini_evq
argument_list|(
name|eep
operator|->
name|ee_enp
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_ev_qprime
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|count
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|uint32_t
name|rptr
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|rptr
operator|=
name|count
operator|&
name|eep
operator|->
name|ee_mask
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_bug35388_workaround
condition|)
block|{
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_EVQ_MINNEVS
operator|>
operator|(
literal|1
operator|<<
name|ERF_DD_EVQ_IND_RPTR_WIDTH
operator|)
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_EVQ_MAXNEVS
operator|<
operator|(
literal|1
operator|<<
literal|2
operator|*
name|ERF_DD_EVQ_IND_RPTR_WIDTH
operator|)
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|ERF_DD_EVQ_IND_RPTR_FLAGS
argument_list|,
name|EFE_DD_EVQ_IND_RPTR_FLAGS_HIGH
argument_list|,
name|ERF_DD_EVQ_IND_RPTR
argument_list|,
operator|(
name|rptr
operator|>>
name|ERF_DD_EVQ_IND_RPTR_WIDTH
operator|)
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|ER_DD_EVQ_INDIRECT
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|ERF_DD_EVQ_IND_RPTR_FLAGS
argument_list|,
name|EFE_DD_EVQ_IND_RPTR_FLAGS_LOW
argument_list|,
name|ERF_DD_EVQ_IND_RPTR
argument_list|,
name|rptr
operator|&
operator|(
operator|(
literal|1
operator|<<
name|ERF_DD_EVQ_IND_RPTR_WIDTH
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|ER_DD_EVQ_INDIRECT
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dword
argument_list|,
name|ERF_DZ_EVQ_RPTR
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|ER_DZ_EVQ_RPTR_REG
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_driver_event
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|evq
parameter_list|,
name|__in
name|efx_qword_t
name|data
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_DRIVER_EVENT_IN_LEN
argument_list|,
name|MC_CMD_DRIVER_EVENT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_DRIVER_EVENT
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_DRIVER_EVENT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_DRIVER_EVENT_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRIVER_EVENT_IN_EVQ
argument_list|,
name|evq
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRIVER_EVENT_IN_DATA_LO
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
name|data
argument_list|,
name|EFX_DWORD_0
argument_list|)
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRIVER_EVENT_IN_DATA_HI
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
name|data
argument_list|,
name|EFX_DWORD_1
argument_list|)
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ef10_ev_qpost
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|uint16_t
name|data
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|efx_qword_t
name|event
decl_stmt|;
name|EFX_POPULATE_QWORD_3
argument_list|(
name|event
argument_list|,
name|ESF_DZ_DRV_CODE
argument_list|,
name|ESE_DZ_EV_CODE_DRV_GEN_EV
argument_list|,
name|ESF_DZ_DRV_SUB_CODE
argument_list|,
literal|0
argument_list|,
name|ESF_DZ_DRV_SUB_DATA_DW0
argument_list|,
operator|(
name|uint32_t
operator|)
name|data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_driver_event
argument_list|(
name|enp
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_ev_qmoderate
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|us
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|uint32_t
name|timer_val
decl_stmt|,
name|mode
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|us
operator|>
name|encp
operator|->
name|enc_evq_timer_max_us
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* If the value is zero then disable the timer */
if|if
condition|(
name|us
operator|==
literal|0
condition|)
block|{
name|timer_val
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|FFE_CZ_TIMER_MODE_DIS
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the timer value in quanta */
name|timer_val
operator|=
name|us
operator|*
literal|1000
operator|/
name|encp
operator|->
name|enc_evq_timer_quantum_ns
expr_stmt|;
comment|/* Moderation value is base 0 so we need to deduct 1 */
if|if
condition|(
name|timer_val
operator|>
literal|0
condition|)
name|timer_val
operator|--
expr_stmt|;
name|mode
operator|=
name|FFE_CZ_TIMER_MODE_INT_HLDOFF
expr_stmt|;
block|}
if|if
condition|(
name|encp
operator|->
name|enc_bug35388_workaround
condition|)
block|{
name|EFX_POPULATE_DWORD_3
argument_list|(
name|dword
argument_list|,
name|ERF_DD_EVQ_IND_TIMER_FLAGS
argument_list|,
name|EFE_DD_EVQ_IND_TIMER_FLAGS
argument_list|,
name|ERF_DD_EVQ_IND_TIMER_MODE
argument_list|,
name|mode
argument_list|,
name|ERF_DD_EVQ_IND_TIMER_VAL
argument_list|,
name|timer_val
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|ER_DD_EVQ_INDIRECT
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EFX_POPULATE_DWORD_2
argument_list|(
name|dword
argument_list|,
name|ERF_DZ_TC_TIMER_MODE
argument_list|,
name|mode
argument_list|,
name|ERF_DZ_TC_TIMER_VAL
argument_list|,
name|timer_val
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|ER_DZ_EVQ_TMR_REG
argument_list|,
name|eep
operator|->
name|ee_index
argument_list|,
operator|&
name|dword
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_QSTATS
end_if

begin_decl_stmt
name|void
name|ef10_ev_qstats_update
argument_list|(
name|__in
name|efx_evq_t
operator|*
name|eep
argument_list|,
name|__inout_ecount
argument_list|(
argument|EV_NQSTATS
argument_list|)
name|efsys_stat_t
operator|*
name|stat
argument_list|)
block|{
name|unsigned
name|int
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|EV_NQSTATS
condition|;
name|id
operator|++
control|)
block|{
name|efsys_stat_t
modifier|*
name|essp
init|=
operator|&
name|stat
index|[
name|id
index|]
decl_stmt|;
name|EFSYS_STAT_INCR
argument_list|(
name|essp
argument_list|,
name|eep
operator|->
name|ee_stat
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|eep
operator|->
name|ee_stat
index|[
name|id
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_QSTATS */
end_comment

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_rx
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|label
decl_stmt|;
name|uint32_t
name|mac_class
decl_stmt|;
name|uint32_t
name|eth_tag_class
decl_stmt|;
name|uint32_t
name|l3_class
decl_stmt|;
name|uint32_t
name|l4_class
decl_stmt|;
name|uint32_t
name|next_read_lbits
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|boolean_t
name|cont
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|efx_evq_rxq_state_t
modifier|*
name|eersp
decl_stmt|;
name|unsigned
name|int
name|desc_count
decl_stmt|;
name|unsigned
name|int
name|last_used_id
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX
argument_list|)
expr_stmt|;
comment|/* Discard events after RXQ/TXQ errors */
if|if
condition|(
name|enp
operator|->
name|en_reset_flags
operator|&
operator|(
name|EFX_RESET_RXQ_ERR
operator||
name|EFX_RESET_TXQ_ERR
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* Basic packet information */
name|size
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_BYTES
argument_list|)
expr_stmt|;
name|next_read_lbits
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_DSC_PTR_LBITS
argument_list|)
expr_stmt|;
name|label
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_QLABEL
argument_list|)
expr_stmt|;
name|eth_tag_class
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_ETH_TAG_CLASS
argument_list|)
expr_stmt|;
name|mac_class
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_MAC_CLASS
argument_list|)
expr_stmt|;
name|l3_class
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_L3_CLASS
argument_list|)
expr_stmt|;
name|l4_class
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_L4_CLASS
argument_list|)
expr_stmt|;
name|cont
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_CONT
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_DROP_EVENT
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Drop this event */
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cont
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * This may be part of a scattered frame, or it may be a 		 * truncated frame if scatter is disabled on this RXQ. 		 * Overlength frames can be received if e.g. a VF is configured 		 * for 1500 MTU but connected to a port set to 9000 MTU 		 * (see bug56567). 		 * FIXME: There is not yet any driver that supports scatter on 		 * Huntington.  Scatter support is required for OSX. 		 */
name|flags
operator||=
name|EFX_PKT_CONT
expr_stmt|;
block|}
if|if
condition|(
name|mac_class
operator|==
name|ESE_DZ_MAC_CLASS_UCAST
condition|)
name|flags
operator||=
name|EFX_PKT_UNICAST
expr_stmt|;
comment|/* Increment the count of descriptors read */
name|eersp
operator|=
operator|&
name|eep
operator|->
name|ee_rxq_state
index|[
name|label
index|]
expr_stmt|;
name|desc_count
operator|=
operator|(
name|next_read_lbits
operator|-
name|eersp
operator|->
name|eers_rx_read_ptr
operator|)
operator|&
name|EFX_MASK32
argument_list|(
name|ESF_DZ_RX_DSC_PTR_LBITS
argument_list|)
expr_stmt|;
name|eersp
operator|->
name|eers_rx_read_ptr
operator|+=
name|desc_count
expr_stmt|;
comment|/* 	 * FIXME: add error checking to make sure this a batched event. 	 * This could also be an aborted scatter, see Bug36629. 	 */
if|if
condition|(
name|desc_count
operator|>
literal|1
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_BATCH
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_PREFIX_LEN
expr_stmt|;
block|}
comment|/* Calculate the index of the last descriptor consumed */
name|last_used_id
operator|=
operator|(
name|eersp
operator|->
name|eers_rx_read_ptr
operator|-
literal|1
operator|)
operator|&
name|eersp
operator|->
name|eers_rx_mask
expr_stmt|;
comment|/* Check for errors that invalidate checksum and L3/L4 fields */
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_ECC_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* RX frame truncated (error flag is misnamed) */
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_FRM_TRUNC
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_DISCARD
expr_stmt|;
goto|goto
name|deliver
goto|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_ECRC_ERR
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Bad Ethernet frame CRC */
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_ETH_CRC_ERR
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_DISCARD
expr_stmt|;
goto|goto
name|deliver
goto|;
block|}
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_PARSE_INCOMPLETE
argument_list|)
condition|)
block|{
comment|/* 		 * Hardware parse failed, due to malformed headers 		 * or headers that are too long for the parser. 		 * Headers and checksums must be validated by the host. 		 */
comment|// TODO: EFX_EV_QSTAT_INCR(eep, EV_RX_PARSE_INCOMPLETE);
goto|goto
name|deliver
goto|;
block|}
if|if
condition|(
operator|(
name|eth_tag_class
operator|==
name|ESE_DZ_ETH_TAG_CLASS_VLAN1
operator|)
operator|||
operator|(
name|eth_tag_class
operator|==
name|ESE_DZ_ETH_TAG_CLASS_VLAN2
operator|)
condition|)
block|{
name|flags
operator||=
name|EFX_PKT_VLAN_TAGGED
expr_stmt|;
block|}
switch|switch
condition|(
name|l3_class
condition|)
block|{
case|case
name|ESE_DZ_L3_CLASS_IP4
case|:
case|case
name|ESE_DZ_L3_CLASS_IP4_FRAG
case|:
name|flags
operator||=
name|EFX_PKT_IPV4
expr_stmt|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_IPCKSUM_ERR
argument_list|)
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_IPV4_HDR_CHKSUM_ERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|EFX_CKSUM_IPV4
expr_stmt|;
block|}
if|if
condition|(
name|l4_class
operator|==
name|ESE_DZ_L4_CLASS_TCP
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TCP_IPV4
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l4_class
operator|==
name|ESE_DZ_L4_CLASS_UDP
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_UDP_IPV4
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_UDP
expr_stmt|;
block|}
else|else
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_OTHER_IPV4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ESE_DZ_L3_CLASS_IP6
case|:
case|case
name|ESE_DZ_L3_CLASS_IP6_FRAG
case|:
name|flags
operator||=
name|EFX_PKT_IPV6
expr_stmt|;
if|if
condition|(
name|l4_class
operator|==
name|ESE_DZ_L4_CLASS_TCP
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TCP_IPV6
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l4_class
operator|==
name|ESE_DZ_L4_CLASS_UDP
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_UDP_IPV6
argument_list|)
expr_stmt|;
name|flags
operator||=
name|EFX_PKT_UDP
expr_stmt|;
block|}
else|else
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_OTHER_IPV6
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_NON_IP
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|flags
operator|&
operator|(
name|EFX_PKT_TCP
operator||
name|EFX_PKT_UDP
operator|)
condition|)
block|{
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_RX_TCPUDP_CKSUM_ERR
argument_list|)
condition|)
block|{
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_TCP_UDP_CHKSUM_ERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator||=
name|EFX_CKSUM_TCPUDP
expr_stmt|;
block|}
block|}
name|deliver
label|:
comment|/* If we're not discarding the packet then it is ok */
if|if
condition|(
operator|~
name|flags
operator|&
name|EFX_DISCARD
condition|)
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_RX_OK
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_rx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_rx
argument_list|(
name|arg
argument_list|,
name|label
argument_list|,
name|last_used_id
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_tx
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|label
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_TX
argument_list|)
expr_stmt|;
comment|/* Discard events after RXQ/TXQ errors */
if|if
condition|(
name|enp
operator|->
name|en_reset_flags
operator|&
operator|(
name|EFX_RESET_RXQ_ERR
operator||
name|EFX_RESET_TXQ_ERR
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_TX_DROP_EVENT
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Drop this event */
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
comment|/* Per-packet TX completion (was per-descriptor for Falcon/Siena) */
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_TX_DESCR_INDX
argument_list|)
expr_stmt|;
name|label
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_TX_QLABEL
argument_list|)
expr_stmt|;
name|EFSYS_PROBE2
argument_list|(
name|tx_complete
argument_list|,
name|uint32_t
argument_list|,
name|label
argument_list|,
name|uint32_t
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_tx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_tx
argument_list|(
name|arg
argument_list|,
name|label
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_driver
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|int
name|code
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
name|code
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_DRV_SUB_CODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ESE_DZ_DRV_TIMER_EV
case|:
block|{
name|uint32_t
name|id
decl_stmt|;
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_DRV_TMR_ID
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_timer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_timer
argument_list|(
name|arg
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ESE_DZ_DRV_WAKE_UP_EV
case|:
block|{
name|uint32_t
name|id
decl_stmt|;
name|id
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_DRV_EVQ_ID
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_wake_up
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_wake_up
argument_list|(
name|arg
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ESE_DZ_DRV_START_UP_EV
case|:
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_initialized
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_initialized
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|EFSYS_PROBE3
argument_list|(
argument|bad_event
argument_list|,
argument|unsigned int
argument_list|,
argument|eep->ee_index
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_1)
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_0)
argument_list|)
empty_stmt|;
break|break;
block|}
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_drv_gen
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|boolean_t
name|should_abort
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRV_GEN
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
name|data
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|ESF_DZ_DRV_SUB_DATA_DW0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|>=
operator|(
operator|(
name|uint32_t
operator|)
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
name|EFSYS_PROBE3
argument_list|(
argument|bad_event
argument_list|,
argument|unsigned int
argument_list|,
argument|eep->ee_index
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_1)
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_0)
argument_list|)
empty_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_software
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_software
argument_list|(
name|arg
argument_list|,
operator|(
name|uint16_t
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|boolean_t
name|ef10_ev_mcdi
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__in
specifier|const
name|efx_ev_callbacks_t
modifier|*
name|eecp
parameter_list|,
name|__in_opt
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|efx_nic_t
modifier|*
name|enp
init|=
name|eep
operator|->
name|ee_enp
decl_stmt|;
name|unsigned
name|code
decl_stmt|;
name|boolean_t
name|should_abort
init|=
name|B_FALSE
decl_stmt|;
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_MCDI_RESPONSE
argument_list|)
expr_stmt|;
name|code
operator|=
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|MCDI_EVENT_CODE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MCDI_EVENT_CODE_BADSSERT
case|:
name|efx_mcdi_ev_death
argument_list|(
name|enp
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_CODE_CMDDONE
case|:
name|efx_mcdi_ev_cpl
argument_list|(
name|enp
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|CMDDONE_SEQ
argument_list|)
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|CMDDONE_DATALEN
argument_list|)
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|CMDDONE_ERRNO
argument_list|)
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|EFSYS_OPT_MCDI_PROXY_AUTH
case|case
name|MCDI_EVENT_CODE_PROXY_RESPONSE
case|:
comment|/* 		 * This event notifies a function that an authorization request 		 * has been processed. If the request was authorized then the 		 * function can now re-send the original MCDI request. 		 * See SF-113652-SW "SR-IOV Proxied Network Access Control". 		 */
name|efx_mcdi_ev_proxy_response
argument_list|(
name|enp
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|PROXY_RESPONSE_HANDLE
argument_list|)
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|PROXY_RESPONSE_RC
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* EFSYS_OPT_MCDI_PROXY_AUTH */
case|case
name|MCDI_EVENT_CODE_LINKCHANGE
case|:
block|{
name|efx_link_mode_t
name|link_mode
decl_stmt|;
name|ef10_phy_link_ev
argument_list|(
name|enp
argument_list|,
name|eqp
argument_list|,
operator|&
name|link_mode
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_link_change
argument_list|(
name|arg
argument_list|,
name|link_mode
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_SENSOREVT
case|:
block|{
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|efx_mon_stat_t
name|id
decl_stmt|;
name|efx_mon_stat_value_t
name|value
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* Decode monitor stat for MCDI sensor (if supported) */
if|if
condition|(
operator|(
name|rc
operator|=
name|mcdi_mon_ev
argument_list|(
name|enp
argument_list|,
name|eqp
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Report monitor stat change */
name|should_abort
operator|=
name|eecp
operator|->
name|eec_monitor
argument_list|(
name|arg
argument_list|,
name|id
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|ENOTSUP
condition|)
block|{
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_UNKNOWN_SENSOREVT
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|DATA
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|EFSYS_ASSERT
argument_list|(
name|rc
operator|==
name|ENODEV
argument_list|)
expr_stmt|;
comment|/* Wrong port */
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_SCHEDERR
case|:
comment|/* Informational only */
break|break;
case|case
name|MCDI_EVENT_CODE_REBOOT
case|:
comment|/* Falcon/Siena only (should not been seen with Huntington). */
name|efx_mcdi_ev_death
argument_list|(
name|enp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_CODE_MC_REBOOT
case|:
comment|/* MC_REBOOT event is used for Huntington (EF10) and later. */
name|efx_mcdi_ev_death
argument_list|(
name|enp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_CODE_MAC_STATS_DMA
case|:
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
if|if
condition|(
name|eecp
operator|->
name|eec_mac_stats
operator|!=
name|NULL
condition|)
block|{
name|eecp
operator|->
name|eec_mac_stats
argument_list|(
name|arg
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|MAC_STATS_DMA_GENERATION
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|MCDI_EVENT_CODE_FWALERT
case|:
block|{
name|uint32_t
name|reason
init|=
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|FWALERT_REASON
argument_list|)
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|MCDI_EVENT_FWALERT_REASON_SRAM_ACCESS
condition|)
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_FWALERT_SRAM
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|FWALERT_DATA
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|should_abort
operator|=
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_UNKNOWN_FWALERT
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|DATA
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_TX_ERR
case|:
block|{
comment|/* 		 * After a TXQ error is detected, firmware sends a TX_ERR event. 		 * This may be followed by TX completions (which we discard), 		 * and then finally by a TX_FLUSH event. Firmware destroys the 		 * TXQ automatically after sending the TX_FLUSH event. 		 */
name|enp
operator|->
name|en_reset_flags
operator||=
name|EFX_RESET_TXQ_ERR
expr_stmt|;
name|EFSYS_PROBE2
argument_list|(
name|tx_descq_err
argument_list|,
name|uint32_t
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|EFX_DWORD_1
argument_list|)
argument_list|,
name|uint32_t
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|EFX_DWORD_0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Inform the driver that a reset is required. */
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_TX_ERROR
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|TX_ERR_DATA
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_TX_FLUSH
case|:
block|{
name|uint32_t
name|txq_index
init|=
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|TX_FLUSH_TXQ
argument_list|)
decl_stmt|;
comment|/* 		 * EF10 firmware sends two TX_FLUSH events: one to the txq's 		 * event queue, and one to evq 0 (with TX_FLUSH_TO_DRIVER set). 		 * We want to wait for all completions, so ignore the events 		 * with TX_FLUSH_TO_DRIVER. 		 */
if|if
condition|(
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|TX_FLUSH_TO_DRIVER
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
break|break;
block|}
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_TX_DESCQ_FLS_DONE
argument_list|)
expr_stmt|;
name|EFSYS_PROBE1
argument_list|(
name|tx_descq_fls_done
argument_list|,
name|uint32_t
argument_list|,
name|txq_index
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_txq_flush_done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_txq_flush_done
argument_list|(
name|arg
argument_list|,
name|txq_index
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_RX_ERR
case|:
block|{
comment|/* 		 * After an RXQ error is detected, firmware sends an RX_ERR 		 * event. This may be followed by RX events (which we discard), 		 * and then finally by an RX_FLUSH event. Firmware destroys the 		 * RXQ automatically after sending the RX_FLUSH event. 		 */
name|enp
operator|->
name|en_reset_flags
operator||=
name|EFX_RESET_RXQ_ERR
expr_stmt|;
name|EFSYS_PROBE2
argument_list|(
name|rx_descq_err
argument_list|,
name|uint32_t
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|EFX_DWORD_1
argument_list|)
argument_list|,
name|uint32_t
argument_list|,
name|EFX_QWORD_FIELD
argument_list|(
operator|*
name|eqp
argument_list|,
name|EFX_DWORD_0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Inform the driver that a reset is required. */
name|eecp
operator|->
name|eec_exception
argument_list|(
name|arg
argument_list|,
name|EFX_EXCEPTION_RX_ERROR
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|RX_ERR_DATA
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCDI_EVENT_CODE_RX_FLUSH
case|:
block|{
name|uint32_t
name|rxq_index
init|=
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|RX_FLUSH_RXQ
argument_list|)
decl_stmt|;
comment|/* 		 * EF10 firmware sends two RX_FLUSH events: one to the rxq's 		 * event queue, and one to evq 0 (with RX_FLUSH_TO_DRIVER set). 		 * We want to wait for all completions, so ignore the events 		 * with RX_FLUSH_TO_DRIVER. 		 */
if|if
condition|(
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|RX_FLUSH_TO_DRIVER
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|should_abort
operator|=
name|B_FALSE
expr_stmt|;
break|break;
block|}
name|EFX_EV_QSTAT_INCR
argument_list|(
name|eep
argument_list|,
name|EV_DRIVER_RX_DESCQ_FLS_DONE
argument_list|)
expr_stmt|;
name|EFSYS_PROBE1
argument_list|(
name|rx_descq_fls_done
argument_list|,
name|uint32_t
argument_list|,
name|rxq_index
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|eecp
operator|->
name|eec_rxq_flush_done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|should_abort
operator|=
name|eecp
operator|->
name|eec_rxq_flush_done
argument_list|(
name|arg
argument_list|,
name|rxq_index
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|EFSYS_PROBE3
argument_list|(
argument|bad_event
argument_list|,
argument|unsigned int
argument_list|,
argument|eep->ee_index
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_1)
argument_list|,
argument|uint32_t
argument_list|,
argument|EFX_QWORD_FIELD(*eqp, EFX_DWORD_0)
argument_list|)
empty_stmt|;
break|break;
block|}
return|return
operator|(
name|should_abort
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ef10_ev_rxlabel_init
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|efx_rxq_t
modifier|*
name|erp
parameter_list|,
name|__in
name|unsigned
name|int
name|label
parameter_list|)
block|{
name|efx_evq_rxq_state_t
modifier|*
name|eersp
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|label
argument_list|,
operator|<
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|eep
operator|->
name|ee_rxq_state
argument_list|)
argument_list|)
expr_stmt|;
name|eersp
operator|=
operator|&
name|eep
operator|->
name|ee_rxq_state
index|[
name|label
index|]
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eersp
operator|->
name|eers_rx_mask
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|eersp
operator|->
name|eers_rx_read_ptr
operator|=
literal|0
expr_stmt|;
name|eersp
operator|->
name|eers_rx_mask
operator|=
name|erp
operator|->
name|er_mask
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ef10_ev_rxlabel_fini
parameter_list|(
name|__in
name|efx_evq_t
modifier|*
name|eep
parameter_list|,
name|__in
name|unsigned
name|int
name|label
parameter_list|)
block|{
name|efx_evq_rxq_state_t
modifier|*
name|eersp
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|label
argument_list|,
operator|<
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|eep
operator|->
name|ee_rxq_state
argument_list|)
argument_list|)
expr_stmt|;
name|eersp
operator|=
operator|&
name|eep
operator|->
name|ee_rxq_state
index|[
name|label
index|]
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|eersp
operator|->
name|eers_rx_mask
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|eersp
operator|->
name|eers_rx_read_ptr
operator|=
literal|0
expr_stmt|;
name|eersp
operator|->
name|eers_rx_mask
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

end_unit

