begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_include
include|#
directive|include
file|"mcdi_mon.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
end_if

begin_include
include|#
directive|include
file|"ef10_tlv_layout.h"
end_include

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_port_assignment
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|portp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PORT_ASSIGNMENT_IN_LEN
argument_list|,
name|MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PORT_ASSIGNMENT
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PORT_ASSIGNMENT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|portp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PORT_ASSIGNMENT_OUT_PORT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_port_modes
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|modesp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PORT_MODES_IN_LEN
argument_list|,
name|MC_CMD_GET_PORT_MODES_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PORT_MODES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PORT_MODES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PORT_MODES_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Accept pre-Medford size (8 bytes - no CurrentMode field) */
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PORT_MODES_OUT_CURRENT_MODE_OFST
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|modesp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PORT_MODES_OUT_MODES
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_vadaptor_alloc
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|port_id
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_VADAPTOR_ALLOC_IN_LEN
argument_list|,
name|MC_CMD_VADAPTOR_ALLOC_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_vport_id
argument_list|,
operator|==
argument_list|,
name|EVB_PORT_ID_NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_VADAPTOR_ALLOC
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_VADAPTOR_ALLOC_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_VADAPTOR_ALLOC_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|VADAPTOR_ALLOC_IN_UPSTREAM_PORT_ID
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_1
argument_list|(
name|req
argument_list|,
name|VADAPTOR_ALLOC_IN_FLAGS
argument_list|,
name|VADAPTOR_ALLOC_IN_FLAG_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED
argument_list|,
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_allow_set_mac_with_installed_filters
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_vadaptor_free
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|port_id
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_VADAPTOR_FREE_IN_LEN
argument_list|,
name|MC_CMD_VADAPTOR_FREE_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_VADAPTOR_FREE
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_VADAPTOR_FREE_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_VADAPTOR_FREE_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|VADAPTOR_FREE_IN_UPSTREAM_PORT_ID
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_mac_address_pf
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|6
argument_list|)
name|uint8_t
name|mac_addrp
index|[
literal|6
index|]
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_MAC_ADDRESSES_IN_LEN
argument_list|,
name|MC_CMD_GET_MAC_ADDRESSES_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_MAC_ADDRESSES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_MAC_ADDRESSES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_MAC_ADDRESSES_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_MAC_ADDRESSES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_MAC_ADDRESSES_OUT_MAC_COUNT
argument_list|)
operator|<
literal|1
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|mac_addrp
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|addrp
decl_stmt|;
name|addrp
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_MAC_ADDRESSES_OUT_MAC_ADDR_BASE
argument_list|)
expr_stmt|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|mac_addrp
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_mac_address_vf
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|6
argument_list|)
name|uint8_t
name|mac_addrp
index|[
literal|6
index|]
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_IN_LEN
argument_list|,
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMAX
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_VPORT_GET_MAC_ADDRESSES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMAX
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|VPORT_GET_MAC_ADDRESSES_IN_VPORT_ID
argument_list|,
name|EVB_PORT_ID_ASSIGNED
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMIN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|VPORT_GET_MAC_ADDRESSES_OUT_MACADDR_COUNT
argument_list|)
operator|<
literal|1
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|mac_addrp
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|addrp
decl_stmt|;
name|addrp
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|VPORT_GET_MAC_ADDRESSES_OUT_MACADDR
argument_list|)
expr_stmt|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|mac_addrp
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_clock
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|sys_freqp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_CLOCK_IN_LEN
argument_list|,
name|MC_CMD_GET_CLOCK_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_CLOCK
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_CLOCK_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_CLOCK_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_CLOCK_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|sys_freqp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_CLOCK_OUT_SYS_FREQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sys_freqp
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_vector_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|vec_basep
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|pf_nvecp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|vf_nvecp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_VECTOR_CFG_IN_LEN
argument_list|,
name|MC_CMD_GET_VECTOR_CFG_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_VECTOR_CFG
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_VECTOR_CFG_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_VECTOR_CFG_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_VECTOR_CFG_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|vec_basep
operator|!=
name|NULL
condition|)
operator|*
name|vec_basep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VECTOR_CFG_OUT_VEC_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_nvecp
operator|!=
name|NULL
condition|)
operator|*
name|pf_nvecp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VECTOR_CFG_OUT_VECS_PER_PF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf_nvecp
operator|!=
name|NULL
condition|)
operator|*
name|vf_nvecp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VECTOR_CFG_OUT_VECS_PER_VF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_capabilities
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|efx_dword_t
modifier|*
name|flagsp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_CAPABILITIES_IN_LEN
argument_list|,
name|MC_CMD_GET_CAPABILITIES_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_CAPABILITIES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_CAPABILITIES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_CAPABILITIES_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_CAPABILITIES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|flagsp
operator|=
operator|*
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|efx_dword_t
argument_list|,
name|GET_CAPABILITIES_OUT_FLAGS1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_alloc_vis
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|min_vi_count
parameter_list|,
name|__in
name|uint32_t
name|max_vi_count
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|vi_basep
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|vi_countp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_ALLOC_VIS_IN_LEN
argument_list|,
name|MC_CMD_ALLOC_VIS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|vi_countp
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ALLOC_VIS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_ALLOC_VIS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_ALLOC_VIS_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_IN_MIN_VI_COUNT
argument_list|,
name|min_vi_count
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_IN_MAX_VI_COUNT
argument_list|,
name|max_vi_count
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_ALLOC_VIS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|vi_basep
operator|!=
name|NULL
condition|)
operator|*
name|vi_basep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_OUT_VI_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi_countp
operator|!=
name|NULL
condition|)
operator|*
name|vi_countp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_OUT_VI_COUNT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_free_vis
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_FREE_VIS_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_FREE_VIS_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FREE_VIS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
comment|/* Ignore ELREADY (no allocated VIs, so nothing to free) */
if|if
condition|(
operator|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|req
operator|.
name|emr_rc
operator|!=
name|EALREADY
operator|)
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_alloc_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|efx_piobuf_handle_t
modifier|*
name|handlep
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_ALLOC_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_ALLOC_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|handlep
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ALLOC_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_ALLOC_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_ALLOC_PIOBUF_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_ALLOC_PIOBUF_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
operator|*
name|handlep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_PIOBUF_OUT_PIOBUF_HANDLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_free_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_piobuf_handle_t
name|handle
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_FREE_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_FREE_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FREE_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_FREE_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_FREE_PIOBUF_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FREE_PIOBUF_IN_PIOBUF_HANDLE
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_link_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|,
name|__in
name|efx_piobuf_handle_t
name|handle
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_LINK_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_LINK_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_LINK_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_LINK_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_LINK_PIOBUF_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LINK_PIOBUF_IN_PIOBUF_HANDLE
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LINK_PIOBUF_IN_TXQ_INSTANCE
argument_list|,
name|vi_index
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_unlink_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_UNLINK_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_UNLINK_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_UNLINK_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_UNLINK_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_UNLINK_PIOBUF_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|UNLINK_PIOBUF_IN_TXQ_INSTANCE
argument_list|,
name|vi_index
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hunt_nic_alloc_piobufs
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|max_piobuf_count
parameter_list|)
block|{
name|efx_piobuf_handle_t
modifier|*
name|handlep
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|max_piobuf_count
argument_list|,
operator|<=
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
argument_list|)
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|handlep
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_alloc_piobuf
argument_list|(
name|enp
argument_list|,
name|handlep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_alloc_map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|++
expr_stmt|;
block|}
return|return;
name|fail1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|handlep
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
expr_stmt|;
name|efx_mcdi_free_piobuf
argument_list|(
name|enp
argument_list|,
operator|*
name|handlep
argument_list|)
expr_stmt|;
operator|*
name|handlep
operator|=
name|EFX_PIOBUF_HANDLE_INVALID
expr_stmt|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hunt_nic_free_piobufs
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_piobuf_handle_t
modifier|*
name|handlep
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|handlep
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
expr_stmt|;
name|efx_mcdi_free_piobuf
argument_list|(
name|enp
argument_list|,
operator|*
name|handlep
argument_list|)
expr_stmt|;
operator|*
name|handlep
operator|=
name|EFX_PIOBUF_HANDLE_INVALID
expr_stmt|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sub-allocate a block from a piobuf */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_pio_alloc
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|bufnump
parameter_list|,
name|__out
name|efx_piobuf_handle_t
modifier|*
name|handlep
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|blknump
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|offsetp
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
name|enp
operator|->
name|en_drv_cfg
decl_stmt|;
name|uint32_t
name|blk_per_buf
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|,
name|blk
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|bufnump
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|handlep
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|blknump
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|offsetp
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|sizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|edcp
operator|->
name|edc_pio_alloc_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|==
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|blk_per_buf
operator|=
name|HUNT_PIOBUF_SIZE
operator|/
name|edcp
operator|->
name|edc_pio_alloc_size
expr_stmt|;
for|for
control|(
name|buf
operator|=
literal|0
init|;
name|buf
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|buf
operator|++
control|)
block|{
name|uint32_t
modifier|*
name|map
init|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_alloc_map
index|[
name|buf
index|]
decl_stmt|;
if|if
condition|(
operator|~
operator|(
operator|*
name|map
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|EFSYS_ASSERT3U
argument_list|(
name|blk_per_buf
argument_list|,
operator|<=
argument_list|,
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|blk_per_buf
condition|;
name|blk
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|map
operator|&
operator|(
literal|1u
operator|<<
name|blk
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|map
operator||=
operator|(
literal|1u
operator|<<
name|blk
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail2
goto|;
name|done
label|:
operator|*
name|handlep
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|buf
index|]
expr_stmt|;
operator|*
name|bufnump
operator|=
name|buf
expr_stmt|;
operator|*
name|blknump
operator|=
name|blk
expr_stmt|;
operator|*
name|sizep
operator|=
name|edcp
operator|->
name|edc_pio_alloc_size
expr_stmt|;
operator|*
name|offsetp
operator|=
name|blk
operator|*
operator|(
operator|*
name|sizep
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a piobuf sub-allocated block */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_pio_free
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|bufnum
parameter_list|,
name|__in
name|uint32_t
name|blknum
parameter_list|)
block|{
name|uint32_t
modifier|*
name|map
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|bufnum
operator|>=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|)
operator|||
operator|(
name|blknum
operator|>=
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|map
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_alloc_map
index|[
name|bufnum
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|map
operator|&
operator|(
literal|1u
operator|<<
name|blknum
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|map
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|blknum
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_pio_link
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|,
name|__in
name|efx_piobuf_handle_t
name|handle
parameter_list|)
block|{
return|return
operator|(
name|efx_mcdi_link_piobuf
argument_list|(
name|enp
argument_list|,
name|vi_index
argument_list|,
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_pio_unlink
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|)
block|{
return|return
operator|(
name|efx_mcdi_unlink_piobuf
argument_list|(
name|enp
argument_list|,
name|vi_index
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|hunt_get_datapath_caps
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_dword_t
name|datapath_capabilities
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_capabilities
argument_list|(
name|enp
argument_list|,
operator|&
name|datapath_capabilities
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	 * Huntington RXDP firmware inserts a 0 or 14 byte prefix. 	 * We only support the 14 byte prefix here. 	 */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_RX_PREFIX_LEN_14
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|encp
operator|->
name|enc_rx_prefix_size
operator|=
literal|14
expr_stmt|;
comment|/* Check if the firmware supports TSO */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_TX_TSO
argument_list|)
operator|==
literal|1
condition|)
name|encp
operator|->
name|enc_fw_assisted_tso_enabled
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|encp
operator|->
name|enc_fw_assisted_tso_enabled
operator|=
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware has vadapter/vport/vswitch support */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_EVB
argument_list|)
operator|==
literal|1
condition|)
name|encp
operator|->
name|enc_datapath_cap_evb
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|encp
operator|->
name|enc_datapath_cap_evb
operator|=
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware supports VLAN insertion */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_TX_VLAN_INSERTION
argument_list|)
operator|==
literal|1
condition|)
name|encp
operator|->
name|enc_hw_tx_insert_vlan_enabled
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|encp
operator|->
name|enc_hw_tx_insert_vlan_enabled
operator|=
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware supports RX event batching */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_RX_BATCHING
argument_list|)
operator|==
literal|1
condition|)
block|{
name|encp
operator|->
name|enc_rx_batching_enabled
operator|=
name|B_TRUE
expr_stmt|;
name|encp
operator|->
name|enc_rx_batch_max
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|encp
operator|->
name|enc_rx_batching_enabled
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* Check if the firmware supports disabling scatter on RXQs */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_RX_DISABLE_SCATTER
argument_list|)
operator|==
literal|1
condition|)
block|{
name|encp
operator|->
name|enc_rx_disable_scatter_supported
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|encp
operator|->
name|enc_rx_disable_scatter_supported
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* Check if the firmware supports set mac with running filters */
if|if
condition|(
name|MCDI_CMD_DWORD_FIELD
argument_list|(
operator|&
name|datapath_capabilities
argument_list|,
name|GET_CAPABILITIES_OUT_VADAPTOR_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED
argument_list|)
operator|==
literal|1
condition|)
block|{
name|encp
operator|->
name|enc_allow_set_mac_with_installed_filters
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|encp
operator|->
name|enc_allow_set_mac_with_installed_filters
operator|=
name|B_FALSE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The external port mapping is a one-based numbering of the external  * connectors on the board. It does not distinguish off-board separated  * outputs such as multi-headed cables.  * The number of ports that map to each external port connector  * on the board is determined by the chip family and the port modes to  * which the NIC can be configured. The mapping table lists modes with  * port numbering requirements in increasing order.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|efx_family_t
name|family
decl_stmt|;
name|uint32_t
name|modes_mask
decl_stmt|;
name|uint32_t
name|stride
decl_stmt|;
block|}
name|__hunt_external_port_mappings
index|[]
init|=
block|{
comment|/* Supported modes requiring 1 output per port */
block|{
name|EFX_FAMILY_HUNTINGTON
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_10G_10G
operator|)
block|,
literal|1
block|}
block|,
comment|/* Supported modes requiring 2 outputs per port */
block|{
name|EFX_FAMILY_HUNTINGTON
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_40G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_10G_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_40G
operator|)
block|,
literal|2
block|}
comment|/* 	 * NOTE: Medford modes will require 4 outputs per port: 	 *	TLV_PORT_MODE_10G_10G_10G_10G_Q 	 *	TLV_PORT_MODE_10G_10G_10G_10G_Q2 	 * The Q2 mode routes outputs to external port 2. Support for this 	 * will require a new field specifying the number to add after 	 * scaling by stride. This is fixed at 1 currently. 	 */
block|}
struct|;
end_struct

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|hunt_external_port_mapping
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|port
parameter_list|,
name|__out
name|uint8_t
modifier|*
name|external_portp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|port_modes
decl_stmt|;
name|uint32_t
name|matches
decl_stmt|;
name|uint32_t
name|stride
init|=
literal|1
decl_stmt|;
comment|/* default 1-1 mapping */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_modes
argument_list|(
name|enp
argument_list|,
operator|&
name|port_modes
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* No port mode information available - use default mapping */
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Infer the internal port -> external port mapping from 	 * the possible port modes for this NIC. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|__hunt_external_port_mappings
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|__hunt_external_port_mappings
index|[
name|i
index|]
operator|.
name|family
operator|!=
name|enp
operator|->
name|en_family
condition|)
continue|continue;
name|matches
operator|=
operator|(
name|__hunt_external_port_mappings
index|[
name|i
index|]
operator|.
name|modes_mask
operator|&
name|port_modes
operator|)
expr_stmt|;
if|if
condition|(
name|matches
operator|!=
literal|0
condition|)
block|{
name|stride
operator|=
name|__hunt_external_port_mappings
index|[
name|i
index|]
operator|.
name|stride
expr_stmt|;
name|port_modes
operator|&=
operator|~
name|matches
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port_modes
operator|!=
literal|0
condition|)
block|{
comment|/* Some advertised modes are not supported */
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|out
label|:
comment|/* 	 * Scale as required by last matched mode and then convert to 	 * one-based numbering 	 */
operator|*
name|external_portp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|port
operator|/
name|stride
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|hunt_board_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint8_t
name|mac_addr
index|[
literal|6
index|]
decl_stmt|;
name|uint32_t
name|board_type
init|=
literal|0
decl_stmt|;
name|hunt_link_state_t
name|hls
decl_stmt|;
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|;
name|uint32_t
name|vf
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|sysclk
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|nvec
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_assignment
argument_list|(
name|enp
argument_list|,
operator|&
name|port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	 * NOTE: The MCDI protocol numbers ports from zero. 	 * The common code MCDI interface numbers ports from one. 	 */
name|emip
operator|->
name|emi_port
operator|=
name|port
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_external_port_mapping
argument_list|(
name|enp
argument_list|,
name|port
argument_list|,
operator|&
name|encp
operator|->
name|enc_external_port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Get PCIe function number from firmware (used for 	 * per-function privilege and dynamic config info). 	 *  - PCIe PF: pf = PF number, vf = 0xffff. 	 *  - PCIe VF: pf = parent PF, vf = VF number. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_function_info
argument_list|(
name|enp
argument_list|,
operator|&
name|pf
argument_list|,
operator|&
name|vf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|encp
operator|->
name|enc_pf
operator|=
name|pf
expr_stmt|;
name|encp
operator|->
name|enc_vf
operator|=
name|vf
expr_stmt|;
comment|/* MAC address for this function */
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_pf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
condition|)
block|{
comment|/* 			 * If the static config does not include a global MAC 			 * address pool then the board may return a locally 			 * administered MAC address (this should only happen on 			 * incorrectly programmed boards). 			 */
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_vf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|encp
operator|->
name|enc_mac_addr
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* Board configuration */
name|rc
operator|=
name|efx_mcdi_get_board_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|board_type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Unprivileged functions may not be able to read board cfg */
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
name|board_type
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|fail5
goto|;
block|}
name|encp
operator|->
name|enc_board_type
operator|=
name|board_type
expr_stmt|;
name|encp
operator|->
name|enc_clk_mult
operator|=
literal|1
expr_stmt|;
comment|/* not used for Huntington */
comment|/* Fill out fields in enp->en_port and enp->en_nic_cfg from MCDI */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
comment|/* Obtain the default PHY advertised capabilities */
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_phy_get_link
argument_list|(
name|enp
argument_list|,
operator|&
name|hls
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|=
name|hls
operator|.
name|hls_adv_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_adv_cap_mask
operator|=
name|hls
operator|.
name|hls_adv_cap_mask
expr_stmt|;
comment|/* 	 * Enable firmware workarounds for hardware errata. 	 * Expected responses are: 	 *  - 0 (zero): 	 *	Success: workaround enabled or disabled as requested. 	 *  - MC_CMD_ERR_ENOSYS (reported as ENOTSUP): 	 *	Firmware does not support the MC_CMD_WORKAROUND request. 	 *	(assume that the workaround is not supported). 	 *  - MC_CMD_ERR_ENOENT (reported as ENOENT): 	 *	Firmware does not support the requested workaround. 	 *  - MC_CMD_ERR_EPERM  (reported as EACCES): 	 *	Unprivileged function cannot enable/disable workarounds. 	 * 	 * See efx_mcdi_request_errcode() for MCDI error translations. 	 */
comment|/* 	 * If the bug35388 workaround is enabled, then use an indirect access 	 * method to avoid unsafe EVQ writes. 	 */
name|rc
operator|=
name|efx_mcdi_set_workaround
argument_list|(
name|enp
argument_list|,
name|MC_CMD_WORKAROUND_BUG35388
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|||
operator|(
name|rc
operator|==
name|EACCES
operator|)
condition|)
name|encp
operator|->
name|enc_bug35388_workaround
operator|=
name|B_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rc
operator|==
name|ENOTSUP
operator|)
operator|||
operator|(
name|rc
operator|==
name|ENOENT
operator|)
condition|)
name|encp
operator|->
name|enc_bug35388_workaround
operator|=
name|B_FALSE
expr_stmt|;
else|else
goto|goto
name|fail8
goto|;
comment|/* 	 * If the bug41750 workaround is enabled, then do not test interrupts, 	 * as the test will fail (seen with Greenport controllers). 	 */
name|rc
operator|=
name|efx_mcdi_set_workaround
argument_list|(
name|enp
argument_list|,
name|MC_CMD_WORKAROUND_BUG41750
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
block|{
comment|/* Assume a controller with 40G ports needs the workaround. */
if|if
condition|(
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|&
name|EFX_PHY_CAP_40000FDX
condition|)
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rc
operator|==
name|ENOTSUP
operator|)
operator|||
operator|(
name|rc
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail9
goto|;
block|}
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_VF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
comment|/* Interrupt testing does not work for VFs. See bug50084. */
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * If the bug26807 workaround is enabled, then firmware has enabled 	 * support for chained multicast filters. Firmware will reset (FLR) 	 * functions which have filters in the hardware filter table when the 	 * workaround is enabled/disabled. 	 * 	 * We must recheck if the workaround is enabled after inserting the 	 * first hardware filter, in case it has been changed since this check. 	 */
name|rc
operator|=
name|efx_mcdi_set_workaround
argument_list|(
name|enp
argument_list|,
name|MC_CMD_WORKAROUND_BUG26807
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_WORKAROUND_EXT_OUT_FLR_DONE_LBN
operator|)
condition|)
block|{
comment|/* 			 * Other functions had installed filters before the 			 * workaround was enabled, and they have been reset 			 * by firmware. 			 */
name|EFSYS_PROBE
argument_list|(
name|bug26807_workaround_flr_done
argument_list|)
expr_stmt|;
comment|/* FIXME: bump MC warm boot count ? */
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
block|{
comment|/* 		 * Unprivileged functions cannot enable the workaround in older 		 * firmware. 		 */
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rc
operator|==
name|ENOTSUP
operator|)
operator|||
operator|(
name|rc
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail10
goto|;
block|}
comment|/* Get sysclk frequency (in MHz). */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_clock
argument_list|(
name|enp
argument_list|,
operator|&
name|sysclk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail11
goto|;
comment|/* 	 * The timer quantum is 1536 sysclk cycles, documented for the 	 * EV_TMR_VAL field of EV_TIMER_TBL. Scale for MHz and ns units. 	 */
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|=
literal|1536000UL
operator|/
name|sysclk
expr_stmt|;
comment|/* 1536 cycles */
if|if
condition|(
name|encp
operator|->
name|enc_bug35388_workaround
condition|)
block|{
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|ERF_DD_EVQ_IND_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|FRF_CZ_TC_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
comment|/* Check capabilities of running datapath firmware */
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_get_datapath_caps
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail12
goto|;
comment|/* Alignment for receive packet DMA buffers */
name|encp
operator|->
name|enc_rx_buf_align_start
operator|=
literal|1
expr_stmt|;
name|encp
operator|->
name|enc_rx_buf_align_end
operator|=
literal|64
expr_stmt|;
comment|/* RX DMA end padding */
comment|/* Alignment for WPTR updates */
name|encp
operator|->
name|enc_rx_push_align
operator|=
name|HUNTINGTON_RX_WPTR_ALIGN
expr_stmt|;
comment|/* 	 * Set resource limits for MC_CMD_ALLOC_VIS. Note that we cannot use 	 * MC_CMD_GET_RESOURCE_LIMITS here as that reports the available 	 * resources (allocated to this PCIe function), which is zero until 	 * after we have allocated VIs. 	 */
name|encp
operator|->
name|enc_evq_limit
operator|=
literal|1024
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|EFX_RXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|EFX_TXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_buftbl_limit
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_limit
operator|=
name|HUNT_PIOBUF_NBUFS
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_size
operator|=
name|HUNT_PIOBUF_SIZE
expr_stmt|;
comment|/* 	 * Get the current privilege mask. Note that this may be modified 	 * dynamically, so this value is informational only. DO NOT use 	 * the privilege mask to check for sufficient privileges, as that 	 * can result in time-of-check/time-of-use bugs. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_privilege_mask
argument_list|(
name|enp
argument_list|,
name|pf
argument_list|,
name|vf
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|!=
name|ENOTSUP
condition|)
goto|goto
name|fail13
goto|;
comment|/* Fallback for old firmware without privilege mask support */
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
comment|/* Assume PF has admin privilege */
name|mask
operator|=
name|HUNT_LEGACY_PF_PRIVILEGE_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* VF is always unprivileged by default */
name|mask
operator|=
name|HUNT_LEGACY_VF_PRIVILEGE_MASK
expr_stmt|;
block|}
block|}
name|encp
operator|->
name|enc_privilege_mask
operator|=
name|mask
expr_stmt|;
comment|/* Get interrupt vector limits */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_vector_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|nvec
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
goto|goto
name|fail14
goto|;
comment|/* Ignore error (cannot query vector limits from a VF). */
name|base
operator|=
literal|0
expr_stmt|;
name|nvec
operator|=
literal|1024
expr_stmt|;
block|}
name|encp
operator|->
name|enc_intr_vec_base
operator|=
name|base
expr_stmt|;
name|encp
operator|->
name|enc_intr_limit
operator|=
name|nvec
expr_stmt|;
comment|/* 	 * Maximum number of bytes into the frame the TCP header can start for 	 * firmware assisted TSO to work. 	 */
name|encp
operator|->
name|enc_tx_tso_tcp_header_offset_limit
operator|=
literal|208
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail14
label|:
name|EFSYS_PROBE
argument_list|(
name|fail14
argument_list|)
expr_stmt|;
name|fail13
label|:
name|EFSYS_PROBE
argument_list|(
name|fail13
argument_list|)
expr_stmt|;
name|fail12
label|:
name|EFSYS_PROBE
argument_list|(
name|fail12
argument_list|)
expr_stmt|;
name|fail11
label|:
name|EFSYS_PROBE
argument_list|(
name|fail11
argument_list|)
expr_stmt|;
name|fail10
label|:
name|EFSYS_PROBE
argument_list|(
name|fail10
argument_list|)
expr_stmt|;
name|fail9
label|:
name|EFSYS_PROBE
argument_list|(
name|fail9
argument_list|)
expr_stmt|;
name|fail8
label|:
name|EFSYS_PROBE
argument_list|(
name|fail8
argument_list|)
expr_stmt|;
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_probe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_drv_cfg
operator|)
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
comment|/* Read and clear any assertion state */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Exit the assertion handler */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|rc
operator|!=
name|EACCES
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_drv_attach
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_board_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|rc
operator|!=
name|EACCES
condition|)
goto|goto
name|fail4
goto|;
comment|/* 	 * Set default driver config limits (based on board config). 	 * 	 * FIXME: For now allocate a fixed number of VIs which is likely to be 	 * sufficient and small enough to allow multiple functions on the same 	 * port. 	 */
name|edcp
operator|->
name|edc_min_vi_count
operator|=
name|edcp
operator|->
name|edc_max_vi_count
operator|=
name|MIN
argument_list|(
literal|128
argument_list|,
name|MAX
argument_list|(
name|encp
operator|->
name|enc_rxq_limit
argument_list|,
name|encp
operator|->
name|enc_txq_limit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The client driver must configure and enable PIO buffer support */
name|edcp
operator|->
name|edc_max_piobuf_count
operator|=
literal|0
expr_stmt|;
name|edcp
operator|->
name|edc_pio_alloc_size
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
comment|/* Wipe the MAC statistics */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_mac_stats_clear
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail5
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_loopback_modes
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MON_STATS
if|if
condition|(
operator|(
name|rc
operator|=
name|mcdi_mon_cfg_build
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Unprivileged functions do not have access to sensors */
if|if
condition|(
name|rc
operator|!=
name|EACCES
condition|)
goto|goto
name|fail7
goto|;
block|}
endif|#
directive|endif
name|encp
operator|->
name|enc_features
operator|=
name|enp
operator|->
name|en_features
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_set_drv_limits
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_drv_limits_t
modifier|*
name|edlp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_drv_cfg
operator|)
decl_stmt|;
name|uint32_t
name|min_evq_count
decl_stmt|,
name|max_evq_count
decl_stmt|;
name|uint32_t
name|min_rxq_count
decl_stmt|,
name|max_rxq_count
decl_stmt|;
name|uint32_t
name|min_txq_count
decl_stmt|,
name|max_txq_count
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|edlp
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Get minimum required and maximum usable VI limits */
name|min_evq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_min_evq_count
argument_list|,
name|encp
operator|->
name|enc_evq_limit
argument_list|)
expr_stmt|;
name|min_rxq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_min_rxq_count
argument_list|,
name|encp
operator|->
name|enc_rxq_limit
argument_list|)
expr_stmt|;
name|min_txq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_min_txq_count
argument_list|,
name|encp
operator|->
name|enc_txq_limit
argument_list|)
expr_stmt|;
name|edcp
operator|->
name|edc_min_vi_count
operator|=
name|MAX
argument_list|(
name|min_evq_count
argument_list|,
name|MAX
argument_list|(
name|min_rxq_count
argument_list|,
name|min_txq_count
argument_list|)
argument_list|)
expr_stmt|;
name|max_evq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_max_evq_count
argument_list|,
name|encp
operator|->
name|enc_evq_limit
argument_list|)
expr_stmt|;
name|max_rxq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_max_rxq_count
argument_list|,
name|encp
operator|->
name|enc_rxq_limit
argument_list|)
expr_stmt|;
name|max_txq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_max_txq_count
argument_list|,
name|encp
operator|->
name|enc_txq_limit
argument_list|)
expr_stmt|;
name|edcp
operator|->
name|edc_max_vi_count
operator|=
name|MAX
argument_list|(
name|max_evq_count
argument_list|,
name|MAX
argument_list|(
name|max_rxq_count
argument_list|,
name|max_txq_count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check limits for sub-allocated piobuf blocks. 	 * PIO is optional, so don't fail if the limits are incorrect. 	 */
if|if
condition|(
operator|(
name|encp
operator|->
name|enc_piobuf_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|encp
operator|->
name|enc_piobuf_limit
operator|==
literal|0
operator|)
operator|||
operator|(
name|edlp
operator|->
name|edl_min_pio_alloc_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|edlp
operator|->
name|edl_min_pio_alloc_size
operator|>
name|encp
operator|->
name|enc_piobuf_size
operator|)
condition|)
block|{
comment|/* Disable PIO */
name|edcp
operator|->
name|edc_max_piobuf_count
operator|=
literal|0
expr_stmt|;
name|edcp
operator|->
name|edc_pio_alloc_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|blk_size
decl_stmt|,
name|blk_count
decl_stmt|,
name|blks_per_piobuf
decl_stmt|;
name|blk_size
operator|=
name|MAX
argument_list|(
name|edlp
operator|->
name|edl_min_pio_alloc_size
argument_list|,
name|HUNT_MIN_PIO_ALLOC_SIZE
argument_list|)
expr_stmt|;
name|blks_per_piobuf
operator|=
name|encp
operator|->
name|enc_piobuf_size
operator|/
name|blk_size
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|blks_per_piobuf
argument_list|,
operator|<=
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|blk_count
operator|=
operator|(
name|encp
operator|->
name|enc_piobuf_limit
operator|*
name|blks_per_piobuf
operator|)
expr_stmt|;
comment|/* A zero max pio alloc count means unlimited */
if|if
condition|(
operator|(
name|edlp
operator|->
name|edl_max_pio_alloc_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|edlp
operator|->
name|edl_max_pio_alloc_count
operator|<
name|blk_count
operator|)
condition|)
block|{
name|blk_count
operator|=
name|edlp
operator|->
name|edl_max_pio_alloc_count
expr_stmt|;
block|}
name|edcp
operator|->
name|edc_pio_alloc_size
operator|=
name|blk_size
expr_stmt|;
name|edcp
operator|->
name|edc_max_piobuf_count
operator|=
operator|(
name|blk_count
operator|+
operator|(
name|blks_per_piobuf
operator|-
literal|1
operator|)
operator|)
operator|/
name|blks_per_piobuf
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_reset
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_ENTITY_RESET_IN_LEN
argument_list|,
name|MC_CMD_ENTITY_RESET_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* hunt_nic_reset() is called to recover from BADASSERT failures. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ENTITY_RESET
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_ENTITY_RESET_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_ENTITY_RESET_OUT_LEN
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_1
argument_list|(
name|req
argument_list|,
name|ENTITY_RESET_IN_FLAG
argument_list|,
name|ENTITY_RESET_IN_FUNCTION_RESOURCE_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
comment|/* Clear RX/TX DMA queue errors */
name|enp
operator|->
name|en_reset_flags
operator|&=
operator|~
operator|(
name|EFX_RESET_RXQ_ERR
operator||
name|EFX_RESET_TXQ_ERR
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_drv_cfg
operator|)
decl_stmt|;
name|uint32_t
name|min_vi_count
decl_stmt|,
name|max_vi_count
decl_stmt|;
name|uint32_t
name|vi_count
decl_stmt|,
name|vi_base
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|retry
decl_stmt|;
name|uint32_t
name|delay_us
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
comment|/* Enable reporting of some events (e.g. link change) */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_log_ctrl
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Allocate (optional) on-chip PIO buffers */
name|hunt_nic_alloc_piobufs
argument_list|(
name|enp
argument_list|,
name|edcp
operator|->
name|edc_max_piobuf_count
argument_list|)
expr_stmt|;
comment|/* 	 * For best performance, PIO writes should use a write-combined 	 * (WC) memory mapping. Using a separate WC mapping for the PIO 	 * aperture of each VI would be a burden to drivers (and not 	 * possible if the host page size is>4Kbyte). 	 * 	 * To avoid this we use a single uncached (UC) mapping for VI 	 * register access, and a single WC mapping for extra VIs used 	 * for PIO writes. 	 * 	 * Each piobuf must be linked to a VI in the WC mapping, and to 	 * each VI that is using a sub-allocated block from the piobuf. 	 */
name|min_vi_count
operator|=
name|edcp
operator|->
name|edc_min_vi_count
expr_stmt|;
name|max_vi_count
operator|=
name|edcp
operator|->
name|edc_max_vi_count
operator|+
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
expr_stmt|;
comment|/* Ensure that the previously attached driver's VIs are freed */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_free_vis
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Reserve VI resources (EVQ+RXQ+TXQ) for this PCIe function. If this 	 * fails then retrying the request for fewer VI resources may succeed. 	 */
name|vi_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_alloc_vis
argument_list|(
name|enp
argument_list|,
name|min_vi_count
argument_list|,
name|max_vi_count
argument_list|,
operator|&
name|vi_base
argument_list|,
operator|&
name|vi_count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|EFSYS_PROBE2
argument_list|(
name|vi_alloc
argument_list|,
name|uint32_t
argument_list|,
name|vi_base
argument_list|,
name|uint32_t
argument_list|,
name|vi_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi_count
operator|<
name|min_vi_count
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_base
operator|=
name|vi_base
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_count
operator|=
name|vi_count
expr_stmt|;
if|if
condition|(
name|vi_count
operator|<
name|min_vi_count
operator|+
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|)
block|{
comment|/* Not enough extra VIs to map piobufs */
name|hunt_nic_free_piobufs
argument_list|(
name|enp
argument_list|)
expr_stmt|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|=
name|vi_count
operator|-
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
expr_stmt|;
comment|/* Save UC memory mapping details */
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|>
literal|0
condition|)
block|{
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
operator|=
operator|(
name|ER_DZ_TX_PIOBUF_STEP
operator|*
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|)
expr_stmt|;
block|}
else|else
block|{
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
operator|=
operator|(
name|ER_DZ_TX_PIOBUF_STEP
operator|*
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_count
operator|)
expr_stmt|;
block|}
comment|/* Save WC memory mapping details */
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_offset
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_offset
operator|+
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_size
operator|=
operator|(
name|ER_DZ_TX_PIOBUF_STEP
operator|*
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|)
expr_stmt|;
comment|/* Link piobufs to extra VIs in WC mapping */
if|if
condition|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|efx_mcdi_link_piobuf
argument_list|(
name|enp
argument_list|,
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|+
name|i
argument_list|,
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 	 * Allocate a vAdaptor attached to our upstream vPort/pPort. 	 * 	 * On a VF, this may fail with MC_CMD_ERR_NO_EVB_PORT (ENOENT) if the PF 	 * driver has yet to bring up the EVB port. See bug 56147. In this case, 	 * retry the request several times after waiting a while. The wait time 	 * between retries starts small (10ms) and exponentially increases. 	 * Total wait time is a little over two seconds. Retry logic in the 	 * client driver may mean this whole loop is repeated if it continues to 	 * fail. 	 */
name|retry
operator|=
literal|0
expr_stmt|;
name|delay_us
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_vadaptor_alloc
argument_list|(
name|enp
argument_list|,
name|EVB_PORT_ID_ASSIGNED
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
operator|&
name|enp
operator|->
name|en_nic_cfg
argument_list|)
operator|||
operator|(
name|rc
operator|!=
name|ENOENT
operator|)
condition|)
block|{
comment|/* 			 * Do not retry alloc for PF, or for other errors on 			 * a VF. 			 */
goto|goto
name|fail5
goto|;
block|}
comment|/* VF startup before PF is ready. Retry allocation. */
if|if
condition|(
name|retry
operator|>
literal|5
condition|)
block|{
comment|/* Too many attempts */
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail6
goto|;
block|}
name|EFSYS_PROBE1
argument_list|(
name|mcdi_no_evb_port_retry
argument_list|,
name|int
argument_list|,
name|retry
argument_list|)
expr_stmt|;
name|EFSYS_SLEEP
argument_list|(
name|delay_us
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|delay_us
operator|<
literal|500000
condition|)
name|delay_us
operator|<<=
literal|2
expr_stmt|;
block|}
name|enp
operator|->
name|en_vport_id
operator|=
name|EVB_PORT_ID_ASSIGNED
expr_stmt|;
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_mcdi_max_payload_length
operator|=
name|MCDI_CTL_SDU_LEN_MAX_V2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|hunt_nic_free_piobufs
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_get_vi_pool
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|vi_countp
parameter_list|)
block|{
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
comment|/* 	 * Report VIs that the client driver can use. 	 * Do not include VIs used for PIO buffer writes. 	 */
operator|*
name|vi_countp
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_get_bar_region
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nic_region_t
name|region
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|offsetp
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_HUNTINGTON
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: Specify host memory mapping alignment and granularity 	 * in efx_drv_limits_t so that they can be taken into account 	 * when allocating extra VIs for PIO writes. 	 */
switch|switch
condition|(
name|region
condition|)
block|{
case|case
name|EFX_REGION_VI
case|:
comment|/* UC mapped memory BAR region for VI registers */
operator|*
name|offsetp
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_offset
expr_stmt|;
operator|*
name|sizep
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
expr_stmt|;
break|break;
case|case
name|EFX_REGION_PIO_WRITE_VI
case|:
comment|/* WC mapped memory BAR region for piobuf writes */
operator|*
name|offsetp
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_offset
expr_stmt|;
operator|*
name|sizep
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_size
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hunt_nic_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_vadaptor_free
argument_list|(
name|enp
argument_list|,
name|enp
operator|->
name|en_vport_id
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_vport_id
operator|=
literal|0
expr_stmt|;
comment|/* Unlink piobufs from extra VIs in WC mapping */
if|if
condition|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|efx_mcdi_unlink_piobuf
argument_list|(
name|enp
argument_list|,
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|hunt_nic_free_piobufs
argument_list|(
name|enp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_free_vis
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hunt_nic_unprobe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|mcdi_mon_cfg_free
argument_list|(
name|enp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MON_STATS */
operator|(
name|void
operator|)
name|efx_mcdi_drv_attach
argument_list|(
name|enp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_DIAG
end_if

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_nic_register_test
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* FIXME */
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
if|if
condition|(
name|B_FALSE
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* FIXME */
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_DIAG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON */
end_comment

end_unit

