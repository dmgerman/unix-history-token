begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2016 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MON_MCDI
end_if

begin_include
include|#
directive|include
file|"mcdi_mon.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
end_if

begin_include
include|#
directive|include
file|"ef10_tlv_layout.h"
end_include

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|hunt_nic_get_required_pcie_bandwidth
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|bandwidth_mbpsp
parameter_list|)
block|{
name|uint32_t
name|port_modes
decl_stmt|;
name|uint32_t
name|max_port_mode
decl_stmt|;
name|uint32_t
name|bandwidth
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* 	 * On Huntington, the firmware may not give us the current port mode, so 	 * we need to go by the set of available port modes and assume the most 	 * capable mode is in use. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_modes
argument_list|(
name|enp
argument_list|,
operator|&
name|port_modes
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* No port mode info available */
name|bandwidth
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|port_modes
operator|&
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_40G
operator|)
condition|)
block|{
comment|/* 		 * This needs the full PCIe bandwidth (and could use 		 * more) - roughly 64 Gbit/s for 8 lanes of Gen3. 		 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_calculate_pcie_link_bandwidth
argument_list|(
literal|8
argument_list|,
name|EFX_PCIE_LINK_SPEED_GEN3
argument_list|,
operator|&
name|bandwidth
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
if|if
condition|(
name|port_modes
operator|&
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G
operator|)
condition|)
block|{
name|max_port_mode
operator|=
name|TLV_PORT_MODE_40G
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_modes
operator|&
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_10G_10G
operator|)
condition|)
block|{
name|max_port_mode
operator|=
name|TLV_PORT_MODE_10G_10G_10G_10G
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume two 10G ports */
name|max_port_mode
operator|=
name|TLV_PORT_MODE_10G_10G
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_nic_get_port_mode_bandwidth
argument_list|(
name|max_port_mode
argument_list|,
operator|&
name|bandwidth
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
block|}
name|out
label|:
operator|*
name|bandwidth_mbpsp
operator|=
name|bandwidth
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|hunt_board_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint8_t
name|mac_addr
index|[
literal|6
index|]
decl_stmt|;
name|uint32_t
name|board_type
init|=
literal|0
decl_stmt|;
name|ef10_link_state_t
name|els
decl_stmt|;
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|uint32_t
name|port
decl_stmt|;
name|uint32_t
name|pf
decl_stmt|;
name|uint32_t
name|vf
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|sysclk
decl_stmt|,
name|dpcpu_clk
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|nvec
decl_stmt|;
name|uint32_t
name|bandwidth
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_assignment
argument_list|(
name|enp
argument_list|,
operator|&
name|port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	 * NOTE: The MCDI protocol numbers ports from zero. 	 * The common code MCDI interface numbers ports from one. 	 */
name|emip
operator|->
name|emi_port
operator|=
name|port
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_external_port_mapping
argument_list|(
name|enp
argument_list|,
name|port
argument_list|,
operator|&
name|encp
operator|->
name|enc_external_port
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Get PCIe function number from firmware (used for 	 * per-function privilege and dynamic config info). 	 *  - PCIe PF: pf = PF number, vf = 0xffff. 	 *  - PCIe VF: pf = parent PF, vf = VF number. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_function_info
argument_list|(
name|enp
argument_list|,
operator|&
name|pf
argument_list|,
operator|&
name|vf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|encp
operator|->
name|enc_pf
operator|=
name|pf
expr_stmt|;
name|encp
operator|->
name|enc_vf
operator|=
name|vf
expr_stmt|;
comment|/* MAC address for this function */
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_pf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mac_addr
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
condition|)
block|{
comment|/* 			 * If the static config does not include a global MAC 			 * address pool then the board may return a locally 			 * administered MAC address (this should only happen on 			 * incorrectly programmed boards). 			 */
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|rc
operator|=
name|efx_mcdi_get_mac_address_vf
argument_list|(
name|enp
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|encp
operator|->
name|enc_mac_addr
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* Board configuration */
name|rc
operator|=
name|efx_mcdi_get_board_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|board_type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* Unprivileged functions may not be able to read board cfg */
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
name|board_type
operator|=
literal|0
expr_stmt|;
else|else
goto|goto
name|fail5
goto|;
block|}
name|encp
operator|->
name|enc_board_type
operator|=
name|board_type
expr_stmt|;
name|encp
operator|->
name|enc_clk_mult
operator|=
literal|1
expr_stmt|;
comment|/* not used for Huntington */
comment|/* Fill out fields in enp->en_port and enp->en_nic_cfg from MCDI */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
comment|/* Obtain the default PHY advertised capabilities */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_phy_get_link
argument_list|(
name|enp
argument_list|,
operator|&
name|els
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|=
name|els
operator|.
name|els_adv_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_adv_cap_mask
operator|=
name|els
operator|.
name|els_adv_cap_mask
expr_stmt|;
comment|/* 	 * Enable firmware workarounds for hardware errata. 	 * Expected responses are: 	 *  - 0 (zero): 	 *	Success: workaround enabled or disabled as requested. 	 *  - MC_CMD_ERR_ENOSYS (reported as ENOTSUP): 	 *	Firmware does not support the MC_CMD_WORKAROUND request. 	 *	(assume that the workaround is not supported). 	 *  - MC_CMD_ERR_ENOENT (reported as ENOENT): 	 *	Firmware does not support the requested workaround. 	 *  - MC_CMD_ERR_EPERM  (reported as EACCES): 	 *	Unprivileged function cannot enable/disable workarounds. 	 * 	 * See efx_mcdi_request_errcode() for MCDI error translations. 	 */
comment|/* 	 * If the bug35388 workaround is enabled, then use an indirect access 	 * method to avoid unsafe EVQ writes. 	 */
name|rc
operator|=
name|efx_mcdi_set_workaround
argument_list|(
name|enp
argument_list|,
name|MC_CMD_WORKAROUND_BUG35388
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|||
operator|(
name|rc
operator|==
name|EACCES
operator|)
condition|)
name|encp
operator|->
name|enc_bug35388_workaround
operator|=
name|B_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rc
operator|==
name|ENOTSUP
operator|)
operator|||
operator|(
name|rc
operator|==
name|ENOENT
operator|)
condition|)
name|encp
operator|->
name|enc_bug35388_workaround
operator|=
name|B_FALSE
expr_stmt|;
else|else
goto|goto
name|fail8
goto|;
comment|/* 	 * If the bug41750 workaround is enabled, then do not test interrupts, 	 * as the test will fail (seen with Greenport controllers). 	 */
name|rc
operator|=
name|efx_mcdi_set_workaround
argument_list|(
name|enp
argument_list|,
name|MC_CMD_WORKAROUND_BUG41750
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
block|{
comment|/* Assume a controller with 40G ports needs the workaround. */
if|if
condition|(
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|&
name|EFX_PHY_CAP_40000FDX
condition|)
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rc
operator|==
name|ENOTSUP
operator|)
operator|||
operator|(
name|rc
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail9
goto|;
block|}
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_VF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
comment|/* Interrupt testing does not work for VFs. See bug50084. */
name|encp
operator|->
name|enc_bug41750_workaround
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * If the bug26807 workaround is enabled, then firmware has enabled 	 * support for chained multicast filters. Firmware will reset (FLR) 	 * functions which have filters in the hardware filter table when the 	 * workaround is enabled/disabled. 	 * 	 * We must recheck if the workaround is enabled after inserting the 	 * first hardware filter, in case it has been changed since this check. 	 */
name|rc
operator|=
name|efx_mcdi_set_workaround
argument_list|(
name|enp
argument_list|,
name|MC_CMD_WORKAROUND_BUG26807
argument_list|,
name|B_TRUE
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_WORKAROUND_EXT_OUT_FLR_DONE_LBN
operator|)
condition|)
block|{
comment|/* 			 * Other functions had installed filters before the 			 * workaround was enabled, and they have been reset 			 * by firmware. 			 */
name|EFSYS_PROBE
argument_list|(
name|bug26807_workaround_flr_done
argument_list|)
expr_stmt|;
comment|/* FIXME: bump MC warm boot count ? */
block|}
block|}
elseif|else
if|if
condition|(
name|rc
operator|==
name|EACCES
condition|)
block|{
comment|/* 		 * Unprivileged functions cannot enable the workaround in older 		 * firmware. 		 */
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rc
operator|==
name|ENOTSUP
operator|)
operator|||
operator|(
name|rc
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|encp
operator|->
name|enc_bug26807_workaround
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail10
goto|;
block|}
comment|/* Get clock frequencies (in MHz). */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_clock
argument_list|(
name|enp
argument_list|,
operator|&
name|sysclk
argument_list|,
operator|&
name|dpcpu_clk
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail11
goto|;
comment|/* 	 * The Huntington timer quantum is 1536 sysclk cycles, documented for 	 * the EV_TMR_VAL field of EV_TIMER_TBL. Scale for MHz and ns units. 	 */
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|=
literal|1536000UL
operator|/
name|sysclk
expr_stmt|;
comment|/* 1536 cycles */
if|if
condition|(
name|encp
operator|->
name|enc_bug35388_workaround
condition|)
block|{
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|ERF_DD_EVQ_IND_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|FRF_CZ_TC_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
comment|/* Check capabilities of running datapath firmware */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_get_datapath_caps
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail12
goto|;
comment|/* Alignment for receive packet DMA buffers */
name|encp
operator|->
name|enc_rx_buf_align_start
operator|=
literal|1
expr_stmt|;
name|encp
operator|->
name|enc_rx_buf_align_end
operator|=
literal|64
expr_stmt|;
comment|/* RX DMA end padding */
comment|/* Alignment for WPTR updates */
name|encp
operator|->
name|enc_rx_push_align
operator|=
name|EF10_RX_WPTR_ALIGN
expr_stmt|;
comment|/* 	 * Set resource limits for MC_CMD_ALLOC_VIS. Note that we cannot use 	 * MC_CMD_GET_RESOURCE_LIMITS here as that reports the available 	 * resources (allocated to this PCIe function), which is zero until 	 * after we have allocated VIs. 	 */
name|encp
operator|->
name|enc_evq_limit
operator|=
literal|1024
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|EFX_RXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|EFX_TXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_buftbl_limit
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_limit
operator|=
name|HUNT_PIOBUF_NBUFS
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_size
operator|=
name|HUNT_PIOBUF_SIZE
expr_stmt|;
name|encp
operator|->
name|enc_piobuf_min_alloc_size
operator|=
name|HUNT_MIN_PIO_ALLOC_SIZE
expr_stmt|;
comment|/* 	 * Get the current privilege mask. Note that this may be modified 	 * dynamically, so this value is informational only. DO NOT use 	 * the privilege mask to check for sufficient privileges, as that 	 * can result in time-of-check/time-of-use bugs. 	 */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_get_privilege_mask
argument_list|(
name|enp
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail13
goto|;
name|encp
operator|->
name|enc_privilege_mask
operator|=
name|mask
expr_stmt|;
comment|/* Get interrupt vector limits */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_vector_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|base
argument_list|,
operator|&
name|nvec
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
goto|goto
name|fail14
goto|;
comment|/* Ignore error (cannot query vector limits from a VF). */
name|base
operator|=
literal|0
expr_stmt|;
name|nvec
operator|=
literal|1024
expr_stmt|;
block|}
name|encp
operator|->
name|enc_intr_vec_base
operator|=
name|base
expr_stmt|;
name|encp
operator|->
name|enc_intr_limit
operator|=
name|nvec
expr_stmt|;
comment|/* 	 * Maximum number of bytes into the frame the TCP header can start for 	 * firmware assisted TSO to work. 	 */
name|encp
operator|->
name|enc_tx_tso_tcp_header_offset_limit
operator|=
name|EF10_TCP_HEADER_OFFSET_LIMIT
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|hunt_nic_get_required_pcie_bandwidth
argument_list|(
name|enp
argument_list|,
operator|&
name|bandwidth
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail15
goto|;
name|encp
operator|->
name|enc_required_pcie_bandwidth_mbps
operator|=
name|bandwidth
expr_stmt|;
comment|/* All Huntington devices have a PCIe Gen3, 8 lane connector */
name|encp
operator|->
name|enc_max_pcie_link_gen
operator|=
name|EFX_PCIE_LINK_SPEED_GEN3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail15
label|:
name|EFSYS_PROBE
argument_list|(
name|fail15
argument_list|)
expr_stmt|;
name|fail14
label|:
name|EFSYS_PROBE
argument_list|(
name|fail14
argument_list|)
expr_stmt|;
name|fail13
label|:
name|EFSYS_PROBE
argument_list|(
name|fail13
argument_list|)
expr_stmt|;
name|fail12
label|:
name|EFSYS_PROBE
argument_list|(
name|fail12
argument_list|)
expr_stmt|;
name|fail11
label|:
name|EFSYS_PROBE
argument_list|(
name|fail11
argument_list|)
expr_stmt|;
name|fail10
label|:
name|EFSYS_PROBE
argument_list|(
name|fail10
argument_list|)
expr_stmt|;
name|fail9
label|:
name|EFSYS_PROBE
argument_list|(
name|fail9
argument_list|)
expr_stmt|;
name|fail8
label|:
name|EFSYS_PROBE
argument_list|(
name|fail8
argument_list|)
expr_stmt|;
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON */
end_comment

end_unit

