begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2016 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MON_MCDI
end_if

begin_include
include|#
directive|include
file|"mcdi_mon.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_include
include|#
directive|include
file|"ef10_tlv_layout.h"
end_include

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_port_assignment
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|portp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PORT_ASSIGNMENT_IN_LEN
argument_list|,
name|MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PORT_ASSIGNMENT
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PORT_ASSIGNMENT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|portp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PORT_ASSIGNMENT_OUT_PORT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_port_modes
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|modesp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|current_modep
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PORT_MODES_IN_LEN
argument_list|,
name|MC_CMD_GET_PORT_MODES_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PORT_MODES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PORT_MODES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PORT_MODES_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* 	 * Require only Modes and DefaultMode fields, unless the current mode 	 * was requested (CurrentMode field was added for Medford). 	 */
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PORT_MODES_OUT_CURRENT_MODE_OFST
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
operator|(
name|current_modep
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PORT_MODES_OUT_CURRENT_MODE_OFST
operator|+
literal|4
operator|)
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
operator|*
name|modesp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PORT_MODES_OUT_MODES
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_modep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|current_modep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PORT_MODES_OUT_CURRENT_MODE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_get_port_mode_bandwidth
parameter_list|(
name|__in
name|uint32_t
name|port_mode
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|bandwidth_mbpsp
parameter_list|)
block|{
name|uint32_t
name|bandwidth
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
switch|switch
condition|(
name|port_mode
condition|)
block|{
case|case
name|TLV_PORT_MODE_10G
case|:
name|bandwidth
operator|=
literal|10000
expr_stmt|;
break|break;
case|case
name|TLV_PORT_MODE_10G_10G
case|:
name|bandwidth
operator|=
literal|10000
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|TLV_PORT_MODE_10G_10G_10G_10G
case|:
case|case
name|TLV_PORT_MODE_10G_10G_10G_10G_Q
case|:
case|case
name|TLV_PORT_MODE_10G_10G_10G_10G_Q2
case|:
name|bandwidth
operator|=
literal|10000
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|TLV_PORT_MODE_40G
case|:
name|bandwidth
operator|=
literal|40000
expr_stmt|;
break|break;
case|case
name|TLV_PORT_MODE_40G_40G
case|:
name|bandwidth
operator|=
literal|40000
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|TLV_PORT_MODE_40G_10G_10G
case|:
case|case
name|TLV_PORT_MODE_10G_10G_40G
case|:
name|bandwidth
operator|=
literal|40000
operator|+
operator|(
literal|10000
operator|*
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|*
name|bandwidth_mbpsp
operator|=
name|bandwidth
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_vadaptor_alloc
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|port_id
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_VADAPTOR_ALLOC_IN_LEN
argument_list|,
name|MC_CMD_VADAPTOR_ALLOC_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_vport_id
argument_list|,
operator|==
argument_list|,
name|EVB_PORT_ID_NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_VADAPTOR_ALLOC
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_VADAPTOR_ALLOC_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_VADAPTOR_ALLOC_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|VADAPTOR_ALLOC_IN_UPSTREAM_PORT_ID
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_1
argument_list|(
name|req
argument_list|,
name|VADAPTOR_ALLOC_IN_FLAGS
argument_list|,
name|VADAPTOR_ALLOC_IN_FLAG_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED
argument_list|,
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_allow_set_mac_with_installed_filters
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_vadaptor_free
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|port_id
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_VADAPTOR_FREE_IN_LEN
argument_list|,
name|MC_CMD_VADAPTOR_FREE_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_VADAPTOR_FREE
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_VADAPTOR_FREE_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_VADAPTOR_FREE_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|VADAPTOR_FREE_IN_UPSTREAM_PORT_ID
argument_list|,
name|port_id
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_mac_address_pf
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|6
argument_list|)
name|uint8_t
name|mac_addrp
index|[
literal|6
index|]
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_MAC_ADDRESSES_IN_LEN
argument_list|,
name|MC_CMD_GET_MAC_ADDRESSES_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_MAC_ADDRESSES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_MAC_ADDRESSES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_MAC_ADDRESSES_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_MAC_ADDRESSES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_MAC_ADDRESSES_OUT_MAC_COUNT
argument_list|)
operator|<
literal|1
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|mac_addrp
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|addrp
decl_stmt|;
name|addrp
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_MAC_ADDRESSES_OUT_MAC_ADDR_BASE
argument_list|)
expr_stmt|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|mac_addrp
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_mac_address_vf
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|6
argument_list|)
name|uint8_t
name|mac_addrp
index|[
literal|6
index|]
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_IN_LEN
argument_list|,
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMAX
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_VPORT_GET_MAC_ADDRESSES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMAX
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|VPORT_GET_MAC_ADDRESSES_IN_VPORT_ID
argument_list|,
name|EVB_PORT_ID_ASSIGNED
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_VPORT_GET_MAC_ADDRESSES_OUT_LENMIN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|VPORT_GET_MAC_ADDRESSES_OUT_MACADDR_COUNT
argument_list|)
operator|<
literal|1
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|mac_addrp
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|addrp
decl_stmt|;
name|addrp
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|VPORT_GET_MAC_ADDRESSES_OUT_MACADDR
argument_list|)
expr_stmt|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|mac_addrp
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_clock
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|sys_freqp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|dpcpu_freqp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_CLOCK_IN_LEN
argument_list|,
name|MC_CMD_GET_CLOCK_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_CLOCK
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_CLOCK_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_CLOCK_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_CLOCK_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|sys_freqp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_CLOCK_OUT_SYS_FREQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sys_freqp
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
operator|*
name|dpcpu_freqp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_CLOCK_OUT_DPCPU_FREQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dpcpu_freqp
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_vector_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|vec_basep
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|pf_nvecp
parameter_list|,
name|__out_opt
name|uint32_t
modifier|*
name|vf_nvecp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_VECTOR_CFG_IN_LEN
argument_list|,
name|MC_CMD_GET_VECTOR_CFG_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_VECTOR_CFG
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_VECTOR_CFG_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_VECTOR_CFG_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_VECTOR_CFG_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|vec_basep
operator|!=
name|NULL
condition|)
operator|*
name|vec_basep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VECTOR_CFG_OUT_VEC_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf_nvecp
operator|!=
name|NULL
condition|)
operator|*
name|pf_nvecp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VECTOR_CFG_OUT_VECS_PER_PF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf_nvecp
operator|!=
name|NULL
condition|)
operator|*
name|vf_nvecp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VECTOR_CFG_OUT_VECS_PER_VF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_get_capabilities
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|flagsp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|flags2p
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_CAPABILITIES_IN_LEN
argument_list|,
name|MC_CMD_GET_CAPABILITIES_V2_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_CAPABILITIES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_CAPABILITIES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_CAPABILITIES_V2_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_CAPABILITIES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|flagsp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_CAPABILITIES_OUT_FLAGS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_CAPABILITIES_V2_OUT_LEN
condition|)
operator|*
name|flags2p
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|flags2p
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_CAPABILITIES_V2_OUT_FLAGS2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_alloc_vis
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|min_vi_count
parameter_list|,
name|__in
name|uint32_t
name|max_vi_count
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|vi_basep
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|vi_countp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|vi_shiftp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_ALLOC_VIS_IN_LEN
argument_list|,
name|MC_CMD_ALLOC_VIS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|vi_countp
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ALLOC_VIS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_ALLOC_VIS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_ALLOC_VIS_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_IN_MIN_VI_COUNT
argument_list|,
name|min_vi_count
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_IN_MAX_VI_COUNT
argument_list|,
name|max_vi_count
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_ALLOC_VIS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
operator|*
name|vi_basep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_OUT_VI_BASE
argument_list|)
expr_stmt|;
operator|*
name|vi_countp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_OUT_VI_COUNT
argument_list|)
expr_stmt|;
comment|/* Report VI_SHIFT if available (always zero for Huntington) */
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_ALLOC_VIS_EXT_OUT_LEN
condition|)
operator|*
name|vi_shiftp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|vi_shiftp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_VIS_EXT_OUT_VI_SHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_free_vis
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_FREE_VIS_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_FREE_VIS_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FREE_VIS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
comment|/* Ignore ELREADY (no allocated VIs, so nothing to free) */
if|if
condition|(
operator|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|req
operator|.
name|emr_rc
operator|!=
name|EALREADY
operator|)
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_alloc_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|efx_piobuf_handle_t
modifier|*
name|handlep
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_ALLOC_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_ALLOC_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|handlep
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ALLOC_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_ALLOC_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_ALLOC_PIOBUF_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_ALLOC_PIOBUF_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
operator|*
name|handlep
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|ALLOC_PIOBUF_OUT_PIOBUF_HANDLE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_free_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_piobuf_handle_t
name|handle
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_FREE_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_FREE_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_FREE_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_FREE_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_FREE_PIOBUF_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|FREE_PIOBUF_IN_PIOBUF_HANDLE
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_link_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|,
name|__in
name|efx_piobuf_handle_t
name|handle
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_LINK_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_LINK_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_LINK_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_LINK_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_LINK_PIOBUF_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LINK_PIOBUF_IN_PIOBUF_HANDLE
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LINK_PIOBUF_IN_TXQ_INSTANCE
argument_list|,
name|vi_index
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_unlink_piobuf
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_UNLINK_PIOBUF_IN_LEN
argument_list|,
name|MC_CMD_UNLINK_PIOBUF_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_UNLINK_PIOBUF
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_UNLINK_PIOBUF_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_UNLINK_PIOBUF_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|UNLINK_PIOBUF_IN_TXQ_INSTANCE
argument_list|,
name|vi_index
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_nic_alloc_piobufs
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|max_piobuf_count
parameter_list|)
block|{
name|efx_piobuf_handle_t
modifier|*
name|handlep
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|max_piobuf_count
argument_list|,
operator|<=
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
argument_list|)
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|handlep
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_alloc_piobuf
argument_list|(
name|enp
argument_list|,
name|handlep
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_alloc_map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|++
expr_stmt|;
block|}
return|return;
name|fail1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|handlep
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
expr_stmt|;
name|efx_mcdi_free_piobuf
argument_list|(
name|enp
argument_list|,
operator|*
name|handlep
argument_list|)
expr_stmt|;
operator|*
name|handlep
operator|=
name|EFX_PIOBUF_HANDLE_INVALID
expr_stmt|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ef10_nic_free_piobufs
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_piobuf_handle_t
modifier|*
name|handlep
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|handlep
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
expr_stmt|;
name|efx_mcdi_free_piobuf
argument_list|(
name|enp
argument_list|,
operator|*
name|handlep
argument_list|)
expr_stmt|;
operator|*
name|handlep
operator|=
name|EFX_PIOBUF_HANDLE_INVALID
expr_stmt|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sub-allocate a block from a piobuf */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_pio_alloc
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|bufnump
parameter_list|,
name|__out
name|efx_piobuf_handle_t
modifier|*
name|handlep
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|blknump
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|offsetp
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
name|enp
operator|->
name|en_nic_cfg
decl_stmt|;
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
name|enp
operator|->
name|en_drv_cfg
decl_stmt|;
name|uint32_t
name|blk_per_buf
decl_stmt|;
name|uint32_t
name|buf
decl_stmt|,
name|blk
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|bufnump
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|handlep
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|blknump
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|offsetp
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|sizep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|edcp
operator|->
name|edc_pio_alloc_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|==
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|blk_per_buf
operator|=
name|encp
operator|->
name|enc_piobuf_size
operator|/
name|edcp
operator|->
name|edc_pio_alloc_size
expr_stmt|;
for|for
control|(
name|buf
operator|=
literal|0
init|;
name|buf
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|buf
operator|++
control|)
block|{
name|uint32_t
modifier|*
name|map
init|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_alloc_map
index|[
name|buf
index|]
decl_stmt|;
if|if
condition|(
operator|~
operator|(
operator|*
name|map
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|EFSYS_ASSERT3U
argument_list|(
name|blk_per_buf
argument_list|,
operator|<=
argument_list|,
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
literal|0
init|;
name|blk
operator|<
name|blk_per_buf
condition|;
name|blk
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|map
operator|&
operator|(
literal|1u
operator|<<
name|blk
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|map
operator||=
operator|(
literal|1u
operator|<<
name|blk
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail2
goto|;
name|done
label|:
operator|*
name|handlep
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|buf
index|]
expr_stmt|;
operator|*
name|bufnump
operator|=
name|buf
expr_stmt|;
operator|*
name|blknump
operator|=
name|blk
expr_stmt|;
operator|*
name|sizep
operator|=
name|edcp
operator|->
name|edc_pio_alloc_size
expr_stmt|;
operator|*
name|offsetp
operator|=
name|blk
operator|*
operator|(
operator|*
name|sizep
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a piobuf sub-allocated block */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_pio_free
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|bufnum
parameter_list|,
name|__in
name|uint32_t
name|blknum
parameter_list|)
block|{
name|uint32_t
modifier|*
name|map
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|bufnum
operator|>=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|)
operator|||
operator|(
name|blknum
operator|>=
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|map
operator|=
operator|&
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_alloc_map
index|[
name|bufnum
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|map
operator|&
operator|(
literal|1u
operator|<<
name|blknum
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|map
operator|&=
operator|~
operator|(
literal|1u
operator|<<
name|blknum
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_pio_link
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|,
name|__in
name|efx_piobuf_handle_t
name|handle
parameter_list|)
block|{
return|return
operator|(
name|efx_mcdi_link_piobuf
argument_list|(
name|enp
argument_list|,
name|vi_index
argument_list|,
name|handle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_pio_unlink
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|vi_index
parameter_list|)
block|{
return|return
operator|(
name|efx_mcdi_unlink_piobuf
argument_list|(
name|enp
argument_list|,
name|vi_index
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_get_datapath_caps
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|flags2
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_capabilities
argument_list|(
name|enp
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|flags2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
define|#
directive|define
name|CAP_FLAG
parameter_list|(
name|flags1
parameter_list|,
name|field
parameter_list|)
define|\
value|((flags1)& (1<< (MC_CMD_GET_CAPABILITIES_V2_OUT_ ## field ## _LBN)))
define|#
directive|define
name|CAP_FLAG2
parameter_list|(
name|flags2
parameter_list|,
name|field
parameter_list|)
define|\
value|((flags2)& (1<< (MC_CMD_GET_CAPABILITIES_V2_OUT_ ## field ## _LBN)))
comment|/* 	 * Huntington RXDP firmware inserts a 0 or 14 byte prefix. 	 * We only support the 14 byte prefix here. 	 */
if|if
condition|(
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|RX_PREFIX_LEN_14
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|encp
operator|->
name|enc_rx_prefix_size
operator|=
literal|14
expr_stmt|;
comment|/* Check if the firmware supports TSO */
name|encp
operator|->
name|enc_fw_assisted_tso_enabled
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|TX_TSO
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware supports FATSOv2 */
name|encp
operator|->
name|enc_fw_assisted_tso_v2_enabled
operator|=
name|CAP_FLAG2
argument_list|(
name|flags2
argument_list|,
name|TX_TSO_V2
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware has vadapter/vport/vswitch support */
name|encp
operator|->
name|enc_datapath_cap_evb
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|EVB
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware supports VLAN insertion */
name|encp
operator|->
name|enc_hw_tx_insert_vlan_enabled
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|TX_VLAN_INSERTION
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware supports RX event batching */
name|encp
operator|->
name|enc_rx_batching_enabled
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|RX_BATCHING
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|encp
operator|->
name|enc_rx_batching_enabled
condition|)
name|encp
operator|->
name|enc_rx_batch_max
operator|=
literal|16
expr_stmt|;
comment|/* Check if the firmware supports disabling scatter on RXQs */
name|encp
operator|->
name|enc_rx_disable_scatter_supported
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|RX_DISABLE_SCATTER
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* Check if the firmware supports set mac with running filters */
name|encp
operator|->
name|enc_allow_set_mac_with_installed_filters
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|VADAPTOR_PERMIT_SET_MAC_WHEN_FILTERS_INSTALLED
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* 	 * Check if firmware supports the extended MC_CMD_SET_MAC, which allows 	 * specifying which parameters to configure. 	 */
name|encp
operator|->
name|enc_enhanced_set_mac_supported
operator|=
name|CAP_FLAG
argument_list|(
name|flags
argument_list|,
name|SET_MAC_ENHANCED
argument_list|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
undef|#
directive|undef
name|CAP_FLAG
undef|#
directive|undef
name|CAP_FLAG2
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EF10_LEGACY_PF_PRIVILEGE_MASK
define|\
value|(MC_CMD_PRIVILEGE_MASK_IN_GRP_ADMIN			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_LINK			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_ONLOAD			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_PTP			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_INSECURE_FILTERS		|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_MAC_SPOOFING		|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_UNICAST			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_MULTICAST			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_BROADCAST			|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_ALL_MULTICAST		|	\ 	MC_CMD_PRIVILEGE_MASK_IN_GRP_PROMISCUOUS)
end_define

begin_define
define|#
directive|define
name|EF10_LEGACY_VF_PRIVILEGE_MASK
value|0
end_define

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_get_privilege_mask
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|maskp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_privilege_mask
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_pf
argument_list|,
name|encp
operator|->
name|enc_vf
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|!=
name|ENOTSUP
condition|)
goto|goto
name|fail1
goto|;
comment|/* Fallback for old firmware without privilege mask support */
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
name|encp
argument_list|)
condition|)
block|{
comment|/* Assume PF has admin privilege */
name|mask
operator|=
name|EF10_LEGACY_PF_PRIVILEGE_MASK
expr_stmt|;
block|}
else|else
block|{
comment|/* VF is always unprivileged by default */
name|mask
operator|=
name|EF10_LEGACY_VF_PRIVILEGE_MASK
expr_stmt|;
block|}
block|}
operator|*
name|maskp
operator|=
name|mask
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The external port mapping is a one-based numbering of the external  * connectors on the board. It does not distinguish off-board separated  * outputs such as multi-headed cables.  * The number of ports that map to each external port connector  * on the board is determined by the chip family and the port modes to  * which the NIC can be configured. The mapping table lists modes with  * port numbering requirements in increasing order.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|efx_family_t
name|family
decl_stmt|;
name|uint32_t
name|modes_mask
decl_stmt|;
name|uint32_t
name|stride
decl_stmt|;
block|}
name|__ef10_external_port_mappings
index|[]
init|=
block|{
comment|/* Supported modes requiring 1 output per port */
block|{
name|EFX_FAMILY_HUNTINGTON
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_10G_10G
operator|)
block|,
literal|1
block|}
block|,
block|{
name|EFX_FAMILY_MEDFORD
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_10G_10G
operator|)
block|,
literal|1
block|}
block|,
comment|/* Supported modes requiring 2 outputs per port */
block|{
name|EFX_FAMILY_HUNTINGTON
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_40G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_10G_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_40G
operator|)
block|,
literal|2
block|}
block|,
block|{
name|EFX_FAMILY_MEDFORD
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_40G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_40G_10G_10G
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_40G
operator|)
block|,
literal|2
block|}
block|,
comment|/* Supported modes requiring 4 outputs per port */
block|{
name|EFX_FAMILY_MEDFORD
block|,
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_10G_10G_Q
operator|)
operator||
operator|(
literal|1
operator|<<
name|TLV_PORT_MODE_10G_10G_10G_10G_Q2
operator|)
block|,
literal|4
block|}
block|, }
struct|;
end_struct

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_external_port_mapping
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|port
parameter_list|,
name|__out
name|uint8_t
modifier|*
name|external_portp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|port_modes
decl_stmt|;
name|uint32_t
name|matches
decl_stmt|;
name|uint32_t
name|stride
init|=
literal|1
decl_stmt|;
comment|/* default 1-1 mapping */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_port_modes
argument_list|(
name|enp
argument_list|,
operator|&
name|port_modes
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* No port mode information available - use default mapping */
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Infer the internal port -> external port mapping from 	 * the possible port modes for this NIC. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EFX_ARRAY_SIZE
argument_list|(
name|__ef10_external_port_mappings
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|__ef10_external_port_mappings
index|[
name|i
index|]
operator|.
name|family
operator|!=
name|enp
operator|->
name|en_family
condition|)
continue|continue;
name|matches
operator|=
operator|(
name|__ef10_external_port_mappings
index|[
name|i
index|]
operator|.
name|modes_mask
operator|&
name|port_modes
operator|)
expr_stmt|;
if|if
condition|(
name|matches
operator|!=
literal|0
condition|)
block|{
name|stride
operator|=
name|__ef10_external_port_mappings
index|[
name|i
index|]
operator|.
name|stride
expr_stmt|;
name|port_modes
operator|&=
operator|~
name|matches
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port_modes
operator|!=
literal|0
condition|)
block|{
comment|/* Some advertised modes are not supported */
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|out
label|:
comment|/* 	 * Scale as required by last matched mode and then convert to 	 * one-based numbering 	 */
operator|*
name|external_portp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|port
operator|/
name|stride
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_probe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
specifier|const
name|efx_nic_ops_t
modifier|*
name|enop
init|=
name|enp
operator|->
name|en_enop
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_drv_cfg
operator|)
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
comment|/* Read and clear any assertion state */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Exit the assertion handler */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|rc
operator|!=
name|EACCES
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_drv_attach
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|enop
operator|->
name|eno_board_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|rc
operator|!=
name|EACCES
condition|)
goto|goto
name|fail4
goto|;
comment|/* 	 * Set default driver config limits (based on board config). 	 * 	 * FIXME: For now allocate a fixed number of VIs which is likely to be 	 * sufficient and small enough to allow multiple functions on the same 	 * port. 	 */
name|edcp
operator|->
name|edc_min_vi_count
operator|=
name|edcp
operator|->
name|edc_max_vi_count
operator|=
name|MIN
argument_list|(
literal|128
argument_list|,
name|MAX
argument_list|(
name|encp
operator|->
name|enc_rxq_limit
argument_list|,
name|encp
operator|->
name|enc_txq_limit
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The client driver must configure and enable PIO buffer support */
name|edcp
operator|->
name|edc_max_piobuf_count
operator|=
literal|0
expr_stmt|;
name|edcp
operator|->
name|edc_pio_alloc_size
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
comment|/* Wipe the MAC statistics */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_mac_stats_clear
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail5
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_loopback_modes
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MON_STATS
if|if
condition|(
operator|(
name|rc
operator|=
name|mcdi_mon_cfg_build
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Unprivileged functions do not have access to sensors */
if|if
condition|(
name|rc
operator|!=
name|EACCES
condition|)
goto|goto
name|fail7
goto|;
block|}
endif|#
directive|endif
name|encp
operator|->
name|enc_features
operator|=
name|enp
operator|->
name|en_features
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_set_drv_limits
parameter_list|(
name|__inout
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_drv_limits_t
modifier|*
name|edlp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_drv_cfg
operator|)
decl_stmt|;
name|uint32_t
name|min_evq_count
decl_stmt|,
name|max_evq_count
decl_stmt|;
name|uint32_t
name|min_rxq_count
decl_stmt|,
name|max_rxq_count
decl_stmt|;
name|uint32_t
name|min_txq_count
decl_stmt|,
name|max_txq_count
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
name|edlp
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Get minimum required and maximum usable VI limits */
name|min_evq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_min_evq_count
argument_list|,
name|encp
operator|->
name|enc_evq_limit
argument_list|)
expr_stmt|;
name|min_rxq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_min_rxq_count
argument_list|,
name|encp
operator|->
name|enc_rxq_limit
argument_list|)
expr_stmt|;
name|min_txq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_min_txq_count
argument_list|,
name|encp
operator|->
name|enc_txq_limit
argument_list|)
expr_stmt|;
name|edcp
operator|->
name|edc_min_vi_count
operator|=
name|MAX
argument_list|(
name|min_evq_count
argument_list|,
name|MAX
argument_list|(
name|min_rxq_count
argument_list|,
name|min_txq_count
argument_list|)
argument_list|)
expr_stmt|;
name|max_evq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_max_evq_count
argument_list|,
name|encp
operator|->
name|enc_evq_limit
argument_list|)
expr_stmt|;
name|max_rxq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_max_rxq_count
argument_list|,
name|encp
operator|->
name|enc_rxq_limit
argument_list|)
expr_stmt|;
name|max_txq_count
operator|=
name|MIN
argument_list|(
name|edlp
operator|->
name|edl_max_txq_count
argument_list|,
name|encp
operator|->
name|enc_txq_limit
argument_list|)
expr_stmt|;
name|edcp
operator|->
name|edc_max_vi_count
operator|=
name|MAX
argument_list|(
name|max_evq_count
argument_list|,
name|MAX
argument_list|(
name|max_rxq_count
argument_list|,
name|max_txq_count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check limits for sub-allocated piobuf blocks. 	 * PIO is optional, so don't fail if the limits are incorrect. 	 */
if|if
condition|(
operator|(
name|encp
operator|->
name|enc_piobuf_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|encp
operator|->
name|enc_piobuf_limit
operator|==
literal|0
operator|)
operator|||
operator|(
name|edlp
operator|->
name|edl_min_pio_alloc_size
operator|==
literal|0
operator|)
operator|||
operator|(
name|edlp
operator|->
name|edl_min_pio_alloc_size
operator|>
name|encp
operator|->
name|enc_piobuf_size
operator|)
condition|)
block|{
comment|/* Disable PIO */
name|edcp
operator|->
name|edc_max_piobuf_count
operator|=
literal|0
expr_stmt|;
name|edcp
operator|->
name|edc_pio_alloc_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|blk_size
decl_stmt|,
name|blk_count
decl_stmt|,
name|blks_per_piobuf
decl_stmt|;
name|blk_size
operator|=
name|MAX
argument_list|(
name|edlp
operator|->
name|edl_min_pio_alloc_size
argument_list|,
name|encp
operator|->
name|enc_piobuf_min_alloc_size
argument_list|)
expr_stmt|;
name|blks_per_piobuf
operator|=
name|encp
operator|->
name|enc_piobuf_size
operator|/
name|blk_size
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|blks_per_piobuf
argument_list|,
operator|<=
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|blk_count
operator|=
operator|(
name|encp
operator|->
name|enc_piobuf_limit
operator|*
name|blks_per_piobuf
operator|)
expr_stmt|;
comment|/* A zero max pio alloc count means unlimited */
if|if
condition|(
operator|(
name|edlp
operator|->
name|edl_max_pio_alloc_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|edlp
operator|->
name|edl_max_pio_alloc_count
operator|<
name|blk_count
operator|)
condition|)
block|{
name|blk_count
operator|=
name|edlp
operator|->
name|edl_max_pio_alloc_count
expr_stmt|;
block|}
name|edcp
operator|->
name|edc_pio_alloc_size
operator|=
name|blk_size
expr_stmt|;
name|edcp
operator|->
name|edc_max_piobuf_count
operator|=
operator|(
name|blk_count
operator|+
operator|(
name|blks_per_piobuf
operator|-
literal|1
operator|)
operator|)
operator|/
name|blks_per_piobuf
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_reset
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_ENTITY_RESET_IN_LEN
argument_list|,
name|MC_CMD_ENTITY_RESET_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* ef10_nic_reset() is called to recover from BADASSERT failures. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ENTITY_RESET
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_ENTITY_RESET_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_ENTITY_RESET_OUT_LEN
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_1
argument_list|(
name|req
argument_list|,
name|ENTITY_RESET_IN_FLAG
argument_list|,
name|ENTITY_RESET_IN_FUNCTION_RESOURCE_RESET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
comment|/* Clear RX/TX DMA queue errors */
name|enp
operator|->
name|en_reset_flags
operator|&=
operator|~
operator|(
name|EFX_RESET_RXQ_ERR
operator||
name|EFX_RESET_TXQ_ERR
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_drv_cfg_t
modifier|*
name|edcp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_drv_cfg
operator|)
decl_stmt|;
name|uint32_t
name|min_vi_count
decl_stmt|,
name|max_vi_count
decl_stmt|;
name|uint32_t
name|vi_count
decl_stmt|,
name|vi_base
decl_stmt|,
name|vi_shift
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|retry
decl_stmt|;
name|uint32_t
name|delay_us
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
comment|/* Enable reporting of some events (e.g. link change) */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_log_ctrl
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Allocate (optional) on-chip PIO buffers */
name|ef10_nic_alloc_piobufs
argument_list|(
name|enp
argument_list|,
name|edcp
operator|->
name|edc_max_piobuf_count
argument_list|)
expr_stmt|;
comment|/* 	 * For best performance, PIO writes should use a write-combined 	 * (WC) memory mapping. Using a separate WC mapping for the PIO 	 * aperture of each VI would be a burden to drivers (and not 	 * possible if the host page size is>4Kbyte). 	 * 	 * To avoid this we use a single uncached (UC) mapping for VI 	 * register access, and a single WC mapping for extra VIs used 	 * for PIO writes. 	 * 	 * Each piobuf must be linked to a VI in the WC mapping, and to 	 * each VI that is using a sub-allocated block from the piobuf. 	 */
name|min_vi_count
operator|=
name|edcp
operator|->
name|edc_min_vi_count
expr_stmt|;
name|max_vi_count
operator|=
name|edcp
operator|->
name|edc_max_vi_count
operator|+
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
expr_stmt|;
comment|/* Ensure that the previously attached driver's VIs are freed */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_free_vis
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Reserve VI resources (EVQ+RXQ+TXQ) for this PCIe function. If this 	 * fails then retrying the request for fewer VI resources may succeed. 	 */
name|vi_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_alloc_vis
argument_list|(
name|enp
argument_list|,
name|min_vi_count
argument_list|,
name|max_vi_count
argument_list|,
operator|&
name|vi_base
argument_list|,
operator|&
name|vi_count
argument_list|,
operator|&
name|vi_shift
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
name|EFSYS_PROBE2
argument_list|(
name|vi_alloc
argument_list|,
name|uint32_t
argument_list|,
name|vi_base
argument_list|,
name|uint32_t
argument_list|,
name|vi_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi_count
operator|<
name|min_vi_count
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_base
operator|=
name|vi_base
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_count
operator|=
name|vi_count
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_shift
operator|=
name|vi_shift
expr_stmt|;
if|if
condition|(
name|vi_count
operator|<
name|min_vi_count
operator|+
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|)
block|{
comment|/* Not enough extra VIs to map piobufs */
name|ef10_nic_free_piobufs
argument_list|(
name|enp
argument_list|)
expr_stmt|;
block|}
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|=
name|vi_count
operator|-
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
expr_stmt|;
comment|/* Save UC memory mapping details */
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|>
literal|0
condition|)
block|{
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
operator|=
operator|(
name|ER_DZ_TX_PIOBUF_STEP
operator|*
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|)
expr_stmt|;
block|}
else|else
block|{
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
operator|=
operator|(
name|ER_DZ_TX_PIOBUF_STEP
operator|*
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_count
operator|)
expr_stmt|;
block|}
comment|/* Save WC memory mapping details */
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_offset
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_offset
operator|+
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_size
operator|=
operator|(
name|ER_DZ_TX_PIOBUF_STEP
operator|*
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|)
expr_stmt|;
comment|/* Link piobufs to extra VIs in WC mapping */
if|if
condition|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|efx_mcdi_link_piobuf
argument_list|(
name|enp
argument_list|,
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|+
name|i
argument_list|,
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_handle
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 	 * Allocate a vAdaptor attached to our upstream vPort/pPort. 	 * 	 * On a VF, this may fail with MC_CMD_ERR_NO_EVB_PORT (ENOENT) if the PF 	 * driver has yet to bring up the EVB port. See bug 56147. In this case, 	 * retry the request several times after waiting a while. The wait time 	 * between retries starts small (10ms) and exponentially increases. 	 * Total wait time is a little over two seconds. Retry logic in the 	 * client driver may mean this whole loop is repeated if it continues to 	 * fail. 	 */
name|retry
operator|=
literal|0
expr_stmt|;
name|delay_us
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_vadaptor_alloc
argument_list|(
name|enp
argument_list|,
name|EVB_PORT_ID_ASSIGNED
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|EFX_PCI_FUNCTION_IS_PF
argument_list|(
operator|&
name|enp
operator|->
name|en_nic_cfg
argument_list|)
operator|||
operator|(
name|rc
operator|!=
name|ENOENT
operator|)
condition|)
block|{
comment|/* 			 * Do not retry alloc for PF, or for other errors on 			 * a VF. 			 */
goto|goto
name|fail5
goto|;
block|}
comment|/* VF startup before PF is ready. Retry allocation. */
if|if
condition|(
name|retry
operator|>
literal|5
condition|)
block|{
comment|/* Too many attempts */
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail6
goto|;
block|}
name|EFSYS_PROBE1
argument_list|(
name|mcdi_no_evb_port_retry
argument_list|,
name|int
argument_list|,
name|retry
argument_list|)
expr_stmt|;
name|EFSYS_SLEEP
argument_list|(
name|delay_us
argument_list|)
expr_stmt|;
name|retry
operator|++
expr_stmt|;
if|if
condition|(
name|delay_us
operator|<
literal|500000
condition|)
name|delay_us
operator|<<=
literal|2
expr_stmt|;
block|}
name|enp
operator|->
name|en_vport_id
operator|=
name|EVB_PORT_ID_ASSIGNED
expr_stmt|;
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_mcdi_max_payload_length
operator|=
name|MCDI_CTL_SDU_LEN_MAX_V2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|ef10_nic_free_piobufs
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_get_vi_pool
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|vi_countp
parameter_list|)
block|{
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
comment|/* 	 * Report VIs that the client driver can use. 	 * Do not include VIs used for PIO buffer writes. 	 */
operator|*
name|vi_countp
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_get_bar_region
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_nic_region_t
name|region
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|offsetp
parameter_list|,
name|__out
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_HUNTINGTON
operator|||
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_MEDFORD
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: Specify host memory mapping alignment and granularity 	 * in efx_drv_limits_t so that they can be taken into account 	 * when allocating extra VIs for PIO writes. 	 */
switch|switch
condition|(
name|region
condition|)
block|{
case|case
name|EFX_REGION_VI
case|:
comment|/* UC mapped memory BAR region for VI registers */
operator|*
name|offsetp
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_offset
expr_stmt|;
operator|*
name|sizep
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_uc_mem_map_size
expr_stmt|;
break|break;
case|case
name|EFX_REGION_PIO_WRITE_VI
case|:
comment|/* WC mapped memory BAR region for piobuf writes */
operator|*
name|offsetp
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_offset
expr_stmt|;
operator|*
name|sizep
operator|=
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_wc_mem_map_size
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ef10_nic_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_vadaptor_free
argument_list|(
name|enp
argument_list|,
name|enp
operator|->
name|en_vport_id
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_vport_id
operator|=
literal|0
expr_stmt|;
comment|/* Unlink piobufs from extra VIs in WC mapping */
if|if
condition|(
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_piobuf_count
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|efx_mcdi_unlink_piobuf
argument_list|(
name|enp
argument_list|,
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_pio_write_vi_base
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|ef10_nic_free_piobufs
argument_list|(
name|enp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_free_vis
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_arch
operator|.
name|ef10
operator|.
name|ena_vi_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ef10_nic_unprobe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|mcdi_mon_cfg_free
argument_list|(
name|enp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MON_STATS */
operator|(
name|void
operator|)
name|efx_mcdi_drv_attach
argument_list|(
name|enp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_DIAG
end_if

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_nic_register_test
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* FIXME */
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
name|_NOTE
argument_list|(
argument|CONSTANTCONDITION
argument_list|)
if|if
condition|(
name|B_FALSE
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* FIXME */
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_DIAG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

end_unit

