begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MON_MCDI
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_MON_STATS
end_if

begin_define
define|#
directive|define
name|MCDI_MON_NEXT_PAGE
value|(uint16_t)0xfffe
end_define

begin_define
define|#
directive|define
name|MCDI_MON_INVALID_SENSOR
value|(uint16_t)0xfffd
end_define

begin_define
define|#
directive|define
name|MCDI_MON_PAGE_SIZE
value|0x20
end_define

begin_comment
comment|/* Bitmasks of valid port(s) for each sensor */
end_comment

begin_define
define|#
directive|define
name|MCDI_MON_PORT_NONE
value|(0x00)
end_define

begin_define
define|#
directive|define
name|MCDI_MON_PORT_P1
value|(0x01)
end_define

begin_define
define|#
directive|define
name|MCDI_MON_PORT_P2
value|(0x02)
end_define

begin_define
define|#
directive|define
name|MCDI_MON_PORT_P3
value|(0x04)
end_define

begin_define
define|#
directive|define
name|MCDI_MON_PORT_P4
value|(0x08)
end_define

begin_define
define|#
directive|define
name|MCDI_MON_PORT_Px
value|(0xFFFF)
end_define

begin_comment
comment|/* Entry for MCDI sensor in sensor map */
end_comment

begin_define
define|#
directive|define
name|STAT
parameter_list|(
name|portmask
parameter_list|,
name|stat
parameter_list|)
define|\
value|{ (MCDI_MON_PORT_##portmask), (EFX_MON_STAT_##stat) }
end_define

begin_comment
comment|/* Entry for sensor next page flag in sensor map */
end_comment

begin_define
define|#
directive|define
name|STAT_NEXT_PAGE
parameter_list|()
define|\
value|{ MCDI_MON_PORT_NONE, MCDI_MON_NEXT_PAGE }
end_define

begin_comment
comment|/* Placeholder for gaps in the array */
end_comment

begin_define
define|#
directive|define
name|STAT_NO_SENSOR
parameter_list|()
define|\
value|{ MCDI_MON_PORT_NONE, MCDI_MON_INVALID_SENSOR }
end_define

begin_comment
comment|/* Map from MC sensors to monitor statistics */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|mcdi_sensor_map_s
block|{
name|uint16_t
name|msm_port_mask
decl_stmt|;
name|uint16_t
name|msm_stat
decl_stmt|;
block|}
name|mcdi_sensor_map
index|[]
init|=
block|{
comment|/* Sensor page 0		MC_CMD_SENSOR_xxx */
name|STAT
argument_list|(
name|Px
argument_list|,
name|INT_TEMP
argument_list|)
block|,
comment|/* 0x00 CONTROLLER_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|EXT_TEMP
argument_list|)
block|,
comment|/* 0x01 PHY_COMMON_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|INT_COOLING
argument_list|)
block|,
comment|/* 0x02 CONTROLLER_COOLING */
name|STAT
argument_list|(
name|P1
argument_list|,
name|EXT_TEMP
argument_list|)
block|,
comment|/* 0x03 PHY0_TEMP */
name|STAT
argument_list|(
name|P1
argument_list|,
name|EXT_COOLING
argument_list|)
block|,
comment|/* 0x04 PHY0_COOLING */
name|STAT
argument_list|(
name|P2
argument_list|,
name|EXT_TEMP
argument_list|)
block|,
comment|/* 0x05 PHY1_TEMP */
name|STAT
argument_list|(
name|P2
argument_list|,
name|EXT_COOLING
argument_list|)
block|,
comment|/* 0x06 PHY1_COOLING */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|1V
argument_list|)
block|,
comment|/* 0x07 IN_1V0 */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|1_2V
argument_list|)
block|,
comment|/* 0x08 IN_1V2 */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|1_8V
argument_list|)
block|,
comment|/* 0x09 IN_1V8 */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|2_5V
argument_list|)
block|,
comment|/* 0x0a IN_2V5 */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|3_3V
argument_list|)
block|,
comment|/* 0x0b IN_3V3 */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|12V
argument_list|)
block|,
comment|/* 0x0c IN_12V0 */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|1_2VA
argument_list|)
block|,
comment|/* 0x0d IN_1V2A */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VREF
argument_list|)
block|,
comment|/* 0x0e IN_VREF */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VAOE
argument_list|)
block|,
comment|/* 0x0f OUT_VAOE */
name|STAT
argument_list|(
name|Px
argument_list|,
name|AOE_TEMP
argument_list|)
block|,
comment|/* 0x10 AOE_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|PSU_AOE_TEMP
argument_list|)
block|,
comment|/* 0x11 PSU_AOE_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|PSU_TEMP
argument_list|)
block|,
comment|/* 0x12 PSU_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|FAN0
argument_list|)
block|,
comment|/* 0x13 FAN_0 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|FAN1
argument_list|)
block|,
comment|/* 0x14 FAN_1 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|FAN2
argument_list|)
block|,
comment|/* 0x15 FAN_2 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|FAN3
argument_list|)
block|,
comment|/* 0x16 FAN_3 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|FAN4
argument_list|)
block|,
comment|/* 0x17 FAN_4 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VAOE_IN
argument_list|)
block|,
comment|/* 0x18 IN_VAOE */
name|STAT
argument_list|(
name|Px
argument_list|,
name|IAOE
argument_list|)
block|,
comment|/* 0x19 OUT_IAOE */
name|STAT
argument_list|(
name|Px
argument_list|,
name|IAOE_IN
argument_list|)
block|,
comment|/* 0x1a IN_IAOE */
name|STAT
argument_list|(
name|Px
argument_list|,
name|NIC_POWER
argument_list|)
block|,
comment|/* 0x1b NIC_POWER */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|0_9V
argument_list|)
block|,
comment|/* 0x1c IN_0V9 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|I0_9V
argument_list|)
block|,
comment|/* 0x1d IN_I0V9 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|I1_2V
argument_list|)
block|,
comment|/* 0x1e IN_I1V2 */
name|STAT_NEXT_PAGE
argument_list|()
block|,
comment|/* 0x1f Next page flag (not a sensor) */
comment|/* Sensor page 1		MC_CMD_SENSOR_xxx */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|0_9V_ADC
argument_list|)
block|,
comment|/* 0x20 IN_0V9_ADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|INT_TEMP2
argument_list|)
block|,
comment|/* 0x21 CONTROLLER_2_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VREG_TEMP
argument_list|)
block|,
comment|/* 0x22 VREG_INTERNAL_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VREG_0_9V_TEMP
argument_list|)
block|,
comment|/* 0x23 VREG_0V9_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VREG_1_2V_TEMP
argument_list|)
block|,
comment|/* 0x24 VREG_1V2_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|INT_VPTAT
argument_list|)
block|,
comment|/* 0x25 CTRLR. VPTAT */
name|STAT
argument_list|(
name|Px
argument_list|,
name|INT_ADC_TEMP
argument_list|)
block|,
comment|/* 0x26 CTRLR. INTERNAL_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|EXT_VPTAT
argument_list|)
block|,
comment|/* 0x27 CTRLR. VPTAT_EXTADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|EXT_ADC_TEMP
argument_list|)
block|,
comment|/* 0x28 CTRLR. INTERNAL_TEMP_EXTADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|AMBIENT_TEMP
argument_list|)
block|,
comment|/* 0x29 AMBIENT_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|AIRFLOW
argument_list|)
block|,
comment|/* 0x2a AIRFLOW */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VDD08D_VSS08D_CSR
argument_list|)
block|,
comment|/* 0x2b VDD08D_VSS08D_CSR */
name|STAT
argument_list|(
name|Px
argument_list|,
name|VDD08D_VSS08D_CSR_EXTADC
argument_list|)
block|,
comment|/* 0x2c VDD08D_VSS08D_CSR_EXTADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|HOTPOINT_TEMP
argument_list|)
block|,
comment|/* 0x2d HOTPOINT_TEMP */
name|STAT
argument_list|(
name|P1
argument_list|,
name|PHY_POWER_SWITCH_PORT0
argument_list|)
block|,
comment|/* 0x2e PHY_POWER_SWITCH_PORT0 */
name|STAT
argument_list|(
name|P2
argument_list|,
name|PHY_POWER_SWITCH_PORT1
argument_list|)
block|,
comment|/* 0x2f PHY_POWER_SWITCH_PORT1 */
name|STAT
argument_list|(
name|Px
argument_list|,
name|MUM_VCC
argument_list|)
block|,
comment|/* 0x30 MUM_VCC */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|0V9_A
argument_list|)
block|,
comment|/* 0x31 0V9_A */
name|STAT
argument_list|(
name|Px
argument_list|,
name|I0V9_A
argument_list|)
block|,
comment|/* 0x32 I0V9_A */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|0V9_A_TEMP
argument_list|)
block|,
comment|/* 0x33 0V9_A_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|0V9_B
argument_list|)
block|,
comment|/* 0x34 0V9_B */
name|STAT
argument_list|(
name|Px
argument_list|,
name|I0V9_B
argument_list|)
block|,
comment|/* 0x35 I0V9_B */
name|STAT
argument_list|(
name|Px
argument_list|,
literal|0V9_B_TEMP
argument_list|)
block|,
comment|/* 0x36 0V9_B_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CCOM_AVREG_1V2_SUPPLY
argument_list|)
block|,
comment|/* 0x37 CCOM_AVREG_1V2_SUPPLY */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CCOM_AVREG_1V2_SUPPLY_EXT_ADC
argument_list|)
block|,
comment|/* 0x38 CCOM_AVREG_1V2_SUPPLY_EXT_ADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CCOM_AVREG_1V8_SUPPLY
argument_list|)
block|,
comment|/* 0x39 CCOM_AVREG_1V8_SUPPLY */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CCOM_AVREG_1V8_SUPPLY_EXT_ADC
argument_list|)
block|,
comment|/* 0x3a CCOM_AVREG_1V8_SUPPLY_EXT_ADC */
name|STAT_NO_SENSOR
argument_list|()
block|,
comment|/* 0x3b (no sensor) */
name|STAT_NO_SENSOR
argument_list|()
block|,
comment|/* 0x3c (no sensor) */
name|STAT_NO_SENSOR
argument_list|()
block|,
comment|/* 0x3d (no sensor) */
name|STAT_NO_SENSOR
argument_list|()
block|,
comment|/* 0x3e (no sensor) */
name|STAT_NEXT_PAGE
argument_list|()
block|,
comment|/* 0x3f Next page flag (not a sensor) */
comment|/* Sensor page 2		MC_CMD_SENSOR_xxx */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_MASTER_VPTAT
argument_list|)
block|,
comment|/* 0x40 MASTER_VPTAT */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_MASTER_INTERNAL_TEMP
argument_list|)
block|,
comment|/* 0x41 MASTER_INT_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_MASTER_VPTAT_EXT_ADC
argument_list|)
block|,
comment|/* 0x42 MAST_VPTAT_EXT_ADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_MASTER_INTERNAL_TEMP_EXT_ADC
argument_list|)
block|,
comment|/* 0x43 MASTER_INTERNAL_TEMP_EXT_ADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_SLAVE_VPTAT
argument_list|)
block|,
comment|/* 0x44 SLAVE_VPTAT */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_SLAVE_INTERNAL_TEMP
argument_list|)
block|,
comment|/* 0x45 SLAVE_INTERNAL_TEMP */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_SLAVE_VPTAT_EXT_ADC
argument_list|)
block|,
comment|/* 0x46 SLAVE_VPTAT_EXT_ADC */
name|STAT
argument_list|(
name|Px
argument_list|,
name|CONTROLLER_SLAVE_INTERNAL_TEMP_EXT_ADC
argument_list|)
block|,
comment|/* 0x47 SLAVE_INTERNAL_TEMP_EXT_ADC */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MCDI_STATIC_SENSOR_ASSERT
parameter_list|(
name|_field
parameter_list|)
define|\
value|EFX_STATIC_ASSERT(MC_CMD_SENSOR_STATE_ ## _field		\ 			    == EFX_MON_STAT_STATE_ ## _field)
end_define

begin_decl_stmt
specifier|static
name|void
name|mcdi_mon_decode_stats
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in_ecount
argument_list|(
argument|sensor_mask_size
argument_list|)
name|uint32_t
operator|*
name|sensor_mask
argument_list|,
name|__in
name|size_t
name|sensor_mask_size
argument_list|,
name|__in_opt
name|efsys_mem_t
operator|*
name|esmp
argument_list|,
name|__out_ecount_opt
argument_list|(
argument|sensor_mask_size
argument_list|)
name|uint32_t
operator|*
name|stat_maskp
argument_list|,
name|__inout_ecount_opt
argument_list|(
argument|EFX_MON_NSTATS
argument_list|)
name|efx_mon_stat_value_t
operator|*
name|stat
argument_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|uint16_t
name|port_mask
decl_stmt|;
name|uint16_t
name|sensor
decl_stmt|;
name|size_t
name|sensor_max
decl_stmt|;
name|uint32_t
name|stat_mask
index|[
operator|(
name|EFX_ARRAY_SIZE
argument_list|(
name|mcdi_sensor_map
argument_list|)
operator|+
literal|31
operator|)
operator|/
literal|32
index|]
decl_stmt|;
name|uint32_t
name|idx
init|=
literal|0
decl_stmt|;
name|uint32_t
name|page
init|=
literal|0
decl_stmt|;
comment|/* Assert the MC_CMD_SENSOR and EFX_MON_STATE namespaces agree */
name|MCDI_STATIC_SENSOR_ASSERT
argument_list|(
name|OK
argument_list|)
expr_stmt|;
name|MCDI_STATIC_SENSOR_ASSERT
argument_list|(
name|WARNING
argument_list|)
expr_stmt|;
name|MCDI_STATIC_SENSOR_ASSERT
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
name|MCDI_STATIC_SENSOR_ASSERT
argument_list|(
name|BROKEN
argument_list|)
expr_stmt|;
name|MCDI_STATIC_SENSOR_ASSERT
argument_list|(
name|NO_READING
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|stat_mask
index|[
literal|0
index|]
argument_list|)
operator|*
literal|8
operator|==
name|EFX_MON_MASK_ELEMENT_SIZE
argument_list|)
expr_stmt|;
name|sensor_max
operator|=
name|MIN
argument_list|(
operator|(
literal|8
operator|*
name|sensor_mask_size
operator|)
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|mcdi_sensor_map
argument_list|)
argument_list|)
expr_stmt|;
name|port_mask
operator|=
literal|1U
operator|<<
name|emip
operator|->
name|emi_port
expr_stmt|;
name|memset
argument_list|(
name|stat_mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stat_mask
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The MCDI sensor readings in the DMA buffer are a packed array of 	 * MC_CMD_SENSOR_VALUE_ENTRY structures, which only includes entries for 	 * supported sensors (bit set in sensor_mask). The sensor_mask and 	 * sensor readings do not include entries for the per-page NEXT_PAGE 	 * flag. 	 * 	 * sensor_mask may legitimately contain MCDI sensors that the driver 	 * does not understand. 	 */
for|for
control|(
name|sensor
operator|=
literal|0
init|;
name|sensor
operator|<
name|sensor_max
condition|;
operator|++
name|sensor
control|)
block|{
name|efx_mon_stat_t
name|id
init|=
name|mcdi_sensor_map
index|[
name|sensor
index|]
operator|.
name|msm_stat
decl_stmt|;
if|if
condition|(
operator|(
name|sensor
operator|%
name|MCDI_MON_PAGE_SIZE
operator|)
operator|==
name|MC_CMD_SENSOR_PAGE0_NEXT
condition|)
block|{
name|EFSYS_ASSERT3U
argument_list|(
name|id
argument_list|,
operator|==
argument_list|,
name|MCDI_MON_NEXT_PAGE
argument_list|)
expr_stmt|;
name|page
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|~
operator|(
name|sensor_mask
index|[
name|page
index|]
operator|)
operator|&
operator|(
literal|1U
operator|<<
name|sensor
operator|)
condition|)
continue|continue;
name|idx
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|port_mask
operator|&
name|mcdi_sensor_map
index|[
name|sensor
index|]
operator|.
name|msm_port_mask
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|EFSYS_ASSERT
argument_list|(
name|id
operator|<
name|EFX_MON_NSTATS
argument_list|)
expr_stmt|;
comment|/* 		 * stat_mask is a bitmask indexed by EFX_MON_* monitor statistic 		 * identifiers from efx_mon_stat_t (without NEXT_PAGE bits). 		 * 		 * If there is an entry in the MCDI sensor to monitor statistic 		 * map then the sensor reading is used for the value of the 		 * monitor statistic. 		 */
name|stat_mask
index|[
name|id
operator|/
name|EFX_MON_MASK_ELEMENT_SIZE
index|]
operator||=
operator|(
literal|1U
operator|<<
operator|(
name|id
operator|%
name|EFX_MON_MASK_ELEMENT_SIZE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|NULL
operator|&&
name|esmp
operator|!=
name|NULL
operator|&&
operator|!
name|EFSYS_MEM_IS_NULL
argument_list|(
name|esmp
argument_list|)
condition|)
block|{
name|efx_dword_t
name|dword
decl_stmt|;
comment|/* Get MCDI sensor reading from DMA buffer */
name|EFSYS_MEM_READD
argument_list|(
name|esmp
argument_list|,
literal|4
operator|*
operator|(
name|idx
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|dword
argument_list|)
expr_stmt|;
comment|/* Update EFX monitor stat from MCDI sensor reading */
name|stat
index|[
name|id
index|]
operator|.
name|emsv_value
operator|=
operator|(
name|uint16_t
operator|)
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE
argument_list|)
expr_stmt|;
name|stat
index|[
name|id
index|]
operator|.
name|emsv_state
operator|=
operator|(
name|uint16_t
operator|)
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat_maskp
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|stat_maskp
argument_list|,
name|stat_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|stat_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|mcdi_mon_ev
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__out
name|efx_mon_stat_t
modifier|*
name|idp
parameter_list|,
name|__out
name|efx_mon_stat_value_t
modifier|*
name|valuep
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint16_t
name|port_mask
decl_stmt|;
name|uint16_t
name|sensor
decl_stmt|;
name|uint16_t
name|state
decl_stmt|;
name|uint16_t
name|value
decl_stmt|;
name|efx_mon_stat_t
name|id
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|port_mask
operator|=
operator|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
operator|)
condition|?
name|MCDI_MON_PORT_P1
else|:
name|MCDI_MON_PORT_P2
expr_stmt|;
name|sensor
operator|=
operator|(
name|uint16_t
operator|)
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|SENSOREVT_MONITOR
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
name|uint16_t
operator|)
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|SENSOREVT_STATE
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|uint16_t
operator|)
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|SENSOREVT_VALUE
argument_list|)
expr_stmt|;
comment|/* Hardware must support this MCDI sensor */
name|EFSYS_ASSERT3U
argument_list|(
name|sensor
argument_list|,
operator|<
argument_list|,
operator|(
literal|8
operator|*
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
operator|)
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|(
name|sensor
operator|%
name|MCDI_MON_PAGE_SIZE
operator|)
operator|!=
name|MC_CMD_SENSOR_PAGE0_NEXT
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|encp
operator|->
name|enc_mcdi_sensor_maskp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|(
name|encp
operator|->
name|enc_mcdi_sensor_maskp
index|[
name|sensor
operator|/
name|MCDI_MON_PAGE_SIZE
index|]
operator|&
operator|(
literal|1U
operator|<<
operator|(
name|sensor
operator|%
name|MCDI_MON_PAGE_SIZE
operator|)
operator|)
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* But we don't have to understand it */
if|if
condition|(
name|sensor
operator|>=
name|EFX_ARRAY_SIZE
argument_list|(
name|mcdi_sensor_map
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|id
operator|=
name|mcdi_sensor_map
index|[
name|sensor
index|]
operator|.
name|msm_stat
expr_stmt|;
if|if
condition|(
operator|(
name|port_mask
operator|&
name|mcdi_sensor_map
index|[
name|sensor
index|]
operator|.
name|msm_port_mask
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|EFSYS_ASSERT
argument_list|(
name|id
operator|<
name|EFX_MON_NSTATS
argument_list|)
expr_stmt|;
operator|*
name|idp
operator|=
name|id
expr_stmt|;
name|valuep
operator|->
name|emsv_value
operator|=
name|value
expr_stmt|;
name|valuep
operator|->
name|emsv_state
operator|=
name|state
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_read_sensors
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efsys_mem_t
modifier|*
name|esmp
parameter_list|,
name|__in
name|uint32_t
name|size
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_READ_SENSORS_EXT_IN_LEN
argument_list|,
name|MC_CMD_READ_SENSORS_EXT_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|addr_lo
decl_stmt|,
name|addr_hi
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_READ_SENSORS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_READ_SENSORS_EXT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_READ_SENSORS_EXT_OUT_LEN
expr_stmt|;
name|addr_lo
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|EFSYS_MEM_ADDR
argument_list|(
name|esmp
argument_list|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|addr_hi
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|EFSYS_MEM_ADDR
argument_list|(
name|esmp
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|READ_SENSORS_EXT_IN_DMA_ADDR_LO
argument_list|,
name|addr_lo
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|READ_SENSORS_EXT_IN_DMA_ADDR_HI
argument_list|,
name|addr_hi
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|READ_SENSORS_EXT_IN_LENGTH
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
return|return
operator|(
name|req
operator|.
name|emr_rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_sensor_info_npages
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|npagesp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_SENSOR_INFO_EXT_IN_LEN
argument_list|,
name|MC_CMD_SENSOR_INFO_OUT_LENMAX
argument_list|)
index|]
decl_stmt|;
name|int
name|page
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|npagesp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|page
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_SENSOR_INFO
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_SENSOR_INFO_EXT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_SENSOR_INFO_OUT_LENMAX
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SENSOR_INFO_EXT_IN_PAGE
argument_list|,
name|page
operator|++
argument_list|)
expr_stmt|;
name|efx_mcdi_execute_quiet
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
block|}
do|while
condition|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|SENSOR_INFO_OUT_MASK
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_SENSOR_PAGE0_NEXT
operator|)
condition|)
do|;
operator|*
name|npagesp
operator|=
name|page
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|__checkReturn
name|efx_rc_t
name|efx_mcdi_sensor_info
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount
argument_list|(
argument|npages
argument_list|)
name|uint32_t
operator|*
name|sensor_maskp
argument_list|,
name|__in
name|size_t
name|npages
argument_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_SENSOR_INFO_EXT_IN_LEN
argument_list|,
name|MC_CMD_SENSOR_INFO_OUT_LENMAX
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|page
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|sensor_maskp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
name|npages
condition|;
name|page
operator|++
control|)
block|{
name|uint32_t
name|mask
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_SENSOR_INFO
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_SENSOR_INFO_EXT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_SENSOR_INFO_OUT_LENMAX
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SENSOR_INFO_EXT_IN_PAGE
argument_list|,
name|page
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|SENSOR_INFO_OUT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|page
operator|!=
operator|(
name|npages
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
literal|1U
operator|<<
name|MC_CMD_SENSOR_PAGE0_NEXT
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|sensor_maskp
index|[
name|page
index|]
operator|=
name|mask
expr_stmt|;
block|}
if|if
condition|(
name|sensor_maskp
index|[
name|npages
operator|-
literal|1
index|]
operator|&
operator|(
literal|1U
operator|<<
name|MC_CMD_SENSOR_PAGE0_NEXT
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|mcdi_mon_stats_update
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|efsys_mem_t
operator|*
name|esmp
argument_list|,
name|__inout_ecount
argument_list|(
argument|EFX_MON_NSTATS
argument_list|)
name|efx_mon_stat_value_t
operator|*
name|values
argument_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint32_t
name|size
init|=
name|encp
operator|->
name|enc_mon_stat_dma_buf_size
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_sensors
argument_list|(
name|enp
argument_list|,
name|esmp
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|EFSYS_DMA_SYNC_FOR_KERNEL
argument_list|(
name|esmp
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mcdi_mon_decode_stats
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_maskp
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
argument_list|,
name|esmp
argument_list|,
name|NULL
argument_list|,
name|values
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|mcdi_mon_cfg_build
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint32_t
name|npages
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
switch|switch
condition|(
name|enp
operator|->
name|en_family
condition|)
block|{
if|#
directive|if
name|EFSYS_OPT_SIENA
case|case
name|EFX_FAMILY_SIENA
case|:
name|encp
operator|->
name|enc_mon_type
operator|=
name|EFX_MON_SFC90X0
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
case|case
name|EFX_FAMILY_HUNTINGTON
case|:
name|encp
operator|->
name|enc_mon_type
operator|=
name|EFX_MON_SFC91X0
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Get mc sensor mask size */
name|npages
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_sensor_info_npages
argument_list|(
name|enp
argument_list|,
operator|&
name|npages
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
name|encp
operator|->
name|enc_mon_stat_dma_buf_size
operator|=
name|npages
operator|*
name|EFX_MON_STATS_PAGE_SIZE
expr_stmt|;
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
operator|=
name|npages
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* Allocate mc sensor mask */
name|EFSYS_KMEM_ALLOC
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_maskp
argument_list|)
expr_stmt|;
if|if
condition|(
name|encp
operator|->
name|enc_mcdi_sensor_maskp
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
comment|/* Read mc sensor mask */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_sensor_info
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_maskp
argument_list|,
name|npages
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
comment|/* Build monitor statistics mask */
name|mcdi_mon_decode_stats
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_maskp
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
argument_list|,
name|NULL
argument_list|,
name|encp
operator|->
name|enc_mon_stat_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_maskp
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mcdi_mon_cfg_free
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
if|if
condition|(
name|encp
operator|->
name|enc_mcdi_sensor_maskp
operator|!=
name|NULL
condition|)
block|{
name|EFSYS_KMEM_FREE
argument_list|(
name|enp
operator|->
name|en_esip
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_mask_size
argument_list|,
name|encp
operator|->
name|enc_mcdi_sensor_maskp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MON_STATS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MON_MCDI */
end_comment

end_unit

