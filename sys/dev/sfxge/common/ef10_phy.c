begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_HUNTINGTON
operator|||
name|EFSYS_OPT_MEDFORD
end_if

begin_function
specifier|static
name|void
name|mcdi_phy_decode_cap
parameter_list|(
name|__in
name|uint32_t
name|mcdi_cap
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|maskp
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_10HDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_10HDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_10FDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_10FDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_100HDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_100HDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_100FDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_100FDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_1000HDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_1000HDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_1000FDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_1000FDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_10000FDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_10000FDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_40000FDX_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_40000FDX
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_PAUSE_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_PAUSE
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_ASYM_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_ASYM
operator|)
expr_stmt|;
if|if
condition|(
name|mcdi_cap
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_PHY_CAP_AN_LBN
operator|)
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_CAP_AN
operator|)
expr_stmt|;
operator|*
name|maskp
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcdi_phy_decode_link_mode
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|uint32_t
name|link_flags
parameter_list|,
name|__in
name|unsigned
name|int
name|speed
parameter_list|,
name|__in
name|unsigned
name|int
name|fcntl
parameter_list|,
name|__out
name|efx_link_mode_t
modifier|*
name|link_modep
parameter_list|,
name|__out
name|unsigned
name|int
modifier|*
name|fcntlp
parameter_list|)
block|{
name|boolean_t
name|fd
init|=
operator|!
operator|!
operator|(
name|link_flags
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN
operator|)
operator|)
decl_stmt|;
name|boolean_t
name|up
init|=
operator|!
operator|!
operator|(
name|link_flags
operator|&
operator|(
literal|1
operator|<<
name|MC_CMD_GET_LINK_OUT_LINK_UP_LBN
operator|)
operator|)
decl_stmt|;
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
if|if
condition|(
operator|!
name|up
condition|)
operator|*
name|link_modep
operator|=
name|EFX_LINK_DOWN
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|40000
operator|&&
name|fd
condition|)
operator|*
name|link_modep
operator|=
name|EFX_LINK_40000FDX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|10000
operator|&&
name|fd
condition|)
operator|*
name|link_modep
operator|=
name|EFX_LINK_10000FDX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|1000
condition|)
operator|*
name|link_modep
operator|=
name|fd
condition|?
name|EFX_LINK_1000FDX
else|:
name|EFX_LINK_1000HDX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|100
condition|)
operator|*
name|link_modep
operator|=
name|fd
condition|?
name|EFX_LINK_100FDX
else|:
name|EFX_LINK_100HDX
expr_stmt|;
elseif|else
if|if
condition|(
name|speed
operator|==
literal|10
condition|)
operator|*
name|link_modep
operator|=
name|fd
condition|?
name|EFX_LINK_10FDX
else|:
name|EFX_LINK_10HDX
expr_stmt|;
else|else
operator|*
name|link_modep
operator|=
name|EFX_LINK_UNKNOWN
expr_stmt|;
if|if
condition|(
name|fcntl
operator|==
name|MC_CMD_FCNTL_OFF
condition|)
operator|*
name|fcntlp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|fcntl
operator|==
name|MC_CMD_FCNTL_RESPOND
condition|)
operator|*
name|fcntlp
operator|=
name|EFX_FCNTL_RESPOND
expr_stmt|;
elseif|else
if|if
condition|(
name|fcntl
operator|==
name|MC_CMD_FCNTL_GENERATE
condition|)
operator|*
name|fcntlp
operator|=
name|EFX_FCNTL_GENERATE
expr_stmt|;
elseif|else
if|if
condition|(
name|fcntl
operator|==
name|MC_CMD_FCNTL_BIDIR
condition|)
operator|*
name|fcntlp
operator|=
name|EFX_FCNTL_RESPOND
operator||
name|EFX_FCNTL_GENERATE
expr_stmt|;
else|else
block|{
name|EFSYS_PROBE1
argument_list|(
name|mc_pcol_error
argument_list|,
name|int
argument_list|,
name|fcntl
argument_list|)
expr_stmt|;
operator|*
name|fcntlp
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ef10_phy_link_ev
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_qword_t
modifier|*
name|eqp
parameter_list|,
name|__out
name|efx_link_mode_t
modifier|*
name|link_modep
parameter_list|)
block|{
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|unsigned
name|int
name|link_flags
decl_stmt|;
name|unsigned
name|int
name|speed
decl_stmt|;
name|unsigned
name|int
name|fcntl
decl_stmt|;
name|efx_link_mode_t
name|link_mode
decl_stmt|;
name|uint32_t
name|lp_cap_mask
decl_stmt|;
comment|/* 	 * Convert the LINKCHANGE speed enumeration into mbit/s, in the 	 * same way as GET_LINK encodes the speed 	 */
switch|switch
condition|(
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|LINKCHANGE_SPEED
argument_list|)
condition|)
block|{
case|case
name|MCDI_EVENT_LINKCHANGE_SPEED_100M
case|:
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_LINKCHANGE_SPEED_1G
case|:
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_LINKCHANGE_SPEED_10G
case|:
name|speed
operator|=
literal|10000
expr_stmt|;
break|break;
case|case
name|MCDI_EVENT_LINKCHANGE_SPEED_40G
case|:
name|speed
operator|=
literal|40000
expr_stmt|;
break|break;
default|default:
name|speed
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|link_flags
operator|=
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|LINKCHANGE_LINK_FLAGS
argument_list|)
expr_stmt|;
name|mcdi_phy_decode_link_mode
argument_list|(
name|enp
argument_list|,
name|link_flags
argument_list|,
name|speed
argument_list|,
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|LINKCHANGE_FCNTL
argument_list|)
argument_list|,
operator|&
name|link_mode
argument_list|,
operator|&
name|fcntl
argument_list|)
expr_stmt|;
name|mcdi_phy_decode_cap
argument_list|(
name|MCDI_EV_FIELD
argument_list|(
name|eqp
argument_list|,
name|LINKCHANGE_LP_CAP
argument_list|)
argument_list|,
operator|&
name|lp_cap_mask
argument_list|)
expr_stmt|;
comment|/* 	 * It's safe to update ep_lp_cap_mask without the driver's port lock 	 * because presumably any concurrently running efx_port_poll() is 	 * only going to arrive at the same value. 	 * 	 * ep_fcntl has two meanings. It's either the link common fcntl 	 * (if the PHY supports AN), or it's the forced link state. If 	 * the former, it's safe to update the value for the same reason as 	 * for ep_lp_cap_mask. If the latter, then just ignore the value, 	 * because we can race with efx_mac_fcntl_set(). 	 */
name|epp
operator|->
name|ep_lp_cap_mask
operator|=
name|lp_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_fcntl
operator|=
name|fcntl
expr_stmt|;
operator|*
name|link_modep
operator|=
name|link_mode
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_power
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|boolean_t
name|power
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|power
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check if the PHY is a zombie */
if|if
condition|(
operator|(
name|rc
operator|=
name|ef10_phy_verify
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|enp
operator|->
name|en_reset_flags
operator||=
name|EFX_RESET_PHY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_get_link
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|ef10_link_state_t
modifier|*
name|elsp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_LINK_IN_LEN
argument_list|,
name|MC_CMD_GET_LINK_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_LINK
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_LINK_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_LINK_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_LINK_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|mcdi_phy_decode_cap
argument_list|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_CAP
argument_list|)
argument_list|,
operator|&
name|elsp
operator|->
name|els_adv_cap_mask
argument_list|)
expr_stmt|;
name|mcdi_phy_decode_cap
argument_list|(
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_LP_CAP
argument_list|)
argument_list|,
operator|&
name|elsp
operator|->
name|els_lp_cap_mask
argument_list|)
expr_stmt|;
name|mcdi_phy_decode_link_mode
argument_list|(
name|enp
argument_list|,
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_FLAGS
argument_list|)
argument_list|,
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_LINK_SPEED
argument_list|)
argument_list|,
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_FCNTL
argument_list|)
argument_list|,
operator|&
name|elsp
operator|->
name|els_link_mode
argument_list|,
operator|&
name|elsp
operator|->
name|els_fcntl
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
comment|/* Assert the MC_CMD_LOOPBACK and EFX_LOOPBACK namespace agree */
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_NONE
operator|==
name|EFX_LOOPBACK_OFF
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_DATA
operator|==
name|EFX_LOOPBACK_DATA
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_GMAC
operator|==
name|EFX_LOOPBACK_GMAC
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XGMII
operator|==
name|EFX_LOOPBACK_XGMII
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XGXS
operator|==
name|EFX_LOOPBACK_XGXS
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XAUI
operator|==
name|EFX_LOOPBACK_XAUI
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_GMII
operator|==
name|EFX_LOOPBACK_GMII
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_SGMII
operator|==
name|EFX_LOOPBACK_SGMII
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XGBR
operator|==
name|EFX_LOOPBACK_XGBR
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XFI
operator|==
name|EFX_LOOPBACK_XFI
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XAUI_FAR
operator|==
name|EFX_LOOPBACK_XAUI_FAR
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_GMII_FAR
operator|==
name|EFX_LOOPBACK_GMII_FAR
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_SGMII_FAR
operator|==
name|EFX_LOOPBACK_SGMII_FAR
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_XFI_FAR
operator|==
name|EFX_LOOPBACK_XFI_FAR
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_GPHY
operator|==
name|EFX_LOOPBACK_GPHY
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_PHYXS
operator|==
name|EFX_LOOPBACK_PHY_XS
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_PCS
operator|==
name|EFX_LOOPBACK_PCS
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOOPBACK_PMAPMD
operator|==
name|EFX_LOOPBACK_PMA_PMD
argument_list|)
expr_stmt|;
name|elsp
operator|->
name|els_loopback
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_LOOPBACK_MODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_LOOPBACK */
name|elsp
operator|->
name|els_mac_up
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LINK_OUT_MAC_FAULT
argument_list|)
operator|==
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_reconfigure
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_SET_LINK_IN_LEN
argument_list|,
name|MC_CMD_SET_LINK_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|cap_mask
decl_stmt|;
name|unsigned
name|int
name|led_mode
decl_stmt|;
name|unsigned
name|int
name|speed
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
if|if
condition|(
operator|~
name|encp
operator|->
name|enc_func_flags
operator|&
name|EFX_NIC_FUNC_LINKCTRL
condition|)
goto|goto
name|out
goto|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_SET_LINK
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_SET_LINK_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_SET_LINK_OUT_LEN
expr_stmt|;
name|cap_mask
operator|=
name|epp
operator|->
name|ep_adv_cap_mask
expr_stmt|;
name|MCDI_IN_POPULATE_DWORD_10
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_CAP
argument_list|,
name|PHY_CAP_10HDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_10HDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_10FDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_10FDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_100HDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_100HDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_100FDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_100FDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_1000HDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_1000HDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_1000FDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_1000FDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_10000FDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_10000FDX
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_PAUSE
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_PAUSE
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_ASYM
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_ASYM
operator|)
operator|&
literal|0x1
argument_list|,
name|PHY_CAP_AN
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_AN
operator|)
operator|&
literal|0x1
argument_list|)
expr_stmt|;
comment|/* Too many fields for for POPULATE macros, so insert this afterwards */
name|MCDI_IN_SET_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_CAP
argument_list|,
name|PHY_CAP_40000FDX
argument_list|,
operator|(
name|cap_mask
operator|>>
name|EFX_PHY_CAP_40000FDX
operator|)
operator|&
literal|0x1
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_LOOPBACK_MODE
argument_list|,
name|epp
operator|->
name|ep_loopback_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|epp
operator|->
name|ep_loopback_link_mode
condition|)
block|{
case|case
name|EFX_LINK_100FDX
case|:
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|EFX_LINK_1000FDX
case|:
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
name|EFX_LINK_10000FDX
case|:
name|speed
operator|=
literal|10000
expr_stmt|;
break|break;
case|case
name|EFX_LINK_40000FDX
case|:
name|speed
operator|=
literal|40000
expr_stmt|;
break|break;
default|default:
name|speed
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_LOOPBACK_MODE
argument_list|,
name|MC_CMD_LOOPBACK_NONE
argument_list|)
expr_stmt|;
name|speed
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_LOOPBACK */
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_LOOPBACK_SPEED
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_FLAGS
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_FLAGS
argument_list|,
name|epp
operator|->
name|ep_phy_flags
argument_list|)
expr_stmt|;
else|#
directive|else
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_LINK_IN_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_FLAGS */
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* And set the blink mode */
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_SET_ID_LED
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_SET_ID_LED_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_SET_ID_LED_OUT_LEN
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_LED_CONTROL
switch|switch
condition|(
name|epp
operator|->
name|ep_phy_led_mode
condition|)
block|{
case|case
name|EFX_PHY_LED_DEFAULT
case|:
name|led_mode
operator|=
name|MC_CMD_LED_DEFAULT
expr_stmt|;
break|break;
case|case
name|EFX_PHY_LED_OFF
case|:
name|led_mode
operator|=
name|MC_CMD_LED_OFF
expr_stmt|;
break|break;
case|case
name|EFX_PHY_LED_ON
case|:
name|led_mode
operator|=
name|MC_CMD_LED_ON
expr_stmt|;
break|break;
default|default:
name|EFSYS_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|led_mode
operator|=
name|MC_CMD_LED_DEFAULT
expr_stmt|;
block|}
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_ID_LED_IN_STATE
argument_list|,
name|led_mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|SET_ID_LED_IN_STATE
argument_list|,
name|MC_CMD_LED_DEFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_LED_CONTROL */
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|out
label|:
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_verify
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_PHY_STATE_IN_LEN
argument_list|,
name|MC_CMD_GET_PHY_STATE_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|state
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PHY_STATE
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_PHY_STATE_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_PHY_STATE_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PHY_STATE_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|state
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_STATE_OUT_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|MC_CMD_PHY_STATE_OK
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|MC_CMD_PHY_STATE_ZOMBIE
condition|)
name|EFSYS_PROBE1
argument_list|(
name|mc_pcol_error
argument_list|,
name|int
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ENOTACTIVE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_oui_get
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|ouip
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp, ouip)
argument_list|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_PHY_STATS
end_if

begin_decl_stmt
name|__checkReturn
name|efx_rc_t
name|ef10_phy_stats_update
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__in
name|efsys_mem_t
operator|*
name|esmp
argument_list|,
name|__inout_ecount
argument_list|(
argument|EFX_PHY_NSTATS
argument_list|)
name|uint32_t
operator|*
name|stat
argument_list|)
block|{
comment|/* TBD: no stats support in firmware yet */
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp, esmp)
argument_list|)
name|memset
argument_list|(
name|stat
argument_list|,
literal|0
argument_list|,
name|EFX_PHY_NSTATS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_PHY_STATS */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_PHY_PROPS
end_if

begin_if
if|#
directive|if
name|EFSYS_OPT_NAMES
end_if

begin_function
specifier|const
name|char
modifier|*
name|ef10_phy_prop_name
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|id
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp, id)
argument_list|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_NAMES */
end_comment

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_prop_get
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|id
parameter_list|,
name|__in
name|uint32_t
name|flags
parameter_list|,
name|__out
name|uint32_t
modifier|*
name|valp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp, id, flags, valp)
argument_list|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|ef10_phy_prop_set
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|id
parameter_list|,
name|__in
name|uint32_t
name|val
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp, id, val)
argument_list|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_PHY_PROPS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_HUNTINGTON || EFSYS_OPT_MEDFORD */
end_comment

end_unit

