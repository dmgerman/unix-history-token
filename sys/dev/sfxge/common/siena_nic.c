begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2015 Solarflare Communications Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright notice,  *    this list of conditions and the following disclaimer in the documentation  *    and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation are  * those of the authors and should not be interpreted as representing official  * policies, either expressed or implied, of the FreeBSD Project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_include
include|#
directive|include
file|"mcdi_mon.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_SIENA
end_if

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|siena_nic_get_partn_mask
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|unsigned
name|int
modifier|*
name|maskp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_NVRAM_TYPES_IN_LEN
argument_list|,
name|MC_CMD_NVRAM_TYPES_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_NVRAM_TYPES
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_NVRAM_TYPES_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_NVRAM_TYPES_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_NVRAM_TYPES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|maskp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|NVRAM_TYPES_OUT_TYPES
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|siena_board_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|uint8_t
name|mac_addr
index|[
literal|6
index|]
decl_stmt|;
name|efx_dword_t
name|capabilities
decl_stmt|;
name|uint32_t
name|board_type
decl_stmt|;
name|uint32_t
name|nevq
decl_stmt|,
name|nrxq
decl_stmt|,
name|ntxq
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* External port identifier using one-based port numbering */
name|encp
operator|->
name|enc_external_port
operator|=
operator|(
name|uint8_t
operator|)
name|enp
operator|->
name|en_mcdi
operator|.
name|em_emip
operator|.
name|emi_port
expr_stmt|;
comment|/* Board configuration */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_board_cfg
argument_list|(
name|enp
argument_list|,
operator|&
name|board_type
argument_list|,
operator|&
name|capabilities
argument_list|,
name|mac_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|encp
operator|->
name|enc_mac_addr
argument_list|,
name|mac_addr
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_board_type
operator|=
name|board_type
expr_stmt|;
comment|/* Additional capabilities */
name|encp
operator|->
name|enc_clk_mult
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|capabilities
argument_list|,
name|MC_CMD_CAPABILITIES_TURBO
argument_list|)
condition|)
block|{
name|enp
operator|->
name|en_features
operator||=
name|EFX_FEATURE_TURBO
expr_stmt|;
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|capabilities
argument_list|,
name|MC_CMD_CAPABILITIES_TURBO_ACTIVE
argument_list|)
condition|)
block|{
name|encp
operator|->
name|enc_clk_mult
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|=
name|EFX_EVQ_SIENA_TIMER_QUANTUM_NS
operator|/
name|encp
operator|->
name|enc_clk_mult
expr_stmt|;
name|encp
operator|->
name|enc_evq_timer_max_us
operator|=
operator|(
name|encp
operator|->
name|enc_evq_timer_quantum_ns
operator|<<
name|FRF_CZ_TC_TIMER_VAL_WIDTH
operator|)
operator|/
literal|1000
expr_stmt|;
comment|/* When hash header insertion is enabled, Siena inserts 16 bytes */
name|encp
operator|->
name|enc_rx_prefix_size
operator|=
literal|16
expr_stmt|;
comment|/* Alignment for receive packet DMA buffers */
name|encp
operator|->
name|enc_rx_buf_align_start
operator|=
literal|1
expr_stmt|;
name|encp
operator|->
name|enc_rx_buf_align_end
operator|=
literal|1
expr_stmt|;
comment|/* Alignment for WPTR updates */
name|encp
operator|->
name|enc_rx_push_align
operator|=
literal|1
expr_stmt|;
comment|/* Resource limits */
name|rc
operator|=
name|efx_mcdi_get_resource_limits
argument_list|(
name|enp
argument_list|,
operator|&
name|nevq
argument_list|,
operator|&
name|nrxq
argument_list|,
operator|&
name|ntxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|!=
name|ENOTSUP
condition|)
goto|goto
name|fail2
goto|;
name|nevq
operator|=
literal|1024
expr_stmt|;
name|nrxq
operator|=
name|EFX_RXQ_LIMIT_TARGET
expr_stmt|;
name|ntxq
operator|=
name|EFX_TXQ_LIMIT_TARGET
expr_stmt|;
block|}
name|encp
operator|->
name|enc_evq_limit
operator|=
name|nevq
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|MIN
argument_list|(
name|EFX_RXQ_LIMIT_TARGET
argument_list|,
name|nrxq
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|MIN
argument_list|(
name|EFX_TXQ_LIMIT_TARGET
argument_list|,
name|ntxq
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_buftbl_limit
operator|=
name|SIENA_SRAM_ROWS
operator|-
operator|(
name|encp
operator|->
name|enc_txq_limit
operator|*
name|EFX_TXQ_DC_NDESCS
argument_list|(
name|EFX_TXQ_DC_SIZE
argument_list|)
operator|)
operator|-
operator|(
name|encp
operator|->
name|enc_rxq_limit
operator|*
name|EFX_RXQ_DC_NDESCS
argument_list|(
name|EFX_RXQ_DC_SIZE
argument_list|)
operator|)
expr_stmt|;
name|encp
operator|->
name|enc_hw_tx_insert_vlan_enabled
operator|=
name|B_FALSE
expr_stmt|;
name|encp
operator|->
name|enc_fw_assisted_tso_enabled
operator|=
name|B_FALSE
expr_stmt|;
name|encp
operator|->
name|enc_fw_assisted_tso_v2_enabled
operator|=
name|B_FALSE
expr_stmt|;
name|encp
operator|->
name|enc_allow_set_mac_with_installed_filters
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|efx_rc_t
name|siena_phy_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* Fill out fields in enp->en_port and enp->en_nic_cfg from MCDI */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|#
directive|if
name|EFSYS_OPT_PHY_STATS
comment|/* Convert the MCDI statistic mask into the EFX_PHY_STAT mask */
name|siena_phy_decode_stats
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_mcdi_phy_stat_mask
argument_list|,
name|NULL
argument_list|,
operator|&
name|encp
operator|->
name|enc_phy_stat_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_STATS */
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nic_probe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|siena_link_state_t
name|sls
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|efx_oword_t
name|oword
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
comment|/* Test BIU */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_biu_test
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Clear the region register */
name|EFX_POPULATE_OWORD_4
argument_list|(
name|oword
argument_list|,
name|FRF_AZ_ADR_REGION0
argument_list|,
literal|0
argument_list|,
name|FRF_AZ_ADR_REGION1
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
argument_list|,
name|FRF_AZ_ADR_REGION2
argument_list|,
operator|(
literal|2
operator|<<
literal|16
operator|)
argument_list|,
name|FRF_AZ_ADR_REGION3
argument_list|,
operator|(
literal|3
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_ADR_REGION_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
comment|/* Read clear any assertion state */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* Exit the assertion handler */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
comment|/* Wrestle control from the BMC */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_drv_attach
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_board_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail5
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
comment|/* Obtain the default PHY advertised capabilities */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_reset
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_phy_get_link
argument_list|(
name|enp
argument_list|,
operator|&
name|sls
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail8
goto|;
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|=
name|sls
operator|.
name|sls_adv_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_adv_cap_mask
operator|=
name|sls
operator|.
name|sls_adv_cap_mask
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_VPD
operator|||
name|EFSYS_OPT_NVRAM
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_get_partn_mask
argument_list|(
name|enp
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail9
goto|;
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_partn_mask
operator|=
name|mask
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
comment|/* Wipe the MAC statistics */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_mac_stats_clear
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail10
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_get_loopback_modes
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail11
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MON_STATS
if|if
condition|(
operator|(
name|rc
operator|=
name|mcdi_mon_cfg_build
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail12
goto|;
endif|#
directive|endif
name|encp
operator|->
name|enc_features
operator|=
name|enp
operator|->
name|en_features
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|fail12
label|:
name|EFSYS_PROBE
argument_list|(
name|fail12
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|fail11
label|:
name|EFSYS_PROBE
argument_list|(
name|fail11
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
name|fail10
label|:
name|EFSYS_PROBE
argument_list|(
name|fail10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_VPD
operator|||
name|EFSYS_OPT_NVRAM
name|fail9
label|:
name|EFSYS_PROBE
argument_list|(
name|fail9
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail8
label|:
name|EFSYS_PROBE
argument_list|(
name|fail8
argument_list|)
expr_stmt|;
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nic_reset
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
comment|/* siena_nic_reset() is called to recover from BADASSERT failures. */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* 	 * Bug24908: ENTITY_RESET_IN_LEN is non zero but zero may be supplied 	 * for backwards compatibility with PORT_RESET_IN_LEN. 	 */
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_ENTITY_RESET_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_ENTITY_RESET
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|siena_nic_rx_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_oword_t
name|oword
decl_stmt|;
comment|/* 	 * RX_INGR_EN is always enabled on Siena, because we rely on 	 * the RX parser to be resiliant to missing SOP/EOP. 	 */
name|EFX_BAR_READO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_CFG_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|EFX_SET_OWORD_FIELD
argument_list|(
name|oword
argument_list|,
name|FRF_BZ_RX_INGR_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_CFG_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
comment|/* Disable parsing of additional 802.1Q in Q packets */
name|EFX_BAR_READO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_FILTER_CTL_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|EFX_SET_OWORD_FIELD
argument_list|(
name|oword
argument_list|,
name|FRF_CZ_RX_FILTER_ALL_VLAN_ETHERTYPES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_FILTER_CTL_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|siena_nic_usrev_dis
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_oword_t
name|oword
decl_stmt|;
name|EFX_POPULATE_OWORD_1
argument_list|(
name|oword
argument_list|,
name|FRF_CZ_USREV_DIS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_CZ_USR_EV_CFG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nic_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_rc_t
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
comment|/* Enable reporting of some events (e.g. link change) */
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_log_ctrl
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|siena_sram_init
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* Configure Siena's RX block */
name|siena_nic_rx_cfg
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* Disable USR_EVents for now */
name|siena_nic_usrev_dis
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* bug17057: Ensure set_link is called */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_phy_reconfigure
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
name|enp
operator|->
name|en_nic_cfg
operator|.
name|enc_mcdi_max_payload_length
operator|=
name|MCDI_CTL_SDU_LEN_MAX_V1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|siena_nic_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
block|}
end_function

begin_function
name|void
name|siena_nic_unprobe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|mcdi_mon_cfg_free
argument_list|(
name|enp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_MON_STATS */
operator|(
name|void
operator|)
name|efx_mcdi_drv_attach
argument_list|(
name|enp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_DIAG
end_if

begin_decl_stmt
specifier|static
name|efx_register_set_t
name|__siena_registers
index|[]
init|=
block|{
block|{
name|FR_AZ_ADR_REGION_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_USR_EV_CFG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_RX_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_TX_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_TX_RESERVED_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_SRM_TX_DC_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_RX_DC_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_RX_DC_PF_WM_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_DP_CTRL_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_BZ_RX_RSS_TKEY_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_RX_RSS_IPV6_REG1_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_RX_RSS_IPV6_REG2_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_RX_RSS_IPV6_REG3_OFST
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|__siena_register_masks
index|[]
init|=
block|{
literal|0x0003FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x000103FF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFE
block|,
literal|0xFFFFFFFF
block|,
literal|0x0003FFFF
block|,
literal|0x00000000
block|,
literal|0x7FFF0037
block|,
literal|0xFFFF8000
block|,
literal|0xFFFFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0xFFFEFE80
block|,
literal|0x1FFFFFFF
block|,
literal|0x020000FE
block|,
literal|0x007FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000003
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x000003FF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000FFF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x00000007
block|,
literal|0x00000000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|efx_register_set_t
name|__siena_tables
index|[]
init|=
block|{
block|{
name|FR_AZ_RX_FILTER_TBL0_OFST
block|,
name|FR_AZ_RX_FILTER_TBL0_STEP
block|,
name|FR_AZ_RX_FILTER_TBL0_ROWS
block|}
block|,
block|{
name|FR_CZ_RX_MAC_FILTER_TBL0_OFST
block|,
name|FR_CZ_RX_MAC_FILTER_TBL0_STEP
block|,
name|FR_CZ_RX_MAC_FILTER_TBL0_ROWS
block|}
block|,
block|{
name|FR_AZ_RX_DESC_PTR_TBL_OFST
block|,
name|FR_AZ_RX_DESC_PTR_TBL_STEP
block|,
name|FR_CZ_RX_DESC_PTR_TBL_ROWS
block|}
block|,
block|{
name|FR_AZ_TX_DESC_PTR_TBL_OFST
block|,
name|FR_AZ_TX_DESC_PTR_TBL_STEP
block|,
name|FR_CZ_TX_DESC_PTR_TBL_ROWS
block|}
block|,
block|{
name|FR_AZ_TIMER_TBL_OFST
block|,
name|FR_AZ_TIMER_TBL_STEP
block|,
name|FR_CZ_TIMER_TBL_ROWS
block|}
block|,
block|{
name|FR_CZ_TX_FILTER_TBL0_OFST
block|,
name|FR_CZ_TX_FILTER_TBL0_STEP
block|,
name|FR_CZ_TX_FILTER_TBL0_ROWS
block|}
block|,
block|{
name|FR_CZ_TX_MAC_FILTER_TBL0_OFST
block|,
name|FR_CZ_TX_MAC_FILTER_TBL0_STEP
block|,
name|FR_CZ_TX_MAC_FILTER_TBL0_ROWS
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|__siena_table_masks
index|[]
init|=
block|{
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x000003FF
block|,
literal|0xFFFF0FFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x00000E7F
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFE
block|,
literal|0x0FFFFFFF
block|,
literal|0x01800000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFE
block|,
literal|0x0FFFFFFF
block|,
literal|0x0C000000
block|,
literal|0x00000000
block|,
literal|0x3FFFFFFF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x000013FF
block|,
literal|0xFFFF07FF
block|,
literal|0xFFFFFFFF
block|,
literal|0x0000007F
block|,
literal|0x00000000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|__checkReturn
name|efx_rc_t
name|siena_nic_register_test
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_register_set_t
modifier|*
name|rsp
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|dwordp
decl_stmt|;
name|unsigned
name|int
name|nitems
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|efx_rc_t
name|rc
decl_stmt|;
comment|/* Fill out the register mask entries */
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_register_masks
argument_list|)
operator|==
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_registers
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_registers
argument_list|)
expr_stmt|;
name|dwordp
operator|=
name|__siena_register_masks
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nitems
condition|;
operator|++
name|count
control|)
block|{
name|rsp
operator|=
name|__siena_registers
operator|+
name|count
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|0
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|1
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|2
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|3
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
block|}
comment|/* Fill out the register table entries */
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_table_masks
argument_list|)
operator|==
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
expr_stmt|;
name|dwordp
operator|=
name|__siena_table_masks
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nitems
condition|;
operator|++
name|count
control|)
block|{
name|rsp
operator|=
name|__siena_tables
operator|+
name|count
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|0
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|1
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|2
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|3
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_registers
argument_list|(
name|enp
argument_list|,
name|__siena_registers
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_registers
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_tables
argument_list|(
name|enp
argument_list|,
name|__siena_tables
argument_list|,
name|EFX_PATTERN_BYTE_ALTERNATE
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_tables
argument_list|(
name|enp
argument_list|,
name|__siena_tables
argument_list|,
name|EFX_PATTERN_BYTE_CHANGING
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_tables
argument_list|(
name|enp
argument_list|,
name|__siena_tables
argument_list|,
name|EFX_PATTERN_BIT_SWEEP
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|efx_rc_t
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_DIAG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_SIENA */
end_comment

end_unit

