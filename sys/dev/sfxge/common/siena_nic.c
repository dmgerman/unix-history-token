begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2009 Solarflare Communications Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_SIENA
end_if

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_nic_get_partn_mask
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__out
name|unsigned
name|int
modifier|*
name|maskp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|outbuf
index|[
name|MC_CMD_NVRAM_TYPES_OUT_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_NVRAM_TYPES
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_NVRAM_TYPES_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_NVRAM_TYPES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
operator|*
name|maskp
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|NVRAM_TYPES_OUT_TYPES
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_nic_exit_assertion_handler
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MC_CMD_REBOOT_IN_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_REBOOT
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_REBOOT_IN_LEN
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_REBOOT_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|REBOOT_IN_FLAGS
argument_list|,
name|MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
operator|&&
name|req
operator|.
name|emr_rc
operator|!=
name|EIO
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_nic_read_assertion
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_ASSERTS_IN_LEN
argument_list|,
name|MC_CMD_GET_ASSERTS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|reason
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|unsigned
name|int
name|ofst
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * Before we attempt to chat to the MC, we should verify that the MC 	 * isn't in it's assertion handler, either due to a previous reboot, 	 * or because we're reinitializing due to an eec_exception(). 	 * 	 * Use GET_ASSERTS to read any assertion state that may be present. 	 * Retry this command twice. Once because a boot-time assertion failure 	 * might cause the 1st MCDI request to fail. And once again because 	 * we might race with siena_nic_exit_assertion_handler() running on the 	 * other port. 	 */
name|retry
operator|=
literal|2
expr_stmt|;
do|do
block|{
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_ASSERTS
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_GET_ASSERTS_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_ASSERTS_OUT_LEN
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|GET_ASSERTS_IN_CLEAR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|req
operator|.
name|emr_rc
operator|==
name|EINTR
operator|||
name|req
operator|.
name|emr_rc
operator|==
name|EIO
operator|)
operator|&&
name|retry
operator|--
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_ASSERTS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
comment|/* Print out any assertion state recorded */
name|flags
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_ASSERTS_OUT_GLOBAL_FLAGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reason
operator|=
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL
operator|)
condition|?
literal|"system-level assertion"
else|:
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL
operator|)
condition|?
literal|"thread-level assertion"
else|:
operator|(
name|flags
operator|==
name|MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED
operator|)
condition|?
literal|"watchdog reset"
else|:
literal|"unknown assertion"
expr_stmt|;
name|EFSYS_PROBE3
argument_list|(
argument|mcpu_assertion
argument_list|,
argument|const char *
argument_list|,
argument|reason
argument_list|,
argument|unsigned int
argument_list|,
argument|MCDI_OUT_DWORD(req, GET_ASSERTS_OUT_SAVED_PC_OFFS)
argument_list|,
argument|unsigned int
argument_list|,
argument|MCDI_OUT_DWORD(req, GET_ASSERTS_OUT_THREAD_OFFS)
argument_list|)
empty_stmt|;
comment|/* Print out the registers */
name|ofst
operator|=
name|MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
init|;
name|index
operator|<
literal|32
condition|;
name|index
operator|++
control|)
block|{
name|EFSYS_PROBE2
argument_list|(
argument|mcpu_register
argument_list|,
argument|unsigned int
argument_list|,
argument|index
argument_list|,
argument|unsigned int
argument_list|,
argument|EFX_DWORD_FIELD(*MCDI_OUT(req, efx_dword_t, ofst), 					    EFX_DWORD_0)
argument_list|)
empty_stmt|;
name|ofst
operator|+=
sizeof|sizeof
argument_list|(
name|efx_dword_t
argument_list|)
expr_stmt|;
block|}
name|EFSYS_ASSERT
argument_list|(
name|ofst
operator|<=
name|MC_CMD_GET_ASSERTS_OUT_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_nic_attach
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|boolean_t
name|attach
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MC_CMD_DRV_ATTACH_IN_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_DRV_ATTACH
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_DRV_ATTACH_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRV_ATTACH_IN_NEW_STATE
argument_list|,
name|attach
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|DRV_ATTACH_IN_UPDATE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_DRV_ATTACH_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_PCIE_TUNE
end_if

begin_function
name|__checkReturn
name|int
name|siena_nic_pcie_extended_sync
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|uint8_t
name|inbuf
index|[
name|MC_CMD_WORKAROUND_IN_LEN
index|]
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_WORKAROUND
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|inbuf
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_WORKAROUND_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|WORKAROUND_IN_TYPE
argument_list|,
name|MC_CMD_WORKAROUND_BUG17230
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|WORKAROUND_IN_ENABLED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_PCIE_TUNE */
end_comment

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_board_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|uint8_t
name|outbuf
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_BOARD_CFG_OUT_LEN
argument_list|,
name|MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Board configuration */
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_BOARD_CFG
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_GET_BOARD_CFG_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_BOARD_CFG_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_BOARD_CFG_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
condition|)
name|src
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0
argument_list|)
expr_stmt|;
else|else
name|src
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|uint8_t
argument_list|,
name|GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1
argument_list|)
expr_stmt|;
name|EFX_MAC_ADDR_COPY
argument_list|(
name|encp
operator|->
name|enc_mac_addr
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_board_type
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_BOARD_CFG_OUT_BOARD_TYPE
argument_list|)
expr_stmt|;
comment|/* Resource limits */
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_RESOURCE_LIMITS
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_GET_RESOURCE_LIMITS_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|encp
operator|->
name|enc_evq_limit
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_RESOURCE_LIMITS_OUT_EVQ
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|MIN
argument_list|(
name|EFX_TXQ_LIMIT_TARGET
argument_list|,
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_RESOURCE_LIMITS_OUT_TXQ
argument_list|)
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|MIN
argument_list|(
name|EFX_RXQ_LIMIT_TARGET
argument_list|,
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_RESOURCE_LIMITS_OUT_RXQ
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|==
name|ENOTSUP
condition|)
block|{
name|encp
operator|->
name|enc_evq_limit
operator|=
literal|1024
expr_stmt|;
name|encp
operator|->
name|enc_txq_limit
operator|=
name|EFX_TXQ_LIMIT_TARGET
expr_stmt|;
name|encp
operator|->
name|enc_rxq_limit
operator|=
name|EFX_RXQ_LIMIT_TARGET
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
name|encp
operator|->
name|enc_buftbl_limit
operator|=
name|SIENA_SRAM_ROWS
operator|-
operator|(
name|encp
operator|->
name|enc_txq_limit
operator|*
literal|16
operator|)
operator|-
operator|(
name|encp
operator|->
name|enc_rxq_limit
operator|*
literal|64
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_phy_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|outbuf
index|[
name|MC_CMD_GET_PHY_CFG_OUT_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_PHY_CFG
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_GET_PHY_CFG_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_PHY_CFG_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|encp
operator|->
name|enc_phy_type
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_TYPE
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_NAMES
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|encp
operator|->
name|enc_phy_name
argument_list|,
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|char
argument_list|,
name|GET_PHY_CFG_OUT_NAME
argument_list|)
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|encp
operator|->
name|enc_phy_name
argument_list|)
operator|-
literal|1
argument_list|,
name|MC_CMD_GET_PHY_CFG_OUT_NAME_LEN
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_NAMES */
operator|(
name|void
operator|)
name|memset
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|,
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|char
argument_list|,
name|GET_PHY_CFG_OUT_REVISION
argument_list|)
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|encp
operator|->
name|enc_phy_revision
argument_list|)
operator|-
literal|1
argument_list|,
name|MC_CMD_GET_PHY_CFG_OUT_REVISION_LEN
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_LED_CONTROL
name|encp
operator|->
name|enc_led_mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|EFX_PHY_LED_DEFAULT
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_PHY_LED_OFF
operator|)
operator||
operator|(
literal|1
operator|<<
name|EFX_PHY_LED_ON
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_LED_CONTROL */
if|#
directive|if
name|EFSYS_OPT_PHY_PROPS
name|encp
operator|->
name|enc_phy_nprops
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_PROPS */
comment|/* Get the media type of the fixed port, if recognised. */
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_XAUI
operator|==
name|EFX_PHY_MEDIA_XAUI
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_CX4
operator|==
name|EFX_PHY_MEDIA_CX4
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_KX4
operator|==
name|EFX_PHY_MEDIA_KX4
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_XFP
operator|==
name|EFX_PHY_MEDIA_XFP
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_SFP_PLUS
operator|==
name|EFX_PHY_MEDIA_SFP_PLUS
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_MEDIA_BASE_T
operator|==
name|EFX_PHY_MEDIA_BASE_T
argument_list|)
expr_stmt|;
name|epp
operator|->
name|ep_fixed_port_type
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_MEDIA_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|epp
operator|->
name|ep_fixed_port_type
operator|>=
name|EFX_PHY_MEDIA_NTYPES
condition|)
name|epp
operator|->
name|ep_fixed_port_type
operator|=
name|EFX_PHY_MEDIA_INVALID
expr_stmt|;
name|epp
operator|->
name|ep_phy_cap_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_SUPPORTED_CAP
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_FLAGS
name|encp
operator|->
name|enc_phy_flags_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_FLAGS */
name|encp
operator|->
name|enc_port
operator|=
operator|(
name|uint8_t
operator|)
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_PRT
argument_list|)
expr_stmt|;
comment|/* Populate internal state */
name|encp
operator|->
name|enc_siena_channel
operator|=
operator|(
name|uint8_t
operator|)
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_CHANNEL
argument_list|)
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_PHY_STATS
name|encp
operator|->
name|enc_siena_phy_stat_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_STATS_MASK
argument_list|)
expr_stmt|;
comment|/* Convert the MCDI statistic mask into the EFX_PHY_STAT mask */
name|siena_phy_decode_stats
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_siena_phy_stat_mask
argument_list|,
name|NULL
argument_list|,
operator|&
name|encp
operator|->
name|enc_phy_stat_mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_PHY_STATS */
if|#
directive|if
name|EFSYS_OPT_PHY_BIST
name|encp
operator|->
name|enc_bist_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|,
name|GET_PHY_CFG_OUT_BIST_CABLE_SHORT
argument_list|)
condition|)
name|encp
operator|->
name|enc_bist_mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_BIST_TYPE_CABLE_SHORT
operator|)
expr_stmt|;
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|,
name|GET_PHY_CFG_OUT_BIST_CABLE_LONG
argument_list|)
condition|)
name|encp
operator|->
name|enc_bist_mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_BIST_TYPE_CABLE_LONG
operator|)
expr_stmt|;
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_PHY_CFG_OUT_FLAGS
argument_list|,
name|GET_PHY_CFG_OUT_BIST
argument_list|)
condition|)
name|encp
operator|->
name|enc_bist_mask
operator||=
operator|(
literal|1
operator|<<
name|EFX_PHY_BIST_TYPE_NORMAL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* EFSYS_OPT_BIST */
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
end_if

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_loopback_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|outbuf
index|[
name|MC_CMD_GET_LOOPBACK_MODES_OUT_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_LOOPBACK_MODES
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_GET_LOOPBACK_MODES_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_LOOPBACK_MODES_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
comment|/* 	 * We assert the MC_CMD_LOOPBACK and EFX_LOOPBACK namespaces agree 	 * in siena_phy.c:siena_phy_get_link() 	 */
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_100FDX
index|]
operator|=
name|EFX_LOOPBACK_MASK
operator|&
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LOOPBACK_MODES_OUT_100M
argument_list|)
operator|&
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LOOPBACK_MODES_OUT_SUGGESTED
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_1000FDX
index|]
operator|=
name|EFX_LOOPBACK_MASK
operator|&
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LOOPBACK_MODES_OUT_1G
argument_list|)
operator|&
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LOOPBACK_MODES_OUT_SUGGESTED
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_10000FDX
index|]
operator|=
name|EFX_LOOPBACK_MASK
operator|&
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LOOPBACK_MODES_OUT_10G
argument_list|)
operator|&
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_LOOPBACK_MODES_OUT_SUGGESTED
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_UNKNOWN
index|]
operator|=
operator|(
literal|1
operator|<<
name|EFX_LOOPBACK_OFF
operator|)
operator||
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_100FDX
index|]
operator||
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_1000FDX
index|]
operator||
name|encp
operator|->
name|enc_loopback_types
index|[
name|EFX_LINK_10000FDX
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_LOOPBACK */
end_comment

begin_if
if|#
directive|if
name|EFSYS_OPT_MON_STATS
end_if

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_monitor_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|outbuf
index|[
name|MCDI_CTL_SDU_LEN_MAX
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_SENSOR_INFO
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_SENSOR_INFO_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_SENSOR_INFO_OUT_MASK_OFST
operator|+
literal|4
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|encp
operator|->
name|enc_siena_mon_stat_mask
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|SENSOR_INFO_OUT_MASK
argument_list|)
expr_stmt|;
name|encp
operator|->
name|enc_mon_type
operator|=
name|EFX_MON_SFC90X0
expr_stmt|;
name|siena_mon_decode_stats
argument_list|(
name|enp
argument_list|,
name|encp
operator|->
name|enc_siena_mon_stat_mask
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|encp
operator|->
name|enc_mon_stat_mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MON_STATS */
end_comment

begin_function
name|__checkReturn
name|int
name|siena_nic_probe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_port_t
modifier|*
name|epp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_port
operator|)
decl_stmt|;
name|efx_nic_cfg_t
modifier|*
name|encp
init|=
operator|&
operator|(
name|enp
operator|->
name|en_nic_cfg
operator|)
decl_stmt|;
name|siena_link_state_t
name|sls
decl_stmt|;
name|unsigned
name|int
name|mask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
comment|/* XXX: pacify gcc */
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
comment|/* Read clear any assertion state */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
comment|/* Exit the assertion handler */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
comment|/* Wrestle control from the BMC */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_attach
argument_list|(
name|enp
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_board_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
name|encp
operator|->
name|enc_evq_moderation_max
operator|=
name|EFX_EV_TIMER_QUANTUM
operator|<<
name|FRF_CZ_TIMER_VAL_WIDTH
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_phy_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail5
goto|;
comment|/* Obtain the default PHY advertised capabilities */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_reset
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail6
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_phy_get_link
argument_list|(
name|enp
argument_list|,
operator|&
name|sls
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail7
goto|;
name|epp
operator|->
name|ep_default_adv_cap_mask
operator|=
name|sls
operator|.
name|sls_adv_cap_mask
expr_stmt|;
name|epp
operator|->
name|ep_adv_cap_mask
operator|=
name|sls
operator|.
name|sls_adv_cap_mask
expr_stmt|;
if|#
directive|if
name|EFSYS_OPT_VPD
operator|||
name|EFSYS_OPT_NVRAM
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_get_partn_mask
argument_list|(
name|enp
argument_list|,
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail8
goto|;
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_partn_mask
operator|=
name|mask
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
comment|/* Wipe the MAC statistics */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_mac_stats_clear
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail9
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_loopback_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail10
goto|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MON_STATS
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_monitor_cfg
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail11
goto|;
endif|#
directive|endif
name|encp
operator|->
name|enc_features
operator|=
name|enp
operator|->
name|en_features
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|EFSYS_OPT_MON_STATS
name|fail11
label|:
name|EFSYS_PROBE
argument_list|(
name|fail11
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_LOOPBACK
name|fail10
label|:
name|EFSYS_PROBE
argument_list|(
name|fail10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_MAC_STATS
name|fail9
label|:
name|EFSYS_PROBE
argument_list|(
name|fail9
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|EFSYS_OPT_VPD
operator|||
name|EFSYS_OPT_NVRAM
name|fail8
label|:
name|EFSYS_PROBE
argument_list|(
name|fail8
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fail7
label|:
name|EFSYS_PROBE
argument_list|(
name|fail7
argument_list|)
expr_stmt|;
name|fail6
label|:
name|EFSYS_PROBE
argument_list|(
name|fail6
argument_list|)
expr_stmt|;
name|fail5
label|:
name|EFSYS_PROBE
argument_list|(
name|fail5
argument_list|)
expr_stmt|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|int
name|siena_nic_reset
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
comment|/* siena_nic_reset() is called to recover from BADASSERT failures. */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_read_assertion
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_exit_assertion_handler
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_PORT_RESET
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_PORT_RESET_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_PORT_RESET_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__checkReturn
name|int
name|siena_nic_logging
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|uint8_t
name|payload
index|[
name|MC_CMD_LOG_CTRL_IN_LEN
index|]
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_LOG_CTRL
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_LOG_CTRL_IN_LEN
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_LOG_CTRL_OUT_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LOG_CTRL_IN_LOG_DEST
argument_list|,
name|MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ
argument_list|)
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|LOG_CTRL_IN_LOG_DEST_EVQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|siena_nic_rx_cfg
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_oword_t
name|oword
decl_stmt|;
comment|/* 	 * RX_INGR_EN is always enabled on Siena, because we rely on 	 * the RX parser to be resiliant to missing SOP/EOP. 	 */
name|EFX_BAR_READO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_CFG_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|EFX_SET_OWORD_FIELD
argument_list|(
name|oword
argument_list|,
name|FRF_BZ_RX_INGR_EN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_CFG_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
comment|/* Disable parsing of additional 802.1Q in Q packets */
name|EFX_BAR_READO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_FILTER_CTL_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|EFX_SET_OWORD_FIELD
argument_list|(
name|oword
argument_list|,
name|FRF_CZ_RX_FILTER_ALL_VLAN_ETHERTYPES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_RX_FILTER_CTL_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|siena_nic_usrev_dis
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_oword_t
name|oword
decl_stmt|;
name|EFX_POPULATE_OWORD_1
argument_list|(
name|oword
argument_list|,
name|FRF_CZ_USREV_DIS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|EFX_BAR_WRITEO
argument_list|(
name|enp
argument_list|,
name|FR_CZ_USR_EV_CFG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|__checkReturn
name|int
name|siena_nic_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_nic_logging
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
name|siena_sram_init
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* Configure Siena's RX block */
name|siena_nic_rx_cfg
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* Disable USR_EVents for now */
name|siena_nic_usrev_dis
argument_list|(
name|enp
argument_list|)
expr_stmt|;
comment|/* bug17057: Ensure set_link is called */
if|if
condition|(
operator|(
name|rc
operator|=
name|siena_phy_reconfigure
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|siena_nic_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|_NOTE
argument_list|(
argument|ARGUNUSED(enp)
argument_list|)
block|}
end_function

begin_function
name|void
name|siena_nic_unprobe
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
operator|(
name|void
operator|)
name|siena_nic_attach
argument_list|(
name|enp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|EFSYS_OPT_DIAG
end_if

begin_decl_stmt
specifier|static
name|efx_register_set_t
name|__cs
name|__siena_registers
index|[]
init|=
block|{
block|{
name|FR_AZ_ADR_REGION_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_USR_EV_CFG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_RX_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_TX_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_TX_RESERVED_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_SRM_TX_DC_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_RX_DC_CFG_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_RX_DC_PF_WM_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_AZ_DP_CTRL_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_BZ_RX_RSS_TKEY_REG_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_RX_RSS_IPV6_REG1_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_RX_RSS_IPV6_REG2_OFST
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
name|FR_CZ_RX_RSS_IPV6_REG3_OFST
block|,
literal|0
block|,
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|__cs
name|__siena_register_masks
index|[]
init|=
block|{
literal|0x0003FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x0003FFFF
block|,
literal|0x000103FF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFE
block|,
literal|0xFFFFFFFF
block|,
literal|0x0003FFFF
block|,
literal|0x00000000
block|,
literal|0x7FFF0037
block|,
literal|0xFFFF8000
block|,
literal|0xFFFFFFFF
block|,
literal|0x03FFFFFF
block|,
literal|0xFFFEFE80
block|,
literal|0x1FFFFFFF
block|,
literal|0x020000FE
block|,
literal|0x007FFFFF
block|,
literal|0x001FFFFF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000003
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x000003FF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000FFF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x00000007
block|,
literal|0x00000000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|efx_register_set_t
name|__cs
name|__siena_tables
index|[]
init|=
block|{
block|{
name|FR_AZ_RX_FILTER_TBL0_OFST
block|,
name|FR_AZ_RX_FILTER_TBL0_STEP
block|,
name|FR_AZ_RX_FILTER_TBL0_ROWS
block|}
block|,
block|{
name|FR_CZ_RX_MAC_FILTER_TBL0_OFST
block|,
name|FR_CZ_RX_MAC_FILTER_TBL0_STEP
block|,
name|FR_CZ_RX_MAC_FILTER_TBL0_ROWS
block|}
block|,
block|{
name|FR_AZ_RX_DESC_PTR_TBL_OFST
block|,
name|FR_AZ_RX_DESC_PTR_TBL_STEP
block|,
name|FR_CZ_RX_DESC_PTR_TBL_ROWS
block|}
block|,
block|{
name|FR_AZ_TX_DESC_PTR_TBL_OFST
block|,
name|FR_AZ_TX_DESC_PTR_TBL_STEP
block|,
name|FR_CZ_TX_DESC_PTR_TBL_ROWS
block|}
block|,
block|{
name|FR_AZ_TIMER_TBL_OFST
block|,
name|FR_AZ_TIMER_TBL_STEP
block|,
name|FR_CZ_TIMER_TBL_ROWS
block|}
block|,
block|{
name|FR_CZ_TX_FILTER_TBL0_OFST
block|,
name|FR_CZ_TX_FILTER_TBL0_STEP
block|,
name|FR_CZ_TX_FILTER_TBL0_ROWS
block|}
block|,
block|{
name|FR_CZ_TX_MAC_FILTER_TBL0_OFST
block|,
name|FR_CZ_TX_MAC_FILTER_TBL0_STEP
block|,
name|FR_CZ_TX_MAC_FILTER_TBL0_ROWS
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|__cs
name|__siena_table_masks
index|[]
init|=
block|{
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x000003FF
block|,
literal|0xFFFF0FFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x00000E7F
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFF
block|,
literal|0x0FFFFFFF
block|,
literal|0x01800000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFE
block|,
literal|0x0FFFFFFF
block|,
literal|0x0C000000
block|,
literal|0x00000000
block|,
literal|0x3FFFFFFF
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0x00000000
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0xFFFFFFFF
block|,
literal|0x000013FF
block|,
literal|0xFFFF07FF
block|,
literal|0xFFFFFFFF
block|,
literal|0x0000007F
block|,
literal|0x00000000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|__checkReturn
name|int
name|siena_nic_register_test
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_register_set_t
modifier|*
name|rsp
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|dwordp
decl_stmt|;
name|unsigned
name|int
name|nitems
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Fill out the register mask entries */
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_register_masks
argument_list|)
operator|==
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_registers
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_registers
argument_list|)
expr_stmt|;
name|dwordp
operator|=
name|__siena_register_masks
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nitems
condition|;
operator|++
name|count
control|)
block|{
name|rsp
operator|=
name|__siena_registers
operator|+
name|count
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|0
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|1
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|2
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|3
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
block|}
comment|/* Fill out the register table entries */
name|EFX_STATIC_ASSERT
argument_list|(
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_table_masks
argument_list|)
operator|==
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|nitems
operator|=
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
expr_stmt|;
name|dwordp
operator|=
name|__siena_table_masks
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nitems
condition|;
operator|++
name|count
control|)
block|{
name|rsp
operator|=
name|__siena_tables
operator|+
name|count
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|0
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|1
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|2
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
name|rsp
operator|->
name|mask
operator|.
name|eo_u32
index|[
literal|3
index|]
operator|=
operator|*
name|dwordp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_registers
argument_list|(
name|enp
argument_list|,
name|__siena_registers
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_registers
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_tables
argument_list|(
name|enp
argument_list|,
name|__siena_tables
argument_list|,
name|EFX_PATTERN_BYTE_ALTERNATE
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail2
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_tables
argument_list|(
name|enp
argument_list|,
name|__siena_tables
argument_list|,
name|EFX_PATTERN_BYTE_CHANGING
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail3
goto|;
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_nic_test_tables
argument_list|(
name|enp
argument_list|,
name|__siena_tables
argument_list|,
name|EFX_PATTERN_BIT_SWEEP
argument_list|,
name|EFX_ARRAY_SIZE
argument_list|(
name|__siena_tables
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail4
goto|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_DIAG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_SIENA */
end_comment

end_unit

