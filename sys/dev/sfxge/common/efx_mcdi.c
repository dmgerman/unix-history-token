begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2008-2009 Solarflare Communications Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"efsys.h"
end_include

begin_include
include|#
directive|include
file|"efx.h"
end_include

begin_include
include|#
directive|include
file|"efx_types.h"
end_include

begin_include
include|#
directive|include
file|"efx_regs.h"
end_include

begin_include
include|#
directive|include
file|"efx_regs_mcdi.h"
end_include

begin_include
include|#
directive|include
file|"efx_impl.h"
end_include

begin_if
if|#
directive|if
name|EFSYS_OPT_MCDI
end_if

begin_comment
comment|/* Shared memory layout */
end_comment

begin_define
define|#
directive|define
name|MCDI_P1_DBL_OFST
value|0x0
end_define

begin_define
define|#
directive|define
name|MCDI_P2_DBL_OFST
value|0x1
end_define

begin_define
define|#
directive|define
name|MCDI_P1_PDU_OFST
value|0x2
end_define

begin_define
define|#
directive|define
name|MCDI_P2_PDU_OFST
value|0x42
end_define

begin_define
define|#
directive|define
name|MCDI_P1_REBOOT_OFST
value|0x1fe
end_define

begin_define
define|#
directive|define
name|MCDI_P2_REBOOT_OFST
value|0x1ff
end_define

begin_comment
comment|/*  * A reboot/assertion causes the MCDI status word to be set after the  * command word is set or a REBOOT event is sent. If we notice a reboot  * via these mechanisms then wait 10ms for the status word to be set.  */
end_comment

begin_define
define|#
directive|define
name|MCDI_STATUS_SLEEP_US
value|10000
end_define

begin_function
name|void
name|efx_mcdi_request_start
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|,
name|__in
name|boolean_t
name|ev_cpl
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|unsigned
name|int
name|xflags
decl_stmt|;
name|unsigned
name|int
name|pdur
decl_stmt|;
name|unsigned
name|int
name|dbr
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|int
name|state
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|emip
operator|->
name|emi_port
condition|)
block|{
case|case
literal|1
case|:
name|pdur
operator|=
name|MCDI_P1_PDU_OFST
expr_stmt|;
name|dbr
operator|=
name|MCDI_P1_DBL_OFST
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pdur
operator|=
name|MCDI_P2_PDU_OFST
expr_stmt|;
name|dbr
operator|=
name|MCDI_P2_DBL_OFST
expr_stmt|;
break|break;
default|default:
name|EFSYS_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pdur
operator|=
name|dbr
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* 	 * efx_mcdi_request_start() is naturally serialised against both 	 * efx_mcdi_request_poll() and efx_mcdi_ev_cpl()/efx_mcdi_ev_death(), 	 * by virtue of there only being one outstanding MCDI request. 	 * Unfortunately, upper layers may also call efx_mcdi_request_abort() 	 * at any time, to timeout a pending mcdi request, That request may 	 * then subsequently complete, meaning efx_mcdi_ev_cpl() or 	 * efx_mcdi_ev_death() may end up running in parallel with 	 * efx_mcdi_request_start(). This race is handled by ensuring that 	 * %emi_pending_req, %emi_ev_cpl and %emi_seq are protected by the 	 * en_eslp lock. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_pending_req
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|emip
operator|->
name|emi_pending_req
operator|=
name|emrp
expr_stmt|;
name|emip
operator|->
name|emi_ev_cpl
operator|=
name|ev_cpl
expr_stmt|;
name|emip
operator|->
name|emi_poll_cnt
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
name|emip
operator|->
name|emi_seq
operator|++
operator|&
literal|0xf
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|xflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ev_cpl
condition|)
name|xflags
operator||=
name|MCDI_HEADER_XFLAGS_EVREQ
expr_stmt|;
comment|/* Construct the header in shared memory */
name|EFX_POPULATE_DWORD_6
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_CODE
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|MCDI_HEADER_RESYNC
argument_list|,
literal|1
argument_list|,
name|MCDI_HEADER_DATALEN
argument_list|,
name|emrp
operator|->
name|emr_in_length
argument_list|,
name|MCDI_HEADER_SEQ
argument_list|,
name|seq
argument_list|,
name|MCDI_HEADER_RESPONSE
argument_list|,
literal|0
argument_list|,
name|MCDI_HEADER_XFLAGS
argument_list|,
name|xflags
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|pdur
argument_list|,
operator|&
name|dword
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|emrp
operator|->
name|emr_in_length
condition|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|efx_dword_t
argument_list|)
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|dword
argument_list|,
name|MCDI_IN
argument_list|(
operator|*
name|emrp
argument_list|,
name|efx_dword_t
argument_list|,
name|pos
argument_list|)
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|dword
argument_list|)
argument_list|,
name|emrp
operator|->
name|emr_in_length
operator|-
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|pdur
operator|+
literal|1
operator|+
operator|(
name|pos
operator|>>
literal|2
operator|)
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* Ring the doorbell */
name|EFX_POPULATE_DWORD_1
argument_list|(
name|dword
argument_list|,
name|EFX_DWORD_0
argument_list|,
literal|0xd004be11
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|dbr
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|efx_mcdi_request_copyout
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|unsigned
name|int
name|pos
decl_stmt|;
name|unsigned
name|int
name|pdur
decl_stmt|;
name|efx_dword_t
name|data
decl_stmt|;
name|pdur
operator|=
operator|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
operator|)
condition|?
name|MCDI_P1_PDU_OFST
else|:
name|MCDI_P2_PDU_OFST
expr_stmt|;
comment|/* Copy payload out if caller supplied buffer */
if|if
condition|(
name|emrp
operator|->
name|emr_out_buf
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|bytes
init|=
name|MIN
argument_list|(
name|emrp
operator|->
name|emr_out_length_used
argument_list|,
name|emrp
operator|->
name|emr_out_length
argument_list|)
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|bytes
condition|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|efx_dword_t
argument_list|)
control|)
block|{
name|EFX_BAR_TBL_READD
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|pdur
operator|+
literal|1
operator|+
operator|(
name|pos
operator|>>
literal|2
operator|)
argument_list|,
operator|&
name|data
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|MCDI_OUT
argument_list|(
operator|*
name|emrp
argument_list|,
name|efx_dword_t
argument_list|,
name|pos
argument_list|)
argument_list|,
operator|&
name|data
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|,
name|bytes
operator|-
name|pos
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|efx_mcdi_request_errcode
parameter_list|(
name|__in
name|unsigned
name|int
name|err
parameter_list|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|MC_CMD_ERR_ENOENT
case|:
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|MC_CMD_ERR_EINTR
case|:
return|return
operator|(
name|EINTR
operator|)
return|;
case|case
name|MC_CMD_ERR_EACCES
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
name|MC_CMD_ERR_EBUSY
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|MC_CMD_ERR_EINVAL
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MC_CMD_ERR_EDEADLK
case|:
return|return
operator|(
name|EDEADLK
operator|)
return|;
case|case
name|MC_CMD_ERR_ENOSYS
case|:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
case|case
name|MC_CMD_ERR_ETIME
case|:
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
ifdef|#
directive|ifdef
name|WITH_MCDI_V2
case|case
name|MC_CMD_ERR_EAGAIN
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
case|case
name|MC_CMD_ERR_ENOSPC
case|:
return|return
operator|(
name|ENOSPC
operator|)
return|;
endif|#
directive|endif
default|default:
name|EFSYS_PROBE1
argument_list|(
name|mc_pcol_error
argument_list|,
name|int
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|efx_mcdi_raise_exception
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in_opt
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|,
name|__in
name|int
name|rc
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|emip
operator|->
name|emi_mtp
decl_stmt|;
name|efx_mcdi_exception_t
name|exception
decl_stmt|;
comment|/* Reboot or Assertion failure only */
name|EFSYS_ASSERT
argument_list|(
name|rc
operator|==
name|EIO
operator|||
name|rc
operator|==
name|EINTR
argument_list|)
expr_stmt|;
comment|/* 	 * If MC_CMD_REBOOT causes a reboot (dependent on parameters), 	 * then the EIO is not worthy of an exception. 	 */
if|if
condition|(
name|emrp
operator|!=
name|NULL
operator|&&
name|emrp
operator|->
name|emr_cmd
operator|==
name|MC_CMD_REBOOT
operator|&&
name|rc
operator|==
name|EIO
condition|)
return|return;
name|exception
operator|=
operator|(
name|rc
operator|==
name|EIO
operator|)
condition|?
name|EFX_MCDI_EXCEPTION_MC_REBOOT
else|:
name|EFX_MCDI_EXCEPTION_MC_BADASSERT
expr_stmt|;
name|emtp
operator|->
name|emt_exception
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|exception
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|efx_mcdi_poll_reboot
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|unsigned
name|int
name|rebootr
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
operator|||
name|emip
operator|->
name|emi_port
operator|==
literal|2
argument_list|)
expr_stmt|;
name|rebootr
operator|=
operator|(
operator|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
operator|)
condition|?
name|MCDI_P1_REBOOT_OFST
else|:
name|MCDI_P2_REBOOT_OFST
operator|)
expr_stmt|;
name|EFX_BAR_TBL_READD
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|rebootr
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|value
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EFX_ZERO_DWORD
argument_list|(
name|dword
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_WRITED
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|rebootr
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|MC_STATUS_DWORD_ASSERT
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
else|else
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|boolean_t
name|efx_mcdi_request_poll
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
decl_stmt|;
name|efx_dword_t
name|dword
decl_stmt|;
name|unsigned
name|int
name|pdur
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* Serialise against post-watchdog efx_mcdi_ev* */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_pending_req
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT
argument_list|(
operator|!
name|emip
operator|->
name|emi_ev_cpl
argument_list|)
expr_stmt|;
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
comment|/* Check for reboot atomically w.r.t efx_mcdi_request_start */
if|if
condition|(
name|emip
operator|->
name|emi_poll_cnt
operator|++
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
block|}
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
operator|||
name|emip
operator|->
name|emi_port
operator|==
literal|2
argument_list|)
expr_stmt|;
name|pdur
operator|=
operator|(
name|emip
operator|->
name|emi_port
operator|==
literal|1
operator|)
condition|?
name|MCDI_P1_PDU_OFST
else|:
name|MCDI_P2_PDU_OFST
expr_stmt|;
comment|/* Read the command header */
name|EFX_BAR_TBL_READD
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|pdur
argument_list|,
operator|&
name|dword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_RESPONSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
comment|/* Request complete */
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|seq
operator|=
operator|(
name|emip
operator|->
name|emi_seq
operator|-
literal|1
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|/* Check for synchronous reboot */
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_ERROR
argument_list|)
operator|!=
literal|0
operator|&&
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_DATALEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Consume status word */
name|EFSYS_SPIN
argument_list|(
name|MCDI_STATUS_SLEEP_US
argument_list|)
expr_stmt|;
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* Check that the returned data is consistent */
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_CODE
argument_list|)
operator|!=
name|emrp
operator|->
name|emr_cmd
operator|||
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_SEQ
argument_list|)
operator|!=
name|seq
condition|)
block|{
comment|/* Response is for a different request */
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|length
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_DATALEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|EFX_DWORD_FIELD
argument_list|(
name|dword
argument_list|,
name|MCDI_HEADER_ERROR
argument_list|)
condition|)
block|{
name|efx_dword_t
name|errdword
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|length
argument_list|,
operator|==
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|EFX_BAR_TBL_READD
argument_list|(
name|enp
argument_list|,
name|FR_CZ_MC_TREG_SMEM
argument_list|,
name|pdur
operator|+
literal|1
operator|+
operator|(
name|MC_CMD_ERR_CODE_OFST
operator|>>
literal|2
operator|)
argument_list|,
operator|&
name|errdword
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|EFX_DWORD_FIELD
argument_list|(
name|errdword
argument_list|,
name|EFX_DWORD_0
argument_list|)
expr_stmt|;
name|rc
operator|=
name|efx_mcdi_request_errcode
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
name|EFSYS_PROBE2
argument_list|(
name|mcdi_err
argument_list|,
name|int
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|int
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
else|else
block|{
name|emrp
operator|->
name|emr_out_length_used
operator|=
name|length
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_request_copyout
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
comment|/* Fill out error state */
name|emrp
operator|->
name|emr_rc
operator|=
name|rc
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
comment|/* Reboot/Assertion */
if|if
condition|(
name|rc
operator|==
name|EIO
operator|||
name|rc
operator|==
name|EINTR
condition|)
name|efx_mcdi_raise_exception
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_execute
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|efx_mcdi_req_t
modifier|*
name|emrp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|emip
operator|->
name|emi_mtp
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
name|emtp
operator|->
name|emt_execute
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_ev_cpl
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|unsigned
name|int
name|seq
parameter_list|,
name|__in
name|unsigned
name|int
name|outlen
parameter_list|,
name|__in
name|int
name|errcode
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|emip
operator|->
name|emi_mtp
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
decl_stmt|;
name|int
name|state
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|&
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* 	 * Serialise against efx_mcdi_request_poll()/efx_mcdi_request_start() 	 * when we're completing an aborted request. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_pending_req
operator|==
name|NULL
operator|||
operator|!
name|emip
operator|->
name|emi_ev_cpl
operator|||
operator|(
name|seq
operator|!=
operator|(
operator|(
name|emip
operator|->
name|emi_seq
operator|-
literal|1
operator|)
operator|&
literal|0xf
operator|)
operator|)
condition|)
block|{
name|EFSYS_ASSERT
argument_list|(
name|emip
operator|->
name|emi_aborted
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|emip
operator|->
name|emi_aborted
operator|>
literal|0
condition|)
operator|--
name|emip
operator|->
name|emi_aborted
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* 	 * Fill out the remaining hdr fields, and copyout the payload 	 * if the user supplied an output buffer. 	 */
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|EFSYS_PROBE2
argument_list|(
name|mcdi_err
argument_list|,
name|int
argument_list|,
name|emrp
operator|->
name|emr_cmd
argument_list|,
name|int
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
name|efx_mcdi_request_errcode
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emrp
operator|->
name|emr_out_length_used
operator|=
name|outlen
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
literal|0
expr_stmt|;
name|efx_mcdi_request_copyout
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|)
expr_stmt|;
block|}
name|emtp
operator|->
name|emt_ev_cpl
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_ev_death
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
name|int
name|rc
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|emtp
init|=
name|emip
operator|->
name|emi_mtp
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|ev_cpl
decl_stmt|;
name|int
name|state
decl_stmt|;
comment|/* 	 * The MCDI request (if there is one) has been terminated, either 	 * by a BADASSERT or REBOOT event. 	 * 	 * If there is an outstanding event-completed MCDI operation, then we 	 * will never receive the completion event (because both MCDI 	 * completions and BADASSERT events are sent to the same evq). So 	 * complete this MCDI op. 	 * 	 * This function might run in parallel with efx_mcdi_request_poll() 	 * for poll completed mcdi requests, and also with 	 * efx_mcdi_request_start() for post-watchdog completions. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
name|ev_cpl
operator|=
name|emip
operator|->
name|emi_ev_cpl
expr_stmt|;
if|if
condition|(
name|emrp
operator|!=
name|NULL
operator|&&
name|emip
operator|->
name|emi_ev_cpl
condition|)
block|{
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
name|rc
expr_stmt|;
operator|++
name|emip
operator|->
name|emi_aborted
expr_stmt|;
block|}
comment|/* 	 * Since we're running in parallel with a request, consume the 	 * status word before dropping the lock. 	 */
if|if
condition|(
name|rc
operator|==
name|EIO
operator|||
name|rc
operator|==
name|EINTR
condition|)
block|{
name|EFSYS_SPIN
argument_list|(
name|MCDI_STATUS_SLEEP_US
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
expr_stmt|;
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|efx_mcdi_raise_exception
argument_list|(
name|enp
argument_list|,
name|emrp
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|emrp
operator|!=
name|NULL
operator|&&
name|ev_cpl
condition|)
name|emtp
operator|->
name|emt_ev_cpl
argument_list|(
name|emtp
operator|->
name|emt_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|__checkReturn
name|int
name|efx_mcdi_version
argument_list|(
name|__in
name|efx_nic_t
operator|*
name|enp
argument_list|,
name|__out_ecount_opt
argument_list|(
literal|4
argument_list|)
name|uint16_t
name|versionp
index|[
literal|4
index|]
argument_list|,
name|__out_opt
name|uint32_t
operator|*
name|buildp
argument_list|,
name|__out_opt
name|efx_mcdi_boot_t
operator|*
name|statusp
argument_list|)
block|{
name|uint8_t
name|outbuf
index|[
name|MAX
argument_list|(
name|MC_CMD_GET_VERSION_OUT_LEN
argument_list|,
name|MC_CMD_GET_BOOT_STATUS_OUT_LEN
argument_list|)
index|]
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|efx_word_t
modifier|*
name|ver_words
decl_stmt|;
name|uint16_t
name|version
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|build
decl_stmt|;
name|efx_mcdi_boot_t
name|status
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_GET_VERSION_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_VERSION
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_VERSION_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* bootrom support */
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|==
name|MC_CMD_GET_VERSION_V0_OUT_LEN
condition|)
block|{
name|version
index|[
literal|0
index|]
operator|=
name|version
index|[
literal|1
index|]
operator|=
name|version
index|[
literal|2
index|]
operator|=
name|version
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|build
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VERSION_OUT_FIRMWARE
argument_list|)
expr_stmt|;
goto|goto
name|version
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_VERSION_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|ver_words
operator|=
name|MCDI_OUT2
argument_list|(
name|req
argument_list|,
name|efx_word_t
argument_list|,
name|GET_VERSION_OUT_VERSION
argument_list|)
expr_stmt|;
name|version
index|[
literal|0
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|0
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|version
index|[
literal|1
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|1
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|version
index|[
literal|2
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|2
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|version
index|[
literal|3
index|]
operator|=
name|EFX_WORD_FIELD
argument_list|(
name|ver_words
index|[
literal|3
index|]
argument_list|,
name|EFX_WORD_0
argument_list|)
expr_stmt|;
name|build
operator|=
name|MCDI_OUT_DWORD
argument_list|(
name|req
argument_list|,
name|GET_VERSION_OUT_FIRMWARE
argument_list|)
expr_stmt|;
name|version
label|:
comment|/* The bootrom doesn't understand BOOT_STATUS */
if|if
condition|(
name|build
operator|==
name|MC_CMD_GET_VERSION_OUT_FIRMWARE_SIENA_BOOTROM
condition|)
block|{
name|status
operator|=
name|EFX_MCDI_BOOT_ROM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_GET_BOOT_STATUS
expr_stmt|;
name|EFX_STATIC_ASSERT
argument_list|(
name|MC_CMD_GET_BOOT_STATUS_IN_LEN
operator|==
literal|0
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
literal|0
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|outbuf
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
name|MC_CMD_GET_BOOT_STATUS_OUT_LEN
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
literal|0
condition|)
block|{
name|rc
operator|=
name|req
operator|.
name|emr_rc
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
if|if
condition|(
name|req
operator|.
name|emr_out_length_used
operator|<
name|MC_CMD_GET_BOOT_STATUS_OUT_LEN
condition|)
block|{
name|rc
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|fail4
goto|;
block|}
if|if
condition|(
name|MCDI_OUT_DWORD_FIELD
argument_list|(
name|req
argument_list|,
name|GET_BOOT_STATUS_OUT_FLAGS
argument_list|,
name|GET_BOOT_STATUS_OUT_FLAGS_PRIMARY
argument_list|)
condition|)
name|status
operator|=
name|EFX_MCDI_BOOT_PRIMARY
expr_stmt|;
else|else
name|status
operator|=
name|EFX_MCDI_BOOT_SECONDARY
expr_stmt|;
name|out
label|:
if|if
condition|(
name|versionp
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|versionp
argument_list|,
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buildp
operator|!=
name|NULL
condition|)
operator|*
name|buildp
operator|=
name|build
expr_stmt|;
if|if
condition|(
name|statusp
operator|!=
name|NULL
condition|)
operator|*
name|statusp
operator|=
name|status
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail4
label|:
name|EFSYS_PROBE
argument_list|(
name|fail4
argument_list|)
expr_stmt|;
name|fail3
label|:
name|EFSYS_PROBE
argument_list|(
name|fail3
argument_list|)
expr_stmt|;
name|fail2
label|:
name|EFSYS_PROBE
argument_list|(
name|fail2
argument_list|)
expr_stmt|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_decl_stmt

begin_function
name|__checkReturn
name|int
name|efx_mcdi_init
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|,
name|__in
specifier|const
name|efx_mcdi_transport_t
modifier|*
name|mtp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|efx_oword_t
name|oword
decl_stmt|;
name|unsigned
name|int
name|portnum
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator||=
name|EFX_MOD_MCDI
expr_stmt|;
if|if
condition|(
name|enp
operator|->
name|en_family
operator|==
name|EFX_FAMILY_FALCON
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|emip
operator|->
name|emi_mtp
operator|=
name|mtp
expr_stmt|;
comment|/* Determine the port number to use for MCDI */
name|EFX_BAR_READO
argument_list|(
name|enp
argument_list|,
name|FR_AZ_CS_DEBUG_REG
argument_list|,
operator|&
name|oword
argument_list|)
expr_stmt|;
name|portnum
operator|=
name|EFX_OWORD_FIELD
argument_list|(
name|oword
argument_list|,
name|FRF_CZ_CS_PORT_NUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|portnum
operator|==
literal|0
condition|)
block|{
comment|/* Presumably booted from ROM; only MCDI port 1 will work */
name|emip
operator|->
name|emi_port
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|portnum
operator|<=
literal|2
condition|)
block|{
name|emip
operator|->
name|emi_port
operator|=
name|portnum
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* 	 * Wipe the atomic reboot status so subsequent MCDI requests succeed. 	 * BOOT_STATUS is preserved so eno_nic_probe() can boot out of the 	 * assertion handler. 	 */
operator|(
name|void
operator|)
name|efx_mcdi_poll_reboot
argument_list|(
name|enp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator|&=
operator|~
name|EFX_MOD_MCDI
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|int
name|efx_mcdi_reboot
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|MC_CMD_REBOOT_IN_LEN
index|]
decl_stmt|;
name|efx_mcdi_req_t
name|req
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* 	 * We could require the caller to have caused en_mod_flags=0 to 	 * call this function. This doesn't help the other port though, 	 * who's about to get the MC ripped out from underneath them. 	 * Since they have to cope with the subsequent fallout of MCDI 	 * failures, we should as well. 	 */
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_magic
argument_list|,
operator|==
argument_list|,
name|EFX_NIC_MAGIC
argument_list|)
expr_stmt|;
name|req
operator|.
name|emr_cmd
operator|=
name|MC_CMD_REBOOT
expr_stmt|;
name|req
operator|.
name|emr_in_buf
operator|=
name|payload
expr_stmt|;
name|req
operator|.
name|emr_in_length
operator|=
name|MC_CMD_REBOOT_IN_LEN
expr_stmt|;
name|req
operator|.
name|emr_out_buf
operator|=
name|NULL
expr_stmt|;
name|req
operator|.
name|emr_out_length
operator|=
literal|0
expr_stmt|;
name|MCDI_IN_SET_DWORD
argument_list|(
name|req
argument_list|,
name|REBOOT_IN_FLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|efx_mcdi_execute
argument_list|(
name|enp
argument_list|,
operator|&
name|req
argument_list|)
expr_stmt|;
comment|/* Invert EIO */
if|if
condition|(
name|req
operator|.
name|emr_rc
operator|!=
name|EIO
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail1
label|:
name|EFSYS_PROBE1
argument_list|(
name|fail1
argument_list|,
name|int
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|__checkReturn
name|boolean_t
name|efx_mcdi_request_abort
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|efx_mcdi_req_t
modifier|*
name|emrp
decl_stmt|;
name|boolean_t
name|aborted
decl_stmt|;
name|int
name|state
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_family
argument_list|,
operator|==
argument_list|,
name|EFX_FAMILY_SIENA
argument_list|)
expr_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_features
argument_list|,
operator|&
argument_list|,
name|EFX_FEATURE_MCDI
argument_list|)
expr_stmt|;
comment|/* 	 * efx_mcdi_ev_* may have already completed this event, and be 	 * spinning/blocked on the upper layer lock. So it *is* legitimate 	 * to for emi_pending_req to be NULL. If there is a pending event 	 * completed request, then provide a "credit" to allow 	 * efx_mcdi_ev_cpl() to accept a single spurious completion. 	 */
name|EFSYS_LOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|emrp
operator|=
name|emip
operator|->
name|emi_pending_req
expr_stmt|;
name|aborted
operator|=
operator|(
name|emrp
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|aborted
condition|)
block|{
name|emip
operator|->
name|emi_pending_req
operator|=
name|NULL
expr_stmt|;
comment|/* Error the request */
name|emrp
operator|->
name|emr_out_length_used
operator|=
literal|0
expr_stmt|;
name|emrp
operator|->
name|emr_rc
operator|=
name|ETIMEDOUT
expr_stmt|;
comment|/* Provide a credit for seqno/emr_pending_req mismatches */
if|if
condition|(
name|emip
operator|->
name|emi_ev_cpl
condition|)
operator|++
name|emip
operator|->
name|emi_aborted
expr_stmt|;
comment|/* 		 * The upper layer has called us, so we don't 		 * need to complete the request. 		 */
block|}
name|EFSYS_UNLOCK
argument_list|(
name|enp
operator|->
name|en_eslp
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|aborted
operator|)
return|;
block|}
end_function

begin_function
name|void
name|efx_mcdi_fini
parameter_list|(
name|__in
name|efx_nic_t
modifier|*
name|enp
parameter_list|)
block|{
name|efx_mcdi_iface_t
modifier|*
name|emip
init|=
operator|&
operator|(
name|enp
operator|->
name|en_u
operator|.
name|siena
operator|.
name|enu_mip
operator|)
decl_stmt|;
name|EFSYS_ASSERT3U
argument_list|(
name|enp
operator|->
name|en_mod_flags
argument_list|,
operator|==
argument_list|,
name|EFX_MOD_MCDI
argument_list|)
expr_stmt|;
name|enp
operator|->
name|en_mod_flags
operator|&=
operator|~
name|EFX_MOD_MCDI
expr_stmt|;
if|if
condition|(
operator|~
operator|(
name|enp
operator|->
name|en_features
operator|)
operator|&
name|EFX_FEATURE_MCDI
condition|)
return|return;
name|emip
operator|->
name|emi_mtp
operator|=
name|NULL
expr_stmt|;
name|emip
operator|->
name|emi_port
operator|=
literal|0
expr_stmt|;
name|emip
operator|->
name|emi_aborted
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFSYS_OPT_MCDI */
end_comment

end_unit

